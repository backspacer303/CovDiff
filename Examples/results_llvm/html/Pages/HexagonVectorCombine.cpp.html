<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>HexagonVectorCombine.cpp</title>
    <link rel="stylesheet" href="../Style/style.css" />
  </head>
  <body>
    <div class="headerDiv">
      <h1>
        Code Coverage
      </h1>
      <p>
        Source file: /home/nikola/Desktop/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
      </p>
    </div>
    <button class="collapsible" type="button">Open Summary Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Summary Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line number</th>
    <th class="mainTh">Line</th>
    <th class="mainTh">Number of hits</th>
    <th class="mainTh">Tests that cover line</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="">//===-- HexagonVectorCombine.cpp ------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="">// HexagonVectorCombine is a utility class implementing a variety of functions</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="">// that assist in vector-based optimizations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="">// AlignVectors: replace unaligned vector loads and stores with aligned ones.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="">// HvxIdioms: recognize various opportunities to generate HVX intrinsic code.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="">#include "llvm/ADT/APInt.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="">#include "llvm/ADT/ArrayRef.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="">#include "llvm/ADT/DenseMap.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="">#include "llvm/ADT/STLExtras.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="">#include "llvm/ADT/SmallVector.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="">#include "llvm/Analysis/AliasAnalysis.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="">#include "llvm/Analysis/AssumptionCache.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="">#include "llvm/Analysis/InstSimplifyFolder.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="">#include "llvm/Analysis/InstructionSimplify.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="">#include "llvm/Analysis/ScalarEvolution.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="">#include "llvm/Analysis/TargetLibraryInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="">#include "llvm/Analysis/ValueTracking.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="">#include "llvm/Analysis/VectorUtils.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="">#include "llvm/CodeGen/TargetPassConfig.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="">#include "llvm/CodeGen/ValueTypes.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="">#include "llvm/IR/Dominators.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="">#include "llvm/IR/IRBuilder.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="">#include "llvm/IR/IntrinsicInst.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="">#include "llvm/IR/Intrinsics.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="">#include "llvm/IR/IntrinsicsHexagon.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="">#include "llvm/IR/Metadata.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="">#include "llvm/IR/PatternMatch.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="">#include "llvm/InitializePasses.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="">#include "llvm/Pass.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="">#include "llvm/Support/CommandLine.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="">#include "llvm/Support/KnownBits.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="">#include "llvm/Support/MathExtras.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="">#include "llvm/Support/raw_ostream.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="">#include "llvm/Target/TargetMachine.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="">#include "llvm/Transforms/Utils/Local.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="">#include "HexagonSubtarget.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="">#include "HexagonTargetMachine.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="">#include <algorithm></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="">#include <deque></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="">#include <map></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="">#include <optional></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="">#include <set></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="">#include <utility></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="">#include <vector></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="">#define DEBUG_TYPE "hexagon-vc"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="">using namespace llvm;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="">namespace {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="">cl::opt<bool> DumpModule("hvc-dump-module", cl::Hidden);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="">cl::opt<bool> VAEnabled("hvc-va", cl::Hidden, cl::init(true)); // Align</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="">cl::opt<bool> VIEnabled("hvc-vi", cl::Hidden, cl::init(true)); // Idioms</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="">cl::opt<bool> VADoFullStores("hvc-va-full-stores", cl::Hidden);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="">cl::opt<unsigned> VAGroupCountLimit("hvc-va-group-count-limit", cl::Hidden,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="">                                    cl::init(~0));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="">cl::opt<unsigned> VAGroupSizeLimit("hvc-va-group-size-limit", cl::Hidden,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="">                                   cl::init(~0));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="">class HexagonVectorCombine {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="uncoveredLine">  HexagonVectorCombine(Function &F_, AliasAnalysis &AA_, AssumptionCache &AC_,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="">                       DominatorTree &DT_, ScalarEvolution &SE_,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="">                       TargetLibraryInfo &TLI_, const TargetMachine &TM_)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="uncoveredLine">      : F(F_), DL(F.getParent()->getDataLayout()), AA(AA_), AC(AC_), DT(DT_),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="uncoveredLine">        SE(SE_), TLI(TLI_),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="uncoveredLine">        HST(static_cast<const HexagonSubtarget &>(*TM_.getSubtargetImpl(F))) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="">  bool run();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="">  // Common integer type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="">  IntegerType *getIntTy(unsigned Width = 32) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="">  // Byte type: either scalar (when Length = 0), or vector with given</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="">  // element count.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="">  Type *getByteTy(int ElemCount = 0) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="">  // Boolean type: either scalar (when Length = 0), or vector with given</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="">  // element count.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="">  Type *getBoolTy(int ElemCount = 0) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="">  // Create a ConstantInt of type returned by getIntTy with the value Val.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="">  ConstantInt *getConstInt(int Val, unsigned Width = 32) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="">  // Get the integer value of V, if it exists.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="">  std::optional<APInt> getIntValue(const Value *Val) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="">  // Is Val a constant 0, or a vector of 0s?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="">  bool isZero(const Value *Val) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="">  // Is Val an undef value?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="">  bool isUndef(const Value *Val) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="">  // Is Val a scalar (i1 true) or a vector of (i1 true)?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="">  bool isTrue(const Value *Val) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="">  // Is Val a scalar (i1 false) or a vector of (i1 false)?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="">  bool isFalse(const Value *Val) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="">  // Get HVX vector type with the given element type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="">  VectorType *getHvxTy(Type *ElemTy, bool Pair = false) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="">  enum SizeKind {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="">    Store, // Store size</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="">    Alloc, // Alloc size</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="">  int getSizeOf(const Value *Val, SizeKind Kind = Store) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="">  int getSizeOf(const Type *Ty, SizeKind Kind = Store) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="">  int getTypeAlignment(Type *Ty) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="">  size_t length(Value *Val) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="">  size_t length(Type *Ty) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="">  Constant *getNullValue(Type *Ty) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="">  Constant *getFullValue(Type *Ty) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="">  Constant *getConstSplat(Type *Ty, int Val) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="">  Value *simplify(Value *Val) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="">  Value *insertb(IRBuilderBase &Builder, Value *Dest, Value *Src, int Start,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="">                 int Length, int Where) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="">  Value *vlalignb(IRBuilderBase &Builder, Value *Lo, Value *Hi,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="">                  Value *Amt) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="">  Value *vralignb(IRBuilderBase &Builder, Value *Lo, Value *Hi,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="">                  Value *Amt) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="">  Value *concat(IRBuilderBase &Builder, ArrayRef<Value *> Vecs) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="">  Value *vresize(IRBuilderBase &Builder, Value *Val, int NewSize,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="">                 Value *Pad) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="">  Value *rescale(IRBuilderBase &Builder, Value *Mask, Type *FromTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="">                 Type *ToTy) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="">  Value *vlsb(IRBuilderBase &Builder, Value *Val) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="">  Value *vbytes(IRBuilderBase &Builder, Value *Val) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="">  Value *subvector(IRBuilderBase &Builder, Value *Val, unsigned Start,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="">                   unsigned Length) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="">  Value *sublo(IRBuilderBase &Builder, Value *Val) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="">  Value *subhi(IRBuilderBase &Builder, Value *Val) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="">  Value *vdeal(IRBuilderBase &Builder, Value *Val0, Value *Val1) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="">  Value *vshuff(IRBuilderBase &Builder, Value *Val0, Value *Val1) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="">  Value *createHvxIntrinsic(IRBuilderBase &Builder, Intrinsic::ID IntID,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="">                            Type *RetTy, ArrayRef<Value *> Args,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="">                            ArrayRef<Type *> ArgTys = std::nullopt,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="">                            ArrayRef<Value *> MDSources = std::nullopt) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="">  SmallVector<Value *> splitVectorElements(IRBuilderBase &Builder, Value *Vec,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="">                                           unsigned ToWidth) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="">  Value *joinVectorElements(IRBuilderBase &Builder, ArrayRef<Value *> Values,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="">                            VectorType *ToType) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="">  std::optional<int> calculatePointerDifference(Value *Ptr0, Value *Ptr1) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="">  unsigned getNumSignificantBits(const Value *V,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="">                                 const Instruction *CtxI = nullptr) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="">  KnownBits getKnownBits(const Value *V,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="">                         const Instruction *CtxI = nullptr) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="">  bool isSafeToClone(const Instruction &In) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="">  template <typename T = std::vector<Instruction *>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="">  bool isSafeToMoveBeforeInBB(const Instruction &In,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="">                              BasicBlock::const_iterator To,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="">                              const T &IgnoreInsts = {}) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="">  // This function is only used for assertions at the moment.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="">  [[maybe_unused]] bool isByteVecTy(Type *Ty) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="">  Function &F;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="">  const DataLayout &DL;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="">  AliasAnalysis &AA;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="">  AssumptionCache &AC;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="">  DominatorTree &DT;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="">  ScalarEvolution &SE;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="">  TargetLibraryInfo &TLI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="">  const HexagonSubtarget &HST;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="">  Value *getElementRange(IRBuilderBase &Builder, Value *Lo, Value *Hi,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="">                         int Start, int Length) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="">class AlignVectors {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="">  // This code tries to replace unaligned vector loads/stores with aligned</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="">  // ones.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="">  // Consider unaligned load:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="">  //   %v = original_load %some_addr, align <bad></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="">  //   %user = %v</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="">  // It will generate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="">  //      = load ..., align <good></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="">  //      = load ..., align <good></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="">  //      = valign</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="">  //      etc.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="">  //   %synthesize = combine/shuffle the loaded data so that it looks</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="">  //                 exactly like what "original_load" has loaded.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="">  //   %user = %synthesize</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="">  // Similarly for stores.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="uncoveredLine">  AlignVectors(const HexagonVectorCombine &HVC_) : HVC(HVC_) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="">  bool run();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="">  using InstList = std::vector<Instruction *>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="">  using InstMap = DenseMap<Instruction *, Instruction *>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="">  struct AddrInfo {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="">    AddrInfo(const AddrInfo &) = default;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="uncoveredLine">    AddrInfo(const HexagonVectorCombine &HVC, Instruction *I, Value *A, Type *T,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="">             Align H)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="uncoveredLine">        : Inst(I), Addr(A), ValTy(T), HaveAlign(H),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="uncoveredLine">          NeedAlign(HVC.getTypeAlignment(ValTy)) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="">    AddrInfo &operator=(const AddrInfo &) = default;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="">    // XXX: add Size member?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="">    Instruction *Inst;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="">    Value *Addr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="">    Type *ValTy;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="">    Align HaveAlign;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="">    Align NeedAlign;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="">    int Offset = 0; // Offset (in bytes) from the first member of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="">                    // containing AddrList.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="">  using AddrList = std::vector<AddrInfo>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="">  struct InstrLess {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="uncoveredLine">    bool operator()(const Instruction *A, const Instruction *B) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="uncoveredLine">      return A->comesBefore(B);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="">  using DepList = std::set<Instruction *, InstrLess>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="">  struct MoveGroup {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="uncoveredLine">    MoveGroup(const AddrInfo &AI, Instruction *B, bool Hvx, bool Load)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="uncoveredLine">        : Base(B), Main{AI.Inst}, Clones{}, IsHvx(Hvx), IsLoad(Load) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="uncoveredLine">    MoveGroup() = default;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="">    Instruction *Base; // Base instruction of the parent address group.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="">    InstList Main;     // Main group of instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="">    InstList Deps;     // List of dependencies.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="">    InstMap Clones;    // Map from original Deps to cloned ones.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="">    bool IsHvx;        // Is this group of HVX instructions?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="">    bool IsLoad;       // Is this a load group?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="">  using MoveList = std::vector<MoveGroup>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="">  struct ByteSpan {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="">    // A representation of "interesting" bytes within a given span of memory.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="">    // These bytes are those that are loaded or stored, and they don't have</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="">    // to cover the entire span of memory.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="">    // The representation works by picking a contiguous sequence of bytes</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="">    // from somewhere within a llvm::Value, and placing it at a given offset</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="">    // within the span.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="">    // The sequence of bytes from llvm:Value is represented by Segment.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="">    // Block is Segment, plus where it goes in the span.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="">    // An important feature of ByteSpan is being able to make a "section",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="">    // i.e. creating another ByteSpan corresponding to a range of offsets</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="">    // relative to the source span.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="">    struct Segment {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="">      // Segment of a Value: 'Len' bytes starting at byte 'Begin'.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="uncoveredLine">      Segment(Value *Val, int Begin, int Len)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="uncoveredLine">          : Val(Val), Start(Begin), Size(Len) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="">      Segment(const Segment &Seg) = default;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="">      Segment &operator=(const Segment &Seg) = default;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="">      Value *Val; // Value representable as a sequence of bytes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="">      int Start;  // First byte of the value that belongs to the segment.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="">      int Size;   // Number of bytes in the segment.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="">    };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="">    struct Block {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="uncoveredLine">      Block(Value *Val, int Len, int Pos) : Seg(Val, 0, Len), Pos(Pos) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="uncoveredLine">      Block(Value *Val, int Off, int Len, int Pos)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="uncoveredLine">          : Seg(Val, Off, Len), Pos(Pos) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="">      Block(const Block &Blk) = default;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="">      Block &operator=(const Block &Blk) = default;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="">      Segment Seg; // Value segment.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="">      int Pos;     // Position (offset) of the block in the span.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="">    };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="">    int extent() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="">    ByteSpan section(int Start, int Length) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="">    ByteSpan &shift(int Offset);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="">    SmallVector<Value *, 8> values() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="uncoveredLine">    int size() const { return Blocks.size(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="uncoveredLine">    Block &operator[](int i) { return Blocks[i]; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="uncoveredLine">    const Block &operator[](int i) const { return Blocks[i]; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="">    std::vector<Block> Blocks;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="">    using iterator = decltype(Blocks)::iterator;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="uncoveredLine">    iterator begin() { return Blocks.begin(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="uncoveredLine">    iterator end() { return Blocks.end(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="">    using const_iterator = decltype(Blocks)::const_iterator;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="uncoveredLine">    const_iterator begin() const { return Blocks.begin(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="uncoveredLine">    const_iterator end() const { return Blocks.end(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="">  Align getAlignFromValue(const Value *V) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="">  std::optional<AddrInfo> getAddrInfo(Instruction &In) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="">  bool isHvx(const AddrInfo &AI) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="">  // This function is only used for assertions at the moment.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="">  [[maybe_unused]] bool isSectorTy(Type *Ty) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="">  Value *getPayload(Value *Val) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="">  Value *getMask(Value *Val) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="">  Value *getPassThrough(Value *Val) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="">  Value *createAdjustedPointer(IRBuilderBase &Builder, Value *Ptr, Type *ValTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="">                               int Adjust,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="">                               const InstMap &CloneMap = InstMap()) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="">  Value *createAlignedPointer(IRBuilderBase &Builder, Value *Ptr, Type *ValTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="">                              int Alignment,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="">                              const InstMap &CloneMap = InstMap()) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="">  Value *createLoad(IRBuilderBase &Builder, Type *ValTy, Value *Ptr,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="">                    Value *Predicate, int Alignment, Value *Mask,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="">                    Value *PassThru,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="">                    ArrayRef<Value *> MDSources = std::nullopt) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="">  Value *createSimpleLoad(IRBuilderBase &Builder, Type *ValTy, Value *Ptr,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="">                          int Alignment,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="">                          ArrayRef<Value *> MDSources = std::nullopt) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="">  Value *createStore(IRBuilderBase &Builder, Value *Val, Value *Ptr,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="">                     Value *Predicate, int Alignment, Value *Mask,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="">                     ArrayRef<Value *> MDSources = std ::nullopt) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="">  Value *createSimpleStore(IRBuilderBase &Builder, Value *Val, Value *Ptr,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="">                           int Alignment,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="">                           ArrayRef<Value *> MDSources = std ::nullopt) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="">  Value *createPredicatedLoad(IRBuilderBase &Builder, Type *ValTy, Value *Ptr,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="">                              Value *Predicate, int Alignment,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="">                              ArrayRef<Value *> MDSources = std::nullopt) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="">  Value *</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="">  createPredicatedStore(IRBuilderBase &Builder, Value *Val, Value *Ptr,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="">                        Value *Predicate, int Alignment,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="">                        ArrayRef<Value *> MDSources = std::nullopt) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="">  DepList getUpwardDeps(Instruction *In, Instruction *Base) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="">  bool createAddressGroups();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="">  MoveList createLoadGroups(const AddrList &Group) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="">  MoveList createStoreGroups(const AddrList &Group) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="">  bool moveTogether(MoveGroup &Move) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="">  template <typename T> InstMap cloneBefore(Instruction *To, T &&Insts) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="">  void realignLoadGroup(IRBuilderBase &Builder, const ByteSpan &VSpan,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="">                        int ScLen, Value *AlignVal, Value *AlignAddr) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="">  void realignStoreGroup(IRBuilderBase &Builder, const ByteSpan &VSpan,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="">                         int ScLen, Value *AlignVal, Value *AlignAddr) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="">  bool realignGroup(const MoveGroup &Move) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="">  Value *makeTestIfUnaligned(IRBuilderBase &Builder, Value *AlignVal,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="">                             int Alignment) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="">  friend raw_ostream &operator<<(raw_ostream &OS, const AddrInfo &AI);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="">  friend raw_ostream &operator<<(raw_ostream &OS, const MoveGroup &MG);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="">  friend raw_ostream &operator<<(raw_ostream &OS, const ByteSpan::Block &B);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="">  friend raw_ostream &operator<<(raw_ostream &OS, const ByteSpan &BS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="">  std::map<Instruction *, AddrList> AddrGroups;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="">  const HexagonVectorCombine &HVC;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="">LLVM_ATTRIBUTE_UNUSED</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="uncoveredLine">raw_ostream &operator<<(raw_ostream &OS, const AlignVectors::AddrInfo &AI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="uncoveredLine">  OS << "Inst: " << AI.Inst << "  " << *AI.Inst << '\n';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="uncoveredLine">  OS << "Addr: " << *AI.Addr << '\n';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="uncoveredLine">  OS << "Type: " << *AI.ValTy << '\n';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="uncoveredLine">  OS << "HaveAlign: " << AI.HaveAlign.value() << '\n';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="uncoveredLine">  OS << "NeedAlign: " << AI.NeedAlign.value() << '\n';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="uncoveredLine">  OS << "Offset: " << AI.Offset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="uncoveredLine">  return OS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="">LLVM_ATTRIBUTE_UNUSED</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="uncoveredLine">raw_ostream &operator<<(raw_ostream &OS, const AlignVectors::MoveGroup &MG) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="uncoveredLine">  OS << "IsLoad:" << (MG.IsLoad ? "yes" : "no");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="uncoveredLine">  OS << ", IsHvx:" << (MG.IsHvx ? "yes" : "no") << '\n';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="uncoveredLine">  OS << "Main\n";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="uncoveredLine">  for (Instruction *I : MG.Main)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="uncoveredLine">    OS << "  " << *I << '\n';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="uncoveredLine">  OS << "Deps\n";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="uncoveredLine">  for (Instruction *I : MG.Deps)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="uncoveredLine">    OS << "  " << *I << '\n';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="uncoveredLine">  OS << "Clones\n";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="uncoveredLine">  for (auto [K, V] : MG.Clones) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="uncoveredLine">    OS << "    ";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="uncoveredLine">    K->printAsOperand(OS, false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="uncoveredLine">    OS << "\t-> " << *V << '\n';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="uncoveredLine">  return OS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="">LLVM_ATTRIBUTE_UNUSED</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="uncoveredLine">raw_ostream &operator<<(raw_ostream &OS,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="">                        const AlignVectors::ByteSpan::Block &B) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="uncoveredLine">  OS << "  @" << B.Pos << " [" << B.Seg.Start << ',' << B.Seg.Size << "] ";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="uncoveredLine">  if (B.Seg.Val == reinterpret_cast<const Value *>(&B)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="uncoveredLine">    OS << "(self:" << B.Seg.Val << ')';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="uncoveredLine">  } else if (B.Seg.Val != nullptr) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="uncoveredLine">    OS << *B.Seg.Val;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="uncoveredLine">    OS << "(null)";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="uncoveredLine">  return OS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="">LLVM_ATTRIBUTE_UNUSED</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="uncoveredLine">raw_ostream &operator<<(raw_ostream &OS, const AlignVectors::ByteSpan &BS) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="uncoveredLine">  OS << "ByteSpan[size=" << BS.size() << ", extent=" << BS.extent() << '\n';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="uncoveredLine">  for (const AlignVectors::ByteSpan::Block &B : BS)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="uncoveredLine">    OS << B << '\n';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="uncoveredLine">  OS << ']';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="uncoveredLine">  return OS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="">class HvxIdioms {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="uncoveredLine">  HvxIdioms(const HexagonVectorCombine &HVC_) : HVC(HVC_) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="uncoveredLine">    auto *Int32Ty = HVC.getIntTy(32);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="uncoveredLine">    HvxI32Ty = HVC.getHvxTy(Int32Ty, /*Pair=*/false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="uncoveredLine">    HvxP32Ty = HVC.getHvxTy(Int32Ty, /*Pair=*/true);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="">  bool run();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="">  enum Signedness { Positive, Signed, Unsigned };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="">  // Value + sign</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="">  // This is to keep track of whether the value should be treated as signed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="">  // or unsigned, or is known to be positive.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="">  struct SValue {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="">    Value *Val;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="">    Signedness Sgn;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="">  struct FxpOp {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="">    unsigned Opcode;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="">    unsigned Frac; // Number of fraction bits</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="">    SValue X, Y;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="">    // If present, add 1 << RoundAt before shift:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="">    std::optional<unsigned> RoundAt;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="">    VectorType *ResTy;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="">  auto getNumSignificantBits(Value *V, Instruction *In) const</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="">      -> std::pair<unsigned, Signedness>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="">  auto canonSgn(SValue X, SValue Y) const -> std::pair<SValue, SValue>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="">  auto matchFxpMul(Instruction &In) const -> std::optional<FxpOp>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="">  auto processFxpMul(Instruction &In, const FxpOp &Op) const -> Value *;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="">  auto processFxpMulChopped(IRBuilderBase &Builder, Instruction &In,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="">                            const FxpOp &Op) const -> Value *;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="">  auto createMulQ15(IRBuilderBase &Builder, SValue X, SValue Y,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="">                    bool Rounding) const -> Value *;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="">  auto createMulQ31(IRBuilderBase &Builder, SValue X, SValue Y,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="">                    bool Rounding) const -> Value *;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="">  // Return {Result, Carry}, where Carry is a vector predicate.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="">  auto createAddCarry(IRBuilderBase &Builder, Value *X, Value *Y,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="">                      Value *CarryIn = nullptr) const</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="">      -> std::pair<Value *, Value *>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="">  auto createMul16(IRBuilderBase &Builder, SValue X, SValue Y) const -> Value *;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="">  auto createMulH16(IRBuilderBase &Builder, SValue X, SValue Y) const</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="">      -> Value *;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="">  auto createMul32(IRBuilderBase &Builder, SValue X, SValue Y) const</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="">      -> std::pair<Value *, Value *>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="">  auto createAddLong(IRBuilderBase &Builder, ArrayRef<Value *> WordX,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="">                     ArrayRef<Value *> WordY) const -> SmallVector<Value *>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="">  auto createMulLong(IRBuilderBase &Builder, ArrayRef<Value *> WordX,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="">                     Signedness SgnX, ArrayRef<Value *> WordY,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="">                     Signedness SgnY) const -> SmallVector<Value *>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="">  VectorType *HvxI32Ty;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="">  VectorType *HvxP32Ty;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="">  const HexagonVectorCombine &HVC;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="">  friend raw_ostream &operator<<(raw_ostream &, const FxpOp &);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="uncoveredLine">[[maybe_unused]] raw_ostream &operator<<(raw_ostream &OS,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="">                                         const HvxIdioms::FxpOp &Op) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="">  static const char *SgnNames[] = {"Positive", "Signed", "Unsigned"};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="uncoveredLine">  OS << Instruction::getOpcodeName(Op.Opcode) << '.' << Op.Frac;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="uncoveredLine">  if (Op.RoundAt.has_value()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="uncoveredLine">    if (Op.Frac != 0 && *Op.RoundAt == Op.Frac - 1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="uncoveredLine">      OS << ":rnd";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="uncoveredLine">      OS << " + 1<<" << *Op.RoundAt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="uncoveredLine">  OS << "\n  X:(" << SgnNames[Op.X.Sgn] << ") " << *Op.X.Val << "\n"</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="uncoveredLine">     << "  Y:(" << SgnNames[Op.Y.Sgn] << ") " << *Op.Y.Val;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="uncoveredLine">  return OS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="">} // namespace</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="">namespace {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="uncoveredLine">template <typename T> T *getIfUnordered(T *MaybeT) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="uncoveredLine">  return MaybeT && MaybeT->isUnordered() ? MaybeT : nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="uncoveredLine">template <typename T> T *isCandidate(Instruction *In) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="uncoveredLine">  return dyn_cast<T>(In);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="uncoveredLine">template <> LoadInst *isCandidate<LoadInst>(Instruction *In) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="uncoveredLine">  return getIfUnordered(dyn_cast<LoadInst>(In));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="uncoveredLine">template <> StoreInst *isCandidate<StoreInst>(Instruction *In) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="uncoveredLine">  return getIfUnordered(dyn_cast<StoreInst>(In));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="">#if !defined(_MSC_VER) || _MSC_VER >= 1926</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="">// VS2017 and some versions of VS2019 have trouble compiling this:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="">// error C2976: 'std::map': too few template arguments</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="">// VS 2019 16.x is known to work, except for 16.4/16.5 (MSC_VER 1924/1925)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="">template <typename Pred, typename... Ts></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="uncoveredLine">void erase_if(std::map<Ts...> &map, Pred p)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="">#else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="">template <typename Pred, typename T, typename U></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="">void erase_if(std::map<T, U> &map, Pred p)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="">{</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="uncoveredLine">  for (auto i = map.begin(), e = map.end(); i != e;) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="uncoveredLine">    if (p(*i))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="uncoveredLine">      i = map.erase(i);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="uncoveredLine">      i = std::next(i);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="">// Forward other erase_ifs to the LLVM implementations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="uncoveredLine">template <typename Pred, typename T> void erase_if(T &&container, Pred p) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="uncoveredLine">  llvm::erase_if(std::forward<T>(container), p);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="">} // namespace</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="">// --- Begin AlignVectors</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="">// For brevity, only consider loads. We identify a group of loads where we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="">// know the relative differences between their addresses, so we know how they</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="">// are laid out in memory (relative to one another). These loads can overlap,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="">// can be shorter or longer than the desired vector length.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="">// Ultimately we want to generate a sequence of aligned loads that will load</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="">// every byte that the original loads loaded, and have the program use these</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="">// loaded values instead of the original loads.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="">// We consider the contiguous memory area spanned by all these loads.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="">// Let's say that a single aligned vector load can load 16 bytes at a time.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="">// If the program wanted to use a byte at offset 13 from the beginning of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="">// original span, it will be a byte at offset 13+x in the aligned data for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="">// some x>=0. This may happen to be in the first aligned load, or in the load</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="">// following it. Since we generally don't know what the that alignment value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="">// is at compile time, we proactively do valigns on the aligned loads, so that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="">// byte that was at offset 13 is still at offset 13 after the valigns.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="">// This will be the starting point for making the rest of the program use the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="">// data loaded by the new loads.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="">// For each original load, and its users:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="">//   %v = load ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="">//   ... = %v</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="">//   ... = %v</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="">// we create</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="">//   %new_v = extract/combine/shuffle data from loaded/valigned vectors so</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="">//            it contains the same value as %v did before</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="">// then replace all users of %v with %new_v.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="">//   ... = %new_v</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="">//   ... = %new_v</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="uncoveredLine">auto AlignVectors::ByteSpan::extent() const -> int {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="uncoveredLine">  if (size() == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="uncoveredLine">    return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="uncoveredLine">  int Min = Blocks[0].Pos;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="uncoveredLine">  int Max = Blocks[0].Pos + Blocks[0].Seg.Size;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="uncoveredLine">  for (int i = 1, e = size(); i != e; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="uncoveredLine">    Min = std::min(Min, Blocks[i].Pos);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="uncoveredLine">    Max = std::max(Max, Blocks[i].Pos + Blocks[i].Seg.Size);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="uncoveredLine">  return Max - Min;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="uncoveredLine">auto AlignVectors::ByteSpan::section(int Start, int Length) const -> ByteSpan {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="uncoveredLine">  ByteSpan Section;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="uncoveredLine">  for (const ByteSpan::Block &B : Blocks) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="uncoveredLine">    int L = std::max(B.Pos, Start);                       // Left end.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="uncoveredLine">    int R = std::min(B.Pos + B.Seg.Size, Start + Length); // Right end+1.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="uncoveredLine">    if (L < R) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="">      // How much to chop off the beginning of the segment:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="uncoveredLine">      int Off = L > B.Pos ? L - B.Pos : 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="uncoveredLine">      Section.Blocks.emplace_back(B.Seg.Val, B.Seg.Start + Off, R - L, L);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="uncoveredLine">  return Section;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="uncoveredLine">auto AlignVectors::ByteSpan::shift(int Offset) -> ByteSpan & {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="uncoveredLine">  for (Block &B : Blocks)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="uncoveredLine">    B.Pos += Offset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="uncoveredLine">  return *this;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="uncoveredLine">auto AlignVectors::ByteSpan::values() const -> SmallVector<Value *, 8> {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="uncoveredLine">  SmallVector<Value *, 8> Values(Blocks.size());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="uncoveredLine">  for (int i = 0, e = Blocks.size(); i != e; ++i)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="uncoveredLine">    Values[i] = Blocks[i].Seg.Val;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="uncoveredLine">  return Values;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="uncoveredLine">auto AlignVectors::getAlignFromValue(const Value *V) const -> Align {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="uncoveredLine">  const auto *C = dyn_cast<ConstantInt>(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="uncoveredLine">  assert(C && "Alignment must be a compile-time constant integer");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="uncoveredLine">  return C->getAlignValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="uncoveredLine">auto AlignVectors::getAddrInfo(Instruction &In) const</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="">    -> std::optional<AddrInfo> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="uncoveredLine">  if (auto *L = isCandidate<LoadInst>(&In))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="uncoveredLine">    return AddrInfo(HVC, L, L->getPointerOperand(), L->getType(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="uncoveredLine">                    L->getAlign());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="uncoveredLine">  if (auto *S = isCandidate<StoreInst>(&In))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="uncoveredLine">    return AddrInfo(HVC, S, S->getPointerOperand(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="uncoveredLine">                    S->getValueOperand()->getType(), S->getAlign());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="uncoveredLine">  if (auto *II = isCandidate<IntrinsicInst>(&In)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="uncoveredLine">    Intrinsic::ID ID = II->getIntrinsicID();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="uncoveredLine">    switch (ID) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="uncoveredLine">    case Intrinsic::masked_load:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="uncoveredLine">      return AddrInfo(HVC, II, II->getArgOperand(0), II->getType(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="uncoveredLine">                      getAlignFromValue(II->getArgOperand(1)));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="uncoveredLine">    case Intrinsic::masked_store:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="uncoveredLine">      return AddrInfo(HVC, II, II->getArgOperand(1),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="">                      II->getArgOperand(0)->getType(),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="uncoveredLine">                      getAlignFromValue(II->getArgOperand(2)));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="uncoveredLine">  return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="uncoveredLine">auto AlignVectors::isHvx(const AddrInfo &AI) const -> bool {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="uncoveredLine">  return HVC.HST.isTypeForHVX(AI.ValTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="uncoveredLine">auto AlignVectors::getPayload(Value *Val) const -> Value * {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="uncoveredLine">  if (auto *In = dyn_cast<Instruction>(Val)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="uncoveredLine">    Intrinsic::ID ID = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="uncoveredLine">    if (auto *II = dyn_cast<IntrinsicInst>(In))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="uncoveredLine">      ID = II->getIntrinsicID();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="uncoveredLine">    if (isa<StoreInst>(In) || ID == Intrinsic::masked_store)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="uncoveredLine">      return In->getOperand(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="uncoveredLine">  return Val;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="uncoveredLine">auto AlignVectors::getMask(Value *Val) const -> Value * {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="uncoveredLine">  if (auto *II = dyn_cast<IntrinsicInst>(Val)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="uncoveredLine">    switch (II->getIntrinsicID()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="uncoveredLine">    case Intrinsic::masked_load:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="uncoveredLine">      return II->getArgOperand(2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="uncoveredLine">    case Intrinsic::masked_store:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="uncoveredLine">      return II->getArgOperand(3);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="uncoveredLine">  Type *ValTy = getPayload(Val)->getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="uncoveredLine">  if (auto *VecTy = dyn_cast<VectorType>(ValTy))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="uncoveredLine">    return HVC.getFullValue(HVC.getBoolTy(HVC.length(VecTy)));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="uncoveredLine">  return HVC.getFullValue(HVC.getBoolTy());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="uncoveredLine">auto AlignVectors::getPassThrough(Value *Val) const -> Value * {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="uncoveredLine">  if (auto *II = dyn_cast<IntrinsicInst>(Val)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="uncoveredLine">    if (II->getIntrinsicID() == Intrinsic::masked_load)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="uncoveredLine">      return II->getArgOperand(3);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="uncoveredLine">  return UndefValue::get(getPayload(Val)->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="uncoveredLine">auto AlignVectors::createAdjustedPointer(IRBuilderBase &Builder, Value *Ptr,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="">                                         Type *ValTy, int Adjust,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="">                                         const InstMap &CloneMap) const</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="">    -> Value * {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="uncoveredLine">  if (auto *I = dyn_cast<Instruction>(Ptr))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="uncoveredLine">    if (Instruction *New = CloneMap.lookup(I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="uncoveredLine">      Ptr = New;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="uncoveredLine">  return Builder.CreateGEP(Type::getInt8Ty(HVC.F.getContext()), Ptr,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="uncoveredLine">                           HVC.getConstInt(Adjust), "gep");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="uncoveredLine">auto AlignVectors::createAlignedPointer(IRBuilderBase &Builder, Value *Ptr,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="">                                        Type *ValTy, int Alignment,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="">                                        const InstMap &CloneMap) const</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="">    -> Value * {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="uncoveredLine">  auto remap = [&](Value *V) -> Value * {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="uncoveredLine">    if (auto *I = dyn_cast<Instruction>(V)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="uncoveredLine">      for (auto [Old, New] : CloneMap)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="uncoveredLine">        I->replaceUsesOfWith(Old, New);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="uncoveredLine">      return I;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="uncoveredLine">    return V;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="uncoveredLine">  Value *AsInt = Builder.CreatePtrToInt(Ptr, HVC.getIntTy(), "pti");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="uncoveredLine">  Value *Mask = HVC.getConstInt(-Alignment);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="uncoveredLine">  Value *And = Builder.CreateAnd(remap(AsInt), Mask, "and");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="uncoveredLine">  return Builder.CreateIntToPtr(And, ValTy->getPointerTo(), "itp");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="uncoveredLine">auto AlignVectors::createLoad(IRBuilderBase &Builder, Type *ValTy, Value *Ptr,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="">                              Value *Predicate, int Alignment, Value *Mask,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="">                              Value *PassThru,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="">                              ArrayRef<Value *> MDSources) const -> Value * {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="uncoveredLine">  bool HvxHasPredLoad = HVC.HST.useHVXV62Ops();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="">  // Predicate is nullptr if not creating predicated load</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="uncoveredLine">  if (Predicate) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="uncoveredLine">    assert(!Predicate->getType()->isVectorTy() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="">           "Expectning scalar predicate");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="uncoveredLine">    if (HVC.isFalse(Predicate))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="uncoveredLine">      return UndefValue::get(ValTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="uncoveredLine">    if (!HVC.isTrue(Predicate) && HvxHasPredLoad) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="uncoveredLine">      Value *Load = createPredicatedLoad(Builder, ValTy, Ptr, Predicate,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="">                                         Alignment, MDSources);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="uncoveredLine">      return Builder.CreateSelect(Mask, Load, PassThru);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="">    // Predicate == true here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="uncoveredLine">  assert(!HVC.isUndef(Mask)); // Should this be allowed?</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="uncoveredLine">  if (HVC.isZero(Mask))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="uncoveredLine">    return PassThru;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="uncoveredLine">  if (HVC.isTrue(Mask))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="uncoveredLine">    return createSimpleLoad(Builder, ValTy, Ptr, Alignment, MDSources);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="uncoveredLine">  Instruction *Load = Builder.CreateMaskedLoad(ValTy, Ptr, Align(Alignment),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="">                                               Mask, PassThru, "mld");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="uncoveredLine">  propagateMetadata(Load, MDSources);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="uncoveredLine">  return Load;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="uncoveredLine">auto AlignVectors::createSimpleLoad(IRBuilderBase &Builder, Type *ValTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="">                                    Value *Ptr, int Alignment,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="">                                    ArrayRef<Value *> MDSources) const</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="">    -> Value * {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="">  Instruction *Load =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="uncoveredLine">      Builder.CreateAlignedLoad(ValTy, Ptr, Align(Alignment), "ald");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="uncoveredLine">  propagateMetadata(Load, MDSources);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="uncoveredLine">  return Load;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="uncoveredLine">auto AlignVectors::createPredicatedLoad(IRBuilderBase &Builder, Type *ValTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="">                                        Value *Ptr, Value *Predicate,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="">                                        int Alignment,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="">                                        ArrayRef<Value *> MDSources) const</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="">    -> Value * {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="uncoveredLine">  assert(HVC.HST.isTypeForHVX(ValTy) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="">         "Predicates 'scalar' vector loads not yet supported");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="uncoveredLine">  assert(Predicate);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="uncoveredLine">  assert(!Predicate->getType()->isVectorTy() && "Expectning scalar predicate");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="uncoveredLine">  assert(HVC.getSizeOf(ValTy, HVC.Alloc) % Alignment == 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="uncoveredLine">  if (HVC.isFalse(Predicate))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="uncoveredLine">    return UndefValue::get(ValTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="uncoveredLine">  if (HVC.isTrue(Predicate))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="uncoveredLine">    return createSimpleLoad(Builder, ValTy, Ptr, Alignment, MDSources);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="uncoveredLine">  auto V6_vL32b_pred_ai = HVC.HST.getIntrinsicId(Hexagon::V6_vL32b_pred_ai);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="">  // FIXME: This may not put the offset from Ptr into the vmem offset.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="uncoveredLine">  return HVC.createHvxIntrinsic(Builder, V6_vL32b_pred_ai, ValTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="uncoveredLine">                                {Predicate, Ptr, HVC.getConstInt(0)},</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="uncoveredLine">                                std::nullopt, MDSources);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="uncoveredLine">auto AlignVectors::createStore(IRBuilderBase &Builder, Value *Val, Value *Ptr,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="">                               Value *Predicate, int Alignment, Value *Mask,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="">                               ArrayRef<Value *> MDSources) const -> Value * {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="uncoveredLine">  if (HVC.isZero(Mask) || HVC.isUndef(Val) || HVC.isUndef(Mask))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="uncoveredLine">    return UndefValue::get(Val->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="uncoveredLine">  assert(!Predicate || (!Predicate->getType()->isVectorTy() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="">                        "Expectning scalar predicate"));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="uncoveredLine">  if (Predicate) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="uncoveredLine">    if (HVC.isFalse(Predicate))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="uncoveredLine">      return UndefValue::get(Val->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="uncoveredLine">    if (HVC.isTrue(Predicate))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="uncoveredLine">      Predicate = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="">  // Here both Predicate and Mask are true or unknown.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="uncoveredLine">  if (HVC.isTrue(Mask)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="uncoveredLine">    if (Predicate) { // Predicate unknown</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="uncoveredLine">      return createPredicatedStore(Builder, Val, Ptr, Predicate, Alignment,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="uncoveredLine">                                   MDSources);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="">    // Predicate is true:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="uncoveredLine">    return createSimpleStore(Builder, Val, Ptr, Alignment, MDSources);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="">  // Mask is unknown</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="uncoveredLine">  if (!Predicate) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="">    Instruction *Store =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="uncoveredLine">        Builder.CreateMaskedStore(Val, Ptr, Align(Alignment), Mask);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="uncoveredLine">    propagateMetadata(Store, MDSources);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="uncoveredLine">    return Store;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="">  // Both Predicate and Mask are unknown.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="">  // Emulate masked store with predicated-load + mux + predicated-store.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="uncoveredLine">  Value *PredLoad = createPredicatedLoad(Builder, Val->getType(), Ptr,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="">                                         Predicate, Alignment, MDSources);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="uncoveredLine">  Value *Mux = Builder.CreateSelect(Mask, Val, PredLoad);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="uncoveredLine">  return createPredicatedStore(Builder, Mux, Ptr, Predicate, Alignment,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="uncoveredLine">                               MDSources);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="uncoveredLine">auto AlignVectors::createSimpleStore(IRBuilderBase &Builder, Value *Val,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="">                                     Value *Ptr, int Alignment,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="">                                     ArrayRef<Value *> MDSources) const</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="">    -> Value * {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="uncoveredLine">  Instruction *Store = Builder.CreateAlignedStore(Val, Ptr, Align(Alignment));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="uncoveredLine">  propagateMetadata(Store, MDSources);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="uncoveredLine">  return Store;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="uncoveredLine">auto AlignVectors::createPredicatedStore(IRBuilderBase &Builder, Value *Val,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="">                                         Value *Ptr, Value *Predicate,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="">                                         int Alignment,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="">                                         ArrayRef<Value *> MDSources) const</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="">    -> Value * {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="uncoveredLine">  assert(HVC.HST.isTypeForHVX(Val->getType()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="">         "Predicates 'scalar' vector stores not yet supported");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="uncoveredLine">  assert(Predicate);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="uncoveredLine">  if (HVC.isFalse(Predicate))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="uncoveredLine">    return UndefValue::get(Val->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="uncoveredLine">  if (HVC.isTrue(Predicate))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="uncoveredLine">    return createSimpleStore(Builder, Val, Ptr, Alignment, MDSources);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="uncoveredLine">  assert(HVC.getSizeOf(Val, HVC.Alloc) % Alignment == 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="uncoveredLine">  auto V6_vS32b_pred_ai = HVC.HST.getIntrinsicId(Hexagon::V6_vS32b_pred_ai);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="">  // FIXME: This may not put the offset from Ptr into the vmem offset.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="uncoveredLine">  return HVC.createHvxIntrinsic(Builder, V6_vS32b_pred_ai, nullptr,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="uncoveredLine">                                {Predicate, Ptr, HVC.getConstInt(0), Val},</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="uncoveredLine">                                std::nullopt, MDSources);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="uncoveredLine">auto AlignVectors::getUpwardDeps(Instruction *In, Instruction *Base) const</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="">    -> DepList {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="uncoveredLine">  BasicBlock *Parent = Base->getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="uncoveredLine">  assert(In->getParent() == Parent &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="">         "Base and In should be in the same block");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="uncoveredLine">  assert(Base->comesBefore(In) && "Base should come before In");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="uncoveredLine">  DepList Deps;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="uncoveredLine">  std::deque<Instruction *> WorkQ = {In};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="uncoveredLine">  while (!WorkQ.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="uncoveredLine">    Instruction *D = WorkQ.front();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="uncoveredLine">    WorkQ.pop_front();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="uncoveredLine">    if (D != In)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="uncoveredLine">      Deps.insert(D);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="uncoveredLine">    for (Value *Op : D->operands()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="uncoveredLine">      if (auto *I = dyn_cast<Instruction>(Op)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="uncoveredLine">        if (I->getParent() == Parent && Base->comesBefore(I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="uncoveredLine">          WorkQ.push_back(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="uncoveredLine">  return Deps;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="uncoveredLine">auto AlignVectors::createAddressGroups() -> bool {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="">  // An address group created here may contain instructions spanning</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="">  // multiple basic blocks.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="uncoveredLine">  AddrList WorkStack;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="uncoveredLine">  auto findBaseAndOffset = [&](AddrInfo &AI) -> std::pair<Instruction *, int> {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="uncoveredLine">    for (AddrInfo &W : WorkStack) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="uncoveredLine">      if (auto D = HVC.calculatePointerDifference(AI.Addr, W.Addr))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="uncoveredLine">        return std::make_pair(W.Inst, *D);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="uncoveredLine">    return std::make_pair(nullptr, 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="uncoveredLine">  auto traverseBlock = [&](DomTreeNode *DomN, auto Visit) -> void {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="uncoveredLine">    BasicBlock &Block = *DomN->getBlock();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="uncoveredLine">    for (Instruction &I : Block) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="uncoveredLine">      auto AI = this->getAddrInfo(I); // Use this-> for gcc6.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="uncoveredLine">      if (!AI)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="uncoveredLine">      auto F = findBaseAndOffset(*AI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="">      Instruction *GroupInst;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="uncoveredLine">      if (Instruction *BI = F.first) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="uncoveredLine">        AI->Offset = F.second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="uncoveredLine">        GroupInst = BI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="uncoveredLine">        WorkStack.push_back(*AI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="uncoveredLine">        GroupInst = AI->Inst;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="uncoveredLine">      AddrGroups[GroupInst].push_back(*AI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="uncoveredLine">    for (DomTreeNode *C : DomN->children())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="uncoveredLine">      Visit(C, Visit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="uncoveredLine">    while (!WorkStack.empty() && WorkStack.back().Inst->getParent() == &Block)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="uncoveredLine">      WorkStack.pop_back();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="uncoveredLine">  traverseBlock(HVC.DT.getRootNode(), traverseBlock);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="uncoveredLine">  assert(WorkStack.empty());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="">  // AddrGroups are formed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="">  // Remove groups of size 1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="uncoveredLine">  erase_if(AddrGroups, [](auto &G) { return G.second.size() == 1; });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="">  // Remove groups that don't use HVX types.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="uncoveredLine">  erase_if(AddrGroups, [&](auto &G) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="uncoveredLine">    return llvm::none_of(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="uncoveredLine">        G.second, [&](auto &I) { return HVC.HST.isTypeForHVX(I.ValTy); });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="uncoveredLine">  return !AddrGroups.empty();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="uncoveredLine">auto AlignVectors::createLoadGroups(const AddrList &Group) const -> MoveList {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="">  // Form load groups.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="">  // To avoid complications with moving code across basic blocks, only form</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="">  // groups that are contained within a single basic block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="uncoveredLine">  unsigned SizeLimit = VAGroupSizeLimit;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="uncoveredLine">  if (SizeLimit == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="uncoveredLine">    return {};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="uncoveredLine">  auto tryAddTo = [&](const AddrInfo &Info, MoveGroup &Move) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="uncoveredLine">    assert(!Move.Main.empty() && "Move group should have non-empty Main");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="uncoveredLine">    if (Move.Main.size() >= SizeLimit)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="">    // Don't mix HVX and non-HVX instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="uncoveredLine">    if (Move.IsHvx != isHvx(Info))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="">    // Leading instruction in the load group.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="uncoveredLine">    Instruction *Base = Move.Main.front();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="uncoveredLine">    if (Base->getParent() != Info.Inst->getParent())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="">    // Check if it's safe to move the load.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="uncoveredLine">    if (!HVC.isSafeToMoveBeforeInBB(*Info.Inst, Base->getIterator()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="">    // And if it's safe to clone the dependencies.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="uncoveredLine">    auto isSafeToCopyAtBase = [&](const Instruction *I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="uncoveredLine">      return HVC.isSafeToMoveBeforeInBB(*I, Base->getIterator()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="uncoveredLine">             HVC.isSafeToClone(*I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="uncoveredLine">    };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="uncoveredLine">    DepList Deps = getUpwardDeps(Info.Inst, Base);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="uncoveredLine">    if (!llvm::all_of(Deps, isSafeToCopyAtBase))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="uncoveredLine">    Move.Main.push_back(Info.Inst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="uncoveredLine">    llvm::append_range(Move.Deps, Deps);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="uncoveredLine">  MoveList LoadGroups;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="uncoveredLine">  for (const AddrInfo &Info : Group) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="uncoveredLine">    if (!Info.Inst->mayReadFromMemory())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="uncoveredLine">    if (LoadGroups.empty() || !tryAddTo(Info, LoadGroups.back()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="uncoveredLine">      LoadGroups.emplace_back(Info, Group.front().Inst, isHvx(Info), true);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="">  // Erase singleton groups.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="uncoveredLine">  erase_if(LoadGroups, [](const MoveGroup &G) { return G.Main.size() <= 1; });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="">  // Erase HVX groups on targets < HvxV62 (due to lack of predicated loads).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="uncoveredLine">  if (!HVC.HST.useHVXV62Ops())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="uncoveredLine">    erase_if(LoadGroups, [](const MoveGroup &G) { return G.IsHvx; });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="uncoveredLine">  return LoadGroups;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="uncoveredLine">auto AlignVectors::createStoreGroups(const AddrList &Group) const -> MoveList {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="">  // Form store groups.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="">  // To avoid complications with moving code across basic blocks, only form</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="">  // groups that are contained within a single basic block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="uncoveredLine">  unsigned SizeLimit = VAGroupSizeLimit;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="uncoveredLine">  if (SizeLimit == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="uncoveredLine">    return {};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="uncoveredLine">  auto tryAddTo = [&](const AddrInfo &Info, MoveGroup &Move) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="uncoveredLine">    assert(!Move.Main.empty() && "Move group should have non-empty Main");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="uncoveredLine">    if (Move.Main.size() >= SizeLimit)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="">    // For stores with return values we'd have to collect downward depenencies.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="">    // There are no such stores that we handle at the moment, so omit that.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="uncoveredLine">    assert(Info.Inst->getType()->isVoidTy() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="">           "Not handling stores with return values");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="">    // Don't mix HVX and non-HVX instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="uncoveredLine">    if (Move.IsHvx != isHvx(Info))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="">    // For stores we need to be careful whether it's safe to move them.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="">    // Stores that are otherwise safe to move together may not appear safe</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="">    // to move over one another (i.e. isSafeToMoveBefore may return false).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="uncoveredLine">    Instruction *Base = Move.Main.front();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="uncoveredLine">    if (Base->getParent() != Info.Inst->getParent())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="uncoveredLine">    if (!HVC.isSafeToMoveBeforeInBB(*Info.Inst, Base->getIterator(), Move.Main))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="uncoveredLine">    Move.Main.push_back(Info.Inst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="uncoveredLine">  MoveList StoreGroups;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="uncoveredLine">  for (auto I = Group.rbegin(), E = Group.rend(); I != E; ++I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="uncoveredLine">    const AddrInfo &Info = *I;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="uncoveredLine">    if (!Info.Inst->mayWriteToMemory())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="uncoveredLine">    if (StoreGroups.empty() || !tryAddTo(Info, StoreGroups.back()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="uncoveredLine">      StoreGroups.emplace_back(Info, Group.front().Inst, isHvx(Info), false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="">  // Erase singleton groups.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="uncoveredLine">  erase_if(StoreGroups, [](const MoveGroup &G) { return G.Main.size() <= 1; });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="">  // Erase HVX groups on targets < HvxV62 (due to lack of predicated loads).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="uncoveredLine">  if (!HVC.HST.useHVXV62Ops())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="uncoveredLine">    erase_if(StoreGroups, [](const MoveGroup &G) { return G.IsHvx; });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="">  // Erase groups where every store is a full HVX vector. The reason is that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="">  // aligning predicated stores generates complex code that may be less</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="">  // efficient than a sequence of unaligned vector stores.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="uncoveredLine">  if (!VADoFullStores) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="uncoveredLine">    erase_if(StoreGroups, [this](const MoveGroup &G) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="uncoveredLine">      return G.IsHvx && llvm::all_of(G.Main, [this](Instruction *S) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="uncoveredLine">               auto MaybeInfo = this->getAddrInfo(*S);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="uncoveredLine">               assert(MaybeInfo.has_value());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="uncoveredLine">               return HVC.HST.isHVXVectorType(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="uncoveredLine">                   EVT::getEVT(MaybeInfo->ValTy, false));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="uncoveredLine">             });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="">    });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="uncoveredLine">  return StoreGroups;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="uncoveredLine">auto AlignVectors::moveTogether(MoveGroup &Move) const -> bool {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="">  // Move all instructions to be adjacent.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="uncoveredLine">  assert(!Move.Main.empty() && "Move group should have non-empty Main");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="uncoveredLine">  Instruction *Where = Move.Main.front();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="uncoveredLine">  if (Move.IsLoad) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="">    // Move all the loads (and dependencies) to where the first load is.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="">    // Clone all deps to before Where, keeping order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="uncoveredLine">    Move.Clones = cloneBefore(Where, Move.Deps);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="">    // Move all main instructions to after Where, keeping order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="uncoveredLine">    ArrayRef<Instruction *> Main(Move.Main);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="uncoveredLine">    for (Instruction *M : Main) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="uncoveredLine">      if (M != Where)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="uncoveredLine">        M->moveAfter(Where);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="uncoveredLine">      for (auto [Old, New] : Move.Clones)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="uncoveredLine">        M->replaceUsesOfWith(Old, New);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="uncoveredLine">      Where = M;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="">    // Replace Deps with the clones.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="uncoveredLine">    for (int i = 0, e = Move.Deps.size(); i != e; ++i)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="uncoveredLine">      Move.Deps[i] = Move.Clones[Move.Deps[i]];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="">    // Move all the stores to where the last store is.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="">    // NOTE: Deps are empty for "store" groups. If they need to be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="">    // non-empty, decide on the order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="uncoveredLine">    assert(Move.Deps.empty());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="">    // Move all main instructions to before Where, inverting order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="uncoveredLine">    ArrayRef<Instruction *> Main(Move.Main);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="uncoveredLine">    for (Instruction *M : Main.drop_front(1)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="uncoveredLine">      M->moveBefore(Where);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="uncoveredLine">      Where = M;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="uncoveredLine">  return Move.Main.size() + Move.Deps.size() > 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="">template <typename T></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="uncoveredLine">auto AlignVectors::cloneBefore(Instruction *To, T &&Insts) const -> InstMap {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="uncoveredLine">  InstMap Map;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="uncoveredLine">  for (Instruction *I : Insts) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="uncoveredLine">    assert(HVC.isSafeToClone(*I));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="uncoveredLine">    Instruction *C = I->clone();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="uncoveredLine">    C->setName(Twine("c.") + I->getName() + ".");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="uncoveredLine">    C->insertBefore(To);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="uncoveredLine">    for (auto [Old, New] : Map)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="uncoveredLine">      C->replaceUsesOfWith(Old, New);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="uncoveredLine">    Map.insert(std::make_pair(I, C));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="uncoveredLine">  return Map;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="uncoveredLine">auto AlignVectors::realignLoadGroup(IRBuilderBase &Builder,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="">                                    const ByteSpan &VSpan, int ScLen,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="">                                    Value *AlignVal, Value *AlignAddr) const</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="">    -> void {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << __func__ << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="uncoveredLine">  Type *SecTy = HVC.getByteTy(ScLen);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="uncoveredLine">  int NumSectors = (VSpan.extent() + ScLen - 1) / ScLen;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="uncoveredLine">  bool DoAlign = !HVC.isZero(AlignVal);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="uncoveredLine">  BasicBlock::iterator BasePos = Builder.GetInsertPoint();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="uncoveredLine">  BasicBlock *BaseBlock = Builder.GetInsertBlock();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="uncoveredLine">  ByteSpan ASpan;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="uncoveredLine">  auto *True = HVC.getFullValue(HVC.getBoolTy(ScLen));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="uncoveredLine">  auto *Undef = UndefValue::get(SecTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="">  // Created load does not have to be "Instruction" (e.g. "undef").</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="uncoveredLine">  SmallVector<Value *> Loads(NumSectors + DoAlign, nullptr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="">  // We could create all of the aligned loads, and generate the valigns</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="">  // at the location of the first load, but for large load groups, this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="">  // could create highly suboptimal code (there have been groups of 140+</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="">  // loads in real code).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="">  // Instead, place the loads/valigns as close to the users as possible.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="">  // In any case we need to have a mapping from the blocks of VSpan (the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="">  // span covered by the pre-existing loads) to ASpan (the span covered</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="">  // by the aligned loads). There is a small problem, though: ASpan needs</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="">  // to have pointers to the loads/valigns, but we don't have these loads</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="">  // because we don't know where to put them yet. We find out by creating</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="">  // a section of ASpan that corresponds to values (blocks) from VSpan,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="">  // and checking where the new load should be placed. We need to attach</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="">  // this location information to each block in ASpan somehow, so we put</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="">  // distincts values for Seg.Val in each ASpan.Blocks[i], and use a map</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="">  // to store the location for each Seg.Val.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="">  // The distinct values happen to be Blocks[i].Seg.Val = &Blocks[i],</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="">  // which helps with printing ByteSpans without crashing when printing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="">  // Segments with these temporary identifiers in place of Val.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="">  // Populate the blocks first, to avoid reallocations of the vector</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="">  // interfering with generating the placeholder addresses.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="uncoveredLine">  for (int Index = 0; Index != NumSectors; ++Index)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="uncoveredLine">    ASpan.Blocks.emplace_back(nullptr, ScLen, Index * ScLen);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="uncoveredLine">  for (int Index = 0; Index != NumSectors; ++Index) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="uncoveredLine">    ASpan.Blocks[Index].Seg.Val =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="uncoveredLine">        reinterpret_cast<Value *>(&ASpan.Blocks[Index]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="">  // Multiple values from VSpan can map to the same value in ASpan. Since we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="">  // try to create loads lazily, we need to find the earliest use for each</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="">  // value from ASpan.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="uncoveredLine">  DenseMap<void *, Instruction *> EarliestUser;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="uncoveredLine">  auto isEarlier = [](Instruction *A, Instruction *B) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="uncoveredLine">    if (B == nullptr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="uncoveredLine">    if (A == nullptr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="uncoveredLine">    assert(A->getParent() == B->getParent());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="uncoveredLine">    return A->comesBefore(B);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="uncoveredLine">  auto earliestUser = [&](const auto &Uses) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="uncoveredLine">    Instruction *User = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="uncoveredLine">    for (const Use &U : Uses) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="uncoveredLine">      auto *I = dyn_cast<Instruction>(U.getUser());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="uncoveredLine">      assert(I != nullptr && "Load used in a non-instruction?");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="">      // Make sure we only consider users in this block, but we need</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="">      // to remember if there were users outside the block too. This is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="">      // because if no users are found, aligned loads will not be created.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="uncoveredLine">      if (I->getParent() == BaseBlock) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="uncoveredLine">        if (!isa<PHINode>(I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="uncoveredLine">          User = std::min(User, I, isEarlier);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="uncoveredLine">        User = std::min(User, BaseBlock->getTerminator(), isEarlier);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="uncoveredLine">    return User;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="uncoveredLine">  for (const ByteSpan::Block &B : VSpan) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="uncoveredLine">    ByteSpan ASection = ASpan.section(B.Pos, B.Seg.Size);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="uncoveredLine">    for (const ByteSpan::Block &S : ASection) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="uncoveredLine">      EarliestUser[S.Seg.Val] = std::min(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="uncoveredLine">          EarliestUser[S.Seg.Val], earliestUser(B.Seg.Val->uses()), isEarlier);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="uncoveredLine">  LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="">    dbgs() << "ASpan:\n" << ASpan << '\n';</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="">    dbgs() << "Earliest users of ASpan:\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="">    for (auto &[Val, User] : EarliestUser) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="">      dbgs() << Val << "\n ->" << *User << '\n';</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="uncoveredLine">  auto createLoad = [&](IRBuilderBase &Builder, const ByteSpan &VSpan,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="">                        int Index, bool MakePred) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="">    Value *Ptr =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="uncoveredLine">        createAdjustedPointer(Builder, AlignAddr, SecTy, Index * ScLen);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="">    Value *Predicate =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="uncoveredLine">        MakePred ? makeTestIfUnaligned(Builder, AlignVal, ScLen) : nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="">    // If vector shifting is potentially needed, accumulate metadata</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="">    // from source sections of twice the load width.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="uncoveredLine">    int Start = (Index - DoAlign) * ScLen;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="uncoveredLine">    int Width = (1 + DoAlign) * ScLen;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="uncoveredLine">    return this->createLoad(Builder, SecTy, Ptr, Predicate, ScLen, True, Undef,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="uncoveredLine">                            VSpan.section(Start, Width).values());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="uncoveredLine">  auto moveBefore = [this](Instruction *In, Instruction *To) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="">    // Move In and its upward dependencies to before To.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="uncoveredLine">    assert(In->getParent() == To->getParent());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="uncoveredLine">    DepList Deps = getUpwardDeps(In, To);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="uncoveredLine">    In->moveBefore(To);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="">    // DepList is sorted with respect to positions in the basic block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="uncoveredLine">    InstMap Map = cloneBefore(In, Deps);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="uncoveredLine">    for (auto [Old, New] : Map)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="uncoveredLine">      In->replaceUsesOfWith(Old, New);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="">  // Generate necessary loads at appropriate locations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "Creating loads for ASpan sectors\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="uncoveredLine">  for (int Index = 0; Index != NumSectors + 1; ++Index) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="">    // In ASpan, each block will be either a single aligned load, or a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="">    // valign of a pair of loads. In the latter case, an aligned load j</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="">    // will belong to the current valign, and the one in the previous</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="">    // block (for j > 0).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="">    // Place the load at a location which will dominate the valign, assuming</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="">    // the valign will be placed right before the earliest user.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="">    Instruction *PrevAt =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="uncoveredLine">        DoAlign && Index > 0 ? EarliestUser[&ASpan[Index - 1]] : nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="">    Instruction *ThisAt =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="uncoveredLine">        Index < NumSectors ? EarliestUser[&ASpan[Index]] : nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="uncoveredLine">    if (auto *Where = std::min(PrevAt, ThisAt, isEarlier)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="uncoveredLine">      Builder.SetInsertPoint(Where);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="uncoveredLine">      Loads[Index] =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="uncoveredLine">          createLoad(Builder, VSpan, Index, DoAlign && Index == NumSectors);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="">      // We know it's safe to put the load at BasePos, but we'd prefer to put</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="">      // it at "Where". To see if the load is safe to be placed at Where, put</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="">      // it there first and then check if it's safe to move it to BasePos.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="">      // If not, then the load needs to be placed at BasePos.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="">      // We can't do this check proactively because we need the load to exist</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="">      // in order to check legality.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="uncoveredLine">      if (auto *Load = dyn_cast<Instruction>(Loads[Index])) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="uncoveredLine">        if (!HVC.isSafeToMoveBeforeInBB(*Load, BasePos))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="uncoveredLine">          moveBefore(Load, &*BasePos);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "Loads[" << Index << "]:" << *Loads[Index] << '\n');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="">  // Generate valigns if needed, and fill in proper values in ASpan</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "Creating values for ASpan sectors\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="uncoveredLine">  for (int Index = 0; Index != NumSectors; ++Index) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="uncoveredLine">    ASpan[Index].Seg.Val = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="uncoveredLine">    if (auto *Where = EarliestUser[&ASpan[Index]]) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="uncoveredLine">      Builder.SetInsertPoint(Where);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="uncoveredLine">      Value *Val = Loads[Index];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="uncoveredLine">      assert(Val != nullptr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="uncoveredLine">      if (DoAlign) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="uncoveredLine">        Value *NextLoad = Loads[Index + 1];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="uncoveredLine">        assert(NextLoad != nullptr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="uncoveredLine">        Val = HVC.vralignb(Builder, Val, NextLoad, AlignVal);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="uncoveredLine">      ASpan[Index].Seg.Val = Val;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "ASpan[" << Index << "]:" << *Val << '\n');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="uncoveredLine">  for (const ByteSpan::Block &B : VSpan) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="uncoveredLine">    ByteSpan ASection = ASpan.section(B.Pos, B.Seg.Size).shift(-B.Pos);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="uncoveredLine">    Value *Accum = UndefValue::get(HVC.getByteTy(B.Seg.Size));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="uncoveredLine">    Builder.SetInsertPoint(cast<Instruction>(B.Seg.Val));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="">    // We're generating a reduction, where each instruction depends on</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="">    // the previous one, so we need to order them according to the position</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="">    // of their inputs in the code.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="uncoveredLine">    std::vector<ByteSpan::Block *> ABlocks;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="uncoveredLine">    for (ByteSpan::Block &S : ASection) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="uncoveredLine">      if (S.Seg.Val != nullptr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="uncoveredLine">        ABlocks.push_back(&S);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="uncoveredLine">    llvm::sort(ABlocks,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="uncoveredLine">               [&](const ByteSpan::Block *A, const ByteSpan::Block *B) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="uncoveredLine">                 return isEarlier(cast<Instruction>(A->Seg.Val),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="uncoveredLine">                                  cast<Instruction>(B->Seg.Val));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="">               });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="uncoveredLine">    for (ByteSpan::Block *S : ABlocks) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="">      // The processing of the data loaded by the aligned loads</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="">      // needs to be inserted after the data is available.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="uncoveredLine">      Instruction *SegI = cast<Instruction>(S->Seg.Val);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="uncoveredLine">      Builder.SetInsertPoint(&*std::next(SegI->getIterator()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="uncoveredLine">      Value *Pay = HVC.vbytes(Builder, getPayload(S->Seg.Val));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="">      Accum =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="uncoveredLine">          HVC.insertb(Builder, Accum, Pay, S->Seg.Start, S->Seg.Size, S->Pos);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="">    // Instead of casting everything to bytes for the vselect, cast to the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="">    // original value type. This will avoid complications with casting masks.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="">    // For example, in cases when the original mask applied to i32, it could</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="">    // be converted to a mask applicable to i8 via pred_typecast intrinsic,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="">    // but if the mask is not exactly of HVX length, extra handling would be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="">    // needed to make it work.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="uncoveredLine">    Type *ValTy = getPayload(B.Seg.Val)->getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="uncoveredLine">    Value *Cast = Builder.CreateBitCast(Accum, ValTy, "cst");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="uncoveredLine">    Value *Sel = Builder.CreateSelect(getMask(B.Seg.Val), Cast,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="uncoveredLine">                                      getPassThrough(B.Seg.Val), "sel");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="uncoveredLine">    B.Seg.Val->replaceAllUsesWith(Sel);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="uncoveredLine">auto AlignVectors::realignStoreGroup(IRBuilderBase &Builder,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="">                                     const ByteSpan &VSpan, int ScLen,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="">                                     Value *AlignVal, Value *AlignAddr) const</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="">    -> void {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << __func__ << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="uncoveredLine">  Type *SecTy = HVC.getByteTy(ScLen);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="uncoveredLine">  int NumSectors = (VSpan.extent() + ScLen - 1) / ScLen;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="uncoveredLine">  bool DoAlign = !HVC.isZero(AlignVal);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="">  // Stores.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="uncoveredLine">  ByteSpan ASpanV, ASpanM;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="">  // Return a vector value corresponding to the input value Val:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="">  // either <1 x Val> for scalar Val, or Val itself for vector Val.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="uncoveredLine">  auto MakeVec = [](IRBuilderBase &Builder, Value *Val) -> Value * {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="uncoveredLine">    Type *Ty = Val->getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="uncoveredLine">    if (Ty->isVectorTy())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="uncoveredLine">      return Val;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="uncoveredLine">    auto *VecTy = VectorType::get(Ty, 1, /*Scalable=*/false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="uncoveredLine">    return Builder.CreateBitCast(Val, VecTy, "cst");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="">  // Create an extra "undef" sector at the beginning and at the end.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="">  // They will be used as the left/right filler in the vlalign step.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="uncoveredLine">  for (int Index = (DoAlign ? -1 : 0); Index != NumSectors + DoAlign; ++Index) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="">    // For stores, the size of each section is an aligned vector length.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="">    // Adjust the store offsets relative to the section start offset.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="">    ByteSpan VSection =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="uncoveredLine">        VSpan.section(Index * ScLen, ScLen).shift(-Index * ScLen);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="uncoveredLine">    Value *Undef = UndefValue::get(SecTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="uncoveredLine">    Value *Zero = HVC.getNullValue(SecTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="uncoveredLine">    Value *AccumV = Undef;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="uncoveredLine">    Value *AccumM = Zero;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="uncoveredLine">    for (ByteSpan::Block &S : VSection) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="uncoveredLine">      Value *Pay = getPayload(S.Seg.Val);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="uncoveredLine">      Value *Mask = HVC.rescale(Builder, MakeVec(Builder, getMask(S.Seg.Val)),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="uncoveredLine">                                Pay->getType(), HVC.getByteTy());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="uncoveredLine">      Value *PartM = HVC.insertb(Builder, Zero, HVC.vbytes(Builder, Mask),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="">                                 S.Seg.Start, S.Seg.Size, S.Pos);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="uncoveredLine">      AccumM = Builder.CreateOr(AccumM, PartM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="uncoveredLine">      Value *PartV = HVC.insertb(Builder, Undef, HVC.vbytes(Builder, Pay),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="">                                 S.Seg.Start, S.Seg.Size, S.Pos);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="uncoveredLine">      AccumV = Builder.CreateSelect(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="">          Builder.CreateICmp(CmpInst::ICMP_NE, PartM, Zero), PartV, AccumV);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="uncoveredLine">    ASpanV.Blocks.emplace_back(AccumV, ScLen, Index * ScLen);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="uncoveredLine">    ASpanM.Blocks.emplace_back(AccumM, ScLen, Index * ScLen);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="uncoveredLine">  LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="">    dbgs() << "ASpanV before vlalign:\n" << ASpanV << '\n';</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="">    dbgs() << "ASpanM before vlalign:\n" << ASpanM << '\n';</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="">  // vlalign</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="uncoveredLine">  if (DoAlign) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="uncoveredLine">    for (int Index = 1; Index != NumSectors + 2; ++Index) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="uncoveredLine">      Value *PrevV = ASpanV[Index - 1].Seg.Val, *ThisV = ASpanV[Index].Seg.Val;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="uncoveredLine">      Value *PrevM = ASpanM[Index - 1].Seg.Val, *ThisM = ASpanM[Index].Seg.Val;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="uncoveredLine">      assert(isSectorTy(PrevV->getType()) && isSectorTy(PrevM->getType()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="uncoveredLine">      ASpanV[Index - 1].Seg.Val = HVC.vlalignb(Builder, PrevV, ThisV, AlignVal);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="uncoveredLine">      ASpanM[Index - 1].Seg.Val = HVC.vlalignb(Builder, PrevM, ThisM, AlignVal);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="uncoveredLine">  LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="">    dbgs() << "ASpanV after vlalign:\n" << ASpanV << '\n';</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="">    dbgs() << "ASpanM after vlalign:\n" << ASpanM << '\n';</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="uncoveredLine">  auto createStore = [&](IRBuilderBase &Builder, const ByteSpan &ASpanV,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="">                         const ByteSpan &ASpanM, int Index, bool MakePred) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="uncoveredLine">    Value *Val = ASpanV[Index].Seg.Val;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="uncoveredLine">    Value *Mask = ASpanM[Index].Seg.Val; // bytes</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="uncoveredLine">    if (HVC.isUndef(Val) || HVC.isZero(Mask))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="uncoveredLine">      return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="">    Value *Ptr =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="uncoveredLine">        createAdjustedPointer(Builder, AlignAddr, SecTy, Index * ScLen);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="">    Value *Predicate =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="uncoveredLine">        MakePred ? makeTestIfUnaligned(Builder, AlignVal, ScLen) : nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="">    // If vector shifting is potentially needed, accumulate metadata</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="">    // from source sections of twice the store width.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="uncoveredLine">    int Start = (Index - DoAlign) * ScLen;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="uncoveredLine">    int Width = (1 + DoAlign) * ScLen;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="uncoveredLine">    this->createStore(Builder, Val, Ptr, Predicate, ScLen,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="uncoveredLine">                      HVC.vlsb(Builder, Mask),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="uncoveredLine">                      VSpan.section(Start, Width).values());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="uncoveredLine">  for (int Index = 0; Index != NumSectors + DoAlign; ++Index) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="uncoveredLine">    createStore(Builder, ASpanV, ASpanM, Index, DoAlign && Index == NumSectors);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="uncoveredLine">auto AlignVectors::realignGroup(const MoveGroup &Move) const -> bool {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "Realigning group:\n" << Move << '\n');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="">  // TODO: Needs support for masked loads/stores of "scalar" vectors.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="uncoveredLine">  if (!Move.IsHvx)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="">  // Return the element with the maximum alignment from Range,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="">  // where GetValue obtains the value to compare from an element.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="uncoveredLine">  auto getMaxOf = [](auto Range, auto GetValue) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="uncoveredLine">    return *std::max_element(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="">        Range.begin(), Range.end(),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="uncoveredLine">        [&GetValue](auto &A, auto &B) { return GetValue(A) < GetValue(B); });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="uncoveredLine">  const AddrList &BaseInfos = AddrGroups.at(Move.Base);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="">  // Conceptually, there is a vector of N bytes covering the addresses</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="">  // starting from the minimum offset (i.e. Base.Addr+Start). This vector</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="">  // represents a contiguous memory region that spans all accessed memory</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="">  // locations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="">  // The correspondence between loaded or stored values will be expressed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="">  // in terms of this vector. For example, the 0th element of the vector</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="">  // from the Base address info will start at byte Start from the beginning</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="">  // of this conceptual vector.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="">  // This vector will be loaded/stored starting at the nearest down-aligned</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="">  // address and the amount od the down-alignment will be AlignVal:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="">  //   valign(load_vector(align_down(Base+Start)), AlignVal)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="uncoveredLine">  std::set<Instruction *> TestSet(Move.Main.begin(), Move.Main.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="uncoveredLine">  AddrList MoveInfos;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="uncoveredLine">  llvm::copy_if(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="">      BaseInfos, std::back_inserter(MoveInfos),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="uncoveredLine">      [&TestSet](const AddrInfo &AI) { return TestSet.count(AI.Inst); });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="">  // Maximum alignment present in the whole address group.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="">  const AddrInfo &WithMaxAlign =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="uncoveredLine">      getMaxOf(MoveInfos, [](const AddrInfo &AI) { return AI.HaveAlign; });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="uncoveredLine">  Align MaxGiven = WithMaxAlign.HaveAlign;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="">  // Minimum alignment present in the move address group.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="">  const AddrInfo &WithMinOffset =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="uncoveredLine">      getMaxOf(MoveInfos, [](const AddrInfo &AI) { return -AI.Offset; });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="">  const AddrInfo &WithMaxNeeded =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="uncoveredLine">      getMaxOf(MoveInfos, [](const AddrInfo &AI) { return AI.NeedAlign; });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="uncoveredLine">  Align MinNeeded = WithMaxNeeded.NeedAlign;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="">  // Set the builder's insertion point right before the load group, or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="">  // immediately after the store group. (Instructions in a store group are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="">  // listed in reverse order.)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="uncoveredLine">  Instruction *InsertAt = Move.Main.front();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="uncoveredLine">  if (!Move.IsLoad) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="">    // There should be a terminator (which store isn't, but check anyways).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="uncoveredLine">    assert(InsertAt->getIterator() != InsertAt->getParent()->end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="uncoveredLine">    InsertAt = &*std::next(InsertAt->getIterator());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="">  IRBuilder Builder(InsertAt->getParent(), InsertAt->getIterator(),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="uncoveredLine">                    InstSimplifyFolder(HVC.DL));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="uncoveredLine">  Value *AlignAddr = nullptr; // Actual aligned address.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="uncoveredLine">  Value *AlignVal = nullptr;  // Right-shift amount (for valign).</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="uncoveredLine">  if (MinNeeded <= MaxGiven) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="uncoveredLine">    int Start = WithMinOffset.Offset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="uncoveredLine">    int OffAtMax = WithMaxAlign.Offset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="">    // Shift the offset of the maximally aligned instruction (OffAtMax)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="">    // back by just enough multiples of the required alignment to cover the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="">    // distance from Start to OffAtMax.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="">    // Calculate the address adjustment amount based on the address with the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="">    // maximum alignment. This is to allow a simple gep instruction instead</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="">    // of potential bitcasts to i8*.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="uncoveredLine">    int Adjust = -alignTo(OffAtMax - Start, MinNeeded.value());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="uncoveredLine">    AlignAddr = createAdjustedPointer(Builder, WithMaxAlign.Addr,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="uncoveredLine">                                      WithMaxAlign.ValTy, Adjust, Move.Clones);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="uncoveredLine">    int Diff = Start - (OffAtMax + Adjust);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="uncoveredLine">    AlignVal = HVC.getConstInt(Diff);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="uncoveredLine">    assert(Diff >= 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="uncoveredLine">    assert(static_cast<decltype(MinNeeded.value())>(Diff) < MinNeeded.value());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="">    // WithMinOffset is the lowest address in the group,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="">    //   WithMinOffset.Addr = Base+Start.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="">    // Align instructions for both HVX (V6_valign) and scalar (S2_valignrb)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="">    // mask off unnecessary bits, so it's ok to just the original pointer as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="">    // the alignment amount.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="">    // Do an explicit down-alignment of the address to avoid creating an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="">    // aligned instruction with an address that is not really aligned.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="">    AlignAddr =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="uncoveredLine">        createAlignedPointer(Builder, WithMinOffset.Addr, WithMinOffset.ValTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="uncoveredLine">                             MinNeeded.value(), Move.Clones);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="">    AlignVal =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="uncoveredLine">        Builder.CreatePtrToInt(WithMinOffset.Addr, HVC.getIntTy(), "pti");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="uncoveredLine">    if (auto *I = dyn_cast<Instruction>(AlignVal)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="uncoveredLine">      for (auto [Old, New] : Move.Clones)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="uncoveredLine">        I->replaceUsesOfWith(Old, New);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="uncoveredLine">  ByteSpan VSpan;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="uncoveredLine">  for (const AddrInfo &AI : MoveInfos) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="uncoveredLine">    VSpan.Blocks.emplace_back(AI.Inst, HVC.getSizeOf(AI.ValTy),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="uncoveredLine">                              AI.Offset - WithMinOffset.Offset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="">  // The aligned loads/stores will use blocks that are either scalars,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="">  // or HVX vectors. Let "sector" be the unified term for such a block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="">  // blend(scalar, vector) -> sector...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="uncoveredLine">  int ScLen = Move.IsHvx ? HVC.HST.getVectorLength()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="uncoveredLine">                         : std::max<int>(MinNeeded.value(), 4);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="uncoveredLine">  assert(!Move.IsHvx || ScLen == 64 || ScLen == 128);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="uncoveredLine">  assert(Move.IsHvx || ScLen == 4 || ScLen == 8);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="uncoveredLine">  LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="">    dbgs() << "ScLen:  " << ScLen << "\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="">    dbgs() << "AlignVal:" << *AlignVal << "\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="">    dbgs() << "AlignAddr:" << *AlignAddr << "\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="">    dbgs() << "VSpan:\n" << VSpan << '\n';</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="uncoveredLine">  if (Move.IsLoad)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="uncoveredLine">    realignLoadGroup(Builder, VSpan, ScLen, AlignVal, AlignAddr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="uncoveredLine">    realignStoreGroup(Builder, VSpan, ScLen, AlignVal, AlignAddr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="uncoveredLine">  for (auto *Inst : Move.Main)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="uncoveredLine">    Inst->eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="uncoveredLine">auto AlignVectors::makeTestIfUnaligned(IRBuilderBase &Builder, Value *AlignVal,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="">                                       int Alignment) const -> Value * {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="uncoveredLine">  auto *AlignTy = AlignVal->getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="uncoveredLine">  Value *And = Builder.CreateAnd(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="uncoveredLine">      AlignVal, ConstantInt::get(AlignTy, Alignment - 1), "and");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="uncoveredLine">  Value *Zero = ConstantInt::get(AlignTy, 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="uncoveredLine">  return Builder.CreateICmpNE(And, Zero, "isz");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="uncoveredLine">auto AlignVectors::isSectorTy(Type *Ty) const -> bool {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="uncoveredLine">  if (!HVC.isByteVecTy(Ty))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="uncoveredLine">  int Size = HVC.getSizeOf(Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="uncoveredLine">  if (HVC.HST.isTypeForHVX(Ty))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="uncoveredLine">    return Size == static_cast<int>(HVC.HST.getVectorLength());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="uncoveredLine">  return Size == 4 || Size == 8;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="uncoveredLine">auto AlignVectors::run() -> bool {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "Running HVC::AlignVectors on " << HVC.F.getName()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="">                    << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="uncoveredLine">  if (!createAddressGroups())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="uncoveredLine">  LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="">    dbgs() << "Address groups(" << AddrGroups.size() << "):\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="">    for (auto &[In, AL] : AddrGroups) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="">      for (const AddrInfo &AI : AL)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="">        dbgs() << "---\n" << AI << '\n';</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="uncoveredLine">  bool Changed = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="uncoveredLine">  MoveList LoadGroups, StoreGroups;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="uncoveredLine">  for (auto &G : AddrGroups) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="uncoveredLine">    llvm::append_range(LoadGroups, createLoadGroups(G.second));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="uncoveredLine">    llvm::append_range(StoreGroups, createStoreGroups(G.second));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="uncoveredLine">  LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="">    dbgs() << "\nLoad groups(" << LoadGroups.size() << "):\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="">    for (const MoveGroup &G : LoadGroups)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="">      dbgs() << G << "\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="">    dbgs() << "Store groups(" << StoreGroups.size() << "):\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="">    for (const MoveGroup &G : StoreGroups)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="">      dbgs() << G << "\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="">  // Cumulative limit on the number of groups.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="uncoveredLine">  unsigned CountLimit = VAGroupCountLimit;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="uncoveredLine">  if (CountLimit == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="uncoveredLine">  if (LoadGroups.size() > CountLimit) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="uncoveredLine">    LoadGroups.resize(CountLimit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="uncoveredLine">    StoreGroups.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="uncoveredLine">    unsigned StoreLimit = CountLimit - LoadGroups.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="uncoveredLine">    if (StoreGroups.size() > StoreLimit)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="uncoveredLine">      StoreGroups.resize(StoreLimit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="uncoveredLine">  for (auto &M : LoadGroups)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="uncoveredLine">    Changed |= moveTogether(M);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="uncoveredLine">  for (auto &M : StoreGroups)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="uncoveredLine">    Changed |= moveTogether(M);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "After moveTogether:\n" << HVC.F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="uncoveredLine">  for (auto &M : LoadGroups)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="uncoveredLine">    Changed |= realignGroup(M);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="uncoveredLine">  for (auto &M : StoreGroups)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="uncoveredLine">    Changed |= realignGroup(M);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="uncoveredLine">  return Changed;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="">// --- End AlignVectors</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="">// --- Begin HvxIdioms</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="uncoveredLine">auto HvxIdioms::getNumSignificantBits(Value *V, Instruction *In) const</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="">    -> std::pair<unsigned, Signedness> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="uncoveredLine">  unsigned Bits = HVC.getNumSignificantBits(V, In);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="">  // The significant bits are calculated including the sign bit. This may</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="">  // add an extra bit for zero-extended values, e.g. (zext i32 to i64) may</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="">  // result in 33 significant bits. To avoid extra words, skip the extra</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="">  // sign bit, but keep information that the value is to be treated as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="">  // unsigned.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="uncoveredLine">  KnownBits Known = HVC.getKnownBits(V, In);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="uncoveredLine">  Signedness Sign = Signed;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="uncoveredLine">  unsigned NumToTest = 0; // Number of bits used in test for unsignedness.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="uncoveredLine">  if (isPowerOf2_32(Bits))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="uncoveredLine">    NumToTest = Bits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="uncoveredLine">  else if (Bits > 1 && isPowerOf2_32(Bits - 1))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="uncoveredLine">    NumToTest = Bits - 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="uncoveredLine">  if (NumToTest != 0 && Known.Zero.ashr(NumToTest).isAllOnes()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="uncoveredLine">    Sign = Unsigned;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="uncoveredLine">    Bits = NumToTest;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="">  // If the top bit of the nearest power-of-2 is zero, this value is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="">  // positive. It could be treated as either signed or unsigned.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="uncoveredLine">  if (unsigned Pow2 = PowerOf2Ceil(Bits); Pow2 != Bits) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="uncoveredLine">    if (Known.Zero.ashr(Pow2 - 1).isAllOnes())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="uncoveredLine">      Sign = Positive;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="uncoveredLine">  return {Bits, Sign};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="uncoveredLine">auto HvxIdioms::canonSgn(SValue X, SValue Y) const</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="">    -> std::pair<SValue, SValue> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="">  // Canonicalize the signedness of X and Y, so that the result is one of:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="">  //   S, S</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="">  //   U/P, S</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="">  //   U/P, U/P</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="uncoveredLine">  if (X.Sgn == Signed && Y.Sgn != Signed)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="uncoveredLine">    std::swap(X, Y);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="uncoveredLine">  return {X, Y};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="">// Match</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="">//   (X * Y) [>> N], or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="">//   ((X * Y) + (1 << M)) >> N</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="uncoveredLine">auto HvxIdioms::matchFxpMul(Instruction &In) const -> std::optional<FxpOp> {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="">  using namespace PatternMatch;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="uncoveredLine">  auto *Ty = In.getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="uncoveredLine">  if (!Ty->isVectorTy() || !Ty->getScalarType()->isIntegerTy())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="uncoveredLine">    return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="uncoveredLine">  unsigned Width = cast<IntegerType>(Ty->getScalarType())->getBitWidth();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="uncoveredLine">  FxpOp Op;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="uncoveredLine">  Value *Exp = &In;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="">  // Fixed-point multiplication is always shifted right (except when the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="">  // fraction is 0 bits).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="uncoveredLine">  auto m_Shr = [](auto &&V, auto &&S) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="uncoveredLine">    return m_CombineOr(m_LShr(V, S), m_AShr(V, S));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="uncoveredLine">  const APInt *Qn = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="uncoveredLine">  if (Value * T; match(Exp, m_Shr(m_Value(T), m_APInt(Qn)))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="uncoveredLine">    Op.Frac = Qn->getZExtValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="uncoveredLine">    Exp = T;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="uncoveredLine">    Op.Frac = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="uncoveredLine">  if (Op.Frac > Width)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="uncoveredLine">    return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="">  // Check if there is rounding added.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="uncoveredLine">  const APInt *C = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="uncoveredLine">  if (Value * T; Op.Frac > 0 && match(Exp, m_Add(m_Value(T), m_APInt(C)))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="uncoveredLine">    uint64_t CV = C->getZExtValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="uncoveredLine">    if (CV != 0 && !isPowerOf2_64(CV))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="uncoveredLine">      return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="uncoveredLine">    if (CV != 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="uncoveredLine">      Op.RoundAt = Log2_64(CV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="uncoveredLine">    Exp = T;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="">  // Check if the rest is a multiplication.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="uncoveredLine">  if (match(Exp, m_Mul(m_Value(Op.X.Val), m_Value(Op.Y.Val)))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="uncoveredLine">    Op.Opcode = Instruction::Mul;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="">    // FIXME: The information below is recomputed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="uncoveredLine">    Op.X.Sgn = getNumSignificantBits(Op.X.Val, &In).second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="uncoveredLine">    Op.Y.Sgn = getNumSignificantBits(Op.Y.Val, &In).second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="uncoveredLine">    Op.ResTy = cast<VectorType>(Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="uncoveredLine">    return Op;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="uncoveredLine">  return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="uncoveredLine">auto HvxIdioms::processFxpMul(Instruction &In, const FxpOp &Op) const</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="">    -> Value * {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="uncoveredLine">  assert(Op.X.Val->getType() == Op.Y.Val->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="uncoveredLine">  auto *VecTy = dyn_cast<VectorType>(Op.X.Val->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="uncoveredLine">  if (VecTy == nullptr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="uncoveredLine">  auto *ElemTy = cast<IntegerType>(VecTy->getElementType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="uncoveredLine">  unsigned ElemWidth = ElemTy->getBitWidth();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="">  // TODO: This can be relaxed after legalization is done pre-isel.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="uncoveredLine">  if ((HVC.length(VecTy) * ElemWidth) % (8 * HVC.HST.getVectorLength()) != 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="">  // There are no special intrinsics that should be used for multiplying</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="">  // signed 8-bit values, so just skip them. Normal codegen should handle</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="">  // this just fine.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="uncoveredLine">  if (ElemWidth <= 8)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="">  // Similarly, if this is just a multiplication that can be handled without</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="">  // intervention, then leave it alone.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="uncoveredLine">  if (ElemWidth <= 32 && Op.Frac == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="uncoveredLine">  auto [BitsX, SignX] = getNumSignificantBits(Op.X.Val, &In);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="uncoveredLine">  auto [BitsY, SignY] = getNumSignificantBits(Op.Y.Val, &In);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="">  // TODO: Add multiplication of vectors by scalar registers (up to 4 bytes).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="uncoveredLine">  Value *X = Op.X.Val, *Y = Op.Y.Val;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="">  IRBuilder Builder(In.getParent(), In.getIterator(),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="uncoveredLine">                    InstSimplifyFolder(HVC.DL));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="uncoveredLine">  auto roundUpWidth = [](unsigned Width) -> unsigned {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="uncoveredLine">    if (Width <= 32 && !isPowerOf2_32(Width)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="">      // If the element width is not a power of 2, round it up</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="">      // to the next one. Do this for widths not exceeding 32.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="uncoveredLine">      return PowerOf2Ceil(Width);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="uncoveredLine">    if (Width > 32 && Width % 32 != 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="">      // For wider elements, round it up to the multiple of 32.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="uncoveredLine">      return alignTo(Width, 32u);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="uncoveredLine">    return Width;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="uncoveredLine">  BitsX = roundUpWidth(BitsX);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="uncoveredLine">  BitsY = roundUpWidth(BitsY);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="">  // For elementwise multiplication vectors must have the same lengths, so</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="">  // resize the elements of both inputs to the same width, the max of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="">  // calculated significant bits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="uncoveredLine">  unsigned Width = std::max(BitsX, BitsY);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="uncoveredLine">  auto *ResizeTy = VectorType::get(HVC.getIntTy(Width), VecTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="uncoveredLine">  if (Width < ElemWidth) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="uncoveredLine">    X = Builder.CreateTrunc(X, ResizeTy, "trn");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="uncoveredLine">    Y = Builder.CreateTrunc(Y, ResizeTy, "trn");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="uncoveredLine">  } else if (Width > ElemWidth) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="uncoveredLine">    X = SignX == Signed ? Builder.CreateSExt(X, ResizeTy, "sxt")</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="uncoveredLine">                        : Builder.CreateZExt(X, ResizeTy, "zxt");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="uncoveredLine">    Y = SignY == Signed ? Builder.CreateSExt(Y, ResizeTy, "sxt")</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="uncoveredLine">                        : Builder.CreateZExt(Y, ResizeTy, "zxt");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="uncoveredLine">  assert(X->getType() == Y->getType() && X->getType() == ResizeTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="uncoveredLine">  unsigned VecLen = HVC.length(ResizeTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="uncoveredLine">  unsigned ChopLen = (8 * HVC.HST.getVectorLength()) / std::min(Width, 32u);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="uncoveredLine">  SmallVector<Value *> Results;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="uncoveredLine">  FxpOp ChopOp = Op;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="uncoveredLine">  ChopOp.ResTy = VectorType::get(Op.ResTy->getElementType(), ChopLen, false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="uncoveredLine">  for (unsigned V = 0; V != VecLen / ChopLen; ++V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="uncoveredLine">    ChopOp.X.Val = HVC.subvector(Builder, X, V * ChopLen, ChopLen);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="uncoveredLine">    ChopOp.Y.Val = HVC.subvector(Builder, Y, V * ChopLen, ChopLen);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="uncoveredLine">    Results.push_back(processFxpMulChopped(Builder, In, ChopOp));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="uncoveredLine">    if (Results.back() == nullptr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="uncoveredLine">  if (Results.empty() || Results.back() == nullptr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="uncoveredLine">  Value *Cat = HVC.concat(Builder, Results);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="uncoveredLine">  Value *Ext = SignX == Signed || SignY == Signed</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="uncoveredLine">                   ? Builder.CreateSExt(Cat, VecTy, "sxt")</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="uncoveredLine">                   : Builder.CreateZExt(Cat, VecTy, "zxt");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="uncoveredLine">  return Ext;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="uncoveredLine">auto HvxIdioms::processFxpMulChopped(IRBuilderBase &Builder, Instruction &In,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="">                                     const FxpOp &Op) const -> Value * {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="uncoveredLine">  assert(Op.X.Val->getType() == Op.Y.Val->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="uncoveredLine">  auto *InpTy = cast<VectorType>(Op.X.Val->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="uncoveredLine">  unsigned Width = InpTy->getScalarSizeInBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="uncoveredLine">  bool Rounding = Op.RoundAt.has_value();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="uncoveredLine">  if (!Op.RoundAt || *Op.RoundAt == Op.Frac - 1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="">    // The fixed-point intrinsics do signed multiplication.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="uncoveredLine">    if (Width == Op.Frac + 1 && Op.X.Sgn != Unsigned && Op.Y.Sgn != Unsigned) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="uncoveredLine">      Value *QMul = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="uncoveredLine">      if (Width == 16) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="uncoveredLine">        QMul = createMulQ15(Builder, Op.X, Op.Y, Rounding);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="uncoveredLine">      } else if (Width == 32) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="uncoveredLine">        QMul = createMulQ31(Builder, Op.X, Op.Y, Rounding);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="uncoveredLine">      if (QMul != nullptr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="uncoveredLine">        return QMul;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="uncoveredLine">  assert(Width >= 32 || isPowerOf2_32(Width)); // Width <= 32 => Width is 2^n</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="uncoveredLine">  assert(Width < 32 || Width % 32 == 0);       // Width > 32 => Width is 32*k</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="">  // If Width < 32, then it should really be 16.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="uncoveredLine">  if (Width < 32) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="uncoveredLine">    if (Width < 16)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="uncoveredLine">      return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="">    // Getting here with Op.Frac == 0 isn't wrong, but suboptimal: here we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="">    // generate a full precision products, which is unnecessary if there is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="">    // no shift.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="uncoveredLine">    assert(Width == 16);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="uncoveredLine">    assert(Op.Frac != 0 && "Unshifted mul should have been skipped");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="uncoveredLine">    if (Op.Frac == 16) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="">      // Multiply high</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="uncoveredLine">      if (Value *MulH = createMulH16(Builder, Op.X, Op.Y))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="uncoveredLine">        return MulH;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="">    // Do full-precision multiply and shift.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="uncoveredLine">    Value *Prod32 = createMul16(Builder, Op.X, Op.Y);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="uncoveredLine">    if (Rounding) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="uncoveredLine">      Value *RoundVal = HVC.getConstSplat(Prod32->getType(), 1 << *Op.RoundAt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="uncoveredLine">      Prod32 = Builder.CreateAdd(Prod32, RoundVal, "add");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="uncoveredLine">    Value *ShiftAmt = HVC.getConstSplat(Prod32->getType(), Op.Frac);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="uncoveredLine">    Value *Shifted = Op.X.Sgn == Signed || Op.Y.Sgn == Signed</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="uncoveredLine">                         ? Builder.CreateAShr(Prod32, ShiftAmt, "asr")</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="uncoveredLine">                         : Builder.CreateLShr(Prod32, ShiftAmt, "lsr");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="uncoveredLine">    return Builder.CreateTrunc(Shifted, InpTy, "trn");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="">  // Width >= 32</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="">  // Break up the arguments Op.X and Op.Y into vectors of smaller widths</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="">  // in preparation of doing the multiplication by 32-bit parts.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="uncoveredLine">  auto WordX = HVC.splitVectorElements(Builder, Op.X.Val, /*ToWidth=*/32);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="uncoveredLine">  auto WordY = HVC.splitVectorElements(Builder, Op.Y.Val, /*ToWidth=*/32);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="uncoveredLine">  auto WordP = createMulLong(Builder, WordX, Op.X.Sgn, WordY, Op.Y.Sgn);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="uncoveredLine">  auto *HvxWordTy = cast<VectorType>(WordP.front()->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="">  // Add the optional rounding to the proper word.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="uncoveredLine">  if (Op.RoundAt.has_value()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="uncoveredLine">    Value *Zero = HVC.getNullValue(WordX[0]->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="uncoveredLine">    SmallVector<Value *> RoundV(WordP.size(), Zero);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="uncoveredLine">    RoundV[*Op.RoundAt / 32] =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="uncoveredLine">        HVC.getConstSplat(HvxWordTy, 1 << (*Op.RoundAt % 32));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="uncoveredLine">    WordP = createAddLong(Builder, WordP, RoundV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="">  // createRightShiftLong?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="">  // Shift all products right by Op.Frac.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="uncoveredLine">  unsigned SkipWords = Op.Frac / 32;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="uncoveredLine">  Constant *ShiftAmt = HVC.getConstSplat(HvxWordTy, Op.Frac % 32);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="uncoveredLine">  for (int Dst = 0, End = WordP.size() - SkipWords; Dst != End; ++Dst) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="uncoveredLine">    int Src = Dst + SkipWords;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="uncoveredLine">    Value *Lo = WordP[Src];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="uncoveredLine">    if (Src + 1 < End) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="uncoveredLine">      Value *Hi = WordP[Src + 1];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="uncoveredLine">      WordP[Dst] = Builder.CreateIntrinsic(HvxWordTy, Intrinsic::fshr,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="">                                           {Hi, Lo, ShiftAmt},</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="">                                           /*FMFSource*/ nullptr, "int");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="">      // The shift of the most significant word.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="uncoveredLine">      WordP[Dst] = Builder.CreateAShr(Lo, ShiftAmt, "asr");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="uncoveredLine">  if (SkipWords != 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="uncoveredLine">    WordP.resize(WordP.size() - SkipWords);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="uncoveredLine">  return HVC.joinVectorElements(Builder, WordP, Op.ResTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="uncoveredLine">auto HvxIdioms::createMulQ15(IRBuilderBase &Builder, SValue X, SValue Y,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="">                             bool Rounding) const -> Value * {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="uncoveredLine">  assert(X.Val->getType() == Y.Val->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="uncoveredLine">  assert(X.Val->getType()->getScalarType() == HVC.getIntTy(16));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="uncoveredLine">  assert(HVC.HST.isHVXVectorType(EVT::getEVT(X.Val->getType(), false)));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="">  // There is no non-rounding intrinsic for i16.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="uncoveredLine">  if (!Rounding || X.Sgn == Unsigned || Y.Sgn == Unsigned)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="uncoveredLine">  auto V6_vmpyhvsrs = HVC.HST.getIntrinsicId(Hexagon::V6_vmpyhvsrs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="uncoveredLine">  return HVC.createHvxIntrinsic(Builder, V6_vmpyhvsrs, X.Val->getType(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="uncoveredLine">                                {X.Val, Y.Val});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="uncoveredLine">auto HvxIdioms::createMulQ31(IRBuilderBase &Builder, SValue X, SValue Y,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="">                             bool Rounding) const -> Value * {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="uncoveredLine">  Type *InpTy = X.Val->getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="uncoveredLine">  assert(InpTy == Y.Val->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="uncoveredLine">  assert(InpTy->getScalarType() == HVC.getIntTy(32));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="uncoveredLine">  assert(HVC.HST.isHVXVectorType(EVT::getEVT(InpTy, false)));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="uncoveredLine">  if (X.Sgn == Unsigned || Y.Sgn == Unsigned)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="uncoveredLine">  auto V6_vmpyewuh = HVC.HST.getIntrinsicId(Hexagon::V6_vmpyewuh);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="">  auto V6_vmpyo_acc = Rounding</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="uncoveredLine">                          ? HVC.HST.getIntrinsicId(Hexagon::V6_vmpyowh_rnd_sacc)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="uncoveredLine">                          : HVC.HST.getIntrinsicId(Hexagon::V6_vmpyowh_sacc);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="">  Value *V1 =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="uncoveredLine">      HVC.createHvxIntrinsic(Builder, V6_vmpyewuh, InpTy, {X.Val, Y.Val});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="uncoveredLine">  return HVC.createHvxIntrinsic(Builder, V6_vmpyo_acc, InpTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="uncoveredLine">                                {V1, X.Val, Y.Val});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="uncoveredLine">auto HvxIdioms::createAddCarry(IRBuilderBase &Builder, Value *X, Value *Y,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="">                               Value *CarryIn) const</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="">    -> std::pair<Value *, Value *> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="uncoveredLine">  assert(X->getType() == Y->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="uncoveredLine">  auto VecTy = cast<VectorType>(X->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="uncoveredLine">  if (VecTy == HvxI32Ty && HVC.HST.useHVXV62Ops()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="uncoveredLine">    SmallVector<Value *> Args = {X, Y};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="">    Intrinsic::ID AddCarry;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="uncoveredLine">    if (CarryIn == nullptr && HVC.HST.useHVXV66Ops()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="uncoveredLine">      AddCarry = HVC.HST.getIntrinsicId(Hexagon::V6_vaddcarryo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="uncoveredLine">      AddCarry = HVC.HST.getIntrinsicId(Hexagon::V6_vaddcarry);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="uncoveredLine">      if (CarryIn == nullptr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="uncoveredLine">        CarryIn = HVC.getNullValue(HVC.getBoolTy(HVC.length(VecTy)));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="uncoveredLine">      Args.push_back(CarryIn);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="uncoveredLine">    Value *Ret = HVC.createHvxIntrinsic(Builder, AddCarry,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="">                                        /*RetTy=*/nullptr, Args);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="uncoveredLine">    Value *Result = Builder.CreateExtractValue(Ret, {0}, "ext");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="uncoveredLine">    Value *CarryOut = Builder.CreateExtractValue(Ret, {1}, "ext");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="uncoveredLine">    return {Result, CarryOut};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="">  // In other cases, do a regular add, and unsigned compare-less-than.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="">  // The carry-out can originate in two places: adding the carry-in or adding</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="">  // the two input values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="uncoveredLine">  Value *Result1 = X; // Result1 = X + CarryIn</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="uncoveredLine">  if (CarryIn != nullptr) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="uncoveredLine">    unsigned Width = VecTy->getScalarSizeInBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="uncoveredLine">    uint32_t Mask = 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="uncoveredLine">    if (Width < 32) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="uncoveredLine">      for (unsigned i = 0, e = 32 / Width; i != e; ++i)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="uncoveredLine">        Mask = (Mask << Width) | 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="uncoveredLine">    auto V6_vandqrt = HVC.HST.getIntrinsicId(Hexagon::V6_vandqrt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="">    Value *ValueIn =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="uncoveredLine">        HVC.createHvxIntrinsic(Builder, V6_vandqrt, /*RetTy=*/nullptr,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="uncoveredLine">                               {CarryIn, HVC.getConstInt(Mask)});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="uncoveredLine">    Result1 = Builder.CreateAdd(X, ValueIn, "add");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="uncoveredLine">  Value *CarryOut1 = Builder.CreateCmp(CmpInst::ICMP_ULT, Result1, X, "cmp");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="uncoveredLine">  Value *Result2 = Builder.CreateAdd(Result1, Y, "add");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="uncoveredLine">  Value *CarryOut2 = Builder.CreateCmp(CmpInst::ICMP_ULT, Result2, Y, "cmp");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="uncoveredLine">  return {Result2, Builder.CreateOr(CarryOut1, CarryOut2, "orb")};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="uncoveredLine">auto HvxIdioms::createMul16(IRBuilderBase &Builder, SValue X, SValue Y) const</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="">    -> Value * {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="uncoveredLine">  Intrinsic::ID V6_vmpyh = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="uncoveredLine">  std::tie(X, Y) = canonSgn(X, Y);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="uncoveredLine">  if (X.Sgn == Signed) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="uncoveredLine">    V6_vmpyh = HVC.HST.getIntrinsicId(Hexagon::V6_vmpyhv);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="uncoveredLine">  } else if (Y.Sgn == Signed) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="">    // In vmpyhus the second operand is unsigned</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="uncoveredLine">    V6_vmpyh = HVC.HST.getIntrinsicId(Hexagon::V6_vmpyhus);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="uncoveredLine">    V6_vmpyh = HVC.HST.getIntrinsicId(Hexagon::V6_vmpyuhv);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="">  // i16*i16 -> i32 / interleaved</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="">  Value *P =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="uncoveredLine">      HVC.createHvxIntrinsic(Builder, V6_vmpyh, HvxP32Ty, {Y.Val, X.Val});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="">  // Deinterleave</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="uncoveredLine">  return HVC.vshuff(Builder, HVC.sublo(Builder, P), HVC.subhi(Builder, P));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="uncoveredLine">auto HvxIdioms::createMulH16(IRBuilderBase &Builder, SValue X, SValue Y) const</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="">    -> Value * {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="uncoveredLine">  Type *HvxI16Ty = HVC.getHvxTy(HVC.getIntTy(16), /*Pair=*/false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="uncoveredLine">  if (HVC.HST.useHVXV69Ops()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="uncoveredLine">    if (X.Sgn != Signed && Y.Sgn != Signed) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="uncoveredLine">      auto V6_vmpyuhvs = HVC.HST.getIntrinsicId(Hexagon::V6_vmpyuhvs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="uncoveredLine">      return HVC.createHvxIntrinsic(Builder, V6_vmpyuhvs, HvxI16Ty,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="uncoveredLine">                                    {X.Val, Y.Val});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="uncoveredLine">  Type *HvxP16Ty = HVC.getHvxTy(HVC.getIntTy(16), /*Pair=*/true);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="">  Value *Pair16 =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="uncoveredLine">      Builder.CreateBitCast(createMul16(Builder, X, Y), HvxP16Ty, "cst");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="uncoveredLine">  unsigned Len = HVC.length(HvxP16Ty) / 2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="uncoveredLine">  SmallVector<int, 128> PickOdd(Len);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="uncoveredLine">  for (int i = 0; i != static_cast<int>(Len); ++i)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="uncoveredLine">    PickOdd[i] = 2 * i + 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="uncoveredLine">  return Builder.CreateShuffleVector(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="uncoveredLine">      HVC.sublo(Builder, Pair16), HVC.subhi(Builder, Pair16), PickOdd, "shf");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="uncoveredLine">auto HvxIdioms::createMul32(IRBuilderBase &Builder, SValue X, SValue Y) const</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="">    -> std::pair<Value *, Value *> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="uncoveredLine">  assert(X.Val->getType() == Y.Val->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="uncoveredLine">  assert(X.Val->getType() == HvxI32Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="">  Intrinsic::ID V6_vmpy_parts;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="uncoveredLine">  std::tie(X, Y) = canonSgn(X, Y);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="uncoveredLine">  if (X.Sgn == Signed) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="uncoveredLine">    V6_vmpy_parts = Intrinsic::hexagon_V6_vmpyss_parts;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="uncoveredLine">  } else if (Y.Sgn == Signed) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="uncoveredLine">    V6_vmpy_parts = Intrinsic::hexagon_V6_vmpyus_parts;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="uncoveredLine">    V6_vmpy_parts = Intrinsic::hexagon_V6_vmpyuu_parts;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="uncoveredLine">  Value *Parts = HVC.createHvxIntrinsic(Builder, V6_vmpy_parts, nullptr,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="uncoveredLine">                                        {X.Val, Y.Val}, {HvxI32Ty});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="uncoveredLine">  Value *Hi = Builder.CreateExtractValue(Parts, {0}, "ext");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="uncoveredLine">  Value *Lo = Builder.CreateExtractValue(Parts, {1}, "ext");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="uncoveredLine">  return {Lo, Hi};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="uncoveredLine">auto HvxIdioms::createAddLong(IRBuilderBase &Builder, ArrayRef<Value *> WordX,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="">                              ArrayRef<Value *> WordY) const</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="">    -> SmallVector<Value *> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="uncoveredLine">  assert(WordX.size() == WordY.size());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="uncoveredLine">  unsigned Idx = 0, Length = WordX.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="uncoveredLine">  SmallVector<Value *> Sum(Length);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="uncoveredLine">  while (Idx != Length) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="uncoveredLine">    if (HVC.isZero(WordX[Idx]))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="uncoveredLine">      Sum[Idx] = WordY[Idx];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="uncoveredLine">    else if (HVC.isZero(WordY[Idx]))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="uncoveredLine">      Sum[Idx] = WordX[Idx];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="uncoveredLine">    ++Idx;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="uncoveredLine">  Value *Carry = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="uncoveredLine">  for (; Idx != Length; ++Idx) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="uncoveredLine">    std::tie(Sum[Idx], Carry) =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="uncoveredLine">        createAddCarry(Builder, WordX[Idx], WordY[Idx], Carry);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="">  // This drops the final carry beyond the highest word.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="uncoveredLine">  return Sum;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="uncoveredLine">auto HvxIdioms::createMulLong(IRBuilderBase &Builder, ArrayRef<Value *> WordX,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="">                              Signedness SgnX, ArrayRef<Value *> WordY,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="">                              Signedness SgnY) const -> SmallVector<Value *> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="uncoveredLine">  SmallVector<SmallVector<Value *>> Products(WordX.size() + WordY.size());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="">  // WordX[i] * WordY[j] produces words i+j and i+j+1 of the results,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="">  // that is halves 2(i+j), 2(i+j)+1, 2(i+j)+2, 2(i+j)+3.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="uncoveredLine">  for (int i = 0, e = WordX.size(); i != e; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="uncoveredLine">    for (int j = 0, f = WordY.size(); j != f; ++j) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="">      // Check the 4 halves that this multiplication can generate.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="uncoveredLine">      Signedness SX = (i + 1 == e) ? SgnX : Unsigned;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="uncoveredLine">      Signedness SY = (j + 1 == f) ? SgnY : Unsigned;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="uncoveredLine">      auto [Lo, Hi] = createMul32(Builder, {WordX[i], SX}, {WordY[j], SY});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="uncoveredLine">      Products[i + j + 0].push_back(Lo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="uncoveredLine">      Products[i + j + 1].push_back(Hi);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="uncoveredLine">  Value *Zero = HVC.getNullValue(WordX[0]->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="uncoveredLine">  auto pop_back_or_zero = [Zero](auto &Vector) -> Value * {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="uncoveredLine">    if (Vector.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="uncoveredLine">      return Zero;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="uncoveredLine">    auto Last = Vector.back();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="uncoveredLine">    Vector.pop_back();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="uncoveredLine">    return Last;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="uncoveredLine">  for (int i = 0, e = Products.size(); i != e; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="uncoveredLine">    while (Products[i].size() > 1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="uncoveredLine">      Value *Carry = nullptr; // no carry-in</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="uncoveredLine">      for (int j = i; j != e; ++j) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="uncoveredLine">        auto &ProdJ = Products[j];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="uncoveredLine">        auto [Sum, CarryOut] = createAddCarry(Builder, pop_back_or_zero(ProdJ),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="">                                              pop_back_or_zero(ProdJ), Carry);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="uncoveredLine">        ProdJ.insert(ProdJ.begin(), Sum);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="uncoveredLine">        Carry = CarryOut;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="uncoveredLine">  SmallVector<Value *> WordP;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="uncoveredLine">  for (auto &P : Products) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="uncoveredLine">    assert(P.size() == 1 && "Should have been added together");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="uncoveredLine">    WordP.push_back(P.front());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="uncoveredLine">  return WordP;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="uncoveredLine">auto HvxIdioms::run() -> bool {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="uncoveredLine">  bool Changed = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="uncoveredLine">  for (BasicBlock &B : HVC.F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="uncoveredLine">    for (auto It = B.rbegin(); It != B.rend(); ++It) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="uncoveredLine">      if (auto Fxm = matchFxpMul(*It)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="uncoveredLine">        Value *New = processFxpMul(*It, *Fxm);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="">        // Always report "changed" for now.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="uncoveredLine">        Changed = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="uncoveredLine">        if (!New)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="uncoveredLine">        bool StartOver = !isa<Instruction>(New);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="uncoveredLine">        It->replaceAllUsesWith(New);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="uncoveredLine">        RecursivelyDeleteTriviallyDeadInstructions(&*It, &HVC.TLI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="uncoveredLine">        It = StartOver ? B.rbegin()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="uncoveredLine">                       : cast<Instruction>(New)->getReverseIterator();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="uncoveredLine">        Changed = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="uncoveredLine">  return Changed;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="">// --- End HvxIdioms</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::run() -> bool {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="uncoveredLine">  if (DumpModule)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="uncoveredLine">    dbgs() << "Module before HexagonVectorCombine\n" << *F.getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="uncoveredLine">  bool Changed = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="uncoveredLine">  if (HST.useHVXOps()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="uncoveredLine">    if (VAEnabled)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="uncoveredLine">      Changed |= AlignVectors(*this).run();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="uncoveredLine">    if (VIEnabled)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="uncoveredLine">      Changed |= HvxIdioms(*this).run();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="uncoveredLine">  if (DumpModule) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="uncoveredLine">    dbgs() << "Module " << (Changed ? "(modified)" : "(unchanged)")</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="">           << " after HexagonVectorCombine\n"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="uncoveredLine">           << *F.getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="uncoveredLine">  return Changed;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::getIntTy(unsigned Width) const -> IntegerType * {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="uncoveredLine">  return IntegerType::get(F.getContext(), Width);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::getByteTy(int ElemCount) const -> Type * {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="uncoveredLine">  assert(ElemCount >= 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="uncoveredLine">  IntegerType *ByteTy = Type::getInt8Ty(F.getContext());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="uncoveredLine">  if (ElemCount == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="uncoveredLine">    return ByteTy;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="uncoveredLine">  return VectorType::get(ByteTy, ElemCount, /*Scalable=*/false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::getBoolTy(int ElemCount) const -> Type * {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="uncoveredLine">  assert(ElemCount >= 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="uncoveredLine">  IntegerType *BoolTy = Type::getInt1Ty(F.getContext());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="uncoveredLine">  if (ElemCount == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="uncoveredLine">    return BoolTy;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="uncoveredLine">  return VectorType::get(BoolTy, ElemCount, /*Scalable=*/false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::getConstInt(int Val, unsigned Width) const</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="">    -> ConstantInt * {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="uncoveredLine">  return ConstantInt::getSigned(getIntTy(Width), Val);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::isZero(const Value *Val) const -> bool {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="uncoveredLine">  if (auto *C = dyn_cast<Constant>(Val))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="uncoveredLine">    return C->isZeroValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::getIntValue(const Value *Val) const</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="">    -> std::optional<APInt> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="uncoveredLine">  if (auto *CI = dyn_cast<ConstantInt>(Val))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="uncoveredLine">    return CI->getValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="uncoveredLine">  return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::isUndef(const Value *Val) const -> bool {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="uncoveredLine">  return isa<UndefValue>(Val);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::isTrue(const Value *Val) const -> bool {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="uncoveredLine">  return Val == ConstantInt::getTrue(Val->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::isFalse(const Value *Val) const -> bool {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="uncoveredLine">  return isZero(Val);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::getHvxTy(Type *ElemTy, bool Pair) const</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="">    -> VectorType * {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="uncoveredLine">  EVT ETy = EVT::getEVT(ElemTy, false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="uncoveredLine">  assert(ETy.isSimple() && "Invalid HVX element type");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="">  // Do not allow boolean types here: they don't have a fixed length.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="uncoveredLine">  assert(HST.isHVXElementType(ETy.getSimpleVT(), /*IncludeBool=*/false) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="">         "Invalid HVX element type");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="uncoveredLine">  unsigned HwLen = HST.getVectorLength();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="uncoveredLine">  unsigned NumElems = (8 * HwLen) / ETy.getSizeInBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="uncoveredLine">  return VectorType::get(ElemTy, Pair ? 2 * NumElems : NumElems,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="uncoveredLine">                         /*Scalable=*/false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::getSizeOf(const Value *Val, SizeKind Kind) const</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="">    -> int {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="uncoveredLine">  return getSizeOf(Val->getType(), Kind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::getSizeOf(const Type *Ty, SizeKind Kind) const</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="">    -> int {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="uncoveredLine">  auto *NcTy = const_cast<Type *>(Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="uncoveredLine">  switch (Kind) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="uncoveredLine">  case Store:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="uncoveredLine">    return DL.getTypeStoreSize(NcTy).getFixedValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="uncoveredLine">  case Alloc:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="uncoveredLine">    return DL.getTypeAllocSize(NcTy).getFixedValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="uncoveredLine">  llvm_unreachable("Unhandled SizeKind enum");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::getTypeAlignment(Type *Ty) const -> int {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="">  // The actual type may be shorter than the HVX vector, so determine</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="">  // the alignment based on subtarget info.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="uncoveredLine">  if (HST.isTypeForHVX(Ty))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="uncoveredLine">    return HST.getVectorLength();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="uncoveredLine">  return DL.getABITypeAlign(Ty).value();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::length(Value *Val) const -> size_t {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="uncoveredLine">  return length(Val->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::length(Type *Ty) const -> size_t {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="uncoveredLine">  auto *VecTy = dyn_cast<VectorType>(Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="uncoveredLine">  assert(VecTy && "Must be a vector type");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="uncoveredLine">  return VecTy->getElementCount().getFixedValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::getNullValue(Type *Ty) const -> Constant * {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="uncoveredLine">  assert(Ty->isIntOrIntVectorTy());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="uncoveredLine">  auto Zero = ConstantInt::get(Ty->getScalarType(), 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="uncoveredLine">  if (auto *VecTy = dyn_cast<VectorType>(Ty))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="uncoveredLine">    return ConstantVector::getSplat(VecTy->getElementCount(), Zero);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="uncoveredLine">  return Zero;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::getFullValue(Type *Ty) const -> Constant * {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="uncoveredLine">  assert(Ty->isIntOrIntVectorTy());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="uncoveredLine">  auto Minus1 = ConstantInt::get(Ty->getScalarType(), -1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="uncoveredLine">  if (auto *VecTy = dyn_cast<VectorType>(Ty))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="uncoveredLine">    return ConstantVector::getSplat(VecTy->getElementCount(), Minus1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="uncoveredLine">  return Minus1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::getConstSplat(Type *Ty, int Val) const</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="">    -> Constant * {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="uncoveredLine">  assert(Ty->isVectorTy());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="uncoveredLine">  auto VecTy = cast<VectorType>(Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="uncoveredLine">  Type *ElemTy = VecTy->getElementType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="">  // Add support for floats if needed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="uncoveredLine">  auto *Splat = ConstantVector::getSplat(VecTy->getElementCount(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="">                                         ConstantInt::get(ElemTy, Val));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="uncoveredLine">  return Splat;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::simplify(Value *V) const -> Value * {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="uncoveredLine">  if (auto *In = dyn_cast<Instruction>(V)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="uncoveredLine">    SimplifyQuery Q(DL, &TLI, &DT, &AC, In);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="uncoveredLine">    return simplifyInstruction(In, Q);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="uncoveredLine">  return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="">// Insert bytes [Start..Start+Length) of Src into Dst at byte Where.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::insertb(IRBuilderBase &Builder, Value *Dst,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="">                                   Value *Src, int Start, int Length,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="">                                   int Where) const -> Value * {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="uncoveredLine">  assert(isByteVecTy(Dst->getType()) && isByteVecTy(Src->getType()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="uncoveredLine">  int SrcLen = getSizeOf(Src);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="uncoveredLine">  int DstLen = getSizeOf(Dst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="uncoveredLine">  assert(0 <= Start && Start + Length <= SrcLen);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="uncoveredLine">  assert(0 <= Where && Where + Length <= DstLen);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="uncoveredLine">  int P2Len = PowerOf2Ceil(SrcLen | DstLen);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="uncoveredLine">  auto *Undef = UndefValue::get(getByteTy());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="uncoveredLine">  Value *P2Src = vresize(Builder, Src, P2Len, Undef);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="uncoveredLine">  Value *P2Dst = vresize(Builder, Dst, P2Len, Undef);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="uncoveredLine">  SmallVector<int, 256> SMask(P2Len);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="uncoveredLine">  for (int i = 0; i != P2Len; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="">    // If i is in [Where, Where+Length), pick Src[Start+(i-Where)].</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="">    // Otherwise, pick Dst[i];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="uncoveredLine">    SMask[i] =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="uncoveredLine">        (Where <= i && i < Where + Length) ? P2Len + Start + (i - Where) : i;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="uncoveredLine">  Value *P2Insert = Builder.CreateShuffleVector(P2Dst, P2Src, SMask, "shf");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="uncoveredLine">  return vresize(Builder, P2Insert, DstLen, Undef);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::vlalignb(IRBuilderBase &Builder, Value *Lo,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="">                                    Value *Hi, Value *Amt) const -> Value * {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="uncoveredLine">  assert(Lo->getType() == Hi->getType() && "Argument type mismatch");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="uncoveredLine">  if (isZero(Amt))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="uncoveredLine">    return Hi;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="uncoveredLine">  int VecLen = getSizeOf(Hi);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="uncoveredLine">  if (auto IntAmt = getIntValue(Amt))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="uncoveredLine">    return getElementRange(Builder, Lo, Hi, VecLen - IntAmt->getSExtValue(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="uncoveredLine">                           VecLen);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="uncoveredLine">  if (HST.isTypeForHVX(Hi->getType())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="uncoveredLine">    assert(static_cast<unsigned>(VecLen) == HST.getVectorLength() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="">           "Expecting an exact HVX type");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="uncoveredLine">    return createHvxIntrinsic(Builder, HST.getIntrinsicId(Hexagon::V6_vlalignb),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="uncoveredLine">                              Hi->getType(), {Hi, Lo, Amt});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="uncoveredLine">  if (VecLen == 4) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="uncoveredLine">    Value *Pair = concat(Builder, {Lo, Hi});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="">    Value *Shift =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="uncoveredLine">        Builder.CreateLShr(Builder.CreateShl(Pair, Amt, "shl"), 32, "lsr");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="">    Value *Trunc =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="uncoveredLine">        Builder.CreateTrunc(Shift, Type::getInt32Ty(F.getContext()), "trn");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="uncoveredLine">    return Builder.CreateBitCast(Trunc, Hi->getType(), "cst");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="uncoveredLine">  if (VecLen == 8) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="uncoveredLine">    Value *Sub = Builder.CreateSub(getConstInt(VecLen), Amt, "sub");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="uncoveredLine">    return vralignb(Builder, Lo, Hi, Sub);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="uncoveredLine">  llvm_unreachable("Unexpected vector length");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::vralignb(IRBuilderBase &Builder, Value *Lo,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="">                                    Value *Hi, Value *Amt) const -> Value * {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="uncoveredLine">  assert(Lo->getType() == Hi->getType() && "Argument type mismatch");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="uncoveredLine">  if (isZero(Amt))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="uncoveredLine">    return Lo;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="uncoveredLine">  int VecLen = getSizeOf(Lo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="uncoveredLine">  if (auto IntAmt = getIntValue(Amt))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="uncoveredLine">    return getElementRange(Builder, Lo, Hi, IntAmt->getSExtValue(), VecLen);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="uncoveredLine">  if (HST.isTypeForHVX(Lo->getType())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="uncoveredLine">    assert(static_cast<unsigned>(VecLen) == HST.getVectorLength() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="">           "Expecting an exact HVX type");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="uncoveredLine">    return createHvxIntrinsic(Builder, HST.getIntrinsicId(Hexagon::V6_valignb),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="uncoveredLine">                              Lo->getType(), {Hi, Lo, Amt});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="uncoveredLine">  if (VecLen == 4) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="uncoveredLine">    Value *Pair = concat(Builder, {Lo, Hi});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="uncoveredLine">    Value *Shift = Builder.CreateLShr(Pair, Amt, "lsr");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="">    Value *Trunc =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="uncoveredLine">        Builder.CreateTrunc(Shift, Type::getInt32Ty(F.getContext()), "trn");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="uncoveredLine">    return Builder.CreateBitCast(Trunc, Lo->getType(), "cst");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="uncoveredLine">  if (VecLen == 8) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="uncoveredLine">    Type *Int64Ty = Type::getInt64Ty(F.getContext());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="uncoveredLine">    Value *Lo64 = Builder.CreateBitCast(Lo, Int64Ty, "cst");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="uncoveredLine">    Value *Hi64 = Builder.CreateBitCast(Hi, Int64Ty, "cst");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="uncoveredLine">    Function *FI = Intrinsic::getDeclaration(F.getParent(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="">                                             Intrinsic::hexagon_S2_valignrb);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="uncoveredLine">    Value *Call = Builder.CreateCall(FI, {Hi64, Lo64, Amt}, "cup");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="uncoveredLine">    return Builder.CreateBitCast(Call, Lo->getType(), "cst");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="uncoveredLine">  llvm_unreachable("Unexpected vector length");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="">// Concatenates a sequence of vectors of the same type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::concat(IRBuilderBase &Builder,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="">                                  ArrayRef<Value *> Vecs) const -> Value * {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="uncoveredLine">  assert(!Vecs.empty());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="uncoveredLine">  SmallVector<int, 256> SMask;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="uncoveredLine">  std::vector<Value *> Work[2];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="uncoveredLine">  int ThisW = 0, OtherW = 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="uncoveredLine">  Work[ThisW].assign(Vecs.begin(), Vecs.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="uncoveredLine">  while (Work[ThisW].size() > 1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="uncoveredLine">    auto *Ty = cast<VectorType>(Work[ThisW].front()->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="uncoveredLine">    SMask.resize(length(Ty) * 2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="uncoveredLine">    std::iota(SMask.begin(), SMask.end(), 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="uncoveredLine">    Work[OtherW].clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="uncoveredLine">    if (Work[ThisW].size() % 2 != 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="uncoveredLine">      Work[ThisW].push_back(UndefValue::get(Ty));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="uncoveredLine">    for (int i = 0, e = Work[ThisW].size(); i < e; i += 2) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="uncoveredLine">      Value *Joined = Builder.CreateShuffleVector(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="uncoveredLine">          Work[ThisW][i], Work[ThisW][i + 1], SMask, "shf");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="uncoveredLine">      Work[OtherW].push_back(Joined);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="uncoveredLine">    std::swap(ThisW, OtherW);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="">  // Since there may have been some undefs appended to make shuffle operands</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="">  // have the same type, perform the last shuffle to only pick the original</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="">  // elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="uncoveredLine">  SMask.resize(Vecs.size() * length(Vecs.front()->getType()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="uncoveredLine">  std::iota(SMask.begin(), SMask.end(), 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="uncoveredLine">  Value *Total = Work[ThisW].front();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="uncoveredLine">  return Builder.CreateShuffleVector(Total, SMask, "shf");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::vresize(IRBuilderBase &Builder, Value *Val,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="">                                   int NewSize, Value *Pad) const -> Value * {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="uncoveredLine">  assert(isa<VectorType>(Val->getType()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="uncoveredLine">  auto *ValTy = cast<VectorType>(Val->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="uncoveredLine">  assert(ValTy->getElementType() == Pad->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="uncoveredLine">  int CurSize = length(ValTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="uncoveredLine">  if (CurSize == NewSize)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="uncoveredLine">    return Val;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="">  // Truncate?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="uncoveredLine">  if (CurSize > NewSize)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="uncoveredLine">    return getElementRange(Builder, Val, /*Ignored*/ Val, 0, NewSize);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="">  // Extend.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="uncoveredLine">  SmallVector<int, 128> SMask(NewSize);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="uncoveredLine">  std::iota(SMask.begin(), SMask.begin() + CurSize, 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="uncoveredLine">  std::fill(SMask.begin() + CurSize, SMask.end(), CurSize);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="uncoveredLine">  Value *PadVec = Builder.CreateVectorSplat(CurSize, Pad, "spt");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="uncoveredLine">  return Builder.CreateShuffleVector(Val, PadVec, SMask, "shf");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::rescale(IRBuilderBase &Builder, Value *Mask,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="">                                   Type *FromTy, Type *ToTy) const -> Value * {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="">  // Mask is a vector <N x i1>, where each element corresponds to an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="">  // element of FromTy. Remap it so that each element will correspond</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="">  // to an element of ToTy.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="uncoveredLine">  assert(isa<VectorType>(Mask->getType()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="uncoveredLine">  Type *FromSTy = FromTy->getScalarType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="uncoveredLine">  Type *ToSTy = ToTy->getScalarType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="uncoveredLine">  if (FromSTy == ToSTy)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="uncoveredLine">    return Mask;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="uncoveredLine">  int FromSize = getSizeOf(FromSTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="uncoveredLine">  int ToSize = getSizeOf(ToSTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="uncoveredLine">  assert(FromSize % ToSize == 0 || ToSize % FromSize == 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="uncoveredLine">  auto *MaskTy = cast<VectorType>(Mask->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="uncoveredLine">  int FromCount = length(MaskTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2475</td>
    <td class="uncoveredLine">  int ToCount = (FromCount * FromSize) / ToSize;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2476</td>
    <td class="uncoveredLine">  assert((FromCount * FromSize) % ToSize == 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2477</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2478</td>
    <td class="uncoveredLine">  auto *FromITy = getIntTy(FromSize * 8);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2479</td>
    <td class="uncoveredLine">  auto *ToITy = getIntTy(ToSize * 8);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2480</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2481</td>
    <td class="">  // Mask <N x i1> -> sext to <N x FromTy> -> bitcast to <M x ToTy> -></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2482</td>
    <td class="">  // -> trunc to <M x i1>.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2483</td>
    <td class="uncoveredLine">  Value *Ext = Builder.CreateSExt(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2484</td>
    <td class="uncoveredLine">      Mask, VectorType::get(FromITy, FromCount, /*Scalable=*/false), "sxt");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2485</td>
    <td class="uncoveredLine">  Value *Cast = Builder.CreateBitCast(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2486</td>
    <td class="uncoveredLine">      Ext, VectorType::get(ToITy, ToCount, /*Scalable=*/false), "cst");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2487</td>
    <td class="uncoveredLine">  return Builder.CreateTrunc(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2488</td>
    <td class="uncoveredLine">      Cast, VectorType::get(getBoolTy(), ToCount, /*Scalable=*/false), "trn");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2489</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2490</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2491</td>
    <td class="">// Bitcast to bytes, and return least significant bits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2492</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::vlsb(IRBuilderBase &Builder, Value *Val) const</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2493</td>
    <td class="">    -> Value * {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2494</td>
    <td class="uncoveredLine">  Type *ScalarTy = Val->getType()->getScalarType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2495</td>
    <td class="uncoveredLine">  if (ScalarTy == getBoolTy())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2496</td>
    <td class="uncoveredLine">    return Val;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2497</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2498</td>
    <td class="uncoveredLine">  Value *Bytes = vbytes(Builder, Val);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2499</td>
    <td class="uncoveredLine">  if (auto *VecTy = dyn_cast<VectorType>(Bytes->getType()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2500</td>
    <td class="uncoveredLine">    return Builder.CreateTrunc(Bytes, getBoolTy(getSizeOf(VecTy)), "trn");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2501</td>
    <td class="">  // If Bytes is a scalar (i.e. Val was a scalar byte), return i1, not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2502</td>
    <td class="">  // <1 x i1>.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2503</td>
    <td class="uncoveredLine">  return Builder.CreateTrunc(Bytes, getBoolTy(), "trn");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2504</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2505</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2506</td>
    <td class="">// Bitcast to bytes for non-bool. For bool, convert i1 -> i8.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2507</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::vbytes(IRBuilderBase &Builder, Value *Val) const</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2508</td>
    <td class="">    -> Value * {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2509</td>
    <td class="uncoveredLine">  Type *ScalarTy = Val->getType()->getScalarType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2510</td>
    <td class="uncoveredLine">  if (ScalarTy == getByteTy())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2511</td>
    <td class="uncoveredLine">    return Val;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2512</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2513</td>
    <td class="uncoveredLine">  if (ScalarTy != getBoolTy())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2514</td>
    <td class="uncoveredLine">    return Builder.CreateBitCast(Val, getByteTy(getSizeOf(Val)), "cst");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2515</td>
    <td class="">  // For bool, return a sext from i1 to i8.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2516</td>
    <td class="uncoveredLine">  if (auto *VecTy = dyn_cast<VectorType>(Val->getType()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2517</td>
    <td class="uncoveredLine">    return Builder.CreateSExt(Val, VectorType::get(getByteTy(), VecTy), "sxt");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2518</td>
    <td class="uncoveredLine">  return Builder.CreateSExt(Val, getByteTy(), "sxt");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2519</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2520</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2521</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::subvector(IRBuilderBase &Builder, Value *Val,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2522</td>
    <td class="">                                     unsigned Start, unsigned Length) const</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2523</td>
    <td class="">    -> Value * {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2524</td>
    <td class="uncoveredLine">  assert(Start + Length <= length(Val));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2525</td>
    <td class="uncoveredLine">  return getElementRange(Builder, Val, /*Ignored*/ Val, Start, Length);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2526</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2527</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2528</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::sublo(IRBuilderBase &Builder, Value *Val) const</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2529</td>
    <td class="">    -> Value * {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2530</td>
    <td class="uncoveredLine">  size_t Len = length(Val);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2531</td>
    <td class="uncoveredLine">  assert(Len % 2 == 0 && "Length should be even");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2532</td>
    <td class="uncoveredLine">  return subvector(Builder, Val, 0, Len / 2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2533</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2534</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2535</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::subhi(IRBuilderBase &Builder, Value *Val) const</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2536</td>
    <td class="">    -> Value * {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2537</td>
    <td class="uncoveredLine">  size_t Len = length(Val);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2538</td>
    <td class="uncoveredLine">  assert(Len % 2 == 0 && "Length should be even");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2539</td>
    <td class="uncoveredLine">  return subvector(Builder, Val, Len / 2, Len / 2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2540</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2541</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2542</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::vdeal(IRBuilderBase &Builder, Value *Val0,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2543</td>
    <td class="">                                 Value *Val1) const -> Value * {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2544</td>
    <td class="uncoveredLine">  assert(Val0->getType() == Val1->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2545</td>
    <td class="uncoveredLine">  int Len = length(Val0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2546</td>
    <td class="uncoveredLine">  SmallVector<int, 128> Mask(2 * Len);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2547</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2548</td>
    <td class="uncoveredLine">  for (int i = 0; i != Len; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2549</td>
    <td class="uncoveredLine">    Mask[i] = 2 * i;           // Even</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2550</td>
    <td class="uncoveredLine">    Mask[i + Len] = 2 * i + 1; // Odd</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2551</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2552</td>
    <td class="uncoveredLine">  return Builder.CreateShuffleVector(Val0, Val1, Mask, "shf");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2553</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2554</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2555</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::vshuff(IRBuilderBase &Builder, Value *Val0,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2556</td>
    <td class="">                                  Value *Val1) const -> Value * { //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2557</td>
    <td class="uncoveredLine">  assert(Val0->getType() == Val1->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2558</td>
    <td class="uncoveredLine">  int Len = length(Val0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2559</td>
    <td class="uncoveredLine">  SmallVector<int, 128> Mask(2 * Len);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2560</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2561</td>
    <td class="uncoveredLine">  for (int i = 0; i != Len; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2562</td>
    <td class="uncoveredLine">    Mask[2 * i + 0] = i;       // Val0</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2563</td>
    <td class="uncoveredLine">    Mask[2 * i + 1] = i + Len; // Val1</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2564</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2565</td>
    <td class="uncoveredLine">  return Builder.CreateShuffleVector(Val0, Val1, Mask, "shf");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2566</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2567</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2568</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::createHvxIntrinsic(IRBuilderBase &Builder,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2569</td>
    <td class="">                                              Intrinsic::ID IntID, Type *RetTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2570</td>
    <td class="">                                              ArrayRef<Value *> Args,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2571</td>
    <td class="">                                              ArrayRef<Type *> ArgTys,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2572</td>
    <td class="">                                              ArrayRef<Value *> MDSources) const</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2573</td>
    <td class="">    -> Value * {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2574</td>
    <td class="uncoveredLine">  auto getCast = [&](IRBuilderBase &Builder, Value *Val,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2575</td>
    <td class="">                     Type *DestTy) -> Value * {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2576</td>
    <td class="uncoveredLine">    Type *SrcTy = Val->getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2577</td>
    <td class="uncoveredLine">    if (SrcTy == DestTy)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2578</td>
    <td class="uncoveredLine">      return Val;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2579</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2580</td>
    <td class="">    // Non-HVX type. It should be a scalar, and it should already have</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2581</td>
    <td class="">    // a valid type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2582</td>
    <td class="uncoveredLine">    assert(HST.isTypeForHVX(SrcTy, /*IncludeBool=*/true));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2583</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2584</td>
    <td class="uncoveredLine">    Type *BoolTy = Type::getInt1Ty(F.getContext());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2585</td>
    <td class="uncoveredLine">    if (cast<VectorType>(SrcTy)->getElementType() != BoolTy)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2586</td>
    <td class="uncoveredLine">      return Builder.CreateBitCast(Val, DestTy, "cst");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2587</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2588</td>
    <td class="">    // Predicate HVX vector.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2589</td>
    <td class="uncoveredLine">    unsigned HwLen = HST.getVectorLength();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2590</td>
    <td class="uncoveredLine">    Intrinsic::ID TC = HwLen == 64 ? Intrinsic::hexagon_V6_pred_typecast</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2591</td>
    <td class="">                                   : Intrinsic::hexagon_V6_pred_typecast_128B;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2592</td>
    <td class="">    Function *FI =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2593</td>
    <td class="uncoveredLine">        Intrinsic::getDeclaration(F.getParent(), TC, {DestTy, Val->getType()});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2594</td>
    <td class="uncoveredLine">    return Builder.CreateCall(FI, {Val}, "cup");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2595</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2596</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2597</td>
    <td class="uncoveredLine">  Function *IntrFn = Intrinsic::getDeclaration(F.getParent(), IntID, ArgTys);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2598</td>
    <td class="uncoveredLine">  FunctionType *IntrTy = IntrFn->getFunctionType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2599</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2600</td>
    <td class="uncoveredLine">  SmallVector<Value *, 4> IntrArgs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2601</td>
    <td class="uncoveredLine">  for (int i = 0, e = Args.size(); i != e; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2602</td>
    <td class="uncoveredLine">    Value *A = Args[i];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2603</td>
    <td class="uncoveredLine">    Type *T = IntrTy->getParamType(i);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2604</td>
    <td class="uncoveredLine">    if (A->getType() != T) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2605</td>
    <td class="uncoveredLine">      IntrArgs.push_back(getCast(Builder, A, T));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2606</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2607</td>
    <td class="uncoveredLine">      IntrArgs.push_back(A);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2608</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2609</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2610</td>
    <td class="uncoveredLine">  StringRef MaybeName = !IntrTy->getReturnType()->isVoidTy() ? "cup" : "";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2611</td>
    <td class="uncoveredLine">  CallInst *Call = Builder.CreateCall(IntrFn, IntrArgs, MaybeName);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2612</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2613</td>
    <td class="uncoveredLine">  MemoryEffects ME = Call->getAttributes().getMemoryEffects();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2614</td>
    <td class="uncoveredLine">  if (!ME.doesNotAccessMemory() && !ME.onlyAccessesInaccessibleMem())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2615</td>
    <td class="uncoveredLine">    propagateMetadata(Call, MDSources);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2616</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2617</td>
    <td class="uncoveredLine">  Type *CallTy = Call->getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2618</td>
    <td class="uncoveredLine">  if (RetTy == nullptr || CallTy == RetTy)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2619</td>
    <td class="uncoveredLine">    return Call;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2620</td>
    <td class="">  // Scalar types should have RetTy matching the call return type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2621</td>
    <td class="uncoveredLine">  assert(HST.isTypeForHVX(CallTy, /*IncludeBool=*/true));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2622</td>
    <td class="uncoveredLine">  return getCast(Builder, Call, RetTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2623</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2624</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2625</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::splitVectorElements(IRBuilderBase &Builder,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2626</td>
    <td class="">                                               Value *Vec,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2627</td>
    <td class="">                                               unsigned ToWidth) const</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2628</td>
    <td class="">    -> SmallVector<Value *> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2629</td>
    <td class="">  // Break a vector of wide elements into a series of vectors with narrow</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2630</td>
    <td class="">  // elements:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2631</td>
    <td class="">  //   (...c0:b0:a0, ...c1:b1:a1, ...c2:b2:a2, ...)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2632</td>
    <td class="">  // --></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2633</td>
    <td class="">  //   (a0, a1, a2, ...)    // lowest "ToWidth" bits</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2634</td>
    <td class="">  //   (b0, b1, b2, ...)    // the next lowest...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2635</td>
    <td class="">  //   (c0, c1, c2, ...)    // ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2636</td>
    <td class="">  //   ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2637</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2638</td>
    <td class="">  // The number of elements in each resulting vector is the same as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2639</td>
    <td class="">  // in the original vector.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2640</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2641</td>
    <td class="uncoveredLine">  auto *VecTy = cast<VectorType>(Vec->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2642</td>
    <td class="uncoveredLine">  assert(VecTy->getElementType()->isIntegerTy());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2643</td>
    <td class="uncoveredLine">  unsigned FromWidth = VecTy->getScalarSizeInBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2644</td>
    <td class="uncoveredLine">  assert(isPowerOf2_32(ToWidth) && isPowerOf2_32(FromWidth));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2645</td>
    <td class="uncoveredLine">  assert(ToWidth <= FromWidth && "Breaking up into wider elements?");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2646</td>
    <td class="uncoveredLine">  unsigned NumResults = FromWidth / ToWidth;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2647</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2648</td>
    <td class="uncoveredLine">  SmallVector<Value *> Results(NumResults);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2649</td>
    <td class="uncoveredLine">  Results[0] = Vec;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2650</td>
    <td class="uncoveredLine">  unsigned Length = length(VecTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2651</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2652</td>
    <td class="">  // Do it by splitting in half, since those operations correspond to deal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2653</td>
    <td class="">  // instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2654</td>
    <td class="uncoveredLine">  auto splitInHalf = [&](unsigned Begin, unsigned End, auto splitFunc) -> void {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2655</td>
    <td class="">    // Take V = Results[Begin], split it in L, H.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2656</td>
    <td class="">    // Store Results[Begin] = L, Results[(Begin+End)/2] = H</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2657</td>
    <td class="">    // Call itself recursively split(Begin, Half), split(Half+1, End)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2658</td>
    <td class="uncoveredLine">    if (Begin + 1 == End)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2659</td>
    <td class="uncoveredLine">      return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2660</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2661</td>
    <td class="uncoveredLine">    Value *Val = Results[Begin];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2662</td>
    <td class="uncoveredLine">    unsigned Width = Val->getType()->getScalarSizeInBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2663</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2664</td>
    <td class="uncoveredLine">    auto *VTy = VectorType::get(getIntTy(Width / 2), 2 * Length, false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2665</td>
    <td class="uncoveredLine">    Value *VVal = Builder.CreateBitCast(Val, VTy, "cst");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2666</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2667</td>
    <td class="uncoveredLine">    Value *Res = vdeal(Builder, sublo(Builder, VVal), subhi(Builder, VVal));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2668</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2669</td>
    <td class="uncoveredLine">    unsigned Half = (Begin + End) / 2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2670</td>
    <td class="uncoveredLine">    Results[Begin] = sublo(Builder, Res);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2671</td>
    <td class="uncoveredLine">    Results[Half] = subhi(Builder, Res);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2672</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2673</td>
    <td class="uncoveredLine">    splitFunc(Begin, Half, splitFunc);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2674</td>
    <td class="uncoveredLine">    splitFunc(Half, End, splitFunc);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2675</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2676</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2677</td>
    <td class="uncoveredLine">  splitInHalf(0, NumResults, splitInHalf);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2678</td>
    <td class="uncoveredLine">  return Results;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2679</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2680</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2681</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::joinVectorElements(IRBuilderBase &Builder,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2682</td>
    <td class="">                                              ArrayRef<Value *> Values,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2683</td>
    <td class="">                                              VectorType *ToType) const</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2684</td>
    <td class="">    -> Value * {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2685</td>
    <td class="uncoveredLine">  assert(ToType->getElementType()->isIntegerTy());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2686</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2687</td>
    <td class="">  // If the list of values does not have power-of-2 elements, append copies</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2688</td>
    <td class="">  // of the sign bit to it, to make the size be 2^n.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2689</td>
    <td class="">  // The reason for this is that the values will be joined in pairs, because</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2690</td>
    <td class="">  // otherwise the shuffles will result in convoluted code. With pairwise</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2691</td>
    <td class="">  // joins, the shuffles will hopefully be folded into a perfect shuffle.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2692</td>
    <td class="">  // The output will need to be sign-extended to a type with element width</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2693</td>
    <td class="">  // being a power-of-2 anyways.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2694</td>
    <td class="uncoveredLine">  SmallVector<Value *> Inputs(Values.begin(), Values.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2695</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2696</td>
    <td class="uncoveredLine">  unsigned ToWidth = ToType->getScalarSizeInBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2697</td>
    <td class="uncoveredLine">  unsigned Width = Inputs.front()->getType()->getScalarSizeInBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2698</td>
    <td class="uncoveredLine">  assert(Width <= ToWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2699</td>
    <td class="uncoveredLine">  assert(isPowerOf2_32(Width) && isPowerOf2_32(ToWidth));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2700</td>
    <td class="uncoveredLine">  unsigned Length = length(Inputs.front()->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2701</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2702</td>
    <td class="uncoveredLine">  unsigned NeedInputs = ToWidth / Width;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2703</td>
    <td class="uncoveredLine">  if (Inputs.size() != NeedInputs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2704</td>
    <td class="">    // Having too many inputs is ok: drop the high bits (usual wrap-around).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2705</td>
    <td class="">    // If there are too few, fill them with the sign bit.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2706</td>
    <td class="uncoveredLine">    Value *Last = Inputs.back();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2707</td>
    <td class="uncoveredLine">    Value *Sign = Builder.CreateAShr(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2708</td>
    <td class="uncoveredLine">        Last, getConstSplat(Last->getType(), Width - 1), "asr");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2709</td>
    <td class="uncoveredLine">    Inputs.resize(NeedInputs, Sign);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2710</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2711</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2712</td>
    <td class="uncoveredLine">  while (Inputs.size() > 1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2713</td>
    <td class="uncoveredLine">    Width *= 2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2714</td>
    <td class="uncoveredLine">    auto *VTy = VectorType::get(getIntTy(Width), Length, false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2715</td>
    <td class="uncoveredLine">    for (int i = 0, e = Inputs.size(); i < e; i += 2) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2716</td>
    <td class="uncoveredLine">      Value *Res = vshuff(Builder, Inputs[i], Inputs[i + 1]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2717</td>
    <td class="uncoveredLine">      Inputs[i / 2] = Builder.CreateBitCast(Res, VTy, "cst");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2718</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2719</td>
    <td class="uncoveredLine">    Inputs.resize(Inputs.size() / 2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2720</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2721</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2722</td>
    <td class="uncoveredLine">  assert(Inputs.front()->getType() == ToType);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2723</td>
    <td class="uncoveredLine">  return Inputs.front();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2724</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2725</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2726</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::calculatePointerDifference(Value *Ptr0,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2727</td>
    <td class="">                                                      Value *Ptr1) const</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2728</td>
    <td class="">    -> std::optional<int> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2729</td>
    <td class="">  // Try SCEV first.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2730</td>
    <td class="uncoveredLine">  const SCEV *Scev0 = SE.getSCEV(Ptr0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2731</td>
    <td class="uncoveredLine">  const SCEV *Scev1 = SE.getSCEV(Ptr1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2732</td>
    <td class="uncoveredLine">  const SCEV *ScevDiff = SE.getMinusSCEV(Scev0, Scev1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2733</td>
    <td class="uncoveredLine">  if (auto *Const = dyn_cast<SCEVConstant>(ScevDiff)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2734</td>
    <td class="uncoveredLine">    APInt V = Const->getAPInt();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2735</td>
    <td class="uncoveredLine">    if (V.isSignedIntN(8 * sizeof(int)))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2736</td>
    <td class="uncoveredLine">      return static_cast<int>(V.getSExtValue());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2737</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2738</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2739</td>
    <td class="">  struct Builder : IRBuilder<> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2740</td>
    <td class="uncoveredLine">    Builder(BasicBlock *B) : IRBuilder<>(B->getTerminator()) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2741</td>
    <td class="uncoveredLine">    ~Builder() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2742</td>
    <td class="uncoveredLine">      for (Instruction *I : llvm::reverse(ToErase))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2743</td>
    <td class="uncoveredLine">        I->eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2744</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2745</td>
    <td class="">    SmallVector<Instruction *, 8> ToErase;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2746</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2747</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2748</td>
    <td class="">#define CallBuilder(B, F)                                                      \</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2749</td>
    <td class="">  [&](auto &B_) {                                                              \</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2750</td>
    <td class="">    Value *V = B_.F;                                                           \</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2751</td>
    <td class="">    if (auto *I = dyn_cast<Instruction>(V))                                    \</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2752</td>
    <td class="">      B_.ToErase.push_back(I);                                                 \</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2753</td>
    <td class="">    return V;                                                                  \</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2754</td>
    <td class="">  }(B)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2755</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2756</td>
    <td class="uncoveredLine">  auto Simplify = [this](Value *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2757</td>
    <td class="uncoveredLine">    if (Value *S = simplify(V))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2758</td>
    <td class="uncoveredLine">      return S;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2759</td>
    <td class="uncoveredLine">    return V;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2760</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2761</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2762</td>
    <td class="uncoveredLine">  auto StripBitCast = [](Value *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2763</td>
    <td class="uncoveredLine">    while (auto *C = dyn_cast<BitCastInst>(V))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2764</td>
    <td class="uncoveredLine">      V = C->getOperand(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2765</td>
    <td class="uncoveredLine">    return V;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2766</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2767</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2768</td>
    <td class="uncoveredLine">  Ptr0 = StripBitCast(Ptr0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2769</td>
    <td class="uncoveredLine">  Ptr1 = StripBitCast(Ptr1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2770</td>
    <td class="uncoveredLine">  if (!isa<GetElementPtrInst>(Ptr0) || !isa<GetElementPtrInst>(Ptr1))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2771</td>
    <td class="uncoveredLine">    return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2772</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2773</td>
    <td class="uncoveredLine">  auto *Gep0 = cast<GetElementPtrInst>(Ptr0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2774</td>
    <td class="uncoveredLine">  auto *Gep1 = cast<GetElementPtrInst>(Ptr1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2775</td>
    <td class="uncoveredLine">  if (Gep0->getPointerOperand() != Gep1->getPointerOperand())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2776</td>
    <td class="uncoveredLine">    return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2777</td>
    <td class="uncoveredLine">  if (Gep0->getSourceElementType() != Gep1->getSourceElementType())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2778</td>
    <td class="uncoveredLine">    return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2779</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2780</td>
    <td class="uncoveredLine">  Builder B(Gep0->getParent());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2781</td>
    <td class="uncoveredLine">  int Scale = getSizeOf(Gep0->getSourceElementType(), Alloc);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2782</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2783</td>
    <td class="">  // FIXME: for now only check GEPs with a single index.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2784</td>
    <td class="uncoveredLine">  if (Gep0->getNumOperands() != 2 || Gep1->getNumOperands() != 2)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2785</td>
    <td class="uncoveredLine">    return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2786</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2787</td>
    <td class="uncoveredLine">  Value *Idx0 = Gep0->getOperand(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2788</td>
    <td class="uncoveredLine">  Value *Idx1 = Gep1->getOperand(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2789</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2790</td>
    <td class="">  // First, try to simplify the subtraction directly.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2791</td>
    <td class="uncoveredLine">  if (auto *Diff = dyn_cast<ConstantInt>(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2792</td>
    <td class="uncoveredLine">          Simplify(CallBuilder(B, CreateSub(Idx0, Idx1)))))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2793</td>
    <td class="uncoveredLine">    return Diff->getSExtValue() * Scale;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2794</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2795</td>
    <td class="uncoveredLine">  KnownBits Known0 = getKnownBits(Idx0, Gep0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2796</td>
    <td class="uncoveredLine">  KnownBits Known1 = getKnownBits(Idx1, Gep1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2797</td>
    <td class="uncoveredLine">  APInt Unknown = ~(Known0.Zero | Known0.One) | ~(Known1.Zero | Known1.One);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2798</td>
    <td class="uncoveredLine">  if (Unknown.isAllOnes())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2799</td>
    <td class="uncoveredLine">    return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2800</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2801</td>
    <td class="uncoveredLine">  Value *MaskU = ConstantInt::get(Idx0->getType(), Unknown);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2802</td>
    <td class="uncoveredLine">  Value *AndU0 = Simplify(CallBuilder(B, CreateAnd(Idx0, MaskU)));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2803</td>
    <td class="uncoveredLine">  Value *AndU1 = Simplify(CallBuilder(B, CreateAnd(Idx1, MaskU)));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2804</td>
    <td class="uncoveredLine">  Value *SubU = Simplify(CallBuilder(B, CreateSub(AndU0, AndU1)));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2805</td>
    <td class="uncoveredLine">  int Diff0 = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2806</td>
    <td class="uncoveredLine">  if (auto *C = dyn_cast<ConstantInt>(SubU)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2807</td>
    <td class="uncoveredLine">    Diff0 = C->getSExtValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2808</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2809</td>
    <td class="uncoveredLine">    return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2810</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2811</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2812</td>
    <td class="uncoveredLine">  Value *MaskK = ConstantInt::get(MaskU->getType(), ~Unknown);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2813</td>
    <td class="uncoveredLine">  Value *AndK0 = Simplify(CallBuilder(B, CreateAnd(Idx0, MaskK)));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2814</td>
    <td class="uncoveredLine">  Value *AndK1 = Simplify(CallBuilder(B, CreateAnd(Idx1, MaskK)));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2815</td>
    <td class="uncoveredLine">  Value *SubK = Simplify(CallBuilder(B, CreateSub(AndK0, AndK1)));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2816</td>
    <td class="uncoveredLine">  int Diff1 = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2817</td>
    <td class="uncoveredLine">  if (auto *C = dyn_cast<ConstantInt>(SubK)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2818</td>
    <td class="uncoveredLine">    Diff1 = C->getSExtValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2819</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2820</td>
    <td class="uncoveredLine">    return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2821</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2822</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2823</td>
    <td class="uncoveredLine">  return (Diff0 + Diff1) * Scale;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2824</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2825</td>
    <td class="">#undef CallBuilder</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2826</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2827</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2828</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::getNumSignificantBits(const Value *V,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2829</td>
    <td class="">                                                 const Instruction *CtxI) const</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2830</td>
    <td class="">    -> unsigned {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2831</td>
    <td class="uncoveredLine">  return ComputeMaxSignificantBits(V, DL, /*Depth=*/0, &AC, CtxI, &DT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2832</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2833</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2834</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::getKnownBits(const Value *V,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2835</td>
    <td class="">                                        const Instruction *CtxI) const</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2836</td>
    <td class="">    -> KnownBits {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2837</td>
    <td class="uncoveredLine">  return computeKnownBits(V, DL, /*Depth=*/0, &AC, CtxI, &DT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2838</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2839</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2840</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::isSafeToClone(const Instruction &In) const -> bool {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2841</td>
    <td class="uncoveredLine">  if (In.mayHaveSideEffects() || In.isAtomic() || In.isVolatile() ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2842</td>
    <td class="uncoveredLine">      In.isFenceLike() || In.mayReadOrWriteMemory()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2843</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2844</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2845</td>
    <td class="uncoveredLine">  if (isa<CallBase>(In) || isa<AllocaInst>(In))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2846</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2847</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2848</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2849</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2850</td>
    <td class="">template <typename T></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2851</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::isSafeToMoveBeforeInBB(const Instruction &In,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2852</td>
    <td class="">                                                  BasicBlock::const_iterator To,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2853</td>
    <td class="">                                                  const T &IgnoreInsts) const</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2854</td>
    <td class="">    -> bool {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2855</td>
    <td class="uncoveredLine">  auto getLocOrNone =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2856</td>
    <td class="uncoveredLine">      [this](const Instruction &I) -> std::optional<MemoryLocation> {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2857</td>
    <td class="uncoveredLine">    if (const auto *II = dyn_cast<IntrinsicInst>(&I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2858</td>
    <td class="uncoveredLine">      switch (II->getIntrinsicID()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2859</td>
    <td class="uncoveredLine">      case Intrinsic::masked_load:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2860</td>
    <td class="uncoveredLine">        return MemoryLocation::getForArgument(II, 0, TLI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2861</td>
    <td class="uncoveredLine">      case Intrinsic::masked_store:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2862</td>
    <td class="uncoveredLine">        return MemoryLocation::getForArgument(II, 1, TLI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2863</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2864</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2865</td>
    <td class="uncoveredLine">    return MemoryLocation::getOrNone(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2866</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2867</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2868</td>
    <td class="">  // The source and the destination must be in the same basic block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2869</td>
    <td class="uncoveredLine">  const BasicBlock &Block = *In.getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2870</td>
    <td class="uncoveredLine">  assert(Block.begin() == To || Block.end() == To || To->getParent() == &Block);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2871</td>
    <td class="">  // No PHIs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2872</td>
    <td class="uncoveredLine">  if (isa<PHINode>(In) || (To != Block.end() && isa<PHINode>(*To)))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2873</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2874</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2875</td>
    <td class="uncoveredLine">  if (!mayHaveNonDefUseDependency(In))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2876</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2877</td>
    <td class="uncoveredLine">  bool MayWrite = In.mayWriteToMemory();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2878</td>
    <td class="uncoveredLine">  auto MaybeLoc = getLocOrNone(In);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2879</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2880</td>
    <td class="uncoveredLine">  auto From = In.getIterator();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2881</td>
    <td class="uncoveredLine">  if (From == To)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2882</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2883</td>
    <td class="uncoveredLine">  bool MoveUp = (To != Block.end() && To->comesBefore(&In));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2884</td>
    <td class="uncoveredLine">  auto Range =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2885</td>
    <td class="uncoveredLine">      MoveUp ? std::make_pair(To, From) : std::make_pair(std::next(From), To);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2886</td>
    <td class="uncoveredLine">  for (auto It = Range.first; It != Range.second; ++It) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2887</td>
    <td class="uncoveredLine">    const Instruction &I = *It;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2888</td>
    <td class="uncoveredLine">    if (llvm::is_contained(IgnoreInsts, &I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2889</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2890</td>
    <td class="">    // assume intrinsic can be ignored</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2891</td>
    <td class="uncoveredLine">    if (auto *II = dyn_cast<IntrinsicInst>(&I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2892</td>
    <td class="uncoveredLine">      if (II->getIntrinsicID() == Intrinsic::assume)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2893</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2894</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2895</td>
    <td class="">    // Parts based on isSafeToMoveBefore from CoveMoverUtils.cpp.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2896</td>
    <td class="uncoveredLine">    if (I.mayThrow())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2897</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2898</td>
    <td class="uncoveredLine">    if (auto *CB = dyn_cast<CallBase>(&I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2899</td>
    <td class="uncoveredLine">      if (!CB->hasFnAttr(Attribute::WillReturn))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2900</td>
    <td class="uncoveredLine">        return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2901</td>
    <td class="uncoveredLine">      if (!CB->hasFnAttr(Attribute::NoSync))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2902</td>
    <td class="uncoveredLine">        return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2903</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2904</td>
    <td class="uncoveredLine">    if (I.mayReadOrWriteMemory()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2905</td>
    <td class="uncoveredLine">      auto MaybeLocI = getLocOrNone(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2906</td>
    <td class="uncoveredLine">      if (MayWrite || I.mayWriteToMemory()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2907</td>
    <td class="uncoveredLine">        if (!MaybeLoc || !MaybeLocI)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2908</td>
    <td class="uncoveredLine">          return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2909</td>
    <td class="uncoveredLine">        if (!AA.isNoAlias(*MaybeLoc, *MaybeLocI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2910</td>
    <td class="uncoveredLine">          return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2911</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2912</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2913</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2914</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2915</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2916</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2917</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::isByteVecTy(Type *Ty) const -> bool {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2918</td>
    <td class="uncoveredLine">  if (auto *VecTy = dyn_cast<VectorType>(Ty))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2919</td>
    <td class="uncoveredLine">    return VecTy->getElementType() == getByteTy();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2920</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2921</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2922</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2923</td>
    <td class="uncoveredLine">auto HexagonVectorCombine::getElementRange(IRBuilderBase &Builder, Value *Lo,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2924</td>
    <td class="">                                           Value *Hi, int Start,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2925</td>
    <td class="">                                           int Length) const -> Value * {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2926</td>
    <td class="uncoveredLine">  assert(0 <= Start && size_t(Start + Length) < length(Lo) + length(Hi));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2927</td>
    <td class="uncoveredLine">  SmallVector<int, 128> SMask(Length);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2928</td>
    <td class="uncoveredLine">  std::iota(SMask.begin(), SMask.end(), Start);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2929</td>
    <td class="uncoveredLine">  return Builder.CreateShuffleVector(Lo, Hi, SMask, "shf");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2930</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2931</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2932</td>
    <td class="">// Pass management.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2933</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2934</td>
    <td class="">namespace llvm {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2935</td>
    <td class="">void initializeHexagonVectorCombineLegacyPass(PassRegistry &);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2936</td>
    <td class="">FunctionPass *createHexagonVectorCombineLegacyPass();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2937</td>
    <td class="">} // namespace llvm</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2938</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2939</td>
    <td class="">namespace {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2940</td>
    <td class="">class HexagonVectorCombineLegacy : public FunctionPass {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2941</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2942</td>
    <td class="">  static char ID;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2943</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2944</td>
    <td class="uncoveredLine">  HexagonVectorCombineLegacy() : FunctionPass(ID) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2945</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2946</td>
    <td class="uncoveredLine">  StringRef getPassName() const override { return "Hexagon Vector Combine"; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2947</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2948</td>
    <td class="uncoveredLine">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2949</td>
    <td class="uncoveredLine">    AU.setPreservesCFG();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2950</td>
    <td class="uncoveredLine">    AU.addRequired<AAResultsWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2951</td>
    <td class="uncoveredLine">    AU.addRequired<AssumptionCacheTracker>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2952</td>
    <td class="uncoveredLine">    AU.addRequired<DominatorTreeWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2953</td>
    <td class="uncoveredLine">    AU.addRequired<ScalarEvolutionWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2954</td>
    <td class="uncoveredLine">    AU.addRequired<TargetLibraryInfoWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2955</td>
    <td class="uncoveredLine">    AU.addRequired<TargetPassConfig>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2956</td>
    <td class="uncoveredLine">    FunctionPass::getAnalysisUsage(AU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2957</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2958</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2959</td>
    <td class="uncoveredLine">  bool runOnFunction(Function &F) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2960</td>
    <td class="uncoveredLine">    if (skipFunction(F))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2961</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2962</td>
    <td class="uncoveredLine">    AliasAnalysis &AA = getAnalysis<AAResultsWrapperPass>().getAAResults();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2963</td>
    <td class="">    AssumptionCache &AC =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2964</td>
    <td class="uncoveredLine">        getAnalysis<AssumptionCacheTracker>().getAssumptionCache(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2965</td>
    <td class="uncoveredLine">    DominatorTree &DT = getAnalysis<DominatorTreeWrapperPass>().getDomTree();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2966</td>
    <td class="uncoveredLine">    ScalarEvolution &SE = getAnalysis<ScalarEvolutionWrapperPass>().getSE();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2967</td>
    <td class="">    TargetLibraryInfo &TLI =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2968</td>
    <td class="uncoveredLine">        getAnalysis<TargetLibraryInfoWrapperPass>().getTLI(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2969</td>
    <td class="uncoveredLine">    auto &TM = getAnalysis<TargetPassConfig>().getTM<HexagonTargetMachine>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2970</td>
    <td class="uncoveredLine">    HexagonVectorCombine HVC(F, AA, AC, DT, SE, TLI, TM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2971</td>
    <td class="uncoveredLine">    return HVC.run();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2972</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2973</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2974</td>
    <td class="">} // namespace</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2975</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2976</td>
    <td class="">char HexagonVectorCombineLegacy::ID = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2977</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2978</td>
    <td class="coveredLine">INITIALIZE_PASS_BEGIN(HexagonVectorCombineLegacy, DEBUG_TYPE,</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2979</td>
    <td class="">                      "Hexagon Vector Combine", false, false)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2980</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(AAResultsWrapperPass)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2981</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(AssumptionCacheTracker)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2982</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2983</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(ScalarEvolutionWrapperPass)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2984</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(TargetLibraryInfoWrapperPass)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2985</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(TargetPassConfig)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2986</td>
    <td class="coveredLine">INITIALIZE_PASS_END(HexagonVectorCombineLegacy, DEBUG_TYPE,</td>
    <td>4</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2987</td>
    <td class="">                    "Hexagon Vector Combine", false, false)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2988</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2989</td>
    <td class="uncoveredLine">FunctionPass *llvm::createHexagonVectorCombineLegacyPass() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2990</td>
    <td class="uncoveredLine">  return new HexagonVectorCombineLegacy();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2991</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2992</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Functions Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Functions Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Function name</th>
    <th class="mainTh">Number of hits</th>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120HexagonVectorCombineC2ERN4llvm8FunctionERNS1_9AAResultsERNS1_15AssumptionCacheERNS1_13DominatorTreeERNS1_15ScalarEvolutionERNS1_17TargetLibraryInfoERKNS1_13TargetMachineE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_112AlignVectorsC2ERKNS_20HexagonVectorCombineE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_112AlignVectors8AddrInfoC2ERKNS_20HexagonVectorCombineEPN4llvm11InstructionEPNS5_5ValueEPNS5_4TypeENS5_5AlignE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_112AlignVectors9InstrLessclEPKN4llvm11InstructionES5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_112AlignVectors9MoveGroupC2ERKNS0_8AddrInfoEPN4llvm11InstructionEbb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_112AlignVectors9MoveGroupC2Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_112AlignVectors8ByteSpan7SegmentC2EPN4llvm5ValueEii</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_112AlignVectors8ByteSpan5BlockC2EPN4llvm5ValueEii</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_112AlignVectors8ByteSpan5BlockC2EPN4llvm5ValueEiii</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_112AlignVectors8ByteSpan4sizeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_112AlignVectors8ByteSpanixEi</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_112AlignVectors8ByteSpanixEi</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_112AlignVectors8ByteSpan5beginEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_112AlignVectors8ByteSpan3endEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_112AlignVectors8ByteSpan5beginEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_112AlignVectors8ByteSpan3endEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_1lsERN4llvm11raw_ostreamERKNS_12AlignVectors8AddrInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_1lsERN4llvm11raw_ostreamERKNS_12AlignVectors9MoveGroupE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_1lsERN4llvm11raw_ostreamERKNS_12AlignVectors8ByteSpan5BlockE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_1lsERN4llvm11raw_ostreamERKNS_12AlignVectors8ByteSpanE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_19HvxIdiomsC2ERKNS_20HexagonVectorCombineE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_1lsERN4llvm11raw_ostreamERKNS_9HvxIdioms5FxpOpE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_114getIfUnorderedIN4llvm9StoreInstEEEPT_S4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_114getIfUnorderedIN4llvm8LoadInstEEEPT_S4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_111isCandidateIN4llvm13IntrinsicInstEEEPT_PNS1_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_111isCandidateIN4llvm8LoadInstEEEPT_PNS1_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_111isCandidateIN4llvm9StoreInstEEEPT_PNS1_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_18erase_ifIZNS_12AlignVectors19createAddressGroupsEvEUlRT_E1_JPN4llvm11InstructionESt6vectorINS1_8AddrInfoESaIS9_EESt4lessIS7_ESaISt4pairIKS7_SB_EEEEEvRSt3mapIDpT0_ES2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_18erase_ifIZNS_12AlignVectors19createAddressGroupsEvEUlRT_E2_JPN4llvm11InstructionESt6vectorINS1_8AddrInfoESaIS9_EESt4lessIS7_ESaISt4pairIKS7_SB_EEEEEvRSt3mapIDpT0_ES2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_18erase_ifIZNKS_12AlignVectors16createLoadGroupsERKSt6vectorINS1_8AddrInfoESaIS3_EEEUlRKNS1_9MoveGroupEE0_RS2_IS8_SaIS8_EEEEvOT0_T_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_18erase_ifIZNKS_12AlignVectors16createLoadGroupsERKSt6vectorINS1_8AddrInfoESaIS3_EEEUlRKNS1_9MoveGroupEE1_RS2_IS8_SaIS8_EEEEvOT0_T_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_18erase_ifIZNKS_12AlignVectors17createStoreGroupsERKSt6vectorINS1_8AddrInfoESaIS3_EEEUlRKNS1_9MoveGroupEE0_RS2_IS8_SaIS8_EEEEvOT0_T_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_18erase_ifIZNKS_12AlignVectors17createStoreGroupsERKSt6vectorINS1_8AddrInfoESaIS3_EEEUlRKNS1_9MoveGroupEE1_RS2_IS8_SaIS8_EEEEvOT0_T_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_18erase_ifIZNKS_12AlignVectors17createStoreGroupsERKSt6vectorINS1_8AddrInfoESaIS3_EEEUlRKNS1_9MoveGroupEE2_RS2_IS8_SaIS8_EEEEvOT0_T_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_112AlignVectors8ByteSpan6extentEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_112AlignVectors8ByteSpan7sectionEii</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_112AlignVectors8ByteSpan5shiftEi</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_112AlignVectors8ByteSpan6valuesEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_112AlignVectors17getAlignFromValueEPKN4llvm5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_112AlignVectors11getAddrInfoERN4llvm11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_112AlignVectors5isHvxERKNS0_8AddrInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_112AlignVectors10getPayloadEPN4llvm5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_112AlignVectors7getMaskEPN4llvm5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_112AlignVectors14getPassThroughEPN4llvm5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_112AlignVectors21createAdjustedPointerERN4llvm13IRBuilderBaseEPNS1_5ValueEPNS1_4TypeEiRKNS1_8DenseMapIPNS1_11InstructionESA_NS1_12DenseMapInfoISA_vEENS1_6detail12DenseMapPairISA_SA_EEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_112AlignVectors20createAlignedPointerERN4llvm13IRBuilderBaseEPNS1_5ValueEPNS1_4TypeEiRKNS1_8DenseMapIPNS1_11InstructionESA_NS1_12DenseMapInfoISA_vEENS1_6detail12DenseMapPairISA_SA_EEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_112AlignVectors20createAlignedPointerERN4llvm13IRBuilderBaseEPNS1_5ValueEPNS1_4TypeEiRKNS1_8DenseMapIPNS1_11InstructionESA_NS1_12DenseMapInfoISA_vEENS1_6detail12DenseMapPairISA_SA_EEEEENKUlS5_E_clES5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_112AlignVectors10createLoadERN4llvm13IRBuilderBaseEPNS1_4TypeEPNS1_5ValueES7_iS7_S7_NS1_8ArrayRefIS7_EE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_112AlignVectors16createSimpleLoadERN4llvm13IRBuilderBaseEPNS1_4TypeEPNS1_5ValueEiNS1_8ArrayRefIS7_EE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_112AlignVectors20createPredicatedLoadERN4llvm13IRBuilderBaseEPNS1_4TypeEPNS1_5ValueES7_iNS1_8ArrayRefIS7_EE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_112AlignVectors11createStoreERN4llvm13IRBuilderBaseEPNS1_5ValueES5_S5_iS5_NS1_8ArrayRefIS5_EE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_112AlignVectors17createSimpleStoreERN4llvm13IRBuilderBaseEPNS1_5ValueES5_iNS1_8ArrayRefIS5_EE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_112AlignVectors21createPredicatedStoreERN4llvm13IRBuilderBaseEPNS1_5ValueES5_S5_iNS1_8ArrayRefIS5_EE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_112AlignVectors13getUpwardDepsEPN4llvm11InstructionES3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_112AlignVectors19createAddressGroupsEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_112AlignVectors19createAddressGroupsEvENKUlRNS0_8AddrInfoEE_clES2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_112AlignVectors19createAddressGroupsEvENKUlPN4llvm15DomTreeNodeBaseINS1_10BasicBlockEEET_E0_clIS7_EEvS5_S6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_112AlignVectors19createAddressGroupsEvENKUlRT_E1_clISt4pairIKPN4llvm11InstructionESt6vectorINS0_8AddrInfoESaISB_EEEEEDaS2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_112AlignVectors19createAddressGroupsEvENKUlRT_E2_clISt4pairIKPN4llvm11InstructionESt6vectorINS0_8AddrInfoESaISB_EEEEEDaS2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZZN12_GLOBAL__N_112AlignVectors19createAddressGroupsEvENKUlRT_E2_clISt4pairIKPN4llvm11InstructionESt6vectorINS0_8AddrInfoESaISB_EEEEEDaS2_ENKUlS2_E_clISB_EEDaS2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_112AlignVectors16createLoadGroupsERKSt6vectorINS0_8AddrInfoESaIS2_EE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_112AlignVectors16createLoadGroupsERKSt6vectorINS0_8AddrInfoESaIS2_EEENKUlRKS2_RNS0_9MoveGroupEE_clES8_SA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZZNK12_GLOBAL__N_112AlignVectors16createLoadGroupsERKSt6vectorINS0_8AddrInfoESaIS2_EEENKUlRKS2_RNS0_9MoveGroupEE_clES8_SA_ENKUlPKN4llvm11InstructionEE_clESF_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_112AlignVectors16createLoadGroupsERKSt6vectorINS0_8AddrInfoESaIS2_EEENKUlRKNS0_9MoveGroupEE0_clES9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_112AlignVectors16createLoadGroupsERKSt6vectorINS0_8AddrInfoESaIS2_EEENKUlRKNS0_9MoveGroupEE1_clES9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_112AlignVectors17createStoreGroupsERKSt6vectorINS0_8AddrInfoESaIS2_EE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_112AlignVectors17createStoreGroupsERKSt6vectorINS0_8AddrInfoESaIS2_EEENKUlRKS2_RNS0_9MoveGroupEE_clES8_SA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_112AlignVectors17createStoreGroupsERKSt6vectorINS0_8AddrInfoESaIS2_EEENKUlRKNS0_9MoveGroupEE0_clES9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_112AlignVectors17createStoreGroupsERKSt6vectorINS0_8AddrInfoESaIS2_EEENKUlRKNS0_9MoveGroupEE1_clES9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_112AlignVectors17createStoreGroupsERKSt6vectorINS0_8AddrInfoESaIS2_EEENKUlRKNS0_9MoveGroupEE2_clES9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZZNK12_GLOBAL__N_112AlignVectors17createStoreGroupsERKSt6vectorINS0_8AddrInfoESaIS2_EEENKUlRKNS0_9MoveGroupEE2_clES9_ENKUlPN4llvm11InstructionEE_clESD_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_112AlignVectors12moveTogetherERNS0_9MoveGroupE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_112AlignVectors11cloneBeforeIRSt3setIPN4llvm11InstructionENS0_9InstrLessESaIS5_EEEENS3_8DenseMapIS5_S5_NS3_12DenseMapInfoIS5_vEENS3_6detail12DenseMapPairIS5_S5_EEEES5_OT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_112AlignVectors11cloneBeforeIRSt6vectorIPN4llvm11InstructionESaIS5_EEEENS3_8DenseMapIS5_S5_NS3_12DenseMapInfoIS5_vEENS3_6detail12DenseMapPairIS5_S5_EEEES5_OT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_112AlignVectors16realignLoadGroupERN4llvm13IRBuilderBaseERKNS0_8ByteSpanEiPNS1_5ValueES8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_112AlignVectors16realignLoadGroupERN4llvm13IRBuilderBaseERKNS0_8ByteSpanEiPNS1_5ValueES8_ENKUlPNS1_11InstructionESA_E_clESA_SA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_112AlignVectors16realignLoadGroupERN4llvm13IRBuilderBaseERKNS0_8ByteSpanEiPNS1_5ValueES8_ENKUlRKT_E0_clINS1_14iterator_rangeINS7_17use_iterator_implINS1_3UseEEEEEEEDaSB_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_112AlignVectors16realignLoadGroupERN4llvm13IRBuilderBaseERKNS0_8ByteSpanEiPNS1_5ValueES8_ENKUlS3_S6_ibE1_clES3_S6_ib</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_112AlignVectors16realignLoadGroupERN4llvm13IRBuilderBaseERKNS0_8ByteSpanEiPNS1_5ValueES8_ENKUlPNS1_11InstructionESA_E2_clESA_SA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_112AlignVectors16realignLoadGroupERN4llvm13IRBuilderBaseERKNS0_8ByteSpanEiPNS1_5ValueES8_ENKUlPKNS4_5BlockESB_E3_clESB_SB_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_112AlignVectors17realignStoreGroupERN4llvm13IRBuilderBaseERKNS0_8ByteSpanEiPNS1_5ValueES8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_112AlignVectors17realignStoreGroupERN4llvm13IRBuilderBaseERKNS0_8ByteSpanEiPNS1_5ValueES8_ENKUlS3_S8_E_clES3_S8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_112AlignVectors17realignStoreGroupERN4llvm13IRBuilderBaseERKNS0_8ByteSpanEiPNS1_5ValueES8_ENKUlS3_S6_S6_ibE0_clES3_S6_S6_ib</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_112AlignVectors12realignGroupERKNS0_9MoveGroupE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_112AlignVectors12realignGroupERKNS0_9MoveGroupEENKUlT_T0_E_clISt6vectorINS0_8AddrInfoESaIS9_EEZNKS0_12realignGroupES3_EUlRKS9_E1_EEDaS4_S5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_112AlignVectors12realignGroupERKNS0_9MoveGroupEENKUlT_T0_E_clISt6vectorINS0_8AddrInfoESaIS9_EEZNKS0_12realignGroupES3_EUlRKS9_E2_EEDaS4_S5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_112AlignVectors12realignGroupERKNS0_9MoveGroupEENKUlT_T0_E_clISt6vectorINS0_8AddrInfoESaIS9_EEZNKS0_12realignGroupES3_EUlRKS9_E3_EEDaS4_S5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZZNK12_GLOBAL__N_112AlignVectors12realignGroupERKNS0_9MoveGroupEENKUlT_T0_E_clISt6vectorINS0_8AddrInfoESaIS9_EEZNKS0_12realignGroupES3_EUlRKS9_E2_EEDaS4_S5_ENKUlRS4_RS5_E_clIS9_S9_EEDaSF_SG_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZZNK12_GLOBAL__N_112AlignVectors12realignGroupERKNS0_9MoveGroupEENKUlT_T0_E_clISt6vectorINS0_8AddrInfoESaIS9_EEZNKS0_12realignGroupES3_EUlRKS9_E1_EEDaS4_S5_ENKUlRS4_RS5_E_clIS9_S9_EEDaSF_SG_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZZNK12_GLOBAL__N_112AlignVectors12realignGroupERKNS0_9MoveGroupEENKUlT_T0_E_clISt6vectorINS0_8AddrInfoESaIS9_EEZNKS0_12realignGroupES3_EUlRKS9_E3_EEDaS4_S5_ENKUlRS4_RS5_E_clIS9_S9_EEDaSF_SG_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_112AlignVectors12realignGroupERKNS0_9MoveGroupEENKUlRKNS0_8AddrInfoEE0_clES6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_112AlignVectors12realignGroupERKNS0_9MoveGroupEENKUlRKNS0_8AddrInfoEE1_clES6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_112AlignVectors12realignGroupERKNS0_9MoveGroupEENKUlRKNS0_8AddrInfoEE2_clES6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_112AlignVectors12realignGroupERKNS0_9MoveGroupEENKUlRKNS0_8AddrInfoEE3_clES6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_112AlignVectors19makeTestIfUnalignedERN4llvm13IRBuilderBaseEPNS1_5ValueEi</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_112AlignVectors10isSectorTyEPN4llvm4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_112AlignVectors3runEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_19HvxIdioms21getNumSignificantBitsEPN4llvm5ValueEPNS1_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_19HvxIdioms8canonSgnENS0_6SValueES1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_19HvxIdioms11matchFxpMulERN4llvm11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_19HvxIdioms11matchFxpMulERN4llvm11InstructionEENKUlOT_OT0_E_clINS1_12PatternMatch7bind_tyINS1_5ValueEEENSA_11apint_matchEEEDaS5_S7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_19HvxIdioms13processFxpMulERN4llvm11InstructionERKNS0_5FxpOpE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_19HvxIdioms13processFxpMulERN4llvm11InstructionERKNS0_5FxpOpEENKUljE_clEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_19HvxIdioms20processFxpMulChoppedERN4llvm13IRBuilderBaseERNS1_11InstructionERKNS0_5FxpOpE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_19HvxIdioms12createMulQ15ERN4llvm13IRBuilderBaseENS0_6SValueES4_b</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_19HvxIdioms12createMulQ31ERN4llvm13IRBuilderBaseENS0_6SValueES4_b</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_19HvxIdioms14createAddCarryERN4llvm13IRBuilderBaseEPNS1_5ValueES5_S5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_19HvxIdioms11createMul16ERN4llvm13IRBuilderBaseENS0_6SValueES4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_19HvxIdioms12createMulH16ERN4llvm13IRBuilderBaseENS0_6SValueES4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_19HvxIdioms11createMul32ERN4llvm13IRBuilderBaseENS0_6SValueES4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_19HvxIdioms13createAddLongERN4llvm13IRBuilderBaseENS1_8ArrayRefIPNS1_5ValueEEES7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_19HvxIdioms13createMulLongERN4llvm13IRBuilderBaseENS1_8ArrayRefIPNS1_5ValueEEENS0_10SignednessES7_S8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_19HvxIdioms13createMulLongERN4llvm13IRBuilderBaseENS1_8ArrayRefIPNS1_5ValueEEENS0_10SignednessES7_S8_ENKUlRT_E_clINS1_11SmallVectorIS6_Lj6EEEEES6_SA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_19HvxIdioms3runEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120HexagonVectorCombine3runEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine8getIntTyEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine9getByteTyEi</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine9getBoolTyEi</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine11getConstIntEij</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine6isZeroEPKN4llvm5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine11getIntValueEPKN4llvm5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine7isUndefEPKN4llvm5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine6isTrueEPKN4llvm5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine7isFalseEPKN4llvm5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine8getHvxTyEPN4llvm4TypeEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine9getSizeOfEPKN4llvm5ValueENS0_8SizeKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine9getSizeOfEPKN4llvm4TypeENS0_8SizeKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine16getTypeAlignmentEPN4llvm4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine6lengthEPN4llvm5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine6lengthEPN4llvm4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine12getNullValueEPN4llvm4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine12getFullValueEPN4llvm4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine13getConstSplatEPN4llvm4TypeEi</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine8simplifyEPN4llvm5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine7insertbERN4llvm13IRBuilderBaseEPNS1_5ValueES5_iii</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine8vlalignbERN4llvm13IRBuilderBaseEPNS1_5ValueES5_S5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine8vralignbERN4llvm13IRBuilderBaseEPNS1_5ValueES5_S5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine6concatERN4llvm13IRBuilderBaseENS1_8ArrayRefIPNS1_5ValueEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine7vresizeERN4llvm13IRBuilderBaseEPNS1_5ValueEiS5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine7rescaleERN4llvm13IRBuilderBaseEPNS1_5ValueEPNS1_4TypeES7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine4vlsbERN4llvm13IRBuilderBaseEPNS1_5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine6vbytesERN4llvm13IRBuilderBaseEPNS1_5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine9subvectorERN4llvm13IRBuilderBaseEPNS1_5ValueEjj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine5subloERN4llvm13IRBuilderBaseEPNS1_5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine5subhiERN4llvm13IRBuilderBaseEPNS1_5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine5vdealERN4llvm13IRBuilderBaseEPNS1_5ValueES5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine6vshuffERN4llvm13IRBuilderBaseEPNS1_5ValueES5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine18createHvxIntrinsicERN4llvm13IRBuilderBaseEjPNS1_4TypeENS1_8ArrayRefIPNS1_5ValueEEENS6_IS5_EES9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_120HexagonVectorCombine18createHvxIntrinsicERN4llvm13IRBuilderBaseEjPNS1_4TypeENS1_8ArrayRefIPNS1_5ValueEEENS6_IS5_EES9_ENKUlS3_S8_S5_E_clES3_S8_S5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine19splitVectorElementsERN4llvm13IRBuilderBaseEPNS1_5ValueEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_120HexagonVectorCombine19splitVectorElementsERN4llvm13IRBuilderBaseEPNS1_5ValueEjENKUljjT_E_clIS7_EEvjjS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine18joinVectorElementsERN4llvm13IRBuilderBaseENS1_8ArrayRefIPNS1_5ValueEEEPNS1_10VectorTypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine26calculatePointerDifferenceEPN4llvm5ValueES3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_120HexagonVectorCombine26calculatePointerDifferenceEPN4llvm5ValueES3_EN7BuilderC2EPNS1_10BasicBlockE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_120HexagonVectorCombine26calculatePointerDifferenceEPN4llvm5ValueES3_EN7BuilderD2Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_120HexagonVectorCombine26calculatePointerDifferenceEPN4llvm5ValueES3_ENKUlS3_E_clES3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_120HexagonVectorCombine26calculatePointerDifferenceEPN4llvm5ValueES3_ENKUlS3_E0_clES3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_120HexagonVectorCombine26calculatePointerDifferenceEPN4llvm5ValueES3_ENKUlRT_E1_clIZNKS0_26calculatePointerDifferenceES3_S3_E7BuilderEEDaS5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_120HexagonVectorCombine26calculatePointerDifferenceEPN4llvm5ValueES3_ENKUlRT_E2_clIZNKS0_26calculatePointerDifferenceES3_S3_E7BuilderEEDaS5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_120HexagonVectorCombine26calculatePointerDifferenceEPN4llvm5ValueES3_ENKUlRT_E3_clIZNKS0_26calculatePointerDifferenceES3_S3_E7BuilderEEDaS5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_120HexagonVectorCombine26calculatePointerDifferenceEPN4llvm5ValueES3_ENKUlRT_E4_clIZNKS0_26calculatePointerDifferenceES3_S3_E7BuilderEEDaS5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_120HexagonVectorCombine26calculatePointerDifferenceEPN4llvm5ValueES3_ENKUlRT_E5_clIZNKS0_26calculatePointerDifferenceES3_S3_E7BuilderEEDaS5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_120HexagonVectorCombine26calculatePointerDifferenceEPN4llvm5ValueES3_ENKUlRT_E6_clIZNKS0_26calculatePointerDifferenceES3_S3_E7BuilderEEDaS5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_120HexagonVectorCombine26calculatePointerDifferenceEPN4llvm5ValueES3_ENKUlRT_E7_clIZNKS0_26calculatePointerDifferenceES3_S3_E7BuilderEEDaS5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine21getNumSignificantBitsEPKN4llvm5ValueEPKNS1_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine12getKnownBitsEPKN4llvm5ValueEPKNS1_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine13isSafeToCloneERKN4llvm11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine22isSafeToMoveBeforeInBBISt6vectorIPN4llvm11InstructionESaIS5_EEEEbRKS4_NS3_14ilist_iteratorINS3_12ilist_detail12node_optionsIS4_Lb1ELb0EvEELb0ELb1EEERKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_120HexagonVectorCombine22isSafeToMoveBeforeInBBISt6vectorIPN4llvm11InstructionESaIS5_EEEEbRKS4_NS3_14ilist_iteratorINS3_12ilist_detail12node_optionsIS4_Lb1ELb0EvEELb0ELb1EEERKT_ENKUlS9_E_clES9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine11isByteVecTyEPN4llvm4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120HexagonVectorCombine15getElementRangeERN4llvm13IRBuilderBaseEPNS1_5ValueES5_ii</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126HexagonVectorCombineLegacyC2Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_126HexagonVectorCombineLegacy11getPassNameEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_126HexagonVectorCombineLegacy16getAnalysisUsageERN4llvm13AnalysisUsageE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126HexagonVectorCombineLegacy13runOnFunctionERN4llvm8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL44initializeHexagonVectorCombineLegacyPassOnceRN4llvm12PassRegistryE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm40initializeHexagonVectorCombineLegacyPassERNS_12PassRegistryE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm36createHexagonVectorCombineLegacyPassEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Coverage Diff</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Coverage Diff</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeline">//===-- HexagonVectorCombine.cpp ------------------------------------------===//</td>
    <td class="lineNumber">1</td>
    <td class="codeline">//===-- HexagonVectorCombine.cpp ------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeline">// HexagonVectorCombine is a utility class implementing a variety of functions</td>
    <td class="lineNumber">8</td>
    <td class="codeline">// HexagonVectorCombine is a utility class implementing a variety of functions</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeline">// that assist in vector-based optimizations.</td>
    <td class="lineNumber">9</td>
    <td class="codeline">// that assist in vector-based optimizations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeline">//</td>
    <td class="lineNumber">10</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeline">// AlignVectors: replace unaligned vector loads and stores with aligned ones.</td>
    <td class="lineNumber">11</td>
    <td class="codeline">// AlignVectors: replace unaligned vector loads and stores with aligned ones.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeline">// HvxIdioms: recognize various opportunities to generate HVX intrinsic code.</td>
    <td class="lineNumber">12</td>
    <td class="codeline">// HvxIdioms: recognize various opportunities to generate HVX intrinsic code.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">13</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeline"></td>
    <td class="lineNumber">14</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeline">#include "llvm/ADT/APInt.h"</td>
    <td class="lineNumber">15</td>
    <td class="codeline">#include "llvm/ADT/APInt.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeline">#include "llvm/ADT/ArrayRef.h"</td>
    <td class="lineNumber">16</td>
    <td class="codeline">#include "llvm/ADT/ArrayRef.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeline">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">17</td>
    <td class="codeline">#include "llvm/ADT/DenseMap.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeline">#include "llvm/ADT/STLExtras.h"</td>
    <td class="lineNumber">18</td>
    <td class="codeline">#include "llvm/ADT/STLExtras.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeline">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">19</td>
    <td class="codeline">#include "llvm/ADT/SmallVector.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeline">#include "llvm/Analysis/AliasAnalysis.h"</td>
    <td class="lineNumber">20</td>
    <td class="codeline">#include "llvm/Analysis/AliasAnalysis.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeline">#include "llvm/Analysis/AssumptionCache.h"</td>
    <td class="lineNumber">21</td>
    <td class="codeline">#include "llvm/Analysis/AssumptionCache.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeline">#include "llvm/Analysis/InstSimplifyFolder.h"</td>
    <td class="lineNumber">22</td>
    <td class="codeline">#include "llvm/Analysis/InstSimplifyFolder.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/Analysis/InstructionSimplify.h"</td>
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/Analysis/InstructionSimplify.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/Analysis/ScalarEvolution.h"</td>
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/Analysis/ScalarEvolution.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/Analysis/TargetLibraryInfo.h"</td>
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/Analysis/TargetLibraryInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/Analysis/ValueTracking.h"</td>
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/Analysis/ValueTracking.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeline">#include "llvm/Analysis/VectorUtils.h"</td>
    <td class="lineNumber">27</td>
    <td class="codeline">#include "llvm/Analysis/VectorUtils.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeline">#include "llvm/CodeGen/TargetPassConfig.h"</td>
    <td class="lineNumber">28</td>
    <td class="codeline">#include "llvm/CodeGen/TargetPassConfig.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeline">#include "llvm/CodeGen/ValueTypes.h"</td>
    <td class="lineNumber">29</td>
    <td class="codeline">#include "llvm/CodeGen/ValueTypes.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeline">#include "llvm/IR/Dominators.h"</td>
    <td class="lineNumber">30</td>
    <td class="codeline">#include "llvm/IR/Dominators.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeline">#include "llvm/IR/IRBuilder.h"</td>
    <td class="lineNumber">31</td>
    <td class="codeline">#include "llvm/IR/IRBuilder.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeline">#include "llvm/IR/IntrinsicInst.h"</td>
    <td class="lineNumber">32</td>
    <td class="codeline">#include "llvm/IR/IntrinsicInst.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeline">#include "llvm/IR/Intrinsics.h"</td>
    <td class="lineNumber">33</td>
    <td class="codeline">#include "llvm/IR/Intrinsics.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeline">#include "llvm/IR/IntrinsicsHexagon.h"</td>
    <td class="lineNumber">34</td>
    <td class="codeline">#include "llvm/IR/IntrinsicsHexagon.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeline">#include "llvm/IR/Metadata.h"</td>
    <td class="lineNumber">35</td>
    <td class="codeline">#include "llvm/IR/Metadata.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeline">#include "llvm/IR/PatternMatch.h"</td>
    <td class="lineNumber">36</td>
    <td class="codeline">#include "llvm/IR/PatternMatch.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeline">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">37</td>
    <td class="codeline">#include "llvm/InitializePasses.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeline">#include "llvm/Pass.h"</td>
    <td class="lineNumber">38</td>
    <td class="codeline">#include "llvm/Pass.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeline">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">39</td>
    <td class="codeline">#include "llvm/Support/CommandLine.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeline">#include "llvm/Support/KnownBits.h"</td>
    <td class="lineNumber">40</td>
    <td class="codeline">#include "llvm/Support/KnownBits.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeline">#include "llvm/Support/MathExtras.h"</td>
    <td class="lineNumber">41</td>
    <td class="codeline">#include "llvm/Support/MathExtras.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeline">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">42</td>
    <td class="codeline">#include "llvm/Support/raw_ostream.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeline">#include "llvm/Target/TargetMachine.h"</td>
    <td class="lineNumber">43</td>
    <td class="codeline">#include "llvm/Target/TargetMachine.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeline">#include "llvm/Transforms/Utils/Local.h"</td>
    <td class="lineNumber">44</td>
    <td class="codeline">#include "llvm/Transforms/Utils/Local.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeline"></td>
    <td class="lineNumber">45</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeline">#include "HexagonSubtarget.h"</td>
    <td class="lineNumber">46</td>
    <td class="codeline">#include "HexagonSubtarget.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeline">#include "HexagonTargetMachine.h"</td>
    <td class="lineNumber">47</td>
    <td class="codeline">#include "HexagonTargetMachine.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeline"></td>
    <td class="lineNumber">48</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeline">#include <algorithm></td>
    <td class="lineNumber">49</td>
    <td class="codeline">#include <algorithm></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeline">#include <deque></td>
    <td class="lineNumber">50</td>
    <td class="codeline">#include <deque></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeline">#include <map></td>
    <td class="lineNumber">51</td>
    <td class="codeline">#include <map></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeline">#include <optional></td>
    <td class="lineNumber">52</td>
    <td class="codeline">#include <optional></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeline">#include <set></td>
    <td class="lineNumber">53</td>
    <td class="codeline">#include <set></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeline">#include <utility></td>
    <td class="lineNumber">54</td>
    <td class="codeline">#include <utility></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeline">#include <vector></td>
    <td class="lineNumber">55</td>
    <td class="codeline">#include <vector></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeline"></td>
    <td class="lineNumber">56</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeline">#define DEBUG_TYPE "hexagon-vc"</td>
    <td class="lineNumber">57</td>
    <td class="codeline">#define DEBUG_TYPE "hexagon-vc"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeline"></td>
    <td class="lineNumber">58</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeline">using namespace llvm;</td>
    <td class="lineNumber">59</td>
    <td class="codeline">using namespace llvm;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeline"></td>
    <td class="lineNumber">60</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeline">namespace {</td>
    <td class="lineNumber">61</td>
    <td class="codeline">namespace {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeline">cl::opt<bool> DumpModule("hvc-dump-module", cl::Hidden);</td>
    <td class="lineNumber">62</td>
    <td class="codeline">cl::opt<bool> DumpModule("hvc-dump-module", cl::Hidden);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeline">cl::opt<bool> VAEnabled("hvc-va", cl::Hidden, cl::init(true)); // Align</td>
    <td class="lineNumber">63</td>
    <td class="codeline">cl::opt<bool> VAEnabled("hvc-va", cl::Hidden, cl::init(true)); // Align</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeline">cl::opt<bool> VIEnabled("hvc-vi", cl::Hidden, cl::init(true)); // Idioms</td>
    <td class="lineNumber">64</td>
    <td class="codeline">cl::opt<bool> VIEnabled("hvc-vi", cl::Hidden, cl::init(true)); // Idioms</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeline">cl::opt<bool> VADoFullStores("hvc-va-full-stores", cl::Hidden);</td>
    <td class="lineNumber">65</td>
    <td class="codeline">cl::opt<bool> VADoFullStores("hvc-va-full-stores", cl::Hidden);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeline"></td>
    <td class="lineNumber">66</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeline">cl::opt<unsigned> VAGroupCountLimit("hvc-va-group-count-limit", cl::Hidden,</td>
    <td class="lineNumber">67</td>
    <td class="codeline">cl::opt<unsigned> VAGroupCountLimit("hvc-va-group-count-limit", cl::Hidden,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeline">                                    cl::init(~0));</td>
    <td class="lineNumber">68</td>
    <td class="codeline">                                    cl::init(~0));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeline">cl::opt<unsigned> VAGroupSizeLimit("hvc-va-group-size-limit", cl::Hidden,</td>
    <td class="lineNumber">69</td>
    <td class="codeline">cl::opt<unsigned> VAGroupSizeLimit("hvc-va-group-size-limit", cl::Hidden,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeline">                                   cl::init(~0));</td>
    <td class="lineNumber">70</td>
    <td class="codeline">                                   cl::init(~0));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeline"></td>
    <td class="lineNumber">71</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeline">class HexagonVectorCombine {</td>
    <td class="lineNumber">72</td>
    <td class="codeline">class HexagonVectorCombine {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">73</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeline">  HexagonVectorCombine(Function &F_, AliasAnalysis &AA_, AssumptionCache &AC_,</td>
    <td class="lineNumber">74</td>
    <td class="codeline">  HexagonVectorCombine(Function &F_, AliasAnalysis &AA_, AssumptionCache &AC_,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeline">                       DominatorTree &DT_, ScalarEvolution &SE_,</td>
    <td class="lineNumber">75</td>
    <td class="codeline">                       DominatorTree &DT_, ScalarEvolution &SE_,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeline">                       TargetLibraryInfo &TLI_, const TargetMachine &TM_)</td>
    <td class="lineNumber">76</td>
    <td class="codeline">                       TargetLibraryInfo &TLI_, const TargetMachine &TM_)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeline">      : F(F_), DL(F.getParent()->getDataLayout()), AA(AA_), AC(AC_), DT(DT_),</td>
    <td class="lineNumber">77</td>
    <td class="codeline">      : F(F_), DL(F.getParent()->getDataLayout()), AA(AA_), AC(AC_), DT(DT_),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeline">        SE(SE_), TLI(TLI_),</td>
    <td class="lineNumber">78</td>
    <td class="codeline">        SE(SE_), TLI(TLI_),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeline">        HST(static_cast<const HexagonSubtarget &>(*TM_.getSubtargetImpl(F))) {}</td>
    <td class="lineNumber">79</td>
    <td class="codeline">        HST(static_cast<const HexagonSubtarget &>(*TM_.getSubtargetImpl(F))) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeline"></td>
    <td class="lineNumber">80</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeline">  bool run();</td>
    <td class="lineNumber">81</td>
    <td class="codeline">  bool run();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeline"></td>
    <td class="lineNumber">82</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeline">  // Common integer type.</td>
    <td class="lineNumber">83</td>
    <td class="codeline">  // Common integer type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeline">  IntegerType *getIntTy(unsigned Width = 32) const;</td>
    <td class="lineNumber">84</td>
    <td class="codeline">  IntegerType *getIntTy(unsigned Width = 32) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeline">  // Byte type: either scalar (when Length = 0), or vector with given</td>
    <td class="lineNumber">85</td>
    <td class="codeline">  // Byte type: either scalar (when Length = 0), or vector with given</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeline">  // element count.</td>
    <td class="lineNumber">86</td>
    <td class="codeline">  // element count.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeline">  Type *getByteTy(int ElemCount = 0) const;</td>
    <td class="lineNumber">87</td>
    <td class="codeline">  Type *getByteTy(int ElemCount = 0) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeline">  // Boolean type: either scalar (when Length = 0), or vector with given</td>
    <td class="lineNumber">88</td>
    <td class="codeline">  // Boolean type: either scalar (when Length = 0), or vector with given</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeline">  // element count.</td>
    <td class="lineNumber">89</td>
    <td class="codeline">  // element count.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeline">  Type *getBoolTy(int ElemCount = 0) const;</td>
    <td class="lineNumber">90</td>
    <td class="codeline">  Type *getBoolTy(int ElemCount = 0) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeline">  // Create a ConstantInt of type returned by getIntTy with the value Val.</td>
    <td class="lineNumber">91</td>
    <td class="codeline">  // Create a ConstantInt of type returned by getIntTy with the value Val.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeline">  ConstantInt *getConstInt(int Val, unsigned Width = 32) const;</td>
    <td class="lineNumber">92</td>
    <td class="codeline">  ConstantInt *getConstInt(int Val, unsigned Width = 32) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeline">  // Get the integer value of V, if it exists.</td>
    <td class="lineNumber">93</td>
    <td class="codeline">  // Get the integer value of V, if it exists.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeline">  std::optional<APInt> getIntValue(const Value *Val) const;</td>
    <td class="lineNumber">94</td>
    <td class="codeline">  std::optional<APInt> getIntValue(const Value *Val) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeline">  // Is Val a constant 0, or a vector of 0s?</td>
    <td class="lineNumber">95</td>
    <td class="codeline">  // Is Val a constant 0, or a vector of 0s?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeline">  bool isZero(const Value *Val) const;</td>
    <td class="lineNumber">96</td>
    <td class="codeline">  bool isZero(const Value *Val) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeline">  // Is Val an undef value?</td>
    <td class="lineNumber">97</td>
    <td class="codeline">  // Is Val an undef value?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeline">  bool isUndef(const Value *Val) const;</td>
    <td class="lineNumber">98</td>
    <td class="codeline">  bool isUndef(const Value *Val) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeline">  // Is Val a scalar (i1 true) or a vector of (i1 true)?</td>
    <td class="lineNumber">99</td>
    <td class="codeline">  // Is Val a scalar (i1 true) or a vector of (i1 true)?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeline">  bool isTrue(const Value *Val) const;</td>
    <td class="lineNumber">100</td>
    <td class="codeline">  bool isTrue(const Value *Val) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeline">  // Is Val a scalar (i1 false) or a vector of (i1 false)?</td>
    <td class="lineNumber">101</td>
    <td class="codeline">  // Is Val a scalar (i1 false) or a vector of (i1 false)?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeline">  bool isFalse(const Value *Val) const;</td>
    <td class="lineNumber">102</td>
    <td class="codeline">  bool isFalse(const Value *Val) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeline"></td>
    <td class="lineNumber">103</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeline">  // Get HVX vector type with the given element type.</td>
    <td class="lineNumber">104</td>
    <td class="codeline">  // Get HVX vector type with the given element type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeline">  VectorType *getHvxTy(Type *ElemTy, bool Pair = false) const;</td>
    <td class="lineNumber">105</td>
    <td class="codeline">  VectorType *getHvxTy(Type *ElemTy, bool Pair = false) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeline"></td>
    <td class="lineNumber">106</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeline">  enum SizeKind {</td>
    <td class="lineNumber">107</td>
    <td class="codeline">  enum SizeKind {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeline">    Store, // Store size</td>
    <td class="lineNumber">108</td>
    <td class="codeline">    Store, // Store size</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeline">    Alloc, // Alloc size</td>
    <td class="lineNumber">109</td>
    <td class="codeline">    Alloc, // Alloc size</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">110</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeline">  int getSizeOf(const Value *Val, SizeKind Kind = Store) const;</td>
    <td class="lineNumber">111</td>
    <td class="codeline">  int getSizeOf(const Value *Val, SizeKind Kind = Store) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeline">  int getSizeOf(const Type *Ty, SizeKind Kind = Store) const;</td>
    <td class="lineNumber">112</td>
    <td class="codeline">  int getSizeOf(const Type *Ty, SizeKind Kind = Store) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeline">  int getTypeAlignment(Type *Ty) const;</td>
    <td class="lineNumber">113</td>
    <td class="codeline">  int getTypeAlignment(Type *Ty) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeline">  size_t length(Value *Val) const;</td>
    <td class="lineNumber">114</td>
    <td class="codeline">  size_t length(Value *Val) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeline">  size_t length(Type *Ty) const;</td>
    <td class="lineNumber">115</td>
    <td class="codeline">  size_t length(Type *Ty) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeline"></td>
    <td class="lineNumber">116</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeline">  Constant *getNullValue(Type *Ty) const;</td>
    <td class="lineNumber">117</td>
    <td class="codeline">  Constant *getNullValue(Type *Ty) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeline">  Constant *getFullValue(Type *Ty) const;</td>
    <td class="lineNumber">118</td>
    <td class="codeline">  Constant *getFullValue(Type *Ty) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeline">  Constant *getConstSplat(Type *Ty, int Val) const;</td>
    <td class="lineNumber">119</td>
    <td class="codeline">  Constant *getConstSplat(Type *Ty, int Val) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeline"></td>
    <td class="lineNumber">120</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeline">  Value *simplify(Value *Val) const;</td>
    <td class="lineNumber">121</td>
    <td class="codeline">  Value *simplify(Value *Val) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeline"></td>
    <td class="lineNumber">122</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeline">  Value *insertb(IRBuilderBase &Builder, Value *Dest, Value *Src, int Start,</td>
    <td class="lineNumber">123</td>
    <td class="codeline">  Value *insertb(IRBuilderBase &Builder, Value *Dest, Value *Src, int Start,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeline">                 int Length, int Where) const;</td>
    <td class="lineNumber">124</td>
    <td class="codeline">                 int Length, int Where) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeline">  Value *vlalignb(IRBuilderBase &Builder, Value *Lo, Value *Hi,</td>
    <td class="lineNumber">125</td>
    <td class="codeline">  Value *vlalignb(IRBuilderBase &Builder, Value *Lo, Value *Hi,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeline">                  Value *Amt) const;</td>
    <td class="lineNumber">126</td>
    <td class="codeline">                  Value *Amt) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeline">  Value *vralignb(IRBuilderBase &Builder, Value *Lo, Value *Hi,</td>
    <td class="lineNumber">127</td>
    <td class="codeline">  Value *vralignb(IRBuilderBase &Builder, Value *Lo, Value *Hi,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeline">                  Value *Amt) const;</td>
    <td class="lineNumber">128</td>
    <td class="codeline">                  Value *Amt) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeline">  Value *concat(IRBuilderBase &Builder, ArrayRef<Value *> Vecs) const;</td>
    <td class="lineNumber">129</td>
    <td class="codeline">  Value *concat(IRBuilderBase &Builder, ArrayRef<Value *> Vecs) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeline">  Value *vresize(IRBuilderBase &Builder, Value *Val, int NewSize,</td>
    <td class="lineNumber">130</td>
    <td class="codeline">  Value *vresize(IRBuilderBase &Builder, Value *Val, int NewSize,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeline">                 Value *Pad) const;</td>
    <td class="lineNumber">131</td>
    <td class="codeline">                 Value *Pad) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeline">  Value *rescale(IRBuilderBase &Builder, Value *Mask, Type *FromTy,</td>
    <td class="lineNumber">132</td>
    <td class="codeline">  Value *rescale(IRBuilderBase &Builder, Value *Mask, Type *FromTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeline">                 Type *ToTy) const;</td>
    <td class="lineNumber">133</td>
    <td class="codeline">                 Type *ToTy) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeline">  Value *vlsb(IRBuilderBase &Builder, Value *Val) const;</td>
    <td class="lineNumber">134</td>
    <td class="codeline">  Value *vlsb(IRBuilderBase &Builder, Value *Val) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeline">  Value *vbytes(IRBuilderBase &Builder, Value *Val) const;</td>
    <td class="lineNumber">135</td>
    <td class="codeline">  Value *vbytes(IRBuilderBase &Builder, Value *Val) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeline">  Value *subvector(IRBuilderBase &Builder, Value *Val, unsigned Start,</td>
    <td class="lineNumber">136</td>
    <td class="codeline">  Value *subvector(IRBuilderBase &Builder, Value *Val, unsigned Start,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeline">                   unsigned Length) const;</td>
    <td class="lineNumber">137</td>
    <td class="codeline">                   unsigned Length) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeline">  Value *sublo(IRBuilderBase &Builder, Value *Val) const;</td>
    <td class="lineNumber">138</td>
    <td class="codeline">  Value *sublo(IRBuilderBase &Builder, Value *Val) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeline">  Value *subhi(IRBuilderBase &Builder, Value *Val) const;</td>
    <td class="lineNumber">139</td>
    <td class="codeline">  Value *subhi(IRBuilderBase &Builder, Value *Val) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeline">  Value *vdeal(IRBuilderBase &Builder, Value *Val0, Value *Val1) const;</td>
    <td class="lineNumber">140</td>
    <td class="codeline">  Value *vdeal(IRBuilderBase &Builder, Value *Val0, Value *Val1) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeline">  Value *vshuff(IRBuilderBase &Builder, Value *Val0, Value *Val1) const;</td>
    <td class="lineNumber">141</td>
    <td class="codeline">  Value *vshuff(IRBuilderBase &Builder, Value *Val0, Value *Val1) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeline"></td>
    <td class="lineNumber">142</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeline">  Value *createHvxIntrinsic(IRBuilderBase &Builder, Intrinsic::ID IntID,</td>
    <td class="lineNumber">143</td>
    <td class="codeline">  Value *createHvxIntrinsic(IRBuilderBase &Builder, Intrinsic::ID IntID,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeline">                            Type *RetTy, ArrayRef<Value *> Args,</td>
    <td class="lineNumber">144</td>
    <td class="codeline">                            Type *RetTy, ArrayRef<Value *> Args,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeline">                            ArrayRef<Type *> ArgTys = std::nullopt,</td>
    <td class="lineNumber">145</td>
    <td class="codeline">                            ArrayRef<Type *> ArgTys = std::nullopt,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeline">                            ArrayRef<Value *> MDSources = std::nullopt) const;</td>
    <td class="lineNumber">146</td>
    <td class="codeline">                            ArrayRef<Value *> MDSources = std::nullopt) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeline">  SmallVector<Value *> splitVectorElements(IRBuilderBase &Builder, Value *Vec,</td>
    <td class="lineNumber">147</td>
    <td class="codeline">  SmallVector<Value *> splitVectorElements(IRBuilderBase &Builder, Value *Vec,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeline">                                           unsigned ToWidth) const;</td>
    <td class="lineNumber">148</td>
    <td class="codeline">                                           unsigned ToWidth) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeline">  Value *joinVectorElements(IRBuilderBase &Builder, ArrayRef<Value *> Values,</td>
    <td class="lineNumber">149</td>
    <td class="codeline">  Value *joinVectorElements(IRBuilderBase &Builder, ArrayRef<Value *> Values,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeline">                            VectorType *ToType) const;</td>
    <td class="lineNumber">150</td>
    <td class="codeline">                            VectorType *ToType) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeline"></td>
    <td class="lineNumber">151</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeline">  std::optional<int> calculatePointerDifference(Value *Ptr0, Value *Ptr1) const;</td>
    <td class="lineNumber">152</td>
    <td class="codeline">  std::optional<int> calculatePointerDifference(Value *Ptr0, Value *Ptr1) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeline"></td>
    <td class="lineNumber">153</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeline">  unsigned getNumSignificantBits(const Value *V,</td>
    <td class="lineNumber">154</td>
    <td class="codeline">  unsigned getNumSignificantBits(const Value *V,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeline">                                 const Instruction *CtxI = nullptr) const;</td>
    <td class="lineNumber">155</td>
    <td class="codeline">                                 const Instruction *CtxI = nullptr) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeline">  KnownBits getKnownBits(const Value *V,</td>
    <td class="lineNumber">156</td>
    <td class="codeline">  KnownBits getKnownBits(const Value *V,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeline">                         const Instruction *CtxI = nullptr) const;</td>
    <td class="lineNumber">157</td>
    <td class="codeline">                         const Instruction *CtxI = nullptr) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeline"></td>
    <td class="lineNumber">158</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeline">  bool isSafeToClone(const Instruction &In) const;</td>
    <td class="lineNumber">159</td>
    <td class="codeline">  bool isSafeToClone(const Instruction &In) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeline"></td>
    <td class="lineNumber">160</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeline">  template <typename T = std::vector<Instruction *>></td>
    <td class="lineNumber">161</td>
    <td class="codeline">  template <typename T = std::vector<Instruction *>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeline">  bool isSafeToMoveBeforeInBB(const Instruction &In,</td>
    <td class="lineNumber">162</td>
    <td class="codeline">  bool isSafeToMoveBeforeInBB(const Instruction &In,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeline">                              BasicBlock::const_iterator To,</td>
    <td class="lineNumber">163</td>
    <td class="codeline">                              BasicBlock::const_iterator To,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeline">                              const T &IgnoreInsts = {}) const;</td>
    <td class="lineNumber">164</td>
    <td class="codeline">                              const T &IgnoreInsts = {}) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeline"></td>
    <td class="lineNumber">165</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeline">  // This function is only used for assertions at the moment.</td>
    <td class="lineNumber">166</td>
    <td class="codeline">  // This function is only used for assertions at the moment.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeline">  [[maybe_unused]] bool isByteVecTy(Type *Ty) const;</td>
    <td class="lineNumber">167</td>
    <td class="codeline">  [[maybe_unused]] bool isByteVecTy(Type *Ty) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeline"></td>
    <td class="lineNumber">168</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeline">  Function &F;</td>
    <td class="lineNumber">169</td>
    <td class="codeline">  Function &F;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeline">  const DataLayout &DL;</td>
    <td class="lineNumber">170</td>
    <td class="codeline">  const DataLayout &DL;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeline">  AliasAnalysis &AA;</td>
    <td class="lineNumber">171</td>
    <td class="codeline">  AliasAnalysis &AA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeline">  AssumptionCache &AC;</td>
    <td class="lineNumber">172</td>
    <td class="codeline">  AssumptionCache &AC;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeline">  DominatorTree &DT;</td>
    <td class="lineNumber">173</td>
    <td class="codeline">  DominatorTree &DT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeline">  ScalarEvolution &SE;</td>
    <td class="lineNumber">174</td>
    <td class="codeline">  ScalarEvolution &SE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeline">  TargetLibraryInfo &TLI;</td>
    <td class="lineNumber">175</td>
    <td class="codeline">  TargetLibraryInfo &TLI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeline">  const HexagonSubtarget &HST;</td>
    <td class="lineNumber">176</td>
    <td class="codeline">  const HexagonSubtarget &HST;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeline"></td>
    <td class="lineNumber">177</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">178</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeline">  Value *getElementRange(IRBuilderBase &Builder, Value *Lo, Value *Hi,</td>
    <td class="lineNumber">179</td>
    <td class="codeline">  Value *getElementRange(IRBuilderBase &Builder, Value *Lo, Value *Hi,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeline">                         int Start, int Length) const;</td>
    <td class="lineNumber">180</td>
    <td class="codeline">                         int Start, int Length) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeline">};</td>
    <td class="lineNumber">181</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeline"></td>
    <td class="lineNumber">182</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeline">class AlignVectors {</td>
    <td class="lineNumber">183</td>
    <td class="codeline">class AlignVectors {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeline">  // This code tries to replace unaligned vector loads/stores with aligned</td>
    <td class="lineNumber">184</td>
    <td class="codeline">  // This code tries to replace unaligned vector loads/stores with aligned</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeline">  // ones.</td>
    <td class="lineNumber">185</td>
    <td class="codeline">  // ones.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeline">  // Consider unaligned load:</td>
    <td class="lineNumber">186</td>
    <td class="codeline">  // Consider unaligned load:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeline">  //   %v = original_load %some_addr, align <bad></td>
    <td class="lineNumber">187</td>
    <td class="codeline">  //   %v = original_load %some_addr, align <bad></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeline">  //   %user = %v</td>
    <td class="lineNumber">188</td>
    <td class="codeline">  //   %user = %v</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeline">  // It will generate</td>
    <td class="lineNumber">189</td>
    <td class="codeline">  // It will generate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeline">  //      = load ..., align <good></td>
    <td class="lineNumber">190</td>
    <td class="codeline">  //      = load ..., align <good></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeline">  //      = load ..., align <good></td>
    <td class="lineNumber">191</td>
    <td class="codeline">  //      = load ..., align <good></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeline">  //      = valign</td>
    <td class="lineNumber">192</td>
    <td class="codeline">  //      = valign</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeline">  //      etc.</td>
    <td class="lineNumber">193</td>
    <td class="codeline">  //      etc.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeline">  //   %synthesize = combine/shuffle the loaded data so that it looks</td>
    <td class="lineNumber">194</td>
    <td class="codeline">  //   %synthesize = combine/shuffle the loaded data so that it looks</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeline">  //                 exactly like what "original_load" has loaded.</td>
    <td class="lineNumber">195</td>
    <td class="codeline">  //                 exactly like what "original_load" has loaded.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeline">  //   %user = %synthesize</td>
    <td class="lineNumber">196</td>
    <td class="codeline">  //   %user = %synthesize</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeline">  // Similarly for stores.</td>
    <td class="lineNumber">197</td>
    <td class="codeline">  // Similarly for stores.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">198</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeline">  AlignVectors(const HexagonVectorCombine &HVC_) : HVC(HVC_) {}</td>
    <td class="lineNumber">199</td>
    <td class="codeline">  AlignVectors(const HexagonVectorCombine &HVC_) : HVC(HVC_) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeline"></td>
    <td class="lineNumber">200</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeline">  bool run();</td>
    <td class="lineNumber">201</td>
    <td class="codeline">  bool run();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeline"></td>
    <td class="lineNumber">202</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">203</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeline">  using InstList = std::vector<Instruction *>;</td>
    <td class="lineNumber">204</td>
    <td class="codeline">  using InstList = std::vector<Instruction *>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeline">  using InstMap = DenseMap<Instruction *, Instruction *>;</td>
    <td class="lineNumber">205</td>
    <td class="codeline">  using InstMap = DenseMap<Instruction *, Instruction *>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeline"></td>
    <td class="lineNumber">206</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeline">  struct AddrInfo {</td>
    <td class="lineNumber">207</td>
    <td class="codeline">  struct AddrInfo {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeline">    AddrInfo(const AddrInfo &) = default;</td>
    <td class="lineNumber">208</td>
    <td class="codeline">    AddrInfo(const AddrInfo &) = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeline">    AddrInfo(const HexagonVectorCombine &HVC, Instruction *I, Value *A, Type *T,</td>
    <td class="lineNumber">209</td>
    <td class="codeline">    AddrInfo(const HexagonVectorCombine &HVC, Instruction *I, Value *A, Type *T,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeline">             Align H)</td>
    <td class="lineNumber">210</td>
    <td class="codeline">             Align H)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeline">        : Inst(I), Addr(A), ValTy(T), HaveAlign(H),</td>
    <td class="lineNumber">211</td>
    <td class="codeline">        : Inst(I), Addr(A), ValTy(T), HaveAlign(H),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeline">          NeedAlign(HVC.getTypeAlignment(ValTy)) {}</td>
    <td class="lineNumber">212</td>
    <td class="codeline">          NeedAlign(HVC.getTypeAlignment(ValTy)) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeline">    AddrInfo &operator=(const AddrInfo &) = default;</td>
    <td class="lineNumber">213</td>
    <td class="codeline">    AddrInfo &operator=(const AddrInfo &) = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeline"></td>
    <td class="lineNumber">214</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeline">    // XXX: add Size member?</td>
    <td class="lineNumber">215</td>
    <td class="codeline">    // XXX: add Size member?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeline">    Instruction *Inst;</td>
    <td class="lineNumber">216</td>
    <td class="codeline">    Instruction *Inst;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeline">    Value *Addr;</td>
    <td class="lineNumber">217</td>
    <td class="codeline">    Value *Addr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeline">    Type *ValTy;</td>
    <td class="lineNumber">218</td>
    <td class="codeline">    Type *ValTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeline">    Align HaveAlign;</td>
    <td class="lineNumber">219</td>
    <td class="codeline">    Align HaveAlign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeline">    Align NeedAlign;</td>
    <td class="lineNumber">220</td>
    <td class="codeline">    Align NeedAlign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeline">    int Offset = 0; // Offset (in bytes) from the first member of the</td>
    <td class="lineNumber">221</td>
    <td class="codeline">    int Offset = 0; // Offset (in bytes) from the first member of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeline">                    // containing AddrList.</td>
    <td class="lineNumber">222</td>
    <td class="codeline">                    // containing AddrList.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">223</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeline">  using AddrList = std::vector<AddrInfo>;</td>
    <td class="lineNumber">224</td>
    <td class="codeline">  using AddrList = std::vector<AddrInfo>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeline"></td>
    <td class="lineNumber">225</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeline">  struct InstrLess {</td>
    <td class="lineNumber">226</td>
    <td class="codeline">  struct InstrLess {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeline">    bool operator()(const Instruction *A, const Instruction *B) const {</td>
    <td class="lineNumber">227</td>
    <td class="codeline">    bool operator()(const Instruction *A, const Instruction *B) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeline">      return A->comesBefore(B);</td>
    <td class="lineNumber">228</td>
    <td class="codeline">      return A->comesBefore(B);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">229</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">230</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeline">  using DepList = std::set<Instruction *, InstrLess>;</td>
    <td class="lineNumber">231</td>
    <td class="codeline">  using DepList = std::set<Instruction *, InstrLess>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeline"></td>
    <td class="lineNumber">232</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeline">  struct MoveGroup {</td>
    <td class="lineNumber">233</td>
    <td class="codeline">  struct MoveGroup {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeline">    MoveGroup(const AddrInfo &AI, Instruction *B, bool Hvx, bool Load)</td>
    <td class="lineNumber">234</td>
    <td class="codeline">    MoveGroup(const AddrInfo &AI, Instruction *B, bool Hvx, bool Load)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeline">        : Base(B), Main{AI.Inst}, Clones{}, IsHvx(Hvx), IsLoad(Load) {}</td>
    <td class="lineNumber">235</td>
    <td class="codeline">        : Base(B), Main{AI.Inst}, Clones{}, IsHvx(Hvx), IsLoad(Load) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeline">    MoveGroup() = default;</td>
    <td class="lineNumber">236</td>
    <td class="codeline">    MoveGroup() = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeline">    Instruction *Base; // Base instruction of the parent address group.</td>
    <td class="lineNumber">237</td>
    <td class="codeline">    Instruction *Base; // Base instruction of the parent address group.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeline">    InstList Main;     // Main group of instructions.</td>
    <td class="lineNumber">238</td>
    <td class="codeline">    InstList Main;     // Main group of instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeline">    InstList Deps;     // List of dependencies.</td>
    <td class="lineNumber">239</td>
    <td class="codeline">    InstList Deps;     // List of dependencies.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeline">    InstMap Clones;    // Map from original Deps to cloned ones.</td>
    <td class="lineNumber">240</td>
    <td class="codeline">    InstMap Clones;    // Map from original Deps to cloned ones.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeline">    bool IsHvx;        // Is this group of HVX instructions?</td>
    <td class="lineNumber">241</td>
    <td class="codeline">    bool IsHvx;        // Is this group of HVX instructions?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeline">    bool IsLoad;       // Is this a load group?</td>
    <td class="lineNumber">242</td>
    <td class="codeline">    bool IsLoad;       // Is this a load group?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">243</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeline">  using MoveList = std::vector<MoveGroup>;</td>
    <td class="lineNumber">244</td>
    <td class="codeline">  using MoveList = std::vector<MoveGroup>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeline"></td>
    <td class="lineNumber">245</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeline">  struct ByteSpan {</td>
    <td class="lineNumber">246</td>
    <td class="codeline">  struct ByteSpan {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeline">    // A representation of "interesting" bytes within a given span of memory.</td>
    <td class="lineNumber">247</td>
    <td class="codeline">    // A representation of "interesting" bytes within a given span of memory.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeline">    // These bytes are those that are loaded or stored, and they don't have</td>
    <td class="lineNumber">248</td>
    <td class="codeline">    // These bytes are those that are loaded or stored, and they don't have</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeline">    // to cover the entire span of memory.</td>
    <td class="lineNumber">249</td>
    <td class="codeline">    // to cover the entire span of memory.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">250</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeline">    // The representation works by picking a contiguous sequence of bytes</td>
    <td class="lineNumber">251</td>
    <td class="codeline">    // The representation works by picking a contiguous sequence of bytes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeline">    // from somewhere within a llvm::Value, and placing it at a given offset</td>
    <td class="lineNumber">252</td>
    <td class="codeline">    // from somewhere within a llvm::Value, and placing it at a given offset</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeline">    // within the span.</td>
    <td class="lineNumber">253</td>
    <td class="codeline">    // within the span.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">254</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeline">    // The sequence of bytes from llvm:Value is represented by Segment.</td>
    <td class="lineNumber">255</td>
    <td class="codeline">    // The sequence of bytes from llvm:Value is represented by Segment.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeline">    // Block is Segment, plus where it goes in the span.</td>
    <td class="lineNumber">256</td>
    <td class="codeline">    // Block is Segment, plus where it goes in the span.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">257</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeline">    // An important feature of ByteSpan is being able to make a "section",</td>
    <td class="lineNumber">258</td>
    <td class="codeline">    // An important feature of ByteSpan is being able to make a "section",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeline">    // i.e. creating another ByteSpan corresponding to a range of offsets</td>
    <td class="lineNumber">259</td>
    <td class="codeline">    // i.e. creating another ByteSpan corresponding to a range of offsets</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeline">    // relative to the source span.</td>
    <td class="lineNumber">260</td>
    <td class="codeline">    // relative to the source span.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeline"></td>
    <td class="lineNumber">261</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeline">    struct Segment {</td>
    <td class="lineNumber">262</td>
    <td class="codeline">    struct Segment {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeline">      // Segment of a Value: 'Len' bytes starting at byte 'Begin'.</td>
    <td class="lineNumber">263</td>
    <td class="codeline">      // Segment of a Value: 'Len' bytes starting at byte 'Begin'.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeline">      Segment(Value *Val, int Begin, int Len)</td>
    <td class="lineNumber">264</td>
    <td class="codeline">      Segment(Value *Val, int Begin, int Len)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeline">          : Val(Val), Start(Begin), Size(Len) {}</td>
    <td class="lineNumber">265</td>
    <td class="codeline">          : Val(Val), Start(Begin), Size(Len) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeline">      Segment(const Segment &Seg) = default;</td>
    <td class="lineNumber">266</td>
    <td class="codeline">      Segment(const Segment &Seg) = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeline">      Segment &operator=(const Segment &Seg) = default;</td>
    <td class="lineNumber">267</td>
    <td class="codeline">      Segment &operator=(const Segment &Seg) = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeline">      Value *Val; // Value representable as a sequence of bytes.</td>
    <td class="lineNumber">268</td>
    <td class="codeline">      Value *Val; // Value representable as a sequence of bytes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeline">      int Start;  // First byte of the value that belongs to the segment.</td>
    <td class="lineNumber">269</td>
    <td class="codeline">      int Start;  // First byte of the value that belongs to the segment.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeline">      int Size;   // Number of bytes in the segment.</td>
    <td class="lineNumber">270</td>
    <td class="codeline">      int Size;   // Number of bytes in the segment.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeline">    };</td>
    <td class="lineNumber">271</td>
    <td class="codeline">    };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeline"></td>
    <td class="lineNumber">272</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeline">    struct Block {</td>
    <td class="lineNumber">273</td>
    <td class="codeline">    struct Block {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeline">      Block(Value *Val, int Len, int Pos) : Seg(Val, 0, Len), Pos(Pos) {}</td>
    <td class="lineNumber">274</td>
    <td class="codeline">      Block(Value *Val, int Len, int Pos) : Seg(Val, 0, Len), Pos(Pos) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeline">      Block(Value *Val, int Off, int Len, int Pos)</td>
    <td class="lineNumber">275</td>
    <td class="codeline">      Block(Value *Val, int Off, int Len, int Pos)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeline">          : Seg(Val, Off, Len), Pos(Pos) {}</td>
    <td class="lineNumber">276</td>
    <td class="codeline">          : Seg(Val, Off, Len), Pos(Pos) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeline">      Block(const Block &Blk) = default;</td>
    <td class="lineNumber">277</td>
    <td class="codeline">      Block(const Block &Blk) = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeline">      Block &operator=(const Block &Blk) = default;</td>
    <td class="lineNumber">278</td>
    <td class="codeline">      Block &operator=(const Block &Blk) = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeline">      Segment Seg; // Value segment.</td>
    <td class="lineNumber">279</td>
    <td class="codeline">      Segment Seg; // Value segment.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeline">      int Pos;     // Position (offset) of the block in the span.</td>
    <td class="lineNumber">280</td>
    <td class="codeline">      int Pos;     // Position (offset) of the block in the span.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeline">    };</td>
    <td class="lineNumber">281</td>
    <td class="codeline">    };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeline"></td>
    <td class="lineNumber">282</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeline">    int extent() const;</td>
    <td class="lineNumber">283</td>
    <td class="codeline">    int extent() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeline">    ByteSpan section(int Start, int Length) const;</td>
    <td class="lineNumber">284</td>
    <td class="codeline">    ByteSpan section(int Start, int Length) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeline">    ByteSpan &shift(int Offset);</td>
    <td class="lineNumber">285</td>
    <td class="codeline">    ByteSpan &shift(int Offset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeline">    SmallVector<Value *, 8> values() const;</td>
    <td class="lineNumber">286</td>
    <td class="codeline">    SmallVector<Value *, 8> values() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeline"></td>
    <td class="lineNumber">287</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeline">    int size() const { return Blocks.size(); }</td>
    <td class="lineNumber">288</td>
    <td class="codeline">    int size() const { return Blocks.size(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeline">    Block &operator[](int i) { return Blocks[i]; }</td>
    <td class="lineNumber">289</td>
    <td class="codeline">    Block &operator[](int i) { return Blocks[i]; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeline">    const Block &operator[](int i) const { return Blocks[i]; }</td>
    <td class="lineNumber">290</td>
    <td class="codeline">    const Block &operator[](int i) const { return Blocks[i]; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeline"></td>
    <td class="lineNumber">291</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeline">    std::vector<Block> Blocks;</td>
    <td class="lineNumber">292</td>
    <td class="codeline">    std::vector<Block> Blocks;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeline"></td>
    <td class="lineNumber">293</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeline">    using iterator = decltype(Blocks)::iterator;</td>
    <td class="lineNumber">294</td>
    <td class="codeline">    using iterator = decltype(Blocks)::iterator;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeline">    iterator begin() { return Blocks.begin(); }</td>
    <td class="lineNumber">295</td>
    <td class="codeline">    iterator begin() { return Blocks.begin(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeline">    iterator end() { return Blocks.end(); }</td>
    <td class="lineNumber">296</td>
    <td class="codeline">    iterator end() { return Blocks.end(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeline">    using const_iterator = decltype(Blocks)::const_iterator;</td>
    <td class="lineNumber">297</td>
    <td class="codeline">    using const_iterator = decltype(Blocks)::const_iterator;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeline">    const_iterator begin() const { return Blocks.begin(); }</td>
    <td class="lineNumber">298</td>
    <td class="codeline">    const_iterator begin() const { return Blocks.begin(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeline">    const_iterator end() const { return Blocks.end(); }</td>
    <td class="lineNumber">299</td>
    <td class="codeline">    const_iterator end() const { return Blocks.end(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">300</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeline"></td>
    <td class="lineNumber">301</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeline">  Align getAlignFromValue(const Value *V) const;</td>
    <td class="lineNumber">302</td>
    <td class="codeline">  Align getAlignFromValue(const Value *V) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeline">  std::optional<AddrInfo> getAddrInfo(Instruction &In) const;</td>
    <td class="lineNumber">303</td>
    <td class="codeline">  std::optional<AddrInfo> getAddrInfo(Instruction &In) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeline">  bool isHvx(const AddrInfo &AI) const;</td>
    <td class="lineNumber">304</td>
    <td class="codeline">  bool isHvx(const AddrInfo &AI) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeline">  // This function is only used for assertions at the moment.</td>
    <td class="lineNumber">305</td>
    <td class="codeline">  // This function is only used for assertions at the moment.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeline">  [[maybe_unused]] bool isSectorTy(Type *Ty) const;</td>
    <td class="lineNumber">306</td>
    <td class="codeline">  [[maybe_unused]] bool isSectorTy(Type *Ty) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeline"></td>
    <td class="lineNumber">307</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeline">  Value *getPayload(Value *Val) const;</td>
    <td class="lineNumber">308</td>
    <td class="codeline">  Value *getPayload(Value *Val) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeline">  Value *getMask(Value *Val) const;</td>
    <td class="lineNumber">309</td>
    <td class="codeline">  Value *getMask(Value *Val) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeline">  Value *getPassThrough(Value *Val) const;</td>
    <td class="lineNumber">310</td>
    <td class="codeline">  Value *getPassThrough(Value *Val) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeline"></td>
    <td class="lineNumber">311</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeline">  Value *createAdjustedPointer(IRBuilderBase &Builder, Value *Ptr, Type *ValTy,</td>
    <td class="lineNumber">312</td>
    <td class="codeline">  Value *createAdjustedPointer(IRBuilderBase &Builder, Value *Ptr, Type *ValTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeline">                               int Adjust,</td>
    <td class="lineNumber">313</td>
    <td class="codeline">                               int Adjust,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeline">                               const InstMap &CloneMap = InstMap()) const;</td>
    <td class="lineNumber">314</td>
    <td class="codeline">                               const InstMap &CloneMap = InstMap()) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeline">  Value *createAlignedPointer(IRBuilderBase &Builder, Value *Ptr, Type *ValTy,</td>
    <td class="lineNumber">315</td>
    <td class="codeline">  Value *createAlignedPointer(IRBuilderBase &Builder, Value *Ptr, Type *ValTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeline">                              int Alignment,</td>
    <td class="lineNumber">316</td>
    <td class="codeline">                              int Alignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeline">                              const InstMap &CloneMap = InstMap()) const;</td>
    <td class="lineNumber">317</td>
    <td class="codeline">                              const InstMap &CloneMap = InstMap()) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeline"></td>
    <td class="lineNumber">318</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeline">  Value *createLoad(IRBuilderBase &Builder, Type *ValTy, Value *Ptr,</td>
    <td class="lineNumber">319</td>
    <td class="codeline">  Value *createLoad(IRBuilderBase &Builder, Type *ValTy, Value *Ptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeline">                    Value *Predicate, int Alignment, Value *Mask,</td>
    <td class="lineNumber">320</td>
    <td class="codeline">                    Value *Predicate, int Alignment, Value *Mask,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeline">                    Value *PassThru,</td>
    <td class="lineNumber">321</td>
    <td class="codeline">                    Value *PassThru,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeline">                    ArrayRef<Value *> MDSources = std::nullopt) const;</td>
    <td class="lineNumber">322</td>
    <td class="codeline">                    ArrayRef<Value *> MDSources = std::nullopt) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeline">  Value *createSimpleLoad(IRBuilderBase &Builder, Type *ValTy, Value *Ptr,</td>
    <td class="lineNumber">323</td>
    <td class="codeline">  Value *createSimpleLoad(IRBuilderBase &Builder, Type *ValTy, Value *Ptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeline">                          int Alignment,</td>
    <td class="lineNumber">324</td>
    <td class="codeline">                          int Alignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeline">                          ArrayRef<Value *> MDSources = std::nullopt) const;</td>
    <td class="lineNumber">325</td>
    <td class="codeline">                          ArrayRef<Value *> MDSources = std::nullopt) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeline"></td>
    <td class="lineNumber">326</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeline">  Value *createStore(IRBuilderBase &Builder, Value *Val, Value *Ptr,</td>
    <td class="lineNumber">327</td>
    <td class="codeline">  Value *createStore(IRBuilderBase &Builder, Value *Val, Value *Ptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeline">                     Value *Predicate, int Alignment, Value *Mask,</td>
    <td class="lineNumber">328</td>
    <td class="codeline">                     Value *Predicate, int Alignment, Value *Mask,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeline">                     ArrayRef<Value *> MDSources = std ::nullopt) const;</td>
    <td class="lineNumber">329</td>
    <td class="codeline">                     ArrayRef<Value *> MDSources = std ::nullopt) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeline">  Value *createSimpleStore(IRBuilderBase &Builder, Value *Val, Value *Ptr,</td>
    <td class="lineNumber">330</td>
    <td class="codeline">  Value *createSimpleStore(IRBuilderBase &Builder, Value *Val, Value *Ptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeline">                           int Alignment,</td>
    <td class="lineNumber">331</td>
    <td class="codeline">                           int Alignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeline">                           ArrayRef<Value *> MDSources = std ::nullopt) const;</td>
    <td class="lineNumber">332</td>
    <td class="codeline">                           ArrayRef<Value *> MDSources = std ::nullopt) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeline"></td>
    <td class="lineNumber">333</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeline">  Value *createPredicatedLoad(IRBuilderBase &Builder, Type *ValTy, Value *Ptr,</td>
    <td class="lineNumber">334</td>
    <td class="codeline">  Value *createPredicatedLoad(IRBuilderBase &Builder, Type *ValTy, Value *Ptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeline">                              Value *Predicate, int Alignment,</td>
    <td class="lineNumber">335</td>
    <td class="codeline">                              Value *Predicate, int Alignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeline">                              ArrayRef<Value *> MDSources = std::nullopt) const;</td>
    <td class="lineNumber">336</td>
    <td class="codeline">                              ArrayRef<Value *> MDSources = std::nullopt) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeline">  Value *</td>
    <td class="lineNumber">337</td>
    <td class="codeline">  Value *</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeline">  createPredicatedStore(IRBuilderBase &Builder, Value *Val, Value *Ptr,</td>
    <td class="lineNumber">338</td>
    <td class="codeline">  createPredicatedStore(IRBuilderBase &Builder, Value *Val, Value *Ptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeline">                        Value *Predicate, int Alignment,</td>
    <td class="lineNumber">339</td>
    <td class="codeline">                        Value *Predicate, int Alignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeline">                        ArrayRef<Value *> MDSources = std::nullopt) const;</td>
    <td class="lineNumber">340</td>
    <td class="codeline">                        ArrayRef<Value *> MDSources = std::nullopt) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeline"></td>
    <td class="lineNumber">341</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeline">  DepList getUpwardDeps(Instruction *In, Instruction *Base) const;</td>
    <td class="lineNumber">342</td>
    <td class="codeline">  DepList getUpwardDeps(Instruction *In, Instruction *Base) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeline">  bool createAddressGroups();</td>
    <td class="lineNumber">343</td>
    <td class="codeline">  bool createAddressGroups();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeline">  MoveList createLoadGroups(const AddrList &Group) const;</td>
    <td class="lineNumber">344</td>
    <td class="codeline">  MoveList createLoadGroups(const AddrList &Group) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeline">  MoveList createStoreGroups(const AddrList &Group) const;</td>
    <td class="lineNumber">345</td>
    <td class="codeline">  MoveList createStoreGroups(const AddrList &Group) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeline">  bool moveTogether(MoveGroup &Move) const;</td>
    <td class="lineNumber">346</td>
    <td class="codeline">  bool moveTogether(MoveGroup &Move) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeline">  template <typename T> InstMap cloneBefore(Instruction *To, T &&Insts) const;</td>
    <td class="lineNumber">347</td>
    <td class="codeline">  template <typename T> InstMap cloneBefore(Instruction *To, T &&Insts) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeline"></td>
    <td class="lineNumber">348</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeline">  void realignLoadGroup(IRBuilderBase &Builder, const ByteSpan &VSpan,</td>
    <td class="lineNumber">349</td>
    <td class="codeline">  void realignLoadGroup(IRBuilderBase &Builder, const ByteSpan &VSpan,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeline">                        int ScLen, Value *AlignVal, Value *AlignAddr) const;</td>
    <td class="lineNumber">350</td>
    <td class="codeline">                        int ScLen, Value *AlignVal, Value *AlignAddr) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeline">  void realignStoreGroup(IRBuilderBase &Builder, const ByteSpan &VSpan,</td>
    <td class="lineNumber">351</td>
    <td class="codeline">  void realignStoreGroup(IRBuilderBase &Builder, const ByteSpan &VSpan,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeline">                         int ScLen, Value *AlignVal, Value *AlignAddr) const;</td>
    <td class="lineNumber">352</td>
    <td class="codeline">                         int ScLen, Value *AlignVal, Value *AlignAddr) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeline">  bool realignGroup(const MoveGroup &Move) const;</td>
    <td class="lineNumber">353</td>
    <td class="codeline">  bool realignGroup(const MoveGroup &Move) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeline"></td>
    <td class="lineNumber">354</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeline">  Value *makeTestIfUnaligned(IRBuilderBase &Builder, Value *AlignVal,</td>
    <td class="lineNumber">355</td>
    <td class="codeline">  Value *makeTestIfUnaligned(IRBuilderBase &Builder, Value *AlignVal,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeline">                             int Alignment) const;</td>
    <td class="lineNumber">356</td>
    <td class="codeline">                             int Alignment) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeline"></td>
    <td class="lineNumber">357</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeline">  friend raw_ostream &operator<<(raw_ostream &OS, const AddrInfo &AI);</td>
    <td class="lineNumber">358</td>
    <td class="codeline">  friend raw_ostream &operator<<(raw_ostream &OS, const AddrInfo &AI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeline">  friend raw_ostream &operator<<(raw_ostream &OS, const MoveGroup &MG);</td>
    <td class="lineNumber">359</td>
    <td class="codeline">  friend raw_ostream &operator<<(raw_ostream &OS, const MoveGroup &MG);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeline">  friend raw_ostream &operator<<(raw_ostream &OS, const ByteSpan::Block &B);</td>
    <td class="lineNumber">360</td>
    <td class="codeline">  friend raw_ostream &operator<<(raw_ostream &OS, const ByteSpan::Block &B);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeline">  friend raw_ostream &operator<<(raw_ostream &OS, const ByteSpan &BS);</td>
    <td class="lineNumber">361</td>
    <td class="codeline">  friend raw_ostream &operator<<(raw_ostream &OS, const ByteSpan &BS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeline"></td>
    <td class="lineNumber">362</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeline">  std::map<Instruction *, AddrList> AddrGroups;</td>
    <td class="lineNumber">363</td>
    <td class="codeline">  std::map<Instruction *, AddrList> AddrGroups;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeline">  const HexagonVectorCombine &HVC;</td>
    <td class="lineNumber">364</td>
    <td class="codeline">  const HexagonVectorCombine &HVC;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeline">};</td>
    <td class="lineNumber">365</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeline"></td>
    <td class="lineNumber">366</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeline">LLVM_ATTRIBUTE_UNUSED</td>
    <td class="lineNumber">367</td>
    <td class="codeline">LLVM_ATTRIBUTE_UNUSED</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeline">raw_ostream &operator<<(raw_ostream &OS, const AlignVectors::AddrInfo &AI) {</td>
    <td class="lineNumber">368</td>
    <td class="codeline">raw_ostream &operator<<(raw_ostream &OS, const AlignVectors::AddrInfo &AI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeline">  OS << "Inst: " << AI.Inst << "  " << *AI.Inst << '\n';</td>
    <td class="lineNumber">369</td>
    <td class="codeline">  OS << "Inst: " << AI.Inst << "  " << *AI.Inst << '\n';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeline">  OS << "Addr: " << *AI.Addr << '\n';</td>
    <td class="lineNumber">370</td>
    <td class="codeline">  OS << "Addr: " << *AI.Addr << '\n';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeline">  OS << "Type: " << *AI.ValTy << '\n';</td>
    <td class="lineNumber">371</td>
    <td class="codeline">  OS << "Type: " << *AI.ValTy << '\n';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeline">  OS << "HaveAlign: " << AI.HaveAlign.value() << '\n';</td>
    <td class="lineNumber">372</td>
    <td class="codeline">  OS << "HaveAlign: " << AI.HaveAlign.value() << '\n';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeline">  OS << "NeedAlign: " << AI.NeedAlign.value() << '\n';</td>
    <td class="lineNumber">373</td>
    <td class="codeline">  OS << "NeedAlign: " << AI.NeedAlign.value() << '\n';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeline">  OS << "Offset: " << AI.Offset;</td>
    <td class="lineNumber">374</td>
    <td class="codeline">  OS << "Offset: " << AI.Offset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeline">  return OS;</td>
    <td class="lineNumber">375</td>
    <td class="codeline">  return OS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeline">}</td>
    <td class="lineNumber">376</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeline"></td>
    <td class="lineNumber">377</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeline">LLVM_ATTRIBUTE_UNUSED</td>
    <td class="lineNumber">378</td>
    <td class="codeline">LLVM_ATTRIBUTE_UNUSED</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeline">raw_ostream &operator<<(raw_ostream &OS, const AlignVectors::MoveGroup &MG) {</td>
    <td class="lineNumber">379</td>
    <td class="codeline">raw_ostream &operator<<(raw_ostream &OS, const AlignVectors::MoveGroup &MG) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeline">  OS << "IsLoad:" << (MG.IsLoad ? "yes" : "no");</td>
    <td class="lineNumber">380</td>
    <td class="codeline">  OS << "IsLoad:" << (MG.IsLoad ? "yes" : "no");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeline">  OS << ", IsHvx:" << (MG.IsHvx ? "yes" : "no") << '\n';</td>
    <td class="lineNumber">381</td>
    <td class="codeline">  OS << ", IsHvx:" << (MG.IsHvx ? "yes" : "no") << '\n';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeline">  OS << "Main\n";</td>
    <td class="lineNumber">382</td>
    <td class="codeline">  OS << "Main\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeline">  for (Instruction *I : MG.Main)</td>
    <td class="lineNumber">383</td>
    <td class="codeline">  for (Instruction *I : MG.Main)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeline">    OS << "  " << *I << '\n';</td>
    <td class="lineNumber">384</td>
    <td class="codeline">    OS << "  " << *I << '\n';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeline">  OS << "Deps\n";</td>
    <td class="lineNumber">385</td>
    <td class="codeline">  OS << "Deps\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeline">  for (Instruction *I : MG.Deps)</td>
    <td class="lineNumber">386</td>
    <td class="codeline">  for (Instruction *I : MG.Deps)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeline">    OS << "  " << *I << '\n';</td>
    <td class="lineNumber">387</td>
    <td class="codeline">    OS << "  " << *I << '\n';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeline">  OS << "Clones\n";</td>
    <td class="lineNumber">388</td>
    <td class="codeline">  OS << "Clones\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeline">  for (auto [K, V] : MG.Clones) {</td>
    <td class="lineNumber">389</td>
    <td class="codeline">  for (auto [K, V] : MG.Clones) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeline">    OS << "    ";</td>
    <td class="lineNumber">390</td>
    <td class="codeline">    OS << "    ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeline">    K->printAsOperand(OS, false);</td>
    <td class="lineNumber">391</td>
    <td class="codeline">    K->printAsOperand(OS, false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeline">    OS << "\t-> " << *V << '\n';</td>
    <td class="lineNumber">392</td>
    <td class="codeline">    OS << "\t-> " << *V << '\n';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">393</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeline">  return OS;</td>
    <td class="lineNumber">394</td>
    <td class="codeline">  return OS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeline">}</td>
    <td class="lineNumber">395</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeline"></td>
    <td class="lineNumber">396</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeline">LLVM_ATTRIBUTE_UNUSED</td>
    <td class="lineNumber">397</td>
    <td class="codeline">LLVM_ATTRIBUTE_UNUSED</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeline">raw_ostream &operator<<(raw_ostream &OS,</td>
    <td class="lineNumber">398</td>
    <td class="codeline">raw_ostream &operator<<(raw_ostream &OS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeline">                        const AlignVectors::ByteSpan::Block &B) {</td>
    <td class="lineNumber">399</td>
    <td class="codeline">                        const AlignVectors::ByteSpan::Block &B) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeline">  OS << "  @" << B.Pos << " [" << B.Seg.Start << ',' << B.Seg.Size << "] ";</td>
    <td class="lineNumber">400</td>
    <td class="codeline">  OS << "  @" << B.Pos << " [" << B.Seg.Start << ',' << B.Seg.Size << "] ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeline">  if (B.Seg.Val == reinterpret_cast<const Value *>(&B)) {</td>
    <td class="lineNumber">401</td>
    <td class="codeline">  if (B.Seg.Val == reinterpret_cast<const Value *>(&B)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeline">    OS << "(self:" << B.Seg.Val << ')';</td>
    <td class="lineNumber">402</td>
    <td class="codeline">    OS << "(self:" << B.Seg.Val << ')';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeline">  } else if (B.Seg.Val != nullptr) {</td>
    <td class="lineNumber">403</td>
    <td class="codeline">  } else if (B.Seg.Val != nullptr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeline">    OS << *B.Seg.Val;</td>
    <td class="lineNumber">404</td>
    <td class="codeline">    OS << *B.Seg.Val;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">405</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeline">    OS << "(null)";</td>
    <td class="lineNumber">406</td>
    <td class="codeline">    OS << "(null)";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">407</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeline">  return OS;</td>
    <td class="lineNumber">408</td>
    <td class="codeline">  return OS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeline">}</td>
    <td class="lineNumber">409</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeline"></td>
    <td class="lineNumber">410</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeline">LLVM_ATTRIBUTE_UNUSED</td>
    <td class="lineNumber">411</td>
    <td class="codeline">LLVM_ATTRIBUTE_UNUSED</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeline">raw_ostream &operator<<(raw_ostream &OS, const AlignVectors::ByteSpan &BS) {</td>
    <td class="lineNumber">412</td>
    <td class="codeline">raw_ostream &operator<<(raw_ostream &OS, const AlignVectors::ByteSpan &BS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeline">  OS << "ByteSpan[size=" << BS.size() << ", extent=" << BS.extent() << '\n';</td>
    <td class="lineNumber">413</td>
    <td class="codeline">  OS << "ByteSpan[size=" << BS.size() << ", extent=" << BS.extent() << '\n';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeline">  for (const AlignVectors::ByteSpan::Block &B : BS)</td>
    <td class="lineNumber">414</td>
    <td class="codeline">  for (const AlignVectors::ByteSpan::Block &B : BS)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeline">    OS << B << '\n';</td>
    <td class="lineNumber">415</td>
    <td class="codeline">    OS << B << '\n';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeline">  OS << ']';</td>
    <td class="lineNumber">416</td>
    <td class="codeline">  OS << ']';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeline">  return OS;</td>
    <td class="lineNumber">417</td>
    <td class="codeline">  return OS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeline">}</td>
    <td class="lineNumber">418</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeline"></td>
    <td class="lineNumber">419</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeline">class HvxIdioms {</td>
    <td class="lineNumber">420</td>
    <td class="codeline">class HvxIdioms {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">421</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeline">  HvxIdioms(const HexagonVectorCombine &HVC_) : HVC(HVC_) {</td>
    <td class="lineNumber">422</td>
    <td class="codeline">  HvxIdioms(const HexagonVectorCombine &HVC_) : HVC(HVC_) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeline">    auto *Int32Ty = HVC.getIntTy(32);</td>
    <td class="lineNumber">423</td>
    <td class="codeline">    auto *Int32Ty = HVC.getIntTy(32);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeline">    HvxI32Ty = HVC.getHvxTy(Int32Ty, /*Pair=*/false);</td>
    <td class="lineNumber">424</td>
    <td class="codeline">    HvxI32Ty = HVC.getHvxTy(Int32Ty, /*Pair=*/false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeline">    HvxP32Ty = HVC.getHvxTy(Int32Ty, /*Pair=*/true);</td>
    <td class="lineNumber">425</td>
    <td class="codeline">    HvxP32Ty = HVC.getHvxTy(Int32Ty, /*Pair=*/true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">426</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeline"></td>
    <td class="lineNumber">427</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeline">  bool run();</td>
    <td class="lineNumber">428</td>
    <td class="codeline">  bool run();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeline"></td>
    <td class="lineNumber">429</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">430</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeline">  enum Signedness { Positive, Signed, Unsigned };</td>
    <td class="lineNumber">431</td>
    <td class="codeline">  enum Signedness { Positive, Signed, Unsigned };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeline"></td>
    <td class="lineNumber">432</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeline">  // Value + sign</td>
    <td class="lineNumber">433</td>
    <td class="codeline">  // Value + sign</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeline">  // This is to keep track of whether the value should be treated as signed</td>
    <td class="lineNumber">434</td>
    <td class="codeline">  // This is to keep track of whether the value should be treated as signed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeline">  // or unsigned, or is known to be positive.</td>
    <td class="lineNumber">435</td>
    <td class="codeline">  // or unsigned, or is known to be positive.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeline">  struct SValue {</td>
    <td class="lineNumber">436</td>
    <td class="codeline">  struct SValue {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeline">    Value *Val;</td>
    <td class="lineNumber">437</td>
    <td class="codeline">    Value *Val;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeline">    Signedness Sgn;</td>
    <td class="lineNumber">438</td>
    <td class="codeline">    Signedness Sgn;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">439</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeline"></td>
    <td class="lineNumber">440</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeline">  struct FxpOp {</td>
    <td class="lineNumber">441</td>
    <td class="codeline">  struct FxpOp {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeline">    unsigned Opcode;</td>
    <td class="lineNumber">442</td>
    <td class="codeline">    unsigned Opcode;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeline">    unsigned Frac; // Number of fraction bits</td>
    <td class="lineNumber">443</td>
    <td class="codeline">    unsigned Frac; // Number of fraction bits</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeline">    SValue X, Y;</td>
    <td class="lineNumber">444</td>
    <td class="codeline">    SValue X, Y;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeline">    // If present, add 1 << RoundAt before shift:</td>
    <td class="lineNumber">445</td>
    <td class="codeline">    // If present, add 1 << RoundAt before shift:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeline">    std::optional<unsigned> RoundAt;</td>
    <td class="lineNumber">446</td>
    <td class="codeline">    std::optional<unsigned> RoundAt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeline">    VectorType *ResTy;</td>
    <td class="lineNumber">447</td>
    <td class="codeline">    VectorType *ResTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">448</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeline"></td>
    <td class="lineNumber">449</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeline">  auto getNumSignificantBits(Value *V, Instruction *In) const</td>
    <td class="lineNumber">450</td>
    <td class="codeline">  auto getNumSignificantBits(Value *V, Instruction *In) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeline">      -> std::pair<unsigned, Signedness>;</td>
    <td class="lineNumber">451</td>
    <td class="codeline">      -> std::pair<unsigned, Signedness>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeline">  auto canonSgn(SValue X, SValue Y) const -> std::pair<SValue, SValue>;</td>
    <td class="lineNumber">452</td>
    <td class="codeline">  auto canonSgn(SValue X, SValue Y) const -> std::pair<SValue, SValue>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeline"></td>
    <td class="lineNumber">453</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeline">  auto matchFxpMul(Instruction &In) const -> std::optional<FxpOp>;</td>
    <td class="lineNumber">454</td>
    <td class="codeline">  auto matchFxpMul(Instruction &In) const -> std::optional<FxpOp>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeline">  auto processFxpMul(Instruction &In, const FxpOp &Op) const -> Value *;</td>
    <td class="lineNumber">455</td>
    <td class="codeline">  auto processFxpMul(Instruction &In, const FxpOp &Op) const -> Value *;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeline"></td>
    <td class="lineNumber">456</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeline">  auto processFxpMulChopped(IRBuilderBase &Builder, Instruction &In,</td>
    <td class="lineNumber">457</td>
    <td class="codeline">  auto processFxpMulChopped(IRBuilderBase &Builder, Instruction &In,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeline">                            const FxpOp &Op) const -> Value *;</td>
    <td class="lineNumber">458</td>
    <td class="codeline">                            const FxpOp &Op) const -> Value *;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeline">  auto createMulQ15(IRBuilderBase &Builder, SValue X, SValue Y,</td>
    <td class="lineNumber">459</td>
    <td class="codeline">  auto createMulQ15(IRBuilderBase &Builder, SValue X, SValue Y,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeline">                    bool Rounding) const -> Value *;</td>
    <td class="lineNumber">460</td>
    <td class="codeline">                    bool Rounding) const -> Value *;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeline">  auto createMulQ31(IRBuilderBase &Builder, SValue X, SValue Y,</td>
    <td class="lineNumber">461</td>
    <td class="codeline">  auto createMulQ31(IRBuilderBase &Builder, SValue X, SValue Y,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeline">                    bool Rounding) const -> Value *;</td>
    <td class="lineNumber">462</td>
    <td class="codeline">                    bool Rounding) const -> Value *;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeline">  // Return {Result, Carry}, where Carry is a vector predicate.</td>
    <td class="lineNumber">463</td>
    <td class="codeline">  // Return {Result, Carry}, where Carry is a vector predicate.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeline">  auto createAddCarry(IRBuilderBase &Builder, Value *X, Value *Y,</td>
    <td class="lineNumber">464</td>
    <td class="codeline">  auto createAddCarry(IRBuilderBase &Builder, Value *X, Value *Y,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeline">                      Value *CarryIn = nullptr) const</td>
    <td class="lineNumber">465</td>
    <td class="codeline">                      Value *CarryIn = nullptr) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeline">      -> std::pair<Value *, Value *>;</td>
    <td class="lineNumber">466</td>
    <td class="codeline">      -> std::pair<Value *, Value *>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeline">  auto createMul16(IRBuilderBase &Builder, SValue X, SValue Y) const -> Value *;</td>
    <td class="lineNumber">467</td>
    <td class="codeline">  auto createMul16(IRBuilderBase &Builder, SValue X, SValue Y) const -> Value *;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeline">  auto createMulH16(IRBuilderBase &Builder, SValue X, SValue Y) const</td>
    <td class="lineNumber">468</td>
    <td class="codeline">  auto createMulH16(IRBuilderBase &Builder, SValue X, SValue Y) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeline">      -> Value *;</td>
    <td class="lineNumber">469</td>
    <td class="codeline">      -> Value *;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeline">  auto createMul32(IRBuilderBase &Builder, SValue X, SValue Y) const</td>
    <td class="lineNumber">470</td>
    <td class="codeline">  auto createMul32(IRBuilderBase &Builder, SValue X, SValue Y) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeline">      -> std::pair<Value *, Value *>;</td>
    <td class="lineNumber">471</td>
    <td class="codeline">      -> std::pair<Value *, Value *>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeline">  auto createAddLong(IRBuilderBase &Builder, ArrayRef<Value *> WordX,</td>
    <td class="lineNumber">472</td>
    <td class="codeline">  auto createAddLong(IRBuilderBase &Builder, ArrayRef<Value *> WordX,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeline">                     ArrayRef<Value *> WordY) const -> SmallVector<Value *>;</td>
    <td class="lineNumber">473</td>
    <td class="codeline">                     ArrayRef<Value *> WordY) const -> SmallVector<Value *>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeline">  auto createMulLong(IRBuilderBase &Builder, ArrayRef<Value *> WordX,</td>
    <td class="lineNumber">474</td>
    <td class="codeline">  auto createMulLong(IRBuilderBase &Builder, ArrayRef<Value *> WordX,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeline">                     Signedness SgnX, ArrayRef<Value *> WordY,</td>
    <td class="lineNumber">475</td>
    <td class="codeline">                     Signedness SgnX, ArrayRef<Value *> WordY,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeline">                     Signedness SgnY) const -> SmallVector<Value *>;</td>
    <td class="lineNumber">476</td>
    <td class="codeline">                     Signedness SgnY) const -> SmallVector<Value *>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeline"></td>
    <td class="lineNumber">477</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeline">  VectorType *HvxI32Ty;</td>
    <td class="lineNumber">478</td>
    <td class="codeline">  VectorType *HvxI32Ty;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeline">  VectorType *HvxP32Ty;</td>
    <td class="lineNumber">479</td>
    <td class="codeline">  VectorType *HvxP32Ty;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeline">  const HexagonVectorCombine &HVC;</td>
    <td class="lineNumber">480</td>
    <td class="codeline">  const HexagonVectorCombine &HVC;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeline"></td>
    <td class="lineNumber">481</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeline">  friend raw_ostream &operator<<(raw_ostream &, const FxpOp &);</td>
    <td class="lineNumber">482</td>
    <td class="codeline">  friend raw_ostream &operator<<(raw_ostream &, const FxpOp &);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeline">};</td>
    <td class="lineNumber">483</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeline"></td>
    <td class="lineNumber">484</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeline">[[maybe_unused]] raw_ostream &operator<<(raw_ostream &OS,</td>
    <td class="lineNumber">485</td>
    <td class="codeline">[[maybe_unused]] raw_ostream &operator<<(raw_ostream &OS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeline">                                         const HvxIdioms::FxpOp &Op) {</td>
    <td class="lineNumber">486</td>
    <td class="codeline">                                         const HvxIdioms::FxpOp &Op) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeline">  static const char *SgnNames[] = {"Positive", "Signed", "Unsigned"};</td>
    <td class="lineNumber">487</td>
    <td class="codeline">  static const char *SgnNames[] = {"Positive", "Signed", "Unsigned"};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeline">  OS << Instruction::getOpcodeName(Op.Opcode) << '.' << Op.Frac;</td>
    <td class="lineNumber">488</td>
    <td class="codeline">  OS << Instruction::getOpcodeName(Op.Opcode) << '.' << Op.Frac;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeline">  if (Op.RoundAt.has_value()) {</td>
    <td class="lineNumber">489</td>
    <td class="codeline">  if (Op.RoundAt.has_value()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeline">    if (Op.Frac != 0 && *Op.RoundAt == Op.Frac - 1) {</td>
    <td class="lineNumber">490</td>
    <td class="codeline">    if (Op.Frac != 0 && *Op.RoundAt == Op.Frac - 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeline">      OS << ":rnd";</td>
    <td class="lineNumber">491</td>
    <td class="codeline">      OS << ":rnd";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">492</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeline">      OS << " + 1<<" << *Op.RoundAt;</td>
    <td class="lineNumber">493</td>
    <td class="codeline">      OS << " + 1<<" << *Op.RoundAt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">494</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">495</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeline">  OS << "\n  X:(" << SgnNames[Op.X.Sgn] << ") " << *Op.X.Val << "\n"</td>
    <td class="lineNumber">496</td>
    <td class="codeline">  OS << "\n  X:(" << SgnNames[Op.X.Sgn] << ") " << *Op.X.Val << "\n"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeline">     << "  Y:(" << SgnNames[Op.Y.Sgn] << ") " << *Op.Y.Val;</td>
    <td class="lineNumber">497</td>
    <td class="codeline">     << "  Y:(" << SgnNames[Op.Y.Sgn] << ") " << *Op.Y.Val;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeline">  return OS;</td>
    <td class="lineNumber">498</td>
    <td class="codeline">  return OS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeline">}</td>
    <td class="lineNumber">499</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeline"></td>
    <td class="lineNumber">500</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeline">} // namespace</td>
    <td class="lineNumber">501</td>
    <td class="codeline">} // namespace</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeline"></td>
    <td class="lineNumber">502</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeline">namespace {</td>
    <td class="lineNumber">503</td>
    <td class="codeline">namespace {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeline"></td>
    <td class="lineNumber">504</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeline">template <typename T> T *getIfUnordered(T *MaybeT) {</td>
    <td class="lineNumber">505</td>
    <td class="codeline">template <typename T> T *getIfUnordered(T *MaybeT) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeline">  return MaybeT && MaybeT->isUnordered() ? MaybeT : nullptr;</td>
    <td class="lineNumber">506</td>
    <td class="codeline">  return MaybeT && MaybeT->isUnordered() ? MaybeT : nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeline">}</td>
    <td class="lineNumber">507</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeline">template <typename T> T *isCandidate(Instruction *In) {</td>
    <td class="lineNumber">508</td>
    <td class="codeline">template <typename T> T *isCandidate(Instruction *In) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeline">  return dyn_cast<T>(In);</td>
    <td class="lineNumber">509</td>
    <td class="codeline">  return dyn_cast<T>(In);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeline">}</td>
    <td class="lineNumber">510</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeline">template <> LoadInst *isCandidate<LoadInst>(Instruction *In) {</td>
    <td class="lineNumber">511</td>
    <td class="codeline">template <> LoadInst *isCandidate<LoadInst>(Instruction *In) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeline">  return getIfUnordered(dyn_cast<LoadInst>(In));</td>
    <td class="lineNumber">512</td>
    <td class="codeline">  return getIfUnordered(dyn_cast<LoadInst>(In));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeline">}</td>
    <td class="lineNumber">513</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeline">template <> StoreInst *isCandidate<StoreInst>(Instruction *In) {</td>
    <td class="lineNumber">514</td>
    <td class="codeline">template <> StoreInst *isCandidate<StoreInst>(Instruction *In) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeline">  return getIfUnordered(dyn_cast<StoreInst>(In));</td>
    <td class="lineNumber">515</td>
    <td class="codeline">  return getIfUnordered(dyn_cast<StoreInst>(In));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeline">}</td>
    <td class="lineNumber">516</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeline"></td>
    <td class="lineNumber">517</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeline">#if !defined(_MSC_VER) || _MSC_VER >= 1926</td>
    <td class="lineNumber">518</td>
    <td class="codeline">#if !defined(_MSC_VER) || _MSC_VER >= 1926</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeline">// VS2017 and some versions of VS2019 have trouble compiling this:</td>
    <td class="lineNumber">519</td>
    <td class="codeline">// VS2017 and some versions of VS2019 have trouble compiling this:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeline">// error C2976: 'std::map': too few template arguments</td>
    <td class="lineNumber">520</td>
    <td class="codeline">// error C2976: 'std::map': too few template arguments</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeline">// VS 2019 16.x is known to work, except for 16.4/16.5 (MSC_VER 1924/1925)</td>
    <td class="lineNumber">521</td>
    <td class="codeline">// VS 2019 16.x is known to work, except for 16.4/16.5 (MSC_VER 1924/1925)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeline">template <typename Pred, typename... Ts></td>
    <td class="lineNumber">522</td>
    <td class="codeline">template <typename Pred, typename... Ts></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeline">void erase_if(std::map<Ts...> &map, Pred p)</td>
    <td class="lineNumber">523</td>
    <td class="codeline">void erase_if(std::map<Ts...> &map, Pred p)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeline">#else</td>
    <td class="lineNumber">524</td>
    <td class="codeline">#else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeline">template <typename Pred, typename T, typename U></td>
    <td class="lineNumber">525</td>
    <td class="codeline">template <typename Pred, typename T, typename U></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeline">void erase_if(std::map<T, U> &map, Pred p)</td>
    <td class="lineNumber">526</td>
    <td class="codeline">void erase_if(std::map<T, U> &map, Pred p)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">527</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeline">{</td>
    <td class="lineNumber">528</td>
    <td class="codeline">{</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeline">  for (auto i = map.begin(), e = map.end(); i != e;) {</td>
    <td class="lineNumber">529</td>
    <td class="codeline">  for (auto i = map.begin(), e = map.end(); i != e;) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeline">    if (p(*i))</td>
    <td class="lineNumber">530</td>
    <td class="codeline">    if (p(*i))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeline">      i = map.erase(i);</td>
    <td class="lineNumber">531</td>
    <td class="codeline">      i = map.erase(i);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">532</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeline">      i = std::next(i);</td>
    <td class="lineNumber">533</td>
    <td class="codeline">      i = std::next(i);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">534</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeline">}</td>
    <td class="lineNumber">535</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeline"></td>
    <td class="lineNumber">536</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeline">// Forward other erase_ifs to the LLVM implementations.</td>
    <td class="lineNumber">537</td>
    <td class="codeline">// Forward other erase_ifs to the LLVM implementations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeline">template <typename Pred, typename T> void erase_if(T &&container, Pred p) {</td>
    <td class="lineNumber">538</td>
    <td class="codeline">template <typename Pred, typename T> void erase_if(T &&container, Pred p) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeline">  llvm::erase_if(std::forward<T>(container), p);</td>
    <td class="lineNumber">539</td>
    <td class="codeline">  llvm::erase_if(std::forward<T>(container), p);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeline">}</td>
    <td class="lineNumber">540</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeline"></td>
    <td class="lineNumber">541</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeline">} // namespace</td>
    <td class="lineNumber">542</td>
    <td class="codeline">} // namespace</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeline"></td>
    <td class="lineNumber">543</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeline">// --- Begin AlignVectors</td>
    <td class="lineNumber">544</td>
    <td class="codeline">// --- Begin AlignVectors</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeline"></td>
    <td class="lineNumber">545</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeline">// For brevity, only consider loads. We identify a group of loads where we</td>
    <td class="lineNumber">546</td>
    <td class="codeline">// For brevity, only consider loads. We identify a group of loads where we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeline">// know the relative differences between their addresses, so we know how they</td>
    <td class="lineNumber">547</td>
    <td class="codeline">// know the relative differences between their addresses, so we know how they</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeline">// are laid out in memory (relative to one another). These loads can overlap,</td>
    <td class="lineNumber">548</td>
    <td class="codeline">// are laid out in memory (relative to one another). These loads can overlap,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeline">// can be shorter or longer than the desired vector length.</td>
    <td class="lineNumber">549</td>
    <td class="codeline">// can be shorter or longer than the desired vector length.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeline">// Ultimately we want to generate a sequence of aligned loads that will load</td>
    <td class="lineNumber">550</td>
    <td class="codeline">// Ultimately we want to generate a sequence of aligned loads that will load</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeline">// every byte that the original loads loaded, and have the program use these</td>
    <td class="lineNumber">551</td>
    <td class="codeline">// every byte that the original loads loaded, and have the program use these</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeline">// loaded values instead of the original loads.</td>
    <td class="lineNumber">552</td>
    <td class="codeline">// loaded values instead of the original loads.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeline">// We consider the contiguous memory area spanned by all these loads.</td>
    <td class="lineNumber">553</td>
    <td class="codeline">// We consider the contiguous memory area spanned by all these loads.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeline">//</td>
    <td class="lineNumber">554</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeline">// Let's say that a single aligned vector load can load 16 bytes at a time.</td>
    <td class="lineNumber">555</td>
    <td class="codeline">// Let's say that a single aligned vector load can load 16 bytes at a time.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeline">// If the program wanted to use a byte at offset 13 from the beginning of the</td>
    <td class="lineNumber">556</td>
    <td class="codeline">// If the program wanted to use a byte at offset 13 from the beginning of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeline">// original span, it will be a byte at offset 13+x in the aligned data for</td>
    <td class="lineNumber">557</td>
    <td class="codeline">// original span, it will be a byte at offset 13+x in the aligned data for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeline">// some x>=0. This may happen to be in the first aligned load, or in the load</td>
    <td class="lineNumber">558</td>
    <td class="codeline">// some x>=0. This may happen to be in the first aligned load, or in the load</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeline">// following it. Since we generally don't know what the that alignment value</td>
    <td class="lineNumber">559</td>
    <td class="codeline">// following it. Since we generally don't know what the that alignment value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeline">// is at compile time, we proactively do valigns on the aligned loads, so that</td>
    <td class="lineNumber">560</td>
    <td class="codeline">// is at compile time, we proactively do valigns on the aligned loads, so that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeline">// byte that was at offset 13 is still at offset 13 after the valigns.</td>
    <td class="lineNumber">561</td>
    <td class="codeline">// byte that was at offset 13 is still at offset 13 after the valigns.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeline">//</td>
    <td class="lineNumber">562</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeline">// This will be the starting point for making the rest of the program use the</td>
    <td class="lineNumber">563</td>
    <td class="codeline">// This will be the starting point for making the rest of the program use the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeline">// data loaded by the new loads.</td>
    <td class="lineNumber">564</td>
    <td class="codeline">// data loaded by the new loads.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeline">// For each original load, and its users:</td>
    <td class="lineNumber">565</td>
    <td class="codeline">// For each original load, and its users:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeline">//   %v = load ...</td>
    <td class="lineNumber">566</td>
    <td class="codeline">//   %v = load ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeline">//   ... = %v</td>
    <td class="lineNumber">567</td>
    <td class="codeline">//   ... = %v</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeline">//   ... = %v</td>
    <td class="lineNumber">568</td>
    <td class="codeline">//   ... = %v</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeline">// we create</td>
    <td class="lineNumber">569</td>
    <td class="codeline">// we create</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeline">//   %new_v = extract/combine/shuffle data from loaded/valigned vectors so</td>
    <td class="lineNumber">570</td>
    <td class="codeline">//   %new_v = extract/combine/shuffle data from loaded/valigned vectors so</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeline">//            it contains the same value as %v did before</td>
    <td class="lineNumber">571</td>
    <td class="codeline">//            it contains the same value as %v did before</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeline">// then replace all users of %v with %new_v.</td>
    <td class="lineNumber">572</td>
    <td class="codeline">// then replace all users of %v with %new_v.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeline">//   ... = %new_v</td>
    <td class="lineNumber">573</td>
    <td class="codeline">//   ... = %new_v</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeline">//   ... = %new_v</td>
    <td class="lineNumber">574</td>
    <td class="codeline">//   ... = %new_v</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeline"></td>
    <td class="lineNumber">575</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeline">auto AlignVectors::ByteSpan::extent() const -> int {</td>
    <td class="lineNumber">576</td>
    <td class="codeline">auto AlignVectors::ByteSpan::extent() const -> int {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeline">  if (size() == 0)</td>
    <td class="lineNumber">577</td>
    <td class="codeline">  if (size() == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeline">    return 0;</td>
    <td class="lineNumber">578</td>
    <td class="codeline">    return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeline">  int Min = Blocks[0].Pos;</td>
    <td class="lineNumber">579</td>
    <td class="codeline">  int Min = Blocks[0].Pos;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeline">  int Max = Blocks[0].Pos + Blocks[0].Seg.Size;</td>
    <td class="lineNumber">580</td>
    <td class="codeline">  int Max = Blocks[0].Pos + Blocks[0].Seg.Size;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeline">  for (int i = 1, e = size(); i != e; ++i) {</td>
    <td class="lineNumber">581</td>
    <td class="codeline">  for (int i = 1, e = size(); i != e; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeline">    Min = std::min(Min, Blocks[i].Pos);</td>
    <td class="lineNumber">582</td>
    <td class="codeline">    Min = std::min(Min, Blocks[i].Pos);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeline">    Max = std::max(Max, Blocks[i].Pos + Blocks[i].Seg.Size);</td>
    <td class="lineNumber">583</td>
    <td class="codeline">    Max = std::max(Max, Blocks[i].Pos + Blocks[i].Seg.Size);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">584</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeline">  return Max - Min;</td>
    <td class="lineNumber">585</td>
    <td class="codeline">  return Max - Min;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeline">}</td>
    <td class="lineNumber">586</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeline"></td>
    <td class="lineNumber">587</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeline">auto AlignVectors::ByteSpan::section(int Start, int Length) const -> ByteSpan {</td>
    <td class="lineNumber">588</td>
    <td class="codeline">auto AlignVectors::ByteSpan::section(int Start, int Length) const -> ByteSpan {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeline">  ByteSpan Section;</td>
    <td class="lineNumber">589</td>
    <td class="codeline">  ByteSpan Section;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeline">  for (const ByteSpan::Block &B : Blocks) {</td>
    <td class="lineNumber">590</td>
    <td class="codeline">  for (const ByteSpan::Block &B : Blocks) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeline">    int L = std::max(B.Pos, Start);                       // Left end.</td>
    <td class="lineNumber">591</td>
    <td class="codeline">    int L = std::max(B.Pos, Start);                       // Left end.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeline">    int R = std::min(B.Pos + B.Seg.Size, Start + Length); // Right end+1.</td>
    <td class="lineNumber">592</td>
    <td class="codeline">    int R = std::min(B.Pos + B.Seg.Size, Start + Length); // Right end+1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeline">    if (L < R) {</td>
    <td class="lineNumber">593</td>
    <td class="codeline">    if (L < R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeline">      // How much to chop off the beginning of the segment:</td>
    <td class="lineNumber">594</td>
    <td class="codeline">      // How much to chop off the beginning of the segment:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeline">      int Off = L > B.Pos ? L - B.Pos : 0;</td>
    <td class="lineNumber">595</td>
    <td class="codeline">      int Off = L > B.Pos ? L - B.Pos : 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeline">      Section.Blocks.emplace_back(B.Seg.Val, B.Seg.Start + Off, R - L, L);</td>
    <td class="lineNumber">596</td>
    <td class="codeline">      Section.Blocks.emplace_back(B.Seg.Val, B.Seg.Start + Off, R - L, L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">597</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">598</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeline">  return Section;</td>
    <td class="lineNumber">599</td>
    <td class="codeline">  return Section;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeline">}</td>
    <td class="lineNumber">600</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeline"></td>
    <td class="lineNumber">601</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeline">auto AlignVectors::ByteSpan::shift(int Offset) -> ByteSpan & {</td>
    <td class="lineNumber">602</td>
    <td class="codeline">auto AlignVectors::ByteSpan::shift(int Offset) -> ByteSpan & {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeline">  for (Block &B : Blocks)</td>
    <td class="lineNumber">603</td>
    <td class="codeline">  for (Block &B : Blocks)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeline">    B.Pos += Offset;</td>
    <td class="lineNumber">604</td>
    <td class="codeline">    B.Pos += Offset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeline">  return *this;</td>
    <td class="lineNumber">605</td>
    <td class="codeline">  return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeline">}</td>
    <td class="lineNumber">606</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeline"></td>
    <td class="lineNumber">607</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeline">auto AlignVectors::ByteSpan::values() const -> SmallVector<Value *, 8> {</td>
    <td class="lineNumber">608</td>
    <td class="codeline">auto AlignVectors::ByteSpan::values() const -> SmallVector<Value *, 8> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeline">  SmallVector<Value *, 8> Values(Blocks.size());</td>
    <td class="lineNumber">609</td>
    <td class="codeline">  SmallVector<Value *, 8> Values(Blocks.size());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeline">  for (int i = 0, e = Blocks.size(); i != e; ++i)</td>
    <td class="lineNumber">610</td>
    <td class="codeline">  for (int i = 0, e = Blocks.size(); i != e; ++i)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeline">    Values[i] = Blocks[i].Seg.Val;</td>
    <td class="lineNumber">611</td>
    <td class="codeline">    Values[i] = Blocks[i].Seg.Val;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeline">  return Values;</td>
    <td class="lineNumber">612</td>
    <td class="codeline">  return Values;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeline">}</td>
    <td class="lineNumber">613</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeline"></td>
    <td class="lineNumber">614</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeline">auto AlignVectors::getAlignFromValue(const Value *V) const -> Align {</td>
    <td class="lineNumber">615</td>
    <td class="codeline">auto AlignVectors::getAlignFromValue(const Value *V) const -> Align {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeline">  const auto *C = dyn_cast<ConstantInt>(V);</td>
    <td class="lineNumber">616</td>
    <td class="codeline">  const auto *C = dyn_cast<ConstantInt>(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeline">  assert(C && "Alignment must be a compile-time constant integer");</td>
    <td class="lineNumber">617</td>
    <td class="codeline">  assert(C && "Alignment must be a compile-time constant integer");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeline">  return C->getAlignValue();</td>
    <td class="lineNumber">618</td>
    <td class="codeline">  return C->getAlignValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeline">}</td>
    <td class="lineNumber">619</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeline"></td>
    <td class="lineNumber">620</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeline">auto AlignVectors::getAddrInfo(Instruction &In) const</td>
    <td class="lineNumber">621</td>
    <td class="codeline">auto AlignVectors::getAddrInfo(Instruction &In) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeline">    -> std::optional<AddrInfo> {</td>
    <td class="lineNumber">622</td>
    <td class="codeline">    -> std::optional<AddrInfo> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeline">  if (auto *L = isCandidate<LoadInst>(&In))</td>
    <td class="lineNumber">623</td>
    <td class="codeline">  if (auto *L = isCandidate<LoadInst>(&In))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeline">    return AddrInfo(HVC, L, L->getPointerOperand(), L->getType(),</td>
    <td class="lineNumber">624</td>
    <td class="codeline">    return AddrInfo(HVC, L, L->getPointerOperand(), L->getType(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeline">                    L->getAlign());</td>
    <td class="lineNumber">625</td>
    <td class="codeline">                    L->getAlign());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeline">  if (auto *S = isCandidate<StoreInst>(&In))</td>
    <td class="lineNumber">626</td>
    <td class="codeline">  if (auto *S = isCandidate<StoreInst>(&In))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeline">    return AddrInfo(HVC, S, S->getPointerOperand(),</td>
    <td class="lineNumber">627</td>
    <td class="codeline">    return AddrInfo(HVC, S, S->getPointerOperand(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeline">                    S->getValueOperand()->getType(), S->getAlign());</td>
    <td class="lineNumber">628</td>
    <td class="codeline">                    S->getValueOperand()->getType(), S->getAlign());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeline">  if (auto *II = isCandidate<IntrinsicInst>(&In)) {</td>
    <td class="lineNumber">629</td>
    <td class="codeline">  if (auto *II = isCandidate<IntrinsicInst>(&In)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeline">    Intrinsic::ID ID = II->getIntrinsicID();</td>
    <td class="lineNumber">630</td>
    <td class="codeline">    Intrinsic::ID ID = II->getIntrinsicID();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeline">    switch (ID) {</td>
    <td class="lineNumber">631</td>
    <td class="codeline">    switch (ID) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeline">    case Intrinsic::masked_load:</td>
    <td class="lineNumber">632</td>
    <td class="codeline">    case Intrinsic::masked_load:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeline">      return AddrInfo(HVC, II, II->getArgOperand(0), II->getType(),</td>
    <td class="lineNumber">633</td>
    <td class="codeline">      return AddrInfo(HVC, II, II->getArgOperand(0), II->getType(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeline">                      getAlignFromValue(II->getArgOperand(1)));</td>
    <td class="lineNumber">634</td>
    <td class="codeline">                      getAlignFromValue(II->getArgOperand(1)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeline">    case Intrinsic::masked_store:</td>
    <td class="lineNumber">635</td>
    <td class="codeline">    case Intrinsic::masked_store:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeline">      return AddrInfo(HVC, II, II->getArgOperand(1),</td>
    <td class="lineNumber">636</td>
    <td class="codeline">      return AddrInfo(HVC, II, II->getArgOperand(1),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeline">                      II->getArgOperand(0)->getType(),</td>
    <td class="lineNumber">637</td>
    <td class="codeline">                      II->getArgOperand(0)->getType(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeline">                      getAlignFromValue(II->getArgOperand(2)));</td>
    <td class="lineNumber">638</td>
    <td class="codeline">                      getAlignFromValue(II->getArgOperand(2)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">639</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">640</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeline">  return std::nullopt;</td>
    <td class="lineNumber">641</td>
    <td class="codeline">  return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeline">}</td>
    <td class="lineNumber">642</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeline"></td>
    <td class="lineNumber">643</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeline">auto AlignVectors::isHvx(const AddrInfo &AI) const -> bool {</td>
    <td class="lineNumber">644</td>
    <td class="codeline">auto AlignVectors::isHvx(const AddrInfo &AI) const -> bool {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeline">  return HVC.HST.isTypeForHVX(AI.ValTy);</td>
    <td class="lineNumber">645</td>
    <td class="codeline">  return HVC.HST.isTypeForHVX(AI.ValTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeline">}</td>
    <td class="lineNumber">646</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeline"></td>
    <td class="lineNumber">647</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeline">auto AlignVectors::getPayload(Value *Val) const -> Value * {</td>
    <td class="lineNumber">648</td>
    <td class="codeline">auto AlignVectors::getPayload(Value *Val) const -> Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeline">  if (auto *In = dyn_cast<Instruction>(Val)) {</td>
    <td class="lineNumber">649</td>
    <td class="codeline">  if (auto *In = dyn_cast<Instruction>(Val)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeline">    Intrinsic::ID ID = 0;</td>
    <td class="lineNumber">650</td>
    <td class="codeline">    Intrinsic::ID ID = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeline">    if (auto *II = dyn_cast<IntrinsicInst>(In))</td>
    <td class="lineNumber">651</td>
    <td class="codeline">    if (auto *II = dyn_cast<IntrinsicInst>(In))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeline">      ID = II->getIntrinsicID();</td>
    <td class="lineNumber">652</td>
    <td class="codeline">      ID = II->getIntrinsicID();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeline">    if (isa<StoreInst>(In) || ID == Intrinsic::masked_store)</td>
    <td class="lineNumber">653</td>
    <td class="codeline">    if (isa<StoreInst>(In) || ID == Intrinsic::masked_store)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeline">      return In->getOperand(0);</td>
    <td class="lineNumber">654</td>
    <td class="codeline">      return In->getOperand(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">655</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeline">  return Val;</td>
    <td class="lineNumber">656</td>
    <td class="codeline">  return Val;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeline">}</td>
    <td class="lineNumber">657</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeline"></td>
    <td class="lineNumber">658</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeline">auto AlignVectors::getMask(Value *Val) const -> Value * {</td>
    <td class="lineNumber">659</td>
    <td class="codeline">auto AlignVectors::getMask(Value *Val) const -> Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeline">  if (auto *II = dyn_cast<IntrinsicInst>(Val)) {</td>
    <td class="lineNumber">660</td>
    <td class="codeline">  if (auto *II = dyn_cast<IntrinsicInst>(Val)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeline">    switch (II->getIntrinsicID()) {</td>
    <td class="lineNumber">661</td>
    <td class="codeline">    switch (II->getIntrinsicID()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeline">    case Intrinsic::masked_load:</td>
    <td class="lineNumber">662</td>
    <td class="codeline">    case Intrinsic::masked_load:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeline">      return II->getArgOperand(2);</td>
    <td class="lineNumber">663</td>
    <td class="codeline">      return II->getArgOperand(2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeline">    case Intrinsic::masked_store:</td>
    <td class="lineNumber">664</td>
    <td class="codeline">    case Intrinsic::masked_store:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeline">      return II->getArgOperand(3);</td>
    <td class="lineNumber">665</td>
    <td class="codeline">      return II->getArgOperand(3);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">666</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">667</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeline"></td>
    <td class="lineNumber">668</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeline">  Type *ValTy = getPayload(Val)->getType();</td>
    <td class="lineNumber">669</td>
    <td class="codeline">  Type *ValTy = getPayload(Val)->getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeline">  if (auto *VecTy = dyn_cast<VectorType>(ValTy))</td>
    <td class="lineNumber">670</td>
    <td class="codeline">  if (auto *VecTy = dyn_cast<VectorType>(ValTy))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeline">    return HVC.getFullValue(HVC.getBoolTy(HVC.length(VecTy)));</td>
    <td class="lineNumber">671</td>
    <td class="codeline">    return HVC.getFullValue(HVC.getBoolTy(HVC.length(VecTy)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeline">  return HVC.getFullValue(HVC.getBoolTy());</td>
    <td class="lineNumber">672</td>
    <td class="codeline">  return HVC.getFullValue(HVC.getBoolTy());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeline">}</td>
    <td class="lineNumber">673</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeline"></td>
    <td class="lineNumber">674</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeline">auto AlignVectors::getPassThrough(Value *Val) const -> Value * {</td>
    <td class="lineNumber">675</td>
    <td class="codeline">auto AlignVectors::getPassThrough(Value *Val) const -> Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeline">  if (auto *II = dyn_cast<IntrinsicInst>(Val)) {</td>
    <td class="lineNumber">676</td>
    <td class="codeline">  if (auto *II = dyn_cast<IntrinsicInst>(Val)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeline">    if (II->getIntrinsicID() == Intrinsic::masked_load)</td>
    <td class="lineNumber">677</td>
    <td class="codeline">    if (II->getIntrinsicID() == Intrinsic::masked_load)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeline">      return II->getArgOperand(3);</td>
    <td class="lineNumber">678</td>
    <td class="codeline">      return II->getArgOperand(3);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">679</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeline">  return UndefValue::get(getPayload(Val)->getType());</td>
    <td class="lineNumber">680</td>
    <td class="codeline">  return UndefValue::get(getPayload(Val)->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeline">}</td>
    <td class="lineNumber">681</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeline"></td>
    <td class="lineNumber">682</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeline">auto AlignVectors::createAdjustedPointer(IRBuilderBase &Builder, Value *Ptr,</td>
    <td class="lineNumber">683</td>
    <td class="codeline">auto AlignVectors::createAdjustedPointer(IRBuilderBase &Builder, Value *Ptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeline">                                         Type *ValTy, int Adjust,</td>
    <td class="lineNumber">684</td>
    <td class="codeline">                                         Type *ValTy, int Adjust,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeline">                                         const InstMap &CloneMap) const</td>
    <td class="lineNumber">685</td>
    <td class="codeline">                                         const InstMap &CloneMap) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeline">    -> Value * {</td>
    <td class="lineNumber">686</td>
    <td class="codeline">    -> Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeline">  if (auto *I = dyn_cast<Instruction>(Ptr))</td>
    <td class="lineNumber">687</td>
    <td class="codeline">  if (auto *I = dyn_cast<Instruction>(Ptr))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeline">    if (Instruction *New = CloneMap.lookup(I))</td>
    <td class="lineNumber">688</td>
    <td class="codeline">    if (Instruction *New = CloneMap.lookup(I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeline">      Ptr = New;</td>
    <td class="lineNumber">689</td>
    <td class="codeline">      Ptr = New;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeline">  return Builder.CreateGEP(Type::getInt8Ty(HVC.F.getContext()), Ptr,</td>
    <td class="lineNumber">690</td>
    <td class="codeline">  return Builder.CreateGEP(Type::getInt8Ty(HVC.F.getContext()), Ptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeline">                           HVC.getConstInt(Adjust), "gep");</td>
    <td class="lineNumber">691</td>
    <td class="codeline">                           HVC.getConstInt(Adjust), "gep");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeline">}</td>
    <td class="lineNumber">692</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeline"></td>
    <td class="lineNumber">693</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeline">auto AlignVectors::createAlignedPointer(IRBuilderBase &Builder, Value *Ptr,</td>
    <td class="lineNumber">694</td>
    <td class="codeline">auto AlignVectors::createAlignedPointer(IRBuilderBase &Builder, Value *Ptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeline">                                        Type *ValTy, int Alignment,</td>
    <td class="lineNumber">695</td>
    <td class="codeline">                                        Type *ValTy, int Alignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeline">                                        const InstMap &CloneMap) const</td>
    <td class="lineNumber">696</td>
    <td class="codeline">                                        const InstMap &CloneMap) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeline">    -> Value * {</td>
    <td class="lineNumber">697</td>
    <td class="codeline">    -> Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeline">  auto remap = [&](Value *V) -> Value * {</td>
    <td class="lineNumber">698</td>
    <td class="codeline">  auto remap = [&](Value *V) -> Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeline">    if (auto *I = dyn_cast<Instruction>(V)) {</td>
    <td class="lineNumber">699</td>
    <td class="codeline">    if (auto *I = dyn_cast<Instruction>(V)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeline">      for (auto [Old, New] : CloneMap)</td>
    <td class="lineNumber">700</td>
    <td class="codeline">      for (auto [Old, New] : CloneMap)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeline">        I->replaceUsesOfWith(Old, New);</td>
    <td class="lineNumber">701</td>
    <td class="codeline">        I->replaceUsesOfWith(Old, New);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeline">      return I;</td>
    <td class="lineNumber">702</td>
    <td class="codeline">      return I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">703</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeline">    return V;</td>
    <td class="lineNumber">704</td>
    <td class="codeline">    return V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">705</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeline">  Value *AsInt = Builder.CreatePtrToInt(Ptr, HVC.getIntTy(), "pti");</td>
    <td class="lineNumber">706</td>
    <td class="codeline">  Value *AsInt = Builder.CreatePtrToInt(Ptr, HVC.getIntTy(), "pti");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeline">  Value *Mask = HVC.getConstInt(-Alignment);</td>
    <td class="lineNumber">707</td>
    <td class="codeline">  Value *Mask = HVC.getConstInt(-Alignment);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeline">  Value *And = Builder.CreateAnd(remap(AsInt), Mask, "and");</td>
    <td class="lineNumber">708</td>
    <td class="codeline">  Value *And = Builder.CreateAnd(remap(AsInt), Mask, "and");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeline">  return Builder.CreateIntToPtr(And, ValTy->getPointerTo(), "itp");</td>
    <td class="lineNumber">709</td>
    <td class="codeline">  return Builder.CreateIntToPtr(And, ValTy->getPointerTo(), "itp");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeline">}</td>
    <td class="lineNumber">710</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeline"></td>
    <td class="lineNumber">711</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeline">auto AlignVectors::createLoad(IRBuilderBase &Builder, Type *ValTy, Value *Ptr,</td>
    <td class="lineNumber">712</td>
    <td class="codeline">auto AlignVectors::createLoad(IRBuilderBase &Builder, Type *ValTy, Value *Ptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeline">                              Value *Predicate, int Alignment, Value *Mask,</td>
    <td class="lineNumber">713</td>
    <td class="codeline">                              Value *Predicate, int Alignment, Value *Mask,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeline">                              Value *PassThru,</td>
    <td class="lineNumber">714</td>
    <td class="codeline">                              Value *PassThru,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeline">                              ArrayRef<Value *> MDSources) const -> Value * {</td>
    <td class="lineNumber">715</td>
    <td class="codeline">                              ArrayRef<Value *> MDSources) const -> Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeline">  bool HvxHasPredLoad = HVC.HST.useHVXV62Ops();</td>
    <td class="lineNumber">716</td>
    <td class="codeline">  bool HvxHasPredLoad = HVC.HST.useHVXV62Ops();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeline">  // Predicate is nullptr if not creating predicated load</td>
    <td class="lineNumber">717</td>
    <td class="codeline">  // Predicate is nullptr if not creating predicated load</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeline">  if (Predicate) {</td>
    <td class="lineNumber">718</td>
    <td class="codeline">  if (Predicate) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeline">    assert(!Predicate->getType()->isVectorTy() &&</td>
    <td class="lineNumber">719</td>
    <td class="codeline">    assert(!Predicate->getType()->isVectorTy() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeline">           "Expectning scalar predicate");</td>
    <td class="lineNumber">720</td>
    <td class="codeline">           "Expectning scalar predicate");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeline">    if (HVC.isFalse(Predicate))</td>
    <td class="lineNumber">721</td>
    <td class="codeline">    if (HVC.isFalse(Predicate))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeline">      return UndefValue::get(ValTy);</td>
    <td class="lineNumber">722</td>
    <td class="codeline">      return UndefValue::get(ValTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeline">    if (!HVC.isTrue(Predicate) && HvxHasPredLoad) {</td>
    <td class="lineNumber">723</td>
    <td class="codeline">    if (!HVC.isTrue(Predicate) && HvxHasPredLoad) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeline">      Value *Load = createPredicatedLoad(Builder, ValTy, Ptr, Predicate,</td>
    <td class="lineNumber">724</td>
    <td class="codeline">      Value *Load = createPredicatedLoad(Builder, ValTy, Ptr, Predicate,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeline">                                         Alignment, MDSources);</td>
    <td class="lineNumber">725</td>
    <td class="codeline">                                         Alignment, MDSources);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeline">      return Builder.CreateSelect(Mask, Load, PassThru);</td>
    <td class="lineNumber">726</td>
    <td class="codeline">      return Builder.CreateSelect(Mask, Load, PassThru);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">727</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeline">    // Predicate == true here.</td>
    <td class="lineNumber">728</td>
    <td class="codeline">    // Predicate == true here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">729</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeline">  assert(!HVC.isUndef(Mask)); // Should this be allowed?</td>
    <td class="lineNumber">730</td>
    <td class="codeline">  assert(!HVC.isUndef(Mask)); // Should this be allowed?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeline">  if (HVC.isZero(Mask))</td>
    <td class="lineNumber">731</td>
    <td class="codeline">  if (HVC.isZero(Mask))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeline">    return PassThru;</td>
    <td class="lineNumber">732</td>
    <td class="codeline">    return PassThru;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeline">  if (HVC.isTrue(Mask))</td>
    <td class="lineNumber">733</td>
    <td class="codeline">  if (HVC.isTrue(Mask))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeline">    return createSimpleLoad(Builder, ValTy, Ptr, Alignment, MDSources);</td>
    <td class="lineNumber">734</td>
    <td class="codeline">    return createSimpleLoad(Builder, ValTy, Ptr, Alignment, MDSources);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeline"></td>
    <td class="lineNumber">735</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeline">  Instruction *Load = Builder.CreateMaskedLoad(ValTy, Ptr, Align(Alignment),</td>
    <td class="lineNumber">736</td>
    <td class="codeline">  Instruction *Load = Builder.CreateMaskedLoad(ValTy, Ptr, Align(Alignment),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeline">                                               Mask, PassThru, "mld");</td>
    <td class="lineNumber">737</td>
    <td class="codeline">                                               Mask, PassThru, "mld");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeline">  propagateMetadata(Load, MDSources);</td>
    <td class="lineNumber">738</td>
    <td class="codeline">  propagateMetadata(Load, MDSources);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeline">  return Load;</td>
    <td class="lineNumber">739</td>
    <td class="codeline">  return Load;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeline">}</td>
    <td class="lineNumber">740</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeline"></td>
    <td class="lineNumber">741</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeline">auto AlignVectors::createSimpleLoad(IRBuilderBase &Builder, Type *ValTy,</td>
    <td class="lineNumber">742</td>
    <td class="codeline">auto AlignVectors::createSimpleLoad(IRBuilderBase &Builder, Type *ValTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeline">                                    Value *Ptr, int Alignment,</td>
    <td class="lineNumber">743</td>
    <td class="codeline">                                    Value *Ptr, int Alignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeline">                                    ArrayRef<Value *> MDSources) const</td>
    <td class="lineNumber">744</td>
    <td class="codeline">                                    ArrayRef<Value *> MDSources) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeline">    -> Value * {</td>
    <td class="lineNumber">745</td>
    <td class="codeline">    -> Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeline">  Instruction *Load =</td>
    <td class="lineNumber">746</td>
    <td class="codeline">  Instruction *Load =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeline">      Builder.CreateAlignedLoad(ValTy, Ptr, Align(Alignment), "ald");</td>
    <td class="lineNumber">747</td>
    <td class="codeline">      Builder.CreateAlignedLoad(ValTy, Ptr, Align(Alignment), "ald");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeline">  propagateMetadata(Load, MDSources);</td>
    <td class="lineNumber">748</td>
    <td class="codeline">  propagateMetadata(Load, MDSources);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeline">  return Load;</td>
    <td class="lineNumber">749</td>
    <td class="codeline">  return Load;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeline">}</td>
    <td class="lineNumber">750</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeline"></td>
    <td class="lineNumber">751</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeline">auto AlignVectors::createPredicatedLoad(IRBuilderBase &Builder, Type *ValTy,</td>
    <td class="lineNumber">752</td>
    <td class="codeline">auto AlignVectors::createPredicatedLoad(IRBuilderBase &Builder, Type *ValTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeline">                                        Value *Ptr, Value *Predicate,</td>
    <td class="lineNumber">753</td>
    <td class="codeline">                                        Value *Ptr, Value *Predicate,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeline">                                        int Alignment,</td>
    <td class="lineNumber">754</td>
    <td class="codeline">                                        int Alignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeline">                                        ArrayRef<Value *> MDSources) const</td>
    <td class="lineNumber">755</td>
    <td class="codeline">                                        ArrayRef<Value *> MDSources) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeline">    -> Value * {</td>
    <td class="lineNumber">756</td>
    <td class="codeline">    -> Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeline">  assert(HVC.HST.isTypeForHVX(ValTy) &&</td>
    <td class="lineNumber">757</td>
    <td class="codeline">  assert(HVC.HST.isTypeForHVX(ValTy) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeline">         "Predicates 'scalar' vector loads not yet supported");</td>
    <td class="lineNumber">758</td>
    <td class="codeline">         "Predicates 'scalar' vector loads not yet supported");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeline">  assert(Predicate);</td>
    <td class="lineNumber">759</td>
    <td class="codeline">  assert(Predicate);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeline">  assert(!Predicate->getType()->isVectorTy() && "Expectning scalar predicate");</td>
    <td class="lineNumber">760</td>
    <td class="codeline">  assert(!Predicate->getType()->isVectorTy() && "Expectning scalar predicate");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeline">  assert(HVC.getSizeOf(ValTy, HVC.Alloc) % Alignment == 0);</td>
    <td class="lineNumber">761</td>
    <td class="codeline">  assert(HVC.getSizeOf(ValTy, HVC.Alloc) % Alignment == 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeline">  if (HVC.isFalse(Predicate))</td>
    <td class="lineNumber">762</td>
    <td class="codeline">  if (HVC.isFalse(Predicate))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeline">    return UndefValue::get(ValTy);</td>
    <td class="lineNumber">763</td>
    <td class="codeline">    return UndefValue::get(ValTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeline">  if (HVC.isTrue(Predicate))</td>
    <td class="lineNumber">764</td>
    <td class="codeline">  if (HVC.isTrue(Predicate))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeline">    return createSimpleLoad(Builder, ValTy, Ptr, Alignment, MDSources);</td>
    <td class="lineNumber">765</td>
    <td class="codeline">    return createSimpleLoad(Builder, ValTy, Ptr, Alignment, MDSources);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeline"></td>
    <td class="lineNumber">766</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeline">  auto V6_vL32b_pred_ai = HVC.HST.getIntrinsicId(Hexagon::V6_vL32b_pred_ai);</td>
    <td class="lineNumber">767</td>
    <td class="codeline">  auto V6_vL32b_pred_ai = HVC.HST.getIntrinsicId(Hexagon::V6_vL32b_pred_ai);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeline">  // FIXME: This may not put the offset from Ptr into the vmem offset.</td>
    <td class="lineNumber">768</td>
    <td class="codeline">  // FIXME: This may not put the offset from Ptr into the vmem offset.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeline">  return HVC.createHvxIntrinsic(Builder, V6_vL32b_pred_ai, ValTy,</td>
    <td class="lineNumber">769</td>
    <td class="codeline">  return HVC.createHvxIntrinsic(Builder, V6_vL32b_pred_ai, ValTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeline">                                {Predicate, Ptr, HVC.getConstInt(0)},</td>
    <td class="lineNumber">770</td>
    <td class="codeline">                                {Predicate, Ptr, HVC.getConstInt(0)},</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeline">                                std::nullopt, MDSources);</td>
    <td class="lineNumber">771</td>
    <td class="codeline">                                std::nullopt, MDSources);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeline">}</td>
    <td class="lineNumber">772</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeline"></td>
    <td class="lineNumber">773</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeline">auto AlignVectors::createStore(IRBuilderBase &Builder, Value *Val, Value *Ptr,</td>
    <td class="lineNumber">774</td>
    <td class="codeline">auto AlignVectors::createStore(IRBuilderBase &Builder, Value *Val, Value *Ptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeline">                               Value *Predicate, int Alignment, Value *Mask,</td>
    <td class="lineNumber">775</td>
    <td class="codeline">                               Value *Predicate, int Alignment, Value *Mask,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeline">                               ArrayRef<Value *> MDSources) const -> Value * {</td>
    <td class="lineNumber">776</td>
    <td class="codeline">                               ArrayRef<Value *> MDSources) const -> Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeline">  if (HVC.isZero(Mask) || HVC.isUndef(Val) || HVC.isUndef(Mask))</td>
    <td class="lineNumber">777</td>
    <td class="codeline">  if (HVC.isZero(Mask) || HVC.isUndef(Val) || HVC.isUndef(Mask))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeline">    return UndefValue::get(Val->getType());</td>
    <td class="lineNumber">778</td>
    <td class="codeline">    return UndefValue::get(Val->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeline">  assert(!Predicate || (!Predicate->getType()->isVectorTy() &&</td>
    <td class="lineNumber">779</td>
    <td class="codeline">  assert(!Predicate || (!Predicate->getType()->isVectorTy() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeline">                        "Expectning scalar predicate"));</td>
    <td class="lineNumber">780</td>
    <td class="codeline">                        "Expectning scalar predicate"));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeline">  if (Predicate) {</td>
    <td class="lineNumber">781</td>
    <td class="codeline">  if (Predicate) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeline">    if (HVC.isFalse(Predicate))</td>
    <td class="lineNumber">782</td>
    <td class="codeline">    if (HVC.isFalse(Predicate))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeline">      return UndefValue::get(Val->getType());</td>
    <td class="lineNumber">783</td>
    <td class="codeline">      return UndefValue::get(Val->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeline">    if (HVC.isTrue(Predicate))</td>
    <td class="lineNumber">784</td>
    <td class="codeline">    if (HVC.isTrue(Predicate))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeline">      Predicate = nullptr;</td>
    <td class="lineNumber">785</td>
    <td class="codeline">      Predicate = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">786</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeline">  // Here both Predicate and Mask are true or unknown.</td>
    <td class="lineNumber">787</td>
    <td class="codeline">  // Here both Predicate and Mask are true or unknown.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeline"></td>
    <td class="lineNumber">788</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeline">  if (HVC.isTrue(Mask)) {</td>
    <td class="lineNumber">789</td>
    <td class="codeline">  if (HVC.isTrue(Mask)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeline">    if (Predicate) { // Predicate unknown</td>
    <td class="lineNumber">790</td>
    <td class="codeline">    if (Predicate) { // Predicate unknown</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeline">      return createPredicatedStore(Builder, Val, Ptr, Predicate, Alignment,</td>
    <td class="lineNumber">791</td>
    <td class="codeline">      return createPredicatedStore(Builder, Val, Ptr, Predicate, Alignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeline">                                   MDSources);</td>
    <td class="lineNumber">792</td>
    <td class="codeline">                                   MDSources);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">793</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeline">    // Predicate is true:</td>
    <td class="lineNumber">794</td>
    <td class="codeline">    // Predicate is true:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeline">    return createSimpleStore(Builder, Val, Ptr, Alignment, MDSources);</td>
    <td class="lineNumber">795</td>
    <td class="codeline">    return createSimpleStore(Builder, Val, Ptr, Alignment, MDSources);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">796</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeline"></td>
    <td class="lineNumber">797</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeline">  // Mask is unknown</td>
    <td class="lineNumber">798</td>
    <td class="codeline">  // Mask is unknown</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeline">  if (!Predicate) {</td>
    <td class="lineNumber">799</td>
    <td class="codeline">  if (!Predicate) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeline">    Instruction *Store =</td>
    <td class="lineNumber">800</td>
    <td class="codeline">    Instruction *Store =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeline">        Builder.CreateMaskedStore(Val, Ptr, Align(Alignment), Mask);</td>
    <td class="lineNumber">801</td>
    <td class="codeline">        Builder.CreateMaskedStore(Val, Ptr, Align(Alignment), Mask);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeline">    propagateMetadata(Store, MDSources);</td>
    <td class="lineNumber">802</td>
    <td class="codeline">    propagateMetadata(Store, MDSources);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeline">    return Store;</td>
    <td class="lineNumber">803</td>
    <td class="codeline">    return Store;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">804</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeline"></td>
    <td class="lineNumber">805</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeline">  // Both Predicate and Mask are unknown.</td>
    <td class="lineNumber">806</td>
    <td class="codeline">  // Both Predicate and Mask are unknown.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeline">  // Emulate masked store with predicated-load + mux + predicated-store.</td>
    <td class="lineNumber">807</td>
    <td class="codeline">  // Emulate masked store with predicated-load + mux + predicated-store.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeline">  Value *PredLoad = createPredicatedLoad(Builder, Val->getType(), Ptr,</td>
    <td class="lineNumber">808</td>
    <td class="codeline">  Value *PredLoad = createPredicatedLoad(Builder, Val->getType(), Ptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeline">                                         Predicate, Alignment, MDSources);</td>
    <td class="lineNumber">809</td>
    <td class="codeline">                                         Predicate, Alignment, MDSources);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeline">  Value *Mux = Builder.CreateSelect(Mask, Val, PredLoad);</td>
    <td class="lineNumber">810</td>
    <td class="codeline">  Value *Mux = Builder.CreateSelect(Mask, Val, PredLoad);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeline">  return createPredicatedStore(Builder, Mux, Ptr, Predicate, Alignment,</td>
    <td class="lineNumber">811</td>
    <td class="codeline">  return createPredicatedStore(Builder, Mux, Ptr, Predicate, Alignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeline">                               MDSources);</td>
    <td class="lineNumber">812</td>
    <td class="codeline">                               MDSources);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeline">}</td>
    <td class="lineNumber">813</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeline"></td>
    <td class="lineNumber">814</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeline">auto AlignVectors::createSimpleStore(IRBuilderBase &Builder, Value *Val,</td>
    <td class="lineNumber">815</td>
    <td class="codeline">auto AlignVectors::createSimpleStore(IRBuilderBase &Builder, Value *Val,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeline">                                     Value *Ptr, int Alignment,</td>
    <td class="lineNumber">816</td>
    <td class="codeline">                                     Value *Ptr, int Alignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeline">                                     ArrayRef<Value *> MDSources) const</td>
    <td class="lineNumber">817</td>
    <td class="codeline">                                     ArrayRef<Value *> MDSources) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeline">    -> Value * {</td>
    <td class="lineNumber">818</td>
    <td class="codeline">    -> Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeline">  Instruction *Store = Builder.CreateAlignedStore(Val, Ptr, Align(Alignment));</td>
    <td class="lineNumber">819</td>
    <td class="codeline">  Instruction *Store = Builder.CreateAlignedStore(Val, Ptr, Align(Alignment));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeline">  propagateMetadata(Store, MDSources);</td>
    <td class="lineNumber">820</td>
    <td class="codeline">  propagateMetadata(Store, MDSources);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeline">  return Store;</td>
    <td class="lineNumber">821</td>
    <td class="codeline">  return Store;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeline">}</td>
    <td class="lineNumber">822</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeline"></td>
    <td class="lineNumber">823</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeline">auto AlignVectors::createPredicatedStore(IRBuilderBase &Builder, Value *Val,</td>
    <td class="lineNumber">824</td>
    <td class="codeline">auto AlignVectors::createPredicatedStore(IRBuilderBase &Builder, Value *Val,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeline">                                         Value *Ptr, Value *Predicate,</td>
    <td class="lineNumber">825</td>
    <td class="codeline">                                         Value *Ptr, Value *Predicate,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeline">                                         int Alignment,</td>
    <td class="lineNumber">826</td>
    <td class="codeline">                                         int Alignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeline">                                         ArrayRef<Value *> MDSources) const</td>
    <td class="lineNumber">827</td>
    <td class="codeline">                                         ArrayRef<Value *> MDSources) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeline">    -> Value * {</td>
    <td class="lineNumber">828</td>
    <td class="codeline">    -> Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeline">  assert(HVC.HST.isTypeForHVX(Val->getType()) &&</td>
    <td class="lineNumber">829</td>
    <td class="codeline">  assert(HVC.HST.isTypeForHVX(Val->getType()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeline">         "Predicates 'scalar' vector stores not yet supported");</td>
    <td class="lineNumber">830</td>
    <td class="codeline">         "Predicates 'scalar' vector stores not yet supported");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeline">  assert(Predicate);</td>
    <td class="lineNumber">831</td>
    <td class="codeline">  assert(Predicate);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeline">  if (HVC.isFalse(Predicate))</td>
    <td class="lineNumber">832</td>
    <td class="codeline">  if (HVC.isFalse(Predicate))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeline">    return UndefValue::get(Val->getType());</td>
    <td class="lineNumber">833</td>
    <td class="codeline">    return UndefValue::get(Val->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeline">  if (HVC.isTrue(Predicate))</td>
    <td class="lineNumber">834</td>
    <td class="codeline">  if (HVC.isTrue(Predicate))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeline">    return createSimpleStore(Builder, Val, Ptr, Alignment, MDSources);</td>
    <td class="lineNumber">835</td>
    <td class="codeline">    return createSimpleStore(Builder, Val, Ptr, Alignment, MDSources);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeline"></td>
    <td class="lineNumber">836</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeline">  assert(HVC.getSizeOf(Val, HVC.Alloc) % Alignment == 0);</td>
    <td class="lineNumber">837</td>
    <td class="codeline">  assert(HVC.getSizeOf(Val, HVC.Alloc) % Alignment == 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeline">  auto V6_vS32b_pred_ai = HVC.HST.getIntrinsicId(Hexagon::V6_vS32b_pred_ai);</td>
    <td class="lineNumber">838</td>
    <td class="codeline">  auto V6_vS32b_pred_ai = HVC.HST.getIntrinsicId(Hexagon::V6_vS32b_pred_ai);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeline">  // FIXME: This may not put the offset from Ptr into the vmem offset.</td>
    <td class="lineNumber">839</td>
    <td class="codeline">  // FIXME: This may not put the offset from Ptr into the vmem offset.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeline">  return HVC.createHvxIntrinsic(Builder, V6_vS32b_pred_ai, nullptr,</td>
    <td class="lineNumber">840</td>
    <td class="codeline">  return HVC.createHvxIntrinsic(Builder, V6_vS32b_pred_ai, nullptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeline">                                {Predicate, Ptr, HVC.getConstInt(0), Val},</td>
    <td class="lineNumber">841</td>
    <td class="codeline">                                {Predicate, Ptr, HVC.getConstInt(0), Val},</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeline">                                std::nullopt, MDSources);</td>
    <td class="lineNumber">842</td>
    <td class="codeline">                                std::nullopt, MDSources);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeline">}</td>
    <td class="lineNumber">843</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeline"></td>
    <td class="lineNumber">844</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeline">auto AlignVectors::getUpwardDeps(Instruction *In, Instruction *Base) const</td>
    <td class="lineNumber">845</td>
    <td class="codeline">auto AlignVectors::getUpwardDeps(Instruction *In, Instruction *Base) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeline">    -> DepList {</td>
    <td class="lineNumber">846</td>
    <td class="codeline">    -> DepList {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeline">  BasicBlock *Parent = Base->getParent();</td>
    <td class="lineNumber">847</td>
    <td class="codeline">  BasicBlock *Parent = Base->getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeline">  assert(In->getParent() == Parent &&</td>
    <td class="lineNumber">848</td>
    <td class="codeline">  assert(In->getParent() == Parent &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeline">         "Base and In should be in the same block");</td>
    <td class="lineNumber">849</td>
    <td class="codeline">         "Base and In should be in the same block");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeline">  assert(Base->comesBefore(In) && "Base should come before In");</td>
    <td class="lineNumber">850</td>
    <td class="codeline">  assert(Base->comesBefore(In) && "Base should come before In");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeline"></td>
    <td class="lineNumber">851</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeline">  DepList Deps;</td>
    <td class="lineNumber">852</td>
    <td class="codeline">  DepList Deps;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeline">  std::deque<Instruction *> WorkQ = {In};</td>
    <td class="lineNumber">853</td>
    <td class="codeline">  std::deque<Instruction *> WorkQ = {In};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeline">  while (!WorkQ.empty()) {</td>
    <td class="lineNumber">854</td>
    <td class="codeline">  while (!WorkQ.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeline">    Instruction *D = WorkQ.front();</td>
    <td class="lineNumber">855</td>
    <td class="codeline">    Instruction *D = WorkQ.front();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeline">    WorkQ.pop_front();</td>
    <td class="lineNumber">856</td>
    <td class="codeline">    WorkQ.pop_front();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeline">    if (D != In)</td>
    <td class="lineNumber">857</td>
    <td class="codeline">    if (D != In)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeline">      Deps.insert(D);</td>
    <td class="lineNumber">858</td>
    <td class="codeline">      Deps.insert(D);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeline">    for (Value *Op : D->operands()) {</td>
    <td class="lineNumber">859</td>
    <td class="codeline">    for (Value *Op : D->operands()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeline">      if (auto *I = dyn_cast<Instruction>(Op)) {</td>
    <td class="lineNumber">860</td>
    <td class="codeline">      if (auto *I = dyn_cast<Instruction>(Op)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeline">        if (I->getParent() == Parent && Base->comesBefore(I))</td>
    <td class="lineNumber">861</td>
    <td class="codeline">        if (I->getParent() == Parent && Base->comesBefore(I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeline">          WorkQ.push_back(I);</td>
    <td class="lineNumber">862</td>
    <td class="codeline">          WorkQ.push_back(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">863</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">864</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">865</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeline">  return Deps;</td>
    <td class="lineNumber">866</td>
    <td class="codeline">  return Deps;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeline">}</td>
    <td class="lineNumber">867</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeline"></td>
    <td class="lineNumber">868</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeline">auto AlignVectors::createAddressGroups() -> bool {</td>
    <td class="lineNumber">869</td>
    <td class="codeline">auto AlignVectors::createAddressGroups() -> bool {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeline">  // An address group created here may contain instructions spanning</td>
    <td class="lineNumber">870</td>
    <td class="codeline">  // An address group created here may contain instructions spanning</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeline">  // multiple basic blocks.</td>
    <td class="lineNumber">871</td>
    <td class="codeline">  // multiple basic blocks.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeline">  AddrList WorkStack;</td>
    <td class="lineNumber">872</td>
    <td class="codeline">  AddrList WorkStack;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeline"></td>
    <td class="lineNumber">873</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeline">  auto findBaseAndOffset = [&](AddrInfo &AI) -> std::pair<Instruction *, int> {</td>
    <td class="lineNumber">874</td>
    <td class="codeline">  auto findBaseAndOffset = [&](AddrInfo &AI) -> std::pair<Instruction *, int> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeline">    for (AddrInfo &W : WorkStack) {</td>
    <td class="lineNumber">875</td>
    <td class="codeline">    for (AddrInfo &W : WorkStack) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeline">      if (auto D = HVC.calculatePointerDifference(AI.Addr, W.Addr))</td>
    <td class="lineNumber">876</td>
    <td class="codeline">      if (auto D = HVC.calculatePointerDifference(AI.Addr, W.Addr))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeline">        return std::make_pair(W.Inst, *D);</td>
    <td class="lineNumber">877</td>
    <td class="codeline">        return std::make_pair(W.Inst, *D);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">878</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeline">    return std::make_pair(nullptr, 0);</td>
    <td class="lineNumber">879</td>
    <td class="codeline">    return std::make_pair(nullptr, 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">880</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeline"></td>
    <td class="lineNumber">881</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeline">  auto traverseBlock = [&](DomTreeNode *DomN, auto Visit) -> void {</td>
    <td class="lineNumber">882</td>
    <td class="codeline">  auto traverseBlock = [&](DomTreeNode *DomN, auto Visit) -> void {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeline">    BasicBlock &Block = *DomN->getBlock();</td>
    <td class="lineNumber">883</td>
    <td class="codeline">    BasicBlock &Block = *DomN->getBlock();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeline">    for (Instruction &I : Block) {</td>
    <td class="lineNumber">884</td>
    <td class="codeline">    for (Instruction &I : Block) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeline">      auto AI = this->getAddrInfo(I); // Use this-> for gcc6.</td>
    <td class="lineNumber">885</td>
    <td class="codeline">      auto AI = this->getAddrInfo(I); // Use this-> for gcc6.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeline">      if (!AI)</td>
    <td class="lineNumber">886</td>
    <td class="codeline">      if (!AI)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">887</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeline">      auto F = findBaseAndOffset(*AI);</td>
    <td class="lineNumber">888</td>
    <td class="codeline">      auto F = findBaseAndOffset(*AI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeline">      Instruction *GroupInst;</td>
    <td class="lineNumber">889</td>
    <td class="codeline">      Instruction *GroupInst;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeline">      if (Instruction *BI = F.first) {</td>
    <td class="lineNumber">890</td>
    <td class="codeline">      if (Instruction *BI = F.first) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeline">        AI->Offset = F.second;</td>
    <td class="lineNumber">891</td>
    <td class="codeline">        AI->Offset = F.second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeline">        GroupInst = BI;</td>
    <td class="lineNumber">892</td>
    <td class="codeline">        GroupInst = BI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">893</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeline">        WorkStack.push_back(*AI);</td>
    <td class="lineNumber">894</td>
    <td class="codeline">        WorkStack.push_back(*AI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeline">        GroupInst = AI->Inst;</td>
    <td class="lineNumber">895</td>
    <td class="codeline">        GroupInst = AI->Inst;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">896</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeline">      AddrGroups[GroupInst].push_back(*AI);</td>
    <td class="lineNumber">897</td>
    <td class="codeline">      AddrGroups[GroupInst].push_back(*AI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">898</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeline"></td>
    <td class="lineNumber">899</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeline">    for (DomTreeNode *C : DomN->children())</td>
    <td class="lineNumber">900</td>
    <td class="codeline">    for (DomTreeNode *C : DomN->children())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeline">      Visit(C, Visit);</td>
    <td class="lineNumber">901</td>
    <td class="codeline">      Visit(C, Visit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeline"></td>
    <td class="lineNumber">902</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeline">    while (!WorkStack.empty() && WorkStack.back().Inst->getParent() == &Block)</td>
    <td class="lineNumber">903</td>
    <td class="codeline">    while (!WorkStack.empty() && WorkStack.back().Inst->getParent() == &Block)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeline">      WorkStack.pop_back();</td>
    <td class="lineNumber">904</td>
    <td class="codeline">      WorkStack.pop_back();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">905</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeline"></td>
    <td class="lineNumber">906</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeline">  traverseBlock(HVC.DT.getRootNode(), traverseBlock);</td>
    <td class="lineNumber">907</td>
    <td class="codeline">  traverseBlock(HVC.DT.getRootNode(), traverseBlock);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeline">  assert(WorkStack.empty());</td>
    <td class="lineNumber">908</td>
    <td class="codeline">  assert(WorkStack.empty());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeline"></td>
    <td class="lineNumber">909</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeline">  // AddrGroups are formed.</td>
    <td class="lineNumber">910</td>
    <td class="codeline">  // AddrGroups are formed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeline"></td>
    <td class="lineNumber">911</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeline">  // Remove groups of size 1.</td>
    <td class="lineNumber">912</td>
    <td class="codeline">  // Remove groups of size 1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeline">  erase_if(AddrGroups, [](auto &G) { return G.second.size() == 1; });</td>
    <td class="lineNumber">913</td>
    <td class="codeline">  erase_if(AddrGroups, [](auto &G) { return G.second.size() == 1; });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeline">  // Remove groups that don't use HVX types.</td>
    <td class="lineNumber">914</td>
    <td class="codeline">  // Remove groups that don't use HVX types.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeline">  erase_if(AddrGroups, [&](auto &G) {</td>
    <td class="lineNumber">915</td>
    <td class="codeline">  erase_if(AddrGroups, [&](auto &G) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeline">    return llvm::none_of(</td>
    <td class="lineNumber">916</td>
    <td class="codeline">    return llvm::none_of(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeline">        G.second, [&](auto &I) { return HVC.HST.isTypeForHVX(I.ValTy); });</td>
    <td class="lineNumber">917</td>
    <td class="codeline">        G.second, [&](auto &I) { return HVC.HST.isTypeForHVX(I.ValTy); });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">918</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeline"></td>
    <td class="lineNumber">919</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeline">  return !AddrGroups.empty();</td>
    <td class="lineNumber">920</td>
    <td class="codeline">  return !AddrGroups.empty();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeline">}</td>
    <td class="lineNumber">921</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeline"></td>
    <td class="lineNumber">922</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeline">auto AlignVectors::createLoadGroups(const AddrList &Group) const -> MoveList {</td>
    <td class="lineNumber">923</td>
    <td class="codeline">auto AlignVectors::createLoadGroups(const AddrList &Group) const -> MoveList {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeline">  // Form load groups.</td>
    <td class="lineNumber">924</td>
    <td class="codeline">  // Form load groups.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeline">  // To avoid complications with moving code across basic blocks, only form</td>
    <td class="lineNumber">925</td>
    <td class="codeline">  // To avoid complications with moving code across basic blocks, only form</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeline">  // groups that are contained within a single basic block.</td>
    <td class="lineNumber">926</td>
    <td class="codeline">  // groups that are contained within a single basic block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeline">  unsigned SizeLimit = VAGroupSizeLimit;</td>
    <td class="lineNumber">927</td>
    <td class="codeline">  unsigned SizeLimit = VAGroupSizeLimit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeline">  if (SizeLimit == 0)</td>
    <td class="lineNumber">928</td>
    <td class="codeline">  if (SizeLimit == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeline">    return {};</td>
    <td class="lineNumber">929</td>
    <td class="codeline">    return {};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeline"></td>
    <td class="lineNumber">930</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeline">  auto tryAddTo = [&](const AddrInfo &Info, MoveGroup &Move) {</td>
    <td class="lineNumber">931</td>
    <td class="codeline">  auto tryAddTo = [&](const AddrInfo &Info, MoveGroup &Move) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeline">    assert(!Move.Main.empty() && "Move group should have non-empty Main");</td>
    <td class="lineNumber">932</td>
    <td class="codeline">    assert(!Move.Main.empty() && "Move group should have non-empty Main");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeline">    if (Move.Main.size() >= SizeLimit)</td>
    <td class="lineNumber">933</td>
    <td class="codeline">    if (Move.Main.size() >= SizeLimit)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">934</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeline">    // Don't mix HVX and non-HVX instructions.</td>
    <td class="lineNumber">935</td>
    <td class="codeline">    // Don't mix HVX and non-HVX instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeline">    if (Move.IsHvx != isHvx(Info))</td>
    <td class="lineNumber">936</td>
    <td class="codeline">    if (Move.IsHvx != isHvx(Info))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">937</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeline">    // Leading instruction in the load group.</td>
    <td class="lineNumber">938</td>
    <td class="codeline">    // Leading instruction in the load group.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeline">    Instruction *Base = Move.Main.front();</td>
    <td class="lineNumber">939</td>
    <td class="codeline">    Instruction *Base = Move.Main.front();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeline">    if (Base->getParent() != Info.Inst->getParent())</td>
    <td class="lineNumber">940</td>
    <td class="codeline">    if (Base->getParent() != Info.Inst->getParent())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">941</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeline">    // Check if it's safe to move the load.</td>
    <td class="lineNumber">942</td>
    <td class="codeline">    // Check if it's safe to move the load.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeline">    if (!HVC.isSafeToMoveBeforeInBB(*Info.Inst, Base->getIterator()))</td>
    <td class="lineNumber">943</td>
    <td class="codeline">    if (!HVC.isSafeToMoveBeforeInBB(*Info.Inst, Base->getIterator()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">944</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeline">    // And if it's safe to clone the dependencies.</td>
    <td class="lineNumber">945</td>
    <td class="codeline">    // And if it's safe to clone the dependencies.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeline">    auto isSafeToCopyAtBase = [&](const Instruction *I) {</td>
    <td class="lineNumber">946</td>
    <td class="codeline">    auto isSafeToCopyAtBase = [&](const Instruction *I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeline">      return HVC.isSafeToMoveBeforeInBB(*I, Base->getIterator()) &&</td>
    <td class="lineNumber">947</td>
    <td class="codeline">      return HVC.isSafeToMoveBeforeInBB(*I, Base->getIterator()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeline">             HVC.isSafeToClone(*I);</td>
    <td class="lineNumber">948</td>
    <td class="codeline">             HVC.isSafeToClone(*I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeline">    };</td>
    <td class="lineNumber">949</td>
    <td class="codeline">    };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeline">    DepList Deps = getUpwardDeps(Info.Inst, Base);</td>
    <td class="lineNumber">950</td>
    <td class="codeline">    DepList Deps = getUpwardDeps(Info.Inst, Base);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeline">    if (!llvm::all_of(Deps, isSafeToCopyAtBase))</td>
    <td class="lineNumber">951</td>
    <td class="codeline">    if (!llvm::all_of(Deps, isSafeToCopyAtBase))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">952</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeline"></td>
    <td class="lineNumber">953</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeline">    Move.Main.push_back(Info.Inst);</td>
    <td class="lineNumber">954</td>
    <td class="codeline">    Move.Main.push_back(Info.Inst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeline">    llvm::append_range(Move.Deps, Deps);</td>
    <td class="lineNumber">955</td>
    <td class="codeline">    llvm::append_range(Move.Deps, Deps);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">956</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">957</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeline"></td>
    <td class="lineNumber">958</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeline">  MoveList LoadGroups;</td>
    <td class="lineNumber">959</td>
    <td class="codeline">  MoveList LoadGroups;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeline"></td>
    <td class="lineNumber">960</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeline">  for (const AddrInfo &Info : Group) {</td>
    <td class="lineNumber">961</td>
    <td class="codeline">  for (const AddrInfo &Info : Group) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeline">    if (!Info.Inst->mayReadFromMemory())</td>
    <td class="lineNumber">962</td>
    <td class="codeline">    if (!Info.Inst->mayReadFromMemory())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">963</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeline">    if (LoadGroups.empty() || !tryAddTo(Info, LoadGroups.back()))</td>
    <td class="lineNumber">964</td>
    <td class="codeline">    if (LoadGroups.empty() || !tryAddTo(Info, LoadGroups.back()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeline">      LoadGroups.emplace_back(Info, Group.front().Inst, isHvx(Info), true);</td>
    <td class="lineNumber">965</td>
    <td class="codeline">      LoadGroups.emplace_back(Info, Group.front().Inst, isHvx(Info), true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">966</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeline"></td>
    <td class="lineNumber">967</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeline">  // Erase singleton groups.</td>
    <td class="lineNumber">968</td>
    <td class="codeline">  // Erase singleton groups.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeline">  erase_if(LoadGroups, [](const MoveGroup &G) { return G.Main.size() <= 1; });</td>
    <td class="lineNumber">969</td>
    <td class="codeline">  erase_if(LoadGroups, [](const MoveGroup &G) { return G.Main.size() <= 1; });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeline"></td>
    <td class="lineNumber">970</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeline">  // Erase HVX groups on targets < HvxV62 (due to lack of predicated loads).</td>
    <td class="lineNumber">971</td>
    <td class="codeline">  // Erase HVX groups on targets < HvxV62 (due to lack of predicated loads).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeline">  if (!HVC.HST.useHVXV62Ops())</td>
    <td class="lineNumber">972</td>
    <td class="codeline">  if (!HVC.HST.useHVXV62Ops())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeline">    erase_if(LoadGroups, [](const MoveGroup &G) { return G.IsHvx; });</td>
    <td class="lineNumber">973</td>
    <td class="codeline">    erase_if(LoadGroups, [](const MoveGroup &G) { return G.IsHvx; });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeline"></td>
    <td class="lineNumber">974</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeline">  return LoadGroups;</td>
    <td class="lineNumber">975</td>
    <td class="codeline">  return LoadGroups;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeline">}</td>
    <td class="lineNumber">976</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeline"></td>
    <td class="lineNumber">977</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeline">auto AlignVectors::createStoreGroups(const AddrList &Group) const -> MoveList {</td>
    <td class="lineNumber">978</td>
    <td class="codeline">auto AlignVectors::createStoreGroups(const AddrList &Group) const -> MoveList {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeline">  // Form store groups.</td>
    <td class="lineNumber">979</td>
    <td class="codeline">  // Form store groups.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeline">  // To avoid complications with moving code across basic blocks, only form</td>
    <td class="lineNumber">980</td>
    <td class="codeline">  // To avoid complications with moving code across basic blocks, only form</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeline">  // groups that are contained within a single basic block.</td>
    <td class="lineNumber">981</td>
    <td class="codeline">  // groups that are contained within a single basic block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeline">  unsigned SizeLimit = VAGroupSizeLimit;</td>
    <td class="lineNumber">982</td>
    <td class="codeline">  unsigned SizeLimit = VAGroupSizeLimit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeline">  if (SizeLimit == 0)</td>
    <td class="lineNumber">983</td>
    <td class="codeline">  if (SizeLimit == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeline">    return {};</td>
    <td class="lineNumber">984</td>
    <td class="codeline">    return {};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeline"></td>
    <td class="lineNumber">985</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeline">  auto tryAddTo = [&](const AddrInfo &Info, MoveGroup &Move) {</td>
    <td class="lineNumber">986</td>
    <td class="codeline">  auto tryAddTo = [&](const AddrInfo &Info, MoveGroup &Move) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeline">    assert(!Move.Main.empty() && "Move group should have non-empty Main");</td>
    <td class="lineNumber">987</td>
    <td class="codeline">    assert(!Move.Main.empty() && "Move group should have non-empty Main");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeline">    if (Move.Main.size() >= SizeLimit)</td>
    <td class="lineNumber">988</td>
    <td class="codeline">    if (Move.Main.size() >= SizeLimit)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">989</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeline">    // For stores with return values we'd have to collect downward depenencies.</td>
    <td class="lineNumber">990</td>
    <td class="codeline">    // For stores with return values we'd have to collect downward depenencies.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeline">    // There are no such stores that we handle at the moment, so omit that.</td>
    <td class="lineNumber">991</td>
    <td class="codeline">    // There are no such stores that we handle at the moment, so omit that.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeline">    assert(Info.Inst->getType()->isVoidTy() &&</td>
    <td class="lineNumber">992</td>
    <td class="codeline">    assert(Info.Inst->getType()->isVoidTy() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeline">           "Not handling stores with return values");</td>
    <td class="lineNumber">993</td>
    <td class="codeline">           "Not handling stores with return values");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeline">    // Don't mix HVX and non-HVX instructions.</td>
    <td class="lineNumber">994</td>
    <td class="codeline">    // Don't mix HVX and non-HVX instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeline">    if (Move.IsHvx != isHvx(Info))</td>
    <td class="lineNumber">995</td>
    <td class="codeline">    if (Move.IsHvx != isHvx(Info))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">996</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeline">    // For stores we need to be careful whether it's safe to move them.</td>
    <td class="lineNumber">997</td>
    <td class="codeline">    // For stores we need to be careful whether it's safe to move them.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeline">    // Stores that are otherwise safe to move together may not appear safe</td>
    <td class="lineNumber">998</td>
    <td class="codeline">    // Stores that are otherwise safe to move together may not appear safe</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeline">    // to move over one another (i.e. isSafeToMoveBefore may return false).</td>
    <td class="lineNumber">999</td>
    <td class="codeline">    // to move over one another (i.e. isSafeToMoveBefore may return false).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeline">    Instruction *Base = Move.Main.front();</td>
    <td class="lineNumber">1000</td>
    <td class="codeline">    Instruction *Base = Move.Main.front();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeline">    if (Base->getParent() != Info.Inst->getParent())</td>
    <td class="lineNumber">1001</td>
    <td class="codeline">    if (Base->getParent() != Info.Inst->getParent())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1002</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeline">    if (!HVC.isSafeToMoveBeforeInBB(*Info.Inst, Base->getIterator(), Move.Main))</td>
    <td class="lineNumber">1003</td>
    <td class="codeline">    if (!HVC.isSafeToMoveBeforeInBB(*Info.Inst, Base->getIterator(), Move.Main))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1004</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeline">    Move.Main.push_back(Info.Inst);</td>
    <td class="lineNumber">1005</td>
    <td class="codeline">    Move.Main.push_back(Info.Inst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">1006</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1007</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeline"></td>
    <td class="lineNumber">1008</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeline">  MoveList StoreGroups;</td>
    <td class="lineNumber">1009</td>
    <td class="codeline">  MoveList StoreGroups;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeline"></td>
    <td class="lineNumber">1010</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeline">  for (auto I = Group.rbegin(), E = Group.rend(); I != E; ++I) {</td>
    <td class="lineNumber">1011</td>
    <td class="codeline">  for (auto I = Group.rbegin(), E = Group.rend(); I != E; ++I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeline">    const AddrInfo &Info = *I;</td>
    <td class="lineNumber">1012</td>
    <td class="codeline">    const AddrInfo &Info = *I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeline">    if (!Info.Inst->mayWriteToMemory())</td>
    <td class="lineNumber">1013</td>
    <td class="codeline">    if (!Info.Inst->mayWriteToMemory())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1014</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeline">    if (StoreGroups.empty() || !tryAddTo(Info, StoreGroups.back()))</td>
    <td class="lineNumber">1015</td>
    <td class="codeline">    if (StoreGroups.empty() || !tryAddTo(Info, StoreGroups.back()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeline">      StoreGroups.emplace_back(Info, Group.front().Inst, isHvx(Info), false);</td>
    <td class="lineNumber">1016</td>
    <td class="codeline">      StoreGroups.emplace_back(Info, Group.front().Inst, isHvx(Info), false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1017</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeline"></td>
    <td class="lineNumber">1018</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeline">  // Erase singleton groups.</td>
    <td class="lineNumber">1019</td>
    <td class="codeline">  // Erase singleton groups.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeline">  erase_if(StoreGroups, [](const MoveGroup &G) { return G.Main.size() <= 1; });</td>
    <td class="lineNumber">1020</td>
    <td class="codeline">  erase_if(StoreGroups, [](const MoveGroup &G) { return G.Main.size() <= 1; });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeline"></td>
    <td class="lineNumber">1021</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeline">  // Erase HVX groups on targets < HvxV62 (due to lack of predicated loads).</td>
    <td class="lineNumber">1022</td>
    <td class="codeline">  // Erase HVX groups on targets < HvxV62 (due to lack of predicated loads).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeline">  if (!HVC.HST.useHVXV62Ops())</td>
    <td class="lineNumber">1023</td>
    <td class="codeline">  if (!HVC.HST.useHVXV62Ops())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeline">    erase_if(StoreGroups, [](const MoveGroup &G) { return G.IsHvx; });</td>
    <td class="lineNumber">1024</td>
    <td class="codeline">    erase_if(StoreGroups, [](const MoveGroup &G) { return G.IsHvx; });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeline"></td>
    <td class="lineNumber">1025</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeline">  // Erase groups where every store is a full HVX vector. The reason is that</td>
    <td class="lineNumber">1026</td>
    <td class="codeline">  // Erase groups where every store is a full HVX vector. The reason is that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeline">  // aligning predicated stores generates complex code that may be less</td>
    <td class="lineNumber">1027</td>
    <td class="codeline">  // aligning predicated stores generates complex code that may be less</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeline">  // efficient than a sequence of unaligned vector stores.</td>
    <td class="lineNumber">1028</td>
    <td class="codeline">  // efficient than a sequence of unaligned vector stores.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeline">  if (!VADoFullStores) {</td>
    <td class="lineNumber">1029</td>
    <td class="codeline">  if (!VADoFullStores) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeline">    erase_if(StoreGroups, [this](const MoveGroup &G) {</td>
    <td class="lineNumber">1030</td>
    <td class="codeline">    erase_if(StoreGroups, [this](const MoveGroup &G) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeline">      return G.IsHvx && llvm::all_of(G.Main, [this](Instruction *S) {</td>
    <td class="lineNumber">1031</td>
    <td class="codeline">      return G.IsHvx && llvm::all_of(G.Main, [this](Instruction *S) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeline">               auto MaybeInfo = this->getAddrInfo(*S);</td>
    <td class="lineNumber">1032</td>
    <td class="codeline">               auto MaybeInfo = this->getAddrInfo(*S);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeline">               assert(MaybeInfo.has_value());</td>
    <td class="lineNumber">1033</td>
    <td class="codeline">               assert(MaybeInfo.has_value());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeline">               return HVC.HST.isHVXVectorType(</td>
    <td class="lineNumber">1034</td>
    <td class="codeline">               return HVC.HST.isHVXVectorType(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeline">                   EVT::getEVT(MaybeInfo->ValTy, false));</td>
    <td class="lineNumber">1035</td>
    <td class="codeline">                   EVT::getEVT(MaybeInfo->ValTy, false));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeline">             });</td>
    <td class="lineNumber">1036</td>
    <td class="codeline">             });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeline">    });</td>
    <td class="lineNumber">1037</td>
    <td class="codeline">    });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1038</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeline"></td>
    <td class="lineNumber">1039</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeline">  return StoreGroups;</td>
    <td class="lineNumber">1040</td>
    <td class="codeline">  return StoreGroups;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1041</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeline"></td>
    <td class="lineNumber">1042</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeline">auto AlignVectors::moveTogether(MoveGroup &Move) const -> bool {</td>
    <td class="lineNumber">1043</td>
    <td class="codeline">auto AlignVectors::moveTogether(MoveGroup &Move) const -> bool {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeline">  // Move all instructions to be adjacent.</td>
    <td class="lineNumber">1044</td>
    <td class="codeline">  // Move all instructions to be adjacent.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeline">  assert(!Move.Main.empty() && "Move group should have non-empty Main");</td>
    <td class="lineNumber">1045</td>
    <td class="codeline">  assert(!Move.Main.empty() && "Move group should have non-empty Main");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeline">  Instruction *Where = Move.Main.front();</td>
    <td class="lineNumber">1046</td>
    <td class="codeline">  Instruction *Where = Move.Main.front();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeline"></td>
    <td class="lineNumber">1047</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeline">  if (Move.IsLoad) {</td>
    <td class="lineNumber">1048</td>
    <td class="codeline">  if (Move.IsLoad) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeline">    // Move all the loads (and dependencies) to where the first load is.</td>
    <td class="lineNumber">1049</td>
    <td class="codeline">    // Move all the loads (and dependencies) to where the first load is.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeline">    // Clone all deps to before Where, keeping order.</td>
    <td class="lineNumber">1050</td>
    <td class="codeline">    // Clone all deps to before Where, keeping order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeline">    Move.Clones = cloneBefore(Where, Move.Deps);</td>
    <td class="lineNumber">1051</td>
    <td class="codeline">    Move.Clones = cloneBefore(Where, Move.Deps);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeline">    // Move all main instructions to after Where, keeping order.</td>
    <td class="lineNumber">1052</td>
    <td class="codeline">    // Move all main instructions to after Where, keeping order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeline">    ArrayRef<Instruction *> Main(Move.Main);</td>
    <td class="lineNumber">1053</td>
    <td class="codeline">    ArrayRef<Instruction *> Main(Move.Main);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeline">    for (Instruction *M : Main) {</td>
    <td class="lineNumber">1054</td>
    <td class="codeline">    for (Instruction *M : Main) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeline">      if (M != Where)</td>
    <td class="lineNumber">1055</td>
    <td class="codeline">      if (M != Where)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeline">        M->moveAfter(Where);</td>
    <td class="lineNumber">1056</td>
    <td class="codeline">        M->moveAfter(Where);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeline">      for (auto [Old, New] : Move.Clones)</td>
    <td class="lineNumber">1057</td>
    <td class="codeline">      for (auto [Old, New] : Move.Clones)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeline">        M->replaceUsesOfWith(Old, New);</td>
    <td class="lineNumber">1058</td>
    <td class="codeline">        M->replaceUsesOfWith(Old, New);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeline">      Where = M;</td>
    <td class="lineNumber">1059</td>
    <td class="codeline">      Where = M;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1060</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeline">    // Replace Deps with the clones.</td>
    <td class="lineNumber">1061</td>
    <td class="codeline">    // Replace Deps with the clones.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeline">    for (int i = 0, e = Move.Deps.size(); i != e; ++i)</td>
    <td class="lineNumber">1062</td>
    <td class="codeline">    for (int i = 0, e = Move.Deps.size(); i != e; ++i)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeline">      Move.Deps[i] = Move.Clones[Move.Deps[i]];</td>
    <td class="lineNumber">1063</td>
    <td class="codeline">      Move.Deps[i] = Move.Clones[Move.Deps[i]];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">1064</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeline">    // Move all the stores to where the last store is.</td>
    <td class="lineNumber">1065</td>
    <td class="codeline">    // Move all the stores to where the last store is.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeline">    // NOTE: Deps are empty for "store" groups. If they need to be</td>
    <td class="lineNumber">1066</td>
    <td class="codeline">    // NOTE: Deps are empty for "store" groups. If they need to be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeline">    // non-empty, decide on the order.</td>
    <td class="lineNumber">1067</td>
    <td class="codeline">    // non-empty, decide on the order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeline">    assert(Move.Deps.empty());</td>
    <td class="lineNumber">1068</td>
    <td class="codeline">    assert(Move.Deps.empty());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeline">    // Move all main instructions to before Where, inverting order.</td>
    <td class="lineNumber">1069</td>
    <td class="codeline">    // Move all main instructions to before Where, inverting order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeline">    ArrayRef<Instruction *> Main(Move.Main);</td>
    <td class="lineNumber">1070</td>
    <td class="codeline">    ArrayRef<Instruction *> Main(Move.Main);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeline">    for (Instruction *M : Main.drop_front(1)) {</td>
    <td class="lineNumber">1071</td>
    <td class="codeline">    for (Instruction *M : Main.drop_front(1)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeline">      M->moveBefore(Where);</td>
    <td class="lineNumber">1072</td>
    <td class="codeline">      M->moveBefore(Where);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeline">      Where = M;</td>
    <td class="lineNumber">1073</td>
    <td class="codeline">      Where = M;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1074</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1075</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeline"></td>
    <td class="lineNumber">1076</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeline">  return Move.Main.size() + Move.Deps.size() > 1;</td>
    <td class="lineNumber">1077</td>
    <td class="codeline">  return Move.Main.size() + Move.Deps.size() > 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1078</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeline"></td>
    <td class="lineNumber">1079</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeline">template <typename T></td>
    <td class="lineNumber">1080</td>
    <td class="codeline">template <typename T></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeline">auto AlignVectors::cloneBefore(Instruction *To, T &&Insts) const -> InstMap {</td>
    <td class="lineNumber">1081</td>
    <td class="codeline">auto AlignVectors::cloneBefore(Instruction *To, T &&Insts) const -> InstMap {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeline">  InstMap Map;</td>
    <td class="lineNumber">1082</td>
    <td class="codeline">  InstMap Map;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeline"></td>
    <td class="lineNumber">1083</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeline">  for (Instruction *I : Insts) {</td>
    <td class="lineNumber">1084</td>
    <td class="codeline">  for (Instruction *I : Insts) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeline">    assert(HVC.isSafeToClone(*I));</td>
    <td class="lineNumber">1085</td>
    <td class="codeline">    assert(HVC.isSafeToClone(*I));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeline">    Instruction *C = I->clone();</td>
    <td class="lineNumber">1086</td>
    <td class="codeline">    Instruction *C = I->clone();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeline">    C->setName(Twine("c.") + I->getName() + ".");</td>
    <td class="lineNumber">1087</td>
    <td class="codeline">    C->setName(Twine("c.") + I->getName() + ".");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeline">    C->insertBefore(To);</td>
    <td class="lineNumber">1088</td>
    <td class="codeline">    C->insertBefore(To);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeline"></td>
    <td class="lineNumber">1089</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeline">    for (auto [Old, New] : Map)</td>
    <td class="lineNumber">1090</td>
    <td class="codeline">    for (auto [Old, New] : Map)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeline">      C->replaceUsesOfWith(Old, New);</td>
    <td class="lineNumber">1091</td>
    <td class="codeline">      C->replaceUsesOfWith(Old, New);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeline">    Map.insert(std::make_pair(I, C));</td>
    <td class="lineNumber">1092</td>
    <td class="codeline">    Map.insert(std::make_pair(I, C));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1093</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeline">  return Map;</td>
    <td class="lineNumber">1094</td>
    <td class="codeline">  return Map;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1095</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeline"></td>
    <td class="lineNumber">1096</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeline">auto AlignVectors::realignLoadGroup(IRBuilderBase &Builder,</td>
    <td class="lineNumber">1097</td>
    <td class="codeline">auto AlignVectors::realignLoadGroup(IRBuilderBase &Builder,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeline">                                    const ByteSpan &VSpan, int ScLen,</td>
    <td class="lineNumber">1098</td>
    <td class="codeline">                                    const ByteSpan &VSpan, int ScLen,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeline">                                    Value *AlignVal, Value *AlignAddr) const</td>
    <td class="lineNumber">1099</td>
    <td class="codeline">                                    Value *AlignVal, Value *AlignAddr) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeline">    -> void {</td>
    <td class="lineNumber">1100</td>
    <td class="codeline">    -> void {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << __func__ << "\n");</td>
    <td class="lineNumber">1101</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << __func__ << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeline"></td>
    <td class="lineNumber">1102</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeline">  Type *SecTy = HVC.getByteTy(ScLen);</td>
    <td class="lineNumber">1103</td>
    <td class="codeline">  Type *SecTy = HVC.getByteTy(ScLen);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeline">  int NumSectors = (VSpan.extent() + ScLen - 1) / ScLen;</td>
    <td class="lineNumber">1104</td>
    <td class="codeline">  int NumSectors = (VSpan.extent() + ScLen - 1) / ScLen;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeline">  bool DoAlign = !HVC.isZero(AlignVal);</td>
    <td class="lineNumber">1105</td>
    <td class="codeline">  bool DoAlign = !HVC.isZero(AlignVal);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeline">  BasicBlock::iterator BasePos = Builder.GetInsertPoint();</td>
    <td class="lineNumber">1106</td>
    <td class="codeline">  BasicBlock::iterator BasePos = Builder.GetInsertPoint();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeline">  BasicBlock *BaseBlock = Builder.GetInsertBlock();</td>
    <td class="lineNumber">1107</td>
    <td class="codeline">  BasicBlock *BaseBlock = Builder.GetInsertBlock();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeline"></td>
    <td class="lineNumber">1108</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeline">  ByteSpan ASpan;</td>
    <td class="lineNumber">1109</td>
    <td class="codeline">  ByteSpan ASpan;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeline">  auto *True = HVC.getFullValue(HVC.getBoolTy(ScLen));</td>
    <td class="lineNumber">1110</td>
    <td class="codeline">  auto *True = HVC.getFullValue(HVC.getBoolTy(ScLen));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeline">  auto *Undef = UndefValue::get(SecTy);</td>
    <td class="lineNumber">1111</td>
    <td class="codeline">  auto *Undef = UndefValue::get(SecTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeline"></td>
    <td class="lineNumber">1112</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeline">  // Created load does not have to be "Instruction" (e.g. "undef").</td>
    <td class="lineNumber">1113</td>
    <td class="codeline">  // Created load does not have to be "Instruction" (e.g. "undef").</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeline">  SmallVector<Value *> Loads(NumSectors + DoAlign, nullptr);</td>
    <td class="lineNumber">1114</td>
    <td class="codeline">  SmallVector<Value *> Loads(NumSectors + DoAlign, nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeline"></td>
    <td class="lineNumber">1115</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeline">  // We could create all of the aligned loads, and generate the valigns</td>
    <td class="lineNumber">1116</td>
    <td class="codeline">  // We could create all of the aligned loads, and generate the valigns</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeline">  // at the location of the first load, but for large load groups, this</td>
    <td class="lineNumber">1117</td>
    <td class="codeline">  // at the location of the first load, but for large load groups, this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeline">  // could create highly suboptimal code (there have been groups of 140+</td>
    <td class="lineNumber">1118</td>
    <td class="codeline">  // could create highly suboptimal code (there have been groups of 140+</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeline">  // loads in real code).</td>
    <td class="lineNumber">1119</td>
    <td class="codeline">  // loads in real code).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeline">  // Instead, place the loads/valigns as close to the users as possible.</td>
    <td class="lineNumber">1120</td>
    <td class="codeline">  // Instead, place the loads/valigns as close to the users as possible.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeline">  // In any case we need to have a mapping from the blocks of VSpan (the</td>
    <td class="lineNumber">1121</td>
    <td class="codeline">  // In any case we need to have a mapping from the blocks of VSpan (the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeline">  // span covered by the pre-existing loads) to ASpan (the span covered</td>
    <td class="lineNumber">1122</td>
    <td class="codeline">  // span covered by the pre-existing loads) to ASpan (the span covered</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeline">  // by the aligned loads). There is a small problem, though: ASpan needs</td>
    <td class="lineNumber">1123</td>
    <td class="codeline">  // by the aligned loads). There is a small problem, though: ASpan needs</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeline">  // to have pointers to the loads/valigns, but we don't have these loads</td>
    <td class="lineNumber">1124</td>
    <td class="codeline">  // to have pointers to the loads/valigns, but we don't have these loads</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeline">  // because we don't know where to put them yet. We find out by creating</td>
    <td class="lineNumber">1125</td>
    <td class="codeline">  // because we don't know where to put them yet. We find out by creating</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeline">  // a section of ASpan that corresponds to values (blocks) from VSpan,</td>
    <td class="lineNumber">1126</td>
    <td class="codeline">  // a section of ASpan that corresponds to values (blocks) from VSpan,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeline">  // and checking where the new load should be placed. We need to attach</td>
    <td class="lineNumber">1127</td>
    <td class="codeline">  // and checking where the new load should be placed. We need to attach</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeline">  // this location information to each block in ASpan somehow, so we put</td>
    <td class="lineNumber">1128</td>
    <td class="codeline">  // this location information to each block in ASpan somehow, so we put</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeline">  // distincts values for Seg.Val in each ASpan.Blocks[i], and use a map</td>
    <td class="lineNumber">1129</td>
    <td class="codeline">  // distincts values for Seg.Val in each ASpan.Blocks[i], and use a map</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeline">  // to store the location for each Seg.Val.</td>
    <td class="lineNumber">1130</td>
    <td class="codeline">  // to store the location for each Seg.Val.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeline">  // The distinct values happen to be Blocks[i].Seg.Val = &Blocks[i],</td>
    <td class="lineNumber">1131</td>
    <td class="codeline">  // The distinct values happen to be Blocks[i].Seg.Val = &Blocks[i],</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeline">  // which helps with printing ByteSpans without crashing when printing</td>
    <td class="lineNumber">1132</td>
    <td class="codeline">  // which helps with printing ByteSpans without crashing when printing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeline">  // Segments with these temporary identifiers in place of Val.</td>
    <td class="lineNumber">1133</td>
    <td class="codeline">  // Segments with these temporary identifiers in place of Val.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeline"></td>
    <td class="lineNumber">1134</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeline">  // Populate the blocks first, to avoid reallocations of the vector</td>
    <td class="lineNumber">1135</td>
    <td class="codeline">  // Populate the blocks first, to avoid reallocations of the vector</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeline">  // interfering with generating the placeholder addresses.</td>
    <td class="lineNumber">1136</td>
    <td class="codeline">  // interfering with generating the placeholder addresses.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeline">  for (int Index = 0; Index != NumSectors; ++Index)</td>
    <td class="lineNumber">1137</td>
    <td class="codeline">  for (int Index = 0; Index != NumSectors; ++Index)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeline">    ASpan.Blocks.emplace_back(nullptr, ScLen, Index * ScLen);</td>
    <td class="lineNumber">1138</td>
    <td class="codeline">    ASpan.Blocks.emplace_back(nullptr, ScLen, Index * ScLen);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeline">  for (int Index = 0; Index != NumSectors; ++Index) {</td>
    <td class="lineNumber">1139</td>
    <td class="codeline">  for (int Index = 0; Index != NumSectors; ++Index) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeline">    ASpan.Blocks[Index].Seg.Val =</td>
    <td class="lineNumber">1140</td>
    <td class="codeline">    ASpan.Blocks[Index].Seg.Val =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeline">        reinterpret_cast<Value *>(&ASpan.Blocks[Index]);</td>
    <td class="lineNumber">1141</td>
    <td class="codeline">        reinterpret_cast<Value *>(&ASpan.Blocks[Index]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1142</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeline"></td>
    <td class="lineNumber">1143</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeline">  // Multiple values from VSpan can map to the same value in ASpan. Since we</td>
    <td class="lineNumber">1144</td>
    <td class="codeline">  // Multiple values from VSpan can map to the same value in ASpan. Since we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeline">  // try to create loads lazily, we need to find the earliest use for each</td>
    <td class="lineNumber">1145</td>
    <td class="codeline">  // try to create loads lazily, we need to find the earliest use for each</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeline">  // value from ASpan.</td>
    <td class="lineNumber">1146</td>
    <td class="codeline">  // value from ASpan.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeline">  DenseMap<void *, Instruction *> EarliestUser;</td>
    <td class="lineNumber">1147</td>
    <td class="codeline">  DenseMap<void *, Instruction *> EarliestUser;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeline">  auto isEarlier = [](Instruction *A, Instruction *B) {</td>
    <td class="lineNumber">1148</td>
    <td class="codeline">  auto isEarlier = [](Instruction *A, Instruction *B) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeline">    if (B == nullptr)</td>
    <td class="lineNumber">1149</td>
    <td class="codeline">    if (B == nullptr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">1150</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeline">    if (A == nullptr)</td>
    <td class="lineNumber">1151</td>
    <td class="codeline">    if (A == nullptr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1152</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeline">    assert(A->getParent() == B->getParent());</td>
    <td class="lineNumber">1153</td>
    <td class="codeline">    assert(A->getParent() == B->getParent());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeline">    return A->comesBefore(B);</td>
    <td class="lineNumber">1154</td>
    <td class="codeline">    return A->comesBefore(B);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1155</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeline">  auto earliestUser = [&](const auto &Uses) {</td>
    <td class="lineNumber">1156</td>
    <td class="codeline">  auto earliestUser = [&](const auto &Uses) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeline">    Instruction *User = nullptr;</td>
    <td class="lineNumber">1157</td>
    <td class="codeline">    Instruction *User = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeline">    for (const Use &U : Uses) {</td>
    <td class="lineNumber">1158</td>
    <td class="codeline">    for (const Use &U : Uses) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeline">      auto *I = dyn_cast<Instruction>(U.getUser());</td>
    <td class="lineNumber">1159</td>
    <td class="codeline">      auto *I = dyn_cast<Instruction>(U.getUser());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeline">      assert(I != nullptr && "Load used in a non-instruction?");</td>
    <td class="lineNumber">1160</td>
    <td class="codeline">      assert(I != nullptr && "Load used in a non-instruction?");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeline">      // Make sure we only consider users in this block, but we need</td>
    <td class="lineNumber">1161</td>
    <td class="codeline">      // Make sure we only consider users in this block, but we need</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeline">      // to remember if there were users outside the block too. This is</td>
    <td class="lineNumber">1162</td>
    <td class="codeline">      // to remember if there were users outside the block too. This is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeline">      // because if no users are found, aligned loads will not be created.</td>
    <td class="lineNumber">1163</td>
    <td class="codeline">      // because if no users are found, aligned loads will not be created.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeline">      if (I->getParent() == BaseBlock) {</td>
    <td class="lineNumber">1164</td>
    <td class="codeline">      if (I->getParent() == BaseBlock) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeline">        if (!isa<PHINode>(I))</td>
    <td class="lineNumber">1165</td>
    <td class="codeline">        if (!isa<PHINode>(I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeline">          User = std::min(User, I, isEarlier);</td>
    <td class="lineNumber">1166</td>
    <td class="codeline">          User = std::min(User, I, isEarlier);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">1167</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeline">        User = std::min(User, BaseBlock->getTerminator(), isEarlier);</td>
    <td class="lineNumber">1168</td>
    <td class="codeline">        User = std::min(User, BaseBlock->getTerminator(), isEarlier);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1169</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1170</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeline">    return User;</td>
    <td class="lineNumber">1171</td>
    <td class="codeline">    return User;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1172</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeline"></td>
    <td class="lineNumber">1173</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeline">  for (const ByteSpan::Block &B : VSpan) {</td>
    <td class="lineNumber">1174</td>
    <td class="codeline">  for (const ByteSpan::Block &B : VSpan) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeline">    ByteSpan ASection = ASpan.section(B.Pos, B.Seg.Size);</td>
    <td class="lineNumber">1175</td>
    <td class="codeline">    ByteSpan ASection = ASpan.section(B.Pos, B.Seg.Size);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeline">    for (const ByteSpan::Block &S : ASection) {</td>
    <td class="lineNumber">1176</td>
    <td class="codeline">    for (const ByteSpan::Block &S : ASection) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeline">      EarliestUser[S.Seg.Val] = std::min(</td>
    <td class="lineNumber">1177</td>
    <td class="codeline">      EarliestUser[S.Seg.Val] = std::min(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeline">          EarliestUser[S.Seg.Val], earliestUser(B.Seg.Val->uses()), isEarlier);</td>
    <td class="lineNumber">1178</td>
    <td class="codeline">          EarliestUser[S.Seg.Val], earliestUser(B.Seg.Val->uses()), isEarlier);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1179</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1180</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeline"></td>
    <td class="lineNumber">1181</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeline">  LLVM_DEBUG({</td>
    <td class="lineNumber">1182</td>
    <td class="codeline">  LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeline">    dbgs() << "ASpan:\n" << ASpan << '\n';</td>
    <td class="lineNumber">1183</td>
    <td class="codeline">    dbgs() << "ASpan:\n" << ASpan << '\n';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeline">    dbgs() << "Earliest users of ASpan:\n";</td>
    <td class="lineNumber">1184</td>
    <td class="codeline">    dbgs() << "Earliest users of ASpan:\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeline">    for (auto &[Val, User] : EarliestUser) {</td>
    <td class="lineNumber">1185</td>
    <td class="codeline">    for (auto &[Val, User] : EarliestUser) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeline">      dbgs() << Val << "\n ->" << *User << '\n';</td>
    <td class="lineNumber">1186</td>
    <td class="codeline">      dbgs() << Val << "\n ->" << *User << '\n';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1187</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">1188</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeline"></td>
    <td class="lineNumber">1189</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeline">  auto createLoad = [&](IRBuilderBase &Builder, const ByteSpan &VSpan,</td>
    <td class="lineNumber">1190</td>
    <td class="codeline">  auto createLoad = [&](IRBuilderBase &Builder, const ByteSpan &VSpan,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeline">                        int Index, bool MakePred) {</td>
    <td class="lineNumber">1191</td>
    <td class="codeline">                        int Index, bool MakePred) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeline">    Value *Ptr =</td>
    <td class="lineNumber">1192</td>
    <td class="codeline">    Value *Ptr =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeline">        createAdjustedPointer(Builder, AlignAddr, SecTy, Index * ScLen);</td>
    <td class="lineNumber">1193</td>
    <td class="codeline">        createAdjustedPointer(Builder, AlignAddr, SecTy, Index * ScLen);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeline">    Value *Predicate =</td>
    <td class="lineNumber">1194</td>
    <td class="codeline">    Value *Predicate =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeline">        MakePred ? makeTestIfUnaligned(Builder, AlignVal, ScLen) : nullptr;</td>
    <td class="lineNumber">1195</td>
    <td class="codeline">        MakePred ? makeTestIfUnaligned(Builder, AlignVal, ScLen) : nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeline"></td>
    <td class="lineNumber">1196</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeline">    // If vector shifting is potentially needed, accumulate metadata</td>
    <td class="lineNumber">1197</td>
    <td class="codeline">    // If vector shifting is potentially needed, accumulate metadata</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeline">    // from source sections of twice the load width.</td>
    <td class="lineNumber">1198</td>
    <td class="codeline">    // from source sections of twice the load width.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeline">    int Start = (Index - DoAlign) * ScLen;</td>
    <td class="lineNumber">1199</td>
    <td class="codeline">    int Start = (Index - DoAlign) * ScLen;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeline">    int Width = (1 + DoAlign) * ScLen;</td>
    <td class="lineNumber">1200</td>
    <td class="codeline">    int Width = (1 + DoAlign) * ScLen;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeline">    return this->createLoad(Builder, SecTy, Ptr, Predicate, ScLen, True, Undef,</td>
    <td class="lineNumber">1201</td>
    <td class="codeline">    return this->createLoad(Builder, SecTy, Ptr, Predicate, ScLen, True, Undef,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeline">                            VSpan.section(Start, Width).values());</td>
    <td class="lineNumber">1202</td>
    <td class="codeline">                            VSpan.section(Start, Width).values());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1203</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeline"></td>
    <td class="lineNumber">1204</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeline">  auto moveBefore = [this](Instruction *In, Instruction *To) {</td>
    <td class="lineNumber">1205</td>
    <td class="codeline">  auto moveBefore = [this](Instruction *In, Instruction *To) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeline">    // Move In and its upward dependencies to before To.</td>
    <td class="lineNumber">1206</td>
    <td class="codeline">    // Move In and its upward dependencies to before To.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeline">    assert(In->getParent() == To->getParent());</td>
    <td class="lineNumber">1207</td>
    <td class="codeline">    assert(In->getParent() == To->getParent());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeline">    DepList Deps = getUpwardDeps(In, To);</td>
    <td class="lineNumber">1208</td>
    <td class="codeline">    DepList Deps = getUpwardDeps(In, To);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeline">    In->moveBefore(To);</td>
    <td class="lineNumber">1209</td>
    <td class="codeline">    In->moveBefore(To);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeline">    // DepList is sorted with respect to positions in the basic block.</td>
    <td class="lineNumber">1210</td>
    <td class="codeline">    // DepList is sorted with respect to positions in the basic block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeline">    InstMap Map = cloneBefore(In, Deps);</td>
    <td class="lineNumber">1211</td>
    <td class="codeline">    InstMap Map = cloneBefore(In, Deps);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeline">    for (auto [Old, New] : Map)</td>
    <td class="lineNumber">1212</td>
    <td class="codeline">    for (auto [Old, New] : Map)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeline">      In->replaceUsesOfWith(Old, New);</td>
    <td class="lineNumber">1213</td>
    <td class="codeline">      In->replaceUsesOfWith(Old, New);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1214</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeline"></td>
    <td class="lineNumber">1215</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeline">  // Generate necessary loads at appropriate locations.</td>
    <td class="lineNumber">1216</td>
    <td class="codeline">  // Generate necessary loads at appropriate locations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Creating loads for ASpan sectors\n");</td>
    <td class="lineNumber">1217</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Creating loads for ASpan sectors\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeline">  for (int Index = 0; Index != NumSectors + 1; ++Index) {</td>
    <td class="lineNumber">1218</td>
    <td class="codeline">  for (int Index = 0; Index != NumSectors + 1; ++Index) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeline">    // In ASpan, each block will be either a single aligned load, or a</td>
    <td class="lineNumber">1219</td>
    <td class="codeline">    // In ASpan, each block will be either a single aligned load, or a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeline">    // valign of a pair of loads. In the latter case, an aligned load j</td>
    <td class="lineNumber">1220</td>
    <td class="codeline">    // valign of a pair of loads. In the latter case, an aligned load j</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeline">    // will belong to the current valign, and the one in the previous</td>
    <td class="lineNumber">1221</td>
    <td class="codeline">    // will belong to the current valign, and the one in the previous</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeline">    // block (for j > 0).</td>
    <td class="lineNumber">1222</td>
    <td class="codeline">    // block (for j > 0).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeline">    // Place the load at a location which will dominate the valign, assuming</td>
    <td class="lineNumber">1223</td>
    <td class="codeline">    // Place the load at a location which will dominate the valign, assuming</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeline">    // the valign will be placed right before the earliest user.</td>
    <td class="lineNumber">1224</td>
    <td class="codeline">    // the valign will be placed right before the earliest user.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeline">    Instruction *PrevAt =</td>
    <td class="lineNumber">1225</td>
    <td class="codeline">    Instruction *PrevAt =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeline">        DoAlign && Index > 0 ? EarliestUser[&ASpan[Index - 1]] : nullptr;</td>
    <td class="lineNumber">1226</td>
    <td class="codeline">        DoAlign && Index > 0 ? EarliestUser[&ASpan[Index - 1]] : nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeline">    Instruction *ThisAt =</td>
    <td class="lineNumber">1227</td>
    <td class="codeline">    Instruction *ThisAt =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeline">        Index < NumSectors ? EarliestUser[&ASpan[Index]] : nullptr;</td>
    <td class="lineNumber">1228</td>
    <td class="codeline">        Index < NumSectors ? EarliestUser[&ASpan[Index]] : nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeline">    if (auto *Where = std::min(PrevAt, ThisAt, isEarlier)) {</td>
    <td class="lineNumber">1229</td>
    <td class="codeline">    if (auto *Where = std::min(PrevAt, ThisAt, isEarlier)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeline">      Builder.SetInsertPoint(Where);</td>
    <td class="lineNumber">1230</td>
    <td class="codeline">      Builder.SetInsertPoint(Where);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeline">      Loads[Index] =</td>
    <td class="lineNumber">1231</td>
    <td class="codeline">      Loads[Index] =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeline">          createLoad(Builder, VSpan, Index, DoAlign && Index == NumSectors);</td>
    <td class="lineNumber">1232</td>
    <td class="codeline">          createLoad(Builder, VSpan, Index, DoAlign && Index == NumSectors);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeline">      // We know it's safe to put the load at BasePos, but we'd prefer to put</td>
    <td class="lineNumber">1233</td>
    <td class="codeline">      // We know it's safe to put the load at BasePos, but we'd prefer to put</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeline">      // it at "Where". To see if the load is safe to be placed at Where, put</td>
    <td class="lineNumber">1234</td>
    <td class="codeline">      // it at "Where". To see if the load is safe to be placed at Where, put</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeline">      // it there first and then check if it's safe to move it to BasePos.</td>
    <td class="lineNumber">1235</td>
    <td class="codeline">      // it there first and then check if it's safe to move it to BasePos.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeline">      // If not, then the load needs to be placed at BasePos.</td>
    <td class="lineNumber">1236</td>
    <td class="codeline">      // If not, then the load needs to be placed at BasePos.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeline">      // We can't do this check proactively because we need the load to exist</td>
    <td class="lineNumber">1237</td>
    <td class="codeline">      // We can't do this check proactively because we need the load to exist</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeline">      // in order to check legality.</td>
    <td class="lineNumber">1238</td>
    <td class="codeline">      // in order to check legality.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeline">      if (auto *Load = dyn_cast<Instruction>(Loads[Index])) {</td>
    <td class="lineNumber">1239</td>
    <td class="codeline">      if (auto *Load = dyn_cast<Instruction>(Loads[Index])) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeline">        if (!HVC.isSafeToMoveBeforeInBB(*Load, BasePos))</td>
    <td class="lineNumber">1240</td>
    <td class="codeline">        if (!HVC.isSafeToMoveBeforeInBB(*Load, BasePos))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeline">          moveBefore(Load, &*BasePos);</td>
    <td class="lineNumber">1241</td>
    <td class="codeline">          moveBefore(Load, &*BasePos);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1242</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "Loads[" << Index << "]:" << *Loads[Index] << '\n');</td>
    <td class="lineNumber">1243</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "Loads[" << Index << "]:" << *Loads[Index] << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1244</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1245</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeline"></td>
    <td class="lineNumber">1246</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeline">  // Generate valigns if needed, and fill in proper values in ASpan</td>
    <td class="lineNumber">1247</td>
    <td class="codeline">  // Generate valigns if needed, and fill in proper values in ASpan</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Creating values for ASpan sectors\n");</td>
    <td class="lineNumber">1248</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Creating values for ASpan sectors\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeline">  for (int Index = 0; Index != NumSectors; ++Index) {</td>
    <td class="lineNumber">1249</td>
    <td class="codeline">  for (int Index = 0; Index != NumSectors; ++Index) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeline">    ASpan[Index].Seg.Val = nullptr;</td>
    <td class="lineNumber">1250</td>
    <td class="codeline">    ASpan[Index].Seg.Val = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeline">    if (auto *Where = EarliestUser[&ASpan[Index]]) {</td>
    <td class="lineNumber">1251</td>
    <td class="codeline">    if (auto *Where = EarliestUser[&ASpan[Index]]) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeline">      Builder.SetInsertPoint(Where);</td>
    <td class="lineNumber">1252</td>
    <td class="codeline">      Builder.SetInsertPoint(Where);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeline">      Value *Val = Loads[Index];</td>
    <td class="lineNumber">1253</td>
    <td class="codeline">      Value *Val = Loads[Index];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeline">      assert(Val != nullptr);</td>
    <td class="lineNumber">1254</td>
    <td class="codeline">      assert(Val != nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeline">      if (DoAlign) {</td>
    <td class="lineNumber">1255</td>
    <td class="codeline">      if (DoAlign) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeline">        Value *NextLoad = Loads[Index + 1];</td>
    <td class="lineNumber">1256</td>
    <td class="codeline">        Value *NextLoad = Loads[Index + 1];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeline">        assert(NextLoad != nullptr);</td>
    <td class="lineNumber">1257</td>
    <td class="codeline">        assert(NextLoad != nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeline">        Val = HVC.vralignb(Builder, Val, NextLoad, AlignVal);</td>
    <td class="lineNumber">1258</td>
    <td class="codeline">        Val = HVC.vralignb(Builder, Val, NextLoad, AlignVal);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1259</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeline">      ASpan[Index].Seg.Val = Val;</td>
    <td class="lineNumber">1260</td>
    <td class="codeline">      ASpan[Index].Seg.Val = Val;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "ASpan[" << Index << "]:" << *Val << '\n');</td>
    <td class="lineNumber">1261</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "ASpan[" << Index << "]:" << *Val << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1262</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1263</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeline"></td>
    <td class="lineNumber">1264</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeline">  for (const ByteSpan::Block &B : VSpan) {</td>
    <td class="lineNumber">1265</td>
    <td class="codeline">  for (const ByteSpan::Block &B : VSpan) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeline">    ByteSpan ASection = ASpan.section(B.Pos, B.Seg.Size).shift(-B.Pos);</td>
    <td class="lineNumber">1266</td>
    <td class="codeline">    ByteSpan ASection = ASpan.section(B.Pos, B.Seg.Size).shift(-B.Pos);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeline">    Value *Accum = UndefValue::get(HVC.getByteTy(B.Seg.Size));</td>
    <td class="lineNumber">1267</td>
    <td class="codeline">    Value *Accum = UndefValue::get(HVC.getByteTy(B.Seg.Size));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeline">    Builder.SetInsertPoint(cast<Instruction>(B.Seg.Val));</td>
    <td class="lineNumber">1268</td>
    <td class="codeline">    Builder.SetInsertPoint(cast<Instruction>(B.Seg.Val));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeline"></td>
    <td class="lineNumber">1269</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeline">    // We're generating a reduction, where each instruction depends on</td>
    <td class="lineNumber">1270</td>
    <td class="codeline">    // We're generating a reduction, where each instruction depends on</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeline">    // the previous one, so we need to order them according to the position</td>
    <td class="lineNumber">1271</td>
    <td class="codeline">    // the previous one, so we need to order them according to the position</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeline">    // of their inputs in the code.</td>
    <td class="lineNumber">1272</td>
    <td class="codeline">    // of their inputs in the code.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeline">    std::vector<ByteSpan::Block *> ABlocks;</td>
    <td class="lineNumber">1273</td>
    <td class="codeline">    std::vector<ByteSpan::Block *> ABlocks;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeline">    for (ByteSpan::Block &S : ASection) {</td>
    <td class="lineNumber">1274</td>
    <td class="codeline">    for (ByteSpan::Block &S : ASection) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeline">      if (S.Seg.Val != nullptr)</td>
    <td class="lineNumber">1275</td>
    <td class="codeline">      if (S.Seg.Val != nullptr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeline">        ABlocks.push_back(&S);</td>
    <td class="lineNumber">1276</td>
    <td class="codeline">        ABlocks.push_back(&S);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1277</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeline">    llvm::sort(ABlocks,</td>
    <td class="lineNumber">1278</td>
    <td class="codeline">    llvm::sort(ABlocks,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeline">               [&](const ByteSpan::Block *A, const ByteSpan::Block *B) {</td>
    <td class="lineNumber">1279</td>
    <td class="codeline">               [&](const ByteSpan::Block *A, const ByteSpan::Block *B) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeline">                 return isEarlier(cast<Instruction>(A->Seg.Val),</td>
    <td class="lineNumber">1280</td>
    <td class="codeline">                 return isEarlier(cast<Instruction>(A->Seg.Val),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeline">                                  cast<Instruction>(B->Seg.Val));</td>
    <td class="lineNumber">1281</td>
    <td class="codeline">                                  cast<Instruction>(B->Seg.Val));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeline">               });</td>
    <td class="lineNumber">1282</td>
    <td class="codeline">               });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeline">    for (ByteSpan::Block *S : ABlocks) {</td>
    <td class="lineNumber">1283</td>
    <td class="codeline">    for (ByteSpan::Block *S : ABlocks) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeline">      // The processing of the data loaded by the aligned loads</td>
    <td class="lineNumber">1284</td>
    <td class="codeline">      // The processing of the data loaded by the aligned loads</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeline">      // needs to be inserted after the data is available.</td>
    <td class="lineNumber">1285</td>
    <td class="codeline">      // needs to be inserted after the data is available.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeline">      Instruction *SegI = cast<Instruction>(S->Seg.Val);</td>
    <td class="lineNumber">1286</td>
    <td class="codeline">      Instruction *SegI = cast<Instruction>(S->Seg.Val);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeline">      Builder.SetInsertPoint(&*std::next(SegI->getIterator()));</td>
    <td class="lineNumber">1287</td>
    <td class="codeline">      Builder.SetInsertPoint(&*std::next(SegI->getIterator()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeline">      Value *Pay = HVC.vbytes(Builder, getPayload(S->Seg.Val));</td>
    <td class="lineNumber">1288</td>
    <td class="codeline">      Value *Pay = HVC.vbytes(Builder, getPayload(S->Seg.Val));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeline">      Accum =</td>
    <td class="lineNumber">1289</td>
    <td class="codeline">      Accum =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeline">          HVC.insertb(Builder, Accum, Pay, S->Seg.Start, S->Seg.Size, S->Pos);</td>
    <td class="lineNumber">1290</td>
    <td class="codeline">          HVC.insertb(Builder, Accum, Pay, S->Seg.Start, S->Seg.Size, S->Pos);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1291</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeline">    // Instead of casting everything to bytes for the vselect, cast to the</td>
    <td class="lineNumber">1292</td>
    <td class="codeline">    // Instead of casting everything to bytes for the vselect, cast to the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeline">    // original value type. This will avoid complications with casting masks.</td>
    <td class="lineNumber">1293</td>
    <td class="codeline">    // original value type. This will avoid complications with casting masks.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeline">    // For example, in cases when the original mask applied to i32, it could</td>
    <td class="lineNumber">1294</td>
    <td class="codeline">    // For example, in cases when the original mask applied to i32, it could</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeline">    // be converted to a mask applicable to i8 via pred_typecast intrinsic,</td>
    <td class="lineNumber">1295</td>
    <td class="codeline">    // be converted to a mask applicable to i8 via pred_typecast intrinsic,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeline">    // but if the mask is not exactly of HVX length, extra handling would be</td>
    <td class="lineNumber">1296</td>
    <td class="codeline">    // but if the mask is not exactly of HVX length, extra handling would be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeline">    // needed to make it work.</td>
    <td class="lineNumber">1297</td>
    <td class="codeline">    // needed to make it work.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeline">    Type *ValTy = getPayload(B.Seg.Val)->getType();</td>
    <td class="lineNumber">1298</td>
    <td class="codeline">    Type *ValTy = getPayload(B.Seg.Val)->getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeline">    Value *Cast = Builder.CreateBitCast(Accum, ValTy, "cst");</td>
    <td class="lineNumber">1299</td>
    <td class="codeline">    Value *Cast = Builder.CreateBitCast(Accum, ValTy, "cst");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeline">    Value *Sel = Builder.CreateSelect(getMask(B.Seg.Val), Cast,</td>
    <td class="lineNumber">1300</td>
    <td class="codeline">    Value *Sel = Builder.CreateSelect(getMask(B.Seg.Val), Cast,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeline">                                      getPassThrough(B.Seg.Val), "sel");</td>
    <td class="lineNumber">1301</td>
    <td class="codeline">                                      getPassThrough(B.Seg.Val), "sel");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeline">    B.Seg.Val->replaceAllUsesWith(Sel);</td>
    <td class="lineNumber">1302</td>
    <td class="codeline">    B.Seg.Val->replaceAllUsesWith(Sel);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1303</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1304</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeline"></td>
    <td class="lineNumber">1305</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeline">auto AlignVectors::realignStoreGroup(IRBuilderBase &Builder,</td>
    <td class="lineNumber">1306</td>
    <td class="codeline">auto AlignVectors::realignStoreGroup(IRBuilderBase &Builder,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeline">                                     const ByteSpan &VSpan, int ScLen,</td>
    <td class="lineNumber">1307</td>
    <td class="codeline">                                     const ByteSpan &VSpan, int ScLen,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeline">                                     Value *AlignVal, Value *AlignAddr) const</td>
    <td class="lineNumber">1308</td>
    <td class="codeline">                                     Value *AlignVal, Value *AlignAddr) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeline">    -> void {</td>
    <td class="lineNumber">1309</td>
    <td class="codeline">    -> void {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << __func__ << "\n");</td>
    <td class="lineNumber">1310</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << __func__ << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeline"></td>
    <td class="lineNumber">1311</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeline">  Type *SecTy = HVC.getByteTy(ScLen);</td>
    <td class="lineNumber">1312</td>
    <td class="codeline">  Type *SecTy = HVC.getByteTy(ScLen);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeline">  int NumSectors = (VSpan.extent() + ScLen - 1) / ScLen;</td>
    <td class="lineNumber">1313</td>
    <td class="codeline">  int NumSectors = (VSpan.extent() + ScLen - 1) / ScLen;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeline">  bool DoAlign = !HVC.isZero(AlignVal);</td>
    <td class="lineNumber">1314</td>
    <td class="codeline">  bool DoAlign = !HVC.isZero(AlignVal);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeline"></td>
    <td class="lineNumber">1315</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeline">  // Stores.</td>
    <td class="lineNumber">1316</td>
    <td class="codeline">  // Stores.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeline">  ByteSpan ASpanV, ASpanM;</td>
    <td class="lineNumber">1317</td>
    <td class="codeline">  ByteSpan ASpanV, ASpanM;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeline"></td>
    <td class="lineNumber">1318</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeline">  // Return a vector value corresponding to the input value Val:</td>
    <td class="lineNumber">1319</td>
    <td class="codeline">  // Return a vector value corresponding to the input value Val:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeline">  // either <1 x Val> for scalar Val, or Val itself for vector Val.</td>
    <td class="lineNumber">1320</td>
    <td class="codeline">  // either <1 x Val> for scalar Val, or Val itself for vector Val.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeline">  auto MakeVec = [](IRBuilderBase &Builder, Value *Val) -> Value * {</td>
    <td class="lineNumber">1321</td>
    <td class="codeline">  auto MakeVec = [](IRBuilderBase &Builder, Value *Val) -> Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeline">    Type *Ty = Val->getType();</td>
    <td class="lineNumber">1322</td>
    <td class="codeline">    Type *Ty = Val->getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeline">    if (Ty->isVectorTy())</td>
    <td class="lineNumber">1323</td>
    <td class="codeline">    if (Ty->isVectorTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeline">      return Val;</td>
    <td class="lineNumber">1324</td>
    <td class="codeline">      return Val;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeline">    auto *VecTy = VectorType::get(Ty, 1, /*Scalable=*/false);</td>
    <td class="lineNumber">1325</td>
    <td class="codeline">    auto *VecTy = VectorType::get(Ty, 1, /*Scalable=*/false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeline">    return Builder.CreateBitCast(Val, VecTy, "cst");</td>
    <td class="lineNumber">1326</td>
    <td class="codeline">    return Builder.CreateBitCast(Val, VecTy, "cst");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1327</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeline"></td>
    <td class="lineNumber">1328</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeline">  // Create an extra "undef" sector at the beginning and at the end.</td>
    <td class="lineNumber">1329</td>
    <td class="codeline">  // Create an extra "undef" sector at the beginning and at the end.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeline">  // They will be used as the left/right filler in the vlalign step.</td>
    <td class="lineNumber">1330</td>
    <td class="codeline">  // They will be used as the left/right filler in the vlalign step.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeline">  for (int Index = (DoAlign ? -1 : 0); Index != NumSectors + DoAlign; ++Index) {</td>
    <td class="lineNumber">1331</td>
    <td class="codeline">  for (int Index = (DoAlign ? -1 : 0); Index != NumSectors + DoAlign; ++Index) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeline">    // For stores, the size of each section is an aligned vector length.</td>
    <td class="lineNumber">1332</td>
    <td class="codeline">    // For stores, the size of each section is an aligned vector length.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeline">    // Adjust the store offsets relative to the section start offset.</td>
    <td class="lineNumber">1333</td>
    <td class="codeline">    // Adjust the store offsets relative to the section start offset.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeline">    ByteSpan VSection =</td>
    <td class="lineNumber">1334</td>
    <td class="codeline">    ByteSpan VSection =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeline">        VSpan.section(Index * ScLen, ScLen).shift(-Index * ScLen);</td>
    <td class="lineNumber">1335</td>
    <td class="codeline">        VSpan.section(Index * ScLen, ScLen).shift(-Index * ScLen);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeline">    Value *Undef = UndefValue::get(SecTy);</td>
    <td class="lineNumber">1336</td>
    <td class="codeline">    Value *Undef = UndefValue::get(SecTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeline">    Value *Zero = HVC.getNullValue(SecTy);</td>
    <td class="lineNumber">1337</td>
    <td class="codeline">    Value *Zero = HVC.getNullValue(SecTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeline">    Value *AccumV = Undef;</td>
    <td class="lineNumber">1338</td>
    <td class="codeline">    Value *AccumV = Undef;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeline">    Value *AccumM = Zero;</td>
    <td class="lineNumber">1339</td>
    <td class="codeline">    Value *AccumM = Zero;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeline">    for (ByteSpan::Block &S : VSection) {</td>
    <td class="lineNumber">1340</td>
    <td class="codeline">    for (ByteSpan::Block &S : VSection) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeline">      Value *Pay = getPayload(S.Seg.Val);</td>
    <td class="lineNumber">1341</td>
    <td class="codeline">      Value *Pay = getPayload(S.Seg.Val);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeline">      Value *Mask = HVC.rescale(Builder, MakeVec(Builder, getMask(S.Seg.Val)),</td>
    <td class="lineNumber">1342</td>
    <td class="codeline">      Value *Mask = HVC.rescale(Builder, MakeVec(Builder, getMask(S.Seg.Val)),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeline">                                Pay->getType(), HVC.getByteTy());</td>
    <td class="lineNumber">1343</td>
    <td class="codeline">                                Pay->getType(), HVC.getByteTy());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeline">      Value *PartM = HVC.insertb(Builder, Zero, HVC.vbytes(Builder, Mask),</td>
    <td class="lineNumber">1344</td>
    <td class="codeline">      Value *PartM = HVC.insertb(Builder, Zero, HVC.vbytes(Builder, Mask),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeline">                                 S.Seg.Start, S.Seg.Size, S.Pos);</td>
    <td class="lineNumber">1345</td>
    <td class="codeline">                                 S.Seg.Start, S.Seg.Size, S.Pos);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeline">      AccumM = Builder.CreateOr(AccumM, PartM);</td>
    <td class="lineNumber">1346</td>
    <td class="codeline">      AccumM = Builder.CreateOr(AccumM, PartM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeline"></td>
    <td class="lineNumber">1347</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeline">      Value *PartV = HVC.insertb(Builder, Undef, HVC.vbytes(Builder, Pay),</td>
    <td class="lineNumber">1348</td>
    <td class="codeline">      Value *PartV = HVC.insertb(Builder, Undef, HVC.vbytes(Builder, Pay),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeline">                                 S.Seg.Start, S.Seg.Size, S.Pos);</td>
    <td class="lineNumber">1349</td>
    <td class="codeline">                                 S.Seg.Start, S.Seg.Size, S.Pos);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeline"></td>
    <td class="lineNumber">1350</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeline">      AccumV = Builder.CreateSelect(</td>
    <td class="lineNumber">1351</td>
    <td class="codeline">      AccumV = Builder.CreateSelect(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeline">          Builder.CreateICmp(CmpInst::ICMP_NE, PartM, Zero), PartV, AccumV);</td>
    <td class="lineNumber">1352</td>
    <td class="codeline">          Builder.CreateICmp(CmpInst::ICMP_NE, PartM, Zero), PartV, AccumV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1353</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeline">    ASpanV.Blocks.emplace_back(AccumV, ScLen, Index * ScLen);</td>
    <td class="lineNumber">1354</td>
    <td class="codeline">    ASpanV.Blocks.emplace_back(AccumV, ScLen, Index * ScLen);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeline">    ASpanM.Blocks.emplace_back(AccumM, ScLen, Index * ScLen);</td>
    <td class="lineNumber">1355</td>
    <td class="codeline">    ASpanM.Blocks.emplace_back(AccumM, ScLen, Index * ScLen);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1356</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeline"></td>
    <td class="lineNumber">1357</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeline">  LLVM_DEBUG({</td>
    <td class="lineNumber">1358</td>
    <td class="codeline">  LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeline">    dbgs() << "ASpanV before vlalign:\n" << ASpanV << '\n';</td>
    <td class="lineNumber">1359</td>
    <td class="codeline">    dbgs() << "ASpanV before vlalign:\n" << ASpanV << '\n';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeline">    dbgs() << "ASpanM before vlalign:\n" << ASpanM << '\n';</td>
    <td class="lineNumber">1360</td>
    <td class="codeline">    dbgs() << "ASpanM before vlalign:\n" << ASpanM << '\n';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">1361</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeline"></td>
    <td class="lineNumber">1362</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeline">  // vlalign</td>
    <td class="lineNumber">1363</td>
    <td class="codeline">  // vlalign</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeline">  if (DoAlign) {</td>
    <td class="lineNumber">1364</td>
    <td class="codeline">  if (DoAlign) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeline">    for (int Index = 1; Index != NumSectors + 2; ++Index) {</td>
    <td class="lineNumber">1365</td>
    <td class="codeline">    for (int Index = 1; Index != NumSectors + 2; ++Index) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeline">      Value *PrevV = ASpanV[Index - 1].Seg.Val, *ThisV = ASpanV[Index].Seg.Val;</td>
    <td class="lineNumber">1366</td>
    <td class="codeline">      Value *PrevV = ASpanV[Index - 1].Seg.Val, *ThisV = ASpanV[Index].Seg.Val;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeline">      Value *PrevM = ASpanM[Index - 1].Seg.Val, *ThisM = ASpanM[Index].Seg.Val;</td>
    <td class="lineNumber">1367</td>
    <td class="codeline">      Value *PrevM = ASpanM[Index - 1].Seg.Val, *ThisM = ASpanM[Index].Seg.Val;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeline">      assert(isSectorTy(PrevV->getType()) && isSectorTy(PrevM->getType()));</td>
    <td class="lineNumber">1368</td>
    <td class="codeline">      assert(isSectorTy(PrevV->getType()) && isSectorTy(PrevM->getType()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeline">      ASpanV[Index - 1].Seg.Val = HVC.vlalignb(Builder, PrevV, ThisV, AlignVal);</td>
    <td class="lineNumber">1369</td>
    <td class="codeline">      ASpanV[Index - 1].Seg.Val = HVC.vlalignb(Builder, PrevV, ThisV, AlignVal);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeline">      ASpanM[Index - 1].Seg.Val = HVC.vlalignb(Builder, PrevM, ThisM, AlignVal);</td>
    <td class="lineNumber">1370</td>
    <td class="codeline">      ASpanM[Index - 1].Seg.Val = HVC.vlalignb(Builder, PrevM, ThisM, AlignVal);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1371</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1372</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeline"></td>
    <td class="lineNumber">1373</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeline">  LLVM_DEBUG({</td>
    <td class="lineNumber">1374</td>
    <td class="codeline">  LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeline">    dbgs() << "ASpanV after vlalign:\n" << ASpanV << '\n';</td>
    <td class="lineNumber">1375</td>
    <td class="codeline">    dbgs() << "ASpanV after vlalign:\n" << ASpanV << '\n';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeline">    dbgs() << "ASpanM after vlalign:\n" << ASpanM << '\n';</td>
    <td class="lineNumber">1376</td>
    <td class="codeline">    dbgs() << "ASpanM after vlalign:\n" << ASpanM << '\n';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">1377</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeline"></td>
    <td class="lineNumber">1378</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeline">  auto createStore = [&](IRBuilderBase &Builder, const ByteSpan &ASpanV,</td>
    <td class="lineNumber">1379</td>
    <td class="codeline">  auto createStore = [&](IRBuilderBase &Builder, const ByteSpan &ASpanV,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeline">                         const ByteSpan &ASpanM, int Index, bool MakePred) {</td>
    <td class="lineNumber">1380</td>
    <td class="codeline">                         const ByteSpan &ASpanM, int Index, bool MakePred) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeline">    Value *Val = ASpanV[Index].Seg.Val;</td>
    <td class="lineNumber">1381</td>
    <td class="codeline">    Value *Val = ASpanV[Index].Seg.Val;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeline">    Value *Mask = ASpanM[Index].Seg.Val; // bytes</td>
    <td class="lineNumber">1382</td>
    <td class="codeline">    Value *Mask = ASpanM[Index].Seg.Val; // bytes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeline">    if (HVC.isUndef(Val) || HVC.isZero(Mask))</td>
    <td class="lineNumber">1383</td>
    <td class="codeline">    if (HVC.isUndef(Val) || HVC.isZero(Mask))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">1384</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeline">    Value *Ptr =</td>
    <td class="lineNumber">1385</td>
    <td class="codeline">    Value *Ptr =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeline">        createAdjustedPointer(Builder, AlignAddr, SecTy, Index * ScLen);</td>
    <td class="lineNumber">1386</td>
    <td class="codeline">        createAdjustedPointer(Builder, AlignAddr, SecTy, Index * ScLen);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeline">    Value *Predicate =</td>
    <td class="lineNumber">1387</td>
    <td class="codeline">    Value *Predicate =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeline">        MakePred ? makeTestIfUnaligned(Builder, AlignVal, ScLen) : nullptr;</td>
    <td class="lineNumber">1388</td>
    <td class="codeline">        MakePred ? makeTestIfUnaligned(Builder, AlignVal, ScLen) : nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeline"></td>
    <td class="lineNumber">1389</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeline">    // If vector shifting is potentially needed, accumulate metadata</td>
    <td class="lineNumber">1390</td>
    <td class="codeline">    // If vector shifting is potentially needed, accumulate metadata</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeline">    // from source sections of twice the store width.</td>
    <td class="lineNumber">1391</td>
    <td class="codeline">    // from source sections of twice the store width.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeline">    int Start = (Index - DoAlign) * ScLen;</td>
    <td class="lineNumber">1392</td>
    <td class="codeline">    int Start = (Index - DoAlign) * ScLen;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeline">    int Width = (1 + DoAlign) * ScLen;</td>
    <td class="lineNumber">1393</td>
    <td class="codeline">    int Width = (1 + DoAlign) * ScLen;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeline">    this->createStore(Builder, Val, Ptr, Predicate, ScLen,</td>
    <td class="lineNumber">1394</td>
    <td class="codeline">    this->createStore(Builder, Val, Ptr, Predicate, ScLen,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeline">                      HVC.vlsb(Builder, Mask),</td>
    <td class="lineNumber">1395</td>
    <td class="codeline">                      HVC.vlsb(Builder, Mask),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeline">                      VSpan.section(Start, Width).values());</td>
    <td class="lineNumber">1396</td>
    <td class="codeline">                      VSpan.section(Start, Width).values());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1397</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeline"></td>
    <td class="lineNumber">1398</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeline">  for (int Index = 0; Index != NumSectors + DoAlign; ++Index) {</td>
    <td class="lineNumber">1399</td>
    <td class="codeline">  for (int Index = 0; Index != NumSectors + DoAlign; ++Index) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeline">    createStore(Builder, ASpanV, ASpanM, Index, DoAlign && Index == NumSectors);</td>
    <td class="lineNumber">1400</td>
    <td class="codeline">    createStore(Builder, ASpanV, ASpanM, Index, DoAlign && Index == NumSectors);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1401</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1402</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeline"></td>
    <td class="lineNumber">1403</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeline">auto AlignVectors::realignGroup(const MoveGroup &Move) const -> bool {</td>
    <td class="lineNumber">1404</td>
    <td class="codeline">auto AlignVectors::realignGroup(const MoveGroup &Move) const -> bool {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Realigning group:\n" << Move << '\n');</td>
    <td class="lineNumber">1405</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Realigning group:\n" << Move << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeline"></td>
    <td class="lineNumber">1406</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeline">  // TODO: Needs support for masked loads/stores of "scalar" vectors.</td>
    <td class="lineNumber">1407</td>
    <td class="codeline">  // TODO: Needs support for masked loads/stores of "scalar" vectors.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeline">  if (!Move.IsHvx)</td>
    <td class="lineNumber">1408</td>
    <td class="codeline">  if (!Move.IsHvx)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1409</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeline"></td>
    <td class="lineNumber">1410</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeline">  // Return the element with the maximum alignment from Range,</td>
    <td class="lineNumber">1411</td>
    <td class="codeline">  // Return the element with the maximum alignment from Range,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeline">  // where GetValue obtains the value to compare from an element.</td>
    <td class="lineNumber">1412</td>
    <td class="codeline">  // where GetValue obtains the value to compare from an element.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeline">  auto getMaxOf = [](auto Range, auto GetValue) {</td>
    <td class="lineNumber">1413</td>
    <td class="codeline">  auto getMaxOf = [](auto Range, auto GetValue) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeline">    return *std::max_element(</td>
    <td class="lineNumber">1414</td>
    <td class="codeline">    return *std::max_element(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeline">        Range.begin(), Range.end(),</td>
    <td class="lineNumber">1415</td>
    <td class="codeline">        Range.begin(), Range.end(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeline">        [&GetValue](auto &A, auto &B) { return GetValue(A) < GetValue(B); });</td>
    <td class="lineNumber">1416</td>
    <td class="codeline">        [&GetValue](auto &A, auto &B) { return GetValue(A) < GetValue(B); });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1417</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeline"></td>
    <td class="lineNumber">1418</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeline">  const AddrList &BaseInfos = AddrGroups.at(Move.Base);</td>
    <td class="lineNumber">1419</td>
    <td class="codeline">  const AddrList &BaseInfos = AddrGroups.at(Move.Base);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeline"></td>
    <td class="lineNumber">1420</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeline">  // Conceptually, there is a vector of N bytes covering the addresses</td>
    <td class="lineNumber">1421</td>
    <td class="codeline">  // Conceptually, there is a vector of N bytes covering the addresses</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeline">  // starting from the minimum offset (i.e. Base.Addr+Start). This vector</td>
    <td class="lineNumber">1422</td>
    <td class="codeline">  // starting from the minimum offset (i.e. Base.Addr+Start). This vector</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeline">  // represents a contiguous memory region that spans all accessed memory</td>
    <td class="lineNumber">1423</td>
    <td class="codeline">  // represents a contiguous memory region that spans all accessed memory</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeline">  // locations.</td>
    <td class="lineNumber">1424</td>
    <td class="codeline">  // locations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeline">  // The correspondence between loaded or stored values will be expressed</td>
    <td class="lineNumber">1425</td>
    <td class="codeline">  // The correspondence between loaded or stored values will be expressed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeline">  // in terms of this vector. For example, the 0th element of the vector</td>
    <td class="lineNumber">1426</td>
    <td class="codeline">  // in terms of this vector. For example, the 0th element of the vector</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeline">  // from the Base address info will start at byte Start from the beginning</td>
    <td class="lineNumber">1427</td>
    <td class="codeline">  // from the Base address info will start at byte Start from the beginning</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeline">  // of this conceptual vector.</td>
    <td class="lineNumber">1428</td>
    <td class="codeline">  // of this conceptual vector.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1429</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeline">  // This vector will be loaded/stored starting at the nearest down-aligned</td>
    <td class="lineNumber">1430</td>
    <td class="codeline">  // This vector will be loaded/stored starting at the nearest down-aligned</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeline">  // address and the amount od the down-alignment will be AlignVal:</td>
    <td class="lineNumber">1431</td>
    <td class="codeline">  // address and the amount od the down-alignment will be AlignVal:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeline">  //   valign(load_vector(align_down(Base+Start)), AlignVal)</td>
    <td class="lineNumber">1432</td>
    <td class="codeline">  //   valign(load_vector(align_down(Base+Start)), AlignVal)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeline"></td>
    <td class="lineNumber">1433</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeline">  std::set<Instruction *> TestSet(Move.Main.begin(), Move.Main.end());</td>
    <td class="lineNumber">1434</td>
    <td class="codeline">  std::set<Instruction *> TestSet(Move.Main.begin(), Move.Main.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeline">  AddrList MoveInfos;</td>
    <td class="lineNumber">1435</td>
    <td class="codeline">  AddrList MoveInfos;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeline">  llvm::copy_if(</td>
    <td class="lineNumber">1436</td>
    <td class="codeline">  llvm::copy_if(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeline">      BaseInfos, std::back_inserter(MoveInfos),</td>
    <td class="lineNumber">1437</td>
    <td class="codeline">      BaseInfos, std::back_inserter(MoveInfos),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeline">      [&TestSet](const AddrInfo &AI) { return TestSet.count(AI.Inst); });</td>
    <td class="lineNumber">1438</td>
    <td class="codeline">      [&TestSet](const AddrInfo &AI) { return TestSet.count(AI.Inst); });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeline"></td>
    <td class="lineNumber">1439</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeline">  // Maximum alignment present in the whole address group.</td>
    <td class="lineNumber">1440</td>
    <td class="codeline">  // Maximum alignment present in the whole address group.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeline">  const AddrInfo &WithMaxAlign =</td>
    <td class="lineNumber">1441</td>
    <td class="codeline">  const AddrInfo &WithMaxAlign =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeline">      getMaxOf(MoveInfos, [](const AddrInfo &AI) { return AI.HaveAlign; });</td>
    <td class="lineNumber">1442</td>
    <td class="codeline">      getMaxOf(MoveInfos, [](const AddrInfo &AI) { return AI.HaveAlign; });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeline">  Align MaxGiven = WithMaxAlign.HaveAlign;</td>
    <td class="lineNumber">1443</td>
    <td class="codeline">  Align MaxGiven = WithMaxAlign.HaveAlign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeline"></td>
    <td class="lineNumber">1444</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeline">  // Minimum alignment present in the move address group.</td>
    <td class="lineNumber">1445</td>
    <td class="codeline">  // Minimum alignment present in the move address group.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeline">  const AddrInfo &WithMinOffset =</td>
    <td class="lineNumber">1446</td>
    <td class="codeline">  const AddrInfo &WithMinOffset =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeline">      getMaxOf(MoveInfos, [](const AddrInfo &AI) { return -AI.Offset; });</td>
    <td class="lineNumber">1447</td>
    <td class="codeline">      getMaxOf(MoveInfos, [](const AddrInfo &AI) { return -AI.Offset; });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeline"></td>
    <td class="lineNumber">1448</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeline">  const AddrInfo &WithMaxNeeded =</td>
    <td class="lineNumber">1449</td>
    <td class="codeline">  const AddrInfo &WithMaxNeeded =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeline">      getMaxOf(MoveInfos, [](const AddrInfo &AI) { return AI.NeedAlign; });</td>
    <td class="lineNumber">1450</td>
    <td class="codeline">      getMaxOf(MoveInfos, [](const AddrInfo &AI) { return AI.NeedAlign; });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeline">  Align MinNeeded = WithMaxNeeded.NeedAlign;</td>
    <td class="lineNumber">1451</td>
    <td class="codeline">  Align MinNeeded = WithMaxNeeded.NeedAlign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeline"></td>
    <td class="lineNumber">1452</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeline">  // Set the builder's insertion point right before the load group, or</td>
    <td class="lineNumber">1453</td>
    <td class="codeline">  // Set the builder's insertion point right before the load group, or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeline">  // immediately after the store group. (Instructions in a store group are</td>
    <td class="lineNumber">1454</td>
    <td class="codeline">  // immediately after the store group. (Instructions in a store group are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeline">  // listed in reverse order.)</td>
    <td class="lineNumber">1455</td>
    <td class="codeline">  // listed in reverse order.)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeline">  Instruction *InsertAt = Move.Main.front();</td>
    <td class="lineNumber">1456</td>
    <td class="codeline">  Instruction *InsertAt = Move.Main.front();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeline">  if (!Move.IsLoad) {</td>
    <td class="lineNumber">1457</td>
    <td class="codeline">  if (!Move.IsLoad) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeline">    // There should be a terminator (which store isn't, but check anyways).</td>
    <td class="lineNumber">1458</td>
    <td class="codeline">    // There should be a terminator (which store isn't, but check anyways).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeline">    assert(InsertAt->getIterator() != InsertAt->getParent()->end());</td>
    <td class="lineNumber">1459</td>
    <td class="codeline">    assert(InsertAt->getIterator() != InsertAt->getParent()->end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeline">    InsertAt = &*std::next(InsertAt->getIterator());</td>
    <td class="lineNumber">1460</td>
    <td class="codeline">    InsertAt = &*std::next(InsertAt->getIterator());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1461</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeline"></td>
    <td class="lineNumber">1462</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeline">  IRBuilder Builder(InsertAt->getParent(), InsertAt->getIterator(),</td>
    <td class="lineNumber">1463</td>
    <td class="codeline">  IRBuilder Builder(InsertAt->getParent(), InsertAt->getIterator(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeline">                    InstSimplifyFolder(HVC.DL));</td>
    <td class="lineNumber">1464</td>
    <td class="codeline">                    InstSimplifyFolder(HVC.DL));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeline">  Value *AlignAddr = nullptr; // Actual aligned address.</td>
    <td class="lineNumber">1465</td>
    <td class="codeline">  Value *AlignAddr = nullptr; // Actual aligned address.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeline">  Value *AlignVal = nullptr;  // Right-shift amount (for valign).</td>
    <td class="lineNumber">1466</td>
    <td class="codeline">  Value *AlignVal = nullptr;  // Right-shift amount (for valign).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeline"></td>
    <td class="lineNumber">1467</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeline">  if (MinNeeded <= MaxGiven) {</td>
    <td class="lineNumber">1468</td>
    <td class="codeline">  if (MinNeeded <= MaxGiven) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeline">    int Start = WithMinOffset.Offset;</td>
    <td class="lineNumber">1469</td>
    <td class="codeline">    int Start = WithMinOffset.Offset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeline">    int OffAtMax = WithMaxAlign.Offset;</td>
    <td class="lineNumber">1470</td>
    <td class="codeline">    int OffAtMax = WithMaxAlign.Offset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeline">    // Shift the offset of the maximally aligned instruction (OffAtMax)</td>
    <td class="lineNumber">1471</td>
    <td class="codeline">    // Shift the offset of the maximally aligned instruction (OffAtMax)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeline">    // back by just enough multiples of the required alignment to cover the</td>
    <td class="lineNumber">1472</td>
    <td class="codeline">    // back by just enough multiples of the required alignment to cover the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeline">    // distance from Start to OffAtMax.</td>
    <td class="lineNumber">1473</td>
    <td class="codeline">    // distance from Start to OffAtMax.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeline">    // Calculate the address adjustment amount based on the address with the</td>
    <td class="lineNumber">1474</td>
    <td class="codeline">    // Calculate the address adjustment amount based on the address with the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeline">    // maximum alignment. This is to allow a simple gep instruction instead</td>
    <td class="lineNumber">1475</td>
    <td class="codeline">    // maximum alignment. This is to allow a simple gep instruction instead</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeline">    // of potential bitcasts to i8*.</td>
    <td class="lineNumber">1476</td>
    <td class="codeline">    // of potential bitcasts to i8*.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeline">    int Adjust = -alignTo(OffAtMax - Start, MinNeeded.value());</td>
    <td class="lineNumber">1477</td>
    <td class="codeline">    int Adjust = -alignTo(OffAtMax - Start, MinNeeded.value());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeline">    AlignAddr = createAdjustedPointer(Builder, WithMaxAlign.Addr,</td>
    <td class="lineNumber">1478</td>
    <td class="codeline">    AlignAddr = createAdjustedPointer(Builder, WithMaxAlign.Addr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeline">                                      WithMaxAlign.ValTy, Adjust, Move.Clones);</td>
    <td class="lineNumber">1479</td>
    <td class="codeline">                                      WithMaxAlign.ValTy, Adjust, Move.Clones);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeline">    int Diff = Start - (OffAtMax + Adjust);</td>
    <td class="lineNumber">1480</td>
    <td class="codeline">    int Diff = Start - (OffAtMax + Adjust);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeline">    AlignVal = HVC.getConstInt(Diff);</td>
    <td class="lineNumber">1481</td>
    <td class="codeline">    AlignVal = HVC.getConstInt(Diff);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeline">    assert(Diff >= 0);</td>
    <td class="lineNumber">1482</td>
    <td class="codeline">    assert(Diff >= 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeline">    assert(static_cast<decltype(MinNeeded.value())>(Diff) < MinNeeded.value());</td>
    <td class="lineNumber">1483</td>
    <td class="codeline">    assert(static_cast<decltype(MinNeeded.value())>(Diff) < MinNeeded.value());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">1484</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeline">    // WithMinOffset is the lowest address in the group,</td>
    <td class="lineNumber">1485</td>
    <td class="codeline">    // WithMinOffset is the lowest address in the group,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeline">    //   WithMinOffset.Addr = Base+Start.</td>
    <td class="lineNumber">1486</td>
    <td class="codeline">    //   WithMinOffset.Addr = Base+Start.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeline">    // Align instructions for both HVX (V6_valign) and scalar (S2_valignrb)</td>
    <td class="lineNumber">1487</td>
    <td class="codeline">    // Align instructions for both HVX (V6_valign) and scalar (S2_valignrb)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeline">    // mask off unnecessary bits, so it's ok to just the original pointer as</td>
    <td class="lineNumber">1488</td>
    <td class="codeline">    // mask off unnecessary bits, so it's ok to just the original pointer as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeline">    // the alignment amount.</td>
    <td class="lineNumber">1489</td>
    <td class="codeline">    // the alignment amount.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeline">    // Do an explicit down-alignment of the address to avoid creating an</td>
    <td class="lineNumber">1490</td>
    <td class="codeline">    // Do an explicit down-alignment of the address to avoid creating an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeline">    // aligned instruction with an address that is not really aligned.</td>
    <td class="lineNumber">1491</td>
    <td class="codeline">    // aligned instruction with an address that is not really aligned.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeline">    AlignAddr =</td>
    <td class="lineNumber">1492</td>
    <td class="codeline">    AlignAddr =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeline">        createAlignedPointer(Builder, WithMinOffset.Addr, WithMinOffset.ValTy,</td>
    <td class="lineNumber">1493</td>
    <td class="codeline">        createAlignedPointer(Builder, WithMinOffset.Addr, WithMinOffset.ValTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeline">                             MinNeeded.value(), Move.Clones);</td>
    <td class="lineNumber">1494</td>
    <td class="codeline">                             MinNeeded.value(), Move.Clones);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeline">    AlignVal =</td>
    <td class="lineNumber">1495</td>
    <td class="codeline">    AlignVal =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeline">        Builder.CreatePtrToInt(WithMinOffset.Addr, HVC.getIntTy(), "pti");</td>
    <td class="lineNumber">1496</td>
    <td class="codeline">        Builder.CreatePtrToInt(WithMinOffset.Addr, HVC.getIntTy(), "pti");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeline">    if (auto *I = dyn_cast<Instruction>(AlignVal)) {</td>
    <td class="lineNumber">1497</td>
    <td class="codeline">    if (auto *I = dyn_cast<Instruction>(AlignVal)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeline">      for (auto [Old, New] : Move.Clones)</td>
    <td class="lineNumber">1498</td>
    <td class="codeline">      for (auto [Old, New] : Move.Clones)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeline">        I->replaceUsesOfWith(Old, New);</td>
    <td class="lineNumber">1499</td>
    <td class="codeline">        I->replaceUsesOfWith(Old, New);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1500</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1501</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeline"></td>
    <td class="lineNumber">1502</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeline">  ByteSpan VSpan;</td>
    <td class="lineNumber">1503</td>
    <td class="codeline">  ByteSpan VSpan;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeline">  for (const AddrInfo &AI : MoveInfos) {</td>
    <td class="lineNumber">1504</td>
    <td class="codeline">  for (const AddrInfo &AI : MoveInfos) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeline">    VSpan.Blocks.emplace_back(AI.Inst, HVC.getSizeOf(AI.ValTy),</td>
    <td class="lineNumber">1505</td>
    <td class="codeline">    VSpan.Blocks.emplace_back(AI.Inst, HVC.getSizeOf(AI.ValTy),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeline">                              AI.Offset - WithMinOffset.Offset);</td>
    <td class="lineNumber">1506</td>
    <td class="codeline">                              AI.Offset - WithMinOffset.Offset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1507</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeline"></td>
    <td class="lineNumber">1508</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeline">  // The aligned loads/stores will use blocks that are either scalars,</td>
    <td class="lineNumber">1509</td>
    <td class="codeline">  // The aligned loads/stores will use blocks that are either scalars,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeline">  // or HVX vectors. Let "sector" be the unified term for such a block.</td>
    <td class="lineNumber">1510</td>
    <td class="codeline">  // or HVX vectors. Let "sector" be the unified term for such a block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeline">  // blend(scalar, vector) -> sector...</td>
    <td class="lineNumber">1511</td>
    <td class="codeline">  // blend(scalar, vector) -> sector...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeline">  int ScLen = Move.IsHvx ? HVC.HST.getVectorLength()</td>
    <td class="lineNumber">1512</td>
    <td class="codeline">  int ScLen = Move.IsHvx ? HVC.HST.getVectorLength()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeline">                         : std::max<int>(MinNeeded.value(), 4);</td>
    <td class="lineNumber">1513</td>
    <td class="codeline">                         : std::max<int>(MinNeeded.value(), 4);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeline">  assert(!Move.IsHvx || ScLen == 64 || ScLen == 128);</td>
    <td class="lineNumber">1514</td>
    <td class="codeline">  assert(!Move.IsHvx || ScLen == 64 || ScLen == 128);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeline">  assert(Move.IsHvx || ScLen == 4 || ScLen == 8);</td>
    <td class="lineNumber">1515</td>
    <td class="codeline">  assert(Move.IsHvx || ScLen == 4 || ScLen == 8);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeline"></td>
    <td class="lineNumber">1516</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeline">  LLVM_DEBUG({</td>
    <td class="lineNumber">1517</td>
    <td class="codeline">  LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeline">    dbgs() << "ScLen:  " << ScLen << "\n";</td>
    <td class="lineNumber">1518</td>
    <td class="codeline">    dbgs() << "ScLen:  " << ScLen << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeline">    dbgs() << "AlignVal:" << *AlignVal << "\n";</td>
    <td class="lineNumber">1519</td>
    <td class="codeline">    dbgs() << "AlignVal:" << *AlignVal << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeline">    dbgs() << "AlignAddr:" << *AlignAddr << "\n";</td>
    <td class="lineNumber">1520</td>
    <td class="codeline">    dbgs() << "AlignAddr:" << *AlignAddr << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeline">    dbgs() << "VSpan:\n" << VSpan << '\n';</td>
    <td class="lineNumber">1521</td>
    <td class="codeline">    dbgs() << "VSpan:\n" << VSpan << '\n';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">1522</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeline"></td>
    <td class="lineNumber">1523</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeline">  if (Move.IsLoad)</td>
    <td class="lineNumber">1524</td>
    <td class="codeline">  if (Move.IsLoad)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeline">    realignLoadGroup(Builder, VSpan, ScLen, AlignVal, AlignAddr);</td>
    <td class="lineNumber">1525</td>
    <td class="codeline">    realignLoadGroup(Builder, VSpan, ScLen, AlignVal, AlignAddr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">1526</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeline">    realignStoreGroup(Builder, VSpan, ScLen, AlignVal, AlignAddr);</td>
    <td class="lineNumber">1527</td>
    <td class="codeline">    realignStoreGroup(Builder, VSpan, ScLen, AlignVal, AlignAddr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeline"></td>
    <td class="lineNumber">1528</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeline">  for (auto *Inst : Move.Main)</td>
    <td class="lineNumber">1529</td>
    <td class="codeline">  for (auto *Inst : Move.Main)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeline">    Inst->eraseFromParent();</td>
    <td class="lineNumber">1530</td>
    <td class="codeline">    Inst->eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeline"></td>
    <td class="lineNumber">1531</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">1532</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1533</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeline"></td>
    <td class="lineNumber">1534</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeline">auto AlignVectors::makeTestIfUnaligned(IRBuilderBase &Builder, Value *AlignVal,</td>
    <td class="lineNumber">1535</td>
    <td class="codeline">auto AlignVectors::makeTestIfUnaligned(IRBuilderBase &Builder, Value *AlignVal,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeline">                                       int Alignment) const -> Value * {</td>
    <td class="lineNumber">1536</td>
    <td class="codeline">                                       int Alignment) const -> Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeline">  auto *AlignTy = AlignVal->getType();</td>
    <td class="lineNumber">1537</td>
    <td class="codeline">  auto *AlignTy = AlignVal->getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeline">  Value *And = Builder.CreateAnd(</td>
    <td class="lineNumber">1538</td>
    <td class="codeline">  Value *And = Builder.CreateAnd(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeline">      AlignVal, ConstantInt::get(AlignTy, Alignment - 1), "and");</td>
    <td class="lineNumber">1539</td>
    <td class="codeline">      AlignVal, ConstantInt::get(AlignTy, Alignment - 1), "and");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeline">  Value *Zero = ConstantInt::get(AlignTy, 0);</td>
    <td class="lineNumber">1540</td>
    <td class="codeline">  Value *Zero = ConstantInt::get(AlignTy, 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeline">  return Builder.CreateICmpNE(And, Zero, "isz");</td>
    <td class="lineNumber">1541</td>
    <td class="codeline">  return Builder.CreateICmpNE(And, Zero, "isz");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1542</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeline"></td>
    <td class="lineNumber">1543</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeline">auto AlignVectors::isSectorTy(Type *Ty) const -> bool {</td>
    <td class="lineNumber">1544</td>
    <td class="codeline">auto AlignVectors::isSectorTy(Type *Ty) const -> bool {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeline">  if (!HVC.isByteVecTy(Ty))</td>
    <td class="lineNumber">1545</td>
    <td class="codeline">  if (!HVC.isByteVecTy(Ty))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1546</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeline">  int Size = HVC.getSizeOf(Ty);</td>
    <td class="lineNumber">1547</td>
    <td class="codeline">  int Size = HVC.getSizeOf(Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeline">  if (HVC.HST.isTypeForHVX(Ty))</td>
    <td class="lineNumber">1548</td>
    <td class="codeline">  if (HVC.HST.isTypeForHVX(Ty))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeline">    return Size == static_cast<int>(HVC.HST.getVectorLength());</td>
    <td class="lineNumber">1549</td>
    <td class="codeline">    return Size == static_cast<int>(HVC.HST.getVectorLength());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeline">  return Size == 4 || Size == 8;</td>
    <td class="lineNumber">1550</td>
    <td class="codeline">  return Size == 4 || Size == 8;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1551</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeline"></td>
    <td class="lineNumber">1552</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeline">auto AlignVectors::run() -> bool {</td>
    <td class="lineNumber">1553</td>
    <td class="codeline">auto AlignVectors::run() -> bool {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Running HVC::AlignVectors on " << HVC.F.getName()</td>
    <td class="lineNumber">1554</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Running HVC::AlignVectors on " << HVC.F.getName()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeline">                    << '\n');</td>
    <td class="lineNumber">1555</td>
    <td class="codeline">                    << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeline">  if (!createAddressGroups())</td>
    <td class="lineNumber">1556</td>
    <td class="codeline">  if (!createAddressGroups())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1557</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeline"></td>
    <td class="lineNumber">1558</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeline">  LLVM_DEBUG({</td>
    <td class="lineNumber">1559</td>
    <td class="codeline">  LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeline">    dbgs() << "Address groups(" << AddrGroups.size() << "):\n";</td>
    <td class="lineNumber">1560</td>
    <td class="codeline">    dbgs() << "Address groups(" << AddrGroups.size() << "):\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeline">    for (auto &[In, AL] : AddrGroups) {</td>
    <td class="lineNumber">1561</td>
    <td class="codeline">    for (auto &[In, AL] : AddrGroups) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeline">      for (const AddrInfo &AI : AL)</td>
    <td class="lineNumber">1562</td>
    <td class="codeline">      for (const AddrInfo &AI : AL)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeline">        dbgs() << "---\n" << AI << '\n';</td>
    <td class="lineNumber">1563</td>
    <td class="codeline">        dbgs() << "---\n" << AI << '\n';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1564</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">1565</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeline"></td>
    <td class="lineNumber">1566</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeline">  bool Changed = false;</td>
    <td class="lineNumber">1567</td>
    <td class="codeline">  bool Changed = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeline">  MoveList LoadGroups, StoreGroups;</td>
    <td class="lineNumber">1568</td>
    <td class="codeline">  MoveList LoadGroups, StoreGroups;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeline"></td>
    <td class="lineNumber">1569</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeline">  for (auto &G : AddrGroups) {</td>
    <td class="lineNumber">1570</td>
    <td class="codeline">  for (auto &G : AddrGroups) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeline">    llvm::append_range(LoadGroups, createLoadGroups(G.second));</td>
    <td class="lineNumber">1571</td>
    <td class="codeline">    llvm::append_range(LoadGroups, createLoadGroups(G.second));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeline">    llvm::append_range(StoreGroups, createStoreGroups(G.second));</td>
    <td class="lineNumber">1572</td>
    <td class="codeline">    llvm::append_range(StoreGroups, createStoreGroups(G.second));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1573</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeline"></td>
    <td class="lineNumber">1574</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeline">  LLVM_DEBUG({</td>
    <td class="lineNumber">1575</td>
    <td class="codeline">  LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeline">    dbgs() << "\nLoad groups(" << LoadGroups.size() << "):\n";</td>
    <td class="lineNumber">1576</td>
    <td class="codeline">    dbgs() << "\nLoad groups(" << LoadGroups.size() << "):\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeline">    for (const MoveGroup &G : LoadGroups)</td>
    <td class="lineNumber">1577</td>
    <td class="codeline">    for (const MoveGroup &G : LoadGroups)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeline">      dbgs() << G << "\n";</td>
    <td class="lineNumber">1578</td>
    <td class="codeline">      dbgs() << G << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeline">    dbgs() << "Store groups(" << StoreGroups.size() << "):\n";</td>
    <td class="lineNumber">1579</td>
    <td class="codeline">    dbgs() << "Store groups(" << StoreGroups.size() << "):\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeline">    for (const MoveGroup &G : StoreGroups)</td>
    <td class="lineNumber">1580</td>
    <td class="codeline">    for (const MoveGroup &G : StoreGroups)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeline">      dbgs() << G << "\n";</td>
    <td class="lineNumber">1581</td>
    <td class="codeline">      dbgs() << G << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">1582</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeline"></td>
    <td class="lineNumber">1583</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeline">  // Cumulative limit on the number of groups.</td>
    <td class="lineNumber">1584</td>
    <td class="codeline">  // Cumulative limit on the number of groups.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeline">  unsigned CountLimit = VAGroupCountLimit;</td>
    <td class="lineNumber">1585</td>
    <td class="codeline">  unsigned CountLimit = VAGroupCountLimit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeline">  if (CountLimit == 0)</td>
    <td class="lineNumber">1586</td>
    <td class="codeline">  if (CountLimit == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1587</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeline"></td>
    <td class="lineNumber">1588</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeline">  if (LoadGroups.size() > CountLimit) {</td>
    <td class="lineNumber">1589</td>
    <td class="codeline">  if (LoadGroups.size() > CountLimit) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeline">    LoadGroups.resize(CountLimit);</td>
    <td class="lineNumber">1590</td>
    <td class="codeline">    LoadGroups.resize(CountLimit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeline">    StoreGroups.clear();</td>
    <td class="lineNumber">1591</td>
    <td class="codeline">    StoreGroups.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">1592</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeline">    unsigned StoreLimit = CountLimit - LoadGroups.size();</td>
    <td class="lineNumber">1593</td>
    <td class="codeline">    unsigned StoreLimit = CountLimit - LoadGroups.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeline">    if (StoreGroups.size() > StoreLimit)</td>
    <td class="lineNumber">1594</td>
    <td class="codeline">    if (StoreGroups.size() > StoreLimit)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeline">      StoreGroups.resize(StoreLimit);</td>
    <td class="lineNumber">1595</td>
    <td class="codeline">      StoreGroups.resize(StoreLimit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1596</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeline"></td>
    <td class="lineNumber">1597</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeline">  for (auto &M : LoadGroups)</td>
    <td class="lineNumber">1598</td>
    <td class="codeline">  for (auto &M : LoadGroups)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeline">    Changed |= moveTogether(M);</td>
    <td class="lineNumber">1599</td>
    <td class="codeline">    Changed |= moveTogether(M);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeline">  for (auto &M : StoreGroups)</td>
    <td class="lineNumber">1600</td>
    <td class="codeline">  for (auto &M : StoreGroups)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeline">    Changed |= moveTogether(M);</td>
    <td class="lineNumber">1601</td>
    <td class="codeline">    Changed |= moveTogether(M);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeline"></td>
    <td class="lineNumber">1602</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "After moveTogether:\n" << HVC.F);</td>
    <td class="lineNumber">1603</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "After moveTogether:\n" << HVC.F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeline"></td>
    <td class="lineNumber">1604</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeline">  for (auto &M : LoadGroups)</td>
    <td class="lineNumber">1605</td>
    <td class="codeline">  for (auto &M : LoadGroups)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeline">    Changed |= realignGroup(M);</td>
    <td class="lineNumber">1606</td>
    <td class="codeline">    Changed |= realignGroup(M);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeline">  for (auto &M : StoreGroups)</td>
    <td class="lineNumber">1607</td>
    <td class="codeline">  for (auto &M : StoreGroups)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeline">    Changed |= realignGroup(M);</td>
    <td class="lineNumber">1608</td>
    <td class="codeline">    Changed |= realignGroup(M);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeline"></td>
    <td class="lineNumber">1609</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeline">  return Changed;</td>
    <td class="lineNumber">1610</td>
    <td class="codeline">  return Changed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1611</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeline"></td>
    <td class="lineNumber">1612</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeline">// --- End AlignVectors</td>
    <td class="lineNumber">1613</td>
    <td class="codeline">// --- End AlignVectors</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeline"></td>
    <td class="lineNumber">1614</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeline">// --- Begin HvxIdioms</td>
    <td class="lineNumber">1615</td>
    <td class="codeline">// --- Begin HvxIdioms</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeline"></td>
    <td class="lineNumber">1616</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeline">auto HvxIdioms::getNumSignificantBits(Value *V, Instruction *In) const</td>
    <td class="lineNumber">1617</td>
    <td class="codeline">auto HvxIdioms::getNumSignificantBits(Value *V, Instruction *In) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeline">    -> std::pair<unsigned, Signedness> {</td>
    <td class="lineNumber">1618</td>
    <td class="codeline">    -> std::pair<unsigned, Signedness> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeline">  unsigned Bits = HVC.getNumSignificantBits(V, In);</td>
    <td class="lineNumber">1619</td>
    <td class="codeline">  unsigned Bits = HVC.getNumSignificantBits(V, In);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeline">  // The significant bits are calculated including the sign bit. This may</td>
    <td class="lineNumber">1620</td>
    <td class="codeline">  // The significant bits are calculated including the sign bit. This may</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeline">  // add an extra bit for zero-extended values, e.g. (zext i32 to i64) may</td>
    <td class="lineNumber">1621</td>
    <td class="codeline">  // add an extra bit for zero-extended values, e.g. (zext i32 to i64) may</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeline">  // result in 33 significant bits. To avoid extra words, skip the extra</td>
    <td class="lineNumber">1622</td>
    <td class="codeline">  // result in 33 significant bits. To avoid extra words, skip the extra</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeline">  // sign bit, but keep information that the value is to be treated as</td>
    <td class="lineNumber">1623</td>
    <td class="codeline">  // sign bit, but keep information that the value is to be treated as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeline">  // unsigned.</td>
    <td class="lineNumber">1624</td>
    <td class="codeline">  // unsigned.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeline">  KnownBits Known = HVC.getKnownBits(V, In);</td>
    <td class="lineNumber">1625</td>
    <td class="codeline">  KnownBits Known = HVC.getKnownBits(V, In);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeline">  Signedness Sign = Signed;</td>
    <td class="lineNumber">1626</td>
    <td class="codeline">  Signedness Sign = Signed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeline">  unsigned NumToTest = 0; // Number of bits used in test for unsignedness.</td>
    <td class="lineNumber">1627</td>
    <td class="codeline">  unsigned NumToTest = 0; // Number of bits used in test for unsignedness.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeline">  if (isPowerOf2_32(Bits))</td>
    <td class="lineNumber">1628</td>
    <td class="codeline">  if (isPowerOf2_32(Bits))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeline">    NumToTest = Bits;</td>
    <td class="lineNumber">1629</td>
    <td class="codeline">    NumToTest = Bits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeline">  else if (Bits > 1 && isPowerOf2_32(Bits - 1))</td>
    <td class="lineNumber">1630</td>
    <td class="codeline">  else if (Bits > 1 && isPowerOf2_32(Bits - 1))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeline">    NumToTest = Bits - 1;</td>
    <td class="lineNumber">1631</td>
    <td class="codeline">    NumToTest = Bits - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeline"></td>
    <td class="lineNumber">1632</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeline">  if (NumToTest != 0 && Known.Zero.ashr(NumToTest).isAllOnes()) {</td>
    <td class="lineNumber">1633</td>
    <td class="codeline">  if (NumToTest != 0 && Known.Zero.ashr(NumToTest).isAllOnes()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeline">    Sign = Unsigned;</td>
    <td class="lineNumber">1634</td>
    <td class="codeline">    Sign = Unsigned;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeline">    Bits = NumToTest;</td>
    <td class="lineNumber">1635</td>
    <td class="codeline">    Bits = NumToTest;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1636</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeline"></td>
    <td class="lineNumber">1637</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeline">  // If the top bit of the nearest power-of-2 is zero, this value is</td>
    <td class="lineNumber">1638</td>
    <td class="codeline">  // If the top bit of the nearest power-of-2 is zero, this value is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeline">  // positive. It could be treated as either signed or unsigned.</td>
    <td class="lineNumber">1639</td>
    <td class="codeline">  // positive. It could be treated as either signed or unsigned.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeline">  if (unsigned Pow2 = PowerOf2Ceil(Bits); Pow2 != Bits) {</td>
    <td class="lineNumber">1640</td>
    <td class="codeline">  if (unsigned Pow2 = PowerOf2Ceil(Bits); Pow2 != Bits) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeline">    if (Known.Zero.ashr(Pow2 - 1).isAllOnes())</td>
    <td class="lineNumber">1641</td>
    <td class="codeline">    if (Known.Zero.ashr(Pow2 - 1).isAllOnes())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeline">      Sign = Positive;</td>
    <td class="lineNumber">1642</td>
    <td class="codeline">      Sign = Positive;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1643</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeline">  return {Bits, Sign};</td>
    <td class="lineNumber">1644</td>
    <td class="codeline">  return {Bits, Sign};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1645</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeline"></td>
    <td class="lineNumber">1646</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeline">auto HvxIdioms::canonSgn(SValue X, SValue Y) const</td>
    <td class="lineNumber">1647</td>
    <td class="codeline">auto HvxIdioms::canonSgn(SValue X, SValue Y) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeline">    -> std::pair<SValue, SValue> {</td>
    <td class="lineNumber">1648</td>
    <td class="codeline">    -> std::pair<SValue, SValue> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeline">  // Canonicalize the signedness of X and Y, so that the result is one of:</td>
    <td class="lineNumber">1649</td>
    <td class="codeline">  // Canonicalize the signedness of X and Y, so that the result is one of:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeline">  //   S, S</td>
    <td class="lineNumber">1650</td>
    <td class="codeline">  //   S, S</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeline">  //   U/P, S</td>
    <td class="lineNumber">1651</td>
    <td class="codeline">  //   U/P, S</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeline">  //   U/P, U/P</td>
    <td class="lineNumber">1652</td>
    <td class="codeline">  //   U/P, U/P</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeline">  if (X.Sgn == Signed && Y.Sgn != Signed)</td>
    <td class="lineNumber">1653</td>
    <td class="codeline">  if (X.Sgn == Signed && Y.Sgn != Signed)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeline">    std::swap(X, Y);</td>
    <td class="lineNumber">1654</td>
    <td class="codeline">    std::swap(X, Y);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeline">  return {X, Y};</td>
    <td class="lineNumber">1655</td>
    <td class="codeline">  return {X, Y};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1656</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeline"></td>
    <td class="lineNumber">1657</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeline">// Match</td>
    <td class="lineNumber">1658</td>
    <td class="codeline">// Match</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeline">//   (X * Y) [>> N], or</td>
    <td class="lineNumber">1659</td>
    <td class="codeline">//   (X * Y) [>> N], or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeline">//   ((X * Y) + (1 << M)) >> N</td>
    <td class="lineNumber">1660</td>
    <td class="codeline">//   ((X * Y) + (1 << M)) >> N</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeline">auto HvxIdioms::matchFxpMul(Instruction &In) const -> std::optional<FxpOp> {</td>
    <td class="lineNumber">1661</td>
    <td class="codeline">auto HvxIdioms::matchFxpMul(Instruction &In) const -> std::optional<FxpOp> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeline">  using namespace PatternMatch;</td>
    <td class="lineNumber">1662</td>
    <td class="codeline">  using namespace PatternMatch;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeline">  auto *Ty = In.getType();</td>
    <td class="lineNumber">1663</td>
    <td class="codeline">  auto *Ty = In.getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeline"></td>
    <td class="lineNumber">1664</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeline">  if (!Ty->isVectorTy() || !Ty->getScalarType()->isIntegerTy())</td>
    <td class="lineNumber">1665</td>
    <td class="codeline">  if (!Ty->isVectorTy() || !Ty->getScalarType()->isIntegerTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeline">    return std::nullopt;</td>
    <td class="lineNumber">1666</td>
    <td class="codeline">    return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeline"></td>
    <td class="lineNumber">1667</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeline">  unsigned Width = cast<IntegerType>(Ty->getScalarType())->getBitWidth();</td>
    <td class="lineNumber">1668</td>
    <td class="codeline">  unsigned Width = cast<IntegerType>(Ty->getScalarType())->getBitWidth();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeline"></td>
    <td class="lineNumber">1669</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeline">  FxpOp Op;</td>
    <td class="lineNumber">1670</td>
    <td class="codeline">  FxpOp Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeline">  Value *Exp = &In;</td>
    <td class="lineNumber">1671</td>
    <td class="codeline">  Value *Exp = &In;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeline"></td>
    <td class="lineNumber">1672</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeline">  // Fixed-point multiplication is always shifted right (except when the</td>
    <td class="lineNumber">1673</td>
    <td class="codeline">  // Fixed-point multiplication is always shifted right (except when the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeline">  // fraction is 0 bits).</td>
    <td class="lineNumber">1674</td>
    <td class="codeline">  // fraction is 0 bits).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeline">  auto m_Shr = [](auto &&V, auto &&S) {</td>
    <td class="lineNumber">1675</td>
    <td class="codeline">  auto m_Shr = [](auto &&V, auto &&S) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeline">    return m_CombineOr(m_LShr(V, S), m_AShr(V, S));</td>
    <td class="lineNumber">1676</td>
    <td class="codeline">    return m_CombineOr(m_LShr(V, S), m_AShr(V, S));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1677</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeline"></td>
    <td class="lineNumber">1678</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeline">  const APInt *Qn = nullptr;</td>
    <td class="lineNumber">1679</td>
    <td class="codeline">  const APInt *Qn = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeline">  if (Value * T; match(Exp, m_Shr(m_Value(T), m_APInt(Qn)))) {</td>
    <td class="lineNumber">1680</td>
    <td class="codeline">  if (Value * T; match(Exp, m_Shr(m_Value(T), m_APInt(Qn)))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeline">    Op.Frac = Qn->getZExtValue();</td>
    <td class="lineNumber">1681</td>
    <td class="codeline">    Op.Frac = Qn->getZExtValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeline">    Exp = T;</td>
    <td class="lineNumber">1682</td>
    <td class="codeline">    Exp = T;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">1683</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeline">    Op.Frac = 0;</td>
    <td class="lineNumber">1684</td>
    <td class="codeline">    Op.Frac = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1685</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeline"></td>
    <td class="lineNumber">1686</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeline">  if (Op.Frac > Width)</td>
    <td class="lineNumber">1687</td>
    <td class="codeline">  if (Op.Frac > Width)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeline">    return std::nullopt;</td>
    <td class="lineNumber">1688</td>
    <td class="codeline">    return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeline"></td>
    <td class="lineNumber">1689</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeline">  // Check if there is rounding added.</td>
    <td class="lineNumber">1690</td>
    <td class="codeline">  // Check if there is rounding added.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeline">  const APInt *C = nullptr;</td>
    <td class="lineNumber">1691</td>
    <td class="codeline">  const APInt *C = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeline">  if (Value * T; Op.Frac > 0 && match(Exp, m_Add(m_Value(T), m_APInt(C)))) {</td>
    <td class="lineNumber">1692</td>
    <td class="codeline">  if (Value * T; Op.Frac > 0 && match(Exp, m_Add(m_Value(T), m_APInt(C)))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeline">    uint64_t CV = C->getZExtValue();</td>
    <td class="lineNumber">1693</td>
    <td class="codeline">    uint64_t CV = C->getZExtValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeline">    if (CV != 0 && !isPowerOf2_64(CV))</td>
    <td class="lineNumber">1694</td>
    <td class="codeline">    if (CV != 0 && !isPowerOf2_64(CV))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeline">      return std::nullopt;</td>
    <td class="lineNumber">1695</td>
    <td class="codeline">      return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeline">    if (CV != 0)</td>
    <td class="lineNumber">1696</td>
    <td class="codeline">    if (CV != 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeline">      Op.RoundAt = Log2_64(CV);</td>
    <td class="lineNumber">1697</td>
    <td class="codeline">      Op.RoundAt = Log2_64(CV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeline">    Exp = T;</td>
    <td class="lineNumber">1698</td>
    <td class="codeline">    Exp = T;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1699</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeline"></td>
    <td class="lineNumber">1700</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeline">  // Check if the rest is a multiplication.</td>
    <td class="lineNumber">1701</td>
    <td class="codeline">  // Check if the rest is a multiplication.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeline">  if (match(Exp, m_Mul(m_Value(Op.X.Val), m_Value(Op.Y.Val)))) {</td>
    <td class="lineNumber">1702</td>
    <td class="codeline">  if (match(Exp, m_Mul(m_Value(Op.X.Val), m_Value(Op.Y.Val)))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeline">    Op.Opcode = Instruction::Mul;</td>
    <td class="lineNumber">1703</td>
    <td class="codeline">    Op.Opcode = Instruction::Mul;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeline">    // FIXME: The information below is recomputed.</td>
    <td class="lineNumber">1704</td>
    <td class="codeline">    // FIXME: The information below is recomputed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeline">    Op.X.Sgn = getNumSignificantBits(Op.X.Val, &In).second;</td>
    <td class="lineNumber">1705</td>
    <td class="codeline">    Op.X.Sgn = getNumSignificantBits(Op.X.Val, &In).second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeline">    Op.Y.Sgn = getNumSignificantBits(Op.Y.Val, &In).second;</td>
    <td class="lineNumber">1706</td>
    <td class="codeline">    Op.Y.Sgn = getNumSignificantBits(Op.Y.Val, &In).second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeline">    Op.ResTy = cast<VectorType>(Ty);</td>
    <td class="lineNumber">1707</td>
    <td class="codeline">    Op.ResTy = cast<VectorType>(Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeline">    return Op;</td>
    <td class="lineNumber">1708</td>
    <td class="codeline">    return Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1709</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeline"></td>
    <td class="lineNumber">1710</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeline">  return std::nullopt;</td>
    <td class="lineNumber">1711</td>
    <td class="codeline">  return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1712</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeline"></td>
    <td class="lineNumber">1713</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeline">auto HvxIdioms::processFxpMul(Instruction &In, const FxpOp &Op) const</td>
    <td class="lineNumber">1714</td>
    <td class="codeline">auto HvxIdioms::processFxpMul(Instruction &In, const FxpOp &Op) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeline">    -> Value * {</td>
    <td class="lineNumber">1715</td>
    <td class="codeline">    -> Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeline">  assert(Op.X.Val->getType() == Op.Y.Val->getType());</td>
    <td class="lineNumber">1716</td>
    <td class="codeline">  assert(Op.X.Val->getType() == Op.Y.Val->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeline"></td>
    <td class="lineNumber">1717</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeline">  auto *VecTy = dyn_cast<VectorType>(Op.X.Val->getType());</td>
    <td class="lineNumber">1718</td>
    <td class="codeline">  auto *VecTy = dyn_cast<VectorType>(Op.X.Val->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeline">  if (VecTy == nullptr)</td>
    <td class="lineNumber">1719</td>
    <td class="codeline">  if (VecTy == nullptr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">1720</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeline">  auto *ElemTy = cast<IntegerType>(VecTy->getElementType());</td>
    <td class="lineNumber">1721</td>
    <td class="codeline">  auto *ElemTy = cast<IntegerType>(VecTy->getElementType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeline">  unsigned ElemWidth = ElemTy->getBitWidth();</td>
    <td class="lineNumber">1722</td>
    <td class="codeline">  unsigned ElemWidth = ElemTy->getBitWidth();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeline"></td>
    <td class="lineNumber">1723</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeline">  // TODO: This can be relaxed after legalization is done pre-isel.</td>
    <td class="lineNumber">1724</td>
    <td class="codeline">  // TODO: This can be relaxed after legalization is done pre-isel.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeline">  if ((HVC.length(VecTy) * ElemWidth) % (8 * HVC.HST.getVectorLength()) != 0)</td>
    <td class="lineNumber">1725</td>
    <td class="codeline">  if ((HVC.length(VecTy) * ElemWidth) % (8 * HVC.HST.getVectorLength()) != 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">1726</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeline"></td>
    <td class="lineNumber">1727</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeline">  // There are no special intrinsics that should be used for multiplying</td>
    <td class="lineNumber">1728</td>
    <td class="codeline">  // There are no special intrinsics that should be used for multiplying</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeline">  // signed 8-bit values, so just skip them. Normal codegen should handle</td>
    <td class="lineNumber">1729</td>
    <td class="codeline">  // signed 8-bit values, so just skip them. Normal codegen should handle</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeline">  // this just fine.</td>
    <td class="lineNumber">1730</td>
    <td class="codeline">  // this just fine.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeline">  if (ElemWidth <= 8)</td>
    <td class="lineNumber">1731</td>
    <td class="codeline">  if (ElemWidth <= 8)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">1732</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeline">  // Similarly, if this is just a multiplication that can be handled without</td>
    <td class="lineNumber">1733</td>
    <td class="codeline">  // Similarly, if this is just a multiplication that can be handled without</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeline">  // intervention, then leave it alone.</td>
    <td class="lineNumber">1734</td>
    <td class="codeline">  // intervention, then leave it alone.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeline">  if (ElemWidth <= 32 && Op.Frac == 0)</td>
    <td class="lineNumber">1735</td>
    <td class="codeline">  if (ElemWidth <= 32 && Op.Frac == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">1736</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeline"></td>
    <td class="lineNumber">1737</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeline">  auto [BitsX, SignX] = getNumSignificantBits(Op.X.Val, &In);</td>
    <td class="lineNumber">1738</td>
    <td class="codeline">  auto [BitsX, SignX] = getNumSignificantBits(Op.X.Val, &In);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeline">  auto [BitsY, SignY] = getNumSignificantBits(Op.Y.Val, &In);</td>
    <td class="lineNumber">1739</td>
    <td class="codeline">  auto [BitsY, SignY] = getNumSignificantBits(Op.Y.Val, &In);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeline"></td>
    <td class="lineNumber">1740</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeline">  // TODO: Add multiplication of vectors by scalar registers (up to 4 bytes).</td>
    <td class="lineNumber">1741</td>
    <td class="codeline">  // TODO: Add multiplication of vectors by scalar registers (up to 4 bytes).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeline"></td>
    <td class="lineNumber">1742</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeline">  Value *X = Op.X.Val, *Y = Op.Y.Val;</td>
    <td class="lineNumber">1743</td>
    <td class="codeline">  Value *X = Op.X.Val, *Y = Op.Y.Val;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeline">  IRBuilder Builder(In.getParent(), In.getIterator(),</td>
    <td class="lineNumber">1744</td>
    <td class="codeline">  IRBuilder Builder(In.getParent(), In.getIterator(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeline">                    InstSimplifyFolder(HVC.DL));</td>
    <td class="lineNumber">1745</td>
    <td class="codeline">                    InstSimplifyFolder(HVC.DL));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeline"></td>
    <td class="lineNumber">1746</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeline">  auto roundUpWidth = [](unsigned Width) -> unsigned {</td>
    <td class="lineNumber">1747</td>
    <td class="codeline">  auto roundUpWidth = [](unsigned Width) -> unsigned {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeline">    if (Width <= 32 && !isPowerOf2_32(Width)) {</td>
    <td class="lineNumber">1748</td>
    <td class="codeline">    if (Width <= 32 && !isPowerOf2_32(Width)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeline">      // If the element width is not a power of 2, round it up</td>
    <td class="lineNumber">1749</td>
    <td class="codeline">      // If the element width is not a power of 2, round it up</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeline">      // to the next one. Do this for widths not exceeding 32.</td>
    <td class="lineNumber">1750</td>
    <td class="codeline">      // to the next one. Do this for widths not exceeding 32.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeline">      return PowerOf2Ceil(Width);</td>
    <td class="lineNumber">1751</td>
    <td class="codeline">      return PowerOf2Ceil(Width);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1752</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeline">    if (Width > 32 && Width % 32 != 0) {</td>
    <td class="lineNumber">1753</td>
    <td class="codeline">    if (Width > 32 && Width % 32 != 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeline">      // For wider elements, round it up to the multiple of 32.</td>
    <td class="lineNumber">1754</td>
    <td class="codeline">      // For wider elements, round it up to the multiple of 32.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeline">      return alignTo(Width, 32u);</td>
    <td class="lineNumber">1755</td>
    <td class="codeline">      return alignTo(Width, 32u);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1756</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeline">    return Width;</td>
    <td class="lineNumber">1757</td>
    <td class="codeline">    return Width;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1758</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeline"></td>
    <td class="lineNumber">1759</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeline">  BitsX = roundUpWidth(BitsX);</td>
    <td class="lineNumber">1760</td>
    <td class="codeline">  BitsX = roundUpWidth(BitsX);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeline">  BitsY = roundUpWidth(BitsY);</td>
    <td class="lineNumber">1761</td>
    <td class="codeline">  BitsY = roundUpWidth(BitsY);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeline"></td>
    <td class="lineNumber">1762</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeline">  // For elementwise multiplication vectors must have the same lengths, so</td>
    <td class="lineNumber">1763</td>
    <td class="codeline">  // For elementwise multiplication vectors must have the same lengths, so</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeline">  // resize the elements of both inputs to the same width, the max of the</td>
    <td class="lineNumber">1764</td>
    <td class="codeline">  // resize the elements of both inputs to the same width, the max of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeline">  // calculated significant bits.</td>
    <td class="lineNumber">1765</td>
    <td class="codeline">  // calculated significant bits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeline">  unsigned Width = std::max(BitsX, BitsY);</td>
    <td class="lineNumber">1766</td>
    <td class="codeline">  unsigned Width = std::max(BitsX, BitsY);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeline"></td>
    <td class="lineNumber">1767</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeline">  auto *ResizeTy = VectorType::get(HVC.getIntTy(Width), VecTy);</td>
    <td class="lineNumber">1768</td>
    <td class="codeline">  auto *ResizeTy = VectorType::get(HVC.getIntTy(Width), VecTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeline">  if (Width < ElemWidth) {</td>
    <td class="lineNumber">1769</td>
    <td class="codeline">  if (Width < ElemWidth) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeline">    X = Builder.CreateTrunc(X, ResizeTy, "trn");</td>
    <td class="lineNumber">1770</td>
    <td class="codeline">    X = Builder.CreateTrunc(X, ResizeTy, "trn");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeline">    Y = Builder.CreateTrunc(Y, ResizeTy, "trn");</td>
    <td class="lineNumber">1771</td>
    <td class="codeline">    Y = Builder.CreateTrunc(Y, ResizeTy, "trn");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeline">  } else if (Width > ElemWidth) {</td>
    <td class="lineNumber">1772</td>
    <td class="codeline">  } else if (Width > ElemWidth) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeline">    X = SignX == Signed ? Builder.CreateSExt(X, ResizeTy, "sxt")</td>
    <td class="lineNumber">1773</td>
    <td class="codeline">    X = SignX == Signed ? Builder.CreateSExt(X, ResizeTy, "sxt")</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeline">                        : Builder.CreateZExt(X, ResizeTy, "zxt");</td>
    <td class="lineNumber">1774</td>
    <td class="codeline">                        : Builder.CreateZExt(X, ResizeTy, "zxt");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeline">    Y = SignY == Signed ? Builder.CreateSExt(Y, ResizeTy, "sxt")</td>
    <td class="lineNumber">1775</td>
    <td class="codeline">    Y = SignY == Signed ? Builder.CreateSExt(Y, ResizeTy, "sxt")</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeline">                        : Builder.CreateZExt(Y, ResizeTy, "zxt");</td>
    <td class="lineNumber">1776</td>
    <td class="codeline">                        : Builder.CreateZExt(Y, ResizeTy, "zxt");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1777</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeline"></td>
    <td class="lineNumber">1778</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeline">  assert(X->getType() == Y->getType() && X->getType() == ResizeTy);</td>
    <td class="lineNumber">1779</td>
    <td class="codeline">  assert(X->getType() == Y->getType() && X->getType() == ResizeTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeline"></td>
    <td class="lineNumber">1780</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeline">  unsigned VecLen = HVC.length(ResizeTy);</td>
    <td class="lineNumber">1781</td>
    <td class="codeline">  unsigned VecLen = HVC.length(ResizeTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeline">  unsigned ChopLen = (8 * HVC.HST.getVectorLength()) / std::min(Width, 32u);</td>
    <td class="lineNumber">1782</td>
    <td class="codeline">  unsigned ChopLen = (8 * HVC.HST.getVectorLength()) / std::min(Width, 32u);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeline"></td>
    <td class="lineNumber">1783</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeline">  SmallVector<Value *> Results;</td>
    <td class="lineNumber">1784</td>
    <td class="codeline">  SmallVector<Value *> Results;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeline">  FxpOp ChopOp = Op;</td>
    <td class="lineNumber">1785</td>
    <td class="codeline">  FxpOp ChopOp = Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeline">  ChopOp.ResTy = VectorType::get(Op.ResTy->getElementType(), ChopLen, false);</td>
    <td class="lineNumber">1786</td>
    <td class="codeline">  ChopOp.ResTy = VectorType::get(Op.ResTy->getElementType(), ChopLen, false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeline"></td>
    <td class="lineNumber">1787</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeline">  for (unsigned V = 0; V != VecLen / ChopLen; ++V) {</td>
    <td class="lineNumber">1788</td>
    <td class="codeline">  for (unsigned V = 0; V != VecLen / ChopLen; ++V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeline">    ChopOp.X.Val = HVC.subvector(Builder, X, V * ChopLen, ChopLen);</td>
    <td class="lineNumber">1789</td>
    <td class="codeline">    ChopOp.X.Val = HVC.subvector(Builder, X, V * ChopLen, ChopLen);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeline">    ChopOp.Y.Val = HVC.subvector(Builder, Y, V * ChopLen, ChopLen);</td>
    <td class="lineNumber">1790</td>
    <td class="codeline">    ChopOp.Y.Val = HVC.subvector(Builder, Y, V * ChopLen, ChopLen);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeline">    Results.push_back(processFxpMulChopped(Builder, In, ChopOp));</td>
    <td class="lineNumber">1791</td>
    <td class="codeline">    Results.push_back(processFxpMulChopped(Builder, In, ChopOp));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeline">    if (Results.back() == nullptr)</td>
    <td class="lineNumber">1792</td>
    <td class="codeline">    if (Results.back() == nullptr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1793</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1794</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="codeline"></td>
    <td class="lineNumber">1795</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="codeline">  if (Results.empty() || Results.back() == nullptr)</td>
    <td class="lineNumber">1796</td>
    <td class="codeline">  if (Results.empty() || Results.back() == nullptr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">1797</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="codeline"></td>
    <td class="lineNumber">1798</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="codeline">  Value *Cat = HVC.concat(Builder, Results);</td>
    <td class="lineNumber">1799</td>
    <td class="codeline">  Value *Cat = HVC.concat(Builder, Results);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="codeline">  Value *Ext = SignX == Signed || SignY == Signed</td>
    <td class="lineNumber">1800</td>
    <td class="codeline">  Value *Ext = SignX == Signed || SignY == Signed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="codeline">                   ? Builder.CreateSExt(Cat, VecTy, "sxt")</td>
    <td class="lineNumber">1801</td>
    <td class="codeline">                   ? Builder.CreateSExt(Cat, VecTy, "sxt")</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="codeline">                   : Builder.CreateZExt(Cat, VecTy, "zxt");</td>
    <td class="lineNumber">1802</td>
    <td class="codeline">                   : Builder.CreateZExt(Cat, VecTy, "zxt");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="codeline">  return Ext;</td>
    <td class="lineNumber">1803</td>
    <td class="codeline">  return Ext;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1804</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="codeline"></td>
    <td class="lineNumber">1805</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="codeline">auto HvxIdioms::processFxpMulChopped(IRBuilderBase &Builder, Instruction &In,</td>
    <td class="lineNumber">1806</td>
    <td class="codeline">auto HvxIdioms::processFxpMulChopped(IRBuilderBase &Builder, Instruction &In,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="codeline">                                     const FxpOp &Op) const -> Value * {</td>
    <td class="lineNumber">1807</td>
    <td class="codeline">                                     const FxpOp &Op) const -> Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="codeline">  assert(Op.X.Val->getType() == Op.Y.Val->getType());</td>
    <td class="lineNumber">1808</td>
    <td class="codeline">  assert(Op.X.Val->getType() == Op.Y.Val->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="codeline">  auto *InpTy = cast<VectorType>(Op.X.Val->getType());</td>
    <td class="lineNumber">1809</td>
    <td class="codeline">  auto *InpTy = cast<VectorType>(Op.X.Val->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="codeline">  unsigned Width = InpTy->getScalarSizeInBits();</td>
    <td class="lineNumber">1810</td>
    <td class="codeline">  unsigned Width = InpTy->getScalarSizeInBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="codeline">  bool Rounding = Op.RoundAt.has_value();</td>
    <td class="lineNumber">1811</td>
    <td class="codeline">  bool Rounding = Op.RoundAt.has_value();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="codeline"></td>
    <td class="lineNumber">1812</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="codeline">  if (!Op.RoundAt || *Op.RoundAt == Op.Frac - 1) {</td>
    <td class="lineNumber">1813</td>
    <td class="codeline">  if (!Op.RoundAt || *Op.RoundAt == Op.Frac - 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="codeline">    // The fixed-point intrinsics do signed multiplication.</td>
    <td class="lineNumber">1814</td>
    <td class="codeline">    // The fixed-point intrinsics do signed multiplication.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="codeline">    if (Width == Op.Frac + 1 && Op.X.Sgn != Unsigned && Op.Y.Sgn != Unsigned) {</td>
    <td class="lineNumber">1815</td>
    <td class="codeline">    if (Width == Op.Frac + 1 && Op.X.Sgn != Unsigned && Op.Y.Sgn != Unsigned) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="codeline">      Value *QMul = nullptr;</td>
    <td class="lineNumber">1816</td>
    <td class="codeline">      Value *QMul = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="codeline">      if (Width == 16) {</td>
    <td class="lineNumber">1817</td>
    <td class="codeline">      if (Width == 16) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="codeline">        QMul = createMulQ15(Builder, Op.X, Op.Y, Rounding);</td>
    <td class="lineNumber">1818</td>
    <td class="codeline">        QMul = createMulQ15(Builder, Op.X, Op.Y, Rounding);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="codeline">      } else if (Width == 32) {</td>
    <td class="lineNumber">1819</td>
    <td class="codeline">      } else if (Width == 32) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="codeline">        QMul = createMulQ31(Builder, Op.X, Op.Y, Rounding);</td>
    <td class="lineNumber">1820</td>
    <td class="codeline">        QMul = createMulQ31(Builder, Op.X, Op.Y, Rounding);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1821</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="codeline">      if (QMul != nullptr)</td>
    <td class="lineNumber">1822</td>
    <td class="codeline">      if (QMul != nullptr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="codeline">        return QMul;</td>
    <td class="lineNumber">1823</td>
    <td class="codeline">        return QMul;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1824</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1825</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="codeline"></td>
    <td class="lineNumber">1826</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="codeline">  assert(Width >= 32 || isPowerOf2_32(Width)); // Width <= 32 => Width is 2^n</td>
    <td class="lineNumber">1827</td>
    <td class="codeline">  assert(Width >= 32 || isPowerOf2_32(Width)); // Width <= 32 => Width is 2^n</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="codeline">  assert(Width < 32 || Width % 32 == 0);       // Width > 32 => Width is 32*k</td>
    <td class="lineNumber">1828</td>
    <td class="codeline">  assert(Width < 32 || Width % 32 == 0);       // Width > 32 => Width is 32*k</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="codeline"></td>
    <td class="lineNumber">1829</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="codeline">  // If Width < 32, then it should really be 16.</td>
    <td class="lineNumber">1830</td>
    <td class="codeline">  // If Width < 32, then it should really be 16.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="codeline">  if (Width < 32) {</td>
    <td class="lineNumber">1831</td>
    <td class="codeline">  if (Width < 32) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="codeline">    if (Width < 16)</td>
    <td class="lineNumber">1832</td>
    <td class="codeline">    if (Width < 16)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="codeline">      return nullptr;</td>
    <td class="lineNumber">1833</td>
    <td class="codeline">      return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="codeline">    // Getting here with Op.Frac == 0 isn't wrong, but suboptimal: here we</td>
    <td class="lineNumber">1834</td>
    <td class="codeline">    // Getting here with Op.Frac == 0 isn't wrong, but suboptimal: here we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="codeline">    // generate a full precision products, which is unnecessary if there is</td>
    <td class="lineNumber">1835</td>
    <td class="codeline">    // generate a full precision products, which is unnecessary if there is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="codeline">    // no shift.</td>
    <td class="lineNumber">1836</td>
    <td class="codeline">    // no shift.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="codeline">    assert(Width == 16);</td>
    <td class="lineNumber">1837</td>
    <td class="codeline">    assert(Width == 16);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="codeline">    assert(Op.Frac != 0 && "Unshifted mul should have been skipped");</td>
    <td class="lineNumber">1838</td>
    <td class="codeline">    assert(Op.Frac != 0 && "Unshifted mul should have been skipped");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="codeline">    if (Op.Frac == 16) {</td>
    <td class="lineNumber">1839</td>
    <td class="codeline">    if (Op.Frac == 16) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="codeline">      // Multiply high</td>
    <td class="lineNumber">1840</td>
    <td class="codeline">      // Multiply high</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="codeline">      if (Value *MulH = createMulH16(Builder, Op.X, Op.Y))</td>
    <td class="lineNumber">1841</td>
    <td class="codeline">      if (Value *MulH = createMulH16(Builder, Op.X, Op.Y))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="codeline">        return MulH;</td>
    <td class="lineNumber">1842</td>
    <td class="codeline">        return MulH;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1843</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="codeline">    // Do full-precision multiply and shift.</td>
    <td class="lineNumber">1844</td>
    <td class="codeline">    // Do full-precision multiply and shift.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="codeline">    Value *Prod32 = createMul16(Builder, Op.X, Op.Y);</td>
    <td class="lineNumber">1845</td>
    <td class="codeline">    Value *Prod32 = createMul16(Builder, Op.X, Op.Y);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="codeline">    if (Rounding) {</td>
    <td class="lineNumber">1846</td>
    <td class="codeline">    if (Rounding) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="codeline">      Value *RoundVal = HVC.getConstSplat(Prod32->getType(), 1 << *Op.RoundAt);</td>
    <td class="lineNumber">1847</td>
    <td class="codeline">      Value *RoundVal = HVC.getConstSplat(Prod32->getType(), 1 << *Op.RoundAt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="codeline">      Prod32 = Builder.CreateAdd(Prod32, RoundVal, "add");</td>
    <td class="lineNumber">1848</td>
    <td class="codeline">      Prod32 = Builder.CreateAdd(Prod32, RoundVal, "add");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1849</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="codeline"></td>
    <td class="lineNumber">1850</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="codeline">    Value *ShiftAmt = HVC.getConstSplat(Prod32->getType(), Op.Frac);</td>
    <td class="lineNumber">1851</td>
    <td class="codeline">    Value *ShiftAmt = HVC.getConstSplat(Prod32->getType(), Op.Frac);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="codeline">    Value *Shifted = Op.X.Sgn == Signed || Op.Y.Sgn == Signed</td>
    <td class="lineNumber">1852</td>
    <td class="codeline">    Value *Shifted = Op.X.Sgn == Signed || Op.Y.Sgn == Signed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="codeline">                         ? Builder.CreateAShr(Prod32, ShiftAmt, "asr")</td>
    <td class="lineNumber">1853</td>
    <td class="codeline">                         ? Builder.CreateAShr(Prod32, ShiftAmt, "asr")</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="codeline">                         : Builder.CreateLShr(Prod32, ShiftAmt, "lsr");</td>
    <td class="lineNumber">1854</td>
    <td class="codeline">                         : Builder.CreateLShr(Prod32, ShiftAmt, "lsr");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="codeline">    return Builder.CreateTrunc(Shifted, InpTy, "trn");</td>
    <td class="lineNumber">1855</td>
    <td class="codeline">    return Builder.CreateTrunc(Shifted, InpTy, "trn");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1856</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="codeline"></td>
    <td class="lineNumber">1857</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="codeline">  // Width >= 32</td>
    <td class="lineNumber">1858</td>
    <td class="codeline">  // Width >= 32</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="codeline"></td>
    <td class="lineNumber">1859</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="codeline">  // Break up the arguments Op.X and Op.Y into vectors of smaller widths</td>
    <td class="lineNumber">1860</td>
    <td class="codeline">  // Break up the arguments Op.X and Op.Y into vectors of smaller widths</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="codeline">  // in preparation of doing the multiplication by 32-bit parts.</td>
    <td class="lineNumber">1861</td>
    <td class="codeline">  // in preparation of doing the multiplication by 32-bit parts.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="codeline">  auto WordX = HVC.splitVectorElements(Builder, Op.X.Val, /*ToWidth=*/32);</td>
    <td class="lineNumber">1862</td>
    <td class="codeline">  auto WordX = HVC.splitVectorElements(Builder, Op.X.Val, /*ToWidth=*/32);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="codeline">  auto WordY = HVC.splitVectorElements(Builder, Op.Y.Val, /*ToWidth=*/32);</td>
    <td class="lineNumber">1863</td>
    <td class="codeline">  auto WordY = HVC.splitVectorElements(Builder, Op.Y.Val, /*ToWidth=*/32);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="codeline">  auto WordP = createMulLong(Builder, WordX, Op.X.Sgn, WordY, Op.Y.Sgn);</td>
    <td class="lineNumber">1864</td>
    <td class="codeline">  auto WordP = createMulLong(Builder, WordX, Op.X.Sgn, WordY, Op.Y.Sgn);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="codeline"></td>
    <td class="lineNumber">1865</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="codeline">  auto *HvxWordTy = cast<VectorType>(WordP.front()->getType());</td>
    <td class="lineNumber">1866</td>
    <td class="codeline">  auto *HvxWordTy = cast<VectorType>(WordP.front()->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="codeline"></td>
    <td class="lineNumber">1867</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="codeline">  // Add the optional rounding to the proper word.</td>
    <td class="lineNumber">1868</td>
    <td class="codeline">  // Add the optional rounding to the proper word.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="codeline">  if (Op.RoundAt.has_value()) {</td>
    <td class="lineNumber">1869</td>
    <td class="codeline">  if (Op.RoundAt.has_value()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="codeline">    Value *Zero = HVC.getNullValue(WordX[0]->getType());</td>
    <td class="lineNumber">1870</td>
    <td class="codeline">    Value *Zero = HVC.getNullValue(WordX[0]->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="codeline">    SmallVector<Value *> RoundV(WordP.size(), Zero);</td>
    <td class="lineNumber">1871</td>
    <td class="codeline">    SmallVector<Value *> RoundV(WordP.size(), Zero);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="codeline">    RoundV[*Op.RoundAt / 32] =</td>
    <td class="lineNumber">1872</td>
    <td class="codeline">    RoundV[*Op.RoundAt / 32] =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="codeline">        HVC.getConstSplat(HvxWordTy, 1 << (*Op.RoundAt % 32));</td>
    <td class="lineNumber">1873</td>
    <td class="codeline">        HVC.getConstSplat(HvxWordTy, 1 << (*Op.RoundAt % 32));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="codeline">    WordP = createAddLong(Builder, WordP, RoundV);</td>
    <td class="lineNumber">1874</td>
    <td class="codeline">    WordP = createAddLong(Builder, WordP, RoundV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1875</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="codeline"></td>
    <td class="lineNumber">1876</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="codeline">  // createRightShiftLong?</td>
    <td class="lineNumber">1877</td>
    <td class="codeline">  // createRightShiftLong?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="codeline"></td>
    <td class="lineNumber">1878</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="codeline">  // Shift all products right by Op.Frac.</td>
    <td class="lineNumber">1879</td>
    <td class="codeline">  // Shift all products right by Op.Frac.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="codeline">  unsigned SkipWords = Op.Frac / 32;</td>
    <td class="lineNumber">1880</td>
    <td class="codeline">  unsigned SkipWords = Op.Frac / 32;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="codeline">  Constant *ShiftAmt = HVC.getConstSplat(HvxWordTy, Op.Frac % 32);</td>
    <td class="lineNumber">1881</td>
    <td class="codeline">  Constant *ShiftAmt = HVC.getConstSplat(HvxWordTy, Op.Frac % 32);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="codeline"></td>
    <td class="lineNumber">1882</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="codeline">  for (int Dst = 0, End = WordP.size() - SkipWords; Dst != End; ++Dst) {</td>
    <td class="lineNumber">1883</td>
    <td class="codeline">  for (int Dst = 0, End = WordP.size() - SkipWords; Dst != End; ++Dst) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="codeline">    int Src = Dst + SkipWords;</td>
    <td class="lineNumber">1884</td>
    <td class="codeline">    int Src = Dst + SkipWords;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="codeline">    Value *Lo = WordP[Src];</td>
    <td class="lineNumber">1885</td>
    <td class="codeline">    Value *Lo = WordP[Src];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="codeline">    if (Src + 1 < End) {</td>
    <td class="lineNumber">1886</td>
    <td class="codeline">    if (Src + 1 < End) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="codeline">      Value *Hi = WordP[Src + 1];</td>
    <td class="lineNumber">1887</td>
    <td class="codeline">      Value *Hi = WordP[Src + 1];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="codeline">      WordP[Dst] = Builder.CreateIntrinsic(HvxWordTy, Intrinsic::fshr,</td>
    <td class="lineNumber">1888</td>
    <td class="codeline">      WordP[Dst] = Builder.CreateIntrinsic(HvxWordTy, Intrinsic::fshr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="codeline">                                           {Hi, Lo, ShiftAmt},</td>
    <td class="lineNumber">1889</td>
    <td class="codeline">                                           {Hi, Lo, ShiftAmt},</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="codeline">                                           /*FMFSource*/ nullptr, "int");</td>
    <td class="lineNumber">1890</td>
    <td class="codeline">                                           /*FMFSource*/ nullptr, "int");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">1891</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="codeline">      // The shift of the most significant word.</td>
    <td class="lineNumber">1892</td>
    <td class="codeline">      // The shift of the most significant word.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="codeline">      WordP[Dst] = Builder.CreateAShr(Lo, ShiftAmt, "asr");</td>
    <td class="lineNumber">1893</td>
    <td class="codeline">      WordP[Dst] = Builder.CreateAShr(Lo, ShiftAmt, "asr");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1894</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1895</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="codeline">  if (SkipWords != 0)</td>
    <td class="lineNumber">1896</td>
    <td class="codeline">  if (SkipWords != 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="codeline">    WordP.resize(WordP.size() - SkipWords);</td>
    <td class="lineNumber">1897</td>
    <td class="codeline">    WordP.resize(WordP.size() - SkipWords);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="codeline"></td>
    <td class="lineNumber">1898</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="codeline">  return HVC.joinVectorElements(Builder, WordP, Op.ResTy);</td>
    <td class="lineNumber">1899</td>
    <td class="codeline">  return HVC.joinVectorElements(Builder, WordP, Op.ResTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1900</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="codeline"></td>
    <td class="lineNumber">1901</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="codeline">auto HvxIdioms::createMulQ15(IRBuilderBase &Builder, SValue X, SValue Y,</td>
    <td class="lineNumber">1902</td>
    <td class="codeline">auto HvxIdioms::createMulQ15(IRBuilderBase &Builder, SValue X, SValue Y,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="codeline">                             bool Rounding) const -> Value * {</td>
    <td class="lineNumber">1903</td>
    <td class="codeline">                             bool Rounding) const -> Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="codeline">  assert(X.Val->getType() == Y.Val->getType());</td>
    <td class="lineNumber">1904</td>
    <td class="codeline">  assert(X.Val->getType() == Y.Val->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="codeline">  assert(X.Val->getType()->getScalarType() == HVC.getIntTy(16));</td>
    <td class="lineNumber">1905</td>
    <td class="codeline">  assert(X.Val->getType()->getScalarType() == HVC.getIntTy(16));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="codeline">  assert(HVC.HST.isHVXVectorType(EVT::getEVT(X.Val->getType(), false)));</td>
    <td class="lineNumber">1906</td>
    <td class="codeline">  assert(HVC.HST.isHVXVectorType(EVT::getEVT(X.Val->getType(), false)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="codeline"></td>
    <td class="lineNumber">1907</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="codeline">  // There is no non-rounding intrinsic for i16.</td>
    <td class="lineNumber">1908</td>
    <td class="codeline">  // There is no non-rounding intrinsic for i16.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="codeline">  if (!Rounding || X.Sgn == Unsigned || Y.Sgn == Unsigned)</td>
    <td class="lineNumber">1909</td>
    <td class="codeline">  if (!Rounding || X.Sgn == Unsigned || Y.Sgn == Unsigned)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">1910</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="codeline"></td>
    <td class="lineNumber">1911</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="codeline">  auto V6_vmpyhvsrs = HVC.HST.getIntrinsicId(Hexagon::V6_vmpyhvsrs);</td>
    <td class="lineNumber">1912</td>
    <td class="codeline">  auto V6_vmpyhvsrs = HVC.HST.getIntrinsicId(Hexagon::V6_vmpyhvsrs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="codeline">  return HVC.createHvxIntrinsic(Builder, V6_vmpyhvsrs, X.Val->getType(),</td>
    <td class="lineNumber">1913</td>
    <td class="codeline">  return HVC.createHvxIntrinsic(Builder, V6_vmpyhvsrs, X.Val->getType(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="codeline">                                {X.Val, Y.Val});</td>
    <td class="lineNumber">1914</td>
    <td class="codeline">                                {X.Val, Y.Val});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1915</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="codeline"></td>
    <td class="lineNumber">1916</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="codeline">auto HvxIdioms::createMulQ31(IRBuilderBase &Builder, SValue X, SValue Y,</td>
    <td class="lineNumber">1917</td>
    <td class="codeline">auto HvxIdioms::createMulQ31(IRBuilderBase &Builder, SValue X, SValue Y,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="codeline">                             bool Rounding) const -> Value * {</td>
    <td class="lineNumber">1918</td>
    <td class="codeline">                             bool Rounding) const -> Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="codeline">  Type *InpTy = X.Val->getType();</td>
    <td class="lineNumber">1919</td>
    <td class="codeline">  Type *InpTy = X.Val->getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="codeline">  assert(InpTy == Y.Val->getType());</td>
    <td class="lineNumber">1920</td>
    <td class="codeline">  assert(InpTy == Y.Val->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="codeline">  assert(InpTy->getScalarType() == HVC.getIntTy(32));</td>
    <td class="lineNumber">1921</td>
    <td class="codeline">  assert(InpTy->getScalarType() == HVC.getIntTy(32));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="codeline">  assert(HVC.HST.isHVXVectorType(EVT::getEVT(InpTy, false)));</td>
    <td class="lineNumber">1922</td>
    <td class="codeline">  assert(HVC.HST.isHVXVectorType(EVT::getEVT(InpTy, false)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="codeline"></td>
    <td class="lineNumber">1923</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="codeline">  if (X.Sgn == Unsigned || Y.Sgn == Unsigned)</td>
    <td class="lineNumber">1924</td>
    <td class="codeline">  if (X.Sgn == Unsigned || Y.Sgn == Unsigned)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">1925</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="codeline"></td>
    <td class="lineNumber">1926</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="codeline">  auto V6_vmpyewuh = HVC.HST.getIntrinsicId(Hexagon::V6_vmpyewuh);</td>
    <td class="lineNumber">1927</td>
    <td class="codeline">  auto V6_vmpyewuh = HVC.HST.getIntrinsicId(Hexagon::V6_vmpyewuh);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="codeline">  auto V6_vmpyo_acc = Rounding</td>
    <td class="lineNumber">1928</td>
    <td class="codeline">  auto V6_vmpyo_acc = Rounding</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="codeline">                          ? HVC.HST.getIntrinsicId(Hexagon::V6_vmpyowh_rnd_sacc)</td>
    <td class="lineNumber">1929</td>
    <td class="codeline">                          ? HVC.HST.getIntrinsicId(Hexagon::V6_vmpyowh_rnd_sacc)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="codeline">                          : HVC.HST.getIntrinsicId(Hexagon::V6_vmpyowh_sacc);</td>
    <td class="lineNumber">1930</td>
    <td class="codeline">                          : HVC.HST.getIntrinsicId(Hexagon::V6_vmpyowh_sacc);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="codeline">  Value *V1 =</td>
    <td class="lineNumber">1931</td>
    <td class="codeline">  Value *V1 =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="codeline">      HVC.createHvxIntrinsic(Builder, V6_vmpyewuh, InpTy, {X.Val, Y.Val});</td>
    <td class="lineNumber">1932</td>
    <td class="codeline">      HVC.createHvxIntrinsic(Builder, V6_vmpyewuh, InpTy, {X.Val, Y.Val});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="codeline">  return HVC.createHvxIntrinsic(Builder, V6_vmpyo_acc, InpTy,</td>
    <td class="lineNumber">1933</td>
    <td class="codeline">  return HVC.createHvxIntrinsic(Builder, V6_vmpyo_acc, InpTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="codeline">                                {V1, X.Val, Y.Val});</td>
    <td class="lineNumber">1934</td>
    <td class="codeline">                                {V1, X.Val, Y.Val});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1935</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="codeline"></td>
    <td class="lineNumber">1936</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="codeline">auto HvxIdioms::createAddCarry(IRBuilderBase &Builder, Value *X, Value *Y,</td>
    <td class="lineNumber">1937</td>
    <td class="codeline">auto HvxIdioms::createAddCarry(IRBuilderBase &Builder, Value *X, Value *Y,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="codeline">                               Value *CarryIn) const</td>
    <td class="lineNumber">1938</td>
    <td class="codeline">                               Value *CarryIn) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="codeline">    -> std::pair<Value *, Value *> {</td>
    <td class="lineNumber">1939</td>
    <td class="codeline">    -> std::pair<Value *, Value *> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="codeline">  assert(X->getType() == Y->getType());</td>
    <td class="lineNumber">1940</td>
    <td class="codeline">  assert(X->getType() == Y->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="codeline">  auto VecTy = cast<VectorType>(X->getType());</td>
    <td class="lineNumber">1941</td>
    <td class="codeline">  auto VecTy = cast<VectorType>(X->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="codeline">  if (VecTy == HvxI32Ty && HVC.HST.useHVXV62Ops()) {</td>
    <td class="lineNumber">1942</td>
    <td class="codeline">  if (VecTy == HvxI32Ty && HVC.HST.useHVXV62Ops()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="codeline">    SmallVector<Value *> Args = {X, Y};</td>
    <td class="lineNumber">1943</td>
    <td class="codeline">    SmallVector<Value *> Args = {X, Y};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="codeline">    Intrinsic::ID AddCarry;</td>
    <td class="lineNumber">1944</td>
    <td class="codeline">    Intrinsic::ID AddCarry;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="codeline">    if (CarryIn == nullptr && HVC.HST.useHVXV66Ops()) {</td>
    <td class="lineNumber">1945</td>
    <td class="codeline">    if (CarryIn == nullptr && HVC.HST.useHVXV66Ops()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="codeline">      AddCarry = HVC.HST.getIntrinsicId(Hexagon::V6_vaddcarryo);</td>
    <td class="lineNumber">1946</td>
    <td class="codeline">      AddCarry = HVC.HST.getIntrinsicId(Hexagon::V6_vaddcarryo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">1947</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="codeline">      AddCarry = HVC.HST.getIntrinsicId(Hexagon::V6_vaddcarry);</td>
    <td class="lineNumber">1948</td>
    <td class="codeline">      AddCarry = HVC.HST.getIntrinsicId(Hexagon::V6_vaddcarry);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="codeline">      if (CarryIn == nullptr)</td>
    <td class="lineNumber">1949</td>
    <td class="codeline">      if (CarryIn == nullptr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="codeline">        CarryIn = HVC.getNullValue(HVC.getBoolTy(HVC.length(VecTy)));</td>
    <td class="lineNumber">1950</td>
    <td class="codeline">        CarryIn = HVC.getNullValue(HVC.getBoolTy(HVC.length(VecTy)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="codeline">      Args.push_back(CarryIn);</td>
    <td class="lineNumber">1951</td>
    <td class="codeline">      Args.push_back(CarryIn);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1952</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="codeline">    Value *Ret = HVC.createHvxIntrinsic(Builder, AddCarry,</td>
    <td class="lineNumber">1953</td>
    <td class="codeline">    Value *Ret = HVC.createHvxIntrinsic(Builder, AddCarry,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="codeline">                                        /*RetTy=*/nullptr, Args);</td>
    <td class="lineNumber">1954</td>
    <td class="codeline">                                        /*RetTy=*/nullptr, Args);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="codeline">    Value *Result = Builder.CreateExtractValue(Ret, {0}, "ext");</td>
    <td class="lineNumber">1955</td>
    <td class="codeline">    Value *Result = Builder.CreateExtractValue(Ret, {0}, "ext");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="codeline">    Value *CarryOut = Builder.CreateExtractValue(Ret, {1}, "ext");</td>
    <td class="lineNumber">1956</td>
    <td class="codeline">    Value *CarryOut = Builder.CreateExtractValue(Ret, {1}, "ext");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="codeline">    return {Result, CarryOut};</td>
    <td class="lineNumber">1957</td>
    <td class="codeline">    return {Result, CarryOut};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1958</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="codeline"></td>
    <td class="lineNumber">1959</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="codeline">  // In other cases, do a regular add, and unsigned compare-less-than.</td>
    <td class="lineNumber">1960</td>
    <td class="codeline">  // In other cases, do a regular add, and unsigned compare-less-than.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="codeline">  // The carry-out can originate in two places: adding the carry-in or adding</td>
    <td class="lineNumber">1961</td>
    <td class="codeline">  // The carry-out can originate in two places: adding the carry-in or adding</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="codeline">  // the two input values.</td>
    <td class="lineNumber">1962</td>
    <td class="codeline">  // the two input values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="codeline">  Value *Result1 = X; // Result1 = X + CarryIn</td>
    <td class="lineNumber">1963</td>
    <td class="codeline">  Value *Result1 = X; // Result1 = X + CarryIn</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="codeline">  if (CarryIn != nullptr) {</td>
    <td class="lineNumber">1964</td>
    <td class="codeline">  if (CarryIn != nullptr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="codeline">    unsigned Width = VecTy->getScalarSizeInBits();</td>
    <td class="lineNumber">1965</td>
    <td class="codeline">    unsigned Width = VecTy->getScalarSizeInBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="codeline">    uint32_t Mask = 1;</td>
    <td class="lineNumber">1966</td>
    <td class="codeline">    uint32_t Mask = 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="codeline">    if (Width < 32) {</td>
    <td class="lineNumber">1967</td>
    <td class="codeline">    if (Width < 32) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="codeline">      for (unsigned i = 0, e = 32 / Width; i != e; ++i)</td>
    <td class="lineNumber">1968</td>
    <td class="codeline">      for (unsigned i = 0, e = 32 / Width; i != e; ++i)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="codeline">        Mask = (Mask << Width) | 1;</td>
    <td class="lineNumber">1969</td>
    <td class="codeline">        Mask = (Mask << Width) | 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1970</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="codeline">    auto V6_vandqrt = HVC.HST.getIntrinsicId(Hexagon::V6_vandqrt);</td>
    <td class="lineNumber">1971</td>
    <td class="codeline">    auto V6_vandqrt = HVC.HST.getIntrinsicId(Hexagon::V6_vandqrt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="codeline">    Value *ValueIn =</td>
    <td class="lineNumber">1972</td>
    <td class="codeline">    Value *ValueIn =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="codeline">        HVC.createHvxIntrinsic(Builder, V6_vandqrt, /*RetTy=*/nullptr,</td>
    <td class="lineNumber">1973</td>
    <td class="codeline">        HVC.createHvxIntrinsic(Builder, V6_vandqrt, /*RetTy=*/nullptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="codeline">                               {CarryIn, HVC.getConstInt(Mask)});</td>
    <td class="lineNumber">1974</td>
    <td class="codeline">                               {CarryIn, HVC.getConstInt(Mask)});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="codeline">    Result1 = Builder.CreateAdd(X, ValueIn, "add");</td>
    <td class="lineNumber">1975</td>
    <td class="codeline">    Result1 = Builder.CreateAdd(X, ValueIn, "add");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1976</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="codeline"></td>
    <td class="lineNumber">1977</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="codeline">  Value *CarryOut1 = Builder.CreateCmp(CmpInst::ICMP_ULT, Result1, X, "cmp");</td>
    <td class="lineNumber">1978</td>
    <td class="codeline">  Value *CarryOut1 = Builder.CreateCmp(CmpInst::ICMP_ULT, Result1, X, "cmp");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="codeline">  Value *Result2 = Builder.CreateAdd(Result1, Y, "add");</td>
    <td class="lineNumber">1979</td>
    <td class="codeline">  Value *Result2 = Builder.CreateAdd(Result1, Y, "add");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="codeline">  Value *CarryOut2 = Builder.CreateCmp(CmpInst::ICMP_ULT, Result2, Y, "cmp");</td>
    <td class="lineNumber">1980</td>
    <td class="codeline">  Value *CarryOut2 = Builder.CreateCmp(CmpInst::ICMP_ULT, Result2, Y, "cmp");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="codeline">  return {Result2, Builder.CreateOr(CarryOut1, CarryOut2, "orb")};</td>
    <td class="lineNumber">1981</td>
    <td class="codeline">  return {Result2, Builder.CreateOr(CarryOut1, CarryOut2, "orb")};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1982</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="codeline"></td>
    <td class="lineNumber">1983</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="codeline">auto HvxIdioms::createMul16(IRBuilderBase &Builder, SValue X, SValue Y) const</td>
    <td class="lineNumber">1984</td>
    <td class="codeline">auto HvxIdioms::createMul16(IRBuilderBase &Builder, SValue X, SValue Y) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="codeline">    -> Value * {</td>
    <td class="lineNumber">1985</td>
    <td class="codeline">    -> Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="codeline">  Intrinsic::ID V6_vmpyh = 0;</td>
    <td class="lineNumber">1986</td>
    <td class="codeline">  Intrinsic::ID V6_vmpyh = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="codeline">  std::tie(X, Y) = canonSgn(X, Y);</td>
    <td class="lineNumber">1987</td>
    <td class="codeline">  std::tie(X, Y) = canonSgn(X, Y);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="codeline"></td>
    <td class="lineNumber">1988</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="codeline">  if (X.Sgn == Signed) {</td>
    <td class="lineNumber">1989</td>
    <td class="codeline">  if (X.Sgn == Signed) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="codeline">    V6_vmpyh = HVC.HST.getIntrinsicId(Hexagon::V6_vmpyhv);</td>
    <td class="lineNumber">1990</td>
    <td class="codeline">    V6_vmpyh = HVC.HST.getIntrinsicId(Hexagon::V6_vmpyhv);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="codeline">  } else if (Y.Sgn == Signed) {</td>
    <td class="lineNumber">1991</td>
    <td class="codeline">  } else if (Y.Sgn == Signed) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="codeline">    // In vmpyhus the second operand is unsigned</td>
    <td class="lineNumber">1992</td>
    <td class="codeline">    // In vmpyhus the second operand is unsigned</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="codeline">    V6_vmpyh = HVC.HST.getIntrinsicId(Hexagon::V6_vmpyhus);</td>
    <td class="lineNumber">1993</td>
    <td class="codeline">    V6_vmpyh = HVC.HST.getIntrinsicId(Hexagon::V6_vmpyhus);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">1994</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="codeline">    V6_vmpyh = HVC.HST.getIntrinsicId(Hexagon::V6_vmpyuhv);</td>
    <td class="lineNumber">1995</td>
    <td class="codeline">    V6_vmpyh = HVC.HST.getIntrinsicId(Hexagon::V6_vmpyuhv);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1996</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="codeline"></td>
    <td class="lineNumber">1997</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="codeline">  // i16*i16 -> i32 / interleaved</td>
    <td class="lineNumber">1998</td>
    <td class="codeline">  // i16*i16 -> i32 / interleaved</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="codeline">  Value *P =</td>
    <td class="lineNumber">1999</td>
    <td class="codeline">  Value *P =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="codeline">      HVC.createHvxIntrinsic(Builder, V6_vmpyh, HvxP32Ty, {Y.Val, X.Val});</td>
    <td class="lineNumber">2000</td>
    <td class="codeline">      HVC.createHvxIntrinsic(Builder, V6_vmpyh, HvxP32Ty, {Y.Val, X.Val});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="codeline">  // Deinterleave</td>
    <td class="lineNumber">2001</td>
    <td class="codeline">  // Deinterleave</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="codeline">  return HVC.vshuff(Builder, HVC.sublo(Builder, P), HVC.subhi(Builder, P));</td>
    <td class="lineNumber">2002</td>
    <td class="codeline">  return HVC.vshuff(Builder, HVC.sublo(Builder, P), HVC.subhi(Builder, P));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2003</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="codeline"></td>
    <td class="lineNumber">2004</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="codeline">auto HvxIdioms::createMulH16(IRBuilderBase &Builder, SValue X, SValue Y) const</td>
    <td class="lineNumber">2005</td>
    <td class="codeline">auto HvxIdioms::createMulH16(IRBuilderBase &Builder, SValue X, SValue Y) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="codeline">    -> Value * {</td>
    <td class="lineNumber">2006</td>
    <td class="codeline">    -> Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="codeline">  Type *HvxI16Ty = HVC.getHvxTy(HVC.getIntTy(16), /*Pair=*/false);</td>
    <td class="lineNumber">2007</td>
    <td class="codeline">  Type *HvxI16Ty = HVC.getHvxTy(HVC.getIntTy(16), /*Pair=*/false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="codeline"></td>
    <td class="lineNumber">2008</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="codeline">  if (HVC.HST.useHVXV69Ops()) {</td>
    <td class="lineNumber">2009</td>
    <td class="codeline">  if (HVC.HST.useHVXV69Ops()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="codeline">    if (X.Sgn != Signed && Y.Sgn != Signed) {</td>
    <td class="lineNumber">2010</td>
    <td class="codeline">    if (X.Sgn != Signed && Y.Sgn != Signed) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="codeline">      auto V6_vmpyuhvs = HVC.HST.getIntrinsicId(Hexagon::V6_vmpyuhvs);</td>
    <td class="lineNumber">2011</td>
    <td class="codeline">      auto V6_vmpyuhvs = HVC.HST.getIntrinsicId(Hexagon::V6_vmpyuhvs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="codeline">      return HVC.createHvxIntrinsic(Builder, V6_vmpyuhvs, HvxI16Ty,</td>
    <td class="lineNumber">2012</td>
    <td class="codeline">      return HVC.createHvxIntrinsic(Builder, V6_vmpyuhvs, HvxI16Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="codeline">                                    {X.Val, Y.Val});</td>
    <td class="lineNumber">2013</td>
    <td class="codeline">                                    {X.Val, Y.Val});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2014</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2015</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="codeline"></td>
    <td class="lineNumber">2016</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="codeline">  Type *HvxP16Ty = HVC.getHvxTy(HVC.getIntTy(16), /*Pair=*/true);</td>
    <td class="lineNumber">2017</td>
    <td class="codeline">  Type *HvxP16Ty = HVC.getHvxTy(HVC.getIntTy(16), /*Pair=*/true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="codeline">  Value *Pair16 =</td>
    <td class="lineNumber">2018</td>
    <td class="codeline">  Value *Pair16 =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="codeline">      Builder.CreateBitCast(createMul16(Builder, X, Y), HvxP16Ty, "cst");</td>
    <td class="lineNumber">2019</td>
    <td class="codeline">      Builder.CreateBitCast(createMul16(Builder, X, Y), HvxP16Ty, "cst");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="codeline">  unsigned Len = HVC.length(HvxP16Ty) / 2;</td>
    <td class="lineNumber">2020</td>
    <td class="codeline">  unsigned Len = HVC.length(HvxP16Ty) / 2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="codeline"></td>
    <td class="lineNumber">2021</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="codeline">  SmallVector<int, 128> PickOdd(Len);</td>
    <td class="lineNumber">2022</td>
    <td class="codeline">  SmallVector<int, 128> PickOdd(Len);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="codeline">  for (int i = 0; i != static_cast<int>(Len); ++i)</td>
    <td class="lineNumber">2023</td>
    <td class="codeline">  for (int i = 0; i != static_cast<int>(Len); ++i)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="codeline">    PickOdd[i] = 2 * i + 1;</td>
    <td class="lineNumber">2024</td>
    <td class="codeline">    PickOdd[i] = 2 * i + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="codeline"></td>
    <td class="lineNumber">2025</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="codeline">  return Builder.CreateShuffleVector(</td>
    <td class="lineNumber">2026</td>
    <td class="codeline">  return Builder.CreateShuffleVector(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="codeline">      HVC.sublo(Builder, Pair16), HVC.subhi(Builder, Pair16), PickOdd, "shf");</td>
    <td class="lineNumber">2027</td>
    <td class="codeline">      HVC.sublo(Builder, Pair16), HVC.subhi(Builder, Pair16), PickOdd, "shf");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2028</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="codeline"></td>
    <td class="lineNumber">2029</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="codeline">auto HvxIdioms::createMul32(IRBuilderBase &Builder, SValue X, SValue Y) const</td>
    <td class="lineNumber">2030</td>
    <td class="codeline">auto HvxIdioms::createMul32(IRBuilderBase &Builder, SValue X, SValue Y) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="codeline">    -> std::pair<Value *, Value *> {</td>
    <td class="lineNumber">2031</td>
    <td class="codeline">    -> std::pair<Value *, Value *> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="codeline">  assert(X.Val->getType() == Y.Val->getType());</td>
    <td class="lineNumber">2032</td>
    <td class="codeline">  assert(X.Val->getType() == Y.Val->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="codeline">  assert(X.Val->getType() == HvxI32Ty);</td>
    <td class="lineNumber">2033</td>
    <td class="codeline">  assert(X.Val->getType() == HvxI32Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="codeline"></td>
    <td class="lineNumber">2034</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="codeline">  Intrinsic::ID V6_vmpy_parts;</td>
    <td class="lineNumber">2035</td>
    <td class="codeline">  Intrinsic::ID V6_vmpy_parts;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="codeline">  std::tie(X, Y) = canonSgn(X, Y);</td>
    <td class="lineNumber">2036</td>
    <td class="codeline">  std::tie(X, Y) = canonSgn(X, Y);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="codeline"></td>
    <td class="lineNumber">2037</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="codeline">  if (X.Sgn == Signed) {</td>
    <td class="lineNumber">2038</td>
    <td class="codeline">  if (X.Sgn == Signed) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="codeline">    V6_vmpy_parts = Intrinsic::hexagon_V6_vmpyss_parts;</td>
    <td class="lineNumber">2039</td>
    <td class="codeline">    V6_vmpy_parts = Intrinsic::hexagon_V6_vmpyss_parts;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="codeline">  } else if (Y.Sgn == Signed) {</td>
    <td class="lineNumber">2040</td>
    <td class="codeline">  } else if (Y.Sgn == Signed) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="codeline">    V6_vmpy_parts = Intrinsic::hexagon_V6_vmpyus_parts;</td>
    <td class="lineNumber">2041</td>
    <td class="codeline">    V6_vmpy_parts = Intrinsic::hexagon_V6_vmpyus_parts;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">2042</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="codeline">    V6_vmpy_parts = Intrinsic::hexagon_V6_vmpyuu_parts;</td>
    <td class="lineNumber">2043</td>
    <td class="codeline">    V6_vmpy_parts = Intrinsic::hexagon_V6_vmpyuu_parts;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2044</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="codeline"></td>
    <td class="lineNumber">2045</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="codeline">  Value *Parts = HVC.createHvxIntrinsic(Builder, V6_vmpy_parts, nullptr,</td>
    <td class="lineNumber">2046</td>
    <td class="codeline">  Value *Parts = HVC.createHvxIntrinsic(Builder, V6_vmpy_parts, nullptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="codeline">                                        {X.Val, Y.Val}, {HvxI32Ty});</td>
    <td class="lineNumber">2047</td>
    <td class="codeline">                                        {X.Val, Y.Val}, {HvxI32Ty});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="codeline">  Value *Hi = Builder.CreateExtractValue(Parts, {0}, "ext");</td>
    <td class="lineNumber">2048</td>
    <td class="codeline">  Value *Hi = Builder.CreateExtractValue(Parts, {0}, "ext");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="codeline">  Value *Lo = Builder.CreateExtractValue(Parts, {1}, "ext");</td>
    <td class="lineNumber">2049</td>
    <td class="codeline">  Value *Lo = Builder.CreateExtractValue(Parts, {1}, "ext");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="codeline">  return {Lo, Hi};</td>
    <td class="lineNumber">2050</td>
    <td class="codeline">  return {Lo, Hi};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2051</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="codeline"></td>
    <td class="lineNumber">2052</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="codeline">auto HvxIdioms::createAddLong(IRBuilderBase &Builder, ArrayRef<Value *> WordX,</td>
    <td class="lineNumber">2053</td>
    <td class="codeline">auto HvxIdioms::createAddLong(IRBuilderBase &Builder, ArrayRef<Value *> WordX,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="codeline">                              ArrayRef<Value *> WordY) const</td>
    <td class="lineNumber">2054</td>
    <td class="codeline">                              ArrayRef<Value *> WordY) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="codeline">    -> SmallVector<Value *> {</td>
    <td class="lineNumber">2055</td>
    <td class="codeline">    -> SmallVector<Value *> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="codeline">  assert(WordX.size() == WordY.size());</td>
    <td class="lineNumber">2056</td>
    <td class="codeline">  assert(WordX.size() == WordY.size());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="codeline">  unsigned Idx = 0, Length = WordX.size();</td>
    <td class="lineNumber">2057</td>
    <td class="codeline">  unsigned Idx = 0, Length = WordX.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="codeline">  SmallVector<Value *> Sum(Length);</td>
    <td class="lineNumber">2058</td>
    <td class="codeline">  SmallVector<Value *> Sum(Length);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="codeline"></td>
    <td class="lineNumber">2059</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="codeline">  while (Idx != Length) {</td>
    <td class="lineNumber">2060</td>
    <td class="codeline">  while (Idx != Length) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="codeline">    if (HVC.isZero(WordX[Idx]))</td>
    <td class="lineNumber">2061</td>
    <td class="codeline">    if (HVC.isZero(WordX[Idx]))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="codeline">      Sum[Idx] = WordY[Idx];</td>
    <td class="lineNumber">2062</td>
    <td class="codeline">      Sum[Idx] = WordY[Idx];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="codeline">    else if (HVC.isZero(WordY[Idx]))</td>
    <td class="lineNumber">2063</td>
    <td class="codeline">    else if (HVC.isZero(WordY[Idx]))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="codeline">      Sum[Idx] = WordX[Idx];</td>
    <td class="lineNumber">2064</td>
    <td class="codeline">      Sum[Idx] = WordX[Idx];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">2065</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">2066</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="codeline">    ++Idx;</td>
    <td class="lineNumber">2067</td>
    <td class="codeline">    ++Idx;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2068</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="codeline"></td>
    <td class="lineNumber">2069</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="codeline">  Value *Carry = nullptr;</td>
    <td class="lineNumber">2070</td>
    <td class="codeline">  Value *Carry = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="codeline">  for (; Idx != Length; ++Idx) {</td>
    <td class="lineNumber">2071</td>
    <td class="codeline">  for (; Idx != Length; ++Idx) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="codeline">    std::tie(Sum[Idx], Carry) =</td>
    <td class="lineNumber">2072</td>
    <td class="codeline">    std::tie(Sum[Idx], Carry) =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="codeline">        createAddCarry(Builder, WordX[Idx], WordY[Idx], Carry);</td>
    <td class="lineNumber">2073</td>
    <td class="codeline">        createAddCarry(Builder, WordX[Idx], WordY[Idx], Carry);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2074</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="codeline"></td>
    <td class="lineNumber">2075</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="codeline">  // This drops the final carry beyond the highest word.</td>
    <td class="lineNumber">2076</td>
    <td class="codeline">  // This drops the final carry beyond the highest word.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="codeline">  return Sum;</td>
    <td class="lineNumber">2077</td>
    <td class="codeline">  return Sum;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2078</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="codeline"></td>
    <td class="lineNumber">2079</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="codeline">auto HvxIdioms::createMulLong(IRBuilderBase &Builder, ArrayRef<Value *> WordX,</td>
    <td class="lineNumber">2080</td>
    <td class="codeline">auto HvxIdioms::createMulLong(IRBuilderBase &Builder, ArrayRef<Value *> WordX,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="codeline">                              Signedness SgnX, ArrayRef<Value *> WordY,</td>
    <td class="lineNumber">2081</td>
    <td class="codeline">                              Signedness SgnX, ArrayRef<Value *> WordY,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="codeline">                              Signedness SgnY) const -> SmallVector<Value *> {</td>
    <td class="lineNumber">2082</td>
    <td class="codeline">                              Signedness SgnY) const -> SmallVector<Value *> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="codeline">  SmallVector<SmallVector<Value *>> Products(WordX.size() + WordY.size());</td>
    <td class="lineNumber">2083</td>
    <td class="codeline">  SmallVector<SmallVector<Value *>> Products(WordX.size() + WordY.size());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="codeline"></td>
    <td class="lineNumber">2084</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="codeline">  // WordX[i] * WordY[j] produces words i+j and i+j+1 of the results,</td>
    <td class="lineNumber">2085</td>
    <td class="codeline">  // WordX[i] * WordY[j] produces words i+j and i+j+1 of the results,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="codeline">  // that is halves 2(i+j), 2(i+j)+1, 2(i+j)+2, 2(i+j)+3.</td>
    <td class="lineNumber">2086</td>
    <td class="codeline">  // that is halves 2(i+j), 2(i+j)+1, 2(i+j)+2, 2(i+j)+3.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="codeline">  for (int i = 0, e = WordX.size(); i != e; ++i) {</td>
    <td class="lineNumber">2087</td>
    <td class="codeline">  for (int i = 0, e = WordX.size(); i != e; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="codeline">    for (int j = 0, f = WordY.size(); j != f; ++j) {</td>
    <td class="lineNumber">2088</td>
    <td class="codeline">    for (int j = 0, f = WordY.size(); j != f; ++j) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="codeline">      // Check the 4 halves that this multiplication can generate.</td>
    <td class="lineNumber">2089</td>
    <td class="codeline">      // Check the 4 halves that this multiplication can generate.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="codeline">      Signedness SX = (i + 1 == e) ? SgnX : Unsigned;</td>
    <td class="lineNumber">2090</td>
    <td class="codeline">      Signedness SX = (i + 1 == e) ? SgnX : Unsigned;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="codeline">      Signedness SY = (j + 1 == f) ? SgnY : Unsigned;</td>
    <td class="lineNumber">2091</td>
    <td class="codeline">      Signedness SY = (j + 1 == f) ? SgnY : Unsigned;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="codeline">      auto [Lo, Hi] = createMul32(Builder, {WordX[i], SX}, {WordY[j], SY});</td>
    <td class="lineNumber">2092</td>
    <td class="codeline">      auto [Lo, Hi] = createMul32(Builder, {WordX[i], SX}, {WordY[j], SY});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="codeline">      Products[i + j + 0].push_back(Lo);</td>
    <td class="lineNumber">2093</td>
    <td class="codeline">      Products[i + j + 0].push_back(Lo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="codeline">      Products[i + j + 1].push_back(Hi);</td>
    <td class="lineNumber">2094</td>
    <td class="codeline">      Products[i + j + 1].push_back(Hi);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2095</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2096</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="codeline"></td>
    <td class="lineNumber">2097</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="codeline">  Value *Zero = HVC.getNullValue(WordX[0]->getType());</td>
    <td class="lineNumber">2098</td>
    <td class="codeline">  Value *Zero = HVC.getNullValue(WordX[0]->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="codeline"></td>
    <td class="lineNumber">2099</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="codeline">  auto pop_back_or_zero = [Zero](auto &Vector) -> Value * {</td>
    <td class="lineNumber">2100</td>
    <td class="codeline">  auto pop_back_or_zero = [Zero](auto &Vector) -> Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="codeline">    if (Vector.empty())</td>
    <td class="lineNumber">2101</td>
    <td class="codeline">    if (Vector.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="codeline">      return Zero;</td>
    <td class="lineNumber">2102</td>
    <td class="codeline">      return Zero;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="codeline">    auto Last = Vector.back();</td>
    <td class="lineNumber">2103</td>
    <td class="codeline">    auto Last = Vector.back();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="codeline">    Vector.pop_back();</td>
    <td class="lineNumber">2104</td>
    <td class="codeline">    Vector.pop_back();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="codeline">    return Last;</td>
    <td class="lineNumber">2105</td>
    <td class="codeline">    return Last;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">2106</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="codeline"></td>
    <td class="lineNumber">2107</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="codeline">  for (int i = 0, e = Products.size(); i != e; ++i) {</td>
    <td class="lineNumber">2108</td>
    <td class="codeline">  for (int i = 0, e = Products.size(); i != e; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="codeline">    while (Products[i].size() > 1) {</td>
    <td class="lineNumber">2109</td>
    <td class="codeline">    while (Products[i].size() > 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="codeline">      Value *Carry = nullptr; // no carry-in</td>
    <td class="lineNumber">2110</td>
    <td class="codeline">      Value *Carry = nullptr; // no carry-in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="codeline">      for (int j = i; j != e; ++j) {</td>
    <td class="lineNumber">2111</td>
    <td class="codeline">      for (int j = i; j != e; ++j) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="codeline">        auto &ProdJ = Products[j];</td>
    <td class="lineNumber">2112</td>
    <td class="codeline">        auto &ProdJ = Products[j];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="codeline">        auto [Sum, CarryOut] = createAddCarry(Builder, pop_back_or_zero(ProdJ),</td>
    <td class="lineNumber">2113</td>
    <td class="codeline">        auto [Sum, CarryOut] = createAddCarry(Builder, pop_back_or_zero(ProdJ),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="codeline">                                              pop_back_or_zero(ProdJ), Carry);</td>
    <td class="lineNumber">2114</td>
    <td class="codeline">                                              pop_back_or_zero(ProdJ), Carry);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="codeline">        ProdJ.insert(ProdJ.begin(), Sum);</td>
    <td class="lineNumber">2115</td>
    <td class="codeline">        ProdJ.insert(ProdJ.begin(), Sum);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="codeline">        Carry = CarryOut;</td>
    <td class="lineNumber">2116</td>
    <td class="codeline">        Carry = CarryOut;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2117</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2118</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2119</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="codeline"></td>
    <td class="lineNumber">2120</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="codeline">  SmallVector<Value *> WordP;</td>
    <td class="lineNumber">2121</td>
    <td class="codeline">  SmallVector<Value *> WordP;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="codeline">  for (auto &P : Products) {</td>
    <td class="lineNumber">2122</td>
    <td class="codeline">  for (auto &P : Products) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="codeline">    assert(P.size() == 1 && "Should have been added together");</td>
    <td class="lineNumber">2123</td>
    <td class="codeline">    assert(P.size() == 1 && "Should have been added together");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="codeline">    WordP.push_back(P.front());</td>
    <td class="lineNumber">2124</td>
    <td class="codeline">    WordP.push_back(P.front());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2125</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="codeline"></td>
    <td class="lineNumber">2126</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="codeline">  return WordP;</td>
    <td class="lineNumber">2127</td>
    <td class="codeline">  return WordP;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2128</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="codeline"></td>
    <td class="lineNumber">2129</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="codeline">auto HvxIdioms::run() -> bool {</td>
    <td class="lineNumber">2130</td>
    <td class="codeline">auto HvxIdioms::run() -> bool {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="codeline">  bool Changed = false;</td>
    <td class="lineNumber">2131</td>
    <td class="codeline">  bool Changed = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="codeline"></td>
    <td class="lineNumber">2132</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="codeline">  for (BasicBlock &B : HVC.F) {</td>
    <td class="lineNumber">2133</td>
    <td class="codeline">  for (BasicBlock &B : HVC.F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="codeline">    for (auto It = B.rbegin(); It != B.rend(); ++It) {</td>
    <td class="lineNumber">2134</td>
    <td class="codeline">    for (auto It = B.rbegin(); It != B.rend(); ++It) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="codeline">      if (auto Fxm = matchFxpMul(*It)) {</td>
    <td class="lineNumber">2135</td>
    <td class="codeline">      if (auto Fxm = matchFxpMul(*It)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="codeline">        Value *New = processFxpMul(*It, *Fxm);</td>
    <td class="lineNumber">2136</td>
    <td class="codeline">        Value *New = processFxpMul(*It, *Fxm);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="codeline">        // Always report "changed" for now.</td>
    <td class="lineNumber">2137</td>
    <td class="codeline">        // Always report "changed" for now.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="codeline">        Changed = true;</td>
    <td class="lineNumber">2138</td>
    <td class="codeline">        Changed = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="codeline">        if (!New)</td>
    <td class="lineNumber">2139</td>
    <td class="codeline">        if (!New)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">2140</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="codeline">        bool StartOver = !isa<Instruction>(New);</td>
    <td class="lineNumber">2141</td>
    <td class="codeline">        bool StartOver = !isa<Instruction>(New);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="codeline">        It->replaceAllUsesWith(New);</td>
    <td class="lineNumber">2142</td>
    <td class="codeline">        It->replaceAllUsesWith(New);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="codeline">        RecursivelyDeleteTriviallyDeadInstructions(&*It, &HVC.TLI);</td>
    <td class="lineNumber">2143</td>
    <td class="codeline">        RecursivelyDeleteTriviallyDeadInstructions(&*It, &HVC.TLI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="codeline">        It = StartOver ? B.rbegin()</td>
    <td class="lineNumber">2144</td>
    <td class="codeline">        It = StartOver ? B.rbegin()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="codeline">                       : cast<Instruction>(New)->getReverseIterator();</td>
    <td class="lineNumber">2145</td>
    <td class="codeline">                       : cast<Instruction>(New)->getReverseIterator();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="codeline">        Changed = true;</td>
    <td class="lineNumber">2146</td>
    <td class="codeline">        Changed = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2147</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2148</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2149</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="codeline"></td>
    <td class="lineNumber">2150</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="codeline">  return Changed;</td>
    <td class="lineNumber">2151</td>
    <td class="codeline">  return Changed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2152</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="codeline"></td>
    <td class="lineNumber">2153</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="codeline">// --- End HvxIdioms</td>
    <td class="lineNumber">2154</td>
    <td class="codeline">// --- End HvxIdioms</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="codeline"></td>
    <td class="lineNumber">2155</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="codeline">auto HexagonVectorCombine::run() -> bool {</td>
    <td class="lineNumber">2156</td>
    <td class="codeline">auto HexagonVectorCombine::run() -> bool {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="codeline">  if (DumpModule)</td>
    <td class="lineNumber">2157</td>
    <td class="codeline">  if (DumpModule)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="codeline">    dbgs() << "Module before HexagonVectorCombine\n" << *F.getParent();</td>
    <td class="lineNumber">2158</td>
    <td class="codeline">    dbgs() << "Module before HexagonVectorCombine\n" << *F.getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="codeline"></td>
    <td class="lineNumber">2159</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="codeline">  bool Changed = false;</td>
    <td class="lineNumber">2160</td>
    <td class="codeline">  bool Changed = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="codeline">  if (HST.useHVXOps()) {</td>
    <td class="lineNumber">2161</td>
    <td class="codeline">  if (HST.useHVXOps()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="codeline">    if (VAEnabled)</td>
    <td class="lineNumber">2162</td>
    <td class="codeline">    if (VAEnabled)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="codeline">      Changed |= AlignVectors(*this).run();</td>
    <td class="lineNumber">2163</td>
    <td class="codeline">      Changed |= AlignVectors(*this).run();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="codeline">    if (VIEnabled)</td>
    <td class="lineNumber">2164</td>
    <td class="codeline">    if (VIEnabled)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="codeline">      Changed |= HvxIdioms(*this).run();</td>
    <td class="lineNumber">2165</td>
    <td class="codeline">      Changed |= HvxIdioms(*this).run();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2166</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="codeline"></td>
    <td class="lineNumber">2167</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="codeline">  if (DumpModule) {</td>
    <td class="lineNumber">2168</td>
    <td class="codeline">  if (DumpModule) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="codeline">    dbgs() << "Module " << (Changed ? "(modified)" : "(unchanged)")</td>
    <td class="lineNumber">2169</td>
    <td class="codeline">    dbgs() << "Module " << (Changed ? "(modified)" : "(unchanged)")</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="codeline">           << " after HexagonVectorCombine\n"</td>
    <td class="lineNumber">2170</td>
    <td class="codeline">           << " after HexagonVectorCombine\n"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="codeline">           << *F.getParent();</td>
    <td class="lineNumber">2171</td>
    <td class="codeline">           << *F.getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2172</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="codeline">  return Changed;</td>
    <td class="lineNumber">2173</td>
    <td class="codeline">  return Changed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2174</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="codeline"></td>
    <td class="lineNumber">2175</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="codeline">auto HexagonVectorCombine::getIntTy(unsigned Width) const -> IntegerType * {</td>
    <td class="lineNumber">2176</td>
    <td class="codeline">auto HexagonVectorCombine::getIntTy(unsigned Width) const -> IntegerType * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="codeline">  return IntegerType::get(F.getContext(), Width);</td>
    <td class="lineNumber">2177</td>
    <td class="codeline">  return IntegerType::get(F.getContext(), Width);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2178</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="codeline"></td>
    <td class="lineNumber">2179</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="codeline">auto HexagonVectorCombine::getByteTy(int ElemCount) const -> Type * {</td>
    <td class="lineNumber">2180</td>
    <td class="codeline">auto HexagonVectorCombine::getByteTy(int ElemCount) const -> Type * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="codeline">  assert(ElemCount >= 0);</td>
    <td class="lineNumber">2181</td>
    <td class="codeline">  assert(ElemCount >= 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="codeline">  IntegerType *ByteTy = Type::getInt8Ty(F.getContext());</td>
    <td class="lineNumber">2182</td>
    <td class="codeline">  IntegerType *ByteTy = Type::getInt8Ty(F.getContext());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="codeline">  if (ElemCount == 0)</td>
    <td class="lineNumber">2183</td>
    <td class="codeline">  if (ElemCount == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="codeline">    return ByteTy;</td>
    <td class="lineNumber">2184</td>
    <td class="codeline">    return ByteTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="codeline">  return VectorType::get(ByteTy, ElemCount, /*Scalable=*/false);</td>
    <td class="lineNumber">2185</td>
    <td class="codeline">  return VectorType::get(ByteTy, ElemCount, /*Scalable=*/false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2186</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="codeline"></td>
    <td class="lineNumber">2187</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="codeline">auto HexagonVectorCombine::getBoolTy(int ElemCount) const -> Type * {</td>
    <td class="lineNumber">2188</td>
    <td class="codeline">auto HexagonVectorCombine::getBoolTy(int ElemCount) const -> Type * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="codeline">  assert(ElemCount >= 0);</td>
    <td class="lineNumber">2189</td>
    <td class="codeline">  assert(ElemCount >= 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="codeline">  IntegerType *BoolTy = Type::getInt1Ty(F.getContext());</td>
    <td class="lineNumber">2190</td>
    <td class="codeline">  IntegerType *BoolTy = Type::getInt1Ty(F.getContext());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="codeline">  if (ElemCount == 0)</td>
    <td class="lineNumber">2191</td>
    <td class="codeline">  if (ElemCount == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="codeline">    return BoolTy;</td>
    <td class="lineNumber">2192</td>
    <td class="codeline">    return BoolTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="codeline">  return VectorType::get(BoolTy, ElemCount, /*Scalable=*/false);</td>
    <td class="lineNumber">2193</td>
    <td class="codeline">  return VectorType::get(BoolTy, ElemCount, /*Scalable=*/false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2194</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="codeline"></td>
    <td class="lineNumber">2195</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="codeline">auto HexagonVectorCombine::getConstInt(int Val, unsigned Width) const</td>
    <td class="lineNumber">2196</td>
    <td class="codeline">auto HexagonVectorCombine::getConstInt(int Val, unsigned Width) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="codeline">    -> ConstantInt * {</td>
    <td class="lineNumber">2197</td>
    <td class="codeline">    -> ConstantInt * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="codeline">  return ConstantInt::getSigned(getIntTy(Width), Val);</td>
    <td class="lineNumber">2198</td>
    <td class="codeline">  return ConstantInt::getSigned(getIntTy(Width), Val);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2199</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="codeline"></td>
    <td class="lineNumber">2200</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="codeline">auto HexagonVectorCombine::isZero(const Value *Val) const -> bool {</td>
    <td class="lineNumber">2201</td>
    <td class="codeline">auto HexagonVectorCombine::isZero(const Value *Val) const -> bool {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="codeline">  if (auto *C = dyn_cast<Constant>(Val))</td>
    <td class="lineNumber">2202</td>
    <td class="codeline">  if (auto *C = dyn_cast<Constant>(Val))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="codeline">    return C->isZeroValue();</td>
    <td class="lineNumber">2203</td>
    <td class="codeline">    return C->isZeroValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">2204</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2205</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="codeline"></td>
    <td class="lineNumber">2206</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="codeline">auto HexagonVectorCombine::getIntValue(const Value *Val) const</td>
    <td class="lineNumber">2207</td>
    <td class="codeline">auto HexagonVectorCombine::getIntValue(const Value *Val) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="codeline">    -> std::optional<APInt> {</td>
    <td class="lineNumber">2208</td>
    <td class="codeline">    -> std::optional<APInt> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="codeline">  if (auto *CI = dyn_cast<ConstantInt>(Val))</td>
    <td class="lineNumber">2209</td>
    <td class="codeline">  if (auto *CI = dyn_cast<ConstantInt>(Val))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="codeline">    return CI->getValue();</td>
    <td class="lineNumber">2210</td>
    <td class="codeline">    return CI->getValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="codeline">  return std::nullopt;</td>
    <td class="lineNumber">2211</td>
    <td class="codeline">  return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2212</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="codeline"></td>
    <td class="lineNumber">2213</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="codeline">auto HexagonVectorCombine::isUndef(const Value *Val) const -> bool {</td>
    <td class="lineNumber">2214</td>
    <td class="codeline">auto HexagonVectorCombine::isUndef(const Value *Val) const -> bool {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="codeline">  return isa<UndefValue>(Val);</td>
    <td class="lineNumber">2215</td>
    <td class="codeline">  return isa<UndefValue>(Val);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2216</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="codeline"></td>
    <td class="lineNumber">2217</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="codeline">auto HexagonVectorCombine::isTrue(const Value *Val) const -> bool {</td>
    <td class="lineNumber">2218</td>
    <td class="codeline">auto HexagonVectorCombine::isTrue(const Value *Val) const -> bool {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="codeline">  return Val == ConstantInt::getTrue(Val->getType());</td>
    <td class="lineNumber">2219</td>
    <td class="codeline">  return Val == ConstantInt::getTrue(Val->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2220</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="codeline"></td>
    <td class="lineNumber">2221</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="codeline">auto HexagonVectorCombine::isFalse(const Value *Val) const -> bool {</td>
    <td class="lineNumber">2222</td>
    <td class="codeline">auto HexagonVectorCombine::isFalse(const Value *Val) const -> bool {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="codeline">  return isZero(Val);</td>
    <td class="lineNumber">2223</td>
    <td class="codeline">  return isZero(Val);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2224</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="codeline"></td>
    <td class="lineNumber">2225</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="codeline">auto HexagonVectorCombine::getHvxTy(Type *ElemTy, bool Pair) const</td>
    <td class="lineNumber">2226</td>
    <td class="codeline">auto HexagonVectorCombine::getHvxTy(Type *ElemTy, bool Pair) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="codeline">    -> VectorType * {</td>
    <td class="lineNumber">2227</td>
    <td class="codeline">    -> VectorType * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="codeline">  EVT ETy = EVT::getEVT(ElemTy, false);</td>
    <td class="lineNumber">2228</td>
    <td class="codeline">  EVT ETy = EVT::getEVT(ElemTy, false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="codeline">  assert(ETy.isSimple() && "Invalid HVX element type");</td>
    <td class="lineNumber">2229</td>
    <td class="codeline">  assert(ETy.isSimple() && "Invalid HVX element type");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="codeline">  // Do not allow boolean types here: they don't have a fixed length.</td>
    <td class="lineNumber">2230</td>
    <td class="codeline">  // Do not allow boolean types here: they don't have a fixed length.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="codeline">  assert(HST.isHVXElementType(ETy.getSimpleVT(), /*IncludeBool=*/false) &&</td>
    <td class="lineNumber">2231</td>
    <td class="codeline">  assert(HST.isHVXElementType(ETy.getSimpleVT(), /*IncludeBool=*/false) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="codeline">         "Invalid HVX element type");</td>
    <td class="lineNumber">2232</td>
    <td class="codeline">         "Invalid HVX element type");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="codeline">  unsigned HwLen = HST.getVectorLength();</td>
    <td class="lineNumber">2233</td>
    <td class="codeline">  unsigned HwLen = HST.getVectorLength();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="codeline">  unsigned NumElems = (8 * HwLen) / ETy.getSizeInBits();</td>
    <td class="lineNumber">2234</td>
    <td class="codeline">  unsigned NumElems = (8 * HwLen) / ETy.getSizeInBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="codeline">  return VectorType::get(ElemTy, Pair ? 2 * NumElems : NumElems,</td>
    <td class="lineNumber">2235</td>
    <td class="codeline">  return VectorType::get(ElemTy, Pair ? 2 * NumElems : NumElems,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="codeline">                         /*Scalable=*/false);</td>
    <td class="lineNumber">2236</td>
    <td class="codeline">                         /*Scalable=*/false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2237</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="codeline"></td>
    <td class="lineNumber">2238</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="codeline">auto HexagonVectorCombine::getSizeOf(const Value *Val, SizeKind Kind) const</td>
    <td class="lineNumber">2239</td>
    <td class="codeline">auto HexagonVectorCombine::getSizeOf(const Value *Val, SizeKind Kind) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="codeline">    -> int {</td>
    <td class="lineNumber">2240</td>
    <td class="codeline">    -> int {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="codeline">  return getSizeOf(Val->getType(), Kind);</td>
    <td class="lineNumber">2241</td>
    <td class="codeline">  return getSizeOf(Val->getType(), Kind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2242</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="codeline"></td>
    <td class="lineNumber">2243</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="codeline">auto HexagonVectorCombine::getSizeOf(const Type *Ty, SizeKind Kind) const</td>
    <td class="lineNumber">2244</td>
    <td class="codeline">auto HexagonVectorCombine::getSizeOf(const Type *Ty, SizeKind Kind) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="codeline">    -> int {</td>
    <td class="lineNumber">2245</td>
    <td class="codeline">    -> int {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="codeline">  auto *NcTy = const_cast<Type *>(Ty);</td>
    <td class="lineNumber">2246</td>
    <td class="codeline">  auto *NcTy = const_cast<Type *>(Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="codeline">  switch (Kind) {</td>
    <td class="lineNumber">2247</td>
    <td class="codeline">  switch (Kind) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="codeline">  case Store:</td>
    <td class="lineNumber">2248</td>
    <td class="codeline">  case Store:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="codeline">    return DL.getTypeStoreSize(NcTy).getFixedValue();</td>
    <td class="lineNumber">2249</td>
    <td class="codeline">    return DL.getTypeStoreSize(NcTy).getFixedValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="codeline">  case Alloc:</td>
    <td class="lineNumber">2250</td>
    <td class="codeline">  case Alloc:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="codeline">    return DL.getTypeAllocSize(NcTy).getFixedValue();</td>
    <td class="lineNumber">2251</td>
    <td class="codeline">    return DL.getTypeAllocSize(NcTy).getFixedValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2252</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="codeline">  llvm_unreachable("Unhandled SizeKind enum");</td>
    <td class="lineNumber">2253</td>
    <td class="codeline">  llvm_unreachable("Unhandled SizeKind enum");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2254</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="codeline"></td>
    <td class="lineNumber">2255</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="codeline">auto HexagonVectorCombine::getTypeAlignment(Type *Ty) const -> int {</td>
    <td class="lineNumber">2256</td>
    <td class="codeline">auto HexagonVectorCombine::getTypeAlignment(Type *Ty) const -> int {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="codeline">  // The actual type may be shorter than the HVX vector, so determine</td>
    <td class="lineNumber">2257</td>
    <td class="codeline">  // The actual type may be shorter than the HVX vector, so determine</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="codeline">  // the alignment based on subtarget info.</td>
    <td class="lineNumber">2258</td>
    <td class="codeline">  // the alignment based on subtarget info.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="codeline">  if (HST.isTypeForHVX(Ty))</td>
    <td class="lineNumber">2259</td>
    <td class="codeline">  if (HST.isTypeForHVX(Ty))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="codeline">    return HST.getVectorLength();</td>
    <td class="lineNumber">2260</td>
    <td class="codeline">    return HST.getVectorLength();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="codeline">  return DL.getABITypeAlign(Ty).value();</td>
    <td class="lineNumber">2261</td>
    <td class="codeline">  return DL.getABITypeAlign(Ty).value();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2262</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="codeline"></td>
    <td class="lineNumber">2263</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="codeline">auto HexagonVectorCombine::length(Value *Val) const -> size_t {</td>
    <td class="lineNumber">2264</td>
    <td class="codeline">auto HexagonVectorCombine::length(Value *Val) const -> size_t {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="codeline">  return length(Val->getType());</td>
    <td class="lineNumber">2265</td>
    <td class="codeline">  return length(Val->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2266</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="codeline"></td>
    <td class="lineNumber">2267</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="codeline">auto HexagonVectorCombine::length(Type *Ty) const -> size_t {</td>
    <td class="lineNumber">2268</td>
    <td class="codeline">auto HexagonVectorCombine::length(Type *Ty) const -> size_t {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="codeline">  auto *VecTy = dyn_cast<VectorType>(Ty);</td>
    <td class="lineNumber">2269</td>
    <td class="codeline">  auto *VecTy = dyn_cast<VectorType>(Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="codeline">  assert(VecTy && "Must be a vector type");</td>
    <td class="lineNumber">2270</td>
    <td class="codeline">  assert(VecTy && "Must be a vector type");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="codeline">  return VecTy->getElementCount().getFixedValue();</td>
    <td class="lineNumber">2271</td>
    <td class="codeline">  return VecTy->getElementCount().getFixedValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2272</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="codeline"></td>
    <td class="lineNumber">2273</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="codeline">auto HexagonVectorCombine::getNullValue(Type *Ty) const -> Constant * {</td>
    <td class="lineNumber">2274</td>
    <td class="codeline">auto HexagonVectorCombine::getNullValue(Type *Ty) const -> Constant * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="codeline">  assert(Ty->isIntOrIntVectorTy());</td>
    <td class="lineNumber">2275</td>
    <td class="codeline">  assert(Ty->isIntOrIntVectorTy());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="codeline">  auto Zero = ConstantInt::get(Ty->getScalarType(), 0);</td>
    <td class="lineNumber">2276</td>
    <td class="codeline">  auto Zero = ConstantInt::get(Ty->getScalarType(), 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="codeline">  if (auto *VecTy = dyn_cast<VectorType>(Ty))</td>
    <td class="lineNumber">2277</td>
    <td class="codeline">  if (auto *VecTy = dyn_cast<VectorType>(Ty))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="codeline">    return ConstantVector::getSplat(VecTy->getElementCount(), Zero);</td>
    <td class="lineNumber">2278</td>
    <td class="codeline">    return ConstantVector::getSplat(VecTy->getElementCount(), Zero);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="codeline">  return Zero;</td>
    <td class="lineNumber">2279</td>
    <td class="codeline">  return Zero;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2280</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="codeline"></td>
    <td class="lineNumber">2281</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="codeline">auto HexagonVectorCombine::getFullValue(Type *Ty) const -> Constant * {</td>
    <td class="lineNumber">2282</td>
    <td class="codeline">auto HexagonVectorCombine::getFullValue(Type *Ty) const -> Constant * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="codeline">  assert(Ty->isIntOrIntVectorTy());</td>
    <td class="lineNumber">2283</td>
    <td class="codeline">  assert(Ty->isIntOrIntVectorTy());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="codeline">  auto Minus1 = ConstantInt::get(Ty->getScalarType(), -1);</td>
    <td class="lineNumber">2284</td>
    <td class="codeline">  auto Minus1 = ConstantInt::get(Ty->getScalarType(), -1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="codeline">  if (auto *VecTy = dyn_cast<VectorType>(Ty))</td>
    <td class="lineNumber">2285</td>
    <td class="codeline">  if (auto *VecTy = dyn_cast<VectorType>(Ty))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="codeline">    return ConstantVector::getSplat(VecTy->getElementCount(), Minus1);</td>
    <td class="lineNumber">2286</td>
    <td class="codeline">    return ConstantVector::getSplat(VecTy->getElementCount(), Minus1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="codeline">  return Minus1;</td>
    <td class="lineNumber">2287</td>
    <td class="codeline">  return Minus1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2288</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="codeline"></td>
    <td class="lineNumber">2289</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="codeline">auto HexagonVectorCombine::getConstSplat(Type *Ty, int Val) const</td>
    <td class="lineNumber">2290</td>
    <td class="codeline">auto HexagonVectorCombine::getConstSplat(Type *Ty, int Val) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="codeline">    -> Constant * {</td>
    <td class="lineNumber">2291</td>
    <td class="codeline">    -> Constant * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="codeline">  assert(Ty->isVectorTy());</td>
    <td class="lineNumber">2292</td>
    <td class="codeline">  assert(Ty->isVectorTy());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="codeline">  auto VecTy = cast<VectorType>(Ty);</td>
    <td class="lineNumber">2293</td>
    <td class="codeline">  auto VecTy = cast<VectorType>(Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="codeline">  Type *ElemTy = VecTy->getElementType();</td>
    <td class="lineNumber">2294</td>
    <td class="codeline">  Type *ElemTy = VecTy->getElementType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="codeline">  // Add support for floats if needed.</td>
    <td class="lineNumber">2295</td>
    <td class="codeline">  // Add support for floats if needed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="codeline">  auto *Splat = ConstantVector::getSplat(VecTy->getElementCount(),</td>
    <td class="lineNumber">2296</td>
    <td class="codeline">  auto *Splat = ConstantVector::getSplat(VecTy->getElementCount(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="codeline">                                         ConstantInt::get(ElemTy, Val));</td>
    <td class="lineNumber">2297</td>
    <td class="codeline">                                         ConstantInt::get(ElemTy, Val));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="codeline">  return Splat;</td>
    <td class="lineNumber">2298</td>
    <td class="codeline">  return Splat;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2299</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="codeline"></td>
    <td class="lineNumber">2300</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="codeline">auto HexagonVectorCombine::simplify(Value *V) const -> Value * {</td>
    <td class="lineNumber">2301</td>
    <td class="codeline">auto HexagonVectorCombine::simplify(Value *V) const -> Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="codeline">  if (auto *In = dyn_cast<Instruction>(V)) {</td>
    <td class="lineNumber">2302</td>
    <td class="codeline">  if (auto *In = dyn_cast<Instruction>(V)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="codeline">    SimplifyQuery Q(DL, &TLI, &DT, &AC, In);</td>
    <td class="lineNumber">2303</td>
    <td class="codeline">    SimplifyQuery Q(DL, &TLI, &DT, &AC, In);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="codeline">    return simplifyInstruction(In, Q);</td>
    <td class="lineNumber">2304</td>
    <td class="codeline">    return simplifyInstruction(In, Q);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2305</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="codeline">  return nullptr;</td>
    <td class="lineNumber">2306</td>
    <td class="codeline">  return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2307</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="codeline"></td>
    <td class="lineNumber">2308</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="codeline">// Insert bytes [Start..Start+Length) of Src into Dst at byte Where.</td>
    <td class="lineNumber">2309</td>
    <td class="codeline">// Insert bytes [Start..Start+Length) of Src into Dst at byte Where.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="codeline">auto HexagonVectorCombine::insertb(IRBuilderBase &Builder, Value *Dst,</td>
    <td class="lineNumber">2310</td>
    <td class="codeline">auto HexagonVectorCombine::insertb(IRBuilderBase &Builder, Value *Dst,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="codeline">                                   Value *Src, int Start, int Length,</td>
    <td class="lineNumber">2311</td>
    <td class="codeline">                                   Value *Src, int Start, int Length,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="codeline">                                   int Where) const -> Value * {</td>
    <td class="lineNumber">2312</td>
    <td class="codeline">                                   int Where) const -> Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="codeline">  assert(isByteVecTy(Dst->getType()) && isByteVecTy(Src->getType()));</td>
    <td class="lineNumber">2313</td>
    <td class="codeline">  assert(isByteVecTy(Dst->getType()) && isByteVecTy(Src->getType()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="codeline">  int SrcLen = getSizeOf(Src);</td>
    <td class="lineNumber">2314</td>
    <td class="codeline">  int SrcLen = getSizeOf(Src);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="codeline">  int DstLen = getSizeOf(Dst);</td>
    <td class="lineNumber">2315</td>
    <td class="codeline">  int DstLen = getSizeOf(Dst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="codeline">  assert(0 <= Start && Start + Length <= SrcLen);</td>
    <td class="lineNumber">2316</td>
    <td class="codeline">  assert(0 <= Start && Start + Length <= SrcLen);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="codeline">  assert(0 <= Where && Where + Length <= DstLen);</td>
    <td class="lineNumber">2317</td>
    <td class="codeline">  assert(0 <= Where && Where + Length <= DstLen);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="codeline"></td>
    <td class="lineNumber">2318</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="codeline">  int P2Len = PowerOf2Ceil(SrcLen | DstLen);</td>
    <td class="lineNumber">2319</td>
    <td class="codeline">  int P2Len = PowerOf2Ceil(SrcLen | DstLen);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="codeline">  auto *Undef = UndefValue::get(getByteTy());</td>
    <td class="lineNumber">2320</td>
    <td class="codeline">  auto *Undef = UndefValue::get(getByteTy());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="codeline">  Value *P2Src = vresize(Builder, Src, P2Len, Undef);</td>
    <td class="lineNumber">2321</td>
    <td class="codeline">  Value *P2Src = vresize(Builder, Src, P2Len, Undef);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="codeline">  Value *P2Dst = vresize(Builder, Dst, P2Len, Undef);</td>
    <td class="lineNumber">2322</td>
    <td class="codeline">  Value *P2Dst = vresize(Builder, Dst, P2Len, Undef);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="codeline"></td>
    <td class="lineNumber">2323</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="codeline">  SmallVector<int, 256> SMask(P2Len);</td>
    <td class="lineNumber">2324</td>
    <td class="codeline">  SmallVector<int, 256> SMask(P2Len);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="codeline">  for (int i = 0; i != P2Len; ++i) {</td>
    <td class="lineNumber">2325</td>
    <td class="codeline">  for (int i = 0; i != P2Len; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="codeline">    // If i is in [Where, Where+Length), pick Src[Start+(i-Where)].</td>
    <td class="lineNumber">2326</td>
    <td class="codeline">    // If i is in [Where, Where+Length), pick Src[Start+(i-Where)].</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="codeline">    // Otherwise, pick Dst[i];</td>
    <td class="lineNumber">2327</td>
    <td class="codeline">    // Otherwise, pick Dst[i];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="codeline">    SMask[i] =</td>
    <td class="lineNumber">2328</td>
    <td class="codeline">    SMask[i] =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="codeline">        (Where <= i && i < Where + Length) ? P2Len + Start + (i - Where) : i;</td>
    <td class="lineNumber">2329</td>
    <td class="codeline">        (Where <= i && i < Where + Length) ? P2Len + Start + (i - Where) : i;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2330</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="codeline"></td>
    <td class="lineNumber">2331</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="codeline">  Value *P2Insert = Builder.CreateShuffleVector(P2Dst, P2Src, SMask, "shf");</td>
    <td class="lineNumber">2332</td>
    <td class="codeline">  Value *P2Insert = Builder.CreateShuffleVector(P2Dst, P2Src, SMask, "shf");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="codeline">  return vresize(Builder, P2Insert, DstLen, Undef);</td>
    <td class="lineNumber">2333</td>
    <td class="codeline">  return vresize(Builder, P2Insert, DstLen, Undef);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2334</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="codeline"></td>
    <td class="lineNumber">2335</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="codeline">auto HexagonVectorCombine::vlalignb(IRBuilderBase &Builder, Value *Lo,</td>
    <td class="lineNumber">2336</td>
    <td class="codeline">auto HexagonVectorCombine::vlalignb(IRBuilderBase &Builder, Value *Lo,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="codeline">                                    Value *Hi, Value *Amt) const -> Value * {</td>
    <td class="lineNumber">2337</td>
    <td class="codeline">                                    Value *Hi, Value *Amt) const -> Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="codeline">  assert(Lo->getType() == Hi->getType() && "Argument type mismatch");</td>
    <td class="lineNumber">2338</td>
    <td class="codeline">  assert(Lo->getType() == Hi->getType() && "Argument type mismatch");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="codeline">  if (isZero(Amt))</td>
    <td class="lineNumber">2339</td>
    <td class="codeline">  if (isZero(Amt))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="codeline">    return Hi;</td>
    <td class="lineNumber">2340</td>
    <td class="codeline">    return Hi;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="codeline">  int VecLen = getSizeOf(Hi);</td>
    <td class="lineNumber">2341</td>
    <td class="codeline">  int VecLen = getSizeOf(Hi);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="codeline">  if (auto IntAmt = getIntValue(Amt))</td>
    <td class="lineNumber">2342</td>
    <td class="codeline">  if (auto IntAmt = getIntValue(Amt))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="codeline">    return getElementRange(Builder, Lo, Hi, VecLen - IntAmt->getSExtValue(),</td>
    <td class="lineNumber">2343</td>
    <td class="codeline">    return getElementRange(Builder, Lo, Hi, VecLen - IntAmt->getSExtValue(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="codeline">                           VecLen);</td>
    <td class="lineNumber">2344</td>
    <td class="codeline">                           VecLen);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="codeline"></td>
    <td class="lineNumber">2345</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="codeline">  if (HST.isTypeForHVX(Hi->getType())) {</td>
    <td class="lineNumber">2346</td>
    <td class="codeline">  if (HST.isTypeForHVX(Hi->getType())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="codeline">    assert(static_cast<unsigned>(VecLen) == HST.getVectorLength() &&</td>
    <td class="lineNumber">2347</td>
    <td class="codeline">    assert(static_cast<unsigned>(VecLen) == HST.getVectorLength() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="codeline">           "Expecting an exact HVX type");</td>
    <td class="lineNumber">2348</td>
    <td class="codeline">           "Expecting an exact HVX type");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="codeline">    return createHvxIntrinsic(Builder, HST.getIntrinsicId(Hexagon::V6_vlalignb),</td>
    <td class="lineNumber">2349</td>
    <td class="codeline">    return createHvxIntrinsic(Builder, HST.getIntrinsicId(Hexagon::V6_vlalignb),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="codeline">                              Hi->getType(), {Hi, Lo, Amt});</td>
    <td class="lineNumber">2350</td>
    <td class="codeline">                              Hi->getType(), {Hi, Lo, Amt});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2351</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="codeline"></td>
    <td class="lineNumber">2352</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="codeline">  if (VecLen == 4) {</td>
    <td class="lineNumber">2353</td>
    <td class="codeline">  if (VecLen == 4) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="codeline">    Value *Pair = concat(Builder, {Lo, Hi});</td>
    <td class="lineNumber">2354</td>
    <td class="codeline">    Value *Pair = concat(Builder, {Lo, Hi});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="codeline">    Value *Shift =</td>
    <td class="lineNumber">2355</td>
    <td class="codeline">    Value *Shift =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="codeline">        Builder.CreateLShr(Builder.CreateShl(Pair, Amt, "shl"), 32, "lsr");</td>
    <td class="lineNumber">2356</td>
    <td class="codeline">        Builder.CreateLShr(Builder.CreateShl(Pair, Amt, "shl"), 32, "lsr");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="codeline">    Value *Trunc =</td>
    <td class="lineNumber">2357</td>
    <td class="codeline">    Value *Trunc =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="codeline">        Builder.CreateTrunc(Shift, Type::getInt32Ty(F.getContext()), "trn");</td>
    <td class="lineNumber">2358</td>
    <td class="codeline">        Builder.CreateTrunc(Shift, Type::getInt32Ty(F.getContext()), "trn");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="codeline">    return Builder.CreateBitCast(Trunc, Hi->getType(), "cst");</td>
    <td class="lineNumber">2359</td>
    <td class="codeline">    return Builder.CreateBitCast(Trunc, Hi->getType(), "cst");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2360</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="codeline">  if (VecLen == 8) {</td>
    <td class="lineNumber">2361</td>
    <td class="codeline">  if (VecLen == 8) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="codeline">    Value *Sub = Builder.CreateSub(getConstInt(VecLen), Amt, "sub");</td>
    <td class="lineNumber">2362</td>
    <td class="codeline">    Value *Sub = Builder.CreateSub(getConstInt(VecLen), Amt, "sub");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="codeline">    return vralignb(Builder, Lo, Hi, Sub);</td>
    <td class="lineNumber">2363</td>
    <td class="codeline">    return vralignb(Builder, Lo, Hi, Sub);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2364</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="codeline">  llvm_unreachable("Unexpected vector length");</td>
    <td class="lineNumber">2365</td>
    <td class="codeline">  llvm_unreachable("Unexpected vector length");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2366</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="codeline"></td>
    <td class="lineNumber">2367</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="codeline">auto HexagonVectorCombine::vralignb(IRBuilderBase &Builder, Value *Lo,</td>
    <td class="lineNumber">2368</td>
    <td class="codeline">auto HexagonVectorCombine::vralignb(IRBuilderBase &Builder, Value *Lo,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="codeline">                                    Value *Hi, Value *Amt) const -> Value * {</td>
    <td class="lineNumber">2369</td>
    <td class="codeline">                                    Value *Hi, Value *Amt) const -> Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="codeline">  assert(Lo->getType() == Hi->getType() && "Argument type mismatch");</td>
    <td class="lineNumber">2370</td>
    <td class="codeline">  assert(Lo->getType() == Hi->getType() && "Argument type mismatch");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="codeline">  if (isZero(Amt))</td>
    <td class="lineNumber">2371</td>
    <td class="codeline">  if (isZero(Amt))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="codeline">    return Lo;</td>
    <td class="lineNumber">2372</td>
    <td class="codeline">    return Lo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="codeline">  int VecLen = getSizeOf(Lo);</td>
    <td class="lineNumber">2373</td>
    <td class="codeline">  int VecLen = getSizeOf(Lo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="codeline">  if (auto IntAmt = getIntValue(Amt))</td>
    <td class="lineNumber">2374</td>
    <td class="codeline">  if (auto IntAmt = getIntValue(Amt))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="codeline">    return getElementRange(Builder, Lo, Hi, IntAmt->getSExtValue(), VecLen);</td>
    <td class="lineNumber">2375</td>
    <td class="codeline">    return getElementRange(Builder, Lo, Hi, IntAmt->getSExtValue(), VecLen);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="codeline"></td>
    <td class="lineNumber">2376</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="codeline">  if (HST.isTypeForHVX(Lo->getType())) {</td>
    <td class="lineNumber">2377</td>
    <td class="codeline">  if (HST.isTypeForHVX(Lo->getType())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="codeline">    assert(static_cast<unsigned>(VecLen) == HST.getVectorLength() &&</td>
    <td class="lineNumber">2378</td>
    <td class="codeline">    assert(static_cast<unsigned>(VecLen) == HST.getVectorLength() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="codeline">           "Expecting an exact HVX type");</td>
    <td class="lineNumber">2379</td>
    <td class="codeline">           "Expecting an exact HVX type");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="codeline">    return createHvxIntrinsic(Builder, HST.getIntrinsicId(Hexagon::V6_valignb),</td>
    <td class="lineNumber">2380</td>
    <td class="codeline">    return createHvxIntrinsic(Builder, HST.getIntrinsicId(Hexagon::V6_valignb),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="codeline">                              Lo->getType(), {Hi, Lo, Amt});</td>
    <td class="lineNumber">2381</td>
    <td class="codeline">                              Lo->getType(), {Hi, Lo, Amt});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2382</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="codeline"></td>
    <td class="lineNumber">2383</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="codeline">  if (VecLen == 4) {</td>
    <td class="lineNumber">2384</td>
    <td class="codeline">  if (VecLen == 4) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="codeline">    Value *Pair = concat(Builder, {Lo, Hi});</td>
    <td class="lineNumber">2385</td>
    <td class="codeline">    Value *Pair = concat(Builder, {Lo, Hi});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="codeline">    Value *Shift = Builder.CreateLShr(Pair, Amt, "lsr");</td>
    <td class="lineNumber">2386</td>
    <td class="codeline">    Value *Shift = Builder.CreateLShr(Pair, Amt, "lsr");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="codeline">    Value *Trunc =</td>
    <td class="lineNumber">2387</td>
    <td class="codeline">    Value *Trunc =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="codeline">        Builder.CreateTrunc(Shift, Type::getInt32Ty(F.getContext()), "trn");</td>
    <td class="lineNumber">2388</td>
    <td class="codeline">        Builder.CreateTrunc(Shift, Type::getInt32Ty(F.getContext()), "trn");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="codeline">    return Builder.CreateBitCast(Trunc, Lo->getType(), "cst");</td>
    <td class="lineNumber">2389</td>
    <td class="codeline">    return Builder.CreateBitCast(Trunc, Lo->getType(), "cst");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2390</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="codeline">  if (VecLen == 8) {</td>
    <td class="lineNumber">2391</td>
    <td class="codeline">  if (VecLen == 8) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="codeline">    Type *Int64Ty = Type::getInt64Ty(F.getContext());</td>
    <td class="lineNumber">2392</td>
    <td class="codeline">    Type *Int64Ty = Type::getInt64Ty(F.getContext());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="codeline">    Value *Lo64 = Builder.CreateBitCast(Lo, Int64Ty, "cst");</td>
    <td class="lineNumber">2393</td>
    <td class="codeline">    Value *Lo64 = Builder.CreateBitCast(Lo, Int64Ty, "cst");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="codeline">    Value *Hi64 = Builder.CreateBitCast(Hi, Int64Ty, "cst");</td>
    <td class="lineNumber">2394</td>
    <td class="codeline">    Value *Hi64 = Builder.CreateBitCast(Hi, Int64Ty, "cst");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="codeline">    Function *FI = Intrinsic::getDeclaration(F.getParent(),</td>
    <td class="lineNumber">2395</td>
    <td class="codeline">    Function *FI = Intrinsic::getDeclaration(F.getParent(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="codeline">                                             Intrinsic::hexagon_S2_valignrb);</td>
    <td class="lineNumber">2396</td>
    <td class="codeline">                                             Intrinsic::hexagon_S2_valignrb);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="codeline">    Value *Call = Builder.CreateCall(FI, {Hi64, Lo64, Amt}, "cup");</td>
    <td class="lineNumber">2397</td>
    <td class="codeline">    Value *Call = Builder.CreateCall(FI, {Hi64, Lo64, Amt}, "cup");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="codeline">    return Builder.CreateBitCast(Call, Lo->getType(), "cst");</td>
    <td class="lineNumber">2398</td>
    <td class="codeline">    return Builder.CreateBitCast(Call, Lo->getType(), "cst");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2399</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="codeline">  llvm_unreachable("Unexpected vector length");</td>
    <td class="lineNumber">2400</td>
    <td class="codeline">  llvm_unreachable("Unexpected vector length");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2401</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="codeline"></td>
    <td class="lineNumber">2402</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="codeline">// Concatenates a sequence of vectors of the same type.</td>
    <td class="lineNumber">2403</td>
    <td class="codeline">// Concatenates a sequence of vectors of the same type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="codeline">auto HexagonVectorCombine::concat(IRBuilderBase &Builder,</td>
    <td class="lineNumber">2404</td>
    <td class="codeline">auto HexagonVectorCombine::concat(IRBuilderBase &Builder,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="codeline">                                  ArrayRef<Value *> Vecs) const -> Value * {</td>
    <td class="lineNumber">2405</td>
    <td class="codeline">                                  ArrayRef<Value *> Vecs) const -> Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="codeline">  assert(!Vecs.empty());</td>
    <td class="lineNumber">2406</td>
    <td class="codeline">  assert(!Vecs.empty());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="codeline">  SmallVector<int, 256> SMask;</td>
    <td class="lineNumber">2407</td>
    <td class="codeline">  SmallVector<int, 256> SMask;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="codeline">  std::vector<Value *> Work[2];</td>
    <td class="lineNumber">2408</td>
    <td class="codeline">  std::vector<Value *> Work[2];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="codeline">  int ThisW = 0, OtherW = 1;</td>
    <td class="lineNumber">2409</td>
    <td class="codeline">  int ThisW = 0, OtherW = 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="codeline"></td>
    <td class="lineNumber">2410</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="codeline">  Work[ThisW].assign(Vecs.begin(), Vecs.end());</td>
    <td class="lineNumber">2411</td>
    <td class="codeline">  Work[ThisW].assign(Vecs.begin(), Vecs.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="codeline">  while (Work[ThisW].size() > 1) {</td>
    <td class="lineNumber">2412</td>
    <td class="codeline">  while (Work[ThisW].size() > 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="codeline">    auto *Ty = cast<VectorType>(Work[ThisW].front()->getType());</td>
    <td class="lineNumber">2413</td>
    <td class="codeline">    auto *Ty = cast<VectorType>(Work[ThisW].front()->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="codeline">    SMask.resize(length(Ty) * 2);</td>
    <td class="lineNumber">2414</td>
    <td class="codeline">    SMask.resize(length(Ty) * 2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="codeline">    std::iota(SMask.begin(), SMask.end(), 0);</td>
    <td class="lineNumber">2415</td>
    <td class="codeline">    std::iota(SMask.begin(), SMask.end(), 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="codeline"></td>
    <td class="lineNumber">2416</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="codeline">    Work[OtherW].clear();</td>
    <td class="lineNumber">2417</td>
    <td class="codeline">    Work[OtherW].clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="codeline">    if (Work[ThisW].size() % 2 != 0)</td>
    <td class="lineNumber">2418</td>
    <td class="codeline">    if (Work[ThisW].size() % 2 != 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="codeline">      Work[ThisW].push_back(UndefValue::get(Ty));</td>
    <td class="lineNumber">2419</td>
    <td class="codeline">      Work[ThisW].push_back(UndefValue::get(Ty));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="codeline">    for (int i = 0, e = Work[ThisW].size(); i < e; i += 2) {</td>
    <td class="lineNumber">2420</td>
    <td class="codeline">    for (int i = 0, e = Work[ThisW].size(); i < e; i += 2) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="codeline">      Value *Joined = Builder.CreateShuffleVector(</td>
    <td class="lineNumber">2421</td>
    <td class="codeline">      Value *Joined = Builder.CreateShuffleVector(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="codeline">          Work[ThisW][i], Work[ThisW][i + 1], SMask, "shf");</td>
    <td class="lineNumber">2422</td>
    <td class="codeline">          Work[ThisW][i], Work[ThisW][i + 1], SMask, "shf");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="codeline">      Work[OtherW].push_back(Joined);</td>
    <td class="lineNumber">2423</td>
    <td class="codeline">      Work[OtherW].push_back(Joined);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2424</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="codeline">    std::swap(ThisW, OtherW);</td>
    <td class="lineNumber">2425</td>
    <td class="codeline">    std::swap(ThisW, OtherW);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2426</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="codeline"></td>
    <td class="lineNumber">2427</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="codeline">  // Since there may have been some undefs appended to make shuffle operands</td>
    <td class="lineNumber">2428</td>
    <td class="codeline">  // Since there may have been some undefs appended to make shuffle operands</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="codeline">  // have the same type, perform the last shuffle to only pick the original</td>
    <td class="lineNumber">2429</td>
    <td class="codeline">  // have the same type, perform the last shuffle to only pick the original</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="codeline">  // elements.</td>
    <td class="lineNumber">2430</td>
    <td class="codeline">  // elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="codeline">  SMask.resize(Vecs.size() * length(Vecs.front()->getType()));</td>
    <td class="lineNumber">2431</td>
    <td class="codeline">  SMask.resize(Vecs.size() * length(Vecs.front()->getType()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="codeline">  std::iota(SMask.begin(), SMask.end(), 0);</td>
    <td class="lineNumber">2432</td>
    <td class="codeline">  std::iota(SMask.begin(), SMask.end(), 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="codeline">  Value *Total = Work[ThisW].front();</td>
    <td class="lineNumber">2433</td>
    <td class="codeline">  Value *Total = Work[ThisW].front();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="codeline">  return Builder.CreateShuffleVector(Total, SMask, "shf");</td>
    <td class="lineNumber">2434</td>
    <td class="codeline">  return Builder.CreateShuffleVector(Total, SMask, "shf");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2435</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="codeline"></td>
    <td class="lineNumber">2436</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="codeline">auto HexagonVectorCombine::vresize(IRBuilderBase &Builder, Value *Val,</td>
    <td class="lineNumber">2437</td>
    <td class="codeline">auto HexagonVectorCombine::vresize(IRBuilderBase &Builder, Value *Val,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="codeline">                                   int NewSize, Value *Pad) const -> Value * {</td>
    <td class="lineNumber">2438</td>
    <td class="codeline">                                   int NewSize, Value *Pad) const -> Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="codeline">  assert(isa<VectorType>(Val->getType()));</td>
    <td class="lineNumber">2439</td>
    <td class="codeline">  assert(isa<VectorType>(Val->getType()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="codeline">  auto *ValTy = cast<VectorType>(Val->getType());</td>
    <td class="lineNumber">2440</td>
    <td class="codeline">  auto *ValTy = cast<VectorType>(Val->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="codeline">  assert(ValTy->getElementType() == Pad->getType());</td>
    <td class="lineNumber">2441</td>
    <td class="codeline">  assert(ValTy->getElementType() == Pad->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="codeline"></td>
    <td class="lineNumber">2442</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="codeline">  int CurSize = length(ValTy);</td>
    <td class="lineNumber">2443</td>
    <td class="codeline">  int CurSize = length(ValTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="codeline">  if (CurSize == NewSize)</td>
    <td class="lineNumber">2444</td>
    <td class="codeline">  if (CurSize == NewSize)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="codeline">    return Val;</td>
    <td class="lineNumber">2445</td>
    <td class="codeline">    return Val;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="codeline">  // Truncate?</td>
    <td class="lineNumber">2446</td>
    <td class="codeline">  // Truncate?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="codeline">  if (CurSize > NewSize)</td>
    <td class="lineNumber">2447</td>
    <td class="codeline">  if (CurSize > NewSize)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="codeline">    return getElementRange(Builder, Val, /*Ignored*/ Val, 0, NewSize);</td>
    <td class="lineNumber">2448</td>
    <td class="codeline">    return getElementRange(Builder, Val, /*Ignored*/ Val, 0, NewSize);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="codeline">  // Extend.</td>
    <td class="lineNumber">2449</td>
    <td class="codeline">  // Extend.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="codeline">  SmallVector<int, 128> SMask(NewSize);</td>
    <td class="lineNumber">2450</td>
    <td class="codeline">  SmallVector<int, 128> SMask(NewSize);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="codeline">  std::iota(SMask.begin(), SMask.begin() + CurSize, 0);</td>
    <td class="lineNumber">2451</td>
    <td class="codeline">  std::iota(SMask.begin(), SMask.begin() + CurSize, 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="codeline">  std::fill(SMask.begin() + CurSize, SMask.end(), CurSize);</td>
    <td class="lineNumber">2452</td>
    <td class="codeline">  std::fill(SMask.begin() + CurSize, SMask.end(), CurSize);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="codeline">  Value *PadVec = Builder.CreateVectorSplat(CurSize, Pad, "spt");</td>
    <td class="lineNumber">2453</td>
    <td class="codeline">  Value *PadVec = Builder.CreateVectorSplat(CurSize, Pad, "spt");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="codeline">  return Builder.CreateShuffleVector(Val, PadVec, SMask, "shf");</td>
    <td class="lineNumber">2454</td>
    <td class="codeline">  return Builder.CreateShuffleVector(Val, PadVec, SMask, "shf");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2455</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="codeline"></td>
    <td class="lineNumber">2456</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="codeline">auto HexagonVectorCombine::rescale(IRBuilderBase &Builder, Value *Mask,</td>
    <td class="lineNumber">2457</td>
    <td class="codeline">auto HexagonVectorCombine::rescale(IRBuilderBase &Builder, Value *Mask,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="codeline">                                   Type *FromTy, Type *ToTy) const -> Value * {</td>
    <td class="lineNumber">2458</td>
    <td class="codeline">                                   Type *FromTy, Type *ToTy) const -> Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="codeline">  // Mask is a vector <N x i1>, where each element corresponds to an</td>
    <td class="lineNumber">2459</td>
    <td class="codeline">  // Mask is a vector <N x i1>, where each element corresponds to an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="codeline">  // element of FromTy. Remap it so that each element will correspond</td>
    <td class="lineNumber">2460</td>
    <td class="codeline">  // element of FromTy. Remap it so that each element will correspond</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="codeline">  // to an element of ToTy.</td>
    <td class="lineNumber">2461</td>
    <td class="codeline">  // to an element of ToTy.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="codeline">  assert(isa<VectorType>(Mask->getType()));</td>
    <td class="lineNumber">2462</td>
    <td class="codeline">  assert(isa<VectorType>(Mask->getType()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="codeline"></td>
    <td class="lineNumber">2463</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="codeline">  Type *FromSTy = FromTy->getScalarType();</td>
    <td class="lineNumber">2464</td>
    <td class="codeline">  Type *FromSTy = FromTy->getScalarType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="codeline">  Type *ToSTy = ToTy->getScalarType();</td>
    <td class="lineNumber">2465</td>
    <td class="codeline">  Type *ToSTy = ToTy->getScalarType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="codeline">  if (FromSTy == ToSTy)</td>
    <td class="lineNumber">2466</td>
    <td class="codeline">  if (FromSTy == ToSTy)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="codeline">    return Mask;</td>
    <td class="lineNumber">2467</td>
    <td class="codeline">    return Mask;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="codeline"></td>
    <td class="lineNumber">2468</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="codeline">  int FromSize = getSizeOf(FromSTy);</td>
    <td class="lineNumber">2469</td>
    <td class="codeline">  int FromSize = getSizeOf(FromSTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="codeline">  int ToSize = getSizeOf(ToSTy);</td>
    <td class="lineNumber">2470</td>
    <td class="codeline">  int ToSize = getSizeOf(ToSTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="codeline">  assert(FromSize % ToSize == 0 || ToSize % FromSize == 0);</td>
    <td class="lineNumber">2471</td>
    <td class="codeline">  assert(FromSize % ToSize == 0 || ToSize % FromSize == 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class="codeline"></td>
    <td class="lineNumber">2472</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="codeline">  auto *MaskTy = cast<VectorType>(Mask->getType());</td>
    <td class="lineNumber">2473</td>
    <td class="codeline">  auto *MaskTy = cast<VectorType>(Mask->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="codeline">  int FromCount = length(MaskTy);</td>
    <td class="lineNumber">2474</td>
    <td class="codeline">  int FromCount = length(MaskTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2475</td>
    <td class="codeline">  int ToCount = (FromCount * FromSize) / ToSize;</td>
    <td class="lineNumber">2475</td>
    <td class="codeline">  int ToCount = (FromCount * FromSize) / ToSize;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2476</td>
    <td class="codeline">  assert((FromCount * FromSize) % ToSize == 0);</td>
    <td class="lineNumber">2476</td>
    <td class="codeline">  assert((FromCount * FromSize) % ToSize == 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2477</td>
    <td class="codeline"></td>
    <td class="lineNumber">2477</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2478</td>
    <td class="codeline">  auto *FromITy = getIntTy(FromSize * 8);</td>
    <td class="lineNumber">2478</td>
    <td class="codeline">  auto *FromITy = getIntTy(FromSize * 8);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2479</td>
    <td class="codeline">  auto *ToITy = getIntTy(ToSize * 8);</td>
    <td class="lineNumber">2479</td>
    <td class="codeline">  auto *ToITy = getIntTy(ToSize * 8);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2480</td>
    <td class="codeline"></td>
    <td class="lineNumber">2480</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2481</td>
    <td class="codeline">  // Mask <N x i1> -> sext to <N x FromTy> -> bitcast to <M x ToTy> -></td>
    <td class="lineNumber">2481</td>
    <td class="codeline">  // Mask <N x i1> -> sext to <N x FromTy> -> bitcast to <M x ToTy> -></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2482</td>
    <td class="codeline">  // -> trunc to <M x i1>.</td>
    <td class="lineNumber">2482</td>
    <td class="codeline">  // -> trunc to <M x i1>.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2483</td>
    <td class="codeline">  Value *Ext = Builder.CreateSExt(</td>
    <td class="lineNumber">2483</td>
    <td class="codeline">  Value *Ext = Builder.CreateSExt(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2484</td>
    <td class="codeline">      Mask, VectorType::get(FromITy, FromCount, /*Scalable=*/false), "sxt");</td>
    <td class="lineNumber">2484</td>
    <td class="codeline">      Mask, VectorType::get(FromITy, FromCount, /*Scalable=*/false), "sxt");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2485</td>
    <td class="codeline">  Value *Cast = Builder.CreateBitCast(</td>
    <td class="lineNumber">2485</td>
    <td class="codeline">  Value *Cast = Builder.CreateBitCast(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2486</td>
    <td class="codeline">      Ext, VectorType::get(ToITy, ToCount, /*Scalable=*/false), "cst");</td>
    <td class="lineNumber">2486</td>
    <td class="codeline">      Ext, VectorType::get(ToITy, ToCount, /*Scalable=*/false), "cst");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2487</td>
    <td class="codeline">  return Builder.CreateTrunc(</td>
    <td class="lineNumber">2487</td>
    <td class="codeline">  return Builder.CreateTrunc(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2488</td>
    <td class="codeline">      Cast, VectorType::get(getBoolTy(), ToCount, /*Scalable=*/false), "trn");</td>
    <td class="lineNumber">2488</td>
    <td class="codeline">      Cast, VectorType::get(getBoolTy(), ToCount, /*Scalable=*/false), "trn");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2489</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2489</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2490</td>
    <td class="codeline"></td>
    <td class="lineNumber">2490</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2491</td>
    <td class="codeline">// Bitcast to bytes, and return least significant bits.</td>
    <td class="lineNumber">2491</td>
    <td class="codeline">// Bitcast to bytes, and return least significant bits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2492</td>
    <td class="codeline">auto HexagonVectorCombine::vlsb(IRBuilderBase &Builder, Value *Val) const</td>
    <td class="lineNumber">2492</td>
    <td class="codeline">auto HexagonVectorCombine::vlsb(IRBuilderBase &Builder, Value *Val) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2493</td>
    <td class="codeline">    -> Value * {</td>
    <td class="lineNumber">2493</td>
    <td class="codeline">    -> Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2494</td>
    <td class="codeline">  Type *ScalarTy = Val->getType()->getScalarType();</td>
    <td class="lineNumber">2494</td>
    <td class="codeline">  Type *ScalarTy = Val->getType()->getScalarType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2495</td>
    <td class="codeline">  if (ScalarTy == getBoolTy())</td>
    <td class="lineNumber">2495</td>
    <td class="codeline">  if (ScalarTy == getBoolTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2496</td>
    <td class="codeline">    return Val;</td>
    <td class="lineNumber">2496</td>
    <td class="codeline">    return Val;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2497</td>
    <td class="codeline"></td>
    <td class="lineNumber">2497</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2498</td>
    <td class="codeline">  Value *Bytes = vbytes(Builder, Val);</td>
    <td class="lineNumber">2498</td>
    <td class="codeline">  Value *Bytes = vbytes(Builder, Val);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2499</td>
    <td class="codeline">  if (auto *VecTy = dyn_cast<VectorType>(Bytes->getType()))</td>
    <td class="lineNumber">2499</td>
    <td class="codeline">  if (auto *VecTy = dyn_cast<VectorType>(Bytes->getType()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2500</td>
    <td class="codeline">    return Builder.CreateTrunc(Bytes, getBoolTy(getSizeOf(VecTy)), "trn");</td>
    <td class="lineNumber">2500</td>
    <td class="codeline">    return Builder.CreateTrunc(Bytes, getBoolTy(getSizeOf(VecTy)), "trn");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2501</td>
    <td class="codeline">  // If Bytes is a scalar (i.e. Val was a scalar byte), return i1, not</td>
    <td class="lineNumber">2501</td>
    <td class="codeline">  // If Bytes is a scalar (i.e. Val was a scalar byte), return i1, not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2502</td>
    <td class="codeline">  // <1 x i1>.</td>
    <td class="lineNumber">2502</td>
    <td class="codeline">  // <1 x i1>.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2503</td>
    <td class="codeline">  return Builder.CreateTrunc(Bytes, getBoolTy(), "trn");</td>
    <td class="lineNumber">2503</td>
    <td class="codeline">  return Builder.CreateTrunc(Bytes, getBoolTy(), "trn");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2504</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2504</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2505</td>
    <td class="codeline"></td>
    <td class="lineNumber">2505</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2506</td>
    <td class="codeline">// Bitcast to bytes for non-bool. For bool, convert i1 -> i8.</td>
    <td class="lineNumber">2506</td>
    <td class="codeline">// Bitcast to bytes for non-bool. For bool, convert i1 -> i8.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2507</td>
    <td class="codeline">auto HexagonVectorCombine::vbytes(IRBuilderBase &Builder, Value *Val) const</td>
    <td class="lineNumber">2507</td>
    <td class="codeline">auto HexagonVectorCombine::vbytes(IRBuilderBase &Builder, Value *Val) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2508</td>
    <td class="codeline">    -> Value * {</td>
    <td class="lineNumber">2508</td>
    <td class="codeline">    -> Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2509</td>
    <td class="codeline">  Type *ScalarTy = Val->getType()->getScalarType();</td>
    <td class="lineNumber">2509</td>
    <td class="codeline">  Type *ScalarTy = Val->getType()->getScalarType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2510</td>
    <td class="codeline">  if (ScalarTy == getByteTy())</td>
    <td class="lineNumber">2510</td>
    <td class="codeline">  if (ScalarTy == getByteTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2511</td>
    <td class="codeline">    return Val;</td>
    <td class="lineNumber">2511</td>
    <td class="codeline">    return Val;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2512</td>
    <td class="codeline"></td>
    <td class="lineNumber">2512</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2513</td>
    <td class="codeline">  if (ScalarTy != getBoolTy())</td>
    <td class="lineNumber">2513</td>
    <td class="codeline">  if (ScalarTy != getBoolTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2514</td>
    <td class="codeline">    return Builder.CreateBitCast(Val, getByteTy(getSizeOf(Val)), "cst");</td>
    <td class="lineNumber">2514</td>
    <td class="codeline">    return Builder.CreateBitCast(Val, getByteTy(getSizeOf(Val)), "cst");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2515</td>
    <td class="codeline">  // For bool, return a sext from i1 to i8.</td>
    <td class="lineNumber">2515</td>
    <td class="codeline">  // For bool, return a sext from i1 to i8.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2516</td>
    <td class="codeline">  if (auto *VecTy = dyn_cast<VectorType>(Val->getType()))</td>
    <td class="lineNumber">2516</td>
    <td class="codeline">  if (auto *VecTy = dyn_cast<VectorType>(Val->getType()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2517</td>
    <td class="codeline">    return Builder.CreateSExt(Val, VectorType::get(getByteTy(), VecTy), "sxt");</td>
    <td class="lineNumber">2517</td>
    <td class="codeline">    return Builder.CreateSExt(Val, VectorType::get(getByteTy(), VecTy), "sxt");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2518</td>
    <td class="codeline">  return Builder.CreateSExt(Val, getByteTy(), "sxt");</td>
    <td class="lineNumber">2518</td>
    <td class="codeline">  return Builder.CreateSExt(Val, getByteTy(), "sxt");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2519</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2519</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2520</td>
    <td class="codeline"></td>
    <td class="lineNumber">2520</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2521</td>
    <td class="codeline">auto HexagonVectorCombine::subvector(IRBuilderBase &Builder, Value *Val,</td>
    <td class="lineNumber">2521</td>
    <td class="codeline">auto HexagonVectorCombine::subvector(IRBuilderBase &Builder, Value *Val,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2522</td>
    <td class="codeline">                                     unsigned Start, unsigned Length) const</td>
    <td class="lineNumber">2522</td>
    <td class="codeline">                                     unsigned Start, unsigned Length) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2523</td>
    <td class="codeline">    -> Value * {</td>
    <td class="lineNumber">2523</td>
    <td class="codeline">    -> Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2524</td>
    <td class="codeline">  assert(Start + Length <= length(Val));</td>
    <td class="lineNumber">2524</td>
    <td class="codeline">  assert(Start + Length <= length(Val));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2525</td>
    <td class="codeline">  return getElementRange(Builder, Val, /*Ignored*/ Val, Start, Length);</td>
    <td class="lineNumber">2525</td>
    <td class="codeline">  return getElementRange(Builder, Val, /*Ignored*/ Val, Start, Length);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2526</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2526</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2527</td>
    <td class="codeline"></td>
    <td class="lineNumber">2527</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2528</td>
    <td class="codeline">auto HexagonVectorCombine::sublo(IRBuilderBase &Builder, Value *Val) const</td>
    <td class="lineNumber">2528</td>
    <td class="codeline">auto HexagonVectorCombine::sublo(IRBuilderBase &Builder, Value *Val) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2529</td>
    <td class="codeline">    -> Value * {</td>
    <td class="lineNumber">2529</td>
    <td class="codeline">    -> Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2530</td>
    <td class="codeline">  size_t Len = length(Val);</td>
    <td class="lineNumber">2530</td>
    <td class="codeline">  size_t Len = length(Val);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2531</td>
    <td class="codeline">  assert(Len % 2 == 0 && "Length should be even");</td>
    <td class="lineNumber">2531</td>
    <td class="codeline">  assert(Len % 2 == 0 && "Length should be even");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2532</td>
    <td class="codeline">  return subvector(Builder, Val, 0, Len / 2);</td>
    <td class="lineNumber">2532</td>
    <td class="codeline">  return subvector(Builder, Val, 0, Len / 2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2533</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2533</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2534</td>
    <td class="codeline"></td>
    <td class="lineNumber">2534</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2535</td>
    <td class="codeline">auto HexagonVectorCombine::subhi(IRBuilderBase &Builder, Value *Val) const</td>
    <td class="lineNumber">2535</td>
    <td class="codeline">auto HexagonVectorCombine::subhi(IRBuilderBase &Builder, Value *Val) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2536</td>
    <td class="codeline">    -> Value * {</td>
    <td class="lineNumber">2536</td>
    <td class="codeline">    -> Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2537</td>
    <td class="codeline">  size_t Len = length(Val);</td>
    <td class="lineNumber">2537</td>
    <td class="codeline">  size_t Len = length(Val);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2538</td>
    <td class="codeline">  assert(Len % 2 == 0 && "Length should be even");</td>
    <td class="lineNumber">2538</td>
    <td class="codeline">  assert(Len % 2 == 0 && "Length should be even");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2539</td>
    <td class="codeline">  return subvector(Builder, Val, Len / 2, Len / 2);</td>
    <td class="lineNumber">2539</td>
    <td class="codeline">  return subvector(Builder, Val, Len / 2, Len / 2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2540</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2540</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2541</td>
    <td class="codeline"></td>
    <td class="lineNumber">2541</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2542</td>
    <td class="codeline">auto HexagonVectorCombine::vdeal(IRBuilderBase &Builder, Value *Val0,</td>
    <td class="lineNumber">2542</td>
    <td class="codeline">auto HexagonVectorCombine::vdeal(IRBuilderBase &Builder, Value *Val0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2543</td>
    <td class="codeline">                                 Value *Val1) const -> Value * {</td>
    <td class="lineNumber">2543</td>
    <td class="codeline">                                 Value *Val1) const -> Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2544</td>
    <td class="codeline">  assert(Val0->getType() == Val1->getType());</td>
    <td class="lineNumber">2544</td>
    <td class="codeline">  assert(Val0->getType() == Val1->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2545</td>
    <td class="codeline">  int Len = length(Val0);</td>
    <td class="lineNumber">2545</td>
    <td class="codeline">  int Len = length(Val0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2546</td>
    <td class="codeline">  SmallVector<int, 128> Mask(2 * Len);</td>
    <td class="lineNumber">2546</td>
    <td class="codeline">  SmallVector<int, 128> Mask(2 * Len);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2547</td>
    <td class="codeline"></td>
    <td class="lineNumber">2547</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2548</td>
    <td class="codeline">  for (int i = 0; i != Len; ++i) {</td>
    <td class="lineNumber">2548</td>
    <td class="codeline">  for (int i = 0; i != Len; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2549</td>
    <td class="codeline">    Mask[i] = 2 * i;           // Even</td>
    <td class="lineNumber">2549</td>
    <td class="codeline">    Mask[i] = 2 * i;           // Even</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2550</td>
    <td class="codeline">    Mask[i + Len] = 2 * i + 1; // Odd</td>
    <td class="lineNumber">2550</td>
    <td class="codeline">    Mask[i + Len] = 2 * i + 1; // Odd</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2551</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2551</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2552</td>
    <td class="codeline">  return Builder.CreateShuffleVector(Val0, Val1, Mask, "shf");</td>
    <td class="lineNumber">2552</td>
    <td class="codeline">  return Builder.CreateShuffleVector(Val0, Val1, Mask, "shf");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2553</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2553</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2554</td>
    <td class="codeline"></td>
    <td class="lineNumber">2554</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2555</td>
    <td class="codeline">auto HexagonVectorCombine::vshuff(IRBuilderBase &Builder, Value *Val0,</td>
    <td class="lineNumber">2555</td>
    <td class="codeline">auto HexagonVectorCombine::vshuff(IRBuilderBase &Builder, Value *Val0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2556</td>
    <td class="codeline">                                  Value *Val1) const -> Value * { //</td>
    <td class="lineNumber">2556</td>
    <td class="codeline">                                  Value *Val1) const -> Value * { //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2557</td>
    <td class="codeline">  assert(Val0->getType() == Val1->getType());</td>
    <td class="lineNumber">2557</td>
    <td class="codeline">  assert(Val0->getType() == Val1->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2558</td>
    <td class="codeline">  int Len = length(Val0);</td>
    <td class="lineNumber">2558</td>
    <td class="codeline">  int Len = length(Val0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2559</td>
    <td class="codeline">  SmallVector<int, 128> Mask(2 * Len);</td>
    <td class="lineNumber">2559</td>
    <td class="codeline">  SmallVector<int, 128> Mask(2 * Len);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2560</td>
    <td class="codeline"></td>
    <td class="lineNumber">2560</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2561</td>
    <td class="codeline">  for (int i = 0; i != Len; ++i) {</td>
    <td class="lineNumber">2561</td>
    <td class="codeline">  for (int i = 0; i != Len; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2562</td>
    <td class="codeline">    Mask[2 * i + 0] = i;       // Val0</td>
    <td class="lineNumber">2562</td>
    <td class="codeline">    Mask[2 * i + 0] = i;       // Val0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2563</td>
    <td class="codeline">    Mask[2 * i + 1] = i + Len; // Val1</td>
    <td class="lineNumber">2563</td>
    <td class="codeline">    Mask[2 * i + 1] = i + Len; // Val1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2564</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2564</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2565</td>
    <td class="codeline">  return Builder.CreateShuffleVector(Val0, Val1, Mask, "shf");</td>
    <td class="lineNumber">2565</td>
    <td class="codeline">  return Builder.CreateShuffleVector(Val0, Val1, Mask, "shf");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2566</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2566</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2567</td>
    <td class="codeline"></td>
    <td class="lineNumber">2567</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2568</td>
    <td class="codeline">auto HexagonVectorCombine::createHvxIntrinsic(IRBuilderBase &Builder,</td>
    <td class="lineNumber">2568</td>
    <td class="codeline">auto HexagonVectorCombine::createHvxIntrinsic(IRBuilderBase &Builder,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2569</td>
    <td class="codeline">                                              Intrinsic::ID IntID, Type *RetTy,</td>
    <td class="lineNumber">2569</td>
    <td class="codeline">                                              Intrinsic::ID IntID, Type *RetTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2570</td>
    <td class="codeline">                                              ArrayRef<Value *> Args,</td>
    <td class="lineNumber">2570</td>
    <td class="codeline">                                              ArrayRef<Value *> Args,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2571</td>
    <td class="codeline">                                              ArrayRef<Type *> ArgTys,</td>
    <td class="lineNumber">2571</td>
    <td class="codeline">                                              ArrayRef<Type *> ArgTys,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2572</td>
    <td class="codeline">                                              ArrayRef<Value *> MDSources) const</td>
    <td class="lineNumber">2572</td>
    <td class="codeline">                                              ArrayRef<Value *> MDSources) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2573</td>
    <td class="codeline">    -> Value * {</td>
    <td class="lineNumber">2573</td>
    <td class="codeline">    -> Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2574</td>
    <td class="codeline">  auto getCast = [&](IRBuilderBase &Builder, Value *Val,</td>
    <td class="lineNumber">2574</td>
    <td class="codeline">  auto getCast = [&](IRBuilderBase &Builder, Value *Val,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2575</td>
    <td class="codeline">                     Type *DestTy) -> Value * {</td>
    <td class="lineNumber">2575</td>
    <td class="codeline">                     Type *DestTy) -> Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2576</td>
    <td class="codeline">    Type *SrcTy = Val->getType();</td>
    <td class="lineNumber">2576</td>
    <td class="codeline">    Type *SrcTy = Val->getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2577</td>
    <td class="codeline">    if (SrcTy == DestTy)</td>
    <td class="lineNumber">2577</td>
    <td class="codeline">    if (SrcTy == DestTy)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2578</td>
    <td class="codeline">      return Val;</td>
    <td class="lineNumber">2578</td>
    <td class="codeline">      return Val;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2579</td>
    <td class="codeline"></td>
    <td class="lineNumber">2579</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2580</td>
    <td class="codeline">    // Non-HVX type. It should be a scalar, and it should already have</td>
    <td class="lineNumber">2580</td>
    <td class="codeline">    // Non-HVX type. It should be a scalar, and it should already have</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2581</td>
    <td class="codeline">    // a valid type.</td>
    <td class="lineNumber">2581</td>
    <td class="codeline">    // a valid type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2582</td>
    <td class="codeline">    assert(HST.isTypeForHVX(SrcTy, /*IncludeBool=*/true));</td>
    <td class="lineNumber">2582</td>
    <td class="codeline">    assert(HST.isTypeForHVX(SrcTy, /*IncludeBool=*/true));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2583</td>
    <td class="codeline"></td>
    <td class="lineNumber">2583</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2584</td>
    <td class="codeline">    Type *BoolTy = Type::getInt1Ty(F.getContext());</td>
    <td class="lineNumber">2584</td>
    <td class="codeline">    Type *BoolTy = Type::getInt1Ty(F.getContext());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2585</td>
    <td class="codeline">    if (cast<VectorType>(SrcTy)->getElementType() != BoolTy)</td>
    <td class="lineNumber">2585</td>
    <td class="codeline">    if (cast<VectorType>(SrcTy)->getElementType() != BoolTy)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2586</td>
    <td class="codeline">      return Builder.CreateBitCast(Val, DestTy, "cst");</td>
    <td class="lineNumber">2586</td>
    <td class="codeline">      return Builder.CreateBitCast(Val, DestTy, "cst");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2587</td>
    <td class="codeline"></td>
    <td class="lineNumber">2587</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2588</td>
    <td class="codeline">    // Predicate HVX vector.</td>
    <td class="lineNumber">2588</td>
    <td class="codeline">    // Predicate HVX vector.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2589</td>
    <td class="codeline">    unsigned HwLen = HST.getVectorLength();</td>
    <td class="lineNumber">2589</td>
    <td class="codeline">    unsigned HwLen = HST.getVectorLength();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2590</td>
    <td class="codeline">    Intrinsic::ID TC = HwLen == 64 ? Intrinsic::hexagon_V6_pred_typecast</td>
    <td class="lineNumber">2590</td>
    <td class="codeline">    Intrinsic::ID TC = HwLen == 64 ? Intrinsic::hexagon_V6_pred_typecast</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2591</td>
    <td class="codeline">                                   : Intrinsic::hexagon_V6_pred_typecast_128B;</td>
    <td class="lineNumber">2591</td>
    <td class="codeline">                                   : Intrinsic::hexagon_V6_pred_typecast_128B;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2592</td>
    <td class="codeline">    Function *FI =</td>
    <td class="lineNumber">2592</td>
    <td class="codeline">    Function *FI =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2593</td>
    <td class="codeline">        Intrinsic::getDeclaration(F.getParent(), TC, {DestTy, Val->getType()});</td>
    <td class="lineNumber">2593</td>
    <td class="codeline">        Intrinsic::getDeclaration(F.getParent(), TC, {DestTy, Val->getType()});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2594</td>
    <td class="codeline">    return Builder.CreateCall(FI, {Val}, "cup");</td>
    <td class="lineNumber">2594</td>
    <td class="codeline">    return Builder.CreateCall(FI, {Val}, "cup");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2595</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">2595</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2596</td>
    <td class="codeline"></td>
    <td class="lineNumber">2596</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2597</td>
    <td class="codeline">  Function *IntrFn = Intrinsic::getDeclaration(F.getParent(), IntID, ArgTys);</td>
    <td class="lineNumber">2597</td>
    <td class="codeline">  Function *IntrFn = Intrinsic::getDeclaration(F.getParent(), IntID, ArgTys);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2598</td>
    <td class="codeline">  FunctionType *IntrTy = IntrFn->getFunctionType();</td>
    <td class="lineNumber">2598</td>
    <td class="codeline">  FunctionType *IntrTy = IntrFn->getFunctionType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2599</td>
    <td class="codeline"></td>
    <td class="lineNumber">2599</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2600</td>
    <td class="codeline">  SmallVector<Value *, 4> IntrArgs;</td>
    <td class="lineNumber">2600</td>
    <td class="codeline">  SmallVector<Value *, 4> IntrArgs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2601</td>
    <td class="codeline">  for (int i = 0, e = Args.size(); i != e; ++i) {</td>
    <td class="lineNumber">2601</td>
    <td class="codeline">  for (int i = 0, e = Args.size(); i != e; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2602</td>
    <td class="codeline">    Value *A = Args[i];</td>
    <td class="lineNumber">2602</td>
    <td class="codeline">    Value *A = Args[i];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2603</td>
    <td class="codeline">    Type *T = IntrTy->getParamType(i);</td>
    <td class="lineNumber">2603</td>
    <td class="codeline">    Type *T = IntrTy->getParamType(i);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2604</td>
    <td class="codeline">    if (A->getType() != T) {</td>
    <td class="lineNumber">2604</td>
    <td class="codeline">    if (A->getType() != T) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2605</td>
    <td class="codeline">      IntrArgs.push_back(getCast(Builder, A, T));</td>
    <td class="lineNumber">2605</td>
    <td class="codeline">      IntrArgs.push_back(getCast(Builder, A, T));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2606</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">2606</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2607</td>
    <td class="codeline">      IntrArgs.push_back(A);</td>
    <td class="lineNumber">2607</td>
    <td class="codeline">      IntrArgs.push_back(A);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2608</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2608</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2609</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2609</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2610</td>
    <td class="codeline">  StringRef MaybeName = !IntrTy->getReturnType()->isVoidTy() ? "cup" : "";</td>
    <td class="lineNumber">2610</td>
    <td class="codeline">  StringRef MaybeName = !IntrTy->getReturnType()->isVoidTy() ? "cup" : "";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2611</td>
    <td class="codeline">  CallInst *Call = Builder.CreateCall(IntrFn, IntrArgs, MaybeName);</td>
    <td class="lineNumber">2611</td>
    <td class="codeline">  CallInst *Call = Builder.CreateCall(IntrFn, IntrArgs, MaybeName);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2612</td>
    <td class="codeline"></td>
    <td class="lineNumber">2612</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2613</td>
    <td class="codeline">  MemoryEffects ME = Call->getAttributes().getMemoryEffects();</td>
    <td class="lineNumber">2613</td>
    <td class="codeline">  MemoryEffects ME = Call->getAttributes().getMemoryEffects();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2614</td>
    <td class="codeline">  if (!ME.doesNotAccessMemory() && !ME.onlyAccessesInaccessibleMem())</td>
    <td class="lineNumber">2614</td>
    <td class="codeline">  if (!ME.doesNotAccessMemory() && !ME.onlyAccessesInaccessibleMem())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2615</td>
    <td class="codeline">    propagateMetadata(Call, MDSources);</td>
    <td class="lineNumber">2615</td>
    <td class="codeline">    propagateMetadata(Call, MDSources);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2616</td>
    <td class="codeline"></td>
    <td class="lineNumber">2616</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2617</td>
    <td class="codeline">  Type *CallTy = Call->getType();</td>
    <td class="lineNumber">2617</td>
    <td class="codeline">  Type *CallTy = Call->getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2618</td>
    <td class="codeline">  if (RetTy == nullptr || CallTy == RetTy)</td>
    <td class="lineNumber">2618</td>
    <td class="codeline">  if (RetTy == nullptr || CallTy == RetTy)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2619</td>
    <td class="codeline">    return Call;</td>
    <td class="lineNumber">2619</td>
    <td class="codeline">    return Call;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2620</td>
    <td class="codeline">  // Scalar types should have RetTy matching the call return type.</td>
    <td class="lineNumber">2620</td>
    <td class="codeline">  // Scalar types should have RetTy matching the call return type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2621</td>
    <td class="codeline">  assert(HST.isTypeForHVX(CallTy, /*IncludeBool=*/true));</td>
    <td class="lineNumber">2621</td>
    <td class="codeline">  assert(HST.isTypeForHVX(CallTy, /*IncludeBool=*/true));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2622</td>
    <td class="codeline">  return getCast(Builder, Call, RetTy);</td>
    <td class="lineNumber">2622</td>
    <td class="codeline">  return getCast(Builder, Call, RetTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2623</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2623</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2624</td>
    <td class="codeline"></td>
    <td class="lineNumber">2624</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2625</td>
    <td class="codeline">auto HexagonVectorCombine::splitVectorElements(IRBuilderBase &Builder,</td>
    <td class="lineNumber">2625</td>
    <td class="codeline">auto HexagonVectorCombine::splitVectorElements(IRBuilderBase &Builder,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2626</td>
    <td class="codeline">                                               Value *Vec,</td>
    <td class="lineNumber">2626</td>
    <td class="codeline">                                               Value *Vec,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2627</td>
    <td class="codeline">                                               unsigned ToWidth) const</td>
    <td class="lineNumber">2627</td>
    <td class="codeline">                                               unsigned ToWidth) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2628</td>
    <td class="codeline">    -> SmallVector<Value *> {</td>
    <td class="lineNumber">2628</td>
    <td class="codeline">    -> SmallVector<Value *> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2629</td>
    <td class="codeline">  // Break a vector of wide elements into a series of vectors with narrow</td>
    <td class="lineNumber">2629</td>
    <td class="codeline">  // Break a vector of wide elements into a series of vectors with narrow</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2630</td>
    <td class="codeline">  // elements:</td>
    <td class="lineNumber">2630</td>
    <td class="codeline">  // elements:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2631</td>
    <td class="codeline">  //   (...c0:b0:a0, ...c1:b1:a1, ...c2:b2:a2, ...)</td>
    <td class="lineNumber">2631</td>
    <td class="codeline">  //   (...c0:b0:a0, ...c1:b1:a1, ...c2:b2:a2, ...)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2632</td>
    <td class="codeline">  // --></td>
    <td class="lineNumber">2632</td>
    <td class="codeline">  // --></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2633</td>
    <td class="codeline">  //   (a0, a1, a2, ...)    // lowest "ToWidth" bits</td>
    <td class="lineNumber">2633</td>
    <td class="codeline">  //   (a0, a1, a2, ...)    // lowest "ToWidth" bits</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2634</td>
    <td class="codeline">  //   (b0, b1, b2, ...)    // the next lowest...</td>
    <td class="lineNumber">2634</td>
    <td class="codeline">  //   (b0, b1, b2, ...)    // the next lowest...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2635</td>
    <td class="codeline">  //   (c0, c1, c2, ...)    // ...</td>
    <td class="lineNumber">2635</td>
    <td class="codeline">  //   (c0, c1, c2, ...)    // ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2636</td>
    <td class="codeline">  //   ...</td>
    <td class="lineNumber">2636</td>
    <td class="codeline">  //   ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2637</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">2637</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2638</td>
    <td class="codeline">  // The number of elements in each resulting vector is the same as</td>
    <td class="lineNumber">2638</td>
    <td class="codeline">  // The number of elements in each resulting vector is the same as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2639</td>
    <td class="codeline">  // in the original vector.</td>
    <td class="lineNumber">2639</td>
    <td class="codeline">  // in the original vector.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2640</td>
    <td class="codeline"></td>
    <td class="lineNumber">2640</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2641</td>
    <td class="codeline">  auto *VecTy = cast<VectorType>(Vec->getType());</td>
    <td class="lineNumber">2641</td>
    <td class="codeline">  auto *VecTy = cast<VectorType>(Vec->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2642</td>
    <td class="codeline">  assert(VecTy->getElementType()->isIntegerTy());</td>
    <td class="lineNumber">2642</td>
    <td class="codeline">  assert(VecTy->getElementType()->isIntegerTy());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2643</td>
    <td class="codeline">  unsigned FromWidth = VecTy->getScalarSizeInBits();</td>
    <td class="lineNumber">2643</td>
    <td class="codeline">  unsigned FromWidth = VecTy->getScalarSizeInBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2644</td>
    <td class="codeline">  assert(isPowerOf2_32(ToWidth) && isPowerOf2_32(FromWidth));</td>
    <td class="lineNumber">2644</td>
    <td class="codeline">  assert(isPowerOf2_32(ToWidth) && isPowerOf2_32(FromWidth));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2645</td>
    <td class="codeline">  assert(ToWidth <= FromWidth && "Breaking up into wider elements?");</td>
    <td class="lineNumber">2645</td>
    <td class="codeline">  assert(ToWidth <= FromWidth && "Breaking up into wider elements?");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2646</td>
    <td class="codeline">  unsigned NumResults = FromWidth / ToWidth;</td>
    <td class="lineNumber">2646</td>
    <td class="codeline">  unsigned NumResults = FromWidth / ToWidth;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2647</td>
    <td class="codeline"></td>
    <td class="lineNumber">2647</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2648</td>
    <td class="codeline">  SmallVector<Value *> Results(NumResults);</td>
    <td class="lineNumber">2648</td>
    <td class="codeline">  SmallVector<Value *> Results(NumResults);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2649</td>
    <td class="codeline">  Results[0] = Vec;</td>
    <td class="lineNumber">2649</td>
    <td class="codeline">  Results[0] = Vec;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2650</td>
    <td class="codeline">  unsigned Length = length(VecTy);</td>
    <td class="lineNumber">2650</td>
    <td class="codeline">  unsigned Length = length(VecTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2651</td>
    <td class="codeline"></td>
    <td class="lineNumber">2651</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2652</td>
    <td class="codeline">  // Do it by splitting in half, since those operations correspond to deal</td>
    <td class="lineNumber">2652</td>
    <td class="codeline">  // Do it by splitting in half, since those operations correspond to deal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2653</td>
    <td class="codeline">  // instructions.</td>
    <td class="lineNumber">2653</td>
    <td class="codeline">  // instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2654</td>
    <td class="codeline">  auto splitInHalf = [&](unsigned Begin, unsigned End, auto splitFunc) -> void {</td>
    <td class="lineNumber">2654</td>
    <td class="codeline">  auto splitInHalf = [&](unsigned Begin, unsigned End, auto splitFunc) -> void {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2655</td>
    <td class="codeline">    // Take V = Results[Begin], split it in L, H.</td>
    <td class="lineNumber">2655</td>
    <td class="codeline">    // Take V = Results[Begin], split it in L, H.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2656</td>
    <td class="codeline">    // Store Results[Begin] = L, Results[(Begin+End)/2] = H</td>
    <td class="lineNumber">2656</td>
    <td class="codeline">    // Store Results[Begin] = L, Results[(Begin+End)/2] = H</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2657</td>
    <td class="codeline">    // Call itself recursively split(Begin, Half), split(Half+1, End)</td>
    <td class="lineNumber">2657</td>
    <td class="codeline">    // Call itself recursively split(Begin, Half), split(Half+1, End)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2658</td>
    <td class="codeline">    if (Begin + 1 == End)</td>
    <td class="lineNumber">2658</td>
    <td class="codeline">    if (Begin + 1 == End)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2659</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">2659</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2660</td>
    <td class="codeline"></td>
    <td class="lineNumber">2660</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2661</td>
    <td class="codeline">    Value *Val = Results[Begin];</td>
    <td class="lineNumber">2661</td>
    <td class="codeline">    Value *Val = Results[Begin];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2662</td>
    <td class="codeline">    unsigned Width = Val->getType()->getScalarSizeInBits();</td>
    <td class="lineNumber">2662</td>
    <td class="codeline">    unsigned Width = Val->getType()->getScalarSizeInBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2663</td>
    <td class="codeline"></td>
    <td class="lineNumber">2663</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2664</td>
    <td class="codeline">    auto *VTy = VectorType::get(getIntTy(Width / 2), 2 * Length, false);</td>
    <td class="lineNumber">2664</td>
    <td class="codeline">    auto *VTy = VectorType::get(getIntTy(Width / 2), 2 * Length, false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2665</td>
    <td class="codeline">    Value *VVal = Builder.CreateBitCast(Val, VTy, "cst");</td>
    <td class="lineNumber">2665</td>
    <td class="codeline">    Value *VVal = Builder.CreateBitCast(Val, VTy, "cst");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2666</td>
    <td class="codeline"></td>
    <td class="lineNumber">2666</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2667</td>
    <td class="codeline">    Value *Res = vdeal(Builder, sublo(Builder, VVal), subhi(Builder, VVal));</td>
    <td class="lineNumber">2667</td>
    <td class="codeline">    Value *Res = vdeal(Builder, sublo(Builder, VVal), subhi(Builder, VVal));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2668</td>
    <td class="codeline"></td>
    <td class="lineNumber">2668</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2669</td>
    <td class="codeline">    unsigned Half = (Begin + End) / 2;</td>
    <td class="lineNumber">2669</td>
    <td class="codeline">    unsigned Half = (Begin + End) / 2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2670</td>
    <td class="codeline">    Results[Begin] = sublo(Builder, Res);</td>
    <td class="lineNumber">2670</td>
    <td class="codeline">    Results[Begin] = sublo(Builder, Res);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2671</td>
    <td class="codeline">    Results[Half] = subhi(Builder, Res);</td>
    <td class="lineNumber">2671</td>
    <td class="codeline">    Results[Half] = subhi(Builder, Res);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2672</td>
    <td class="codeline"></td>
    <td class="lineNumber">2672</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2673</td>
    <td class="codeline">    splitFunc(Begin, Half, splitFunc);</td>
    <td class="lineNumber">2673</td>
    <td class="codeline">    splitFunc(Begin, Half, splitFunc);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2674</td>
    <td class="codeline">    splitFunc(Half, End, splitFunc);</td>
    <td class="lineNumber">2674</td>
    <td class="codeline">    splitFunc(Half, End, splitFunc);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2675</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">2675</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2676</td>
    <td class="codeline"></td>
    <td class="lineNumber">2676</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2677</td>
    <td class="codeline">  splitInHalf(0, NumResults, splitInHalf);</td>
    <td class="lineNumber">2677</td>
    <td class="codeline">  splitInHalf(0, NumResults, splitInHalf);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2678</td>
    <td class="codeline">  return Results;</td>
    <td class="lineNumber">2678</td>
    <td class="codeline">  return Results;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2679</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2679</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2680</td>
    <td class="codeline"></td>
    <td class="lineNumber">2680</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2681</td>
    <td class="codeline">auto HexagonVectorCombine::joinVectorElements(IRBuilderBase &Builder,</td>
    <td class="lineNumber">2681</td>
    <td class="codeline">auto HexagonVectorCombine::joinVectorElements(IRBuilderBase &Builder,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2682</td>
    <td class="codeline">                                              ArrayRef<Value *> Values,</td>
    <td class="lineNumber">2682</td>
    <td class="codeline">                                              ArrayRef<Value *> Values,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2683</td>
    <td class="codeline">                                              VectorType *ToType) const</td>
    <td class="lineNumber">2683</td>
    <td class="codeline">                                              VectorType *ToType) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2684</td>
    <td class="codeline">    -> Value * {</td>
    <td class="lineNumber">2684</td>
    <td class="codeline">    -> Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2685</td>
    <td class="codeline">  assert(ToType->getElementType()->isIntegerTy());</td>
    <td class="lineNumber">2685</td>
    <td class="codeline">  assert(ToType->getElementType()->isIntegerTy());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2686</td>
    <td class="codeline"></td>
    <td class="lineNumber">2686</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2687</td>
    <td class="codeline">  // If the list of values does not have power-of-2 elements, append copies</td>
    <td class="lineNumber">2687</td>
    <td class="codeline">  // If the list of values does not have power-of-2 elements, append copies</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2688</td>
    <td class="codeline">  // of the sign bit to it, to make the size be 2^n.</td>
    <td class="lineNumber">2688</td>
    <td class="codeline">  // of the sign bit to it, to make the size be 2^n.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2689</td>
    <td class="codeline">  // The reason for this is that the values will be joined in pairs, because</td>
    <td class="lineNumber">2689</td>
    <td class="codeline">  // The reason for this is that the values will be joined in pairs, because</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2690</td>
    <td class="codeline">  // otherwise the shuffles will result in convoluted code. With pairwise</td>
    <td class="lineNumber">2690</td>
    <td class="codeline">  // otherwise the shuffles will result in convoluted code. With pairwise</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2691</td>
    <td class="codeline">  // joins, the shuffles will hopefully be folded into a perfect shuffle.</td>
    <td class="lineNumber">2691</td>
    <td class="codeline">  // joins, the shuffles will hopefully be folded into a perfect shuffle.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2692</td>
    <td class="codeline">  // The output will need to be sign-extended to a type with element width</td>
    <td class="lineNumber">2692</td>
    <td class="codeline">  // The output will need to be sign-extended to a type with element width</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2693</td>
    <td class="codeline">  // being a power-of-2 anyways.</td>
    <td class="lineNumber">2693</td>
    <td class="codeline">  // being a power-of-2 anyways.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2694</td>
    <td class="codeline">  SmallVector<Value *> Inputs(Values.begin(), Values.end());</td>
    <td class="lineNumber">2694</td>
    <td class="codeline">  SmallVector<Value *> Inputs(Values.begin(), Values.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2695</td>
    <td class="codeline"></td>
    <td class="lineNumber">2695</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2696</td>
    <td class="codeline">  unsigned ToWidth = ToType->getScalarSizeInBits();</td>
    <td class="lineNumber">2696</td>
    <td class="codeline">  unsigned ToWidth = ToType->getScalarSizeInBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2697</td>
    <td class="codeline">  unsigned Width = Inputs.front()->getType()->getScalarSizeInBits();</td>
    <td class="lineNumber">2697</td>
    <td class="codeline">  unsigned Width = Inputs.front()->getType()->getScalarSizeInBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2698</td>
    <td class="codeline">  assert(Width <= ToWidth);</td>
    <td class="lineNumber">2698</td>
    <td class="codeline">  assert(Width <= ToWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2699</td>
    <td class="codeline">  assert(isPowerOf2_32(Width) && isPowerOf2_32(ToWidth));</td>
    <td class="lineNumber">2699</td>
    <td class="codeline">  assert(isPowerOf2_32(Width) && isPowerOf2_32(ToWidth));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2700</td>
    <td class="codeline">  unsigned Length = length(Inputs.front()->getType());</td>
    <td class="lineNumber">2700</td>
    <td class="codeline">  unsigned Length = length(Inputs.front()->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2701</td>
    <td class="codeline"></td>
    <td class="lineNumber">2701</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2702</td>
    <td class="codeline">  unsigned NeedInputs = ToWidth / Width;</td>
    <td class="lineNumber">2702</td>
    <td class="codeline">  unsigned NeedInputs = ToWidth / Width;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2703</td>
    <td class="codeline">  if (Inputs.size() != NeedInputs) {</td>
    <td class="lineNumber">2703</td>
    <td class="codeline">  if (Inputs.size() != NeedInputs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2704</td>
    <td class="codeline">    // Having too many inputs is ok: drop the high bits (usual wrap-around).</td>
    <td class="lineNumber">2704</td>
    <td class="codeline">    // Having too many inputs is ok: drop the high bits (usual wrap-around).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2705</td>
    <td class="codeline">    // If there are too few, fill them with the sign bit.</td>
    <td class="lineNumber">2705</td>
    <td class="codeline">    // If there are too few, fill them with the sign bit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2706</td>
    <td class="codeline">    Value *Last = Inputs.back();</td>
    <td class="lineNumber">2706</td>
    <td class="codeline">    Value *Last = Inputs.back();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2707</td>
    <td class="codeline">    Value *Sign = Builder.CreateAShr(</td>
    <td class="lineNumber">2707</td>
    <td class="codeline">    Value *Sign = Builder.CreateAShr(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2708</td>
    <td class="codeline">        Last, getConstSplat(Last->getType(), Width - 1), "asr");</td>
    <td class="lineNumber">2708</td>
    <td class="codeline">        Last, getConstSplat(Last->getType(), Width - 1), "asr");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2709</td>
    <td class="codeline">    Inputs.resize(NeedInputs, Sign);</td>
    <td class="lineNumber">2709</td>
    <td class="codeline">    Inputs.resize(NeedInputs, Sign);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2710</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2710</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2711</td>
    <td class="codeline"></td>
    <td class="lineNumber">2711</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2712</td>
    <td class="codeline">  while (Inputs.size() > 1) {</td>
    <td class="lineNumber">2712</td>
    <td class="codeline">  while (Inputs.size() > 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2713</td>
    <td class="codeline">    Width *= 2;</td>
    <td class="lineNumber">2713</td>
    <td class="codeline">    Width *= 2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2714</td>
    <td class="codeline">    auto *VTy = VectorType::get(getIntTy(Width), Length, false);</td>
    <td class="lineNumber">2714</td>
    <td class="codeline">    auto *VTy = VectorType::get(getIntTy(Width), Length, false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2715</td>
    <td class="codeline">    for (int i = 0, e = Inputs.size(); i < e; i += 2) {</td>
    <td class="lineNumber">2715</td>
    <td class="codeline">    for (int i = 0, e = Inputs.size(); i < e; i += 2) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2716</td>
    <td class="codeline">      Value *Res = vshuff(Builder, Inputs[i], Inputs[i + 1]);</td>
    <td class="lineNumber">2716</td>
    <td class="codeline">      Value *Res = vshuff(Builder, Inputs[i], Inputs[i + 1]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2717</td>
    <td class="codeline">      Inputs[i / 2] = Builder.CreateBitCast(Res, VTy, "cst");</td>
    <td class="lineNumber">2717</td>
    <td class="codeline">      Inputs[i / 2] = Builder.CreateBitCast(Res, VTy, "cst");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2718</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2718</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2719</td>
    <td class="codeline">    Inputs.resize(Inputs.size() / 2);</td>
    <td class="lineNumber">2719</td>
    <td class="codeline">    Inputs.resize(Inputs.size() / 2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2720</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2720</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2721</td>
    <td class="codeline"></td>
    <td class="lineNumber">2721</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2722</td>
    <td class="codeline">  assert(Inputs.front()->getType() == ToType);</td>
    <td class="lineNumber">2722</td>
    <td class="codeline">  assert(Inputs.front()->getType() == ToType);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2723</td>
    <td class="codeline">  return Inputs.front();</td>
    <td class="lineNumber">2723</td>
    <td class="codeline">  return Inputs.front();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2724</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2724</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2725</td>
    <td class="codeline"></td>
    <td class="lineNumber">2725</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2726</td>
    <td class="codeline">auto HexagonVectorCombine::calculatePointerDifference(Value *Ptr0,</td>
    <td class="lineNumber">2726</td>
    <td class="codeline">auto HexagonVectorCombine::calculatePointerDifference(Value *Ptr0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2727</td>
    <td class="codeline">                                                      Value *Ptr1) const</td>
    <td class="lineNumber">2727</td>
    <td class="codeline">                                                      Value *Ptr1) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2728</td>
    <td class="codeline">    -> std::optional<int> {</td>
    <td class="lineNumber">2728</td>
    <td class="codeline">    -> std::optional<int> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2729</td>
    <td class="codeline">  // Try SCEV first.</td>
    <td class="lineNumber">2729</td>
    <td class="codeline">  // Try SCEV first.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2730</td>
    <td class="codeline">  const SCEV *Scev0 = SE.getSCEV(Ptr0);</td>
    <td class="lineNumber">2730</td>
    <td class="codeline">  const SCEV *Scev0 = SE.getSCEV(Ptr0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2731</td>
    <td class="codeline">  const SCEV *Scev1 = SE.getSCEV(Ptr1);</td>
    <td class="lineNumber">2731</td>
    <td class="codeline">  const SCEV *Scev1 = SE.getSCEV(Ptr1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2732</td>
    <td class="codeline">  const SCEV *ScevDiff = SE.getMinusSCEV(Scev0, Scev1);</td>
    <td class="lineNumber">2732</td>
    <td class="codeline">  const SCEV *ScevDiff = SE.getMinusSCEV(Scev0, Scev1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2733</td>
    <td class="codeline">  if (auto *Const = dyn_cast<SCEVConstant>(ScevDiff)) {</td>
    <td class="lineNumber">2733</td>
    <td class="codeline">  if (auto *Const = dyn_cast<SCEVConstant>(ScevDiff)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2734</td>
    <td class="codeline">    APInt V = Const->getAPInt();</td>
    <td class="lineNumber">2734</td>
    <td class="codeline">    APInt V = Const->getAPInt();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2735</td>
    <td class="codeline">    if (V.isSignedIntN(8 * sizeof(int)))</td>
    <td class="lineNumber">2735</td>
    <td class="codeline">    if (V.isSignedIntN(8 * sizeof(int)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2736</td>
    <td class="codeline">      return static_cast<int>(V.getSExtValue());</td>
    <td class="lineNumber">2736</td>
    <td class="codeline">      return static_cast<int>(V.getSExtValue());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2737</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2737</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2738</td>
    <td class="codeline"></td>
    <td class="lineNumber">2738</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2739</td>
    <td class="codeline">  struct Builder : IRBuilder<> {</td>
    <td class="lineNumber">2739</td>
    <td class="codeline">  struct Builder : IRBuilder<> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2740</td>
    <td class="codeline">    Builder(BasicBlock *B) : IRBuilder<>(B->getTerminator()) {}</td>
    <td class="lineNumber">2740</td>
    <td class="codeline">    Builder(BasicBlock *B) : IRBuilder<>(B->getTerminator()) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2741</td>
    <td class="codeline">    ~Builder() {</td>
    <td class="lineNumber">2741</td>
    <td class="codeline">    ~Builder() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2742</td>
    <td class="codeline">      for (Instruction *I : llvm::reverse(ToErase))</td>
    <td class="lineNumber">2742</td>
    <td class="codeline">      for (Instruction *I : llvm::reverse(ToErase))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2743</td>
    <td class="codeline">        I->eraseFromParent();</td>
    <td class="lineNumber">2743</td>
    <td class="codeline">        I->eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2744</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2744</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2745</td>
    <td class="codeline">    SmallVector<Instruction *, 8> ToErase;</td>
    <td class="lineNumber">2745</td>
    <td class="codeline">    SmallVector<Instruction *, 8> ToErase;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2746</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">2746</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2747</td>
    <td class="codeline"></td>
    <td class="lineNumber">2747</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2748</td>
    <td class="codeline">#define CallBuilder(B, F)                                                      \</td>
    <td class="lineNumber">2748</td>
    <td class="codeline">#define CallBuilder(B, F)                                                      \</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2749</td>
    <td class="codeline">  [&](auto &B_) {                                                              \</td>
    <td class="lineNumber">2749</td>
    <td class="codeline">  [&](auto &B_) {                                                              \</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2750</td>
    <td class="codeline">    Value *V = B_.F;                                                           \</td>
    <td class="lineNumber">2750</td>
    <td class="codeline">    Value *V = B_.F;                                                           \</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2751</td>
    <td class="codeline">    if (auto *I = dyn_cast<Instruction>(V))                                    \</td>
    <td class="lineNumber">2751</td>
    <td class="codeline">    if (auto *I = dyn_cast<Instruction>(V))                                    \</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2752</td>
    <td class="codeline">      B_.ToErase.push_back(I);                                                 \</td>
    <td class="lineNumber">2752</td>
    <td class="codeline">      B_.ToErase.push_back(I);                                                 \</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2753</td>
    <td class="codeline">    return V;                                                                  \</td>
    <td class="lineNumber">2753</td>
    <td class="codeline">    return V;                                                                  \</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2754</td>
    <td class="codeline">  }(B)</td>
    <td class="lineNumber">2754</td>
    <td class="codeline">  }(B)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2755</td>
    <td class="codeline"></td>
    <td class="lineNumber">2755</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2756</td>
    <td class="codeline">  auto Simplify = [this](Value *V) {</td>
    <td class="lineNumber">2756</td>
    <td class="codeline">  auto Simplify = [this](Value *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2757</td>
    <td class="codeline">    if (Value *S = simplify(V))</td>
    <td class="lineNumber">2757</td>
    <td class="codeline">    if (Value *S = simplify(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2758</td>
    <td class="codeline">      return S;</td>
    <td class="lineNumber">2758</td>
    <td class="codeline">      return S;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2759</td>
    <td class="codeline">    return V;</td>
    <td class="lineNumber">2759</td>
    <td class="codeline">    return V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2760</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">2760</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2761</td>
    <td class="codeline"></td>
    <td class="lineNumber">2761</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2762</td>
    <td class="codeline">  auto StripBitCast = [](Value *V) {</td>
    <td class="lineNumber">2762</td>
    <td class="codeline">  auto StripBitCast = [](Value *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2763</td>
    <td class="codeline">    while (auto *C = dyn_cast<BitCastInst>(V))</td>
    <td class="lineNumber">2763</td>
    <td class="codeline">    while (auto *C = dyn_cast<BitCastInst>(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2764</td>
    <td class="codeline">      V = C->getOperand(0);</td>
    <td class="lineNumber">2764</td>
    <td class="codeline">      V = C->getOperand(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2765</td>
    <td class="codeline">    return V;</td>
    <td class="lineNumber">2765</td>
    <td class="codeline">    return V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2766</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">2766</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2767</td>
    <td class="codeline"></td>
    <td class="lineNumber">2767</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2768</td>
    <td class="codeline">  Ptr0 = StripBitCast(Ptr0);</td>
    <td class="lineNumber">2768</td>
    <td class="codeline">  Ptr0 = StripBitCast(Ptr0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2769</td>
    <td class="codeline">  Ptr1 = StripBitCast(Ptr1);</td>
    <td class="lineNumber">2769</td>
    <td class="codeline">  Ptr1 = StripBitCast(Ptr1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2770</td>
    <td class="codeline">  if (!isa<GetElementPtrInst>(Ptr0) || !isa<GetElementPtrInst>(Ptr1))</td>
    <td class="lineNumber">2770</td>
    <td class="codeline">  if (!isa<GetElementPtrInst>(Ptr0) || !isa<GetElementPtrInst>(Ptr1))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2771</td>
    <td class="codeline">    return std::nullopt;</td>
    <td class="lineNumber">2771</td>
    <td class="codeline">    return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2772</td>
    <td class="codeline"></td>
    <td class="lineNumber">2772</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2773</td>
    <td class="codeline">  auto *Gep0 = cast<GetElementPtrInst>(Ptr0);</td>
    <td class="lineNumber">2773</td>
    <td class="codeline">  auto *Gep0 = cast<GetElementPtrInst>(Ptr0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2774</td>
    <td class="codeline">  auto *Gep1 = cast<GetElementPtrInst>(Ptr1);</td>
    <td class="lineNumber">2774</td>
    <td class="codeline">  auto *Gep1 = cast<GetElementPtrInst>(Ptr1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2775</td>
    <td class="codeline">  if (Gep0->getPointerOperand() != Gep1->getPointerOperand())</td>
    <td class="lineNumber">2775</td>
    <td class="codeline">  if (Gep0->getPointerOperand() != Gep1->getPointerOperand())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2776</td>
    <td class="codeline">    return std::nullopt;</td>
    <td class="lineNumber">2776</td>
    <td class="codeline">    return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2777</td>
    <td class="codeline">  if (Gep0->getSourceElementType() != Gep1->getSourceElementType())</td>
    <td class="lineNumber">2777</td>
    <td class="codeline">  if (Gep0->getSourceElementType() != Gep1->getSourceElementType())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2778</td>
    <td class="codeline">    return std::nullopt;</td>
    <td class="lineNumber">2778</td>
    <td class="codeline">    return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2779</td>
    <td class="codeline"></td>
    <td class="lineNumber">2779</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2780</td>
    <td class="codeline">  Builder B(Gep0->getParent());</td>
    <td class="lineNumber">2780</td>
    <td class="codeline">  Builder B(Gep0->getParent());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2781</td>
    <td class="codeline">  int Scale = getSizeOf(Gep0->getSourceElementType(), Alloc);</td>
    <td class="lineNumber">2781</td>
    <td class="codeline">  int Scale = getSizeOf(Gep0->getSourceElementType(), Alloc);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2782</td>
    <td class="codeline"></td>
    <td class="lineNumber">2782</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2783</td>
    <td class="codeline">  // FIXME: for now only check GEPs with a single index.</td>
    <td class="lineNumber">2783</td>
    <td class="codeline">  // FIXME: for now only check GEPs with a single index.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2784</td>
    <td class="codeline">  if (Gep0->getNumOperands() != 2 || Gep1->getNumOperands() != 2)</td>
    <td class="lineNumber">2784</td>
    <td class="codeline">  if (Gep0->getNumOperands() != 2 || Gep1->getNumOperands() != 2)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2785</td>
    <td class="codeline">    return std::nullopt;</td>
    <td class="lineNumber">2785</td>
    <td class="codeline">    return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2786</td>
    <td class="codeline"></td>
    <td class="lineNumber">2786</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2787</td>
    <td class="codeline">  Value *Idx0 = Gep0->getOperand(1);</td>
    <td class="lineNumber">2787</td>
    <td class="codeline">  Value *Idx0 = Gep0->getOperand(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2788</td>
    <td class="codeline">  Value *Idx1 = Gep1->getOperand(1);</td>
    <td class="lineNumber">2788</td>
    <td class="codeline">  Value *Idx1 = Gep1->getOperand(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2789</td>
    <td class="codeline"></td>
    <td class="lineNumber">2789</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2790</td>
    <td class="codeline">  // First, try to simplify the subtraction directly.</td>
    <td class="lineNumber">2790</td>
    <td class="codeline">  // First, try to simplify the subtraction directly.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2791</td>
    <td class="codeline">  if (auto *Diff = dyn_cast<ConstantInt>(</td>
    <td class="lineNumber">2791</td>
    <td class="codeline">  if (auto *Diff = dyn_cast<ConstantInt>(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2792</td>
    <td class="codeline">          Simplify(CallBuilder(B, CreateSub(Idx0, Idx1)))))</td>
    <td class="lineNumber">2792</td>
    <td class="codeline">          Simplify(CallBuilder(B, CreateSub(Idx0, Idx1)))))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2793</td>
    <td class="codeline">    return Diff->getSExtValue() * Scale;</td>
    <td class="lineNumber">2793</td>
    <td class="codeline">    return Diff->getSExtValue() * Scale;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2794</td>
    <td class="codeline"></td>
    <td class="lineNumber">2794</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2795</td>
    <td class="codeline">  KnownBits Known0 = getKnownBits(Idx0, Gep0);</td>
    <td class="lineNumber">2795</td>
    <td class="codeline">  KnownBits Known0 = getKnownBits(Idx0, Gep0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2796</td>
    <td class="codeline">  KnownBits Known1 = getKnownBits(Idx1, Gep1);</td>
    <td class="lineNumber">2796</td>
    <td class="codeline">  KnownBits Known1 = getKnownBits(Idx1, Gep1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2797</td>
    <td class="codeline">  APInt Unknown = ~(Known0.Zero | Known0.One) | ~(Known1.Zero | Known1.One);</td>
    <td class="lineNumber">2797</td>
    <td class="codeline">  APInt Unknown = ~(Known0.Zero | Known0.One) | ~(Known1.Zero | Known1.One);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2798</td>
    <td class="codeline">  if (Unknown.isAllOnes())</td>
    <td class="lineNumber">2798</td>
    <td class="codeline">  if (Unknown.isAllOnes())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2799</td>
    <td class="codeline">    return std::nullopt;</td>
    <td class="lineNumber">2799</td>
    <td class="codeline">    return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2800</td>
    <td class="codeline"></td>
    <td class="lineNumber">2800</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2801</td>
    <td class="codeline">  Value *MaskU = ConstantInt::get(Idx0->getType(), Unknown);</td>
    <td class="lineNumber">2801</td>
    <td class="codeline">  Value *MaskU = ConstantInt::get(Idx0->getType(), Unknown);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2802</td>
    <td class="codeline">  Value *AndU0 = Simplify(CallBuilder(B, CreateAnd(Idx0, MaskU)));</td>
    <td class="lineNumber">2802</td>
    <td class="codeline">  Value *AndU0 = Simplify(CallBuilder(B, CreateAnd(Idx0, MaskU)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2803</td>
    <td class="codeline">  Value *AndU1 = Simplify(CallBuilder(B, CreateAnd(Idx1, MaskU)));</td>
    <td class="lineNumber">2803</td>
    <td class="codeline">  Value *AndU1 = Simplify(CallBuilder(B, CreateAnd(Idx1, MaskU)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2804</td>
    <td class="codeline">  Value *SubU = Simplify(CallBuilder(B, CreateSub(AndU0, AndU1)));</td>
    <td class="lineNumber">2804</td>
    <td class="codeline">  Value *SubU = Simplify(CallBuilder(B, CreateSub(AndU0, AndU1)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2805</td>
    <td class="codeline">  int Diff0 = 0;</td>
    <td class="lineNumber">2805</td>
    <td class="codeline">  int Diff0 = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2806</td>
    <td class="codeline">  if (auto *C = dyn_cast<ConstantInt>(SubU)) {</td>
    <td class="lineNumber">2806</td>
    <td class="codeline">  if (auto *C = dyn_cast<ConstantInt>(SubU)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2807</td>
    <td class="codeline">    Diff0 = C->getSExtValue();</td>
    <td class="lineNumber">2807</td>
    <td class="codeline">    Diff0 = C->getSExtValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2808</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">2808</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2809</td>
    <td class="codeline">    return std::nullopt;</td>
    <td class="lineNumber">2809</td>
    <td class="codeline">    return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2810</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2810</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2811</td>
    <td class="codeline"></td>
    <td class="lineNumber">2811</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2812</td>
    <td class="codeline">  Value *MaskK = ConstantInt::get(MaskU->getType(), ~Unknown);</td>
    <td class="lineNumber">2812</td>
    <td class="codeline">  Value *MaskK = ConstantInt::get(MaskU->getType(), ~Unknown);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2813</td>
    <td class="codeline">  Value *AndK0 = Simplify(CallBuilder(B, CreateAnd(Idx0, MaskK)));</td>
    <td class="lineNumber">2813</td>
    <td class="codeline">  Value *AndK0 = Simplify(CallBuilder(B, CreateAnd(Idx0, MaskK)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2814</td>
    <td class="codeline">  Value *AndK1 = Simplify(CallBuilder(B, CreateAnd(Idx1, MaskK)));</td>
    <td class="lineNumber">2814</td>
    <td class="codeline">  Value *AndK1 = Simplify(CallBuilder(B, CreateAnd(Idx1, MaskK)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2815</td>
    <td class="codeline">  Value *SubK = Simplify(CallBuilder(B, CreateSub(AndK0, AndK1)));</td>
    <td class="lineNumber">2815</td>
    <td class="codeline">  Value *SubK = Simplify(CallBuilder(B, CreateSub(AndK0, AndK1)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2816</td>
    <td class="codeline">  int Diff1 = 0;</td>
    <td class="lineNumber">2816</td>
    <td class="codeline">  int Diff1 = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2817</td>
    <td class="codeline">  if (auto *C = dyn_cast<ConstantInt>(SubK)) {</td>
    <td class="lineNumber">2817</td>
    <td class="codeline">  if (auto *C = dyn_cast<ConstantInt>(SubK)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2818</td>
    <td class="codeline">    Diff1 = C->getSExtValue();</td>
    <td class="lineNumber">2818</td>
    <td class="codeline">    Diff1 = C->getSExtValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2819</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">2819</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2820</td>
    <td class="codeline">    return std::nullopt;</td>
    <td class="lineNumber">2820</td>
    <td class="codeline">    return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2821</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2821</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2822</td>
    <td class="codeline"></td>
    <td class="lineNumber">2822</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2823</td>
    <td class="codeline">  return (Diff0 + Diff1) * Scale;</td>
    <td class="lineNumber">2823</td>
    <td class="codeline">  return (Diff0 + Diff1) * Scale;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2824</td>
    <td class="codeline"></td>
    <td class="lineNumber">2824</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2825</td>
    <td class="codeline">#undef CallBuilder</td>
    <td class="lineNumber">2825</td>
    <td class="codeline">#undef CallBuilder</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2826</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2826</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2827</td>
    <td class="codeline"></td>
    <td class="lineNumber">2827</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2828</td>
    <td class="codeline">auto HexagonVectorCombine::getNumSignificantBits(const Value *V,</td>
    <td class="lineNumber">2828</td>
    <td class="codeline">auto HexagonVectorCombine::getNumSignificantBits(const Value *V,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2829</td>
    <td class="codeline">                                                 const Instruction *CtxI) const</td>
    <td class="lineNumber">2829</td>
    <td class="codeline">                                                 const Instruction *CtxI) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2830</td>
    <td class="codeline">    -> unsigned {</td>
    <td class="lineNumber">2830</td>
    <td class="codeline">    -> unsigned {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2831</td>
    <td class="codeline">  return ComputeMaxSignificantBits(V, DL, /*Depth=*/0, &AC, CtxI, &DT);</td>
    <td class="lineNumber">2831</td>
    <td class="codeline">  return ComputeMaxSignificantBits(V, DL, /*Depth=*/0, &AC, CtxI, &DT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2832</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2832</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2833</td>
    <td class="codeline"></td>
    <td class="lineNumber">2833</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2834</td>
    <td class="codeline">auto HexagonVectorCombine::getKnownBits(const Value *V,</td>
    <td class="lineNumber">2834</td>
    <td class="codeline">auto HexagonVectorCombine::getKnownBits(const Value *V,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2835</td>
    <td class="codeline">                                        const Instruction *CtxI) const</td>
    <td class="lineNumber">2835</td>
    <td class="codeline">                                        const Instruction *CtxI) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2836</td>
    <td class="codeline">    -> KnownBits {</td>
    <td class="lineNumber">2836</td>
    <td class="codeline">    -> KnownBits {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2837</td>
    <td class="codeline">  return computeKnownBits(V, DL, /*Depth=*/0, &AC, CtxI, &DT);</td>
    <td class="lineNumber">2837</td>
    <td class="codeline">  return computeKnownBits(V, DL, /*Depth=*/0, &AC, CtxI, &DT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2838</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2838</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2839</td>
    <td class="codeline"></td>
    <td class="lineNumber">2839</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2840</td>
    <td class="codeline">auto HexagonVectorCombine::isSafeToClone(const Instruction &In) const -> bool {</td>
    <td class="lineNumber">2840</td>
    <td class="codeline">auto HexagonVectorCombine::isSafeToClone(const Instruction &In) const -> bool {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2841</td>
    <td class="codeline">  if (In.mayHaveSideEffects() || In.isAtomic() || In.isVolatile() ||</td>
    <td class="lineNumber">2841</td>
    <td class="codeline">  if (In.mayHaveSideEffects() || In.isAtomic() || In.isVolatile() ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2842</td>
    <td class="codeline">      In.isFenceLike() || In.mayReadOrWriteMemory()) {</td>
    <td class="lineNumber">2842</td>
    <td class="codeline">      In.isFenceLike() || In.mayReadOrWriteMemory()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2843</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2843</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2844</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2844</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2845</td>
    <td class="codeline">  if (isa<CallBase>(In) || isa<AllocaInst>(In))</td>
    <td class="lineNumber">2845</td>
    <td class="codeline">  if (isa<CallBase>(In) || isa<AllocaInst>(In))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2846</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2846</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2847</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">2847</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2848</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2848</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2849</td>
    <td class="codeline"></td>
    <td class="lineNumber">2849</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2850</td>
    <td class="codeline">template <typename T></td>
    <td class="lineNumber">2850</td>
    <td class="codeline">template <typename T></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2851</td>
    <td class="codeline">auto HexagonVectorCombine::isSafeToMoveBeforeInBB(const Instruction &In,</td>
    <td class="lineNumber">2851</td>
    <td class="codeline">auto HexagonVectorCombine::isSafeToMoveBeforeInBB(const Instruction &In,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2852</td>
    <td class="codeline">                                                  BasicBlock::const_iterator To,</td>
    <td class="lineNumber">2852</td>
    <td class="codeline">                                                  BasicBlock::const_iterator To,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2853</td>
    <td class="codeline">                                                  const T &IgnoreInsts) const</td>
    <td class="lineNumber">2853</td>
    <td class="codeline">                                                  const T &IgnoreInsts) const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2854</td>
    <td class="codeline">    -> bool {</td>
    <td class="lineNumber">2854</td>
    <td class="codeline">    -> bool {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2855</td>
    <td class="codeline">  auto getLocOrNone =</td>
    <td class="lineNumber">2855</td>
    <td class="codeline">  auto getLocOrNone =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2856</td>
    <td class="codeline">      [this](const Instruction &I) -> std::optional<MemoryLocation> {</td>
    <td class="lineNumber">2856</td>
    <td class="codeline">      [this](const Instruction &I) -> std::optional<MemoryLocation> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2857</td>
    <td class="codeline">    if (const auto *II = dyn_cast<IntrinsicInst>(&I)) {</td>
    <td class="lineNumber">2857</td>
    <td class="codeline">    if (const auto *II = dyn_cast<IntrinsicInst>(&I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2858</td>
    <td class="codeline">      switch (II->getIntrinsicID()) {</td>
    <td class="lineNumber">2858</td>
    <td class="codeline">      switch (II->getIntrinsicID()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2859</td>
    <td class="codeline">      case Intrinsic::masked_load:</td>
    <td class="lineNumber">2859</td>
    <td class="codeline">      case Intrinsic::masked_load:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2860</td>
    <td class="codeline">        return MemoryLocation::getForArgument(II, 0, TLI);</td>
    <td class="lineNumber">2860</td>
    <td class="codeline">        return MemoryLocation::getForArgument(II, 0, TLI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2861</td>
    <td class="codeline">      case Intrinsic::masked_store:</td>
    <td class="lineNumber">2861</td>
    <td class="codeline">      case Intrinsic::masked_store:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2862</td>
    <td class="codeline">        return MemoryLocation::getForArgument(II, 1, TLI);</td>
    <td class="lineNumber">2862</td>
    <td class="codeline">        return MemoryLocation::getForArgument(II, 1, TLI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2863</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2863</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2864</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2864</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2865</td>
    <td class="codeline">    return MemoryLocation::getOrNone(&I);</td>
    <td class="lineNumber">2865</td>
    <td class="codeline">    return MemoryLocation::getOrNone(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2866</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">2866</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2867</td>
    <td class="codeline"></td>
    <td class="lineNumber">2867</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2868</td>
    <td class="codeline">  // The source and the destination must be in the same basic block.</td>
    <td class="lineNumber">2868</td>
    <td class="codeline">  // The source and the destination must be in the same basic block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2869</td>
    <td class="codeline">  const BasicBlock &Block = *In.getParent();</td>
    <td class="lineNumber">2869</td>
    <td class="codeline">  const BasicBlock &Block = *In.getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2870</td>
    <td class="codeline">  assert(Block.begin() == To || Block.end() == To || To->getParent() == &Block);</td>
    <td class="lineNumber">2870</td>
    <td class="codeline">  assert(Block.begin() == To || Block.end() == To || To->getParent() == &Block);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2871</td>
    <td class="codeline">  // No PHIs.</td>
    <td class="lineNumber">2871</td>
    <td class="codeline">  // No PHIs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2872</td>
    <td class="codeline">  if (isa<PHINode>(In) || (To != Block.end() && isa<PHINode>(*To)))</td>
    <td class="lineNumber">2872</td>
    <td class="codeline">  if (isa<PHINode>(In) || (To != Block.end() && isa<PHINode>(*To)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2873</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2873</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2874</td>
    <td class="codeline"></td>
    <td class="lineNumber">2874</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2875</td>
    <td class="codeline">  if (!mayHaveNonDefUseDependency(In))</td>
    <td class="lineNumber">2875</td>
    <td class="codeline">  if (!mayHaveNonDefUseDependency(In))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2876</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">2876</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2877</td>
    <td class="codeline">  bool MayWrite = In.mayWriteToMemory();</td>
    <td class="lineNumber">2877</td>
    <td class="codeline">  bool MayWrite = In.mayWriteToMemory();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2878</td>
    <td class="codeline">  auto MaybeLoc = getLocOrNone(In);</td>
    <td class="lineNumber">2878</td>
    <td class="codeline">  auto MaybeLoc = getLocOrNone(In);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2879</td>
    <td class="codeline"></td>
    <td class="lineNumber">2879</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2880</td>
    <td class="codeline">  auto From = In.getIterator();</td>
    <td class="lineNumber">2880</td>
    <td class="codeline">  auto From = In.getIterator();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2881</td>
    <td class="codeline">  if (From == To)</td>
    <td class="lineNumber">2881</td>
    <td class="codeline">  if (From == To)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2882</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">2882</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2883</td>
    <td class="codeline">  bool MoveUp = (To != Block.end() && To->comesBefore(&In));</td>
    <td class="lineNumber">2883</td>
    <td class="codeline">  bool MoveUp = (To != Block.end() && To->comesBefore(&In));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2884</td>
    <td class="codeline">  auto Range =</td>
    <td class="lineNumber">2884</td>
    <td class="codeline">  auto Range =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2885</td>
    <td class="codeline">      MoveUp ? std::make_pair(To, From) : std::make_pair(std::next(From), To);</td>
    <td class="lineNumber">2885</td>
    <td class="codeline">      MoveUp ? std::make_pair(To, From) : std::make_pair(std::next(From), To);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2886</td>
    <td class="codeline">  for (auto It = Range.first; It != Range.second; ++It) {</td>
    <td class="lineNumber">2886</td>
    <td class="codeline">  for (auto It = Range.first; It != Range.second; ++It) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2887</td>
    <td class="codeline">    const Instruction &I = *It;</td>
    <td class="lineNumber">2887</td>
    <td class="codeline">    const Instruction &I = *It;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2888</td>
    <td class="codeline">    if (llvm::is_contained(IgnoreInsts, &I))</td>
    <td class="lineNumber">2888</td>
    <td class="codeline">    if (llvm::is_contained(IgnoreInsts, &I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2889</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">2889</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2890</td>
    <td class="codeline">    // assume intrinsic can be ignored</td>
    <td class="lineNumber">2890</td>
    <td class="codeline">    // assume intrinsic can be ignored</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2891</td>
    <td class="codeline">    if (auto *II = dyn_cast<IntrinsicInst>(&I)) {</td>
    <td class="lineNumber">2891</td>
    <td class="codeline">    if (auto *II = dyn_cast<IntrinsicInst>(&I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2892</td>
    <td class="codeline">      if (II->getIntrinsicID() == Intrinsic::assume)</td>
    <td class="lineNumber">2892</td>
    <td class="codeline">      if (II->getIntrinsicID() == Intrinsic::assume)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2893</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">2893</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2894</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2894</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2895</td>
    <td class="codeline">    // Parts based on isSafeToMoveBefore from CoveMoverUtils.cpp.</td>
    <td class="lineNumber">2895</td>
    <td class="codeline">    // Parts based on isSafeToMoveBefore from CoveMoverUtils.cpp.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2896</td>
    <td class="codeline">    if (I.mayThrow())</td>
    <td class="lineNumber">2896</td>
    <td class="codeline">    if (I.mayThrow())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2897</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">2897</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2898</td>
    <td class="codeline">    if (auto *CB = dyn_cast<CallBase>(&I)) {</td>
    <td class="lineNumber">2898</td>
    <td class="codeline">    if (auto *CB = dyn_cast<CallBase>(&I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2899</td>
    <td class="codeline">      if (!CB->hasFnAttr(Attribute::WillReturn))</td>
    <td class="lineNumber">2899</td>
    <td class="codeline">      if (!CB->hasFnAttr(Attribute::WillReturn))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2900</td>
    <td class="codeline">        return false;</td>
    <td class="lineNumber">2900</td>
    <td class="codeline">        return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2901</td>
    <td class="codeline">      if (!CB->hasFnAttr(Attribute::NoSync))</td>
    <td class="lineNumber">2901</td>
    <td class="codeline">      if (!CB->hasFnAttr(Attribute::NoSync))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2902</td>
    <td class="codeline">        return false;</td>
    <td class="lineNumber">2902</td>
    <td class="codeline">        return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2903</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2903</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2904</td>
    <td class="codeline">    if (I.mayReadOrWriteMemory()) {</td>
    <td class="lineNumber">2904</td>
    <td class="codeline">    if (I.mayReadOrWriteMemory()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2905</td>
    <td class="codeline">      auto MaybeLocI = getLocOrNone(I);</td>
    <td class="lineNumber">2905</td>
    <td class="codeline">      auto MaybeLocI = getLocOrNone(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2906</td>
    <td class="codeline">      if (MayWrite || I.mayWriteToMemory()) {</td>
    <td class="lineNumber">2906</td>
    <td class="codeline">      if (MayWrite || I.mayWriteToMemory()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2907</td>
    <td class="codeline">        if (!MaybeLoc || !MaybeLocI)</td>
    <td class="lineNumber">2907</td>
    <td class="codeline">        if (!MaybeLoc || !MaybeLocI)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2908</td>
    <td class="codeline">          return false;</td>
    <td class="lineNumber">2908</td>
    <td class="codeline">          return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2909</td>
    <td class="codeline">        if (!AA.isNoAlias(*MaybeLoc, *MaybeLocI))</td>
    <td class="lineNumber">2909</td>
    <td class="codeline">        if (!AA.isNoAlias(*MaybeLoc, *MaybeLocI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2910</td>
    <td class="codeline">          return false;</td>
    <td class="lineNumber">2910</td>
    <td class="codeline">          return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2911</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2911</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2912</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2912</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2913</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2913</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2914</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">2914</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2915</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2915</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2916</td>
    <td class="codeline"></td>
    <td class="lineNumber">2916</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2917</td>
    <td class="codeline">auto HexagonVectorCombine::isByteVecTy(Type *Ty) const -> bool {</td>
    <td class="lineNumber">2917</td>
    <td class="codeline">auto HexagonVectorCombine::isByteVecTy(Type *Ty) const -> bool {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2918</td>
    <td class="codeline">  if (auto *VecTy = dyn_cast<VectorType>(Ty))</td>
    <td class="lineNumber">2918</td>
    <td class="codeline">  if (auto *VecTy = dyn_cast<VectorType>(Ty))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2919</td>
    <td class="codeline">    return VecTy->getElementType() == getByteTy();</td>
    <td class="lineNumber">2919</td>
    <td class="codeline">    return VecTy->getElementType() == getByteTy();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2920</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">2920</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2921</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2921</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2922</td>
    <td class="codeline"></td>
    <td class="lineNumber">2922</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2923</td>
    <td class="codeline">auto HexagonVectorCombine::getElementRange(IRBuilderBase &Builder, Value *Lo,</td>
    <td class="lineNumber">2923</td>
    <td class="codeline">auto HexagonVectorCombine::getElementRange(IRBuilderBase &Builder, Value *Lo,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2924</td>
    <td class="codeline">                                           Value *Hi, int Start,</td>
    <td class="lineNumber">2924</td>
    <td class="codeline">                                           Value *Hi, int Start,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2925</td>
    <td class="codeline">                                           int Length) const -> Value * {</td>
    <td class="lineNumber">2925</td>
    <td class="codeline">                                           int Length) const -> Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2926</td>
    <td class="codeline">  assert(0 <= Start && size_t(Start + Length) < length(Lo) + length(Hi));</td>
    <td class="lineNumber">2926</td>
    <td class="codeline">  assert(0 <= Start && size_t(Start + Length) < length(Lo) + length(Hi));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2927</td>
    <td class="codeline">  SmallVector<int, 128> SMask(Length);</td>
    <td class="lineNumber">2927</td>
    <td class="codeline">  SmallVector<int, 128> SMask(Length);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2928</td>
    <td class="codeline">  std::iota(SMask.begin(), SMask.end(), Start);</td>
    <td class="lineNumber">2928</td>
    <td class="codeline">  std::iota(SMask.begin(), SMask.end(), Start);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2929</td>
    <td class="codeline">  return Builder.CreateShuffleVector(Lo, Hi, SMask, "shf");</td>
    <td class="lineNumber">2929</td>
    <td class="codeline">  return Builder.CreateShuffleVector(Lo, Hi, SMask, "shf");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2930</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2930</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2931</td>
    <td class="codeline"></td>
    <td class="lineNumber">2931</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2932</td>
    <td class="codeline">// Pass management.</td>
    <td class="lineNumber">2932</td>
    <td class="codeline">// Pass management.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2933</td>
    <td class="codeline"></td>
    <td class="lineNumber">2933</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2934</td>
    <td class="codeline">namespace llvm {</td>
    <td class="lineNumber">2934</td>
    <td class="codeline">namespace llvm {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2935</td>
    <td class="codeline">void initializeHexagonVectorCombineLegacyPass(PassRegistry &);</td>
    <td class="lineNumber">2935</td>
    <td class="codeline">void initializeHexagonVectorCombineLegacyPass(PassRegistry &);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2936</td>
    <td class="codeline">FunctionPass *createHexagonVectorCombineLegacyPass();</td>
    <td class="lineNumber">2936</td>
    <td class="codeline">FunctionPass *createHexagonVectorCombineLegacyPass();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2937</td>
    <td class="codeline">} // namespace llvm</td>
    <td class="lineNumber">2937</td>
    <td class="codeline">} // namespace llvm</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2938</td>
    <td class="codeline"></td>
    <td class="lineNumber">2938</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2939</td>
    <td class="codeline">namespace {</td>
    <td class="lineNumber">2939</td>
    <td class="codeline">namespace {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2940</td>
    <td class="codeline">class HexagonVectorCombineLegacy : public FunctionPass {</td>
    <td class="lineNumber">2940</td>
    <td class="codeline">class HexagonVectorCombineLegacy : public FunctionPass {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2941</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">2941</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2942</td>
    <td class="codeline">  static char ID;</td>
    <td class="lineNumber">2942</td>
    <td class="codeline">  static char ID;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2943</td>
    <td class="codeline"></td>
    <td class="lineNumber">2943</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2944</td>
    <td class="codeline">  HexagonVectorCombineLegacy() : FunctionPass(ID) {}</td>
    <td class="lineNumber">2944</td>
    <td class="codeline">  HexagonVectorCombineLegacy() : FunctionPass(ID) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2945</td>
    <td class="codeline"></td>
    <td class="lineNumber">2945</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2946</td>
    <td class="codeline">  StringRef getPassName() const override { return "Hexagon Vector Combine"; }</td>
    <td class="lineNumber">2946</td>
    <td class="codeline">  StringRef getPassName() const override { return "Hexagon Vector Combine"; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2947</td>
    <td class="codeline"></td>
    <td class="lineNumber">2947</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2948</td>
    <td class="codeline">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td class="lineNumber">2948</td>
    <td class="codeline">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2949</td>
    <td class="codeline">    AU.setPreservesCFG();</td>
    <td class="lineNumber">2949</td>
    <td class="codeline">    AU.setPreservesCFG();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2950</td>
    <td class="codeline">    AU.addRequired<AAResultsWrapperPass>();</td>
    <td class="lineNumber">2950</td>
    <td class="codeline">    AU.addRequired<AAResultsWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2951</td>
    <td class="codeline">    AU.addRequired<AssumptionCacheTracker>();</td>
    <td class="lineNumber">2951</td>
    <td class="codeline">    AU.addRequired<AssumptionCacheTracker>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2952</td>
    <td class="codeline">    AU.addRequired<DominatorTreeWrapperPass>();</td>
    <td class="lineNumber">2952</td>
    <td class="codeline">    AU.addRequired<DominatorTreeWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2953</td>
    <td class="codeline">    AU.addRequired<ScalarEvolutionWrapperPass>();</td>
    <td class="lineNumber">2953</td>
    <td class="codeline">    AU.addRequired<ScalarEvolutionWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2954</td>
    <td class="codeline">    AU.addRequired<TargetLibraryInfoWrapperPass>();</td>
    <td class="lineNumber">2954</td>
    <td class="codeline">    AU.addRequired<TargetLibraryInfoWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2955</td>
    <td class="codeline">    AU.addRequired<TargetPassConfig>();</td>
    <td class="lineNumber">2955</td>
    <td class="codeline">    AU.addRequired<TargetPassConfig>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2956</td>
    <td class="codeline">    FunctionPass::getAnalysisUsage(AU);</td>
    <td class="lineNumber">2956</td>
    <td class="codeline">    FunctionPass::getAnalysisUsage(AU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2957</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2957</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2958</td>
    <td class="codeline"></td>
    <td class="lineNumber">2958</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2959</td>
    <td class="codeline">  bool runOnFunction(Function &F) override {</td>
    <td class="lineNumber">2959</td>
    <td class="codeline">  bool runOnFunction(Function &F) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2960</td>
    <td class="codeline">    if (skipFunction(F))</td>
    <td class="lineNumber">2960</td>
    <td class="codeline">    if (skipFunction(F))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2961</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">2961</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2962</td>
    <td class="codeline">    AliasAnalysis &AA = getAnalysis<AAResultsWrapperPass>().getAAResults();</td>
    <td class="lineNumber">2962</td>
    <td class="codeline">    AliasAnalysis &AA = getAnalysis<AAResultsWrapperPass>().getAAResults();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2963</td>
    <td class="codeline">    AssumptionCache &AC =</td>
    <td class="lineNumber">2963</td>
    <td class="codeline">    AssumptionCache &AC =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2964</td>
    <td class="codeline">        getAnalysis<AssumptionCacheTracker>().getAssumptionCache(F);</td>
    <td class="lineNumber">2964</td>
    <td class="codeline">        getAnalysis<AssumptionCacheTracker>().getAssumptionCache(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2965</td>
    <td class="codeline">    DominatorTree &DT = getAnalysis<DominatorTreeWrapperPass>().getDomTree();</td>
    <td class="lineNumber">2965</td>
    <td class="codeline">    DominatorTree &DT = getAnalysis<DominatorTreeWrapperPass>().getDomTree();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2966</td>
    <td class="codeline">    ScalarEvolution &SE = getAnalysis<ScalarEvolutionWrapperPass>().getSE();</td>
    <td class="lineNumber">2966</td>
    <td class="codeline">    ScalarEvolution &SE = getAnalysis<ScalarEvolutionWrapperPass>().getSE();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2967</td>
    <td class="codeline">    TargetLibraryInfo &TLI =</td>
    <td class="lineNumber">2967</td>
    <td class="codeline">    TargetLibraryInfo &TLI =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2968</td>
    <td class="codeline">        getAnalysis<TargetLibraryInfoWrapperPass>().getTLI(F);</td>
    <td class="lineNumber">2968</td>
    <td class="codeline">        getAnalysis<TargetLibraryInfoWrapperPass>().getTLI(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2969</td>
    <td class="codeline">    auto &TM = getAnalysis<TargetPassConfig>().getTM<HexagonTargetMachine>();</td>
    <td class="lineNumber">2969</td>
    <td class="codeline">    auto &TM = getAnalysis<TargetPassConfig>().getTM<HexagonTargetMachine>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2970</td>
    <td class="codeline">    HexagonVectorCombine HVC(F, AA, AC, DT, SE, TLI, TM);</td>
    <td class="lineNumber">2970</td>
    <td class="codeline">    HexagonVectorCombine HVC(F, AA, AC, DT, SE, TLI, TM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2971</td>
    <td class="codeline">    return HVC.run();</td>
    <td class="lineNumber">2971</td>
    <td class="codeline">    return HVC.run();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2972</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2972</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2973</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2973</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2974</td>
    <td class="codeline">} // namespace</td>
    <td class="lineNumber">2974</td>
    <td class="codeline">} // namespace</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2975</td>
    <td class="codeline"></td>
    <td class="lineNumber">2975</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2976</td>
    <td class="codeline">char HexagonVectorCombineLegacy::ID = 0;</td>
    <td class="lineNumber">2976</td>
    <td class="codeline">char HexagonVectorCombineLegacy::ID = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2977</td>
    <td class="codeline"></td>
    <td class="lineNumber">2977</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2978</td>
    <td class="codeline">INITIALIZE_PASS_BEGIN(HexagonVectorCombineLegacy, DEBUG_TYPE,</td>
    <td class="lineNumber">2978</td>
    <td class="codeline">INITIALIZE_PASS_BEGIN(HexagonVectorCombineLegacy, DEBUG_TYPE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2979</td>
    <td class="codeline">                      "Hexagon Vector Combine", false, false)</td>
    <td class="lineNumber">2979</td>
    <td class="codeline">                      "Hexagon Vector Combine", false, false)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2980</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(AAResultsWrapperPass)</td>
    <td class="lineNumber">2980</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(AAResultsWrapperPass)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2981</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(AssumptionCacheTracker)</td>
    <td class="lineNumber">2981</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(AssumptionCacheTracker)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2982</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
    <td class="lineNumber">2982</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2983</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(ScalarEvolutionWrapperPass)</td>
    <td class="lineNumber">2983</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(ScalarEvolutionWrapperPass)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2984</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(TargetLibraryInfoWrapperPass)</td>
    <td class="lineNumber">2984</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(TargetLibraryInfoWrapperPass)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2985</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(TargetPassConfig)</td>
    <td class="lineNumber">2985</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(TargetPassConfig)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2986</td>
    <td class="codeline">INITIALIZE_PASS_END(HexagonVectorCombineLegacy, DEBUG_TYPE,</td>
    <td class="lineNumber">2986</td>
    <td class="codeline">INITIALIZE_PASS_END(HexagonVectorCombineLegacy, DEBUG_TYPE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2987</td>
    <td class="codeline">                    "Hexagon Vector Combine", false, false)</td>
    <td class="lineNumber">2987</td>
    <td class="codeline">                    "Hexagon Vector Combine", false, false)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2988</td>
    <td class="codeline"></td>
    <td class="lineNumber">2988</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2989</td>
    <td class="codeline">FunctionPass *llvm::createHexagonVectorCombineLegacyPass() {</td>
    <td class="lineNumber">2989</td>
    <td class="codeline">FunctionPass *llvm::createHexagonVectorCombineLegacyPass() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2990</td>
    <td class="codeline">  return new HexagonVectorCombineLegacy();</td>
    <td class="lineNumber">2990</td>
    <td class="codeline">  return new HexagonVectorCombineLegacy();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2991</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2991</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2992</td>
    <td class="codeline"></td>
    <td class="lineNumber">2992</td>
    <td class="codeline"></td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Side By Side Comparison</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Side By Side Comparison</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeLine">//===-- HexagonVectorCombine.cpp ------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1</td>
    <td class="codeLine">//===-- HexagonVectorCombine.cpp ------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeLine">// HexagonVectorCombine is a utility class implementing a variety of functions</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">8</td>
    <td class="codeLine">// HexagonVectorCombine is a utility class implementing a variety of functions</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeLine">// that assist in vector-based optimizations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">9</td>
    <td class="codeLine">// that assist in vector-based optimizations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">10</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeLine">// AlignVectors: replace unaligned vector loads and stores with aligned ones.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">11</td>
    <td class="codeLine">// AlignVectors: replace unaligned vector loads and stores with aligned ones.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeLine">// HvxIdioms: recognize various opportunities to generate HVX intrinsic code.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">12</td>
    <td class="codeLine">// HvxIdioms: recognize various opportunities to generate HVX intrinsic code.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">13</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">14</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeLine">#include "llvm/ADT/APInt.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">15</td>
    <td class="codeLine">#include "llvm/ADT/APInt.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeLine">#include "llvm/ADT/ArrayRef.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">16</td>
    <td class="codeLine">#include "llvm/ADT/ArrayRef.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeLine">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">17</td>
    <td class="codeLine">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeLine">#include "llvm/ADT/STLExtras.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">18</td>
    <td class="codeLine">#include "llvm/ADT/STLExtras.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeLine">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">19</td>
    <td class="codeLine">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeLine">#include "llvm/Analysis/AliasAnalysis.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">20</td>
    <td class="codeLine">#include "llvm/Analysis/AliasAnalysis.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeLine">#include "llvm/Analysis/AssumptionCache.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">21</td>
    <td class="codeLine">#include "llvm/Analysis/AssumptionCache.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "llvm/Analysis/InstSimplifyFolder.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "llvm/Analysis/InstSimplifyFolder.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/Analysis/InstructionSimplify.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/Analysis/InstructionSimplify.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/Analysis/ScalarEvolution.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/Analysis/ScalarEvolution.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/Analysis/TargetLibraryInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/Analysis/TargetLibraryInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/Analysis/ValueTracking.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/Analysis/ValueTracking.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeLine">#include "llvm/Analysis/VectorUtils.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">27</td>
    <td class="codeLine">#include "llvm/Analysis/VectorUtils.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetPassConfig.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">28</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetPassConfig.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeLine">#include "llvm/CodeGen/ValueTypes.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">29</td>
    <td class="codeLine">#include "llvm/CodeGen/ValueTypes.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeLine">#include "llvm/IR/Dominators.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">30</td>
    <td class="codeLine">#include "llvm/IR/Dominators.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeLine">#include "llvm/IR/IRBuilder.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">31</td>
    <td class="codeLine">#include "llvm/IR/IRBuilder.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeLine">#include "llvm/IR/IntrinsicInst.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">32</td>
    <td class="codeLine">#include "llvm/IR/IntrinsicInst.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeLine">#include "llvm/IR/Intrinsics.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">33</td>
    <td class="codeLine">#include "llvm/IR/Intrinsics.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeLine">#include "llvm/IR/IntrinsicsHexagon.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">34</td>
    <td class="codeLine">#include "llvm/IR/IntrinsicsHexagon.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeLine">#include "llvm/IR/Metadata.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">35</td>
    <td class="codeLine">#include "llvm/IR/Metadata.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeLine">#include "llvm/IR/PatternMatch.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">36</td>
    <td class="codeLine">#include "llvm/IR/PatternMatch.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeLine">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">37</td>
    <td class="codeLine">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeLine">#include "llvm/Pass.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">38</td>
    <td class="codeLine">#include "llvm/Pass.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeLine">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">39</td>
    <td class="codeLine">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeLine">#include "llvm/Support/KnownBits.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">40</td>
    <td class="codeLine">#include "llvm/Support/KnownBits.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeLine">#include "llvm/Support/MathExtras.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">41</td>
    <td class="codeLine">#include "llvm/Support/MathExtras.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeLine">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">42</td>
    <td class="codeLine">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeLine">#include "llvm/Target/TargetMachine.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">43</td>
    <td class="codeLine">#include "llvm/Target/TargetMachine.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/Local.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">44</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/Local.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">45</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeLine">#include "HexagonSubtarget.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">46</td>
    <td class="codeLine">#include "HexagonSubtarget.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeLine">#include "HexagonTargetMachine.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">47</td>
    <td class="codeLine">#include "HexagonTargetMachine.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">48</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeLine">#include <algorithm></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">49</td>
    <td class="codeLine">#include <algorithm></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeLine">#include <deque></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">50</td>
    <td class="codeLine">#include <deque></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeLine">#include <map></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">51</td>
    <td class="codeLine">#include <map></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeLine">#include <optional></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">52</td>
    <td class="codeLine">#include <optional></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeLine">#include <set></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">53</td>
    <td class="codeLine">#include <set></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeLine">#include <utility></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">54</td>
    <td class="codeLine">#include <utility></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeLine">#include <vector></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">55</td>
    <td class="codeLine">#include <vector></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">56</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeLine">#define DEBUG_TYPE "hexagon-vc"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">57</td>
    <td class="codeLine">#define DEBUG_TYPE "hexagon-vc"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">58</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">59</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">60</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">61</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeLine">cl::opt<bool> DumpModule("hvc-dump-module", cl::Hidden);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">62</td>
    <td class="codeLine">cl::opt<bool> DumpModule("hvc-dump-module", cl::Hidden);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeLine">cl::opt<bool> VAEnabled("hvc-va", cl::Hidden, cl::init(true)); // Align</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">63</td>
    <td class="codeLine">cl::opt<bool> VAEnabled("hvc-va", cl::Hidden, cl::init(true)); // Align</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeLine">cl::opt<bool> VIEnabled("hvc-vi", cl::Hidden, cl::init(true)); // Idioms</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">64</td>
    <td class="codeLine">cl::opt<bool> VIEnabled("hvc-vi", cl::Hidden, cl::init(true)); // Idioms</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeLine">cl::opt<bool> VADoFullStores("hvc-va-full-stores", cl::Hidden);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">65</td>
    <td class="codeLine">cl::opt<bool> VADoFullStores("hvc-va-full-stores", cl::Hidden);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">66</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeLine">cl::opt<unsigned> VAGroupCountLimit("hvc-va-group-count-limit", cl::Hidden,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">67</td>
    <td class="codeLine">cl::opt<unsigned> VAGroupCountLimit("hvc-va-group-count-limit", cl::Hidden,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeLine">                                    cl::init(~0));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">68</td>
    <td class="codeLine">                                    cl::init(~0));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeLine">cl::opt<unsigned> VAGroupSizeLimit("hvc-va-group-size-limit", cl::Hidden,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">69</td>
    <td class="codeLine">cl::opt<unsigned> VAGroupSizeLimit("hvc-va-group-size-limit", cl::Hidden,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeLine">                                   cl::init(~0));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">70</td>
    <td class="codeLine">                                   cl::init(~0));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">71</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeLine">class HexagonVectorCombine {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">72</td>
    <td class="codeLine">class HexagonVectorCombine {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">73</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeLine">  HexagonVectorCombine(Function &F_, AliasAnalysis &AA_, AssumptionCache &AC_,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">74</td>
    <td class="codeLine">  HexagonVectorCombine(Function &F_, AliasAnalysis &AA_, AssumptionCache &AC_,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeLine">                       DominatorTree &DT_, ScalarEvolution &SE_,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">75</td>
    <td class="codeLine">                       DominatorTree &DT_, ScalarEvolution &SE_,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeLine">                       TargetLibraryInfo &TLI_, const TargetMachine &TM_)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">76</td>
    <td class="codeLine">                       TargetLibraryInfo &TLI_, const TargetMachine &TM_)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeLine">      : F(F_), DL(F.getParent()->getDataLayout()), AA(AA_), AC(AC_), DT(DT_),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">77</td>
    <td class="codeLine">      : F(F_), DL(F.getParent()->getDataLayout()), AA(AA_), AC(AC_), DT(DT_),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeLine">        SE(SE_), TLI(TLI_),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">78</td>
    <td class="codeLine">        SE(SE_), TLI(TLI_),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeLine">        HST(static_cast<const HexagonSubtarget &>(*TM_.getSubtargetImpl(F))) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">79</td>
    <td class="codeLine">        HST(static_cast<const HexagonSubtarget &>(*TM_.getSubtargetImpl(F))) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">80</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeLine">  bool run();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">81</td>
    <td class="codeLine">  bool run();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">82</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeLine">  // Common integer type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">83</td>
    <td class="codeLine">  // Common integer type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeLine">  IntegerType *getIntTy(unsigned Width = 32) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">84</td>
    <td class="codeLine">  IntegerType *getIntTy(unsigned Width = 32) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeLine">  // Byte type: either scalar (when Length = 0), or vector with given</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">85</td>
    <td class="codeLine">  // Byte type: either scalar (when Length = 0), or vector with given</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeLine">  // element count.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">86</td>
    <td class="codeLine">  // element count.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeLine">  Type *getByteTy(int ElemCount = 0) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">87</td>
    <td class="codeLine">  Type *getByteTy(int ElemCount = 0) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeLine">  // Boolean type: either scalar (when Length = 0), or vector with given</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">88</td>
    <td class="codeLine">  // Boolean type: either scalar (when Length = 0), or vector with given</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeLine">  // element count.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">89</td>
    <td class="codeLine">  // element count.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeLine">  Type *getBoolTy(int ElemCount = 0) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">90</td>
    <td class="codeLine">  Type *getBoolTy(int ElemCount = 0) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeLine">  // Create a ConstantInt of type returned by getIntTy with the value Val.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">91</td>
    <td class="codeLine">  // Create a ConstantInt of type returned by getIntTy with the value Val.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeLine">  ConstantInt *getConstInt(int Val, unsigned Width = 32) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">92</td>
    <td class="codeLine">  ConstantInt *getConstInt(int Val, unsigned Width = 32) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeLine">  // Get the integer value of V, if it exists.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">93</td>
    <td class="codeLine">  // Get the integer value of V, if it exists.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeLine">  std::optional<APInt> getIntValue(const Value *Val) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">94</td>
    <td class="codeLine">  std::optional<APInt> getIntValue(const Value *Val) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeLine">  // Is Val a constant 0, or a vector of 0s?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">95</td>
    <td class="codeLine">  // Is Val a constant 0, or a vector of 0s?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeLine">  bool isZero(const Value *Val) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">96</td>
    <td class="codeLine">  bool isZero(const Value *Val) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeLine">  // Is Val an undef value?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">97</td>
    <td class="codeLine">  // Is Val an undef value?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeLine">  bool isUndef(const Value *Val) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">98</td>
    <td class="codeLine">  bool isUndef(const Value *Val) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeLine">  // Is Val a scalar (i1 true) or a vector of (i1 true)?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">99</td>
    <td class="codeLine">  // Is Val a scalar (i1 true) or a vector of (i1 true)?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeLine">  bool isTrue(const Value *Val) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">100</td>
    <td class="codeLine">  bool isTrue(const Value *Val) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeLine">  // Is Val a scalar (i1 false) or a vector of (i1 false)?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">101</td>
    <td class="codeLine">  // Is Val a scalar (i1 false) or a vector of (i1 false)?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeLine">  bool isFalse(const Value *Val) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">102</td>
    <td class="codeLine">  bool isFalse(const Value *Val) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">103</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeLine">  // Get HVX vector type with the given element type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">104</td>
    <td class="codeLine">  // Get HVX vector type with the given element type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeLine">  VectorType *getHvxTy(Type *ElemTy, bool Pair = false) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">105</td>
    <td class="codeLine">  VectorType *getHvxTy(Type *ElemTy, bool Pair = false) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">106</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeLine">  enum SizeKind {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">107</td>
    <td class="codeLine">  enum SizeKind {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeLine">    Store, // Store size</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">108</td>
    <td class="codeLine">    Store, // Store size</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeLine">    Alloc, // Alloc size</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">109</td>
    <td class="codeLine">    Alloc, // Alloc size</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">110</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeLine">  int getSizeOf(const Value *Val, SizeKind Kind = Store) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">111</td>
    <td class="codeLine">  int getSizeOf(const Value *Val, SizeKind Kind = Store) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeLine">  int getSizeOf(const Type *Ty, SizeKind Kind = Store) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">112</td>
    <td class="codeLine">  int getSizeOf(const Type *Ty, SizeKind Kind = Store) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeLine">  int getTypeAlignment(Type *Ty) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">113</td>
    <td class="codeLine">  int getTypeAlignment(Type *Ty) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeLine">  size_t length(Value *Val) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">114</td>
    <td class="codeLine">  size_t length(Value *Val) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeLine">  size_t length(Type *Ty) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">115</td>
    <td class="codeLine">  size_t length(Type *Ty) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">116</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeLine">  Constant *getNullValue(Type *Ty) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">117</td>
    <td class="codeLine">  Constant *getNullValue(Type *Ty) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeLine">  Constant *getFullValue(Type *Ty) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">118</td>
    <td class="codeLine">  Constant *getFullValue(Type *Ty) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeLine">  Constant *getConstSplat(Type *Ty, int Val) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">119</td>
    <td class="codeLine">  Constant *getConstSplat(Type *Ty, int Val) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">120</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeLine">  Value *simplify(Value *Val) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">121</td>
    <td class="codeLine">  Value *simplify(Value *Val) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">122</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeLine">  Value *insertb(IRBuilderBase &Builder, Value *Dest, Value *Src, int Start,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">123</td>
    <td class="codeLine">  Value *insertb(IRBuilderBase &Builder, Value *Dest, Value *Src, int Start,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeLine">                 int Length, int Where) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">124</td>
    <td class="codeLine">                 int Length, int Where) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeLine">  Value *vlalignb(IRBuilderBase &Builder, Value *Lo, Value *Hi,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">125</td>
    <td class="codeLine">  Value *vlalignb(IRBuilderBase &Builder, Value *Lo, Value *Hi,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeLine">                  Value *Amt) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">126</td>
    <td class="codeLine">                  Value *Amt) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeLine">  Value *vralignb(IRBuilderBase &Builder, Value *Lo, Value *Hi,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">127</td>
    <td class="codeLine">  Value *vralignb(IRBuilderBase &Builder, Value *Lo, Value *Hi,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeLine">                  Value *Amt) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">128</td>
    <td class="codeLine">                  Value *Amt) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeLine">  Value *concat(IRBuilderBase &Builder, ArrayRef<Value *> Vecs) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">129</td>
    <td class="codeLine">  Value *concat(IRBuilderBase &Builder, ArrayRef<Value *> Vecs) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeLine">  Value *vresize(IRBuilderBase &Builder, Value *Val, int NewSize,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">130</td>
    <td class="codeLine">  Value *vresize(IRBuilderBase &Builder, Value *Val, int NewSize,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeLine">                 Value *Pad) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">131</td>
    <td class="codeLine">                 Value *Pad) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeLine">  Value *rescale(IRBuilderBase &Builder, Value *Mask, Type *FromTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">132</td>
    <td class="codeLine">  Value *rescale(IRBuilderBase &Builder, Value *Mask, Type *FromTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeLine">                 Type *ToTy) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">133</td>
    <td class="codeLine">                 Type *ToTy) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeLine">  Value *vlsb(IRBuilderBase &Builder, Value *Val) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">134</td>
    <td class="codeLine">  Value *vlsb(IRBuilderBase &Builder, Value *Val) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeLine">  Value *vbytes(IRBuilderBase &Builder, Value *Val) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">135</td>
    <td class="codeLine">  Value *vbytes(IRBuilderBase &Builder, Value *Val) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeLine">  Value *subvector(IRBuilderBase &Builder, Value *Val, unsigned Start,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">136</td>
    <td class="codeLine">  Value *subvector(IRBuilderBase &Builder, Value *Val, unsigned Start,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeLine">                   unsigned Length) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">137</td>
    <td class="codeLine">                   unsigned Length) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeLine">  Value *sublo(IRBuilderBase &Builder, Value *Val) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">138</td>
    <td class="codeLine">  Value *sublo(IRBuilderBase &Builder, Value *Val) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeLine">  Value *subhi(IRBuilderBase &Builder, Value *Val) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">139</td>
    <td class="codeLine">  Value *subhi(IRBuilderBase &Builder, Value *Val) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeLine">  Value *vdeal(IRBuilderBase &Builder, Value *Val0, Value *Val1) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">140</td>
    <td class="codeLine">  Value *vdeal(IRBuilderBase &Builder, Value *Val0, Value *Val1) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeLine">  Value *vshuff(IRBuilderBase &Builder, Value *Val0, Value *Val1) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">141</td>
    <td class="codeLine">  Value *vshuff(IRBuilderBase &Builder, Value *Val0, Value *Val1) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">142</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeLine">  Value *createHvxIntrinsic(IRBuilderBase &Builder, Intrinsic::ID IntID,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">143</td>
    <td class="codeLine">  Value *createHvxIntrinsic(IRBuilderBase &Builder, Intrinsic::ID IntID,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeLine">                            Type *RetTy, ArrayRef<Value *> Args,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">144</td>
    <td class="codeLine">                            Type *RetTy, ArrayRef<Value *> Args,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeLine">                            ArrayRef<Type *> ArgTys = std::nullopt,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">145</td>
    <td class="codeLine">                            ArrayRef<Type *> ArgTys = std::nullopt,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeLine">                            ArrayRef<Value *> MDSources = std::nullopt) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">146</td>
    <td class="codeLine">                            ArrayRef<Value *> MDSources = std::nullopt) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeLine">  SmallVector<Value *> splitVectorElements(IRBuilderBase &Builder, Value *Vec,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">147</td>
    <td class="codeLine">  SmallVector<Value *> splitVectorElements(IRBuilderBase &Builder, Value *Vec,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeLine">                                           unsigned ToWidth) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">148</td>
    <td class="codeLine">                                           unsigned ToWidth) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeLine">  Value *joinVectorElements(IRBuilderBase &Builder, ArrayRef<Value *> Values,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">149</td>
    <td class="codeLine">  Value *joinVectorElements(IRBuilderBase &Builder, ArrayRef<Value *> Values,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeLine">                            VectorType *ToType) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">150</td>
    <td class="codeLine">                            VectorType *ToType) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">151</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeLine">  std::optional<int> calculatePointerDifference(Value *Ptr0, Value *Ptr1) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">152</td>
    <td class="codeLine">  std::optional<int> calculatePointerDifference(Value *Ptr0, Value *Ptr1) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">153</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeLine">  unsigned getNumSignificantBits(const Value *V,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">154</td>
    <td class="codeLine">  unsigned getNumSignificantBits(const Value *V,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeLine">                                 const Instruction *CtxI = nullptr) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">155</td>
    <td class="codeLine">                                 const Instruction *CtxI = nullptr) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeLine">  KnownBits getKnownBits(const Value *V,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">156</td>
    <td class="codeLine">  KnownBits getKnownBits(const Value *V,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeLine">                         const Instruction *CtxI = nullptr) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">157</td>
    <td class="codeLine">                         const Instruction *CtxI = nullptr) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">158</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeLine">  bool isSafeToClone(const Instruction &In) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">159</td>
    <td class="codeLine">  bool isSafeToClone(const Instruction &In) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">160</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeLine">  template <typename T = std::vector<Instruction *>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">161</td>
    <td class="codeLine">  template <typename T = std::vector<Instruction *>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeLine">  bool isSafeToMoveBeforeInBB(const Instruction &In,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">162</td>
    <td class="codeLine">  bool isSafeToMoveBeforeInBB(const Instruction &In,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeLine">                              BasicBlock::const_iterator To,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">163</td>
    <td class="codeLine">                              BasicBlock::const_iterator To,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeLine">                              const T &IgnoreInsts = {}) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">164</td>
    <td class="codeLine">                              const T &IgnoreInsts = {}) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">165</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeLine">  // This function is only used for assertions at the moment.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">166</td>
    <td class="codeLine">  // This function is only used for assertions at the moment.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeLine">  [[maybe_unused]] bool isByteVecTy(Type *Ty) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">167</td>
    <td class="codeLine">  [[maybe_unused]] bool isByteVecTy(Type *Ty) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">168</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeLine">  Function &F;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">169</td>
    <td class="codeLine">  Function &F;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeLine">  const DataLayout &DL;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">170</td>
    <td class="codeLine">  const DataLayout &DL;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeLine">  AliasAnalysis &AA;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">171</td>
    <td class="codeLine">  AliasAnalysis &AA;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeLine">  AssumptionCache &AC;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">172</td>
    <td class="codeLine">  AssumptionCache &AC;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeLine">  DominatorTree &DT;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">173</td>
    <td class="codeLine">  DominatorTree &DT;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeLine">  ScalarEvolution &SE;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">174</td>
    <td class="codeLine">  ScalarEvolution &SE;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeLine">  TargetLibraryInfo &TLI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">175</td>
    <td class="codeLine">  TargetLibraryInfo &TLI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeLine">  const HexagonSubtarget &HST;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">176</td>
    <td class="codeLine">  const HexagonSubtarget &HST;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">177</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">178</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeLine">  Value *getElementRange(IRBuilderBase &Builder, Value *Lo, Value *Hi,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">179</td>
    <td class="codeLine">  Value *getElementRange(IRBuilderBase &Builder, Value *Lo, Value *Hi,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeLine">                         int Start, int Length) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">180</td>
    <td class="codeLine">                         int Start, int Length) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">181</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">182</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeLine">class AlignVectors {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">183</td>
    <td class="codeLine">class AlignVectors {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeLine">  // This code tries to replace unaligned vector loads/stores with aligned</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">184</td>
    <td class="codeLine">  // This code tries to replace unaligned vector loads/stores with aligned</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeLine">  // ones.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">185</td>
    <td class="codeLine">  // ones.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeLine">  // Consider unaligned load:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">186</td>
    <td class="codeLine">  // Consider unaligned load:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeLine">  //   %v = original_load %some_addr, align <bad></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">187</td>
    <td class="codeLine">  //   %v = original_load %some_addr, align <bad></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeLine">  //   %user = %v</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">188</td>
    <td class="codeLine">  //   %user = %v</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeLine">  // It will generate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">189</td>
    <td class="codeLine">  // It will generate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeLine">  //      = load ..., align <good></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">190</td>
    <td class="codeLine">  //      = load ..., align <good></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeLine">  //      = load ..., align <good></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">191</td>
    <td class="codeLine">  //      = load ..., align <good></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeLine">  //      = valign</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">192</td>
    <td class="codeLine">  //      = valign</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeLine">  //      etc.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">193</td>
    <td class="codeLine">  //      etc.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeLine">  //   %synthesize = combine/shuffle the loaded data so that it looks</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">194</td>
    <td class="codeLine">  //   %synthesize = combine/shuffle the loaded data so that it looks</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeLine">  //                 exactly like what "original_load" has loaded.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">195</td>
    <td class="codeLine">  //                 exactly like what "original_load" has loaded.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeLine">  //   %user = %synthesize</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">196</td>
    <td class="codeLine">  //   %user = %synthesize</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeLine">  // Similarly for stores.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">197</td>
    <td class="codeLine">  // Similarly for stores.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">198</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeLine">  AlignVectors(const HexagonVectorCombine &HVC_) : HVC(HVC_) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">199</td>
    <td class="codeLine">  AlignVectors(const HexagonVectorCombine &HVC_) : HVC(HVC_) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">200</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeLine">  bool run();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">201</td>
    <td class="codeLine">  bool run();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">202</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">203</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeLine">  using InstList = std::vector<Instruction *>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">204</td>
    <td class="codeLine">  using InstList = std::vector<Instruction *>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeLine">  using InstMap = DenseMap<Instruction *, Instruction *>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">205</td>
    <td class="codeLine">  using InstMap = DenseMap<Instruction *, Instruction *>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">206</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeLine">  struct AddrInfo {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">207</td>
    <td class="codeLine">  struct AddrInfo {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeLine">    AddrInfo(const AddrInfo &) = default;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">208</td>
    <td class="codeLine">    AddrInfo(const AddrInfo &) = default;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeLine">    AddrInfo(const HexagonVectorCombine &HVC, Instruction *I, Value *A, Type *T,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">209</td>
    <td class="codeLine">    AddrInfo(const HexagonVectorCombine &HVC, Instruction *I, Value *A, Type *T,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeLine">             Align H)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">210</td>
    <td class="codeLine">             Align H)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeLine">        : Inst(I), Addr(A), ValTy(T), HaveAlign(H),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">211</td>
    <td class="codeLine">        : Inst(I), Addr(A), ValTy(T), HaveAlign(H),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeLine">          NeedAlign(HVC.getTypeAlignment(ValTy)) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">212</td>
    <td class="codeLine">          NeedAlign(HVC.getTypeAlignment(ValTy)) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeLine">    AddrInfo &operator=(const AddrInfo &) = default;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">213</td>
    <td class="codeLine">    AddrInfo &operator=(const AddrInfo &) = default;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">214</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeLine">    // XXX: add Size member?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">215</td>
    <td class="codeLine">    // XXX: add Size member?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeLine">    Instruction *Inst;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">216</td>
    <td class="codeLine">    Instruction *Inst;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeLine">    Value *Addr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">217</td>
    <td class="codeLine">    Value *Addr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeLine">    Type *ValTy;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">218</td>
    <td class="codeLine">    Type *ValTy;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeLine">    Align HaveAlign;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">219</td>
    <td class="codeLine">    Align HaveAlign;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeLine">    Align NeedAlign;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">220</td>
    <td class="codeLine">    Align NeedAlign;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeLine">    int Offset = 0; // Offset (in bytes) from the first member of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">221</td>
    <td class="codeLine">    int Offset = 0; // Offset (in bytes) from the first member of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeLine">                    // containing AddrList.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">222</td>
    <td class="codeLine">                    // containing AddrList.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">223</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeLine">  using AddrList = std::vector<AddrInfo>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">224</td>
    <td class="codeLine">  using AddrList = std::vector<AddrInfo>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeLine">  struct InstrLess {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">226</td>
    <td class="codeLine">  struct InstrLess {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeLine">    bool operator()(const Instruction *A, const Instruction *B) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">227</td>
    <td class="codeLine">    bool operator()(const Instruction *A, const Instruction *B) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeLine">      return A->comesBefore(B);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">228</td>
    <td class="codeLine">      return A->comesBefore(B);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">229</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">230</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeLine">  using DepList = std::set<Instruction *, InstrLess>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">231</td>
    <td class="codeLine">  using DepList = std::set<Instruction *, InstrLess>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">232</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeLine">  struct MoveGroup {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">233</td>
    <td class="codeLine">  struct MoveGroup {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeLine">    MoveGroup(const AddrInfo &AI, Instruction *B, bool Hvx, bool Load)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">234</td>
    <td class="codeLine">    MoveGroup(const AddrInfo &AI, Instruction *B, bool Hvx, bool Load)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeLine">        : Base(B), Main{AI.Inst}, Clones{}, IsHvx(Hvx), IsLoad(Load) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">235</td>
    <td class="codeLine">        : Base(B), Main{AI.Inst}, Clones{}, IsHvx(Hvx), IsLoad(Load) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeLine">    MoveGroup() = default;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">236</td>
    <td class="codeLine">    MoveGroup() = default;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeLine">    Instruction *Base; // Base instruction of the parent address group.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">237</td>
    <td class="codeLine">    Instruction *Base; // Base instruction of the parent address group.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeLine">    InstList Main;     // Main group of instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">238</td>
    <td class="codeLine">    InstList Main;     // Main group of instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeLine">    InstList Deps;     // List of dependencies.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">239</td>
    <td class="codeLine">    InstList Deps;     // List of dependencies.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeLine">    InstMap Clones;    // Map from original Deps to cloned ones.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">240</td>
    <td class="codeLine">    InstMap Clones;    // Map from original Deps to cloned ones.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeLine">    bool IsHvx;        // Is this group of HVX instructions?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">241</td>
    <td class="codeLine">    bool IsHvx;        // Is this group of HVX instructions?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeLine">    bool IsLoad;       // Is this a load group?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">242</td>
    <td class="codeLine">    bool IsLoad;       // Is this a load group?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">243</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeLine">  using MoveList = std::vector<MoveGroup>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">244</td>
    <td class="codeLine">  using MoveList = std::vector<MoveGroup>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">245</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeLine">  struct ByteSpan {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">246</td>
    <td class="codeLine">  struct ByteSpan {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeLine">    // A representation of "interesting" bytes within a given span of memory.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">247</td>
    <td class="codeLine">    // A representation of "interesting" bytes within a given span of memory.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeLine">    // These bytes are those that are loaded or stored, and they don't have</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">248</td>
    <td class="codeLine">    // These bytes are those that are loaded or stored, and they don't have</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeLine">    // to cover the entire span of memory.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">249</td>
    <td class="codeLine">    // to cover the entire span of memory.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">250</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeLine">    // The representation works by picking a contiguous sequence of bytes</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">251</td>
    <td class="codeLine">    // The representation works by picking a contiguous sequence of bytes</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeLine">    // from somewhere within a llvm::Value, and placing it at a given offset</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">252</td>
    <td class="codeLine">    // from somewhere within a llvm::Value, and placing it at a given offset</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeLine">    // within the span.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">253</td>
    <td class="codeLine">    // within the span.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">254</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeLine">    // The sequence of bytes from llvm:Value is represented by Segment.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">255</td>
    <td class="codeLine">    // The sequence of bytes from llvm:Value is represented by Segment.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeLine">    // Block is Segment, plus where it goes in the span.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">256</td>
    <td class="codeLine">    // Block is Segment, plus where it goes in the span.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">257</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeLine">    // An important feature of ByteSpan is being able to make a "section",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">258</td>
    <td class="codeLine">    // An important feature of ByteSpan is being able to make a "section",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeLine">    // i.e. creating another ByteSpan corresponding to a range of offsets</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">259</td>
    <td class="codeLine">    // i.e. creating another ByteSpan corresponding to a range of offsets</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeLine">    // relative to the source span.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">260</td>
    <td class="codeLine">    // relative to the source span.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">261</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeLine">    struct Segment {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">262</td>
    <td class="codeLine">    struct Segment {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeLine">      // Segment of a Value: 'Len' bytes starting at byte 'Begin'.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">263</td>
    <td class="codeLine">      // Segment of a Value: 'Len' bytes starting at byte 'Begin'.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeLine">      Segment(Value *Val, int Begin, int Len)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">264</td>
    <td class="codeLine">      Segment(Value *Val, int Begin, int Len)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeLine">          : Val(Val), Start(Begin), Size(Len) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">265</td>
    <td class="codeLine">          : Val(Val), Start(Begin), Size(Len) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeLine">      Segment(const Segment &Seg) = default;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">266</td>
    <td class="codeLine">      Segment(const Segment &Seg) = default;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeLine">      Segment &operator=(const Segment &Seg) = default;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">267</td>
    <td class="codeLine">      Segment &operator=(const Segment &Seg) = default;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeLine">      Value *Val; // Value representable as a sequence of bytes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">268</td>
    <td class="codeLine">      Value *Val; // Value representable as a sequence of bytes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeLine">      int Start;  // First byte of the value that belongs to the segment.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">269</td>
    <td class="codeLine">      int Start;  // First byte of the value that belongs to the segment.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeLine">      int Size;   // Number of bytes in the segment.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">270</td>
    <td class="codeLine">      int Size;   // Number of bytes in the segment.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">271</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">272</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeLine">    struct Block {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">273</td>
    <td class="codeLine">    struct Block {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeLine">      Block(Value *Val, int Len, int Pos) : Seg(Val, 0, Len), Pos(Pos) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">274</td>
    <td class="codeLine">      Block(Value *Val, int Len, int Pos) : Seg(Val, 0, Len), Pos(Pos) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeLine">      Block(Value *Val, int Off, int Len, int Pos)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">275</td>
    <td class="codeLine">      Block(Value *Val, int Off, int Len, int Pos)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeLine">          : Seg(Val, Off, Len), Pos(Pos) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">276</td>
    <td class="codeLine">          : Seg(Val, Off, Len), Pos(Pos) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeLine">      Block(const Block &Blk) = default;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">277</td>
    <td class="codeLine">      Block(const Block &Blk) = default;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeLine">      Block &operator=(const Block &Blk) = default;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">278</td>
    <td class="codeLine">      Block &operator=(const Block &Blk) = default;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeLine">      Segment Seg; // Value segment.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">279</td>
    <td class="codeLine">      Segment Seg; // Value segment.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeLine">      int Pos;     // Position (offset) of the block in the span.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">280</td>
    <td class="codeLine">      int Pos;     // Position (offset) of the block in the span.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">281</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">282</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeLine">    int extent() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">283</td>
    <td class="codeLine">    int extent() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeLine">    ByteSpan section(int Start, int Length) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">284</td>
    <td class="codeLine">    ByteSpan section(int Start, int Length) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeLine">    ByteSpan &shift(int Offset);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">285</td>
    <td class="codeLine">    ByteSpan &shift(int Offset);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeLine">    SmallVector<Value *, 8> values() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">286</td>
    <td class="codeLine">    SmallVector<Value *, 8> values() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">287</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeLine">    int size() const { return Blocks.size(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">288</td>
    <td class="codeLine">    int size() const { return Blocks.size(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeLine">    Block &operator[](int i) { return Blocks[i]; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">289</td>
    <td class="codeLine">    Block &operator[](int i) { return Blocks[i]; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeLine">    const Block &operator[](int i) const { return Blocks[i]; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">290</td>
    <td class="codeLine">    const Block &operator[](int i) const { return Blocks[i]; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">291</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeLine">    std::vector<Block> Blocks;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">292</td>
    <td class="codeLine">    std::vector<Block> Blocks;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">293</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeLine">    using iterator = decltype(Blocks)::iterator;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">294</td>
    <td class="codeLine">    using iterator = decltype(Blocks)::iterator;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeLine">    iterator begin() { return Blocks.begin(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">295</td>
    <td class="codeLine">    iterator begin() { return Blocks.begin(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeLine">    iterator end() { return Blocks.end(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">296</td>
    <td class="codeLine">    iterator end() { return Blocks.end(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeLine">    using const_iterator = decltype(Blocks)::const_iterator;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">297</td>
    <td class="codeLine">    using const_iterator = decltype(Blocks)::const_iterator;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeLine">    const_iterator begin() const { return Blocks.begin(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">298</td>
    <td class="codeLine">    const_iterator begin() const { return Blocks.begin(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeLine">    const_iterator end() const { return Blocks.end(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">299</td>
    <td class="codeLine">    const_iterator end() const { return Blocks.end(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">300</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">301</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeLine">  Align getAlignFromValue(const Value *V) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">302</td>
    <td class="codeLine">  Align getAlignFromValue(const Value *V) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeLine">  std::optional<AddrInfo> getAddrInfo(Instruction &In) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">303</td>
    <td class="codeLine">  std::optional<AddrInfo> getAddrInfo(Instruction &In) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeLine">  bool isHvx(const AddrInfo &AI) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">304</td>
    <td class="codeLine">  bool isHvx(const AddrInfo &AI) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeLine">  // This function is only used for assertions at the moment.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">305</td>
    <td class="codeLine">  // This function is only used for assertions at the moment.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeLine">  [[maybe_unused]] bool isSectorTy(Type *Ty) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">306</td>
    <td class="codeLine">  [[maybe_unused]] bool isSectorTy(Type *Ty) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">307</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeLine">  Value *getPayload(Value *Val) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">308</td>
    <td class="codeLine">  Value *getPayload(Value *Val) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeLine">  Value *getMask(Value *Val) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">309</td>
    <td class="codeLine">  Value *getMask(Value *Val) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeLine">  Value *getPassThrough(Value *Val) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">310</td>
    <td class="codeLine">  Value *getPassThrough(Value *Val) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">311</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeLine">  Value *createAdjustedPointer(IRBuilderBase &Builder, Value *Ptr, Type *ValTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">312</td>
    <td class="codeLine">  Value *createAdjustedPointer(IRBuilderBase &Builder, Value *Ptr, Type *ValTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeLine">                               int Adjust,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">313</td>
    <td class="codeLine">                               int Adjust,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeLine">                               const InstMap &CloneMap = InstMap()) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">314</td>
    <td class="codeLine">                               const InstMap &CloneMap = InstMap()) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeLine">  Value *createAlignedPointer(IRBuilderBase &Builder, Value *Ptr, Type *ValTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">315</td>
    <td class="codeLine">  Value *createAlignedPointer(IRBuilderBase &Builder, Value *Ptr, Type *ValTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeLine">                              int Alignment,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">316</td>
    <td class="codeLine">                              int Alignment,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeLine">                              const InstMap &CloneMap = InstMap()) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">317</td>
    <td class="codeLine">                              const InstMap &CloneMap = InstMap()) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">318</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeLine">  Value *createLoad(IRBuilderBase &Builder, Type *ValTy, Value *Ptr,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">319</td>
    <td class="codeLine">  Value *createLoad(IRBuilderBase &Builder, Type *ValTy, Value *Ptr,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeLine">                    Value *Predicate, int Alignment, Value *Mask,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">320</td>
    <td class="codeLine">                    Value *Predicate, int Alignment, Value *Mask,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeLine">                    Value *PassThru,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">321</td>
    <td class="codeLine">                    Value *PassThru,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeLine">                    ArrayRef<Value *> MDSources = std::nullopt) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">322</td>
    <td class="codeLine">                    ArrayRef<Value *> MDSources = std::nullopt) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeLine">  Value *createSimpleLoad(IRBuilderBase &Builder, Type *ValTy, Value *Ptr,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">323</td>
    <td class="codeLine">  Value *createSimpleLoad(IRBuilderBase &Builder, Type *ValTy, Value *Ptr,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeLine">                          int Alignment,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">324</td>
    <td class="codeLine">                          int Alignment,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeLine">                          ArrayRef<Value *> MDSources = std::nullopt) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">325</td>
    <td class="codeLine">                          ArrayRef<Value *> MDSources = std::nullopt) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">326</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeLine">  Value *createStore(IRBuilderBase &Builder, Value *Val, Value *Ptr,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">327</td>
    <td class="codeLine">  Value *createStore(IRBuilderBase &Builder, Value *Val, Value *Ptr,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeLine">                     Value *Predicate, int Alignment, Value *Mask,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">328</td>
    <td class="codeLine">                     Value *Predicate, int Alignment, Value *Mask,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeLine">                     ArrayRef<Value *> MDSources = std ::nullopt) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">329</td>
    <td class="codeLine">                     ArrayRef<Value *> MDSources = std ::nullopt) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeLine">  Value *createSimpleStore(IRBuilderBase &Builder, Value *Val, Value *Ptr,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">330</td>
    <td class="codeLine">  Value *createSimpleStore(IRBuilderBase &Builder, Value *Val, Value *Ptr,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeLine">                           int Alignment,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">331</td>
    <td class="codeLine">                           int Alignment,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeLine">                           ArrayRef<Value *> MDSources = std ::nullopt) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">332</td>
    <td class="codeLine">                           ArrayRef<Value *> MDSources = std ::nullopt) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">333</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeLine">  Value *createPredicatedLoad(IRBuilderBase &Builder, Type *ValTy, Value *Ptr,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">334</td>
    <td class="codeLine">  Value *createPredicatedLoad(IRBuilderBase &Builder, Type *ValTy, Value *Ptr,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeLine">                              Value *Predicate, int Alignment,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">335</td>
    <td class="codeLine">                              Value *Predicate, int Alignment,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeLine">                              ArrayRef<Value *> MDSources = std::nullopt) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">336</td>
    <td class="codeLine">                              ArrayRef<Value *> MDSources = std::nullopt) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeLine">  Value *</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">337</td>
    <td class="codeLine">  Value *</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeLine">  createPredicatedStore(IRBuilderBase &Builder, Value *Val, Value *Ptr,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">338</td>
    <td class="codeLine">  createPredicatedStore(IRBuilderBase &Builder, Value *Val, Value *Ptr,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeLine">                        Value *Predicate, int Alignment,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">339</td>
    <td class="codeLine">                        Value *Predicate, int Alignment,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeLine">                        ArrayRef<Value *> MDSources = std::nullopt) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">340</td>
    <td class="codeLine">                        ArrayRef<Value *> MDSources = std::nullopt) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">341</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeLine">  DepList getUpwardDeps(Instruction *In, Instruction *Base) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">342</td>
    <td class="codeLine">  DepList getUpwardDeps(Instruction *In, Instruction *Base) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeLine">  bool createAddressGroups();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">343</td>
    <td class="codeLine">  bool createAddressGroups();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeLine">  MoveList createLoadGroups(const AddrList &Group) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">344</td>
    <td class="codeLine">  MoveList createLoadGroups(const AddrList &Group) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeLine">  MoveList createStoreGroups(const AddrList &Group) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">345</td>
    <td class="codeLine">  MoveList createStoreGroups(const AddrList &Group) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeLine">  bool moveTogether(MoveGroup &Move) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">346</td>
    <td class="codeLine">  bool moveTogether(MoveGroup &Move) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeLine">  template <typename T> InstMap cloneBefore(Instruction *To, T &&Insts) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">347</td>
    <td class="codeLine">  template <typename T> InstMap cloneBefore(Instruction *To, T &&Insts) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">348</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeLine">  void realignLoadGroup(IRBuilderBase &Builder, const ByteSpan &VSpan,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">349</td>
    <td class="codeLine">  void realignLoadGroup(IRBuilderBase &Builder, const ByteSpan &VSpan,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeLine">                        int ScLen, Value *AlignVal, Value *AlignAddr) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">350</td>
    <td class="codeLine">                        int ScLen, Value *AlignVal, Value *AlignAddr) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeLine">  void realignStoreGroup(IRBuilderBase &Builder, const ByteSpan &VSpan,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">351</td>
    <td class="codeLine">  void realignStoreGroup(IRBuilderBase &Builder, const ByteSpan &VSpan,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeLine">                         int ScLen, Value *AlignVal, Value *AlignAddr) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">352</td>
    <td class="codeLine">                         int ScLen, Value *AlignVal, Value *AlignAddr) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeLine">  bool realignGroup(const MoveGroup &Move) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">353</td>
    <td class="codeLine">  bool realignGroup(const MoveGroup &Move) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">354</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeLine">  Value *makeTestIfUnaligned(IRBuilderBase &Builder, Value *AlignVal,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">355</td>
    <td class="codeLine">  Value *makeTestIfUnaligned(IRBuilderBase &Builder, Value *AlignVal,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeLine">                             int Alignment) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">356</td>
    <td class="codeLine">                             int Alignment) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">357</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeLine">  friend raw_ostream &operator<<(raw_ostream &OS, const AddrInfo &AI);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">358</td>
    <td class="codeLine">  friend raw_ostream &operator<<(raw_ostream &OS, const AddrInfo &AI);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeLine">  friend raw_ostream &operator<<(raw_ostream &OS, const MoveGroup &MG);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">359</td>
    <td class="codeLine">  friend raw_ostream &operator<<(raw_ostream &OS, const MoveGroup &MG);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeLine">  friend raw_ostream &operator<<(raw_ostream &OS, const ByteSpan::Block &B);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">360</td>
    <td class="codeLine">  friend raw_ostream &operator<<(raw_ostream &OS, const ByteSpan::Block &B);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeLine">  friend raw_ostream &operator<<(raw_ostream &OS, const ByteSpan &BS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">361</td>
    <td class="codeLine">  friend raw_ostream &operator<<(raw_ostream &OS, const ByteSpan &BS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeLine">  std::map<Instruction *, AddrList> AddrGroups;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">363</td>
    <td class="codeLine">  std::map<Instruction *, AddrList> AddrGroups;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeLine">  const HexagonVectorCombine &HVC;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">364</td>
    <td class="codeLine">  const HexagonVectorCombine &HVC;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">365</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">366</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeLine">LLVM_ATTRIBUTE_UNUSED</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">367</td>
    <td class="codeLine">LLVM_ATTRIBUTE_UNUSED</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeLine">raw_ostream &operator<<(raw_ostream &OS, const AlignVectors::AddrInfo &AI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">368</td>
    <td class="codeLine">raw_ostream &operator<<(raw_ostream &OS, const AlignVectors::AddrInfo &AI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeLine">  OS << "Inst: " << AI.Inst << "  " << *AI.Inst << '\n';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">369</td>
    <td class="codeLine">  OS << "Inst: " << AI.Inst << "  " << *AI.Inst << '\n';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeLine">  OS << "Addr: " << *AI.Addr << '\n';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">370</td>
    <td class="codeLine">  OS << "Addr: " << *AI.Addr << '\n';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeLine">  OS << "Type: " << *AI.ValTy << '\n';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">371</td>
    <td class="codeLine">  OS << "Type: " << *AI.ValTy << '\n';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeLine">  OS << "HaveAlign: " << AI.HaveAlign.value() << '\n';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">372</td>
    <td class="codeLine">  OS << "HaveAlign: " << AI.HaveAlign.value() << '\n';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeLine">  OS << "NeedAlign: " << AI.NeedAlign.value() << '\n';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">373</td>
    <td class="codeLine">  OS << "NeedAlign: " << AI.NeedAlign.value() << '\n';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeLine">  OS << "Offset: " << AI.Offset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">374</td>
    <td class="codeLine">  OS << "Offset: " << AI.Offset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeLine">  return OS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">375</td>
    <td class="codeLine">  return OS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">376</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">377</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeLine">LLVM_ATTRIBUTE_UNUSED</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">378</td>
    <td class="codeLine">LLVM_ATTRIBUTE_UNUSED</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeLine">raw_ostream &operator<<(raw_ostream &OS, const AlignVectors::MoveGroup &MG) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">379</td>
    <td class="codeLine">raw_ostream &operator<<(raw_ostream &OS, const AlignVectors::MoveGroup &MG) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeLine">  OS << "IsLoad:" << (MG.IsLoad ? "yes" : "no");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">380</td>
    <td class="codeLine">  OS << "IsLoad:" << (MG.IsLoad ? "yes" : "no");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeLine">  OS << ", IsHvx:" << (MG.IsHvx ? "yes" : "no") << '\n';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">381</td>
    <td class="codeLine">  OS << ", IsHvx:" << (MG.IsHvx ? "yes" : "no") << '\n';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeLine">  OS << "Main\n";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">382</td>
    <td class="codeLine">  OS << "Main\n";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeLine">  for (Instruction *I : MG.Main)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">383</td>
    <td class="codeLine">  for (Instruction *I : MG.Main)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeLine">    OS << "  " << *I << '\n';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">384</td>
    <td class="codeLine">    OS << "  " << *I << '\n';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeLine">  OS << "Deps\n";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">385</td>
    <td class="codeLine">  OS << "Deps\n";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeLine">  for (Instruction *I : MG.Deps)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">386</td>
    <td class="codeLine">  for (Instruction *I : MG.Deps)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeLine">    OS << "  " << *I << '\n';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">387</td>
    <td class="codeLine">    OS << "  " << *I << '\n';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeLine">  OS << "Clones\n";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">388</td>
    <td class="codeLine">  OS << "Clones\n";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeLine">  for (auto [K, V] : MG.Clones) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">389</td>
    <td class="codeLine">  for (auto [K, V] : MG.Clones) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeLine">    OS << "    ";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">390</td>
    <td class="codeLine">    OS << "    ";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeLine">    K->printAsOperand(OS, false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">391</td>
    <td class="codeLine">    K->printAsOperand(OS, false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeLine">    OS << "\t-> " << *V << '\n';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">392</td>
    <td class="codeLine">    OS << "\t-> " << *V << '\n';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">393</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeLine">  return OS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">394</td>
    <td class="codeLine">  return OS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">395</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">396</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeLine">LLVM_ATTRIBUTE_UNUSED</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">397</td>
    <td class="codeLine">LLVM_ATTRIBUTE_UNUSED</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeLine">raw_ostream &operator<<(raw_ostream &OS,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">398</td>
    <td class="codeLine">raw_ostream &operator<<(raw_ostream &OS,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeLine">                        const AlignVectors::ByteSpan::Block &B) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">399</td>
    <td class="codeLine">                        const AlignVectors::ByteSpan::Block &B) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeLine">  OS << "  @" << B.Pos << " [" << B.Seg.Start << ',' << B.Seg.Size << "] ";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">400</td>
    <td class="codeLine">  OS << "  @" << B.Pos << " [" << B.Seg.Start << ',' << B.Seg.Size << "] ";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeLine">  if (B.Seg.Val == reinterpret_cast<const Value *>(&B)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">401</td>
    <td class="codeLine">  if (B.Seg.Val == reinterpret_cast<const Value *>(&B)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeLine">    OS << "(self:" << B.Seg.Val << ')';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">402</td>
    <td class="codeLine">    OS << "(self:" << B.Seg.Val << ')';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeLine">  } else if (B.Seg.Val != nullptr) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">403</td>
    <td class="codeLine">  } else if (B.Seg.Val != nullptr) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeLine">    OS << *B.Seg.Val;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">404</td>
    <td class="codeLine">    OS << *B.Seg.Val;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">405</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeLine">    OS << "(null)";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">406</td>
    <td class="codeLine">    OS << "(null)";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">407</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeLine">  return OS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">408</td>
    <td class="codeLine">  return OS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">409</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">410</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeLine">LLVM_ATTRIBUTE_UNUSED</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">411</td>
    <td class="codeLine">LLVM_ATTRIBUTE_UNUSED</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeLine">raw_ostream &operator<<(raw_ostream &OS, const AlignVectors::ByteSpan &BS) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">412</td>
    <td class="codeLine">raw_ostream &operator<<(raw_ostream &OS, const AlignVectors::ByteSpan &BS) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeLine">  OS << "ByteSpan[size=" << BS.size() << ", extent=" << BS.extent() << '\n';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">413</td>
    <td class="codeLine">  OS << "ByteSpan[size=" << BS.size() << ", extent=" << BS.extent() << '\n';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeLine">  for (const AlignVectors::ByteSpan::Block &B : BS)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">414</td>
    <td class="codeLine">  for (const AlignVectors::ByteSpan::Block &B : BS)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeLine">    OS << B << '\n';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">415</td>
    <td class="codeLine">    OS << B << '\n';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeLine">  OS << ']';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">416</td>
    <td class="codeLine">  OS << ']';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeLine">  return OS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">417</td>
    <td class="codeLine">  return OS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">418</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">419</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeLine">class HvxIdioms {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">420</td>
    <td class="codeLine">class HvxIdioms {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">421</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeLine">  HvxIdioms(const HexagonVectorCombine &HVC_) : HVC(HVC_) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">422</td>
    <td class="codeLine">  HvxIdioms(const HexagonVectorCombine &HVC_) : HVC(HVC_) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeLine">    auto *Int32Ty = HVC.getIntTy(32);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">423</td>
    <td class="codeLine">    auto *Int32Ty = HVC.getIntTy(32);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeLine">    HvxI32Ty = HVC.getHvxTy(Int32Ty, /*Pair=*/false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">424</td>
    <td class="codeLine">    HvxI32Ty = HVC.getHvxTy(Int32Ty, /*Pair=*/false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeLine">    HvxP32Ty = HVC.getHvxTy(Int32Ty, /*Pair=*/true);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">425</td>
    <td class="codeLine">    HvxP32Ty = HVC.getHvxTy(Int32Ty, /*Pair=*/true);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">426</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">427</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeLine">  bool run();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">428</td>
    <td class="codeLine">  bool run();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">429</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">430</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeLine">  enum Signedness { Positive, Signed, Unsigned };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">431</td>
    <td class="codeLine">  enum Signedness { Positive, Signed, Unsigned };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">432</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeLine">  // Value + sign</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">433</td>
    <td class="codeLine">  // Value + sign</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeLine">  // This is to keep track of whether the value should be treated as signed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">434</td>
    <td class="codeLine">  // This is to keep track of whether the value should be treated as signed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeLine">  // or unsigned, or is known to be positive.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">435</td>
    <td class="codeLine">  // or unsigned, or is known to be positive.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeLine">  struct SValue {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">436</td>
    <td class="codeLine">  struct SValue {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeLine">    Value *Val;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">437</td>
    <td class="codeLine">    Value *Val;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeLine">    Signedness Sgn;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">438</td>
    <td class="codeLine">    Signedness Sgn;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">439</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">440</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeLine">  struct FxpOp {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">441</td>
    <td class="codeLine">  struct FxpOp {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeLine">    unsigned Opcode;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">442</td>
    <td class="codeLine">    unsigned Opcode;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeLine">    unsigned Frac; // Number of fraction bits</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">443</td>
    <td class="codeLine">    unsigned Frac; // Number of fraction bits</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeLine">    SValue X, Y;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">444</td>
    <td class="codeLine">    SValue X, Y;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeLine">    // If present, add 1 << RoundAt before shift:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">445</td>
    <td class="codeLine">    // If present, add 1 << RoundAt before shift:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeLine">    std::optional<unsigned> RoundAt;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">446</td>
    <td class="codeLine">    std::optional<unsigned> RoundAt;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeLine">    VectorType *ResTy;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">447</td>
    <td class="codeLine">    VectorType *ResTy;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">448</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">449</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeLine">  auto getNumSignificantBits(Value *V, Instruction *In) const</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">450</td>
    <td class="codeLine">  auto getNumSignificantBits(Value *V, Instruction *In) const</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeLine">      -> std::pair<unsigned, Signedness>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">451</td>
    <td class="codeLine">      -> std::pair<unsigned, Signedness>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeLine">  auto canonSgn(SValue X, SValue Y) const -> std::pair<SValue, SValue>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">452</td>
    <td class="codeLine">  auto canonSgn(SValue X, SValue Y) const -> std::pair<SValue, SValue>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">453</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeLine">  auto matchFxpMul(Instruction &In) const -> std::optional<FxpOp>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">454</td>
    <td class="codeLine">  auto matchFxpMul(Instruction &In) const -> std::optional<FxpOp>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeLine">  auto processFxpMul(Instruction &In, const FxpOp &Op) const -> Value *;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">455</td>
    <td class="codeLine">  auto processFxpMul(Instruction &In, const FxpOp &Op) const -> Value *;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">456</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeLine">  auto processFxpMulChopped(IRBuilderBase &Builder, Instruction &In,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">457</td>
    <td class="codeLine">  auto processFxpMulChopped(IRBuilderBase &Builder, Instruction &In,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeLine">                            const FxpOp &Op) const -> Value *;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">458</td>
    <td class="codeLine">                            const FxpOp &Op) const -> Value *;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeLine">  auto createMulQ15(IRBuilderBase &Builder, SValue X, SValue Y,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">459</td>
    <td class="codeLine">  auto createMulQ15(IRBuilderBase &Builder, SValue X, SValue Y,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeLine">                    bool Rounding) const -> Value *;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">460</td>
    <td class="codeLine">                    bool Rounding) const -> Value *;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeLine">  auto createMulQ31(IRBuilderBase &Builder, SValue X, SValue Y,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">461</td>
    <td class="codeLine">  auto createMulQ31(IRBuilderBase &Builder, SValue X, SValue Y,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeLine">                    bool Rounding) const -> Value *;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">462</td>
    <td class="codeLine">                    bool Rounding) const -> Value *;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeLine">  // Return {Result, Carry}, where Carry is a vector predicate.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">463</td>
    <td class="codeLine">  // Return {Result, Carry}, where Carry is a vector predicate.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeLine">  auto createAddCarry(IRBuilderBase &Builder, Value *X, Value *Y,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">464</td>
    <td class="codeLine">  auto createAddCarry(IRBuilderBase &Builder, Value *X, Value *Y,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeLine">                      Value *CarryIn = nullptr) const</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">465</td>
    <td class="codeLine">                      Value *CarryIn = nullptr) const</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeLine">      -> std::pair<Value *, Value *>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">466</td>
    <td class="codeLine">      -> std::pair<Value *, Value *>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeLine">  auto createMul16(IRBuilderBase &Builder, SValue X, SValue Y) const -> Value *;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">467</td>
    <td class="codeLine">  auto createMul16(IRBuilderBase &Builder, SValue X, SValue Y) const -> Value *;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeLine">  auto createMulH16(IRBuilderBase &Builder, SValue X, SValue Y) const</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">468</td>
    <td class="codeLine">  auto createMulH16(IRBuilderBase &Builder, SValue X, SValue Y) const</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeLine">      -> Value *;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">469</td>
    <td class="codeLine">      -> Value *;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeLine">  auto createMul32(IRBuilderBase &Builder, SValue X, SValue Y) const</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">470</td>
    <td class="codeLine">  auto createMul32(IRBuilderBase &Builder, SValue X, SValue Y) const</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeLine">      -> std::pair<Value *, Value *>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">471</td>
    <td class="codeLine">      -> std::pair<Value *, Value *>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeLine">  auto createAddLong(IRBuilderBase &Builder, ArrayRef<Value *> WordX,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">472</td>
    <td class="codeLine">  auto createAddLong(IRBuilderBase &Builder, ArrayRef<Value *> WordX,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeLine">                     ArrayRef<Value *> WordY) const -> SmallVector<Value *>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">473</td>
    <td class="codeLine">                     ArrayRef<Value *> WordY) const -> SmallVector<Value *>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeLine">  auto createMulLong(IRBuilderBase &Builder, ArrayRef<Value *> WordX,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">474</td>
    <td class="codeLine">  auto createMulLong(IRBuilderBase &Builder, ArrayRef<Value *> WordX,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeLine">                     Signedness SgnX, ArrayRef<Value *> WordY,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">475</td>
    <td class="codeLine">                     Signedness SgnX, ArrayRef<Value *> WordY,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeLine">                     Signedness SgnY) const -> SmallVector<Value *>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">476</td>
    <td class="codeLine">                     Signedness SgnY) const -> SmallVector<Value *>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">477</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeLine">  VectorType *HvxI32Ty;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">478</td>
    <td class="codeLine">  VectorType *HvxI32Ty;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeLine">  VectorType *HvxP32Ty;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">479</td>
    <td class="codeLine">  VectorType *HvxP32Ty;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeLine">  const HexagonVectorCombine &HVC;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">480</td>
    <td class="codeLine">  const HexagonVectorCombine &HVC;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">481</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeLine">  friend raw_ostream &operator<<(raw_ostream &, const FxpOp &);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">482</td>
    <td class="codeLine">  friend raw_ostream &operator<<(raw_ostream &, const FxpOp &);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">483</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">484</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeLine">[[maybe_unused]] raw_ostream &operator<<(raw_ostream &OS,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">485</td>
    <td class="codeLine">[[maybe_unused]] raw_ostream &operator<<(raw_ostream &OS,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeLine">                                         const HvxIdioms::FxpOp &Op) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">486</td>
    <td class="codeLine">                                         const HvxIdioms::FxpOp &Op) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeLine">  static const char *SgnNames[] = {"Positive", "Signed", "Unsigned"};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">487</td>
    <td class="codeLine">  static const char *SgnNames[] = {"Positive", "Signed", "Unsigned"};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeLine">  OS << Instruction::getOpcodeName(Op.Opcode) << '.' << Op.Frac;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">488</td>
    <td class="codeLine">  OS << Instruction::getOpcodeName(Op.Opcode) << '.' << Op.Frac;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeLine">  if (Op.RoundAt.has_value()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">489</td>
    <td class="codeLine">  if (Op.RoundAt.has_value()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeLine">    if (Op.Frac != 0 && *Op.RoundAt == Op.Frac - 1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">490</td>
    <td class="codeLine">    if (Op.Frac != 0 && *Op.RoundAt == Op.Frac - 1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeLine">      OS << ":rnd";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">491</td>
    <td class="codeLine">      OS << ":rnd";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">492</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeLine">      OS << " + 1<<" << *Op.RoundAt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">493</td>
    <td class="codeLine">      OS << " + 1<<" << *Op.RoundAt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">494</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">495</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeLine">  OS << "\n  X:(" << SgnNames[Op.X.Sgn] << ") " << *Op.X.Val << "\n"</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">496</td>
    <td class="codeLine">  OS << "\n  X:(" << SgnNames[Op.X.Sgn] << ") " << *Op.X.Val << "\n"</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeLine">     << "  Y:(" << SgnNames[Op.Y.Sgn] << ") " << *Op.Y.Val;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">497</td>
    <td class="codeLine">     << "  Y:(" << SgnNames[Op.Y.Sgn] << ") " << *Op.Y.Val;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeLine">  return OS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">498</td>
    <td class="codeLine">  return OS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">499</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">500</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeLine">} // namespace</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">501</td>
    <td class="codeLine">} // namespace</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">502</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">503</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">504</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeLine">template <typename T> T *getIfUnordered(T *MaybeT) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">505</td>
    <td class="codeLine">template <typename T> T *getIfUnordered(T *MaybeT) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeLine">  return MaybeT && MaybeT->isUnordered() ? MaybeT : nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">506</td>
    <td class="codeLine">  return MaybeT && MaybeT->isUnordered() ? MaybeT : nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">507</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeLine">template <typename T> T *isCandidate(Instruction *In) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">508</td>
    <td class="codeLine">template <typename T> T *isCandidate(Instruction *In) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeLine">  return dyn_cast<T>(In);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">509</td>
    <td class="codeLine">  return dyn_cast<T>(In);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">510</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeLine">template <> LoadInst *isCandidate<LoadInst>(Instruction *In) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">511</td>
    <td class="codeLine">template <> LoadInst *isCandidate<LoadInst>(Instruction *In) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeLine">  return getIfUnordered(dyn_cast<LoadInst>(In));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">512</td>
    <td class="codeLine">  return getIfUnordered(dyn_cast<LoadInst>(In));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">513</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeLine">template <> StoreInst *isCandidate<StoreInst>(Instruction *In) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">514</td>
    <td class="codeLine">template <> StoreInst *isCandidate<StoreInst>(Instruction *In) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeLine">  return getIfUnordered(dyn_cast<StoreInst>(In));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">515</td>
    <td class="codeLine">  return getIfUnordered(dyn_cast<StoreInst>(In));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">516</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">517</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeLine">#if !defined(_MSC_VER) || _MSC_VER >= 1926</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">518</td>
    <td class="codeLine">#if !defined(_MSC_VER) || _MSC_VER >= 1926</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeLine">// VS2017 and some versions of VS2019 have trouble compiling this:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">519</td>
    <td class="codeLine">// VS2017 and some versions of VS2019 have trouble compiling this:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeLine">// error C2976: 'std::map': too few template arguments</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">520</td>
    <td class="codeLine">// error C2976: 'std::map': too few template arguments</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeLine">// VS 2019 16.x is known to work, except for 16.4/16.5 (MSC_VER 1924/1925)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">521</td>
    <td class="codeLine">// VS 2019 16.x is known to work, except for 16.4/16.5 (MSC_VER 1924/1925)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeLine">template <typename Pred, typename... Ts></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">522</td>
    <td class="codeLine">template <typename Pred, typename... Ts></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeLine">void erase_if(std::map<Ts...> &map, Pred p)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">523</td>
    <td class="codeLine">void erase_if(std::map<Ts...> &map, Pred p)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeLine">#else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">524</td>
    <td class="codeLine">#else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeLine">template <typename Pred, typename T, typename U></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">525</td>
    <td class="codeLine">template <typename Pred, typename T, typename U></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeLine">void erase_if(std::map<T, U> &map, Pred p)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">526</td>
    <td class="codeLine">void erase_if(std::map<T, U> &map, Pred p)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">527</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeLine">{</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">528</td>
    <td class="codeLine">{</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeLine">  for (auto i = map.begin(), e = map.end(); i != e;) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">529</td>
    <td class="codeLine">  for (auto i = map.begin(), e = map.end(); i != e;) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeLine">    if (p(*i))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">530</td>
    <td class="codeLine">    if (p(*i))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeLine">      i = map.erase(i);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">531</td>
    <td class="codeLine">      i = map.erase(i);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">532</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeLine">      i = std::next(i);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">533</td>
    <td class="codeLine">      i = std::next(i);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">534</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">535</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">536</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeLine">// Forward other erase_ifs to the LLVM implementations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">537</td>
    <td class="codeLine">// Forward other erase_ifs to the LLVM implementations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeLine">template <typename Pred, typename T> void erase_if(T &&container, Pred p) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">538</td>
    <td class="codeLine">template <typename Pred, typename T> void erase_if(T &&container, Pred p) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeLine">  llvm::erase_if(std::forward<T>(container), p);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">539</td>
    <td class="codeLine">  llvm::erase_if(std::forward<T>(container), p);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">540</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">541</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeLine">} // namespace</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">542</td>
    <td class="codeLine">} // namespace</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">543</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeLine">// --- Begin AlignVectors</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">544</td>
    <td class="codeLine">// --- Begin AlignVectors</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">545</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeLine">// For brevity, only consider loads. We identify a group of loads where we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">546</td>
    <td class="codeLine">// For brevity, only consider loads. We identify a group of loads where we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeLine">// know the relative differences between their addresses, so we know how they</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">547</td>
    <td class="codeLine">// know the relative differences between their addresses, so we know how they</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeLine">// are laid out in memory (relative to one another). These loads can overlap,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">548</td>
    <td class="codeLine">// are laid out in memory (relative to one another). These loads can overlap,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeLine">// can be shorter or longer than the desired vector length.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">549</td>
    <td class="codeLine">// can be shorter or longer than the desired vector length.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeLine">// Ultimately we want to generate a sequence of aligned loads that will load</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">550</td>
    <td class="codeLine">// Ultimately we want to generate a sequence of aligned loads that will load</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeLine">// every byte that the original loads loaded, and have the program use these</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">551</td>
    <td class="codeLine">// every byte that the original loads loaded, and have the program use these</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeLine">// loaded values instead of the original loads.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">552</td>
    <td class="codeLine">// loaded values instead of the original loads.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeLine">// We consider the contiguous memory area spanned by all these loads.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">553</td>
    <td class="codeLine">// We consider the contiguous memory area spanned by all these loads.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">554</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeLine">// Let's say that a single aligned vector load can load 16 bytes at a time.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">555</td>
    <td class="codeLine">// Let's say that a single aligned vector load can load 16 bytes at a time.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeLine">// If the program wanted to use a byte at offset 13 from the beginning of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">556</td>
    <td class="codeLine">// If the program wanted to use a byte at offset 13 from the beginning of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeLine">// original span, it will be a byte at offset 13+x in the aligned data for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">557</td>
    <td class="codeLine">// original span, it will be a byte at offset 13+x in the aligned data for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeLine">// some x>=0. This may happen to be in the first aligned load, or in the load</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">558</td>
    <td class="codeLine">// some x>=0. This may happen to be in the first aligned load, or in the load</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeLine">// following it. Since we generally don't know what the that alignment value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">559</td>
    <td class="codeLine">// following it. Since we generally don't know what the that alignment value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeLine">// is at compile time, we proactively do valigns on the aligned loads, so that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">560</td>
    <td class="codeLine">// is at compile time, we proactively do valigns on the aligned loads, so that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeLine">// byte that was at offset 13 is still at offset 13 after the valigns.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">561</td>
    <td class="codeLine">// byte that was at offset 13 is still at offset 13 after the valigns.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">562</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeLine">// This will be the starting point for making the rest of the program use the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">563</td>
    <td class="codeLine">// This will be the starting point for making the rest of the program use the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeLine">// data loaded by the new loads.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">564</td>
    <td class="codeLine">// data loaded by the new loads.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeLine">// For each original load, and its users:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">565</td>
    <td class="codeLine">// For each original load, and its users:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeLine">//   %v = load ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">566</td>
    <td class="codeLine">//   %v = load ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeLine">//   ... = %v</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">567</td>
    <td class="codeLine">//   ... = %v</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeLine">//   ... = %v</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">568</td>
    <td class="codeLine">//   ... = %v</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeLine">// we create</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">569</td>
    <td class="codeLine">// we create</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeLine">//   %new_v = extract/combine/shuffle data from loaded/valigned vectors so</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">570</td>
    <td class="codeLine">//   %new_v = extract/combine/shuffle data from loaded/valigned vectors so</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeLine">//            it contains the same value as %v did before</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">571</td>
    <td class="codeLine">//            it contains the same value as %v did before</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeLine">// then replace all users of %v with %new_v.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">572</td>
    <td class="codeLine">// then replace all users of %v with %new_v.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeLine">//   ... = %new_v</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">573</td>
    <td class="codeLine">//   ... = %new_v</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeLine">//   ... = %new_v</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">574</td>
    <td class="codeLine">//   ... = %new_v</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">575</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeLine">auto AlignVectors::ByteSpan::extent() const -> int {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">576</td>
    <td class="codeLine">auto AlignVectors::ByteSpan::extent() const -> int {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeLine">  if (size() == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">577</td>
    <td class="codeLine">  if (size() == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">578</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeLine">  int Min = Blocks[0].Pos;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">579</td>
    <td class="codeLine">  int Min = Blocks[0].Pos;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeLine">  int Max = Blocks[0].Pos + Blocks[0].Seg.Size;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">580</td>
    <td class="codeLine">  int Max = Blocks[0].Pos + Blocks[0].Seg.Size;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeLine">  for (int i = 1, e = size(); i != e; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">581</td>
    <td class="codeLine">  for (int i = 1, e = size(); i != e; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeLine">    Min = std::min(Min, Blocks[i].Pos);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">582</td>
    <td class="codeLine">    Min = std::min(Min, Blocks[i].Pos);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeLine">    Max = std::max(Max, Blocks[i].Pos + Blocks[i].Seg.Size);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">583</td>
    <td class="codeLine">    Max = std::max(Max, Blocks[i].Pos + Blocks[i].Seg.Size);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">584</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeLine">  return Max - Min;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">585</td>
    <td class="codeLine">  return Max - Min;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">586</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">587</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeLine">auto AlignVectors::ByteSpan::section(int Start, int Length) const -> ByteSpan {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">588</td>
    <td class="codeLine">auto AlignVectors::ByteSpan::section(int Start, int Length) const -> ByteSpan {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeLine">  ByteSpan Section;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">589</td>
    <td class="codeLine">  ByteSpan Section;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeLine">  for (const ByteSpan::Block &B : Blocks) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">590</td>
    <td class="codeLine">  for (const ByteSpan::Block &B : Blocks) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeLine">    int L = std::max(B.Pos, Start);                       // Left end.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">591</td>
    <td class="codeLine">    int L = std::max(B.Pos, Start);                       // Left end.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeLine">    int R = std::min(B.Pos + B.Seg.Size, Start + Length); // Right end+1.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">592</td>
    <td class="codeLine">    int R = std::min(B.Pos + B.Seg.Size, Start + Length); // Right end+1.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeLine">    if (L < R) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">593</td>
    <td class="codeLine">    if (L < R) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeLine">      // How much to chop off the beginning of the segment:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">594</td>
    <td class="codeLine">      // How much to chop off the beginning of the segment:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeLine">      int Off = L > B.Pos ? L - B.Pos : 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">595</td>
    <td class="codeLine">      int Off = L > B.Pos ? L - B.Pos : 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeLine">      Section.Blocks.emplace_back(B.Seg.Val, B.Seg.Start + Off, R - L, L);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">596</td>
    <td class="codeLine">      Section.Blocks.emplace_back(B.Seg.Val, B.Seg.Start + Off, R - L, L);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">597</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">598</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeLine">  return Section;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">599</td>
    <td class="codeLine">  return Section;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">600</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">601</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeLine">auto AlignVectors::ByteSpan::shift(int Offset) -> ByteSpan & {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">602</td>
    <td class="codeLine">auto AlignVectors::ByteSpan::shift(int Offset) -> ByteSpan & {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeLine">  for (Block &B : Blocks)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">603</td>
    <td class="codeLine">  for (Block &B : Blocks)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeLine">    B.Pos += Offset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">604</td>
    <td class="codeLine">    B.Pos += Offset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeLine">  return *this;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">605</td>
    <td class="codeLine">  return *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">606</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">607</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeLine">auto AlignVectors::ByteSpan::values() const -> SmallVector<Value *, 8> {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">608</td>
    <td class="codeLine">auto AlignVectors::ByteSpan::values() const -> SmallVector<Value *, 8> {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeLine">  SmallVector<Value *, 8> Values(Blocks.size());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">609</td>
    <td class="codeLine">  SmallVector<Value *, 8> Values(Blocks.size());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeLine">  for (int i = 0, e = Blocks.size(); i != e; ++i)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">610</td>
    <td class="codeLine">  for (int i = 0, e = Blocks.size(); i != e; ++i)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeLine">    Values[i] = Blocks[i].Seg.Val;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">611</td>
    <td class="codeLine">    Values[i] = Blocks[i].Seg.Val;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeLine">  return Values;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">612</td>
    <td class="codeLine">  return Values;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">613</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">614</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeLine">auto AlignVectors::getAlignFromValue(const Value *V) const -> Align {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">615</td>
    <td class="codeLine">auto AlignVectors::getAlignFromValue(const Value *V) const -> Align {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeLine">  const auto *C = dyn_cast<ConstantInt>(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">616</td>
    <td class="codeLine">  const auto *C = dyn_cast<ConstantInt>(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeLine">  assert(C && "Alignment must be a compile-time constant integer");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">617</td>
    <td class="codeLine">  assert(C && "Alignment must be a compile-time constant integer");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeLine">  return C->getAlignValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">618</td>
    <td class="codeLine">  return C->getAlignValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">619</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">620</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeLine">auto AlignVectors::getAddrInfo(Instruction &In) const</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">621</td>
    <td class="codeLine">auto AlignVectors::getAddrInfo(Instruction &In) const</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeLine">    -> std::optional<AddrInfo> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">622</td>
    <td class="codeLine">    -> std::optional<AddrInfo> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeLine">  if (auto *L = isCandidate<LoadInst>(&In))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">623</td>
    <td class="codeLine">  if (auto *L = isCandidate<LoadInst>(&In))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeLine">    return AddrInfo(HVC, L, L->getPointerOperand(), L->getType(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">624</td>
    <td class="codeLine">    return AddrInfo(HVC, L, L->getPointerOperand(), L->getType(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeLine">                    L->getAlign());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">625</td>
    <td class="codeLine">                    L->getAlign());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeLine">  if (auto *S = isCandidate<StoreInst>(&In))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">626</td>
    <td class="codeLine">  if (auto *S = isCandidate<StoreInst>(&In))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeLine">    return AddrInfo(HVC, S, S->getPointerOperand(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">627</td>
    <td class="codeLine">    return AddrInfo(HVC, S, S->getPointerOperand(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeLine">                    S->getValueOperand()->getType(), S->getAlign());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">628</td>
    <td class="codeLine">                    S->getValueOperand()->getType(), S->getAlign());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeLine">  if (auto *II = isCandidate<IntrinsicInst>(&In)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">629</td>
    <td class="codeLine">  if (auto *II = isCandidate<IntrinsicInst>(&In)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeLine">    Intrinsic::ID ID = II->getIntrinsicID();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">630</td>
    <td class="codeLine">    Intrinsic::ID ID = II->getIntrinsicID();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeLine">    switch (ID) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">631</td>
    <td class="codeLine">    switch (ID) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeLine">    case Intrinsic::masked_load:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">632</td>
    <td class="codeLine">    case Intrinsic::masked_load:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeLine">      return AddrInfo(HVC, II, II->getArgOperand(0), II->getType(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">633</td>
    <td class="codeLine">      return AddrInfo(HVC, II, II->getArgOperand(0), II->getType(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeLine">                      getAlignFromValue(II->getArgOperand(1)));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">634</td>
    <td class="codeLine">                      getAlignFromValue(II->getArgOperand(1)));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeLine">    case Intrinsic::masked_store:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">635</td>
    <td class="codeLine">    case Intrinsic::masked_store:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeLine">      return AddrInfo(HVC, II, II->getArgOperand(1),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">636</td>
    <td class="codeLine">      return AddrInfo(HVC, II, II->getArgOperand(1),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeLine">                      II->getArgOperand(0)->getType(),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">637</td>
    <td class="codeLine">                      II->getArgOperand(0)->getType(),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeLine">                      getAlignFromValue(II->getArgOperand(2)));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">638</td>
    <td class="codeLine">                      getAlignFromValue(II->getArgOperand(2)));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">639</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">640</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeLine">  return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">641</td>
    <td class="codeLine">  return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">642</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">643</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeLine">auto AlignVectors::isHvx(const AddrInfo &AI) const -> bool {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">644</td>
    <td class="codeLine">auto AlignVectors::isHvx(const AddrInfo &AI) const -> bool {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeLine">  return HVC.HST.isTypeForHVX(AI.ValTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">645</td>
    <td class="codeLine">  return HVC.HST.isTypeForHVX(AI.ValTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">646</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">647</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeLine">auto AlignVectors::getPayload(Value *Val) const -> Value * {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">648</td>
    <td class="codeLine">auto AlignVectors::getPayload(Value *Val) const -> Value * {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeLine">  if (auto *In = dyn_cast<Instruction>(Val)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">649</td>
    <td class="codeLine">  if (auto *In = dyn_cast<Instruction>(Val)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeLine">    Intrinsic::ID ID = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">650</td>
    <td class="codeLine">    Intrinsic::ID ID = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeLine">    if (auto *II = dyn_cast<IntrinsicInst>(In))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">651</td>
    <td class="codeLine">    if (auto *II = dyn_cast<IntrinsicInst>(In))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeLine">      ID = II->getIntrinsicID();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">652</td>
    <td class="codeLine">      ID = II->getIntrinsicID();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeLine">    if (isa<StoreInst>(In) || ID == Intrinsic::masked_store)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">653</td>
    <td class="codeLine">    if (isa<StoreInst>(In) || ID == Intrinsic::masked_store)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeLine">      return In->getOperand(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">654</td>
    <td class="codeLine">      return In->getOperand(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">655</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeLine">  return Val;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">656</td>
    <td class="codeLine">  return Val;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">657</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">658</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeLine">auto AlignVectors::getMask(Value *Val) const -> Value * {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">659</td>
    <td class="codeLine">auto AlignVectors::getMask(Value *Val) const -> Value * {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeLine">  if (auto *II = dyn_cast<IntrinsicInst>(Val)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">660</td>
    <td class="codeLine">  if (auto *II = dyn_cast<IntrinsicInst>(Val)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeLine">    switch (II->getIntrinsicID()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">661</td>
    <td class="codeLine">    switch (II->getIntrinsicID()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeLine">    case Intrinsic::masked_load:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">662</td>
    <td class="codeLine">    case Intrinsic::masked_load:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeLine">      return II->getArgOperand(2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">663</td>
    <td class="codeLine">      return II->getArgOperand(2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeLine">    case Intrinsic::masked_store:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">664</td>
    <td class="codeLine">    case Intrinsic::masked_store:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeLine">      return II->getArgOperand(3);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">665</td>
    <td class="codeLine">      return II->getArgOperand(3);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">666</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">667</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">668</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeLine">  Type *ValTy = getPayload(Val)->getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">669</td>
    <td class="codeLine">  Type *ValTy = getPayload(Val)->getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeLine">  if (auto *VecTy = dyn_cast<VectorType>(ValTy))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">670</td>
    <td class="codeLine">  if (auto *VecTy = dyn_cast<VectorType>(ValTy))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeLine">    return HVC.getFullValue(HVC.getBoolTy(HVC.length(VecTy)));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">671</td>
    <td class="codeLine">    return HVC.getFullValue(HVC.getBoolTy(HVC.length(VecTy)));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeLine">  return HVC.getFullValue(HVC.getBoolTy());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">672</td>
    <td class="codeLine">  return HVC.getFullValue(HVC.getBoolTy());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">673</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">674</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeLine">auto AlignVectors::getPassThrough(Value *Val) const -> Value * {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">675</td>
    <td class="codeLine">auto AlignVectors::getPassThrough(Value *Val) const -> Value * {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeLine">  if (auto *II = dyn_cast<IntrinsicInst>(Val)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">676</td>
    <td class="codeLine">  if (auto *II = dyn_cast<IntrinsicInst>(Val)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeLine">    if (II->getIntrinsicID() == Intrinsic::masked_load)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">677</td>
    <td class="codeLine">    if (II->getIntrinsicID() == Intrinsic::masked_load)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeLine">      return II->getArgOperand(3);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">678</td>
    <td class="codeLine">      return II->getArgOperand(3);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">679</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeLine">  return UndefValue::get(getPayload(Val)->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">680</td>
    <td class="codeLine">  return UndefValue::get(getPayload(Val)->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">681</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">682</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeLine">auto AlignVectors::createAdjustedPointer(IRBuilderBase &Builder, Value *Ptr,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">683</td>
    <td class="codeLine">auto AlignVectors::createAdjustedPointer(IRBuilderBase &Builder, Value *Ptr,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeLine">                                         Type *ValTy, int Adjust,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">684</td>
    <td class="codeLine">                                         Type *ValTy, int Adjust,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeLine">                                         const InstMap &CloneMap) const</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">685</td>
    <td class="codeLine">                                         const InstMap &CloneMap) const</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeLine">    -> Value * {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">686</td>
    <td class="codeLine">    -> Value * {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeLine">  if (auto *I = dyn_cast<Instruction>(Ptr))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">687</td>
    <td class="codeLine">  if (auto *I = dyn_cast<Instruction>(Ptr))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeLine">    if (Instruction *New = CloneMap.lookup(I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">688</td>
    <td class="codeLine">    if (Instruction *New = CloneMap.lookup(I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeLine">      Ptr = New;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">689</td>
    <td class="codeLine">      Ptr = New;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeLine">  return Builder.CreateGEP(Type::getInt8Ty(HVC.F.getContext()), Ptr,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">690</td>
    <td class="codeLine">  return Builder.CreateGEP(Type::getInt8Ty(HVC.F.getContext()), Ptr,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeLine">                           HVC.getConstInt(Adjust), "gep");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">691</td>
    <td class="codeLine">                           HVC.getConstInt(Adjust), "gep");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">692</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">693</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeLine">auto AlignVectors::createAlignedPointer(IRBuilderBase &Builder, Value *Ptr,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">694</td>
    <td class="codeLine">auto AlignVectors::createAlignedPointer(IRBuilderBase &Builder, Value *Ptr,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeLine">                                        Type *ValTy, int Alignment,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">695</td>
    <td class="codeLine">                                        Type *ValTy, int Alignment,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeLine">                                        const InstMap &CloneMap) const</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">696</td>
    <td class="codeLine">                                        const InstMap &CloneMap) const</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeLine">    -> Value * {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">697</td>
    <td class="codeLine">    -> Value * {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeLine">  auto remap = [&](Value *V) -> Value * {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">698</td>
    <td class="codeLine">  auto remap = [&](Value *V) -> Value * {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeLine">    if (auto *I = dyn_cast<Instruction>(V)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">699</td>
    <td class="codeLine">    if (auto *I = dyn_cast<Instruction>(V)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeLine">      for (auto [Old, New] : CloneMap)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">700</td>
    <td class="codeLine">      for (auto [Old, New] : CloneMap)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeLine">        I->replaceUsesOfWith(Old, New);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">701</td>
    <td class="codeLine">        I->replaceUsesOfWith(Old, New);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeLine">      return I;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">702</td>
    <td class="codeLine">      return I;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">703</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeLine">    return V;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">704</td>
    <td class="codeLine">    return V;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">705</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeLine">  Value *AsInt = Builder.CreatePtrToInt(Ptr, HVC.getIntTy(), "pti");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">706</td>
    <td class="codeLine">  Value *AsInt = Builder.CreatePtrToInt(Ptr, HVC.getIntTy(), "pti");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeLine">  Value *Mask = HVC.getConstInt(-Alignment);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">707</td>
    <td class="codeLine">  Value *Mask = HVC.getConstInt(-Alignment);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeLine">  Value *And = Builder.CreateAnd(remap(AsInt), Mask, "and");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">708</td>
    <td class="codeLine">  Value *And = Builder.CreateAnd(remap(AsInt), Mask, "and");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeLine">  return Builder.CreateIntToPtr(And, ValTy->getPointerTo(), "itp");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">709</td>
    <td class="codeLine">  return Builder.CreateIntToPtr(And, ValTy->getPointerTo(), "itp");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">710</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">711</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeLine">auto AlignVectors::createLoad(IRBuilderBase &Builder, Type *ValTy, Value *Ptr,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">712</td>
    <td class="codeLine">auto AlignVectors::createLoad(IRBuilderBase &Builder, Type *ValTy, Value *Ptr,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeLine">                              Value *Predicate, int Alignment, Value *Mask,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">713</td>
    <td class="codeLine">                              Value *Predicate, int Alignment, Value *Mask,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeLine">                              Value *PassThru,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">714</td>
    <td class="codeLine">                              Value *PassThru,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeLine">                              ArrayRef<Value *> MDSources) const -> Value * {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">715</td>
    <td class="codeLine">                              ArrayRef<Value *> MDSources) const -> Value * {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeLine">  bool HvxHasPredLoad = HVC.HST.useHVXV62Ops();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">716</td>
    <td class="codeLine">  bool HvxHasPredLoad = HVC.HST.useHVXV62Ops();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeLine">  // Predicate is nullptr if not creating predicated load</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">717</td>
    <td class="codeLine">  // Predicate is nullptr if not creating predicated load</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeLine">  if (Predicate) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">718</td>
    <td class="codeLine">  if (Predicate) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeLine">    assert(!Predicate->getType()->isVectorTy() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">719</td>
    <td class="codeLine">    assert(!Predicate->getType()->isVectorTy() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeLine">           "Expectning scalar predicate");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">720</td>
    <td class="codeLine">           "Expectning scalar predicate");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeLine">    if (HVC.isFalse(Predicate))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">721</td>
    <td class="codeLine">    if (HVC.isFalse(Predicate))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeLine">      return UndefValue::get(ValTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">722</td>
    <td class="codeLine">      return UndefValue::get(ValTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeLine">    if (!HVC.isTrue(Predicate) && HvxHasPredLoad) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">723</td>
    <td class="codeLine">    if (!HVC.isTrue(Predicate) && HvxHasPredLoad) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeLine">      Value *Load = createPredicatedLoad(Builder, ValTy, Ptr, Predicate,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">724</td>
    <td class="codeLine">      Value *Load = createPredicatedLoad(Builder, ValTy, Ptr, Predicate,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeLine">                                         Alignment, MDSources);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">725</td>
    <td class="codeLine">                                         Alignment, MDSources);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeLine">      return Builder.CreateSelect(Mask, Load, PassThru);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">726</td>
    <td class="codeLine">      return Builder.CreateSelect(Mask, Load, PassThru);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">727</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeLine">    // Predicate == true here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">728</td>
    <td class="codeLine">    // Predicate == true here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">729</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeLine">  assert(!HVC.isUndef(Mask)); // Should this be allowed?</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">730</td>
    <td class="codeLine">  assert(!HVC.isUndef(Mask)); // Should this be allowed?</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeLine">  if (HVC.isZero(Mask))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">731</td>
    <td class="codeLine">  if (HVC.isZero(Mask))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeLine">    return PassThru;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">732</td>
    <td class="codeLine">    return PassThru;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeLine">  if (HVC.isTrue(Mask))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">733</td>
    <td class="codeLine">  if (HVC.isTrue(Mask))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeLine">    return createSimpleLoad(Builder, ValTy, Ptr, Alignment, MDSources);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">734</td>
    <td class="codeLine">    return createSimpleLoad(Builder, ValTy, Ptr, Alignment, MDSources);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">735</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeLine">  Instruction *Load = Builder.CreateMaskedLoad(ValTy, Ptr, Align(Alignment),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">736</td>
    <td class="codeLine">  Instruction *Load = Builder.CreateMaskedLoad(ValTy, Ptr, Align(Alignment),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeLine">                                               Mask, PassThru, "mld");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">737</td>
    <td class="codeLine">                                               Mask, PassThru, "mld");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeLine">  propagateMetadata(Load, MDSources);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">738</td>
    <td class="codeLine">  propagateMetadata(Load, MDSources);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeLine">  return Load;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">739</td>
    <td class="codeLine">  return Load;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">740</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">741</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeLine">auto AlignVectors::createSimpleLoad(IRBuilderBase &Builder, Type *ValTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">742</td>
    <td class="codeLine">auto AlignVectors::createSimpleLoad(IRBuilderBase &Builder, Type *ValTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeLine">                                    Value *Ptr, int Alignment,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">743</td>
    <td class="codeLine">                                    Value *Ptr, int Alignment,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeLine">                                    ArrayRef<Value *> MDSources) const</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">744</td>
    <td class="codeLine">                                    ArrayRef<Value *> MDSources) const</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeLine">    -> Value * {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">745</td>
    <td class="codeLine">    -> Value * {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeLine">  Instruction *Load =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">746</td>
    <td class="codeLine">  Instruction *Load =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeLine">      Builder.CreateAlignedLoad(ValTy, Ptr, Align(Alignment), "ald");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">747</td>
    <td class="codeLine">      Builder.CreateAlignedLoad(ValTy, Ptr, Align(Alignment), "ald");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeLine">  propagateMetadata(Load, MDSources);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">748</td>
    <td class="codeLine">  propagateMetadata(Load, MDSources);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeLine">  return Load;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">749</td>
    <td class="codeLine">  return Load;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">750</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">751</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeLine">auto AlignVectors::createPredicatedLoad(IRBuilderBase &Builder, Type *ValTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">752</td>
    <td class="codeLine">auto AlignVectors::createPredicatedLoad(IRBuilderBase &Builder, Type *ValTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeLine">                                        Value *Ptr, Value *Predicate,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">753</td>
    <td class="codeLine">                                        Value *Ptr, Value *Predicate,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeLine">                                        int Alignment,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">754</td>
    <td class="codeLine">                                        int Alignment,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeLine">                                        ArrayRef<Value *> MDSources) const</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">755</td>
    <td class="codeLine">                                        ArrayRef<Value *> MDSources) const</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeLine">    -> Value * {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">756</td>
    <td class="codeLine">    -> Value * {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeLine">  assert(HVC.HST.isTypeForHVX(ValTy) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">757</td>
    <td class="codeLine">  assert(HVC.HST.isTypeForHVX(ValTy) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeLine">         "Predicates 'scalar' vector loads not yet supported");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">758</td>
    <td class="codeLine">         "Predicates 'scalar' vector loads not yet supported");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeLine">  assert(Predicate);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">759</td>
    <td class="codeLine">  assert(Predicate);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeLine">  assert(!Predicate->getType()->isVectorTy() && "Expectning scalar predicate");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">760</td>
    <td class="codeLine">  assert(!Predicate->getType()->isVectorTy() && "Expectning scalar predicate");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeLine">  assert(HVC.getSizeOf(ValTy, HVC.Alloc) % Alignment == 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">761</td>
    <td class="codeLine">  assert(HVC.getSizeOf(ValTy, HVC.Alloc) % Alignment == 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeLine">  if (HVC.isFalse(Predicate))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">762</td>
    <td class="codeLine">  if (HVC.isFalse(Predicate))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeLine">    return UndefValue::get(ValTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">763</td>
    <td class="codeLine">    return UndefValue::get(ValTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeLine">  if (HVC.isTrue(Predicate))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">764</td>
    <td class="codeLine">  if (HVC.isTrue(Predicate))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeLine">    return createSimpleLoad(Builder, ValTy, Ptr, Alignment, MDSources);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">765</td>
    <td class="codeLine">    return createSimpleLoad(Builder, ValTy, Ptr, Alignment, MDSources);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">766</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeLine">  auto V6_vL32b_pred_ai = HVC.HST.getIntrinsicId(Hexagon::V6_vL32b_pred_ai);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">767</td>
    <td class="codeLine">  auto V6_vL32b_pred_ai = HVC.HST.getIntrinsicId(Hexagon::V6_vL32b_pred_ai);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeLine">  // FIXME: This may not put the offset from Ptr into the vmem offset.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">768</td>
    <td class="codeLine">  // FIXME: This may not put the offset from Ptr into the vmem offset.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeLine">  return HVC.createHvxIntrinsic(Builder, V6_vL32b_pred_ai, ValTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">769</td>
    <td class="codeLine">  return HVC.createHvxIntrinsic(Builder, V6_vL32b_pred_ai, ValTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeLine">                                {Predicate, Ptr, HVC.getConstInt(0)},</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">770</td>
    <td class="codeLine">                                {Predicate, Ptr, HVC.getConstInt(0)},</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeLine">                                std::nullopt, MDSources);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">771</td>
    <td class="codeLine">                                std::nullopt, MDSources);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">772</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">773</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeLine">auto AlignVectors::createStore(IRBuilderBase &Builder, Value *Val, Value *Ptr,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">774</td>
    <td class="codeLine">auto AlignVectors::createStore(IRBuilderBase &Builder, Value *Val, Value *Ptr,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeLine">                               Value *Predicate, int Alignment, Value *Mask,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">775</td>
    <td class="codeLine">                               Value *Predicate, int Alignment, Value *Mask,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeLine">                               ArrayRef<Value *> MDSources) const -> Value * {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">776</td>
    <td class="codeLine">                               ArrayRef<Value *> MDSources) const -> Value * {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeLine">  if (HVC.isZero(Mask) || HVC.isUndef(Val) || HVC.isUndef(Mask))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">777</td>
    <td class="codeLine">  if (HVC.isZero(Mask) || HVC.isUndef(Val) || HVC.isUndef(Mask))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeLine">    return UndefValue::get(Val->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">778</td>
    <td class="codeLine">    return UndefValue::get(Val->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeLine">  assert(!Predicate || (!Predicate->getType()->isVectorTy() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">779</td>
    <td class="codeLine">  assert(!Predicate || (!Predicate->getType()->isVectorTy() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeLine">                        "Expectning scalar predicate"));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">780</td>
    <td class="codeLine">                        "Expectning scalar predicate"));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeLine">  if (Predicate) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">781</td>
    <td class="codeLine">  if (Predicate) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeLine">    if (HVC.isFalse(Predicate))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">782</td>
    <td class="codeLine">    if (HVC.isFalse(Predicate))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeLine">      return UndefValue::get(Val->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">783</td>
    <td class="codeLine">      return UndefValue::get(Val->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeLine">    if (HVC.isTrue(Predicate))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">784</td>
    <td class="codeLine">    if (HVC.isTrue(Predicate))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeLine">      Predicate = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">785</td>
    <td class="codeLine">      Predicate = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">786</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeLine">  // Here both Predicate and Mask are true or unknown.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">787</td>
    <td class="codeLine">  // Here both Predicate and Mask are true or unknown.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">788</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeLine">  if (HVC.isTrue(Mask)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">789</td>
    <td class="codeLine">  if (HVC.isTrue(Mask)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeLine">    if (Predicate) { // Predicate unknown</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">790</td>
    <td class="codeLine">    if (Predicate) { // Predicate unknown</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeLine">      return createPredicatedStore(Builder, Val, Ptr, Predicate, Alignment,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">791</td>
    <td class="codeLine">      return createPredicatedStore(Builder, Val, Ptr, Predicate, Alignment,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeLine">                                   MDSources);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">792</td>
    <td class="codeLine">                                   MDSources);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">793</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeLine">    // Predicate is true:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">794</td>
    <td class="codeLine">    // Predicate is true:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeLine">    return createSimpleStore(Builder, Val, Ptr, Alignment, MDSources);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">795</td>
    <td class="codeLine">    return createSimpleStore(Builder, Val, Ptr, Alignment, MDSources);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">796</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">797</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeLine">  // Mask is unknown</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">798</td>
    <td class="codeLine">  // Mask is unknown</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeLine">  if (!Predicate) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">799</td>
    <td class="codeLine">  if (!Predicate) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeLine">    Instruction *Store =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">800</td>
    <td class="codeLine">    Instruction *Store =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeLine">        Builder.CreateMaskedStore(Val, Ptr, Align(Alignment), Mask);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">801</td>
    <td class="codeLine">        Builder.CreateMaskedStore(Val, Ptr, Align(Alignment), Mask);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeLine">    propagateMetadata(Store, MDSources);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">802</td>
    <td class="codeLine">    propagateMetadata(Store, MDSources);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeLine">    return Store;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">803</td>
    <td class="codeLine">    return Store;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">804</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">805</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeLine">  // Both Predicate and Mask are unknown.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">806</td>
    <td class="codeLine">  // Both Predicate and Mask are unknown.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeLine">  // Emulate masked store with predicated-load + mux + predicated-store.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">807</td>
    <td class="codeLine">  // Emulate masked store with predicated-load + mux + predicated-store.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeLine">  Value *PredLoad = createPredicatedLoad(Builder, Val->getType(), Ptr,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">808</td>
    <td class="codeLine">  Value *PredLoad = createPredicatedLoad(Builder, Val->getType(), Ptr,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeLine">                                         Predicate, Alignment, MDSources);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">809</td>
    <td class="codeLine">                                         Predicate, Alignment, MDSources);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeLine">  Value *Mux = Builder.CreateSelect(Mask, Val, PredLoad);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">810</td>
    <td class="codeLine">  Value *Mux = Builder.CreateSelect(Mask, Val, PredLoad);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeLine">  return createPredicatedStore(Builder, Mux, Ptr, Predicate, Alignment,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">811</td>
    <td class="codeLine">  return createPredicatedStore(Builder, Mux, Ptr, Predicate, Alignment,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeLine">                               MDSources);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">812</td>
    <td class="codeLine">                               MDSources);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">813</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">814</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeLine">auto AlignVectors::createSimpleStore(IRBuilderBase &Builder, Value *Val,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">815</td>
    <td class="codeLine">auto AlignVectors::createSimpleStore(IRBuilderBase &Builder, Value *Val,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeLine">                                     Value *Ptr, int Alignment,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">816</td>
    <td class="codeLine">                                     Value *Ptr, int Alignment,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeLine">                                     ArrayRef<Value *> MDSources) const</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">817</td>
    <td class="codeLine">                                     ArrayRef<Value *> MDSources) const</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeLine">    -> Value * {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">818</td>
    <td class="codeLine">    -> Value * {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeLine">  Instruction *Store = Builder.CreateAlignedStore(Val, Ptr, Align(Alignment));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">819</td>
    <td class="codeLine">  Instruction *Store = Builder.CreateAlignedStore(Val, Ptr, Align(Alignment));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeLine">  propagateMetadata(Store, MDSources);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">820</td>
    <td class="codeLine">  propagateMetadata(Store, MDSources);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeLine">  return Store;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">821</td>
    <td class="codeLine">  return Store;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">822</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">823</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeLine">auto AlignVectors::createPredicatedStore(IRBuilderBase &Builder, Value *Val,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">824</td>
    <td class="codeLine">auto AlignVectors::createPredicatedStore(IRBuilderBase &Builder, Value *Val,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeLine">                                         Value *Ptr, Value *Predicate,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">825</td>
    <td class="codeLine">                                         Value *Ptr, Value *Predicate,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeLine">                                         int Alignment,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">826</td>
    <td class="codeLine">                                         int Alignment,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeLine">                                         ArrayRef<Value *> MDSources) const</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">827</td>
    <td class="codeLine">                                         ArrayRef<Value *> MDSources) const</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeLine">    -> Value * {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">828</td>
    <td class="codeLine">    -> Value * {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeLine">  assert(HVC.HST.isTypeForHVX(Val->getType()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">829</td>
    <td class="codeLine">  assert(HVC.HST.isTypeForHVX(Val->getType()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeLine">         "Predicates 'scalar' vector stores not yet supported");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">830</td>
    <td class="codeLine">         "Predicates 'scalar' vector stores not yet supported");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeLine">  assert(Predicate);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">831</td>
    <td class="codeLine">  assert(Predicate);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeLine">  if (HVC.isFalse(Predicate))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">832</td>
    <td class="codeLine">  if (HVC.isFalse(Predicate))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeLine">    return UndefValue::get(Val->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">833</td>
    <td class="codeLine">    return UndefValue::get(Val->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeLine">  if (HVC.isTrue(Predicate))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">834</td>
    <td class="codeLine">  if (HVC.isTrue(Predicate))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeLine">    return createSimpleStore(Builder, Val, Ptr, Alignment, MDSources);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">835</td>
    <td class="codeLine">    return createSimpleStore(Builder, Val, Ptr, Alignment, MDSources);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">836</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeLine">  assert(HVC.getSizeOf(Val, HVC.Alloc) % Alignment == 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">837</td>
    <td class="codeLine">  assert(HVC.getSizeOf(Val, HVC.Alloc) % Alignment == 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeLine">  auto V6_vS32b_pred_ai = HVC.HST.getIntrinsicId(Hexagon::V6_vS32b_pred_ai);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">838</td>
    <td class="codeLine">  auto V6_vS32b_pred_ai = HVC.HST.getIntrinsicId(Hexagon::V6_vS32b_pred_ai);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeLine">  // FIXME: This may not put the offset from Ptr into the vmem offset.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">839</td>
    <td class="codeLine">  // FIXME: This may not put the offset from Ptr into the vmem offset.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeLine">  return HVC.createHvxIntrinsic(Builder, V6_vS32b_pred_ai, nullptr,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">840</td>
    <td class="codeLine">  return HVC.createHvxIntrinsic(Builder, V6_vS32b_pred_ai, nullptr,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeLine">                                {Predicate, Ptr, HVC.getConstInt(0), Val},</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">841</td>
    <td class="codeLine">                                {Predicate, Ptr, HVC.getConstInt(0), Val},</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeLine">                                std::nullopt, MDSources);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">842</td>
    <td class="codeLine">                                std::nullopt, MDSources);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">843</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">844</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeLine">auto AlignVectors::getUpwardDeps(Instruction *In, Instruction *Base) const</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">845</td>
    <td class="codeLine">auto AlignVectors::getUpwardDeps(Instruction *In, Instruction *Base) const</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeLine">    -> DepList {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">846</td>
    <td class="codeLine">    -> DepList {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeLine">  BasicBlock *Parent = Base->getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">847</td>
    <td class="codeLine">  BasicBlock *Parent = Base->getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeLine">  assert(In->getParent() == Parent &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">848</td>
    <td class="codeLine">  assert(In->getParent() == Parent &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeLine">         "Base and In should be in the same block");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">849</td>
    <td class="codeLine">         "Base and In should be in the same block");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeLine">  assert(Base->comesBefore(In) && "Base should come before In");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">850</td>
    <td class="codeLine">  assert(Base->comesBefore(In) && "Base should come before In");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">851</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeLine">  DepList Deps;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">852</td>
    <td class="codeLine">  DepList Deps;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeLine">  std::deque<Instruction *> WorkQ = {In};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">853</td>
    <td class="codeLine">  std::deque<Instruction *> WorkQ = {In};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeLine">  while (!WorkQ.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">854</td>
    <td class="codeLine">  while (!WorkQ.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeLine">    Instruction *D = WorkQ.front();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">855</td>
    <td class="codeLine">    Instruction *D = WorkQ.front();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeLine">    WorkQ.pop_front();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">856</td>
    <td class="codeLine">    WorkQ.pop_front();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeLine">    if (D != In)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">857</td>
    <td class="codeLine">    if (D != In)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeLine">      Deps.insert(D);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">858</td>
    <td class="codeLine">      Deps.insert(D);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeLine">    for (Value *Op : D->operands()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">859</td>
    <td class="codeLine">    for (Value *Op : D->operands()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeLine">      if (auto *I = dyn_cast<Instruction>(Op)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">860</td>
    <td class="codeLine">      if (auto *I = dyn_cast<Instruction>(Op)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeLine">        if (I->getParent() == Parent && Base->comesBefore(I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">861</td>
    <td class="codeLine">        if (I->getParent() == Parent && Base->comesBefore(I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeLine">          WorkQ.push_back(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">862</td>
    <td class="codeLine">          WorkQ.push_back(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">863</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">864</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">865</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeLine">  return Deps;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">866</td>
    <td class="codeLine">  return Deps;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">867</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">868</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeLine">auto AlignVectors::createAddressGroups() -> bool {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">869</td>
    <td class="codeLine">auto AlignVectors::createAddressGroups() -> bool {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeLine">  // An address group created here may contain instructions spanning</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">870</td>
    <td class="codeLine">  // An address group created here may contain instructions spanning</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeLine">  // multiple basic blocks.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">871</td>
    <td class="codeLine">  // multiple basic blocks.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeLine">  AddrList WorkStack;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">872</td>
    <td class="codeLine">  AddrList WorkStack;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">873</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeLine">  auto findBaseAndOffset = [&](AddrInfo &AI) -> std::pair<Instruction *, int> {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">874</td>
    <td class="codeLine">  auto findBaseAndOffset = [&](AddrInfo &AI) -> std::pair<Instruction *, int> {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeLine">    for (AddrInfo &W : WorkStack) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">875</td>
    <td class="codeLine">    for (AddrInfo &W : WorkStack) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeLine">      if (auto D = HVC.calculatePointerDifference(AI.Addr, W.Addr))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">876</td>
    <td class="codeLine">      if (auto D = HVC.calculatePointerDifference(AI.Addr, W.Addr))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeLine">        return std::make_pair(W.Inst, *D);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">877</td>
    <td class="codeLine">        return std::make_pair(W.Inst, *D);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">878</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeLine">    return std::make_pair(nullptr, 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">879</td>
    <td class="codeLine">    return std::make_pair(nullptr, 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">880</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">881</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeLine">  auto traverseBlock = [&](DomTreeNode *DomN, auto Visit) -> void {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">882</td>
    <td class="codeLine">  auto traverseBlock = [&](DomTreeNode *DomN, auto Visit) -> void {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeLine">    BasicBlock &Block = *DomN->getBlock();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">883</td>
    <td class="codeLine">    BasicBlock &Block = *DomN->getBlock();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeLine">    for (Instruction &I : Block) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">884</td>
    <td class="codeLine">    for (Instruction &I : Block) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeLine">      auto AI = this->getAddrInfo(I); // Use this-> for gcc6.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">885</td>
    <td class="codeLine">      auto AI = this->getAddrInfo(I); // Use this-> for gcc6.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeLine">      if (!AI)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">886</td>
    <td class="codeLine">      if (!AI)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">887</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeLine">      auto F = findBaseAndOffset(*AI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">888</td>
    <td class="codeLine">      auto F = findBaseAndOffset(*AI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeLine">      Instruction *GroupInst;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">889</td>
    <td class="codeLine">      Instruction *GroupInst;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeLine">      if (Instruction *BI = F.first) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">890</td>
    <td class="codeLine">      if (Instruction *BI = F.first) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeLine">        AI->Offset = F.second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">891</td>
    <td class="codeLine">        AI->Offset = F.second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeLine">        GroupInst = BI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">892</td>
    <td class="codeLine">        GroupInst = BI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">893</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeLine">        WorkStack.push_back(*AI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">894</td>
    <td class="codeLine">        WorkStack.push_back(*AI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeLine">        GroupInst = AI->Inst;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">895</td>
    <td class="codeLine">        GroupInst = AI->Inst;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">896</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeLine">      AddrGroups[GroupInst].push_back(*AI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">897</td>
    <td class="codeLine">      AddrGroups[GroupInst].push_back(*AI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">898</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">899</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeLine">    for (DomTreeNode *C : DomN->children())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">900</td>
    <td class="codeLine">    for (DomTreeNode *C : DomN->children())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeLine">      Visit(C, Visit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">901</td>
    <td class="codeLine">      Visit(C, Visit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">902</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeLine">    while (!WorkStack.empty() && WorkStack.back().Inst->getParent() == &Block)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">903</td>
    <td class="codeLine">    while (!WorkStack.empty() && WorkStack.back().Inst->getParent() == &Block)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeLine">      WorkStack.pop_back();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">904</td>
    <td class="codeLine">      WorkStack.pop_back();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">905</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">906</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeLine">  traverseBlock(HVC.DT.getRootNode(), traverseBlock);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">907</td>
    <td class="codeLine">  traverseBlock(HVC.DT.getRootNode(), traverseBlock);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeLine">  assert(WorkStack.empty());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">908</td>
    <td class="codeLine">  assert(WorkStack.empty());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">909</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeLine">  // AddrGroups are formed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">910</td>
    <td class="codeLine">  // AddrGroups are formed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">911</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeLine">  // Remove groups of size 1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">912</td>
    <td class="codeLine">  // Remove groups of size 1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeLine">  erase_if(AddrGroups, [](auto &G) { return G.second.size() == 1; });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">913</td>
    <td class="codeLine">  erase_if(AddrGroups, [](auto &G) { return G.second.size() == 1; });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeLine">  // Remove groups that don't use HVX types.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">914</td>
    <td class="codeLine">  // Remove groups that don't use HVX types.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeLine">  erase_if(AddrGroups, [&](auto &G) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">915</td>
    <td class="codeLine">  erase_if(AddrGroups, [&](auto &G) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeLine">    return llvm::none_of(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">916</td>
    <td class="codeLine">    return llvm::none_of(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeLine">        G.second, [&](auto &I) { return HVC.HST.isTypeForHVX(I.ValTy); });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">917</td>
    <td class="codeLine">        G.second, [&](auto &I) { return HVC.HST.isTypeForHVX(I.ValTy); });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">918</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">919</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeLine">  return !AddrGroups.empty();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">920</td>
    <td class="codeLine">  return !AddrGroups.empty();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">921</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">922</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeLine">auto AlignVectors::createLoadGroups(const AddrList &Group) const -> MoveList {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">923</td>
    <td class="codeLine">auto AlignVectors::createLoadGroups(const AddrList &Group) const -> MoveList {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeLine">  // Form load groups.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">924</td>
    <td class="codeLine">  // Form load groups.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeLine">  // To avoid complications with moving code across basic blocks, only form</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">925</td>
    <td class="codeLine">  // To avoid complications with moving code across basic blocks, only form</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeLine">  // groups that are contained within a single basic block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">926</td>
    <td class="codeLine">  // groups that are contained within a single basic block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeLine">  unsigned SizeLimit = VAGroupSizeLimit;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">927</td>
    <td class="codeLine">  unsigned SizeLimit = VAGroupSizeLimit;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeLine">  if (SizeLimit == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">928</td>
    <td class="codeLine">  if (SizeLimit == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeLine">    return {};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">929</td>
    <td class="codeLine">    return {};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">930</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeLine">  auto tryAddTo = [&](const AddrInfo &Info, MoveGroup &Move) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">931</td>
    <td class="codeLine">  auto tryAddTo = [&](const AddrInfo &Info, MoveGroup &Move) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeLine">    assert(!Move.Main.empty() && "Move group should have non-empty Main");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">932</td>
    <td class="codeLine">    assert(!Move.Main.empty() && "Move group should have non-empty Main");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeLine">    if (Move.Main.size() >= SizeLimit)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">933</td>
    <td class="codeLine">    if (Move.Main.size() >= SizeLimit)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">934</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeLine">    // Don't mix HVX and non-HVX instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">935</td>
    <td class="codeLine">    // Don't mix HVX and non-HVX instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeLine">    if (Move.IsHvx != isHvx(Info))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">936</td>
    <td class="codeLine">    if (Move.IsHvx != isHvx(Info))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">937</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeLine">    // Leading instruction in the load group.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">938</td>
    <td class="codeLine">    // Leading instruction in the load group.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeLine">    Instruction *Base = Move.Main.front();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">939</td>
    <td class="codeLine">    Instruction *Base = Move.Main.front();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeLine">    if (Base->getParent() != Info.Inst->getParent())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">940</td>
    <td class="codeLine">    if (Base->getParent() != Info.Inst->getParent())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">941</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeLine">    // Check if it's safe to move the load.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">942</td>
    <td class="codeLine">    // Check if it's safe to move the load.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeLine">    if (!HVC.isSafeToMoveBeforeInBB(*Info.Inst, Base->getIterator()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">943</td>
    <td class="codeLine">    if (!HVC.isSafeToMoveBeforeInBB(*Info.Inst, Base->getIterator()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">944</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeLine">    // And if it's safe to clone the dependencies.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">945</td>
    <td class="codeLine">    // And if it's safe to clone the dependencies.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeLine">    auto isSafeToCopyAtBase = [&](const Instruction *I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">946</td>
    <td class="codeLine">    auto isSafeToCopyAtBase = [&](const Instruction *I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeLine">      return HVC.isSafeToMoveBeforeInBB(*I, Base->getIterator()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">947</td>
    <td class="codeLine">      return HVC.isSafeToMoveBeforeInBB(*I, Base->getIterator()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeLine">             HVC.isSafeToClone(*I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">948</td>
    <td class="codeLine">             HVC.isSafeToClone(*I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">949</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeLine">    DepList Deps = getUpwardDeps(Info.Inst, Base);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">950</td>
    <td class="codeLine">    DepList Deps = getUpwardDeps(Info.Inst, Base);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeLine">    if (!llvm::all_of(Deps, isSafeToCopyAtBase))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">951</td>
    <td class="codeLine">    if (!llvm::all_of(Deps, isSafeToCopyAtBase))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">952</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">953</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeLine">    Move.Main.push_back(Info.Inst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">954</td>
    <td class="codeLine">    Move.Main.push_back(Info.Inst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeLine">    llvm::append_range(Move.Deps, Deps);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">955</td>
    <td class="codeLine">    llvm::append_range(Move.Deps, Deps);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">956</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">957</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">958</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeLine">  MoveList LoadGroups;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">959</td>
    <td class="codeLine">  MoveList LoadGroups;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">960</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeLine">  for (const AddrInfo &Info : Group) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">961</td>
    <td class="codeLine">  for (const AddrInfo &Info : Group) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeLine">    if (!Info.Inst->mayReadFromMemory())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">962</td>
    <td class="codeLine">    if (!Info.Inst->mayReadFromMemory())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">963</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeLine">    if (LoadGroups.empty() || !tryAddTo(Info, LoadGroups.back()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">964</td>
    <td class="codeLine">    if (LoadGroups.empty() || !tryAddTo(Info, LoadGroups.back()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeLine">      LoadGroups.emplace_back(Info, Group.front().Inst, isHvx(Info), true);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">965</td>
    <td class="codeLine">      LoadGroups.emplace_back(Info, Group.front().Inst, isHvx(Info), true);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">966</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">967</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeLine">  // Erase singleton groups.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">968</td>
    <td class="codeLine">  // Erase singleton groups.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeLine">  erase_if(LoadGroups, [](const MoveGroup &G) { return G.Main.size() <= 1; });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">969</td>
    <td class="codeLine">  erase_if(LoadGroups, [](const MoveGroup &G) { return G.Main.size() <= 1; });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">970</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeLine">  // Erase HVX groups on targets < HvxV62 (due to lack of predicated loads).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">971</td>
    <td class="codeLine">  // Erase HVX groups on targets < HvxV62 (due to lack of predicated loads).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeLine">  if (!HVC.HST.useHVXV62Ops())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">972</td>
    <td class="codeLine">  if (!HVC.HST.useHVXV62Ops())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeLine">    erase_if(LoadGroups, [](const MoveGroup &G) { return G.IsHvx; });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">973</td>
    <td class="codeLine">    erase_if(LoadGroups, [](const MoveGroup &G) { return G.IsHvx; });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">974</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeLine">  return LoadGroups;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">975</td>
    <td class="codeLine">  return LoadGroups;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">976</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">977</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeLine">auto AlignVectors::createStoreGroups(const AddrList &Group) const -> MoveList {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">978</td>
    <td class="codeLine">auto AlignVectors::createStoreGroups(const AddrList &Group) const -> MoveList {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeLine">  // Form store groups.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">979</td>
    <td class="codeLine">  // Form store groups.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeLine">  // To avoid complications with moving code across basic blocks, only form</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">980</td>
    <td class="codeLine">  // To avoid complications with moving code across basic blocks, only form</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeLine">  // groups that are contained within a single basic block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">981</td>
    <td class="codeLine">  // groups that are contained within a single basic block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeLine">  unsigned SizeLimit = VAGroupSizeLimit;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">982</td>
    <td class="codeLine">  unsigned SizeLimit = VAGroupSizeLimit;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeLine">  if (SizeLimit == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">983</td>
    <td class="codeLine">  if (SizeLimit == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeLine">    return {};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">984</td>
    <td class="codeLine">    return {};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">985</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeLine">  auto tryAddTo = [&](const AddrInfo &Info, MoveGroup &Move) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">986</td>
    <td class="codeLine">  auto tryAddTo = [&](const AddrInfo &Info, MoveGroup &Move) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeLine">    assert(!Move.Main.empty() && "Move group should have non-empty Main");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">987</td>
    <td class="codeLine">    assert(!Move.Main.empty() && "Move group should have non-empty Main");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeLine">    if (Move.Main.size() >= SizeLimit)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">988</td>
    <td class="codeLine">    if (Move.Main.size() >= SizeLimit)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">989</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeLine">    // For stores with return values we'd have to collect downward depenencies.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">990</td>
    <td class="codeLine">    // For stores with return values we'd have to collect downward depenencies.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeLine">    // There are no such stores that we handle at the moment, so omit that.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">991</td>
    <td class="codeLine">    // There are no such stores that we handle at the moment, so omit that.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeLine">    assert(Info.Inst->getType()->isVoidTy() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">992</td>
    <td class="codeLine">    assert(Info.Inst->getType()->isVoidTy() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeLine">           "Not handling stores with return values");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">993</td>
    <td class="codeLine">           "Not handling stores with return values");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeLine">    // Don't mix HVX and non-HVX instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">994</td>
    <td class="codeLine">    // Don't mix HVX and non-HVX instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeLine">    if (Move.IsHvx != isHvx(Info))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">995</td>
    <td class="codeLine">    if (Move.IsHvx != isHvx(Info))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">996</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeLine">    // For stores we need to be careful whether it's safe to move them.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">997</td>
    <td class="codeLine">    // For stores we need to be careful whether it's safe to move them.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeLine">    // Stores that are otherwise safe to move together may not appear safe</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">998</td>
    <td class="codeLine">    // Stores that are otherwise safe to move together may not appear safe</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeLine">    // to move over one another (i.e. isSafeToMoveBefore may return false).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">999</td>
    <td class="codeLine">    // to move over one another (i.e. isSafeToMoveBefore may return false).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeLine">    Instruction *Base = Move.Main.front();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1000</td>
    <td class="codeLine">    Instruction *Base = Move.Main.front();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeLine">    if (Base->getParent() != Info.Inst->getParent())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1001</td>
    <td class="codeLine">    if (Base->getParent() != Info.Inst->getParent())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1002</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeLine">    if (!HVC.isSafeToMoveBeforeInBB(*Info.Inst, Base->getIterator(), Move.Main))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1003</td>
    <td class="codeLine">    if (!HVC.isSafeToMoveBeforeInBB(*Info.Inst, Base->getIterator(), Move.Main))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1004</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeLine">    Move.Main.push_back(Info.Inst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1005</td>
    <td class="codeLine">    Move.Main.push_back(Info.Inst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1006</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1007</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1008</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeLine">  MoveList StoreGroups;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1009</td>
    <td class="codeLine">  MoveList StoreGroups;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1010</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeLine">  for (auto I = Group.rbegin(), E = Group.rend(); I != E; ++I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1011</td>
    <td class="codeLine">  for (auto I = Group.rbegin(), E = Group.rend(); I != E; ++I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeLine">    const AddrInfo &Info = *I;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1012</td>
    <td class="codeLine">    const AddrInfo &Info = *I;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeLine">    if (!Info.Inst->mayWriteToMemory())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1013</td>
    <td class="codeLine">    if (!Info.Inst->mayWriteToMemory())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1014</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeLine">    if (StoreGroups.empty() || !tryAddTo(Info, StoreGroups.back()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1015</td>
    <td class="codeLine">    if (StoreGroups.empty() || !tryAddTo(Info, StoreGroups.back()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeLine">      StoreGroups.emplace_back(Info, Group.front().Inst, isHvx(Info), false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1016</td>
    <td class="codeLine">      StoreGroups.emplace_back(Info, Group.front().Inst, isHvx(Info), false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1017</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1018</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeLine">  // Erase singleton groups.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1019</td>
    <td class="codeLine">  // Erase singleton groups.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeLine">  erase_if(StoreGroups, [](const MoveGroup &G) { return G.Main.size() <= 1; });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1020</td>
    <td class="codeLine">  erase_if(StoreGroups, [](const MoveGroup &G) { return G.Main.size() <= 1; });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1021</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeLine">  // Erase HVX groups on targets < HvxV62 (due to lack of predicated loads).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1022</td>
    <td class="codeLine">  // Erase HVX groups on targets < HvxV62 (due to lack of predicated loads).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeLine">  if (!HVC.HST.useHVXV62Ops())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1023</td>
    <td class="codeLine">  if (!HVC.HST.useHVXV62Ops())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeLine">    erase_if(StoreGroups, [](const MoveGroup &G) { return G.IsHvx; });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1024</td>
    <td class="codeLine">    erase_if(StoreGroups, [](const MoveGroup &G) { return G.IsHvx; });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1025</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeLine">  // Erase groups where every store is a full HVX vector. The reason is that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1026</td>
    <td class="codeLine">  // Erase groups where every store is a full HVX vector. The reason is that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeLine">  // aligning predicated stores generates complex code that may be less</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1027</td>
    <td class="codeLine">  // aligning predicated stores generates complex code that may be less</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeLine">  // efficient than a sequence of unaligned vector stores.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1028</td>
    <td class="codeLine">  // efficient than a sequence of unaligned vector stores.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeLine">  if (!VADoFullStores) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1029</td>
    <td class="codeLine">  if (!VADoFullStores) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeLine">    erase_if(StoreGroups, [this](const MoveGroup &G) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1030</td>
    <td class="codeLine">    erase_if(StoreGroups, [this](const MoveGroup &G) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeLine">      return G.IsHvx && llvm::all_of(G.Main, [this](Instruction *S) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1031</td>
    <td class="codeLine">      return G.IsHvx && llvm::all_of(G.Main, [this](Instruction *S) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeLine">               auto MaybeInfo = this->getAddrInfo(*S);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1032</td>
    <td class="codeLine">               auto MaybeInfo = this->getAddrInfo(*S);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeLine">               assert(MaybeInfo.has_value());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1033</td>
    <td class="codeLine">               assert(MaybeInfo.has_value());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeLine">               return HVC.HST.isHVXVectorType(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1034</td>
    <td class="codeLine">               return HVC.HST.isHVXVectorType(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeLine">                   EVT::getEVT(MaybeInfo->ValTy, false));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1035</td>
    <td class="codeLine">                   EVT::getEVT(MaybeInfo->ValTy, false));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeLine">             });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1036</td>
    <td class="codeLine">             });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1037</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1038</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1039</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeLine">  return StoreGroups;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1040</td>
    <td class="codeLine">  return StoreGroups;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1041</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1042</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeLine">auto AlignVectors::moveTogether(MoveGroup &Move) const -> bool {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1043</td>
    <td class="codeLine">auto AlignVectors::moveTogether(MoveGroup &Move) const -> bool {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeLine">  // Move all instructions to be adjacent.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1044</td>
    <td class="codeLine">  // Move all instructions to be adjacent.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeLine">  assert(!Move.Main.empty() && "Move group should have non-empty Main");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1045</td>
    <td class="codeLine">  assert(!Move.Main.empty() && "Move group should have non-empty Main");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeLine">  Instruction *Where = Move.Main.front();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1046</td>
    <td class="codeLine">  Instruction *Where = Move.Main.front();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1047</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeLine">  if (Move.IsLoad) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1048</td>
    <td class="codeLine">  if (Move.IsLoad) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeLine">    // Move all the loads (and dependencies) to where the first load is.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1049</td>
    <td class="codeLine">    // Move all the loads (and dependencies) to where the first load is.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeLine">    // Clone all deps to before Where, keeping order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1050</td>
    <td class="codeLine">    // Clone all deps to before Where, keeping order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeLine">    Move.Clones = cloneBefore(Where, Move.Deps);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1051</td>
    <td class="codeLine">    Move.Clones = cloneBefore(Where, Move.Deps);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeLine">    // Move all main instructions to after Where, keeping order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1052</td>
    <td class="codeLine">    // Move all main instructions to after Where, keeping order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeLine">    ArrayRef<Instruction *> Main(Move.Main);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1053</td>
    <td class="codeLine">    ArrayRef<Instruction *> Main(Move.Main);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeLine">    for (Instruction *M : Main) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1054</td>
    <td class="codeLine">    for (Instruction *M : Main) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeLine">      if (M != Where)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1055</td>
    <td class="codeLine">      if (M != Where)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeLine">        M->moveAfter(Where);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1056</td>
    <td class="codeLine">        M->moveAfter(Where);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeLine">      for (auto [Old, New] : Move.Clones)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1057</td>
    <td class="codeLine">      for (auto [Old, New] : Move.Clones)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeLine">        M->replaceUsesOfWith(Old, New);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1058</td>
    <td class="codeLine">        M->replaceUsesOfWith(Old, New);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeLine">      Where = M;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1059</td>
    <td class="codeLine">      Where = M;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1060</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeLine">    // Replace Deps with the clones.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1061</td>
    <td class="codeLine">    // Replace Deps with the clones.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeLine">    for (int i = 0, e = Move.Deps.size(); i != e; ++i)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1062</td>
    <td class="codeLine">    for (int i = 0, e = Move.Deps.size(); i != e; ++i)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeLine">      Move.Deps[i] = Move.Clones[Move.Deps[i]];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1063</td>
    <td class="codeLine">      Move.Deps[i] = Move.Clones[Move.Deps[i]];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1064</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeLine">    // Move all the stores to where the last store is.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1065</td>
    <td class="codeLine">    // Move all the stores to where the last store is.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeLine">    // NOTE: Deps are empty for "store" groups. If they need to be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1066</td>
    <td class="codeLine">    // NOTE: Deps are empty for "store" groups. If they need to be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeLine">    // non-empty, decide on the order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1067</td>
    <td class="codeLine">    // non-empty, decide on the order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeLine">    assert(Move.Deps.empty());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1068</td>
    <td class="codeLine">    assert(Move.Deps.empty());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeLine">    // Move all main instructions to before Where, inverting order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1069</td>
    <td class="codeLine">    // Move all main instructions to before Where, inverting order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeLine">    ArrayRef<Instruction *> Main(Move.Main);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1070</td>
    <td class="codeLine">    ArrayRef<Instruction *> Main(Move.Main);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeLine">    for (Instruction *M : Main.drop_front(1)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1071</td>
    <td class="codeLine">    for (Instruction *M : Main.drop_front(1)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeLine">      M->moveBefore(Where);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1072</td>
    <td class="codeLine">      M->moveBefore(Where);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeLine">      Where = M;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1073</td>
    <td class="codeLine">      Where = M;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1074</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1075</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1076</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeLine">  return Move.Main.size() + Move.Deps.size() > 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1077</td>
    <td class="codeLine">  return Move.Main.size() + Move.Deps.size() > 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1078</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1079</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeLine">template <typename T></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1080</td>
    <td class="codeLine">template <typename T></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeLine">auto AlignVectors::cloneBefore(Instruction *To, T &&Insts) const -> InstMap {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1081</td>
    <td class="codeLine">auto AlignVectors::cloneBefore(Instruction *To, T &&Insts) const -> InstMap {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeLine">  InstMap Map;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1082</td>
    <td class="codeLine">  InstMap Map;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1083</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeLine">  for (Instruction *I : Insts) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1084</td>
    <td class="codeLine">  for (Instruction *I : Insts) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeLine">    assert(HVC.isSafeToClone(*I));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1085</td>
    <td class="codeLine">    assert(HVC.isSafeToClone(*I));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeLine">    Instruction *C = I->clone();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1086</td>
    <td class="codeLine">    Instruction *C = I->clone();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeLine">    C->setName(Twine("c.") + I->getName() + ".");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1087</td>
    <td class="codeLine">    C->setName(Twine("c.") + I->getName() + ".");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeLine">    C->insertBefore(To);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1088</td>
    <td class="codeLine">    C->insertBefore(To);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1089</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeLine">    for (auto [Old, New] : Map)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1090</td>
    <td class="codeLine">    for (auto [Old, New] : Map)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeLine">      C->replaceUsesOfWith(Old, New);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1091</td>
    <td class="codeLine">      C->replaceUsesOfWith(Old, New);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeLine">    Map.insert(std::make_pair(I, C));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1092</td>
    <td class="codeLine">    Map.insert(std::make_pair(I, C));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1093</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeLine">  return Map;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1094</td>
    <td class="codeLine">  return Map;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1095</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1096</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeLine">auto AlignVectors::realignLoadGroup(IRBuilderBase &Builder,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1097</td>
    <td class="codeLine">auto AlignVectors::realignLoadGroup(IRBuilderBase &Builder,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeLine">                                    const ByteSpan &VSpan, int ScLen,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1098</td>
    <td class="codeLine">                                    const ByteSpan &VSpan, int ScLen,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeLine">                                    Value *AlignVal, Value *AlignAddr) const</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1099</td>
    <td class="codeLine">                                    Value *AlignVal, Value *AlignAddr) const</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeLine">    -> void {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1100</td>
    <td class="codeLine">    -> void {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << __func__ << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1101</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << __func__ << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1102</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeLine">  Type *SecTy = HVC.getByteTy(ScLen);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1103</td>
    <td class="codeLine">  Type *SecTy = HVC.getByteTy(ScLen);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeLine">  int NumSectors = (VSpan.extent() + ScLen - 1) / ScLen;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1104</td>
    <td class="codeLine">  int NumSectors = (VSpan.extent() + ScLen - 1) / ScLen;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeLine">  bool DoAlign = !HVC.isZero(AlignVal);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1105</td>
    <td class="codeLine">  bool DoAlign = !HVC.isZero(AlignVal);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeLine">  BasicBlock::iterator BasePos = Builder.GetInsertPoint();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1106</td>
    <td class="codeLine">  BasicBlock::iterator BasePos = Builder.GetInsertPoint();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeLine">  BasicBlock *BaseBlock = Builder.GetInsertBlock();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1107</td>
    <td class="codeLine">  BasicBlock *BaseBlock = Builder.GetInsertBlock();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1108</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeLine">  ByteSpan ASpan;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1109</td>
    <td class="codeLine">  ByteSpan ASpan;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeLine">  auto *True = HVC.getFullValue(HVC.getBoolTy(ScLen));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1110</td>
    <td class="codeLine">  auto *True = HVC.getFullValue(HVC.getBoolTy(ScLen));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeLine">  auto *Undef = UndefValue::get(SecTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1111</td>
    <td class="codeLine">  auto *Undef = UndefValue::get(SecTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1112</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeLine">  // Created load does not have to be "Instruction" (e.g. "undef").</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1113</td>
    <td class="codeLine">  // Created load does not have to be "Instruction" (e.g. "undef").</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeLine">  SmallVector<Value *> Loads(NumSectors + DoAlign, nullptr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1114</td>
    <td class="codeLine">  SmallVector<Value *> Loads(NumSectors + DoAlign, nullptr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1115</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeLine">  // We could create all of the aligned loads, and generate the valigns</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1116</td>
    <td class="codeLine">  // We could create all of the aligned loads, and generate the valigns</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeLine">  // at the location of the first load, but for large load groups, this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1117</td>
    <td class="codeLine">  // at the location of the first load, but for large load groups, this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeLine">  // could create highly suboptimal code (there have been groups of 140+</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1118</td>
    <td class="codeLine">  // could create highly suboptimal code (there have been groups of 140+</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeLine">  // loads in real code).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1119</td>
    <td class="codeLine">  // loads in real code).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeLine">  // Instead, place the loads/valigns as close to the users as possible.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1120</td>
    <td class="codeLine">  // Instead, place the loads/valigns as close to the users as possible.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeLine">  // In any case we need to have a mapping from the blocks of VSpan (the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1121</td>
    <td class="codeLine">  // In any case we need to have a mapping from the blocks of VSpan (the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeLine">  // span covered by the pre-existing loads) to ASpan (the span covered</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1122</td>
    <td class="codeLine">  // span covered by the pre-existing loads) to ASpan (the span covered</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeLine">  // by the aligned loads). There is a small problem, though: ASpan needs</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1123</td>
    <td class="codeLine">  // by the aligned loads). There is a small problem, though: ASpan needs</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeLine">  // to have pointers to the loads/valigns, but we don't have these loads</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1124</td>
    <td class="codeLine">  // to have pointers to the loads/valigns, but we don't have these loads</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeLine">  // because we don't know where to put them yet. We find out by creating</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1125</td>
    <td class="codeLine">  // because we don't know where to put them yet. We find out by creating</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeLine">  // a section of ASpan that corresponds to values (blocks) from VSpan,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1126</td>
    <td class="codeLine">  // a section of ASpan that corresponds to values (blocks) from VSpan,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeLine">  // and checking where the new load should be placed. We need to attach</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1127</td>
    <td class="codeLine">  // and checking where the new load should be placed. We need to attach</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeLine">  // this location information to each block in ASpan somehow, so we put</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1128</td>
    <td class="codeLine">  // this location information to each block in ASpan somehow, so we put</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeLine">  // distincts values for Seg.Val in each ASpan.Blocks[i], and use a map</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1129</td>
    <td class="codeLine">  // distincts values for Seg.Val in each ASpan.Blocks[i], and use a map</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeLine">  // to store the location for each Seg.Val.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1130</td>
    <td class="codeLine">  // to store the location for each Seg.Val.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeLine">  // The distinct values happen to be Blocks[i].Seg.Val = &Blocks[i],</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1131</td>
    <td class="codeLine">  // The distinct values happen to be Blocks[i].Seg.Val = &Blocks[i],</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeLine">  // which helps with printing ByteSpans without crashing when printing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1132</td>
    <td class="codeLine">  // which helps with printing ByteSpans without crashing when printing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeLine">  // Segments with these temporary identifiers in place of Val.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1133</td>
    <td class="codeLine">  // Segments with these temporary identifiers in place of Val.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1134</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeLine">  // Populate the blocks first, to avoid reallocations of the vector</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1135</td>
    <td class="codeLine">  // Populate the blocks first, to avoid reallocations of the vector</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeLine">  // interfering with generating the placeholder addresses.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1136</td>
    <td class="codeLine">  // interfering with generating the placeholder addresses.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeLine">  for (int Index = 0; Index != NumSectors; ++Index)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1137</td>
    <td class="codeLine">  for (int Index = 0; Index != NumSectors; ++Index)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeLine">    ASpan.Blocks.emplace_back(nullptr, ScLen, Index * ScLen);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1138</td>
    <td class="codeLine">    ASpan.Blocks.emplace_back(nullptr, ScLen, Index * ScLen);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeLine">  for (int Index = 0; Index != NumSectors; ++Index) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1139</td>
    <td class="codeLine">  for (int Index = 0; Index != NumSectors; ++Index) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeLine">    ASpan.Blocks[Index].Seg.Val =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1140</td>
    <td class="codeLine">    ASpan.Blocks[Index].Seg.Val =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeLine">        reinterpret_cast<Value *>(&ASpan.Blocks[Index]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1141</td>
    <td class="codeLine">        reinterpret_cast<Value *>(&ASpan.Blocks[Index]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1142</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1143</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeLine">  // Multiple values from VSpan can map to the same value in ASpan. Since we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1144</td>
    <td class="codeLine">  // Multiple values from VSpan can map to the same value in ASpan. Since we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeLine">  // try to create loads lazily, we need to find the earliest use for each</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1145</td>
    <td class="codeLine">  // try to create loads lazily, we need to find the earliest use for each</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeLine">  // value from ASpan.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1146</td>
    <td class="codeLine">  // value from ASpan.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeLine">  DenseMap<void *, Instruction *> EarliestUser;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1147</td>
    <td class="codeLine">  DenseMap<void *, Instruction *> EarliestUser;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeLine">  auto isEarlier = [](Instruction *A, Instruction *B) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1148</td>
    <td class="codeLine">  auto isEarlier = [](Instruction *A, Instruction *B) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeLine">    if (B == nullptr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1149</td>
    <td class="codeLine">    if (B == nullptr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1150</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeLine">    if (A == nullptr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1151</td>
    <td class="codeLine">    if (A == nullptr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1152</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeLine">    assert(A->getParent() == B->getParent());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1153</td>
    <td class="codeLine">    assert(A->getParent() == B->getParent());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeLine">    return A->comesBefore(B);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1154</td>
    <td class="codeLine">    return A->comesBefore(B);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1155</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeLine">  auto earliestUser = [&](const auto &Uses) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1156</td>
    <td class="codeLine">  auto earliestUser = [&](const auto &Uses) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeLine">    Instruction *User = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1157</td>
    <td class="codeLine">    Instruction *User = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeLine">    for (const Use &U : Uses) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1158</td>
    <td class="codeLine">    for (const Use &U : Uses) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeLine">      auto *I = dyn_cast<Instruction>(U.getUser());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1159</td>
    <td class="codeLine">      auto *I = dyn_cast<Instruction>(U.getUser());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeLine">      assert(I != nullptr && "Load used in a non-instruction?");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1160</td>
    <td class="codeLine">      assert(I != nullptr && "Load used in a non-instruction?");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeLine">      // Make sure we only consider users in this block, but we need</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1161</td>
    <td class="codeLine">      // Make sure we only consider users in this block, but we need</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeLine">      // to remember if there were users outside the block too. This is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1162</td>
    <td class="codeLine">      // to remember if there were users outside the block too. This is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeLine">      // because if no users are found, aligned loads will not be created.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1163</td>
    <td class="codeLine">      // because if no users are found, aligned loads will not be created.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeLine">      if (I->getParent() == BaseBlock) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1164</td>
    <td class="codeLine">      if (I->getParent() == BaseBlock) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeLine">        if (!isa<PHINode>(I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1165</td>
    <td class="codeLine">        if (!isa<PHINode>(I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeLine">          User = std::min(User, I, isEarlier);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1166</td>
    <td class="codeLine">          User = std::min(User, I, isEarlier);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1167</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeLine">        User = std::min(User, BaseBlock->getTerminator(), isEarlier);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1168</td>
    <td class="codeLine">        User = std::min(User, BaseBlock->getTerminator(), isEarlier);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1169</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1170</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeLine">    return User;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1171</td>
    <td class="codeLine">    return User;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1172</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1173</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeLine">  for (const ByteSpan::Block &B : VSpan) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1174</td>
    <td class="codeLine">  for (const ByteSpan::Block &B : VSpan) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeLine">    ByteSpan ASection = ASpan.section(B.Pos, B.Seg.Size);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1175</td>
    <td class="codeLine">    ByteSpan ASection = ASpan.section(B.Pos, B.Seg.Size);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeLine">    for (const ByteSpan::Block &S : ASection) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1176</td>
    <td class="codeLine">    for (const ByteSpan::Block &S : ASection) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeLine">      EarliestUser[S.Seg.Val] = std::min(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1177</td>
    <td class="codeLine">      EarliestUser[S.Seg.Val] = std::min(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeLine">          EarliestUser[S.Seg.Val], earliestUser(B.Seg.Val->uses()), isEarlier);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1178</td>
    <td class="codeLine">          EarliestUser[S.Seg.Val], earliestUser(B.Seg.Val->uses()), isEarlier);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1179</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1180</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1182</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeLine">    dbgs() << "ASpan:\n" << ASpan << '\n';</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1183</td>
    <td class="codeLine">    dbgs() << "ASpan:\n" << ASpan << '\n';</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeLine">    dbgs() << "Earliest users of ASpan:\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1184</td>
    <td class="codeLine">    dbgs() << "Earliest users of ASpan:\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeLine">    for (auto &[Val, User] : EarliestUser) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1185</td>
    <td class="codeLine">    for (auto &[Val, User] : EarliestUser) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeLine">      dbgs() << Val << "\n ->" << *User << '\n';</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1186</td>
    <td class="codeLine">      dbgs() << Val << "\n ->" << *User << '\n';</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1187</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1188</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1189</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeLine">  auto createLoad = [&](IRBuilderBase &Builder, const ByteSpan &VSpan,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1190</td>
    <td class="codeLine">  auto createLoad = [&](IRBuilderBase &Builder, const ByteSpan &VSpan,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeLine">                        int Index, bool MakePred) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1191</td>
    <td class="codeLine">                        int Index, bool MakePred) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeLine">    Value *Ptr =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1192</td>
    <td class="codeLine">    Value *Ptr =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeLine">        createAdjustedPointer(Builder, AlignAddr, SecTy, Index * ScLen);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1193</td>
    <td class="codeLine">        createAdjustedPointer(Builder, AlignAddr, SecTy, Index * ScLen);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeLine">    Value *Predicate =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1194</td>
    <td class="codeLine">    Value *Predicate =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeLine">        MakePred ? makeTestIfUnaligned(Builder, AlignVal, ScLen) : nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1195</td>
    <td class="codeLine">        MakePred ? makeTestIfUnaligned(Builder, AlignVal, ScLen) : nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1196</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeLine">    // If vector shifting is potentially needed, accumulate metadata</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1197</td>
    <td class="codeLine">    // If vector shifting is potentially needed, accumulate metadata</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeLine">    // from source sections of twice the load width.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1198</td>
    <td class="codeLine">    // from source sections of twice the load width.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeLine">    int Start = (Index - DoAlign) * ScLen;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1199</td>
    <td class="codeLine">    int Start = (Index - DoAlign) * ScLen;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeLine">    int Width = (1 + DoAlign) * ScLen;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1200</td>
    <td class="codeLine">    int Width = (1 + DoAlign) * ScLen;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeLine">    return this->createLoad(Builder, SecTy, Ptr, Predicate, ScLen, True, Undef,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1201</td>
    <td class="codeLine">    return this->createLoad(Builder, SecTy, Ptr, Predicate, ScLen, True, Undef,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeLine">                            VSpan.section(Start, Width).values());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1202</td>
    <td class="codeLine">                            VSpan.section(Start, Width).values());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1203</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1204</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeLine">  auto moveBefore = [this](Instruction *In, Instruction *To) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1205</td>
    <td class="codeLine">  auto moveBefore = [this](Instruction *In, Instruction *To) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeLine">    // Move In and its upward dependencies to before To.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1206</td>
    <td class="codeLine">    // Move In and its upward dependencies to before To.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeLine">    assert(In->getParent() == To->getParent());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1207</td>
    <td class="codeLine">    assert(In->getParent() == To->getParent());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeLine">    DepList Deps = getUpwardDeps(In, To);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1208</td>
    <td class="codeLine">    DepList Deps = getUpwardDeps(In, To);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeLine">    In->moveBefore(To);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1209</td>
    <td class="codeLine">    In->moveBefore(To);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeLine">    // DepList is sorted with respect to positions in the basic block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1210</td>
    <td class="codeLine">    // DepList is sorted with respect to positions in the basic block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeLine">    InstMap Map = cloneBefore(In, Deps);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1211</td>
    <td class="codeLine">    InstMap Map = cloneBefore(In, Deps);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeLine">    for (auto [Old, New] : Map)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1212</td>
    <td class="codeLine">    for (auto [Old, New] : Map)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeLine">      In->replaceUsesOfWith(Old, New);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1213</td>
    <td class="codeLine">      In->replaceUsesOfWith(Old, New);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1214</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1215</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeLine">  // Generate necessary loads at appropriate locations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1216</td>
    <td class="codeLine">  // Generate necessary loads at appropriate locations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Creating loads for ASpan sectors\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1217</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Creating loads for ASpan sectors\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeLine">  for (int Index = 0; Index != NumSectors + 1; ++Index) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1218</td>
    <td class="codeLine">  for (int Index = 0; Index != NumSectors + 1; ++Index) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeLine">    // In ASpan, each block will be either a single aligned load, or a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1219</td>
    <td class="codeLine">    // In ASpan, each block will be either a single aligned load, or a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeLine">    // valign of a pair of loads. In the latter case, an aligned load j</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1220</td>
    <td class="codeLine">    // valign of a pair of loads. In the latter case, an aligned load j</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeLine">    // will belong to the current valign, and the one in the previous</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1221</td>
    <td class="codeLine">    // will belong to the current valign, and the one in the previous</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeLine">    // block (for j > 0).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1222</td>
    <td class="codeLine">    // block (for j > 0).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeLine">    // Place the load at a location which will dominate the valign, assuming</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1223</td>
    <td class="codeLine">    // Place the load at a location which will dominate the valign, assuming</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeLine">    // the valign will be placed right before the earliest user.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1224</td>
    <td class="codeLine">    // the valign will be placed right before the earliest user.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeLine">    Instruction *PrevAt =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1225</td>
    <td class="codeLine">    Instruction *PrevAt =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeLine">        DoAlign && Index > 0 ? EarliestUser[&ASpan[Index - 1]] : nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1226</td>
    <td class="codeLine">        DoAlign && Index > 0 ? EarliestUser[&ASpan[Index - 1]] : nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeLine">    Instruction *ThisAt =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1227</td>
    <td class="codeLine">    Instruction *ThisAt =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeLine">        Index < NumSectors ? EarliestUser[&ASpan[Index]] : nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1228</td>
    <td class="codeLine">        Index < NumSectors ? EarliestUser[&ASpan[Index]] : nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeLine">    if (auto *Where = std::min(PrevAt, ThisAt, isEarlier)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1229</td>
    <td class="codeLine">    if (auto *Where = std::min(PrevAt, ThisAt, isEarlier)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeLine">      Builder.SetInsertPoint(Where);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1230</td>
    <td class="codeLine">      Builder.SetInsertPoint(Where);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeLine">      Loads[Index] =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1231</td>
    <td class="codeLine">      Loads[Index] =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeLine">          createLoad(Builder, VSpan, Index, DoAlign && Index == NumSectors);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1232</td>
    <td class="codeLine">          createLoad(Builder, VSpan, Index, DoAlign && Index == NumSectors);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeLine">      // We know it's safe to put the load at BasePos, but we'd prefer to put</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1233</td>
    <td class="codeLine">      // We know it's safe to put the load at BasePos, but we'd prefer to put</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeLine">      // it at "Where". To see if the load is safe to be placed at Where, put</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1234</td>
    <td class="codeLine">      // it at "Where". To see if the load is safe to be placed at Where, put</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeLine">      // it there first and then check if it's safe to move it to BasePos.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1235</td>
    <td class="codeLine">      // it there first and then check if it's safe to move it to BasePos.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeLine">      // If not, then the load needs to be placed at BasePos.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1236</td>
    <td class="codeLine">      // If not, then the load needs to be placed at BasePos.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeLine">      // We can't do this check proactively because we need the load to exist</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1237</td>
    <td class="codeLine">      // We can't do this check proactively because we need the load to exist</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeLine">      // in order to check legality.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1238</td>
    <td class="codeLine">      // in order to check legality.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeLine">      if (auto *Load = dyn_cast<Instruction>(Loads[Index])) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1239</td>
    <td class="codeLine">      if (auto *Load = dyn_cast<Instruction>(Loads[Index])) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeLine">        if (!HVC.isSafeToMoveBeforeInBB(*Load, BasePos))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1240</td>
    <td class="codeLine">        if (!HVC.isSafeToMoveBeforeInBB(*Load, BasePos))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeLine">          moveBefore(Load, &*BasePos);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1241</td>
    <td class="codeLine">          moveBefore(Load, &*BasePos);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1242</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "Loads[" << Index << "]:" << *Loads[Index] << '\n');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1243</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "Loads[" << Index << "]:" << *Loads[Index] << '\n');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1244</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1245</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1246</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeLine">  // Generate valigns if needed, and fill in proper values in ASpan</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1247</td>
    <td class="codeLine">  // Generate valigns if needed, and fill in proper values in ASpan</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Creating values for ASpan sectors\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1248</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Creating values for ASpan sectors\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeLine">  for (int Index = 0; Index != NumSectors; ++Index) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1249</td>
    <td class="codeLine">  for (int Index = 0; Index != NumSectors; ++Index) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeLine">    ASpan[Index].Seg.Val = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1250</td>
    <td class="codeLine">    ASpan[Index].Seg.Val = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeLine">    if (auto *Where = EarliestUser[&ASpan[Index]]) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1251</td>
    <td class="codeLine">    if (auto *Where = EarliestUser[&ASpan[Index]]) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeLine">      Builder.SetInsertPoint(Where);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1252</td>
    <td class="codeLine">      Builder.SetInsertPoint(Where);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeLine">      Value *Val = Loads[Index];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1253</td>
    <td class="codeLine">      Value *Val = Loads[Index];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeLine">      assert(Val != nullptr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1254</td>
    <td class="codeLine">      assert(Val != nullptr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeLine">      if (DoAlign) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1255</td>
    <td class="codeLine">      if (DoAlign) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeLine">        Value *NextLoad = Loads[Index + 1];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1256</td>
    <td class="codeLine">        Value *NextLoad = Loads[Index + 1];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeLine">        assert(NextLoad != nullptr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1257</td>
    <td class="codeLine">        assert(NextLoad != nullptr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeLine">        Val = HVC.vralignb(Builder, Val, NextLoad, AlignVal);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1258</td>
    <td class="codeLine">        Val = HVC.vralignb(Builder, Val, NextLoad, AlignVal);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1259</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeLine">      ASpan[Index].Seg.Val = Val;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1260</td>
    <td class="codeLine">      ASpan[Index].Seg.Val = Val;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "ASpan[" << Index << "]:" << *Val << '\n');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1261</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "ASpan[" << Index << "]:" << *Val << '\n');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1262</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1263</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1264</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeLine">  for (const ByteSpan::Block &B : VSpan) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1265</td>
    <td class="codeLine">  for (const ByteSpan::Block &B : VSpan) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeLine">    ByteSpan ASection = ASpan.section(B.Pos, B.Seg.Size).shift(-B.Pos);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1266</td>
    <td class="codeLine">    ByteSpan ASection = ASpan.section(B.Pos, B.Seg.Size).shift(-B.Pos);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeLine">    Value *Accum = UndefValue::get(HVC.getByteTy(B.Seg.Size));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1267</td>
    <td class="codeLine">    Value *Accum = UndefValue::get(HVC.getByteTy(B.Seg.Size));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeLine">    Builder.SetInsertPoint(cast<Instruction>(B.Seg.Val));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1268</td>
    <td class="codeLine">    Builder.SetInsertPoint(cast<Instruction>(B.Seg.Val));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1269</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeLine">    // We're generating a reduction, where each instruction depends on</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1270</td>
    <td class="codeLine">    // We're generating a reduction, where each instruction depends on</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeLine">    // the previous one, so we need to order them according to the position</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1271</td>
    <td class="codeLine">    // the previous one, so we need to order them according to the position</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeLine">    // of their inputs in the code.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1272</td>
    <td class="codeLine">    // of their inputs in the code.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeLine">    std::vector<ByteSpan::Block *> ABlocks;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1273</td>
    <td class="codeLine">    std::vector<ByteSpan::Block *> ABlocks;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeLine">    for (ByteSpan::Block &S : ASection) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1274</td>
    <td class="codeLine">    for (ByteSpan::Block &S : ASection) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeLine">      if (S.Seg.Val != nullptr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1275</td>
    <td class="codeLine">      if (S.Seg.Val != nullptr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeLine">        ABlocks.push_back(&S);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1276</td>
    <td class="codeLine">        ABlocks.push_back(&S);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1277</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeLine">    llvm::sort(ABlocks,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1278</td>
    <td class="codeLine">    llvm::sort(ABlocks,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeLine">               [&](const ByteSpan::Block *A, const ByteSpan::Block *B) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1279</td>
    <td class="codeLine">               [&](const ByteSpan::Block *A, const ByteSpan::Block *B) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeLine">                 return isEarlier(cast<Instruction>(A->Seg.Val),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1280</td>
    <td class="codeLine">                 return isEarlier(cast<Instruction>(A->Seg.Val),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeLine">                                  cast<Instruction>(B->Seg.Val));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1281</td>
    <td class="codeLine">                                  cast<Instruction>(B->Seg.Val));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeLine">               });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1282</td>
    <td class="codeLine">               });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeLine">    for (ByteSpan::Block *S : ABlocks) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1283</td>
    <td class="codeLine">    for (ByteSpan::Block *S : ABlocks) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeLine">      // The processing of the data loaded by the aligned loads</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1284</td>
    <td class="codeLine">      // The processing of the data loaded by the aligned loads</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeLine">      // needs to be inserted after the data is available.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1285</td>
    <td class="codeLine">      // needs to be inserted after the data is available.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeLine">      Instruction *SegI = cast<Instruction>(S->Seg.Val);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1286</td>
    <td class="codeLine">      Instruction *SegI = cast<Instruction>(S->Seg.Val);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeLine">      Builder.SetInsertPoint(&*std::next(SegI->getIterator()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1287</td>
    <td class="codeLine">      Builder.SetInsertPoint(&*std::next(SegI->getIterator()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeLine">      Value *Pay = HVC.vbytes(Builder, getPayload(S->Seg.Val));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1288</td>
    <td class="codeLine">      Value *Pay = HVC.vbytes(Builder, getPayload(S->Seg.Val));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeLine">      Accum =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1289</td>
    <td class="codeLine">      Accum =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeLine">          HVC.insertb(Builder, Accum, Pay, S->Seg.Start, S->Seg.Size, S->Pos);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1290</td>
    <td class="codeLine">          HVC.insertb(Builder, Accum, Pay, S->Seg.Start, S->Seg.Size, S->Pos);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1291</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeLine">    // Instead of casting everything to bytes for the vselect, cast to the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1292</td>
    <td class="codeLine">    // Instead of casting everything to bytes for the vselect, cast to the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeLine">    // original value type. This will avoid complications with casting masks.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1293</td>
    <td class="codeLine">    // original value type. This will avoid complications with casting masks.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeLine">    // For example, in cases when the original mask applied to i32, it could</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1294</td>
    <td class="codeLine">    // For example, in cases when the original mask applied to i32, it could</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeLine">    // be converted to a mask applicable to i8 via pred_typecast intrinsic,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1295</td>
    <td class="codeLine">    // be converted to a mask applicable to i8 via pred_typecast intrinsic,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeLine">    // but if the mask is not exactly of HVX length, extra handling would be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1296</td>
    <td class="codeLine">    // but if the mask is not exactly of HVX length, extra handling would be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeLine">    // needed to make it work.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1297</td>
    <td class="codeLine">    // needed to make it work.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeLine">    Type *ValTy = getPayload(B.Seg.Val)->getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1298</td>
    <td class="codeLine">    Type *ValTy = getPayload(B.Seg.Val)->getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeLine">    Value *Cast = Builder.CreateBitCast(Accum, ValTy, "cst");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1299</td>
    <td class="codeLine">    Value *Cast = Builder.CreateBitCast(Accum, ValTy, "cst");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeLine">    Value *Sel = Builder.CreateSelect(getMask(B.Seg.Val), Cast,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1300</td>
    <td class="codeLine">    Value *Sel = Builder.CreateSelect(getMask(B.Seg.Val), Cast,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeLine">                                      getPassThrough(B.Seg.Val), "sel");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1301</td>
    <td class="codeLine">                                      getPassThrough(B.Seg.Val), "sel");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeLine">    B.Seg.Val->replaceAllUsesWith(Sel);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1302</td>
    <td class="codeLine">    B.Seg.Val->replaceAllUsesWith(Sel);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1303</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1304</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1305</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeLine">auto AlignVectors::realignStoreGroup(IRBuilderBase &Builder,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1306</td>
    <td class="codeLine">auto AlignVectors::realignStoreGroup(IRBuilderBase &Builder,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeLine">                                     const ByteSpan &VSpan, int ScLen,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1307</td>
    <td class="codeLine">                                     const ByteSpan &VSpan, int ScLen,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeLine">                                     Value *AlignVal, Value *AlignAddr) const</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1308</td>
    <td class="codeLine">                                     Value *AlignVal, Value *AlignAddr) const</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeLine">    -> void {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1309</td>
    <td class="codeLine">    -> void {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << __func__ << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1310</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << __func__ << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1311</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeLine">  Type *SecTy = HVC.getByteTy(ScLen);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1312</td>
    <td class="codeLine">  Type *SecTy = HVC.getByteTy(ScLen);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeLine">  int NumSectors = (VSpan.extent() + ScLen - 1) / ScLen;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1313</td>
    <td class="codeLine">  int NumSectors = (VSpan.extent() + ScLen - 1) / ScLen;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeLine">  bool DoAlign = !HVC.isZero(AlignVal);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1314</td>
    <td class="codeLine">  bool DoAlign = !HVC.isZero(AlignVal);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1315</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeLine">  // Stores.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1316</td>
    <td class="codeLine">  // Stores.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeLine">  ByteSpan ASpanV, ASpanM;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1317</td>
    <td class="codeLine">  ByteSpan ASpanV, ASpanM;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1318</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeLine">  // Return a vector value corresponding to the input value Val:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1319</td>
    <td class="codeLine">  // Return a vector value corresponding to the input value Val:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeLine">  // either <1 x Val> for scalar Val, or Val itself for vector Val.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1320</td>
    <td class="codeLine">  // either <1 x Val> for scalar Val, or Val itself for vector Val.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeLine">  auto MakeVec = [](IRBuilderBase &Builder, Value *Val) -> Value * {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1321</td>
    <td class="codeLine">  auto MakeVec = [](IRBuilderBase &Builder, Value *Val) -> Value * {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeLine">    Type *Ty = Val->getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1322</td>
    <td class="codeLine">    Type *Ty = Val->getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeLine">    if (Ty->isVectorTy())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1323</td>
    <td class="codeLine">    if (Ty->isVectorTy())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeLine">      return Val;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1324</td>
    <td class="codeLine">      return Val;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeLine">    auto *VecTy = VectorType::get(Ty, 1, /*Scalable=*/false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1325</td>
    <td class="codeLine">    auto *VecTy = VectorType::get(Ty, 1, /*Scalable=*/false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeLine">    return Builder.CreateBitCast(Val, VecTy, "cst");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1326</td>
    <td class="codeLine">    return Builder.CreateBitCast(Val, VecTy, "cst");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1327</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1328</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeLine">  // Create an extra "undef" sector at the beginning and at the end.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1329</td>
    <td class="codeLine">  // Create an extra "undef" sector at the beginning and at the end.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeLine">  // They will be used as the left/right filler in the vlalign step.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1330</td>
    <td class="codeLine">  // They will be used as the left/right filler in the vlalign step.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeLine">  for (int Index = (DoAlign ? -1 : 0); Index != NumSectors + DoAlign; ++Index) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1331</td>
    <td class="codeLine">  for (int Index = (DoAlign ? -1 : 0); Index != NumSectors + DoAlign; ++Index) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeLine">    // For stores, the size of each section is an aligned vector length.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1332</td>
    <td class="codeLine">    // For stores, the size of each section is an aligned vector length.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeLine">    // Adjust the store offsets relative to the section start offset.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1333</td>
    <td class="codeLine">    // Adjust the store offsets relative to the section start offset.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeLine">    ByteSpan VSection =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1334</td>
    <td class="codeLine">    ByteSpan VSection =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeLine">        VSpan.section(Index * ScLen, ScLen).shift(-Index * ScLen);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1335</td>
    <td class="codeLine">        VSpan.section(Index * ScLen, ScLen).shift(-Index * ScLen);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeLine">    Value *Undef = UndefValue::get(SecTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1336</td>
    <td class="codeLine">    Value *Undef = UndefValue::get(SecTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeLine">    Value *Zero = HVC.getNullValue(SecTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1337</td>
    <td class="codeLine">    Value *Zero = HVC.getNullValue(SecTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeLine">    Value *AccumV = Undef;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1338</td>
    <td class="codeLine">    Value *AccumV = Undef;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeLine">    Value *AccumM = Zero;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1339</td>
    <td class="codeLine">    Value *AccumM = Zero;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeLine">    for (ByteSpan::Block &S : VSection) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1340</td>
    <td class="codeLine">    for (ByteSpan::Block &S : VSection) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeLine">      Value *Pay = getPayload(S.Seg.Val);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1341</td>
    <td class="codeLine">      Value *Pay = getPayload(S.Seg.Val);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeLine">      Value *Mask = HVC.rescale(Builder, MakeVec(Builder, getMask(S.Seg.Val)),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1342</td>
    <td class="codeLine">      Value *Mask = HVC.rescale(Builder, MakeVec(Builder, getMask(S.Seg.Val)),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeLine">                                Pay->getType(), HVC.getByteTy());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1343</td>
    <td class="codeLine">                                Pay->getType(), HVC.getByteTy());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeLine">      Value *PartM = HVC.insertb(Builder, Zero, HVC.vbytes(Builder, Mask),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1344</td>
    <td class="codeLine">      Value *PartM = HVC.insertb(Builder, Zero, HVC.vbytes(Builder, Mask),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeLine">                                 S.Seg.Start, S.Seg.Size, S.Pos);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1345</td>
    <td class="codeLine">                                 S.Seg.Start, S.Seg.Size, S.Pos);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeLine">      AccumM = Builder.CreateOr(AccumM, PartM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1346</td>
    <td class="codeLine">      AccumM = Builder.CreateOr(AccumM, PartM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1347</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeLine">      Value *PartV = HVC.insertb(Builder, Undef, HVC.vbytes(Builder, Pay),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1348</td>
    <td class="codeLine">      Value *PartV = HVC.insertb(Builder, Undef, HVC.vbytes(Builder, Pay),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeLine">                                 S.Seg.Start, S.Seg.Size, S.Pos);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1349</td>
    <td class="codeLine">                                 S.Seg.Start, S.Seg.Size, S.Pos);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1350</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeLine">      AccumV = Builder.CreateSelect(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1351</td>
    <td class="codeLine">      AccumV = Builder.CreateSelect(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeLine">          Builder.CreateICmp(CmpInst::ICMP_NE, PartM, Zero), PartV, AccumV);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1352</td>
    <td class="codeLine">          Builder.CreateICmp(CmpInst::ICMP_NE, PartM, Zero), PartV, AccumV);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1353</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeLine">    ASpanV.Blocks.emplace_back(AccumV, ScLen, Index * ScLen);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1354</td>
    <td class="codeLine">    ASpanV.Blocks.emplace_back(AccumV, ScLen, Index * ScLen);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeLine">    ASpanM.Blocks.emplace_back(AccumM, ScLen, Index * ScLen);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1355</td>
    <td class="codeLine">    ASpanM.Blocks.emplace_back(AccumM, ScLen, Index * ScLen);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1356</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1357</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1358</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeLine">    dbgs() << "ASpanV before vlalign:\n" << ASpanV << '\n';</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1359</td>
    <td class="codeLine">    dbgs() << "ASpanV before vlalign:\n" << ASpanV << '\n';</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeLine">    dbgs() << "ASpanM before vlalign:\n" << ASpanM << '\n';</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1360</td>
    <td class="codeLine">    dbgs() << "ASpanM before vlalign:\n" << ASpanM << '\n';</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1361</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeLine">  // vlalign</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1363</td>
    <td class="codeLine">  // vlalign</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeLine">  if (DoAlign) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1364</td>
    <td class="codeLine">  if (DoAlign) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeLine">    for (int Index = 1; Index != NumSectors + 2; ++Index) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1365</td>
    <td class="codeLine">    for (int Index = 1; Index != NumSectors + 2; ++Index) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeLine">      Value *PrevV = ASpanV[Index - 1].Seg.Val, *ThisV = ASpanV[Index].Seg.Val;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1366</td>
    <td class="codeLine">      Value *PrevV = ASpanV[Index - 1].Seg.Val, *ThisV = ASpanV[Index].Seg.Val;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeLine">      Value *PrevM = ASpanM[Index - 1].Seg.Val, *ThisM = ASpanM[Index].Seg.Val;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1367</td>
    <td class="codeLine">      Value *PrevM = ASpanM[Index - 1].Seg.Val, *ThisM = ASpanM[Index].Seg.Val;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeLine">      assert(isSectorTy(PrevV->getType()) && isSectorTy(PrevM->getType()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1368</td>
    <td class="codeLine">      assert(isSectorTy(PrevV->getType()) && isSectorTy(PrevM->getType()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeLine">      ASpanV[Index - 1].Seg.Val = HVC.vlalignb(Builder, PrevV, ThisV, AlignVal);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1369</td>
    <td class="codeLine">      ASpanV[Index - 1].Seg.Val = HVC.vlalignb(Builder, PrevV, ThisV, AlignVal);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeLine">      ASpanM[Index - 1].Seg.Val = HVC.vlalignb(Builder, PrevM, ThisM, AlignVal);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1370</td>
    <td class="codeLine">      ASpanM[Index - 1].Seg.Val = HVC.vlalignb(Builder, PrevM, ThisM, AlignVal);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1371</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1372</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1373</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1374</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeLine">    dbgs() << "ASpanV after vlalign:\n" << ASpanV << '\n';</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1375</td>
    <td class="codeLine">    dbgs() << "ASpanV after vlalign:\n" << ASpanV << '\n';</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeLine">    dbgs() << "ASpanM after vlalign:\n" << ASpanM << '\n';</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1376</td>
    <td class="codeLine">    dbgs() << "ASpanM after vlalign:\n" << ASpanM << '\n';</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1377</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1378</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeLine">  auto createStore = [&](IRBuilderBase &Builder, const ByteSpan &ASpanV,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1379</td>
    <td class="codeLine">  auto createStore = [&](IRBuilderBase &Builder, const ByteSpan &ASpanV,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeLine">                         const ByteSpan &ASpanM, int Index, bool MakePred) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1380</td>
    <td class="codeLine">                         const ByteSpan &ASpanM, int Index, bool MakePred) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeLine">    Value *Val = ASpanV[Index].Seg.Val;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1381</td>
    <td class="codeLine">    Value *Val = ASpanV[Index].Seg.Val;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeLine">    Value *Mask = ASpanM[Index].Seg.Val; // bytes</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1382</td>
    <td class="codeLine">    Value *Mask = ASpanM[Index].Seg.Val; // bytes</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeLine">    if (HVC.isUndef(Val) || HVC.isZero(Mask))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1383</td>
    <td class="codeLine">    if (HVC.isUndef(Val) || HVC.isZero(Mask))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1384</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeLine">    Value *Ptr =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1385</td>
    <td class="codeLine">    Value *Ptr =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeLine">        createAdjustedPointer(Builder, AlignAddr, SecTy, Index * ScLen);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1386</td>
    <td class="codeLine">        createAdjustedPointer(Builder, AlignAddr, SecTy, Index * ScLen);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeLine">    Value *Predicate =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1387</td>
    <td class="codeLine">    Value *Predicate =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeLine">        MakePred ? makeTestIfUnaligned(Builder, AlignVal, ScLen) : nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1388</td>
    <td class="codeLine">        MakePred ? makeTestIfUnaligned(Builder, AlignVal, ScLen) : nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1389</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeLine">    // If vector shifting is potentially needed, accumulate metadata</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1390</td>
    <td class="codeLine">    // If vector shifting is potentially needed, accumulate metadata</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeLine">    // from source sections of twice the store width.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1391</td>
    <td class="codeLine">    // from source sections of twice the store width.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeLine">    int Start = (Index - DoAlign) * ScLen;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1392</td>
    <td class="codeLine">    int Start = (Index - DoAlign) * ScLen;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeLine">    int Width = (1 + DoAlign) * ScLen;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1393</td>
    <td class="codeLine">    int Width = (1 + DoAlign) * ScLen;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeLine">    this->createStore(Builder, Val, Ptr, Predicate, ScLen,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1394</td>
    <td class="codeLine">    this->createStore(Builder, Val, Ptr, Predicate, ScLen,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeLine">                      HVC.vlsb(Builder, Mask),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1395</td>
    <td class="codeLine">                      HVC.vlsb(Builder, Mask),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeLine">                      VSpan.section(Start, Width).values());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1396</td>
    <td class="codeLine">                      VSpan.section(Start, Width).values());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1397</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1398</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeLine">  for (int Index = 0; Index != NumSectors + DoAlign; ++Index) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1399</td>
    <td class="codeLine">  for (int Index = 0; Index != NumSectors + DoAlign; ++Index) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeLine">    createStore(Builder, ASpanV, ASpanM, Index, DoAlign && Index == NumSectors);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1400</td>
    <td class="codeLine">    createStore(Builder, ASpanV, ASpanM, Index, DoAlign && Index == NumSectors);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1401</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1402</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1403</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeLine">auto AlignVectors::realignGroup(const MoveGroup &Move) const -> bool {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1404</td>
    <td class="codeLine">auto AlignVectors::realignGroup(const MoveGroup &Move) const -> bool {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Realigning group:\n" << Move << '\n');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1405</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Realigning group:\n" << Move << '\n');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1406</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeLine">  // TODO: Needs support for masked loads/stores of "scalar" vectors.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1407</td>
    <td class="codeLine">  // TODO: Needs support for masked loads/stores of "scalar" vectors.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeLine">  if (!Move.IsHvx)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1408</td>
    <td class="codeLine">  if (!Move.IsHvx)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1409</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1410</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeLine">  // Return the element with the maximum alignment from Range,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1411</td>
    <td class="codeLine">  // Return the element with the maximum alignment from Range,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeLine">  // where GetValue obtains the value to compare from an element.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1412</td>
    <td class="codeLine">  // where GetValue obtains the value to compare from an element.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeLine">  auto getMaxOf = [](auto Range, auto GetValue) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1413</td>
    <td class="codeLine">  auto getMaxOf = [](auto Range, auto GetValue) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeLine">    return *std::max_element(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1414</td>
    <td class="codeLine">    return *std::max_element(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeLine">        Range.begin(), Range.end(),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1415</td>
    <td class="codeLine">        Range.begin(), Range.end(),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeLine">        [&GetValue](auto &A, auto &B) { return GetValue(A) < GetValue(B); });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1416</td>
    <td class="codeLine">        [&GetValue](auto &A, auto &B) { return GetValue(A) < GetValue(B); });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1417</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1418</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeLine">  const AddrList &BaseInfos = AddrGroups.at(Move.Base);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1419</td>
    <td class="codeLine">  const AddrList &BaseInfos = AddrGroups.at(Move.Base);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1420</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeLine">  // Conceptually, there is a vector of N bytes covering the addresses</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1421</td>
    <td class="codeLine">  // Conceptually, there is a vector of N bytes covering the addresses</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeLine">  // starting from the minimum offset (i.e. Base.Addr+Start). This vector</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1422</td>
    <td class="codeLine">  // starting from the minimum offset (i.e. Base.Addr+Start). This vector</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeLine">  // represents a contiguous memory region that spans all accessed memory</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1423</td>
    <td class="codeLine">  // represents a contiguous memory region that spans all accessed memory</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeLine">  // locations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1424</td>
    <td class="codeLine">  // locations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeLine">  // The correspondence between loaded or stored values will be expressed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1425</td>
    <td class="codeLine">  // The correspondence between loaded or stored values will be expressed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeLine">  // in terms of this vector. For example, the 0th element of the vector</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1426</td>
    <td class="codeLine">  // in terms of this vector. For example, the 0th element of the vector</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeLine">  // from the Base address info will start at byte Start from the beginning</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1427</td>
    <td class="codeLine">  // from the Base address info will start at byte Start from the beginning</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeLine">  // of this conceptual vector.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1428</td>
    <td class="codeLine">  // of this conceptual vector.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1429</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeLine">  // This vector will be loaded/stored starting at the nearest down-aligned</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1430</td>
    <td class="codeLine">  // This vector will be loaded/stored starting at the nearest down-aligned</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeLine">  // address and the amount od the down-alignment will be AlignVal:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1431</td>
    <td class="codeLine">  // address and the amount od the down-alignment will be AlignVal:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeLine">  //   valign(load_vector(align_down(Base+Start)), AlignVal)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1432</td>
    <td class="codeLine">  //   valign(load_vector(align_down(Base+Start)), AlignVal)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1433</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeLine">  std::set<Instruction *> TestSet(Move.Main.begin(), Move.Main.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1434</td>
    <td class="codeLine">  std::set<Instruction *> TestSet(Move.Main.begin(), Move.Main.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeLine">  AddrList MoveInfos;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1435</td>
    <td class="codeLine">  AddrList MoveInfos;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeLine">  llvm::copy_if(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1436</td>
    <td class="codeLine">  llvm::copy_if(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeLine">      BaseInfos, std::back_inserter(MoveInfos),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1437</td>
    <td class="codeLine">      BaseInfos, std::back_inserter(MoveInfos),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeLine">      [&TestSet](const AddrInfo &AI) { return TestSet.count(AI.Inst); });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1438</td>
    <td class="codeLine">      [&TestSet](const AddrInfo &AI) { return TestSet.count(AI.Inst); });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1439</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeLine">  // Maximum alignment present in the whole address group.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1440</td>
    <td class="codeLine">  // Maximum alignment present in the whole address group.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeLine">  const AddrInfo &WithMaxAlign =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1441</td>
    <td class="codeLine">  const AddrInfo &WithMaxAlign =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeLine">      getMaxOf(MoveInfos, [](const AddrInfo &AI) { return AI.HaveAlign; });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1442</td>
    <td class="codeLine">      getMaxOf(MoveInfos, [](const AddrInfo &AI) { return AI.HaveAlign; });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeLine">  Align MaxGiven = WithMaxAlign.HaveAlign;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1443</td>
    <td class="codeLine">  Align MaxGiven = WithMaxAlign.HaveAlign;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1444</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeLine">  // Minimum alignment present in the move address group.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1445</td>
    <td class="codeLine">  // Minimum alignment present in the move address group.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeLine">  const AddrInfo &WithMinOffset =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1446</td>
    <td class="codeLine">  const AddrInfo &WithMinOffset =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeLine">      getMaxOf(MoveInfos, [](const AddrInfo &AI) { return -AI.Offset; });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1447</td>
    <td class="codeLine">      getMaxOf(MoveInfos, [](const AddrInfo &AI) { return -AI.Offset; });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1448</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeLine">  const AddrInfo &WithMaxNeeded =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1449</td>
    <td class="codeLine">  const AddrInfo &WithMaxNeeded =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeLine">      getMaxOf(MoveInfos, [](const AddrInfo &AI) { return AI.NeedAlign; });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1450</td>
    <td class="codeLine">      getMaxOf(MoveInfos, [](const AddrInfo &AI) { return AI.NeedAlign; });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeLine">  Align MinNeeded = WithMaxNeeded.NeedAlign;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1451</td>
    <td class="codeLine">  Align MinNeeded = WithMaxNeeded.NeedAlign;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1452</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeLine">  // Set the builder's insertion point right before the load group, or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1453</td>
    <td class="codeLine">  // Set the builder's insertion point right before the load group, or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeLine">  // immediately after the store group. (Instructions in a store group are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1454</td>
    <td class="codeLine">  // immediately after the store group. (Instructions in a store group are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeLine">  // listed in reverse order.)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1455</td>
    <td class="codeLine">  // listed in reverse order.)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeLine">  Instruction *InsertAt = Move.Main.front();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1456</td>
    <td class="codeLine">  Instruction *InsertAt = Move.Main.front();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeLine">  if (!Move.IsLoad) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1457</td>
    <td class="codeLine">  if (!Move.IsLoad) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeLine">    // There should be a terminator (which store isn't, but check anyways).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1458</td>
    <td class="codeLine">    // There should be a terminator (which store isn't, but check anyways).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeLine">    assert(InsertAt->getIterator() != InsertAt->getParent()->end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1459</td>
    <td class="codeLine">    assert(InsertAt->getIterator() != InsertAt->getParent()->end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeLine">    InsertAt = &*std::next(InsertAt->getIterator());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1460</td>
    <td class="codeLine">    InsertAt = &*std::next(InsertAt->getIterator());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1461</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1462</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeLine">  IRBuilder Builder(InsertAt->getParent(), InsertAt->getIterator(),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1463</td>
    <td class="codeLine">  IRBuilder Builder(InsertAt->getParent(), InsertAt->getIterator(),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeLine">                    InstSimplifyFolder(HVC.DL));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1464</td>
    <td class="codeLine">                    InstSimplifyFolder(HVC.DL));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeLine">  Value *AlignAddr = nullptr; // Actual aligned address.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1465</td>
    <td class="codeLine">  Value *AlignAddr = nullptr; // Actual aligned address.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeLine">  Value *AlignVal = nullptr;  // Right-shift amount (for valign).</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1466</td>
    <td class="codeLine">  Value *AlignVal = nullptr;  // Right-shift amount (for valign).</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1467</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeLine">  if (MinNeeded <= MaxGiven) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1468</td>
    <td class="codeLine">  if (MinNeeded <= MaxGiven) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeLine">    int Start = WithMinOffset.Offset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1469</td>
    <td class="codeLine">    int Start = WithMinOffset.Offset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeLine">    int OffAtMax = WithMaxAlign.Offset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1470</td>
    <td class="codeLine">    int OffAtMax = WithMaxAlign.Offset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeLine">    // Shift the offset of the maximally aligned instruction (OffAtMax)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1471</td>
    <td class="codeLine">    // Shift the offset of the maximally aligned instruction (OffAtMax)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeLine">    // back by just enough multiples of the required alignment to cover the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1472</td>
    <td class="codeLine">    // back by just enough multiples of the required alignment to cover the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeLine">    // distance from Start to OffAtMax.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1473</td>
    <td class="codeLine">    // distance from Start to OffAtMax.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeLine">    // Calculate the address adjustment amount based on the address with the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1474</td>
    <td class="codeLine">    // Calculate the address adjustment amount based on the address with the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeLine">    // maximum alignment. This is to allow a simple gep instruction instead</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1475</td>
    <td class="codeLine">    // maximum alignment. This is to allow a simple gep instruction instead</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeLine">    // of potential bitcasts to i8*.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1476</td>
    <td class="codeLine">    // of potential bitcasts to i8*.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeLine">    int Adjust = -alignTo(OffAtMax - Start, MinNeeded.value());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1477</td>
    <td class="codeLine">    int Adjust = -alignTo(OffAtMax - Start, MinNeeded.value());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeLine">    AlignAddr = createAdjustedPointer(Builder, WithMaxAlign.Addr,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1478</td>
    <td class="codeLine">    AlignAddr = createAdjustedPointer(Builder, WithMaxAlign.Addr,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeLine">                                      WithMaxAlign.ValTy, Adjust, Move.Clones);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1479</td>
    <td class="codeLine">                                      WithMaxAlign.ValTy, Adjust, Move.Clones);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeLine">    int Diff = Start - (OffAtMax + Adjust);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1480</td>
    <td class="codeLine">    int Diff = Start - (OffAtMax + Adjust);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeLine">    AlignVal = HVC.getConstInt(Diff);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1481</td>
    <td class="codeLine">    AlignVal = HVC.getConstInt(Diff);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeLine">    assert(Diff >= 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1482</td>
    <td class="codeLine">    assert(Diff >= 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeLine">    assert(static_cast<decltype(MinNeeded.value())>(Diff) < MinNeeded.value());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1483</td>
    <td class="codeLine">    assert(static_cast<decltype(MinNeeded.value())>(Diff) < MinNeeded.value());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1484</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeLine">    // WithMinOffset is the lowest address in the group,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1485</td>
    <td class="codeLine">    // WithMinOffset is the lowest address in the group,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeLine">    //   WithMinOffset.Addr = Base+Start.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1486</td>
    <td class="codeLine">    //   WithMinOffset.Addr = Base+Start.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeLine">    // Align instructions for both HVX (V6_valign) and scalar (S2_valignrb)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1487</td>
    <td class="codeLine">    // Align instructions for both HVX (V6_valign) and scalar (S2_valignrb)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeLine">    // mask off unnecessary bits, so it's ok to just the original pointer as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1488</td>
    <td class="codeLine">    // mask off unnecessary bits, so it's ok to just the original pointer as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeLine">    // the alignment amount.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1489</td>
    <td class="codeLine">    // the alignment amount.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeLine">    // Do an explicit down-alignment of the address to avoid creating an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1490</td>
    <td class="codeLine">    // Do an explicit down-alignment of the address to avoid creating an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeLine">    // aligned instruction with an address that is not really aligned.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1491</td>
    <td class="codeLine">    // aligned instruction with an address that is not really aligned.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeLine">    AlignAddr =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1492</td>
    <td class="codeLine">    AlignAddr =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeLine">        createAlignedPointer(Builder, WithMinOffset.Addr, WithMinOffset.ValTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1493</td>
    <td class="codeLine">        createAlignedPointer(Builder, WithMinOffset.Addr, WithMinOffset.ValTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeLine">                             MinNeeded.value(), Move.Clones);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1494</td>
    <td class="codeLine">                             MinNeeded.value(), Move.Clones);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeLine">    AlignVal =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1495</td>
    <td class="codeLine">    AlignVal =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeLine">        Builder.CreatePtrToInt(WithMinOffset.Addr, HVC.getIntTy(), "pti");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1496</td>
    <td class="codeLine">        Builder.CreatePtrToInt(WithMinOffset.Addr, HVC.getIntTy(), "pti");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeLine">    if (auto *I = dyn_cast<Instruction>(AlignVal)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1497</td>
    <td class="codeLine">    if (auto *I = dyn_cast<Instruction>(AlignVal)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeLine">      for (auto [Old, New] : Move.Clones)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1498</td>
    <td class="codeLine">      for (auto [Old, New] : Move.Clones)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeLine">        I->replaceUsesOfWith(Old, New);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1499</td>
    <td class="codeLine">        I->replaceUsesOfWith(Old, New);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1500</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1501</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1502</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeLine">  ByteSpan VSpan;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1503</td>
    <td class="codeLine">  ByteSpan VSpan;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeLine">  for (const AddrInfo &AI : MoveInfos) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1504</td>
    <td class="codeLine">  for (const AddrInfo &AI : MoveInfos) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeLine">    VSpan.Blocks.emplace_back(AI.Inst, HVC.getSizeOf(AI.ValTy),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1505</td>
    <td class="codeLine">    VSpan.Blocks.emplace_back(AI.Inst, HVC.getSizeOf(AI.ValTy),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeLine">                              AI.Offset - WithMinOffset.Offset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1506</td>
    <td class="codeLine">                              AI.Offset - WithMinOffset.Offset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1507</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1508</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeLine">  // The aligned loads/stores will use blocks that are either scalars,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1509</td>
    <td class="codeLine">  // The aligned loads/stores will use blocks that are either scalars,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeLine">  // or HVX vectors. Let "sector" be the unified term for such a block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1510</td>
    <td class="codeLine">  // or HVX vectors. Let "sector" be the unified term for such a block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeLine">  // blend(scalar, vector) -> sector...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1511</td>
    <td class="codeLine">  // blend(scalar, vector) -> sector...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeLine">  int ScLen = Move.IsHvx ? HVC.HST.getVectorLength()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1512</td>
    <td class="codeLine">  int ScLen = Move.IsHvx ? HVC.HST.getVectorLength()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeLine">                         : std::max<int>(MinNeeded.value(), 4);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1513</td>
    <td class="codeLine">                         : std::max<int>(MinNeeded.value(), 4);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeLine">  assert(!Move.IsHvx || ScLen == 64 || ScLen == 128);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1514</td>
    <td class="codeLine">  assert(!Move.IsHvx || ScLen == 64 || ScLen == 128);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeLine">  assert(Move.IsHvx || ScLen == 4 || ScLen == 8);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1515</td>
    <td class="codeLine">  assert(Move.IsHvx || ScLen == 4 || ScLen == 8);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1516</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1517</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeLine">    dbgs() << "ScLen:  " << ScLen << "\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1518</td>
    <td class="codeLine">    dbgs() << "ScLen:  " << ScLen << "\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeLine">    dbgs() << "AlignVal:" << *AlignVal << "\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1519</td>
    <td class="codeLine">    dbgs() << "AlignVal:" << *AlignVal << "\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeLine">    dbgs() << "AlignAddr:" << *AlignAddr << "\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1520</td>
    <td class="codeLine">    dbgs() << "AlignAddr:" << *AlignAddr << "\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeLine">    dbgs() << "VSpan:\n" << VSpan << '\n';</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1521</td>
    <td class="codeLine">    dbgs() << "VSpan:\n" << VSpan << '\n';</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1522</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1523</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeLine">  if (Move.IsLoad)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1524</td>
    <td class="codeLine">  if (Move.IsLoad)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeLine">    realignLoadGroup(Builder, VSpan, ScLen, AlignVal, AlignAddr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1525</td>
    <td class="codeLine">    realignLoadGroup(Builder, VSpan, ScLen, AlignVal, AlignAddr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1526</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeLine">    realignStoreGroup(Builder, VSpan, ScLen, AlignVal, AlignAddr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1527</td>
    <td class="codeLine">    realignStoreGroup(Builder, VSpan, ScLen, AlignVal, AlignAddr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1528</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeLine">  for (auto *Inst : Move.Main)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1529</td>
    <td class="codeLine">  for (auto *Inst : Move.Main)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeLine">    Inst->eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1530</td>
    <td class="codeLine">    Inst->eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1531</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1532</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1533</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1534</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeLine">auto AlignVectors::makeTestIfUnaligned(IRBuilderBase &Builder, Value *AlignVal,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1535</td>
    <td class="codeLine">auto AlignVectors::makeTestIfUnaligned(IRBuilderBase &Builder, Value *AlignVal,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeLine">                                       int Alignment) const -> Value * {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1536</td>
    <td class="codeLine">                                       int Alignment) const -> Value * {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeLine">  auto *AlignTy = AlignVal->getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1537</td>
    <td class="codeLine">  auto *AlignTy = AlignVal->getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeLine">  Value *And = Builder.CreateAnd(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1538</td>
    <td class="codeLine">  Value *And = Builder.CreateAnd(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeLine">      AlignVal, ConstantInt::get(AlignTy, Alignment - 1), "and");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1539</td>
    <td class="codeLine">      AlignVal, ConstantInt::get(AlignTy, Alignment - 1), "and");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeLine">  Value *Zero = ConstantInt::get(AlignTy, 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1540</td>
    <td class="codeLine">  Value *Zero = ConstantInt::get(AlignTy, 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeLine">  return Builder.CreateICmpNE(And, Zero, "isz");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1541</td>
    <td class="codeLine">  return Builder.CreateICmpNE(And, Zero, "isz");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1542</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1543</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeLine">auto AlignVectors::isSectorTy(Type *Ty) const -> bool {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1544</td>
    <td class="codeLine">auto AlignVectors::isSectorTy(Type *Ty) const -> bool {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeLine">  if (!HVC.isByteVecTy(Ty))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1545</td>
    <td class="codeLine">  if (!HVC.isByteVecTy(Ty))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1546</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeLine">  int Size = HVC.getSizeOf(Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1547</td>
    <td class="codeLine">  int Size = HVC.getSizeOf(Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeLine">  if (HVC.HST.isTypeForHVX(Ty))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1548</td>
    <td class="codeLine">  if (HVC.HST.isTypeForHVX(Ty))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeLine">    return Size == static_cast<int>(HVC.HST.getVectorLength());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1549</td>
    <td class="codeLine">    return Size == static_cast<int>(HVC.HST.getVectorLength());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeLine">  return Size == 4 || Size == 8;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1550</td>
    <td class="codeLine">  return Size == 4 || Size == 8;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1551</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1552</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeLine">auto AlignVectors::run() -> bool {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1553</td>
    <td class="codeLine">auto AlignVectors::run() -> bool {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Running HVC::AlignVectors on " << HVC.F.getName()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1554</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Running HVC::AlignVectors on " << HVC.F.getName()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeLine">                    << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1555</td>
    <td class="codeLine">                    << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeLine">  if (!createAddressGroups())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1556</td>
    <td class="codeLine">  if (!createAddressGroups())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1557</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1558</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1559</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeLine">    dbgs() << "Address groups(" << AddrGroups.size() << "):\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1560</td>
    <td class="codeLine">    dbgs() << "Address groups(" << AddrGroups.size() << "):\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeLine">    for (auto &[In, AL] : AddrGroups) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1561</td>
    <td class="codeLine">    for (auto &[In, AL] : AddrGroups) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeLine">      for (const AddrInfo &AI : AL)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1562</td>
    <td class="codeLine">      for (const AddrInfo &AI : AL)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeLine">        dbgs() << "---\n" << AI << '\n';</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1563</td>
    <td class="codeLine">        dbgs() << "---\n" << AI << '\n';</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1564</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1565</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1566</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1567</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeLine">  MoveList LoadGroups, StoreGroups;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1568</td>
    <td class="codeLine">  MoveList LoadGroups, StoreGroups;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1569</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeLine">  for (auto &G : AddrGroups) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1570</td>
    <td class="codeLine">  for (auto &G : AddrGroups) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeLine">    llvm::append_range(LoadGroups, createLoadGroups(G.second));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1571</td>
    <td class="codeLine">    llvm::append_range(LoadGroups, createLoadGroups(G.second));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeLine">    llvm::append_range(StoreGroups, createStoreGroups(G.second));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1572</td>
    <td class="codeLine">    llvm::append_range(StoreGroups, createStoreGroups(G.second));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1573</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1574</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1575</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeLine">    dbgs() << "\nLoad groups(" << LoadGroups.size() << "):\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1576</td>
    <td class="codeLine">    dbgs() << "\nLoad groups(" << LoadGroups.size() << "):\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeLine">    for (const MoveGroup &G : LoadGroups)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1577</td>
    <td class="codeLine">    for (const MoveGroup &G : LoadGroups)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeLine">      dbgs() << G << "\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1578</td>
    <td class="codeLine">      dbgs() << G << "\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeLine">    dbgs() << "Store groups(" << StoreGroups.size() << "):\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1579</td>
    <td class="codeLine">    dbgs() << "Store groups(" << StoreGroups.size() << "):\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeLine">    for (const MoveGroup &G : StoreGroups)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1580</td>
    <td class="codeLine">    for (const MoveGroup &G : StoreGroups)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeLine">      dbgs() << G << "\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1581</td>
    <td class="codeLine">      dbgs() << G << "\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1582</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1583</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeLine">  // Cumulative limit on the number of groups.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1584</td>
    <td class="codeLine">  // Cumulative limit on the number of groups.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeLine">  unsigned CountLimit = VAGroupCountLimit;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1585</td>
    <td class="codeLine">  unsigned CountLimit = VAGroupCountLimit;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeLine">  if (CountLimit == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1586</td>
    <td class="codeLine">  if (CountLimit == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1587</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1588</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeLine">  if (LoadGroups.size() > CountLimit) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1589</td>
    <td class="codeLine">  if (LoadGroups.size() > CountLimit) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeLine">    LoadGroups.resize(CountLimit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1590</td>
    <td class="codeLine">    LoadGroups.resize(CountLimit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeLine">    StoreGroups.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1591</td>
    <td class="codeLine">    StoreGroups.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1592</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeLine">    unsigned StoreLimit = CountLimit - LoadGroups.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1593</td>
    <td class="codeLine">    unsigned StoreLimit = CountLimit - LoadGroups.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeLine">    if (StoreGroups.size() > StoreLimit)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1594</td>
    <td class="codeLine">    if (StoreGroups.size() > StoreLimit)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeLine">      StoreGroups.resize(StoreLimit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1595</td>
    <td class="codeLine">      StoreGroups.resize(StoreLimit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1596</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1597</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeLine">  for (auto &M : LoadGroups)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1598</td>
    <td class="codeLine">  for (auto &M : LoadGroups)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeLine">    Changed |= moveTogether(M);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1599</td>
    <td class="codeLine">    Changed |= moveTogether(M);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeLine">  for (auto &M : StoreGroups)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1600</td>
    <td class="codeLine">  for (auto &M : StoreGroups)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeLine">    Changed |= moveTogether(M);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1601</td>
    <td class="codeLine">    Changed |= moveTogether(M);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1602</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "After moveTogether:\n" << HVC.F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1603</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "After moveTogether:\n" << HVC.F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1604</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeLine">  for (auto &M : LoadGroups)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1605</td>
    <td class="codeLine">  for (auto &M : LoadGroups)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeLine">    Changed |= realignGroup(M);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1606</td>
    <td class="codeLine">    Changed |= realignGroup(M);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeLine">  for (auto &M : StoreGroups)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1607</td>
    <td class="codeLine">  for (auto &M : StoreGroups)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeLine">    Changed |= realignGroup(M);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1608</td>
    <td class="codeLine">    Changed |= realignGroup(M);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1609</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1610</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1611</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1612</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeLine">// --- End AlignVectors</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1613</td>
    <td class="codeLine">// --- End AlignVectors</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1614</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeLine">// --- Begin HvxIdioms</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1615</td>
    <td class="codeLine">// --- Begin HvxIdioms</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1616</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeLine">auto HvxIdioms::getNumSignificantBits(Value *V, Instruction *In) const</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1617</td>
    <td class="codeLine">auto HvxIdioms::getNumSignificantBits(Value *V, Instruction *In) const</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeLine">    -> std::pair<unsigned, Signedness> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1618</td>
    <td class="codeLine">    -> std::pair<unsigned, Signedness> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeLine">  unsigned Bits = HVC.getNumSignificantBits(V, In);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1619</td>
    <td class="codeLine">  unsigned Bits = HVC.getNumSignificantBits(V, In);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeLine">  // The significant bits are calculated including the sign bit. This may</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1620</td>
    <td class="codeLine">  // The significant bits are calculated including the sign bit. This may</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeLine">  // add an extra bit for zero-extended values, e.g. (zext i32 to i64) may</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1621</td>
    <td class="codeLine">  // add an extra bit for zero-extended values, e.g. (zext i32 to i64) may</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeLine">  // result in 33 significant bits. To avoid extra words, skip the extra</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1622</td>
    <td class="codeLine">  // result in 33 significant bits. To avoid extra words, skip the extra</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeLine">  // sign bit, but keep information that the value is to be treated as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1623</td>
    <td class="codeLine">  // sign bit, but keep information that the value is to be treated as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeLine">  // unsigned.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1624</td>
    <td class="codeLine">  // unsigned.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeLine">  KnownBits Known = HVC.getKnownBits(V, In);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1625</td>
    <td class="codeLine">  KnownBits Known = HVC.getKnownBits(V, In);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeLine">  Signedness Sign = Signed;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1626</td>
    <td class="codeLine">  Signedness Sign = Signed;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeLine">  unsigned NumToTest = 0; // Number of bits used in test for unsignedness.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1627</td>
    <td class="codeLine">  unsigned NumToTest = 0; // Number of bits used in test for unsignedness.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeLine">  if (isPowerOf2_32(Bits))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1628</td>
    <td class="codeLine">  if (isPowerOf2_32(Bits))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeLine">    NumToTest = Bits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1629</td>
    <td class="codeLine">    NumToTest = Bits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeLine">  else if (Bits > 1 && isPowerOf2_32(Bits - 1))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1630</td>
    <td class="codeLine">  else if (Bits > 1 && isPowerOf2_32(Bits - 1))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeLine">    NumToTest = Bits - 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1631</td>
    <td class="codeLine">    NumToTest = Bits - 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1632</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeLine">  if (NumToTest != 0 && Known.Zero.ashr(NumToTest).isAllOnes()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1633</td>
    <td class="codeLine">  if (NumToTest != 0 && Known.Zero.ashr(NumToTest).isAllOnes()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeLine">    Sign = Unsigned;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1634</td>
    <td class="codeLine">    Sign = Unsigned;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeLine">    Bits = NumToTest;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1635</td>
    <td class="codeLine">    Bits = NumToTest;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1636</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1637</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeLine">  // If the top bit of the nearest power-of-2 is zero, this value is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1638</td>
    <td class="codeLine">  // If the top bit of the nearest power-of-2 is zero, this value is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeLine">  // positive. It could be treated as either signed or unsigned.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1639</td>
    <td class="codeLine">  // positive. It could be treated as either signed or unsigned.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeLine">  if (unsigned Pow2 = PowerOf2Ceil(Bits); Pow2 != Bits) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1640</td>
    <td class="codeLine">  if (unsigned Pow2 = PowerOf2Ceil(Bits); Pow2 != Bits) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeLine">    if (Known.Zero.ashr(Pow2 - 1).isAllOnes())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1641</td>
    <td class="codeLine">    if (Known.Zero.ashr(Pow2 - 1).isAllOnes())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeLine">      Sign = Positive;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1642</td>
    <td class="codeLine">      Sign = Positive;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1643</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeLine">  return {Bits, Sign};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1644</td>
    <td class="codeLine">  return {Bits, Sign};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1645</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1646</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeLine">auto HvxIdioms::canonSgn(SValue X, SValue Y) const</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1647</td>
    <td class="codeLine">auto HvxIdioms::canonSgn(SValue X, SValue Y) const</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeLine">    -> std::pair<SValue, SValue> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1648</td>
    <td class="codeLine">    -> std::pair<SValue, SValue> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeLine">  // Canonicalize the signedness of X and Y, so that the result is one of:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1649</td>
    <td class="codeLine">  // Canonicalize the signedness of X and Y, so that the result is one of:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeLine">  //   S, S</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1650</td>
    <td class="codeLine">  //   S, S</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeLine">  //   U/P, S</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1651</td>
    <td class="codeLine">  //   U/P, S</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeLine">  //   U/P, U/P</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1652</td>
    <td class="codeLine">  //   U/P, U/P</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeLine">  if (X.Sgn == Signed && Y.Sgn != Signed)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1653</td>
    <td class="codeLine">  if (X.Sgn == Signed && Y.Sgn != Signed)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeLine">    std::swap(X, Y);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1654</td>
    <td class="codeLine">    std::swap(X, Y);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeLine">  return {X, Y};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1655</td>
    <td class="codeLine">  return {X, Y};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1656</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1657</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeLine">// Match</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1658</td>
    <td class="codeLine">// Match</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeLine">//   (X * Y) [>> N], or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1659</td>
    <td class="codeLine">//   (X * Y) [>> N], or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeLine">//   ((X * Y) + (1 << M)) >> N</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1660</td>
    <td class="codeLine">//   ((X * Y) + (1 << M)) >> N</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeLine">auto HvxIdioms::matchFxpMul(Instruction &In) const -> std::optional<FxpOp> {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1661</td>
    <td class="codeLine">auto HvxIdioms::matchFxpMul(Instruction &In) const -> std::optional<FxpOp> {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeLine">  using namespace PatternMatch;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1662</td>
    <td class="codeLine">  using namespace PatternMatch;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeLine">  auto *Ty = In.getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1663</td>
    <td class="codeLine">  auto *Ty = In.getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1664</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeLine">  if (!Ty->isVectorTy() || !Ty->getScalarType()->isIntegerTy())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1665</td>
    <td class="codeLine">  if (!Ty->isVectorTy() || !Ty->getScalarType()->isIntegerTy())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1666</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1667</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeLine">  unsigned Width = cast<IntegerType>(Ty->getScalarType())->getBitWidth();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1668</td>
    <td class="codeLine">  unsigned Width = cast<IntegerType>(Ty->getScalarType())->getBitWidth();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1669</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeLine">  FxpOp Op;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1670</td>
    <td class="codeLine">  FxpOp Op;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeLine">  Value *Exp = &In;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1671</td>
    <td class="codeLine">  Value *Exp = &In;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1672</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeLine">  // Fixed-point multiplication is always shifted right (except when the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1673</td>
    <td class="codeLine">  // Fixed-point multiplication is always shifted right (except when the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeLine">  // fraction is 0 bits).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1674</td>
    <td class="codeLine">  // fraction is 0 bits).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeLine">  auto m_Shr = [](auto &&V, auto &&S) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1675</td>
    <td class="codeLine">  auto m_Shr = [](auto &&V, auto &&S) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeLine">    return m_CombineOr(m_LShr(V, S), m_AShr(V, S));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1676</td>
    <td class="codeLine">    return m_CombineOr(m_LShr(V, S), m_AShr(V, S));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1677</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1678</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeLine">  const APInt *Qn = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1679</td>
    <td class="codeLine">  const APInt *Qn = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeLine">  if (Value * T; match(Exp, m_Shr(m_Value(T), m_APInt(Qn)))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1680</td>
    <td class="codeLine">  if (Value * T; match(Exp, m_Shr(m_Value(T), m_APInt(Qn)))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeLine">    Op.Frac = Qn->getZExtValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1681</td>
    <td class="codeLine">    Op.Frac = Qn->getZExtValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeLine">    Exp = T;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1682</td>
    <td class="codeLine">    Exp = T;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1683</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeLine">    Op.Frac = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1684</td>
    <td class="codeLine">    Op.Frac = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1685</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1686</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeLine">  if (Op.Frac > Width)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1687</td>
    <td class="codeLine">  if (Op.Frac > Width)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1688</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1689</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeLine">  // Check if there is rounding added.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1690</td>
    <td class="codeLine">  // Check if there is rounding added.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeLine">  const APInt *C = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1691</td>
    <td class="codeLine">  const APInt *C = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeLine">  if (Value * T; Op.Frac > 0 && match(Exp, m_Add(m_Value(T), m_APInt(C)))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1692</td>
    <td class="codeLine">  if (Value * T; Op.Frac > 0 && match(Exp, m_Add(m_Value(T), m_APInt(C)))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeLine">    uint64_t CV = C->getZExtValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1693</td>
    <td class="codeLine">    uint64_t CV = C->getZExtValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeLine">    if (CV != 0 && !isPowerOf2_64(CV))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1694</td>
    <td class="codeLine">    if (CV != 0 && !isPowerOf2_64(CV))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeLine">      return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1695</td>
    <td class="codeLine">      return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeLine">    if (CV != 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1696</td>
    <td class="codeLine">    if (CV != 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeLine">      Op.RoundAt = Log2_64(CV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1697</td>
    <td class="codeLine">      Op.RoundAt = Log2_64(CV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeLine">    Exp = T;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1698</td>
    <td class="codeLine">    Exp = T;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1699</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1700</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeLine">  // Check if the rest is a multiplication.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1701</td>
    <td class="codeLine">  // Check if the rest is a multiplication.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeLine">  if (match(Exp, m_Mul(m_Value(Op.X.Val), m_Value(Op.Y.Val)))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1702</td>
    <td class="codeLine">  if (match(Exp, m_Mul(m_Value(Op.X.Val), m_Value(Op.Y.Val)))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeLine">    Op.Opcode = Instruction::Mul;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1703</td>
    <td class="codeLine">    Op.Opcode = Instruction::Mul;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeLine">    // FIXME: The information below is recomputed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1704</td>
    <td class="codeLine">    // FIXME: The information below is recomputed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeLine">    Op.X.Sgn = getNumSignificantBits(Op.X.Val, &In).second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1705</td>
    <td class="codeLine">    Op.X.Sgn = getNumSignificantBits(Op.X.Val, &In).second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeLine">    Op.Y.Sgn = getNumSignificantBits(Op.Y.Val, &In).second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1706</td>
    <td class="codeLine">    Op.Y.Sgn = getNumSignificantBits(Op.Y.Val, &In).second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeLine">    Op.ResTy = cast<VectorType>(Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1707</td>
    <td class="codeLine">    Op.ResTy = cast<VectorType>(Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeLine">    return Op;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1708</td>
    <td class="codeLine">    return Op;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1709</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1710</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeLine">  return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1711</td>
    <td class="codeLine">  return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1712</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1713</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeLine">auto HvxIdioms::processFxpMul(Instruction &In, const FxpOp &Op) const</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1714</td>
    <td class="codeLine">auto HvxIdioms::processFxpMul(Instruction &In, const FxpOp &Op) const</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeLine">    -> Value * {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1715</td>
    <td class="codeLine">    -> Value * {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeLine">  assert(Op.X.Val->getType() == Op.Y.Val->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1716</td>
    <td class="codeLine">  assert(Op.X.Val->getType() == Op.Y.Val->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1717</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeLine">  auto *VecTy = dyn_cast<VectorType>(Op.X.Val->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1718</td>
    <td class="codeLine">  auto *VecTy = dyn_cast<VectorType>(Op.X.Val->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeLine">  if (VecTy == nullptr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1719</td>
    <td class="codeLine">  if (VecTy == nullptr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1720</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeLine">  auto *ElemTy = cast<IntegerType>(VecTy->getElementType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1721</td>
    <td class="codeLine">  auto *ElemTy = cast<IntegerType>(VecTy->getElementType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeLine">  unsigned ElemWidth = ElemTy->getBitWidth();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1722</td>
    <td class="codeLine">  unsigned ElemWidth = ElemTy->getBitWidth();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1723</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeLine">  // TODO: This can be relaxed after legalization is done pre-isel.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1724</td>
    <td class="codeLine">  // TODO: This can be relaxed after legalization is done pre-isel.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeLine">  if ((HVC.length(VecTy) * ElemWidth) % (8 * HVC.HST.getVectorLength()) != 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1725</td>
    <td class="codeLine">  if ((HVC.length(VecTy) * ElemWidth) % (8 * HVC.HST.getVectorLength()) != 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1726</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1727</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeLine">  // There are no special intrinsics that should be used for multiplying</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1728</td>
    <td class="codeLine">  // There are no special intrinsics that should be used for multiplying</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeLine">  // signed 8-bit values, so just skip them. Normal codegen should handle</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1729</td>
    <td class="codeLine">  // signed 8-bit values, so just skip them. Normal codegen should handle</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeLine">  // this just fine.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1730</td>
    <td class="codeLine">  // this just fine.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeLine">  if (ElemWidth <= 8)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1731</td>
    <td class="codeLine">  if (ElemWidth <= 8)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1732</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeLine">  // Similarly, if this is just a multiplication that can be handled without</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1733</td>
    <td class="codeLine">  // Similarly, if this is just a multiplication that can be handled without</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeLine">  // intervention, then leave it alone.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1734</td>
    <td class="codeLine">  // intervention, then leave it alone.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeLine">  if (ElemWidth <= 32 && Op.Frac == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1735</td>
    <td class="codeLine">  if (ElemWidth <= 32 && Op.Frac == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1736</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1737</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeLine">  auto [BitsX, SignX] = getNumSignificantBits(Op.X.Val, &In);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1738</td>
    <td class="codeLine">  auto [BitsX, SignX] = getNumSignificantBits(Op.X.Val, &In);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeLine">  auto [BitsY, SignY] = getNumSignificantBits(Op.Y.Val, &In);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1739</td>
    <td class="codeLine">  auto [BitsY, SignY] = getNumSignificantBits(Op.Y.Val, &In);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1740</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeLine">  // TODO: Add multiplication of vectors by scalar registers (up to 4 bytes).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1741</td>
    <td class="codeLine">  // TODO: Add multiplication of vectors by scalar registers (up to 4 bytes).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1742</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeLine">  Value *X = Op.X.Val, *Y = Op.Y.Val;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1743</td>
    <td class="codeLine">  Value *X = Op.X.Val, *Y = Op.Y.Val;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeLine">  IRBuilder Builder(In.getParent(), In.getIterator(),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1744</td>
    <td class="codeLine">  IRBuilder Builder(In.getParent(), In.getIterator(),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeLine">                    InstSimplifyFolder(HVC.DL));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1745</td>
    <td class="codeLine">                    InstSimplifyFolder(HVC.DL));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1746</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeLine">  auto roundUpWidth = [](unsigned Width) -> unsigned {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1747</td>
    <td class="codeLine">  auto roundUpWidth = [](unsigned Width) -> unsigned {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeLine">    if (Width <= 32 && !isPowerOf2_32(Width)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1748</td>
    <td class="codeLine">    if (Width <= 32 && !isPowerOf2_32(Width)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeLine">      // If the element width is not a power of 2, round it up</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1749</td>
    <td class="codeLine">      // If the element width is not a power of 2, round it up</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeLine">      // to the next one. Do this for widths not exceeding 32.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1750</td>
    <td class="codeLine">      // to the next one. Do this for widths not exceeding 32.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeLine">      return PowerOf2Ceil(Width);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1751</td>
    <td class="codeLine">      return PowerOf2Ceil(Width);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1752</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeLine">    if (Width > 32 && Width % 32 != 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1753</td>
    <td class="codeLine">    if (Width > 32 && Width % 32 != 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeLine">      // For wider elements, round it up to the multiple of 32.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1754</td>
    <td class="codeLine">      // For wider elements, round it up to the multiple of 32.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeLine">      return alignTo(Width, 32u);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1755</td>
    <td class="codeLine">      return alignTo(Width, 32u);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1756</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeLine">    return Width;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1757</td>
    <td class="codeLine">    return Width;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1758</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1759</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeLine">  BitsX = roundUpWidth(BitsX);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1760</td>
    <td class="codeLine">  BitsX = roundUpWidth(BitsX);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeLine">  BitsY = roundUpWidth(BitsY);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1761</td>
    <td class="codeLine">  BitsY = roundUpWidth(BitsY);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1762</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeLine">  // For elementwise multiplication vectors must have the same lengths, so</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1763</td>
    <td class="codeLine">  // For elementwise multiplication vectors must have the same lengths, so</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeLine">  // resize the elements of both inputs to the same width, the max of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1764</td>
    <td class="codeLine">  // resize the elements of both inputs to the same width, the max of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeLine">  // calculated significant bits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1765</td>
    <td class="codeLine">  // calculated significant bits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeLine">  unsigned Width = std::max(BitsX, BitsY);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1766</td>
    <td class="codeLine">  unsigned Width = std::max(BitsX, BitsY);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1767</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeLine">  auto *ResizeTy = VectorType::get(HVC.getIntTy(Width), VecTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1768</td>
    <td class="codeLine">  auto *ResizeTy = VectorType::get(HVC.getIntTy(Width), VecTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeLine">  if (Width < ElemWidth) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1769</td>
    <td class="codeLine">  if (Width < ElemWidth) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeLine">    X = Builder.CreateTrunc(X, ResizeTy, "trn");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1770</td>
    <td class="codeLine">    X = Builder.CreateTrunc(X, ResizeTy, "trn");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeLine">    Y = Builder.CreateTrunc(Y, ResizeTy, "trn");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1771</td>
    <td class="codeLine">    Y = Builder.CreateTrunc(Y, ResizeTy, "trn");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeLine">  } else if (Width > ElemWidth) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1772</td>
    <td class="codeLine">  } else if (Width > ElemWidth) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeLine">    X = SignX == Signed ? Builder.CreateSExt(X, ResizeTy, "sxt")</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1773</td>
    <td class="codeLine">    X = SignX == Signed ? Builder.CreateSExt(X, ResizeTy, "sxt")</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeLine">                        : Builder.CreateZExt(X, ResizeTy, "zxt");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1774</td>
    <td class="codeLine">                        : Builder.CreateZExt(X, ResizeTy, "zxt");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeLine">    Y = SignY == Signed ? Builder.CreateSExt(Y, ResizeTy, "sxt")</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1775</td>
    <td class="codeLine">    Y = SignY == Signed ? Builder.CreateSExt(Y, ResizeTy, "sxt")</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeLine">                        : Builder.CreateZExt(Y, ResizeTy, "zxt");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1776</td>
    <td class="codeLine">                        : Builder.CreateZExt(Y, ResizeTy, "zxt");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1777</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1778</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeLine">  assert(X->getType() == Y->getType() && X->getType() == ResizeTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1779</td>
    <td class="codeLine">  assert(X->getType() == Y->getType() && X->getType() == ResizeTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1780</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeLine">  unsigned VecLen = HVC.length(ResizeTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1781</td>
    <td class="codeLine">  unsigned VecLen = HVC.length(ResizeTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeLine">  unsigned ChopLen = (8 * HVC.HST.getVectorLength()) / std::min(Width, 32u);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1782</td>
    <td class="codeLine">  unsigned ChopLen = (8 * HVC.HST.getVectorLength()) / std::min(Width, 32u);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1783</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeLine">  SmallVector<Value *> Results;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1784</td>
    <td class="codeLine">  SmallVector<Value *> Results;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeLine">  FxpOp ChopOp = Op;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1785</td>
    <td class="codeLine">  FxpOp ChopOp = Op;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeLine">  ChopOp.ResTy = VectorType::get(Op.ResTy->getElementType(), ChopLen, false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1786</td>
    <td class="codeLine">  ChopOp.ResTy = VectorType::get(Op.ResTy->getElementType(), ChopLen, false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1787</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeLine">  for (unsigned V = 0; V != VecLen / ChopLen; ++V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1788</td>
    <td class="codeLine">  for (unsigned V = 0; V != VecLen / ChopLen; ++V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeLine">    ChopOp.X.Val = HVC.subvector(Builder, X, V * ChopLen, ChopLen);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1789</td>
    <td class="codeLine">    ChopOp.X.Val = HVC.subvector(Builder, X, V * ChopLen, ChopLen);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeLine">    ChopOp.Y.Val = HVC.subvector(Builder, Y, V * ChopLen, ChopLen);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1790</td>
    <td class="codeLine">    ChopOp.Y.Val = HVC.subvector(Builder, Y, V * ChopLen, ChopLen);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeLine">    Results.push_back(processFxpMulChopped(Builder, In, ChopOp));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1791</td>
    <td class="codeLine">    Results.push_back(processFxpMulChopped(Builder, In, ChopOp));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeLine">    if (Results.back() == nullptr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1792</td>
    <td class="codeLine">    if (Results.back() == nullptr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1793</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1794</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1795</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="codeLine">  if (Results.empty() || Results.back() == nullptr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1796</td>
    <td class="codeLine">  if (Results.empty() || Results.back() == nullptr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1797</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1798</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="codeLine">  Value *Cat = HVC.concat(Builder, Results);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1799</td>
    <td class="codeLine">  Value *Cat = HVC.concat(Builder, Results);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="codeLine">  Value *Ext = SignX == Signed || SignY == Signed</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1800</td>
    <td class="codeLine">  Value *Ext = SignX == Signed || SignY == Signed</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="codeLine">                   ? Builder.CreateSExt(Cat, VecTy, "sxt")</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1801</td>
    <td class="codeLine">                   ? Builder.CreateSExt(Cat, VecTy, "sxt")</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="codeLine">                   : Builder.CreateZExt(Cat, VecTy, "zxt");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1802</td>
    <td class="codeLine">                   : Builder.CreateZExt(Cat, VecTy, "zxt");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="codeLine">  return Ext;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1803</td>
    <td class="codeLine">  return Ext;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1804</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1805</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="codeLine">auto HvxIdioms::processFxpMulChopped(IRBuilderBase &Builder, Instruction &In,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1806</td>
    <td class="codeLine">auto HvxIdioms::processFxpMulChopped(IRBuilderBase &Builder, Instruction &In,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="codeLine">                                     const FxpOp &Op) const -> Value * {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1807</td>
    <td class="codeLine">                                     const FxpOp &Op) const -> Value * {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="codeLine">  assert(Op.X.Val->getType() == Op.Y.Val->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1808</td>
    <td class="codeLine">  assert(Op.X.Val->getType() == Op.Y.Val->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="codeLine">  auto *InpTy = cast<VectorType>(Op.X.Val->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1809</td>
    <td class="codeLine">  auto *InpTy = cast<VectorType>(Op.X.Val->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="codeLine">  unsigned Width = InpTy->getScalarSizeInBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1810</td>
    <td class="codeLine">  unsigned Width = InpTy->getScalarSizeInBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="codeLine">  bool Rounding = Op.RoundAt.has_value();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1811</td>
    <td class="codeLine">  bool Rounding = Op.RoundAt.has_value();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1812</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="codeLine">  if (!Op.RoundAt || *Op.RoundAt == Op.Frac - 1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1813</td>
    <td class="codeLine">  if (!Op.RoundAt || *Op.RoundAt == Op.Frac - 1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="codeLine">    // The fixed-point intrinsics do signed multiplication.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1814</td>
    <td class="codeLine">    // The fixed-point intrinsics do signed multiplication.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="codeLine">    if (Width == Op.Frac + 1 && Op.X.Sgn != Unsigned && Op.Y.Sgn != Unsigned) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1815</td>
    <td class="codeLine">    if (Width == Op.Frac + 1 && Op.X.Sgn != Unsigned && Op.Y.Sgn != Unsigned) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="codeLine">      Value *QMul = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1816</td>
    <td class="codeLine">      Value *QMul = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="codeLine">      if (Width == 16) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1817</td>
    <td class="codeLine">      if (Width == 16) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="codeLine">        QMul = createMulQ15(Builder, Op.X, Op.Y, Rounding);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1818</td>
    <td class="codeLine">        QMul = createMulQ15(Builder, Op.X, Op.Y, Rounding);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="codeLine">      } else if (Width == 32) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1819</td>
    <td class="codeLine">      } else if (Width == 32) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="codeLine">        QMul = createMulQ31(Builder, Op.X, Op.Y, Rounding);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1820</td>
    <td class="codeLine">        QMul = createMulQ31(Builder, Op.X, Op.Y, Rounding);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1821</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="codeLine">      if (QMul != nullptr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1822</td>
    <td class="codeLine">      if (QMul != nullptr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="codeLine">        return QMul;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1823</td>
    <td class="codeLine">        return QMul;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1824</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1825</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1826</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="codeLine">  assert(Width >= 32 || isPowerOf2_32(Width)); // Width <= 32 => Width is 2^n</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1827</td>
    <td class="codeLine">  assert(Width >= 32 || isPowerOf2_32(Width)); // Width <= 32 => Width is 2^n</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="codeLine">  assert(Width < 32 || Width % 32 == 0);       // Width > 32 => Width is 32*k</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1828</td>
    <td class="codeLine">  assert(Width < 32 || Width % 32 == 0);       // Width > 32 => Width is 32*k</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1829</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="codeLine">  // If Width < 32, then it should really be 16.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1830</td>
    <td class="codeLine">  // If Width < 32, then it should really be 16.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="codeLine">  if (Width < 32) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1831</td>
    <td class="codeLine">  if (Width < 32) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="codeLine">    if (Width < 16)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1832</td>
    <td class="codeLine">    if (Width < 16)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="codeLine">      return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1833</td>
    <td class="codeLine">      return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="codeLine">    // Getting here with Op.Frac == 0 isn't wrong, but suboptimal: here we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1834</td>
    <td class="codeLine">    // Getting here with Op.Frac == 0 isn't wrong, but suboptimal: here we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="codeLine">    // generate a full precision products, which is unnecessary if there is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1835</td>
    <td class="codeLine">    // generate a full precision products, which is unnecessary if there is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="codeLine">    // no shift.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1836</td>
    <td class="codeLine">    // no shift.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="codeLine">    assert(Width == 16);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1837</td>
    <td class="codeLine">    assert(Width == 16);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="codeLine">    assert(Op.Frac != 0 && "Unshifted mul should have been skipped");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1838</td>
    <td class="codeLine">    assert(Op.Frac != 0 && "Unshifted mul should have been skipped");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="codeLine">    if (Op.Frac == 16) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1839</td>
    <td class="codeLine">    if (Op.Frac == 16) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="codeLine">      // Multiply high</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1840</td>
    <td class="codeLine">      // Multiply high</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="codeLine">      if (Value *MulH = createMulH16(Builder, Op.X, Op.Y))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1841</td>
    <td class="codeLine">      if (Value *MulH = createMulH16(Builder, Op.X, Op.Y))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="codeLine">        return MulH;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1842</td>
    <td class="codeLine">        return MulH;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1843</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="codeLine">    // Do full-precision multiply and shift.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1844</td>
    <td class="codeLine">    // Do full-precision multiply and shift.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="codeLine">    Value *Prod32 = createMul16(Builder, Op.X, Op.Y);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1845</td>
    <td class="codeLine">    Value *Prod32 = createMul16(Builder, Op.X, Op.Y);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="codeLine">    if (Rounding) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1846</td>
    <td class="codeLine">    if (Rounding) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="codeLine">      Value *RoundVal = HVC.getConstSplat(Prod32->getType(), 1 << *Op.RoundAt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1847</td>
    <td class="codeLine">      Value *RoundVal = HVC.getConstSplat(Prod32->getType(), 1 << *Op.RoundAt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="codeLine">      Prod32 = Builder.CreateAdd(Prod32, RoundVal, "add");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1848</td>
    <td class="codeLine">      Prod32 = Builder.CreateAdd(Prod32, RoundVal, "add");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1849</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1850</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="codeLine">    Value *ShiftAmt = HVC.getConstSplat(Prod32->getType(), Op.Frac);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1851</td>
    <td class="codeLine">    Value *ShiftAmt = HVC.getConstSplat(Prod32->getType(), Op.Frac);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="codeLine">    Value *Shifted = Op.X.Sgn == Signed || Op.Y.Sgn == Signed</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1852</td>
    <td class="codeLine">    Value *Shifted = Op.X.Sgn == Signed || Op.Y.Sgn == Signed</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="codeLine">                         ? Builder.CreateAShr(Prod32, ShiftAmt, "asr")</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1853</td>
    <td class="codeLine">                         ? Builder.CreateAShr(Prod32, ShiftAmt, "asr")</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="codeLine">                         : Builder.CreateLShr(Prod32, ShiftAmt, "lsr");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1854</td>
    <td class="codeLine">                         : Builder.CreateLShr(Prod32, ShiftAmt, "lsr");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="codeLine">    return Builder.CreateTrunc(Shifted, InpTy, "trn");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1855</td>
    <td class="codeLine">    return Builder.CreateTrunc(Shifted, InpTy, "trn");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1856</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1857</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="codeLine">  // Width >= 32</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1858</td>
    <td class="codeLine">  // Width >= 32</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1859</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="codeLine">  // Break up the arguments Op.X and Op.Y into vectors of smaller widths</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1860</td>
    <td class="codeLine">  // Break up the arguments Op.X and Op.Y into vectors of smaller widths</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="codeLine">  // in preparation of doing the multiplication by 32-bit parts.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1861</td>
    <td class="codeLine">  // in preparation of doing the multiplication by 32-bit parts.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="codeLine">  auto WordX = HVC.splitVectorElements(Builder, Op.X.Val, /*ToWidth=*/32);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1862</td>
    <td class="codeLine">  auto WordX = HVC.splitVectorElements(Builder, Op.X.Val, /*ToWidth=*/32);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="codeLine">  auto WordY = HVC.splitVectorElements(Builder, Op.Y.Val, /*ToWidth=*/32);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1863</td>
    <td class="codeLine">  auto WordY = HVC.splitVectorElements(Builder, Op.Y.Val, /*ToWidth=*/32);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="codeLine">  auto WordP = createMulLong(Builder, WordX, Op.X.Sgn, WordY, Op.Y.Sgn);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1864</td>
    <td class="codeLine">  auto WordP = createMulLong(Builder, WordX, Op.X.Sgn, WordY, Op.Y.Sgn);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1865</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="codeLine">  auto *HvxWordTy = cast<VectorType>(WordP.front()->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1866</td>
    <td class="codeLine">  auto *HvxWordTy = cast<VectorType>(WordP.front()->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1867</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="codeLine">  // Add the optional rounding to the proper word.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1868</td>
    <td class="codeLine">  // Add the optional rounding to the proper word.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="codeLine">  if (Op.RoundAt.has_value()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1869</td>
    <td class="codeLine">  if (Op.RoundAt.has_value()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="codeLine">    Value *Zero = HVC.getNullValue(WordX[0]->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1870</td>
    <td class="codeLine">    Value *Zero = HVC.getNullValue(WordX[0]->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="codeLine">    SmallVector<Value *> RoundV(WordP.size(), Zero);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1871</td>
    <td class="codeLine">    SmallVector<Value *> RoundV(WordP.size(), Zero);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="codeLine">    RoundV[*Op.RoundAt / 32] =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1872</td>
    <td class="codeLine">    RoundV[*Op.RoundAt / 32] =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="codeLine">        HVC.getConstSplat(HvxWordTy, 1 << (*Op.RoundAt % 32));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1873</td>
    <td class="codeLine">        HVC.getConstSplat(HvxWordTy, 1 << (*Op.RoundAt % 32));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="codeLine">    WordP = createAddLong(Builder, WordP, RoundV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1874</td>
    <td class="codeLine">    WordP = createAddLong(Builder, WordP, RoundV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1875</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1876</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="codeLine">  // createRightShiftLong?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1877</td>
    <td class="codeLine">  // createRightShiftLong?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1878</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="codeLine">  // Shift all products right by Op.Frac.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1879</td>
    <td class="codeLine">  // Shift all products right by Op.Frac.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="codeLine">  unsigned SkipWords = Op.Frac / 32;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1880</td>
    <td class="codeLine">  unsigned SkipWords = Op.Frac / 32;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="codeLine">  Constant *ShiftAmt = HVC.getConstSplat(HvxWordTy, Op.Frac % 32);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1881</td>
    <td class="codeLine">  Constant *ShiftAmt = HVC.getConstSplat(HvxWordTy, Op.Frac % 32);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1882</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="codeLine">  for (int Dst = 0, End = WordP.size() - SkipWords; Dst != End; ++Dst) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1883</td>
    <td class="codeLine">  for (int Dst = 0, End = WordP.size() - SkipWords; Dst != End; ++Dst) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="codeLine">    int Src = Dst + SkipWords;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1884</td>
    <td class="codeLine">    int Src = Dst + SkipWords;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="codeLine">    Value *Lo = WordP[Src];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1885</td>
    <td class="codeLine">    Value *Lo = WordP[Src];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="codeLine">    if (Src + 1 < End) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1886</td>
    <td class="codeLine">    if (Src + 1 < End) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="codeLine">      Value *Hi = WordP[Src + 1];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1887</td>
    <td class="codeLine">      Value *Hi = WordP[Src + 1];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="codeLine">      WordP[Dst] = Builder.CreateIntrinsic(HvxWordTy, Intrinsic::fshr,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1888</td>
    <td class="codeLine">      WordP[Dst] = Builder.CreateIntrinsic(HvxWordTy, Intrinsic::fshr,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="codeLine">                                           {Hi, Lo, ShiftAmt},</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1889</td>
    <td class="codeLine">                                           {Hi, Lo, ShiftAmt},</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="codeLine">                                           /*FMFSource*/ nullptr, "int");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1890</td>
    <td class="codeLine">                                           /*FMFSource*/ nullptr, "int");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1891</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="codeLine">      // The shift of the most significant word.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1892</td>
    <td class="codeLine">      // The shift of the most significant word.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="codeLine">      WordP[Dst] = Builder.CreateAShr(Lo, ShiftAmt, "asr");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1893</td>
    <td class="codeLine">      WordP[Dst] = Builder.CreateAShr(Lo, ShiftAmt, "asr");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1894</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1895</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="codeLine">  if (SkipWords != 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1896</td>
    <td class="codeLine">  if (SkipWords != 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="codeLine">    WordP.resize(WordP.size() - SkipWords);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1897</td>
    <td class="codeLine">    WordP.resize(WordP.size() - SkipWords);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1898</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="codeLine">  return HVC.joinVectorElements(Builder, WordP, Op.ResTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1899</td>
    <td class="codeLine">  return HVC.joinVectorElements(Builder, WordP, Op.ResTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1900</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1901</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="codeLine">auto HvxIdioms::createMulQ15(IRBuilderBase &Builder, SValue X, SValue Y,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1902</td>
    <td class="codeLine">auto HvxIdioms::createMulQ15(IRBuilderBase &Builder, SValue X, SValue Y,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="codeLine">                             bool Rounding) const -> Value * {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1903</td>
    <td class="codeLine">                             bool Rounding) const -> Value * {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="codeLine">  assert(X.Val->getType() == Y.Val->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1904</td>
    <td class="codeLine">  assert(X.Val->getType() == Y.Val->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="codeLine">  assert(X.Val->getType()->getScalarType() == HVC.getIntTy(16));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1905</td>
    <td class="codeLine">  assert(X.Val->getType()->getScalarType() == HVC.getIntTy(16));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="codeLine">  assert(HVC.HST.isHVXVectorType(EVT::getEVT(X.Val->getType(), false)));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1906</td>
    <td class="codeLine">  assert(HVC.HST.isHVXVectorType(EVT::getEVT(X.Val->getType(), false)));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1907</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="codeLine">  // There is no non-rounding intrinsic for i16.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1908</td>
    <td class="codeLine">  // There is no non-rounding intrinsic for i16.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="codeLine">  if (!Rounding || X.Sgn == Unsigned || Y.Sgn == Unsigned)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1909</td>
    <td class="codeLine">  if (!Rounding || X.Sgn == Unsigned || Y.Sgn == Unsigned)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1910</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1911</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="codeLine">  auto V6_vmpyhvsrs = HVC.HST.getIntrinsicId(Hexagon::V6_vmpyhvsrs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1912</td>
    <td class="codeLine">  auto V6_vmpyhvsrs = HVC.HST.getIntrinsicId(Hexagon::V6_vmpyhvsrs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="codeLine">  return HVC.createHvxIntrinsic(Builder, V6_vmpyhvsrs, X.Val->getType(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1913</td>
    <td class="codeLine">  return HVC.createHvxIntrinsic(Builder, V6_vmpyhvsrs, X.Val->getType(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="codeLine">                                {X.Val, Y.Val});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1914</td>
    <td class="codeLine">                                {X.Val, Y.Val});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1915</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1916</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="codeLine">auto HvxIdioms::createMulQ31(IRBuilderBase &Builder, SValue X, SValue Y,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1917</td>
    <td class="codeLine">auto HvxIdioms::createMulQ31(IRBuilderBase &Builder, SValue X, SValue Y,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="codeLine">                             bool Rounding) const -> Value * {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1918</td>
    <td class="codeLine">                             bool Rounding) const -> Value * {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="codeLine">  Type *InpTy = X.Val->getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1919</td>
    <td class="codeLine">  Type *InpTy = X.Val->getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="codeLine">  assert(InpTy == Y.Val->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1920</td>
    <td class="codeLine">  assert(InpTy == Y.Val->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="codeLine">  assert(InpTy->getScalarType() == HVC.getIntTy(32));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1921</td>
    <td class="codeLine">  assert(InpTy->getScalarType() == HVC.getIntTy(32));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="codeLine">  assert(HVC.HST.isHVXVectorType(EVT::getEVT(InpTy, false)));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1922</td>
    <td class="codeLine">  assert(HVC.HST.isHVXVectorType(EVT::getEVT(InpTy, false)));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1923</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="codeLine">  if (X.Sgn == Unsigned || Y.Sgn == Unsigned)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1924</td>
    <td class="codeLine">  if (X.Sgn == Unsigned || Y.Sgn == Unsigned)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1925</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1926</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="codeLine">  auto V6_vmpyewuh = HVC.HST.getIntrinsicId(Hexagon::V6_vmpyewuh);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1927</td>
    <td class="codeLine">  auto V6_vmpyewuh = HVC.HST.getIntrinsicId(Hexagon::V6_vmpyewuh);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="codeLine">  auto V6_vmpyo_acc = Rounding</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1928</td>
    <td class="codeLine">  auto V6_vmpyo_acc = Rounding</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="codeLine">                          ? HVC.HST.getIntrinsicId(Hexagon::V6_vmpyowh_rnd_sacc)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1929</td>
    <td class="codeLine">                          ? HVC.HST.getIntrinsicId(Hexagon::V6_vmpyowh_rnd_sacc)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="codeLine">                          : HVC.HST.getIntrinsicId(Hexagon::V6_vmpyowh_sacc);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1930</td>
    <td class="codeLine">                          : HVC.HST.getIntrinsicId(Hexagon::V6_vmpyowh_sacc);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="codeLine">  Value *V1 =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1931</td>
    <td class="codeLine">  Value *V1 =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="codeLine">      HVC.createHvxIntrinsic(Builder, V6_vmpyewuh, InpTy, {X.Val, Y.Val});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1932</td>
    <td class="codeLine">      HVC.createHvxIntrinsic(Builder, V6_vmpyewuh, InpTy, {X.Val, Y.Val});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="codeLine">  return HVC.createHvxIntrinsic(Builder, V6_vmpyo_acc, InpTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1933</td>
    <td class="codeLine">  return HVC.createHvxIntrinsic(Builder, V6_vmpyo_acc, InpTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="codeLine">                                {V1, X.Val, Y.Val});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1934</td>
    <td class="codeLine">                                {V1, X.Val, Y.Val});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1935</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1936</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="codeLine">auto HvxIdioms::createAddCarry(IRBuilderBase &Builder, Value *X, Value *Y,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1937</td>
    <td class="codeLine">auto HvxIdioms::createAddCarry(IRBuilderBase &Builder, Value *X, Value *Y,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="codeLine">                               Value *CarryIn) const</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1938</td>
    <td class="codeLine">                               Value *CarryIn) const</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="codeLine">    -> std::pair<Value *, Value *> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1939</td>
    <td class="codeLine">    -> std::pair<Value *, Value *> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="codeLine">  assert(X->getType() == Y->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1940</td>
    <td class="codeLine">  assert(X->getType() == Y->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="codeLine">  auto VecTy = cast<VectorType>(X->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1941</td>
    <td class="codeLine">  auto VecTy = cast<VectorType>(X->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="codeLine">  if (VecTy == HvxI32Ty && HVC.HST.useHVXV62Ops()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1942</td>
    <td class="codeLine">  if (VecTy == HvxI32Ty && HVC.HST.useHVXV62Ops()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="codeLine">    SmallVector<Value *> Args = {X, Y};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1943</td>
    <td class="codeLine">    SmallVector<Value *> Args = {X, Y};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="codeLine">    Intrinsic::ID AddCarry;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1944</td>
    <td class="codeLine">    Intrinsic::ID AddCarry;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="codeLine">    if (CarryIn == nullptr && HVC.HST.useHVXV66Ops()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1945</td>
    <td class="codeLine">    if (CarryIn == nullptr && HVC.HST.useHVXV66Ops()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="codeLine">      AddCarry = HVC.HST.getIntrinsicId(Hexagon::V6_vaddcarryo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1946</td>
    <td class="codeLine">      AddCarry = HVC.HST.getIntrinsicId(Hexagon::V6_vaddcarryo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1947</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="codeLine">      AddCarry = HVC.HST.getIntrinsicId(Hexagon::V6_vaddcarry);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1948</td>
    <td class="codeLine">      AddCarry = HVC.HST.getIntrinsicId(Hexagon::V6_vaddcarry);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="codeLine">      if (CarryIn == nullptr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1949</td>
    <td class="codeLine">      if (CarryIn == nullptr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="codeLine">        CarryIn = HVC.getNullValue(HVC.getBoolTy(HVC.length(VecTy)));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1950</td>
    <td class="codeLine">        CarryIn = HVC.getNullValue(HVC.getBoolTy(HVC.length(VecTy)));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="codeLine">      Args.push_back(CarryIn);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1951</td>
    <td class="codeLine">      Args.push_back(CarryIn);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1952</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="codeLine">    Value *Ret = HVC.createHvxIntrinsic(Builder, AddCarry,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1953</td>
    <td class="codeLine">    Value *Ret = HVC.createHvxIntrinsic(Builder, AddCarry,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="codeLine">                                        /*RetTy=*/nullptr, Args);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1954</td>
    <td class="codeLine">                                        /*RetTy=*/nullptr, Args);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="codeLine">    Value *Result = Builder.CreateExtractValue(Ret, {0}, "ext");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1955</td>
    <td class="codeLine">    Value *Result = Builder.CreateExtractValue(Ret, {0}, "ext");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="codeLine">    Value *CarryOut = Builder.CreateExtractValue(Ret, {1}, "ext");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1956</td>
    <td class="codeLine">    Value *CarryOut = Builder.CreateExtractValue(Ret, {1}, "ext");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="codeLine">    return {Result, CarryOut};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1957</td>
    <td class="codeLine">    return {Result, CarryOut};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1958</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1959</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="codeLine">  // In other cases, do a regular add, and unsigned compare-less-than.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1960</td>
    <td class="codeLine">  // In other cases, do a regular add, and unsigned compare-less-than.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="codeLine">  // The carry-out can originate in two places: adding the carry-in or adding</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1961</td>
    <td class="codeLine">  // The carry-out can originate in two places: adding the carry-in or adding</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="codeLine">  // the two input values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1962</td>
    <td class="codeLine">  // the two input values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="codeLine">  Value *Result1 = X; // Result1 = X + CarryIn</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1963</td>
    <td class="codeLine">  Value *Result1 = X; // Result1 = X + CarryIn</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="codeLine">  if (CarryIn != nullptr) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1964</td>
    <td class="codeLine">  if (CarryIn != nullptr) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="codeLine">    unsigned Width = VecTy->getScalarSizeInBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1965</td>
    <td class="codeLine">    unsigned Width = VecTy->getScalarSizeInBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="codeLine">    uint32_t Mask = 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1966</td>
    <td class="codeLine">    uint32_t Mask = 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="codeLine">    if (Width < 32) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1967</td>
    <td class="codeLine">    if (Width < 32) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="codeLine">      for (unsigned i = 0, e = 32 / Width; i != e; ++i)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1968</td>
    <td class="codeLine">      for (unsigned i = 0, e = 32 / Width; i != e; ++i)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="codeLine">        Mask = (Mask << Width) | 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1969</td>
    <td class="codeLine">        Mask = (Mask << Width) | 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1970</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="codeLine">    auto V6_vandqrt = HVC.HST.getIntrinsicId(Hexagon::V6_vandqrt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1971</td>
    <td class="codeLine">    auto V6_vandqrt = HVC.HST.getIntrinsicId(Hexagon::V6_vandqrt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="codeLine">    Value *ValueIn =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1972</td>
    <td class="codeLine">    Value *ValueIn =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="codeLine">        HVC.createHvxIntrinsic(Builder, V6_vandqrt, /*RetTy=*/nullptr,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1973</td>
    <td class="codeLine">        HVC.createHvxIntrinsic(Builder, V6_vandqrt, /*RetTy=*/nullptr,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="codeLine">                               {CarryIn, HVC.getConstInt(Mask)});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1974</td>
    <td class="codeLine">                               {CarryIn, HVC.getConstInt(Mask)});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="codeLine">    Result1 = Builder.CreateAdd(X, ValueIn, "add");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1975</td>
    <td class="codeLine">    Result1 = Builder.CreateAdd(X, ValueIn, "add");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1976</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1977</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="codeLine">  Value *CarryOut1 = Builder.CreateCmp(CmpInst::ICMP_ULT, Result1, X, "cmp");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1978</td>
    <td class="codeLine">  Value *CarryOut1 = Builder.CreateCmp(CmpInst::ICMP_ULT, Result1, X, "cmp");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="codeLine">  Value *Result2 = Builder.CreateAdd(Result1, Y, "add");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1979</td>
    <td class="codeLine">  Value *Result2 = Builder.CreateAdd(Result1, Y, "add");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="codeLine">  Value *CarryOut2 = Builder.CreateCmp(CmpInst::ICMP_ULT, Result2, Y, "cmp");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1980</td>
    <td class="codeLine">  Value *CarryOut2 = Builder.CreateCmp(CmpInst::ICMP_ULT, Result2, Y, "cmp");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="codeLine">  return {Result2, Builder.CreateOr(CarryOut1, CarryOut2, "orb")};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1981</td>
    <td class="codeLine">  return {Result2, Builder.CreateOr(CarryOut1, CarryOut2, "orb")};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1982</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1983</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="codeLine">auto HvxIdioms::createMul16(IRBuilderBase &Builder, SValue X, SValue Y) const</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1984</td>
    <td class="codeLine">auto HvxIdioms::createMul16(IRBuilderBase &Builder, SValue X, SValue Y) const</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="codeLine">    -> Value * {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1985</td>
    <td class="codeLine">    -> Value * {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="codeLine">  Intrinsic::ID V6_vmpyh = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1986</td>
    <td class="codeLine">  Intrinsic::ID V6_vmpyh = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="codeLine">  std::tie(X, Y) = canonSgn(X, Y);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1987</td>
    <td class="codeLine">  std::tie(X, Y) = canonSgn(X, Y);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1988</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="codeLine">  if (X.Sgn == Signed) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1989</td>
    <td class="codeLine">  if (X.Sgn == Signed) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="codeLine">    V6_vmpyh = HVC.HST.getIntrinsicId(Hexagon::V6_vmpyhv);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1990</td>
    <td class="codeLine">    V6_vmpyh = HVC.HST.getIntrinsicId(Hexagon::V6_vmpyhv);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="codeLine">  } else if (Y.Sgn == Signed) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1991</td>
    <td class="codeLine">  } else if (Y.Sgn == Signed) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="codeLine">    // In vmpyhus the second operand is unsigned</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1992</td>
    <td class="codeLine">    // In vmpyhus the second operand is unsigned</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="codeLine">    V6_vmpyh = HVC.HST.getIntrinsicId(Hexagon::V6_vmpyhus);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1993</td>
    <td class="codeLine">    V6_vmpyh = HVC.HST.getIntrinsicId(Hexagon::V6_vmpyhus);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1994</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="codeLine">    V6_vmpyh = HVC.HST.getIntrinsicId(Hexagon::V6_vmpyuhv);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1995</td>
    <td class="codeLine">    V6_vmpyh = HVC.HST.getIntrinsicId(Hexagon::V6_vmpyuhv);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1996</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1997</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="codeLine">  // i16*i16 -> i32 / interleaved</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1998</td>
    <td class="codeLine">  // i16*i16 -> i32 / interleaved</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="codeLine">  Value *P =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1999</td>
    <td class="codeLine">  Value *P =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="codeLine">      HVC.createHvxIntrinsic(Builder, V6_vmpyh, HvxP32Ty, {Y.Val, X.Val});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2000</td>
    <td class="codeLine">      HVC.createHvxIntrinsic(Builder, V6_vmpyh, HvxP32Ty, {Y.Val, X.Val});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="codeLine">  // Deinterleave</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2001</td>
    <td class="codeLine">  // Deinterleave</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="codeLine">  return HVC.vshuff(Builder, HVC.sublo(Builder, P), HVC.subhi(Builder, P));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2002</td>
    <td class="codeLine">  return HVC.vshuff(Builder, HVC.sublo(Builder, P), HVC.subhi(Builder, P));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2003</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2004</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="codeLine">auto HvxIdioms::createMulH16(IRBuilderBase &Builder, SValue X, SValue Y) const</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2005</td>
    <td class="codeLine">auto HvxIdioms::createMulH16(IRBuilderBase &Builder, SValue X, SValue Y) const</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="codeLine">    -> Value * {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2006</td>
    <td class="codeLine">    -> Value * {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="codeLine">  Type *HvxI16Ty = HVC.getHvxTy(HVC.getIntTy(16), /*Pair=*/false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2007</td>
    <td class="codeLine">  Type *HvxI16Ty = HVC.getHvxTy(HVC.getIntTy(16), /*Pair=*/false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2008</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="codeLine">  if (HVC.HST.useHVXV69Ops()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2009</td>
    <td class="codeLine">  if (HVC.HST.useHVXV69Ops()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="codeLine">    if (X.Sgn != Signed && Y.Sgn != Signed) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2010</td>
    <td class="codeLine">    if (X.Sgn != Signed && Y.Sgn != Signed) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="codeLine">      auto V6_vmpyuhvs = HVC.HST.getIntrinsicId(Hexagon::V6_vmpyuhvs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2011</td>
    <td class="codeLine">      auto V6_vmpyuhvs = HVC.HST.getIntrinsicId(Hexagon::V6_vmpyuhvs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="codeLine">      return HVC.createHvxIntrinsic(Builder, V6_vmpyuhvs, HvxI16Ty,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2012</td>
    <td class="codeLine">      return HVC.createHvxIntrinsic(Builder, V6_vmpyuhvs, HvxI16Ty,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="codeLine">                                    {X.Val, Y.Val});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2013</td>
    <td class="codeLine">                                    {X.Val, Y.Val});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2014</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2015</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2016</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="codeLine">  Type *HvxP16Ty = HVC.getHvxTy(HVC.getIntTy(16), /*Pair=*/true);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2017</td>
    <td class="codeLine">  Type *HvxP16Ty = HVC.getHvxTy(HVC.getIntTy(16), /*Pair=*/true);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="codeLine">  Value *Pair16 =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2018</td>
    <td class="codeLine">  Value *Pair16 =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="codeLine">      Builder.CreateBitCast(createMul16(Builder, X, Y), HvxP16Ty, "cst");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2019</td>
    <td class="codeLine">      Builder.CreateBitCast(createMul16(Builder, X, Y), HvxP16Ty, "cst");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="codeLine">  unsigned Len = HVC.length(HvxP16Ty) / 2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2020</td>
    <td class="codeLine">  unsigned Len = HVC.length(HvxP16Ty) / 2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2021</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="codeLine">  SmallVector<int, 128> PickOdd(Len);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2022</td>
    <td class="codeLine">  SmallVector<int, 128> PickOdd(Len);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="codeLine">  for (int i = 0; i != static_cast<int>(Len); ++i)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2023</td>
    <td class="codeLine">  for (int i = 0; i != static_cast<int>(Len); ++i)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="codeLine">    PickOdd[i] = 2 * i + 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2024</td>
    <td class="codeLine">    PickOdd[i] = 2 * i + 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2025</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="codeLine">  return Builder.CreateShuffleVector(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2026</td>
    <td class="codeLine">  return Builder.CreateShuffleVector(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="codeLine">      HVC.sublo(Builder, Pair16), HVC.subhi(Builder, Pair16), PickOdd, "shf");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2027</td>
    <td class="codeLine">      HVC.sublo(Builder, Pair16), HVC.subhi(Builder, Pair16), PickOdd, "shf");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2028</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2029</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="codeLine">auto HvxIdioms::createMul32(IRBuilderBase &Builder, SValue X, SValue Y) const</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2030</td>
    <td class="codeLine">auto HvxIdioms::createMul32(IRBuilderBase &Builder, SValue X, SValue Y) const</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="codeLine">    -> std::pair<Value *, Value *> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2031</td>
    <td class="codeLine">    -> std::pair<Value *, Value *> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="codeLine">  assert(X.Val->getType() == Y.Val->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2032</td>
    <td class="codeLine">  assert(X.Val->getType() == Y.Val->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="codeLine">  assert(X.Val->getType() == HvxI32Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2033</td>
    <td class="codeLine">  assert(X.Val->getType() == HvxI32Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2034</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="codeLine">  Intrinsic::ID V6_vmpy_parts;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2035</td>
    <td class="codeLine">  Intrinsic::ID V6_vmpy_parts;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="codeLine">  std::tie(X, Y) = canonSgn(X, Y);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2036</td>
    <td class="codeLine">  std::tie(X, Y) = canonSgn(X, Y);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2037</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="codeLine">  if (X.Sgn == Signed) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2038</td>
    <td class="codeLine">  if (X.Sgn == Signed) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="codeLine">    V6_vmpy_parts = Intrinsic::hexagon_V6_vmpyss_parts;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2039</td>
    <td class="codeLine">    V6_vmpy_parts = Intrinsic::hexagon_V6_vmpyss_parts;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="codeLine">  } else if (Y.Sgn == Signed) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2040</td>
    <td class="codeLine">  } else if (Y.Sgn == Signed) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="codeLine">    V6_vmpy_parts = Intrinsic::hexagon_V6_vmpyus_parts;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2041</td>
    <td class="codeLine">    V6_vmpy_parts = Intrinsic::hexagon_V6_vmpyus_parts;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2042</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="codeLine">    V6_vmpy_parts = Intrinsic::hexagon_V6_vmpyuu_parts;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2043</td>
    <td class="codeLine">    V6_vmpy_parts = Intrinsic::hexagon_V6_vmpyuu_parts;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2044</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2045</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="codeLine">  Value *Parts = HVC.createHvxIntrinsic(Builder, V6_vmpy_parts, nullptr,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2046</td>
    <td class="codeLine">  Value *Parts = HVC.createHvxIntrinsic(Builder, V6_vmpy_parts, nullptr,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="codeLine">                                        {X.Val, Y.Val}, {HvxI32Ty});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2047</td>
    <td class="codeLine">                                        {X.Val, Y.Val}, {HvxI32Ty});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="codeLine">  Value *Hi = Builder.CreateExtractValue(Parts, {0}, "ext");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2048</td>
    <td class="codeLine">  Value *Hi = Builder.CreateExtractValue(Parts, {0}, "ext");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="codeLine">  Value *Lo = Builder.CreateExtractValue(Parts, {1}, "ext");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2049</td>
    <td class="codeLine">  Value *Lo = Builder.CreateExtractValue(Parts, {1}, "ext");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="codeLine">  return {Lo, Hi};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2050</td>
    <td class="codeLine">  return {Lo, Hi};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2051</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2052</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="codeLine">auto HvxIdioms::createAddLong(IRBuilderBase &Builder, ArrayRef<Value *> WordX,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2053</td>
    <td class="codeLine">auto HvxIdioms::createAddLong(IRBuilderBase &Builder, ArrayRef<Value *> WordX,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="codeLine">                              ArrayRef<Value *> WordY) const</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2054</td>
    <td class="codeLine">                              ArrayRef<Value *> WordY) const</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="codeLine">    -> SmallVector<Value *> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2055</td>
    <td class="codeLine">    -> SmallVector<Value *> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="codeLine">  assert(WordX.size() == WordY.size());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2056</td>
    <td class="codeLine">  assert(WordX.size() == WordY.size());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="codeLine">  unsigned Idx = 0, Length = WordX.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2057</td>
    <td class="codeLine">  unsigned Idx = 0, Length = WordX.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="codeLine">  SmallVector<Value *> Sum(Length);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2058</td>
    <td class="codeLine">  SmallVector<Value *> Sum(Length);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2059</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="codeLine">  while (Idx != Length) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2060</td>
    <td class="codeLine">  while (Idx != Length) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="codeLine">    if (HVC.isZero(WordX[Idx]))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2061</td>
    <td class="codeLine">    if (HVC.isZero(WordX[Idx]))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="codeLine">      Sum[Idx] = WordY[Idx];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2062</td>
    <td class="codeLine">      Sum[Idx] = WordY[Idx];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="codeLine">    else if (HVC.isZero(WordY[Idx]))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2063</td>
    <td class="codeLine">    else if (HVC.isZero(WordY[Idx]))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="codeLine">      Sum[Idx] = WordX[Idx];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2064</td>
    <td class="codeLine">      Sum[Idx] = WordX[Idx];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2065</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2066</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="codeLine">    ++Idx;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2067</td>
    <td class="codeLine">    ++Idx;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2068</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2069</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="codeLine">  Value *Carry = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2070</td>
    <td class="codeLine">  Value *Carry = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="codeLine">  for (; Idx != Length; ++Idx) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2071</td>
    <td class="codeLine">  for (; Idx != Length; ++Idx) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="codeLine">    std::tie(Sum[Idx], Carry) =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2072</td>
    <td class="codeLine">    std::tie(Sum[Idx], Carry) =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="codeLine">        createAddCarry(Builder, WordX[Idx], WordY[Idx], Carry);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2073</td>
    <td class="codeLine">        createAddCarry(Builder, WordX[Idx], WordY[Idx], Carry);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2074</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2075</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="codeLine">  // This drops the final carry beyond the highest word.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2076</td>
    <td class="codeLine">  // This drops the final carry beyond the highest word.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="codeLine">  return Sum;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2077</td>
    <td class="codeLine">  return Sum;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2078</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2079</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="codeLine">auto HvxIdioms::createMulLong(IRBuilderBase &Builder, ArrayRef<Value *> WordX,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2080</td>
    <td class="codeLine">auto HvxIdioms::createMulLong(IRBuilderBase &Builder, ArrayRef<Value *> WordX,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="codeLine">                              Signedness SgnX, ArrayRef<Value *> WordY,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2081</td>
    <td class="codeLine">                              Signedness SgnX, ArrayRef<Value *> WordY,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="codeLine">                              Signedness SgnY) const -> SmallVector<Value *> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2082</td>
    <td class="codeLine">                              Signedness SgnY) const -> SmallVector<Value *> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="codeLine">  SmallVector<SmallVector<Value *>> Products(WordX.size() + WordY.size());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2083</td>
    <td class="codeLine">  SmallVector<SmallVector<Value *>> Products(WordX.size() + WordY.size());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2084</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="codeLine">  // WordX[i] * WordY[j] produces words i+j and i+j+1 of the results,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2085</td>
    <td class="codeLine">  // WordX[i] * WordY[j] produces words i+j and i+j+1 of the results,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="codeLine">  // that is halves 2(i+j), 2(i+j)+1, 2(i+j)+2, 2(i+j)+3.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2086</td>
    <td class="codeLine">  // that is halves 2(i+j), 2(i+j)+1, 2(i+j)+2, 2(i+j)+3.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="codeLine">  for (int i = 0, e = WordX.size(); i != e; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2087</td>
    <td class="codeLine">  for (int i = 0, e = WordX.size(); i != e; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="codeLine">    for (int j = 0, f = WordY.size(); j != f; ++j) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2088</td>
    <td class="codeLine">    for (int j = 0, f = WordY.size(); j != f; ++j) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="codeLine">      // Check the 4 halves that this multiplication can generate.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2089</td>
    <td class="codeLine">      // Check the 4 halves that this multiplication can generate.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="codeLine">      Signedness SX = (i + 1 == e) ? SgnX : Unsigned;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2090</td>
    <td class="codeLine">      Signedness SX = (i + 1 == e) ? SgnX : Unsigned;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="codeLine">      Signedness SY = (j + 1 == f) ? SgnY : Unsigned;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2091</td>
    <td class="codeLine">      Signedness SY = (j + 1 == f) ? SgnY : Unsigned;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="codeLine">      auto [Lo, Hi] = createMul32(Builder, {WordX[i], SX}, {WordY[j], SY});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2092</td>
    <td class="codeLine">      auto [Lo, Hi] = createMul32(Builder, {WordX[i], SX}, {WordY[j], SY});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="codeLine">      Products[i + j + 0].push_back(Lo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2093</td>
    <td class="codeLine">      Products[i + j + 0].push_back(Lo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="codeLine">      Products[i + j + 1].push_back(Hi);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2094</td>
    <td class="codeLine">      Products[i + j + 1].push_back(Hi);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2095</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2096</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2097</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="codeLine">  Value *Zero = HVC.getNullValue(WordX[0]->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2098</td>
    <td class="codeLine">  Value *Zero = HVC.getNullValue(WordX[0]->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2099</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="codeLine">  auto pop_back_or_zero = [Zero](auto &Vector) -> Value * {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2100</td>
    <td class="codeLine">  auto pop_back_or_zero = [Zero](auto &Vector) -> Value * {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="codeLine">    if (Vector.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2101</td>
    <td class="codeLine">    if (Vector.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="codeLine">      return Zero;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2102</td>
    <td class="codeLine">      return Zero;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="codeLine">    auto Last = Vector.back();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2103</td>
    <td class="codeLine">    auto Last = Vector.back();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="codeLine">    Vector.pop_back();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2104</td>
    <td class="codeLine">    Vector.pop_back();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="codeLine">    return Last;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2105</td>
    <td class="codeLine">    return Last;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2106</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2107</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="codeLine">  for (int i = 0, e = Products.size(); i != e; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2108</td>
    <td class="codeLine">  for (int i = 0, e = Products.size(); i != e; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="codeLine">    while (Products[i].size() > 1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2109</td>
    <td class="codeLine">    while (Products[i].size() > 1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="codeLine">      Value *Carry = nullptr; // no carry-in</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2110</td>
    <td class="codeLine">      Value *Carry = nullptr; // no carry-in</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="codeLine">      for (int j = i; j != e; ++j) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2111</td>
    <td class="codeLine">      for (int j = i; j != e; ++j) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="codeLine">        auto &ProdJ = Products[j];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2112</td>
    <td class="codeLine">        auto &ProdJ = Products[j];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="codeLine">        auto [Sum, CarryOut] = createAddCarry(Builder, pop_back_or_zero(ProdJ),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2113</td>
    <td class="codeLine">        auto [Sum, CarryOut] = createAddCarry(Builder, pop_back_or_zero(ProdJ),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="codeLine">                                              pop_back_or_zero(ProdJ), Carry);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2114</td>
    <td class="codeLine">                                              pop_back_or_zero(ProdJ), Carry);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="codeLine">        ProdJ.insert(ProdJ.begin(), Sum);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2115</td>
    <td class="codeLine">        ProdJ.insert(ProdJ.begin(), Sum);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="codeLine">        Carry = CarryOut;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2116</td>
    <td class="codeLine">        Carry = CarryOut;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2117</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2118</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2119</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2120</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="codeLine">  SmallVector<Value *> WordP;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2121</td>
    <td class="codeLine">  SmallVector<Value *> WordP;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="codeLine">  for (auto &P : Products) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2122</td>
    <td class="codeLine">  for (auto &P : Products) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="codeLine">    assert(P.size() == 1 && "Should have been added together");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2123</td>
    <td class="codeLine">    assert(P.size() == 1 && "Should have been added together");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="codeLine">    WordP.push_back(P.front());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2124</td>
    <td class="codeLine">    WordP.push_back(P.front());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2125</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2126</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="codeLine">  return WordP;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2127</td>
    <td class="codeLine">  return WordP;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2128</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2129</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="codeLine">auto HvxIdioms::run() -> bool {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2130</td>
    <td class="codeLine">auto HvxIdioms::run() -> bool {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2131</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2132</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="codeLine">  for (BasicBlock &B : HVC.F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2133</td>
    <td class="codeLine">  for (BasicBlock &B : HVC.F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="codeLine">    for (auto It = B.rbegin(); It != B.rend(); ++It) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2134</td>
    <td class="codeLine">    for (auto It = B.rbegin(); It != B.rend(); ++It) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="codeLine">      if (auto Fxm = matchFxpMul(*It)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2135</td>
    <td class="codeLine">      if (auto Fxm = matchFxpMul(*It)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="codeLine">        Value *New = processFxpMul(*It, *Fxm);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2136</td>
    <td class="codeLine">        Value *New = processFxpMul(*It, *Fxm);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="codeLine">        // Always report "changed" for now.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2137</td>
    <td class="codeLine">        // Always report "changed" for now.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="codeLine">        Changed = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2138</td>
    <td class="codeLine">        Changed = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="codeLine">        if (!New)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2139</td>
    <td class="codeLine">        if (!New)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2140</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="codeLine">        bool StartOver = !isa<Instruction>(New);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2141</td>
    <td class="codeLine">        bool StartOver = !isa<Instruction>(New);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="codeLine">        It->replaceAllUsesWith(New);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2142</td>
    <td class="codeLine">        It->replaceAllUsesWith(New);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="codeLine">        RecursivelyDeleteTriviallyDeadInstructions(&*It, &HVC.TLI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2143</td>
    <td class="codeLine">        RecursivelyDeleteTriviallyDeadInstructions(&*It, &HVC.TLI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="codeLine">        It = StartOver ? B.rbegin()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2144</td>
    <td class="codeLine">        It = StartOver ? B.rbegin()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="codeLine">                       : cast<Instruction>(New)->getReverseIterator();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2145</td>
    <td class="codeLine">                       : cast<Instruction>(New)->getReverseIterator();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="codeLine">        Changed = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2146</td>
    <td class="codeLine">        Changed = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2147</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2148</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2149</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2150</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2151</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2152</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2153</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="codeLine">// --- End HvxIdioms</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2154</td>
    <td class="codeLine">// --- End HvxIdioms</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2155</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="codeLine">auto HexagonVectorCombine::run() -> bool {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2156</td>
    <td class="codeLine">auto HexagonVectorCombine::run() -> bool {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="codeLine">  if (DumpModule)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2157</td>
    <td class="codeLine">  if (DumpModule)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="codeLine">    dbgs() << "Module before HexagonVectorCombine\n" << *F.getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2158</td>
    <td class="codeLine">    dbgs() << "Module before HexagonVectorCombine\n" << *F.getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2159</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2160</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="codeLine">  if (HST.useHVXOps()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2161</td>
    <td class="codeLine">  if (HST.useHVXOps()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="codeLine">    if (VAEnabled)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2162</td>
    <td class="codeLine">    if (VAEnabled)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="codeLine">      Changed |= AlignVectors(*this).run();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2163</td>
    <td class="codeLine">      Changed |= AlignVectors(*this).run();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="codeLine">    if (VIEnabled)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2164</td>
    <td class="codeLine">    if (VIEnabled)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="codeLine">      Changed |= HvxIdioms(*this).run();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2165</td>
    <td class="codeLine">      Changed |= HvxIdioms(*this).run();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2166</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2167</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="codeLine">  if (DumpModule) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2168</td>
    <td class="codeLine">  if (DumpModule) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="codeLine">    dbgs() << "Module " << (Changed ? "(modified)" : "(unchanged)")</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2169</td>
    <td class="codeLine">    dbgs() << "Module " << (Changed ? "(modified)" : "(unchanged)")</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="codeLine">           << " after HexagonVectorCombine\n"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2170</td>
    <td class="codeLine">           << " after HexagonVectorCombine\n"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="codeLine">           << *F.getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2171</td>
    <td class="codeLine">           << *F.getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2172</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2173</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2174</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2175</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="codeLine">auto HexagonVectorCombine::getIntTy(unsigned Width) const -> IntegerType * {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2176</td>
    <td class="codeLine">auto HexagonVectorCombine::getIntTy(unsigned Width) const -> IntegerType * {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="codeLine">  return IntegerType::get(F.getContext(), Width);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2177</td>
    <td class="codeLine">  return IntegerType::get(F.getContext(), Width);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2178</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2179</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="codeLine">auto HexagonVectorCombine::getByteTy(int ElemCount) const -> Type * {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2180</td>
    <td class="codeLine">auto HexagonVectorCombine::getByteTy(int ElemCount) const -> Type * {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="codeLine">  assert(ElemCount >= 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2181</td>
    <td class="codeLine">  assert(ElemCount >= 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="codeLine">  IntegerType *ByteTy = Type::getInt8Ty(F.getContext());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2182</td>
    <td class="codeLine">  IntegerType *ByteTy = Type::getInt8Ty(F.getContext());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="codeLine">  if (ElemCount == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2183</td>
    <td class="codeLine">  if (ElemCount == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="codeLine">    return ByteTy;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2184</td>
    <td class="codeLine">    return ByteTy;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="codeLine">  return VectorType::get(ByteTy, ElemCount, /*Scalable=*/false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2185</td>
    <td class="codeLine">  return VectorType::get(ByteTy, ElemCount, /*Scalable=*/false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2186</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2187</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="codeLine">auto HexagonVectorCombine::getBoolTy(int ElemCount) const -> Type * {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2188</td>
    <td class="codeLine">auto HexagonVectorCombine::getBoolTy(int ElemCount) const -> Type * {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="codeLine">  assert(ElemCount >= 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2189</td>
    <td class="codeLine">  assert(ElemCount >= 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="codeLine">  IntegerType *BoolTy = Type::getInt1Ty(F.getContext());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2190</td>
    <td class="codeLine">  IntegerType *BoolTy = Type::getInt1Ty(F.getContext());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="codeLine">  if (ElemCount == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2191</td>
    <td class="codeLine">  if (ElemCount == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="codeLine">    return BoolTy;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2192</td>
    <td class="codeLine">    return BoolTy;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="codeLine">  return VectorType::get(BoolTy, ElemCount, /*Scalable=*/false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2193</td>
    <td class="codeLine">  return VectorType::get(BoolTy, ElemCount, /*Scalable=*/false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2194</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2195</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="codeLine">auto HexagonVectorCombine::getConstInt(int Val, unsigned Width) const</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2196</td>
    <td class="codeLine">auto HexagonVectorCombine::getConstInt(int Val, unsigned Width) const</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="codeLine">    -> ConstantInt * {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2197</td>
    <td class="codeLine">    -> ConstantInt * {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="codeLine">  return ConstantInt::getSigned(getIntTy(Width), Val);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2198</td>
    <td class="codeLine">  return ConstantInt::getSigned(getIntTy(Width), Val);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2199</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2200</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="codeLine">auto HexagonVectorCombine::isZero(const Value *Val) const -> bool {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2201</td>
    <td class="codeLine">auto HexagonVectorCombine::isZero(const Value *Val) const -> bool {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="codeLine">  if (auto *C = dyn_cast<Constant>(Val))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2202</td>
    <td class="codeLine">  if (auto *C = dyn_cast<Constant>(Val))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="codeLine">    return C->isZeroValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2203</td>
    <td class="codeLine">    return C->isZeroValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2204</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2205</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2206</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="codeLine">auto HexagonVectorCombine::getIntValue(const Value *Val) const</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2207</td>
    <td class="codeLine">auto HexagonVectorCombine::getIntValue(const Value *Val) const</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="codeLine">    -> std::optional<APInt> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2208</td>
    <td class="codeLine">    -> std::optional<APInt> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="codeLine">  if (auto *CI = dyn_cast<ConstantInt>(Val))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2209</td>
    <td class="codeLine">  if (auto *CI = dyn_cast<ConstantInt>(Val))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="codeLine">    return CI->getValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2210</td>
    <td class="codeLine">    return CI->getValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="codeLine">  return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2211</td>
    <td class="codeLine">  return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2212</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2213</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="codeLine">auto HexagonVectorCombine::isUndef(const Value *Val) const -> bool {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2214</td>
    <td class="codeLine">auto HexagonVectorCombine::isUndef(const Value *Val) const -> bool {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="codeLine">  return isa<UndefValue>(Val);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2215</td>
    <td class="codeLine">  return isa<UndefValue>(Val);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2216</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2217</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="codeLine">auto HexagonVectorCombine::isTrue(const Value *Val) const -> bool {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2218</td>
    <td class="codeLine">auto HexagonVectorCombine::isTrue(const Value *Val) const -> bool {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="codeLine">  return Val == ConstantInt::getTrue(Val->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2219</td>
    <td class="codeLine">  return Val == ConstantInt::getTrue(Val->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2220</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2221</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="codeLine">auto HexagonVectorCombine::isFalse(const Value *Val) const -> bool {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2222</td>
    <td class="codeLine">auto HexagonVectorCombine::isFalse(const Value *Val) const -> bool {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="codeLine">  return isZero(Val);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2223</td>
    <td class="codeLine">  return isZero(Val);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2224</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="codeLine">auto HexagonVectorCombine::getHvxTy(Type *ElemTy, bool Pair) const</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2226</td>
    <td class="codeLine">auto HexagonVectorCombine::getHvxTy(Type *ElemTy, bool Pair) const</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="codeLine">    -> VectorType * {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2227</td>
    <td class="codeLine">    -> VectorType * {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="codeLine">  EVT ETy = EVT::getEVT(ElemTy, false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2228</td>
    <td class="codeLine">  EVT ETy = EVT::getEVT(ElemTy, false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="codeLine">  assert(ETy.isSimple() && "Invalid HVX element type");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2229</td>
    <td class="codeLine">  assert(ETy.isSimple() && "Invalid HVX element type");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="codeLine">  // Do not allow boolean types here: they don't have a fixed length.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2230</td>
    <td class="codeLine">  // Do not allow boolean types here: they don't have a fixed length.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="codeLine">  assert(HST.isHVXElementType(ETy.getSimpleVT(), /*IncludeBool=*/false) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2231</td>
    <td class="codeLine">  assert(HST.isHVXElementType(ETy.getSimpleVT(), /*IncludeBool=*/false) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="codeLine">         "Invalid HVX element type");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2232</td>
    <td class="codeLine">         "Invalid HVX element type");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="codeLine">  unsigned HwLen = HST.getVectorLength();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2233</td>
    <td class="codeLine">  unsigned HwLen = HST.getVectorLength();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="codeLine">  unsigned NumElems = (8 * HwLen) / ETy.getSizeInBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2234</td>
    <td class="codeLine">  unsigned NumElems = (8 * HwLen) / ETy.getSizeInBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="codeLine">  return VectorType::get(ElemTy, Pair ? 2 * NumElems : NumElems,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2235</td>
    <td class="codeLine">  return VectorType::get(ElemTy, Pair ? 2 * NumElems : NumElems,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="codeLine">                         /*Scalable=*/false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2236</td>
    <td class="codeLine">                         /*Scalable=*/false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2237</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2238</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="codeLine">auto HexagonVectorCombine::getSizeOf(const Value *Val, SizeKind Kind) const</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2239</td>
    <td class="codeLine">auto HexagonVectorCombine::getSizeOf(const Value *Val, SizeKind Kind) const</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="codeLine">    -> int {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2240</td>
    <td class="codeLine">    -> int {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="codeLine">  return getSizeOf(Val->getType(), Kind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2241</td>
    <td class="codeLine">  return getSizeOf(Val->getType(), Kind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2242</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2243</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="codeLine">auto HexagonVectorCombine::getSizeOf(const Type *Ty, SizeKind Kind) const</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2244</td>
    <td class="codeLine">auto HexagonVectorCombine::getSizeOf(const Type *Ty, SizeKind Kind) const</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="codeLine">    -> int {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2245</td>
    <td class="codeLine">    -> int {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="codeLine">  auto *NcTy = const_cast<Type *>(Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2246</td>
    <td class="codeLine">  auto *NcTy = const_cast<Type *>(Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="codeLine">  switch (Kind) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2247</td>
    <td class="codeLine">  switch (Kind) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="codeLine">  case Store:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2248</td>
    <td class="codeLine">  case Store:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="codeLine">    return DL.getTypeStoreSize(NcTy).getFixedValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2249</td>
    <td class="codeLine">    return DL.getTypeStoreSize(NcTy).getFixedValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="codeLine">  case Alloc:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2250</td>
    <td class="codeLine">  case Alloc:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="codeLine">    return DL.getTypeAllocSize(NcTy).getFixedValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2251</td>
    <td class="codeLine">    return DL.getTypeAllocSize(NcTy).getFixedValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2252</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="codeLine">  llvm_unreachable("Unhandled SizeKind enum");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2253</td>
    <td class="codeLine">  llvm_unreachable("Unhandled SizeKind enum");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2254</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2255</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="codeLine">auto HexagonVectorCombine::getTypeAlignment(Type *Ty) const -> int {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2256</td>
    <td class="codeLine">auto HexagonVectorCombine::getTypeAlignment(Type *Ty) const -> int {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="codeLine">  // The actual type may be shorter than the HVX vector, so determine</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2257</td>
    <td class="codeLine">  // The actual type may be shorter than the HVX vector, so determine</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="codeLine">  // the alignment based on subtarget info.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2258</td>
    <td class="codeLine">  // the alignment based on subtarget info.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="codeLine">  if (HST.isTypeForHVX(Ty))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2259</td>
    <td class="codeLine">  if (HST.isTypeForHVX(Ty))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="codeLine">    return HST.getVectorLength();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2260</td>
    <td class="codeLine">    return HST.getVectorLength();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="codeLine">  return DL.getABITypeAlign(Ty).value();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2261</td>
    <td class="codeLine">  return DL.getABITypeAlign(Ty).value();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2262</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2263</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="codeLine">auto HexagonVectorCombine::length(Value *Val) const -> size_t {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2264</td>
    <td class="codeLine">auto HexagonVectorCombine::length(Value *Val) const -> size_t {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="codeLine">  return length(Val->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2265</td>
    <td class="codeLine">  return length(Val->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2266</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2267</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="codeLine">auto HexagonVectorCombine::length(Type *Ty) const -> size_t {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2268</td>
    <td class="codeLine">auto HexagonVectorCombine::length(Type *Ty) const -> size_t {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="codeLine">  auto *VecTy = dyn_cast<VectorType>(Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2269</td>
    <td class="codeLine">  auto *VecTy = dyn_cast<VectorType>(Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="codeLine">  assert(VecTy && "Must be a vector type");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2270</td>
    <td class="codeLine">  assert(VecTy && "Must be a vector type");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="codeLine">  return VecTy->getElementCount().getFixedValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2271</td>
    <td class="codeLine">  return VecTy->getElementCount().getFixedValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2272</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2273</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="codeLine">auto HexagonVectorCombine::getNullValue(Type *Ty) const -> Constant * {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2274</td>
    <td class="codeLine">auto HexagonVectorCombine::getNullValue(Type *Ty) const -> Constant * {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="codeLine">  assert(Ty->isIntOrIntVectorTy());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2275</td>
    <td class="codeLine">  assert(Ty->isIntOrIntVectorTy());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="codeLine">  auto Zero = ConstantInt::get(Ty->getScalarType(), 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2276</td>
    <td class="codeLine">  auto Zero = ConstantInt::get(Ty->getScalarType(), 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="codeLine">  if (auto *VecTy = dyn_cast<VectorType>(Ty))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2277</td>
    <td class="codeLine">  if (auto *VecTy = dyn_cast<VectorType>(Ty))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="codeLine">    return ConstantVector::getSplat(VecTy->getElementCount(), Zero);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2278</td>
    <td class="codeLine">    return ConstantVector::getSplat(VecTy->getElementCount(), Zero);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="codeLine">  return Zero;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2279</td>
    <td class="codeLine">  return Zero;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2280</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2281</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="codeLine">auto HexagonVectorCombine::getFullValue(Type *Ty) const -> Constant * {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2282</td>
    <td class="codeLine">auto HexagonVectorCombine::getFullValue(Type *Ty) const -> Constant * {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="codeLine">  assert(Ty->isIntOrIntVectorTy());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2283</td>
    <td class="codeLine">  assert(Ty->isIntOrIntVectorTy());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="codeLine">  auto Minus1 = ConstantInt::get(Ty->getScalarType(), -1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2284</td>
    <td class="codeLine">  auto Minus1 = ConstantInt::get(Ty->getScalarType(), -1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="codeLine">  if (auto *VecTy = dyn_cast<VectorType>(Ty))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2285</td>
    <td class="codeLine">  if (auto *VecTy = dyn_cast<VectorType>(Ty))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="codeLine">    return ConstantVector::getSplat(VecTy->getElementCount(), Minus1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2286</td>
    <td class="codeLine">    return ConstantVector::getSplat(VecTy->getElementCount(), Minus1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="codeLine">  return Minus1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2287</td>
    <td class="codeLine">  return Minus1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2288</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2289</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="codeLine">auto HexagonVectorCombine::getConstSplat(Type *Ty, int Val) const</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2290</td>
    <td class="codeLine">auto HexagonVectorCombine::getConstSplat(Type *Ty, int Val) const</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="codeLine">    -> Constant * {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2291</td>
    <td class="codeLine">    -> Constant * {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="codeLine">  assert(Ty->isVectorTy());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2292</td>
    <td class="codeLine">  assert(Ty->isVectorTy());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="codeLine">  auto VecTy = cast<VectorType>(Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2293</td>
    <td class="codeLine">  auto VecTy = cast<VectorType>(Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="codeLine">  Type *ElemTy = VecTy->getElementType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2294</td>
    <td class="codeLine">  Type *ElemTy = VecTy->getElementType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="codeLine">  // Add support for floats if needed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2295</td>
    <td class="codeLine">  // Add support for floats if needed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="codeLine">  auto *Splat = ConstantVector::getSplat(VecTy->getElementCount(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2296</td>
    <td class="codeLine">  auto *Splat = ConstantVector::getSplat(VecTy->getElementCount(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="codeLine">                                         ConstantInt::get(ElemTy, Val));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2297</td>
    <td class="codeLine">                                         ConstantInt::get(ElemTy, Val));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="codeLine">  return Splat;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2298</td>
    <td class="codeLine">  return Splat;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2299</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2300</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="codeLine">auto HexagonVectorCombine::simplify(Value *V) const -> Value * {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2301</td>
    <td class="codeLine">auto HexagonVectorCombine::simplify(Value *V) const -> Value * {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="codeLine">  if (auto *In = dyn_cast<Instruction>(V)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2302</td>
    <td class="codeLine">  if (auto *In = dyn_cast<Instruction>(V)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="codeLine">    SimplifyQuery Q(DL, &TLI, &DT, &AC, In);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2303</td>
    <td class="codeLine">    SimplifyQuery Q(DL, &TLI, &DT, &AC, In);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="codeLine">    return simplifyInstruction(In, Q);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2304</td>
    <td class="codeLine">    return simplifyInstruction(In, Q);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2305</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2306</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2307</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2308</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="codeLine">// Insert bytes [Start..Start+Length) of Src into Dst at byte Where.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2309</td>
    <td class="codeLine">// Insert bytes [Start..Start+Length) of Src into Dst at byte Where.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="codeLine">auto HexagonVectorCombine::insertb(IRBuilderBase &Builder, Value *Dst,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2310</td>
    <td class="codeLine">auto HexagonVectorCombine::insertb(IRBuilderBase &Builder, Value *Dst,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="codeLine">                                   Value *Src, int Start, int Length,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2311</td>
    <td class="codeLine">                                   Value *Src, int Start, int Length,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="codeLine">                                   int Where) const -> Value * {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2312</td>
    <td class="codeLine">                                   int Where) const -> Value * {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="codeLine">  assert(isByteVecTy(Dst->getType()) && isByteVecTy(Src->getType()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2313</td>
    <td class="codeLine">  assert(isByteVecTy(Dst->getType()) && isByteVecTy(Src->getType()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="codeLine">  int SrcLen = getSizeOf(Src);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2314</td>
    <td class="codeLine">  int SrcLen = getSizeOf(Src);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="codeLine">  int DstLen = getSizeOf(Dst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2315</td>
    <td class="codeLine">  int DstLen = getSizeOf(Dst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="codeLine">  assert(0 <= Start && Start + Length <= SrcLen);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2316</td>
    <td class="codeLine">  assert(0 <= Start && Start + Length <= SrcLen);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="codeLine">  assert(0 <= Where && Where + Length <= DstLen);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2317</td>
    <td class="codeLine">  assert(0 <= Where && Where + Length <= DstLen);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2318</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="codeLine">  int P2Len = PowerOf2Ceil(SrcLen | DstLen);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2319</td>
    <td class="codeLine">  int P2Len = PowerOf2Ceil(SrcLen | DstLen);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="codeLine">  auto *Undef = UndefValue::get(getByteTy());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2320</td>
    <td class="codeLine">  auto *Undef = UndefValue::get(getByteTy());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="codeLine">  Value *P2Src = vresize(Builder, Src, P2Len, Undef);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2321</td>
    <td class="codeLine">  Value *P2Src = vresize(Builder, Src, P2Len, Undef);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="codeLine">  Value *P2Dst = vresize(Builder, Dst, P2Len, Undef);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2322</td>
    <td class="codeLine">  Value *P2Dst = vresize(Builder, Dst, P2Len, Undef);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2323</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="codeLine">  SmallVector<int, 256> SMask(P2Len);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2324</td>
    <td class="codeLine">  SmallVector<int, 256> SMask(P2Len);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="codeLine">  for (int i = 0; i != P2Len; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2325</td>
    <td class="codeLine">  for (int i = 0; i != P2Len; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="codeLine">    // If i is in [Where, Where+Length), pick Src[Start+(i-Where)].</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2326</td>
    <td class="codeLine">    // If i is in [Where, Where+Length), pick Src[Start+(i-Where)].</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="codeLine">    // Otherwise, pick Dst[i];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2327</td>
    <td class="codeLine">    // Otherwise, pick Dst[i];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="codeLine">    SMask[i] =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2328</td>
    <td class="codeLine">    SMask[i] =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="codeLine">        (Where <= i && i < Where + Length) ? P2Len + Start + (i - Where) : i;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2329</td>
    <td class="codeLine">        (Where <= i && i < Where + Length) ? P2Len + Start + (i - Where) : i;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2330</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2331</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="codeLine">  Value *P2Insert = Builder.CreateShuffleVector(P2Dst, P2Src, SMask, "shf");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2332</td>
    <td class="codeLine">  Value *P2Insert = Builder.CreateShuffleVector(P2Dst, P2Src, SMask, "shf");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="codeLine">  return vresize(Builder, P2Insert, DstLen, Undef);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2333</td>
    <td class="codeLine">  return vresize(Builder, P2Insert, DstLen, Undef);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2334</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2335</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="codeLine">auto HexagonVectorCombine::vlalignb(IRBuilderBase &Builder, Value *Lo,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2336</td>
    <td class="codeLine">auto HexagonVectorCombine::vlalignb(IRBuilderBase &Builder, Value *Lo,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="codeLine">                                    Value *Hi, Value *Amt) const -> Value * {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2337</td>
    <td class="codeLine">                                    Value *Hi, Value *Amt) const -> Value * {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="codeLine">  assert(Lo->getType() == Hi->getType() && "Argument type mismatch");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2338</td>
    <td class="codeLine">  assert(Lo->getType() == Hi->getType() && "Argument type mismatch");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="codeLine">  if (isZero(Amt))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2339</td>
    <td class="codeLine">  if (isZero(Amt))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="codeLine">    return Hi;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2340</td>
    <td class="codeLine">    return Hi;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="codeLine">  int VecLen = getSizeOf(Hi);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2341</td>
    <td class="codeLine">  int VecLen = getSizeOf(Hi);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="codeLine">  if (auto IntAmt = getIntValue(Amt))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2342</td>
    <td class="codeLine">  if (auto IntAmt = getIntValue(Amt))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="codeLine">    return getElementRange(Builder, Lo, Hi, VecLen - IntAmt->getSExtValue(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2343</td>
    <td class="codeLine">    return getElementRange(Builder, Lo, Hi, VecLen - IntAmt->getSExtValue(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="codeLine">                           VecLen);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2344</td>
    <td class="codeLine">                           VecLen);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2345</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="codeLine">  if (HST.isTypeForHVX(Hi->getType())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2346</td>
    <td class="codeLine">  if (HST.isTypeForHVX(Hi->getType())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="codeLine">    assert(static_cast<unsigned>(VecLen) == HST.getVectorLength() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2347</td>
    <td class="codeLine">    assert(static_cast<unsigned>(VecLen) == HST.getVectorLength() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="codeLine">           "Expecting an exact HVX type");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2348</td>
    <td class="codeLine">           "Expecting an exact HVX type");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="codeLine">    return createHvxIntrinsic(Builder, HST.getIntrinsicId(Hexagon::V6_vlalignb),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2349</td>
    <td class="codeLine">    return createHvxIntrinsic(Builder, HST.getIntrinsicId(Hexagon::V6_vlalignb),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="codeLine">                              Hi->getType(), {Hi, Lo, Amt});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2350</td>
    <td class="codeLine">                              Hi->getType(), {Hi, Lo, Amt});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2351</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2352</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="codeLine">  if (VecLen == 4) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2353</td>
    <td class="codeLine">  if (VecLen == 4) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="codeLine">    Value *Pair = concat(Builder, {Lo, Hi});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2354</td>
    <td class="codeLine">    Value *Pair = concat(Builder, {Lo, Hi});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="codeLine">    Value *Shift =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2355</td>
    <td class="codeLine">    Value *Shift =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="codeLine">        Builder.CreateLShr(Builder.CreateShl(Pair, Amt, "shl"), 32, "lsr");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2356</td>
    <td class="codeLine">        Builder.CreateLShr(Builder.CreateShl(Pair, Amt, "shl"), 32, "lsr");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="codeLine">    Value *Trunc =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2357</td>
    <td class="codeLine">    Value *Trunc =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="codeLine">        Builder.CreateTrunc(Shift, Type::getInt32Ty(F.getContext()), "trn");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2358</td>
    <td class="codeLine">        Builder.CreateTrunc(Shift, Type::getInt32Ty(F.getContext()), "trn");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="codeLine">    return Builder.CreateBitCast(Trunc, Hi->getType(), "cst");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2359</td>
    <td class="codeLine">    return Builder.CreateBitCast(Trunc, Hi->getType(), "cst");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2360</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="codeLine">  if (VecLen == 8) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2361</td>
    <td class="codeLine">  if (VecLen == 8) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="codeLine">    Value *Sub = Builder.CreateSub(getConstInt(VecLen), Amt, "sub");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2362</td>
    <td class="codeLine">    Value *Sub = Builder.CreateSub(getConstInt(VecLen), Amt, "sub");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="codeLine">    return vralignb(Builder, Lo, Hi, Sub);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2363</td>
    <td class="codeLine">    return vralignb(Builder, Lo, Hi, Sub);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2364</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="codeLine">  llvm_unreachable("Unexpected vector length");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2365</td>
    <td class="codeLine">  llvm_unreachable("Unexpected vector length");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2366</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2367</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="codeLine">auto HexagonVectorCombine::vralignb(IRBuilderBase &Builder, Value *Lo,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2368</td>
    <td class="codeLine">auto HexagonVectorCombine::vralignb(IRBuilderBase &Builder, Value *Lo,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="codeLine">                                    Value *Hi, Value *Amt) const -> Value * {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2369</td>
    <td class="codeLine">                                    Value *Hi, Value *Amt) const -> Value * {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="codeLine">  assert(Lo->getType() == Hi->getType() && "Argument type mismatch");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2370</td>
    <td class="codeLine">  assert(Lo->getType() == Hi->getType() && "Argument type mismatch");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="codeLine">  if (isZero(Amt))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2371</td>
    <td class="codeLine">  if (isZero(Amt))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="codeLine">    return Lo;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2372</td>
    <td class="codeLine">    return Lo;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="codeLine">  int VecLen = getSizeOf(Lo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2373</td>
    <td class="codeLine">  int VecLen = getSizeOf(Lo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="codeLine">  if (auto IntAmt = getIntValue(Amt))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2374</td>
    <td class="codeLine">  if (auto IntAmt = getIntValue(Amt))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="codeLine">    return getElementRange(Builder, Lo, Hi, IntAmt->getSExtValue(), VecLen);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2375</td>
    <td class="codeLine">    return getElementRange(Builder, Lo, Hi, IntAmt->getSExtValue(), VecLen);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2376</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="codeLine">  if (HST.isTypeForHVX(Lo->getType())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2377</td>
    <td class="codeLine">  if (HST.isTypeForHVX(Lo->getType())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="codeLine">    assert(static_cast<unsigned>(VecLen) == HST.getVectorLength() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2378</td>
    <td class="codeLine">    assert(static_cast<unsigned>(VecLen) == HST.getVectorLength() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="codeLine">           "Expecting an exact HVX type");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2379</td>
    <td class="codeLine">           "Expecting an exact HVX type");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="codeLine">    return createHvxIntrinsic(Builder, HST.getIntrinsicId(Hexagon::V6_valignb),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2380</td>
    <td class="codeLine">    return createHvxIntrinsic(Builder, HST.getIntrinsicId(Hexagon::V6_valignb),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="codeLine">                              Lo->getType(), {Hi, Lo, Amt});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2381</td>
    <td class="codeLine">                              Lo->getType(), {Hi, Lo, Amt});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2382</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2383</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="codeLine">  if (VecLen == 4) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2384</td>
    <td class="codeLine">  if (VecLen == 4) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="codeLine">    Value *Pair = concat(Builder, {Lo, Hi});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2385</td>
    <td class="codeLine">    Value *Pair = concat(Builder, {Lo, Hi});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="codeLine">    Value *Shift = Builder.CreateLShr(Pair, Amt, "lsr");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2386</td>
    <td class="codeLine">    Value *Shift = Builder.CreateLShr(Pair, Amt, "lsr");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="codeLine">    Value *Trunc =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2387</td>
    <td class="codeLine">    Value *Trunc =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="codeLine">        Builder.CreateTrunc(Shift, Type::getInt32Ty(F.getContext()), "trn");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2388</td>
    <td class="codeLine">        Builder.CreateTrunc(Shift, Type::getInt32Ty(F.getContext()), "trn");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="codeLine">    return Builder.CreateBitCast(Trunc, Lo->getType(), "cst");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2389</td>
    <td class="codeLine">    return Builder.CreateBitCast(Trunc, Lo->getType(), "cst");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2390</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="codeLine">  if (VecLen == 8) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2391</td>
    <td class="codeLine">  if (VecLen == 8) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="codeLine">    Type *Int64Ty = Type::getInt64Ty(F.getContext());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2392</td>
    <td class="codeLine">    Type *Int64Ty = Type::getInt64Ty(F.getContext());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="codeLine">    Value *Lo64 = Builder.CreateBitCast(Lo, Int64Ty, "cst");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2393</td>
    <td class="codeLine">    Value *Lo64 = Builder.CreateBitCast(Lo, Int64Ty, "cst");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="codeLine">    Value *Hi64 = Builder.CreateBitCast(Hi, Int64Ty, "cst");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2394</td>
    <td class="codeLine">    Value *Hi64 = Builder.CreateBitCast(Hi, Int64Ty, "cst");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="codeLine">    Function *FI = Intrinsic::getDeclaration(F.getParent(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2395</td>
    <td class="codeLine">    Function *FI = Intrinsic::getDeclaration(F.getParent(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="codeLine">                                             Intrinsic::hexagon_S2_valignrb);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2396</td>
    <td class="codeLine">                                             Intrinsic::hexagon_S2_valignrb);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="codeLine">    Value *Call = Builder.CreateCall(FI, {Hi64, Lo64, Amt}, "cup");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2397</td>
    <td class="codeLine">    Value *Call = Builder.CreateCall(FI, {Hi64, Lo64, Amt}, "cup");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="codeLine">    return Builder.CreateBitCast(Call, Lo->getType(), "cst");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2398</td>
    <td class="codeLine">    return Builder.CreateBitCast(Call, Lo->getType(), "cst");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2399</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="codeLine">  llvm_unreachable("Unexpected vector length");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2400</td>
    <td class="codeLine">  llvm_unreachable("Unexpected vector length");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2401</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2402</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="codeLine">// Concatenates a sequence of vectors of the same type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2403</td>
    <td class="codeLine">// Concatenates a sequence of vectors of the same type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="codeLine">auto HexagonVectorCombine::concat(IRBuilderBase &Builder,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2404</td>
    <td class="codeLine">auto HexagonVectorCombine::concat(IRBuilderBase &Builder,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="codeLine">                                  ArrayRef<Value *> Vecs) const -> Value * {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2405</td>
    <td class="codeLine">                                  ArrayRef<Value *> Vecs) const -> Value * {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="codeLine">  assert(!Vecs.empty());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2406</td>
    <td class="codeLine">  assert(!Vecs.empty());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="codeLine">  SmallVector<int, 256> SMask;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2407</td>
    <td class="codeLine">  SmallVector<int, 256> SMask;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="codeLine">  std::vector<Value *> Work[2];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2408</td>
    <td class="codeLine">  std::vector<Value *> Work[2];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="codeLine">  int ThisW = 0, OtherW = 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2409</td>
    <td class="codeLine">  int ThisW = 0, OtherW = 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2410</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="codeLine">  Work[ThisW].assign(Vecs.begin(), Vecs.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2411</td>
    <td class="codeLine">  Work[ThisW].assign(Vecs.begin(), Vecs.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="codeLine">  while (Work[ThisW].size() > 1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2412</td>
    <td class="codeLine">  while (Work[ThisW].size() > 1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="codeLine">    auto *Ty = cast<VectorType>(Work[ThisW].front()->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2413</td>
    <td class="codeLine">    auto *Ty = cast<VectorType>(Work[ThisW].front()->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="codeLine">    SMask.resize(length(Ty) * 2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2414</td>
    <td class="codeLine">    SMask.resize(length(Ty) * 2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="codeLine">    std::iota(SMask.begin(), SMask.end(), 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2415</td>
    <td class="codeLine">    std::iota(SMask.begin(), SMask.end(), 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2416</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="codeLine">    Work[OtherW].clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2417</td>
    <td class="codeLine">    Work[OtherW].clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="codeLine">    if (Work[ThisW].size() % 2 != 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2418</td>
    <td class="codeLine">    if (Work[ThisW].size() % 2 != 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="codeLine">      Work[ThisW].push_back(UndefValue::get(Ty));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2419</td>
    <td class="codeLine">      Work[ThisW].push_back(UndefValue::get(Ty));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="codeLine">    for (int i = 0, e = Work[ThisW].size(); i < e; i += 2) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2420</td>
    <td class="codeLine">    for (int i = 0, e = Work[ThisW].size(); i < e; i += 2) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="codeLine">      Value *Joined = Builder.CreateShuffleVector(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2421</td>
    <td class="codeLine">      Value *Joined = Builder.CreateShuffleVector(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="codeLine">          Work[ThisW][i], Work[ThisW][i + 1], SMask, "shf");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2422</td>
    <td class="codeLine">          Work[ThisW][i], Work[ThisW][i + 1], SMask, "shf");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="codeLine">      Work[OtherW].push_back(Joined);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2423</td>
    <td class="codeLine">      Work[OtherW].push_back(Joined);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2424</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="codeLine">    std::swap(ThisW, OtherW);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2425</td>
    <td class="codeLine">    std::swap(ThisW, OtherW);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2426</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2427</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="codeLine">  // Since there may have been some undefs appended to make shuffle operands</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2428</td>
    <td class="codeLine">  // Since there may have been some undefs appended to make shuffle operands</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="codeLine">  // have the same type, perform the last shuffle to only pick the original</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2429</td>
    <td class="codeLine">  // have the same type, perform the last shuffle to only pick the original</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="codeLine">  // elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2430</td>
    <td class="codeLine">  // elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="codeLine">  SMask.resize(Vecs.size() * length(Vecs.front()->getType()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2431</td>
    <td class="codeLine">  SMask.resize(Vecs.size() * length(Vecs.front()->getType()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="codeLine">  std::iota(SMask.begin(), SMask.end(), 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2432</td>
    <td class="codeLine">  std::iota(SMask.begin(), SMask.end(), 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="codeLine">  Value *Total = Work[ThisW].front();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2433</td>
    <td class="codeLine">  Value *Total = Work[ThisW].front();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="codeLine">  return Builder.CreateShuffleVector(Total, SMask, "shf");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2434</td>
    <td class="codeLine">  return Builder.CreateShuffleVector(Total, SMask, "shf");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2435</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2436</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="codeLine">auto HexagonVectorCombine::vresize(IRBuilderBase &Builder, Value *Val,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2437</td>
    <td class="codeLine">auto HexagonVectorCombine::vresize(IRBuilderBase &Builder, Value *Val,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="codeLine">                                   int NewSize, Value *Pad) const -> Value * {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2438</td>
    <td class="codeLine">                                   int NewSize, Value *Pad) const -> Value * {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="codeLine">  assert(isa<VectorType>(Val->getType()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2439</td>
    <td class="codeLine">  assert(isa<VectorType>(Val->getType()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="codeLine">  auto *ValTy = cast<VectorType>(Val->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2440</td>
    <td class="codeLine">  auto *ValTy = cast<VectorType>(Val->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="codeLine">  assert(ValTy->getElementType() == Pad->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2441</td>
    <td class="codeLine">  assert(ValTy->getElementType() == Pad->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2442</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="codeLine">  int CurSize = length(ValTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2443</td>
    <td class="codeLine">  int CurSize = length(ValTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="codeLine">  if (CurSize == NewSize)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2444</td>
    <td class="codeLine">  if (CurSize == NewSize)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="codeLine">    return Val;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2445</td>
    <td class="codeLine">    return Val;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="codeLine">  // Truncate?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2446</td>
    <td class="codeLine">  // Truncate?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="codeLine">  if (CurSize > NewSize)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2447</td>
    <td class="codeLine">  if (CurSize > NewSize)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="codeLine">    return getElementRange(Builder, Val, /*Ignored*/ Val, 0, NewSize);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2448</td>
    <td class="codeLine">    return getElementRange(Builder, Val, /*Ignored*/ Val, 0, NewSize);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="codeLine">  // Extend.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2449</td>
    <td class="codeLine">  // Extend.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="codeLine">  SmallVector<int, 128> SMask(NewSize);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2450</td>
    <td class="codeLine">  SmallVector<int, 128> SMask(NewSize);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="codeLine">  std::iota(SMask.begin(), SMask.begin() + CurSize, 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2451</td>
    <td class="codeLine">  std::iota(SMask.begin(), SMask.begin() + CurSize, 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="codeLine">  std::fill(SMask.begin() + CurSize, SMask.end(), CurSize);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2452</td>
    <td class="codeLine">  std::fill(SMask.begin() + CurSize, SMask.end(), CurSize);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="codeLine">  Value *PadVec = Builder.CreateVectorSplat(CurSize, Pad, "spt");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2453</td>
    <td class="codeLine">  Value *PadVec = Builder.CreateVectorSplat(CurSize, Pad, "spt");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="codeLine">  return Builder.CreateShuffleVector(Val, PadVec, SMask, "shf");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2454</td>
    <td class="codeLine">  return Builder.CreateShuffleVector(Val, PadVec, SMask, "shf");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2455</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2456</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="codeLine">auto HexagonVectorCombine::rescale(IRBuilderBase &Builder, Value *Mask,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2457</td>
    <td class="codeLine">auto HexagonVectorCombine::rescale(IRBuilderBase &Builder, Value *Mask,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="codeLine">                                   Type *FromTy, Type *ToTy) const -> Value * {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2458</td>
    <td class="codeLine">                                   Type *FromTy, Type *ToTy) const -> Value * {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="codeLine">  // Mask is a vector <N x i1>, where each element corresponds to an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2459</td>
    <td class="codeLine">  // Mask is a vector <N x i1>, where each element corresponds to an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="codeLine">  // element of FromTy. Remap it so that each element will correspond</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2460</td>
    <td class="codeLine">  // element of FromTy. Remap it so that each element will correspond</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="codeLine">  // to an element of ToTy.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2461</td>
    <td class="codeLine">  // to an element of ToTy.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="codeLine">  assert(isa<VectorType>(Mask->getType()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2462</td>
    <td class="codeLine">  assert(isa<VectorType>(Mask->getType()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2463</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="codeLine">  Type *FromSTy = FromTy->getScalarType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2464</td>
    <td class="codeLine">  Type *FromSTy = FromTy->getScalarType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="codeLine">  Type *ToSTy = ToTy->getScalarType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2465</td>
    <td class="codeLine">  Type *ToSTy = ToTy->getScalarType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="codeLine">  if (FromSTy == ToSTy)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2466</td>
    <td class="codeLine">  if (FromSTy == ToSTy)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="codeLine">    return Mask;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2467</td>
    <td class="codeLine">    return Mask;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2468</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="codeLine">  int FromSize = getSizeOf(FromSTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2469</td>
    <td class="codeLine">  int FromSize = getSizeOf(FromSTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="codeLine">  int ToSize = getSizeOf(ToSTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2470</td>
    <td class="codeLine">  int ToSize = getSizeOf(ToSTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="codeLine">  assert(FromSize % ToSize == 0 || ToSize % FromSize == 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2471</td>
    <td class="codeLine">  assert(FromSize % ToSize == 0 || ToSize % FromSize == 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2472</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="codeLine">  auto *MaskTy = cast<VectorType>(Mask->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2473</td>
    <td class="codeLine">  auto *MaskTy = cast<VectorType>(Mask->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="codeLine">  int FromCount = length(MaskTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2474</td>
    <td class="codeLine">  int FromCount = length(MaskTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2475</td>
    <td class="codeLine">  int ToCount = (FromCount * FromSize) / ToSize;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2475</td>
    <td class="codeLine">  int ToCount = (FromCount * FromSize) / ToSize;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2476</td>
    <td class="codeLine">  assert((FromCount * FromSize) % ToSize == 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2476</td>
    <td class="codeLine">  assert((FromCount * FromSize) % ToSize == 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2477</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2477</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2478</td>
    <td class="codeLine">  auto *FromITy = getIntTy(FromSize * 8);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2478</td>
    <td class="codeLine">  auto *FromITy = getIntTy(FromSize * 8);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2479</td>
    <td class="codeLine">  auto *ToITy = getIntTy(ToSize * 8);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2479</td>
    <td class="codeLine">  auto *ToITy = getIntTy(ToSize * 8);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2480</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2480</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2481</td>
    <td class="codeLine">  // Mask <N x i1> -> sext to <N x FromTy> -> bitcast to <M x ToTy> -></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2481</td>
    <td class="codeLine">  // Mask <N x i1> -> sext to <N x FromTy> -> bitcast to <M x ToTy> -></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2482</td>
    <td class="codeLine">  // -> trunc to <M x i1>.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2482</td>
    <td class="codeLine">  // -> trunc to <M x i1>.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2483</td>
    <td class="codeLine">  Value *Ext = Builder.CreateSExt(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2483</td>
    <td class="codeLine">  Value *Ext = Builder.CreateSExt(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2484</td>
    <td class="codeLine">      Mask, VectorType::get(FromITy, FromCount, /*Scalable=*/false), "sxt");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2484</td>
    <td class="codeLine">      Mask, VectorType::get(FromITy, FromCount, /*Scalable=*/false), "sxt");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2485</td>
    <td class="codeLine">  Value *Cast = Builder.CreateBitCast(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2485</td>
    <td class="codeLine">  Value *Cast = Builder.CreateBitCast(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2486</td>
    <td class="codeLine">      Ext, VectorType::get(ToITy, ToCount, /*Scalable=*/false), "cst");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2486</td>
    <td class="codeLine">      Ext, VectorType::get(ToITy, ToCount, /*Scalable=*/false), "cst");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2487</td>
    <td class="codeLine">  return Builder.CreateTrunc(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2487</td>
    <td class="codeLine">  return Builder.CreateTrunc(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2488</td>
    <td class="codeLine">      Cast, VectorType::get(getBoolTy(), ToCount, /*Scalable=*/false), "trn");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2488</td>
    <td class="codeLine">      Cast, VectorType::get(getBoolTy(), ToCount, /*Scalable=*/false), "trn");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2489</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2489</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2490</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2490</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2491</td>
    <td class="codeLine">// Bitcast to bytes, and return least significant bits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2491</td>
    <td class="codeLine">// Bitcast to bytes, and return least significant bits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2492</td>
    <td class="codeLine">auto HexagonVectorCombine::vlsb(IRBuilderBase &Builder, Value *Val) const</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2492</td>
    <td class="codeLine">auto HexagonVectorCombine::vlsb(IRBuilderBase &Builder, Value *Val) const</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2493</td>
    <td class="codeLine">    -> Value * {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2493</td>
    <td class="codeLine">    -> Value * {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2494</td>
    <td class="codeLine">  Type *ScalarTy = Val->getType()->getScalarType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2494</td>
    <td class="codeLine">  Type *ScalarTy = Val->getType()->getScalarType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2495</td>
    <td class="codeLine">  if (ScalarTy == getBoolTy())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2495</td>
    <td class="codeLine">  if (ScalarTy == getBoolTy())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2496</td>
    <td class="codeLine">    return Val;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2496</td>
    <td class="codeLine">    return Val;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2497</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2497</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2498</td>
    <td class="codeLine">  Value *Bytes = vbytes(Builder, Val);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2498</td>
    <td class="codeLine">  Value *Bytes = vbytes(Builder, Val);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2499</td>
    <td class="codeLine">  if (auto *VecTy = dyn_cast<VectorType>(Bytes->getType()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2499</td>
    <td class="codeLine">  if (auto *VecTy = dyn_cast<VectorType>(Bytes->getType()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2500</td>
    <td class="codeLine">    return Builder.CreateTrunc(Bytes, getBoolTy(getSizeOf(VecTy)), "trn");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2500</td>
    <td class="codeLine">    return Builder.CreateTrunc(Bytes, getBoolTy(getSizeOf(VecTy)), "trn");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2501</td>
    <td class="codeLine">  // If Bytes is a scalar (i.e. Val was a scalar byte), return i1, not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2501</td>
    <td class="codeLine">  // If Bytes is a scalar (i.e. Val was a scalar byte), return i1, not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2502</td>
    <td class="codeLine">  // <1 x i1>.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2502</td>
    <td class="codeLine">  // <1 x i1>.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2503</td>
    <td class="codeLine">  return Builder.CreateTrunc(Bytes, getBoolTy(), "trn");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2503</td>
    <td class="codeLine">  return Builder.CreateTrunc(Bytes, getBoolTy(), "trn");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2504</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2504</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2505</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2505</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2506</td>
    <td class="codeLine">// Bitcast to bytes for non-bool. For bool, convert i1 -> i8.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2506</td>
    <td class="codeLine">// Bitcast to bytes for non-bool. For bool, convert i1 -> i8.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2507</td>
    <td class="codeLine">auto HexagonVectorCombine::vbytes(IRBuilderBase &Builder, Value *Val) const</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2507</td>
    <td class="codeLine">auto HexagonVectorCombine::vbytes(IRBuilderBase &Builder, Value *Val) const</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2508</td>
    <td class="codeLine">    -> Value * {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2508</td>
    <td class="codeLine">    -> Value * {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2509</td>
    <td class="codeLine">  Type *ScalarTy = Val->getType()->getScalarType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2509</td>
    <td class="codeLine">  Type *ScalarTy = Val->getType()->getScalarType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2510</td>
    <td class="codeLine">  if (ScalarTy == getByteTy())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2510</td>
    <td class="codeLine">  if (ScalarTy == getByteTy())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2511</td>
    <td class="codeLine">    return Val;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2511</td>
    <td class="codeLine">    return Val;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2512</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2512</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2513</td>
    <td class="codeLine">  if (ScalarTy != getBoolTy())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2513</td>
    <td class="codeLine">  if (ScalarTy != getBoolTy())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2514</td>
    <td class="codeLine">    return Builder.CreateBitCast(Val, getByteTy(getSizeOf(Val)), "cst");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2514</td>
    <td class="codeLine">    return Builder.CreateBitCast(Val, getByteTy(getSizeOf(Val)), "cst");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2515</td>
    <td class="codeLine">  // For bool, return a sext from i1 to i8.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2515</td>
    <td class="codeLine">  // For bool, return a sext from i1 to i8.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2516</td>
    <td class="codeLine">  if (auto *VecTy = dyn_cast<VectorType>(Val->getType()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2516</td>
    <td class="codeLine">  if (auto *VecTy = dyn_cast<VectorType>(Val->getType()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2517</td>
    <td class="codeLine">    return Builder.CreateSExt(Val, VectorType::get(getByteTy(), VecTy), "sxt");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2517</td>
    <td class="codeLine">    return Builder.CreateSExt(Val, VectorType::get(getByteTy(), VecTy), "sxt");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2518</td>
    <td class="codeLine">  return Builder.CreateSExt(Val, getByteTy(), "sxt");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2518</td>
    <td class="codeLine">  return Builder.CreateSExt(Val, getByteTy(), "sxt");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2519</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2519</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2520</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2520</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2521</td>
    <td class="codeLine">auto HexagonVectorCombine::subvector(IRBuilderBase &Builder, Value *Val,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2521</td>
    <td class="codeLine">auto HexagonVectorCombine::subvector(IRBuilderBase &Builder, Value *Val,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2522</td>
    <td class="codeLine">                                     unsigned Start, unsigned Length) const</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2522</td>
    <td class="codeLine">                                     unsigned Start, unsigned Length) const</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2523</td>
    <td class="codeLine">    -> Value * {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2523</td>
    <td class="codeLine">    -> Value * {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2524</td>
    <td class="codeLine">  assert(Start + Length <= length(Val));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2524</td>
    <td class="codeLine">  assert(Start + Length <= length(Val));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2525</td>
    <td class="codeLine">  return getElementRange(Builder, Val, /*Ignored*/ Val, Start, Length);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2525</td>
    <td class="codeLine">  return getElementRange(Builder, Val, /*Ignored*/ Val, Start, Length);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2526</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2526</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2527</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2527</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2528</td>
    <td class="codeLine">auto HexagonVectorCombine::sublo(IRBuilderBase &Builder, Value *Val) const</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2528</td>
    <td class="codeLine">auto HexagonVectorCombine::sublo(IRBuilderBase &Builder, Value *Val) const</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2529</td>
    <td class="codeLine">    -> Value * {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2529</td>
    <td class="codeLine">    -> Value * {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2530</td>
    <td class="codeLine">  size_t Len = length(Val);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2530</td>
    <td class="codeLine">  size_t Len = length(Val);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2531</td>
    <td class="codeLine">  assert(Len % 2 == 0 && "Length should be even");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2531</td>
    <td class="codeLine">  assert(Len % 2 == 0 && "Length should be even");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2532</td>
    <td class="codeLine">  return subvector(Builder, Val, 0, Len / 2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2532</td>
    <td class="codeLine">  return subvector(Builder, Val, 0, Len / 2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2533</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2533</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2534</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2534</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2535</td>
    <td class="codeLine">auto HexagonVectorCombine::subhi(IRBuilderBase &Builder, Value *Val) const</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2535</td>
    <td class="codeLine">auto HexagonVectorCombine::subhi(IRBuilderBase &Builder, Value *Val) const</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2536</td>
    <td class="codeLine">    -> Value * {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2536</td>
    <td class="codeLine">    -> Value * {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2537</td>
    <td class="codeLine">  size_t Len = length(Val);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2537</td>
    <td class="codeLine">  size_t Len = length(Val);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2538</td>
    <td class="codeLine">  assert(Len % 2 == 0 && "Length should be even");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2538</td>
    <td class="codeLine">  assert(Len % 2 == 0 && "Length should be even");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2539</td>
    <td class="codeLine">  return subvector(Builder, Val, Len / 2, Len / 2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2539</td>
    <td class="codeLine">  return subvector(Builder, Val, Len / 2, Len / 2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2540</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2540</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2541</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2541</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2542</td>
    <td class="codeLine">auto HexagonVectorCombine::vdeal(IRBuilderBase &Builder, Value *Val0,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2542</td>
    <td class="codeLine">auto HexagonVectorCombine::vdeal(IRBuilderBase &Builder, Value *Val0,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2543</td>
    <td class="codeLine">                                 Value *Val1) const -> Value * {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2543</td>
    <td class="codeLine">                                 Value *Val1) const -> Value * {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2544</td>
    <td class="codeLine">  assert(Val0->getType() == Val1->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2544</td>
    <td class="codeLine">  assert(Val0->getType() == Val1->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2545</td>
    <td class="codeLine">  int Len = length(Val0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2545</td>
    <td class="codeLine">  int Len = length(Val0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2546</td>
    <td class="codeLine">  SmallVector<int, 128> Mask(2 * Len);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2546</td>
    <td class="codeLine">  SmallVector<int, 128> Mask(2 * Len);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2547</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2547</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2548</td>
    <td class="codeLine">  for (int i = 0; i != Len; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2548</td>
    <td class="codeLine">  for (int i = 0; i != Len; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2549</td>
    <td class="codeLine">    Mask[i] = 2 * i;           // Even</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2549</td>
    <td class="codeLine">    Mask[i] = 2 * i;           // Even</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2550</td>
    <td class="codeLine">    Mask[i + Len] = 2 * i + 1; // Odd</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2550</td>
    <td class="codeLine">    Mask[i + Len] = 2 * i + 1; // Odd</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2551</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2551</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2552</td>
    <td class="codeLine">  return Builder.CreateShuffleVector(Val0, Val1, Mask, "shf");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2552</td>
    <td class="codeLine">  return Builder.CreateShuffleVector(Val0, Val1, Mask, "shf");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2553</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2553</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2554</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2554</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2555</td>
    <td class="codeLine">auto HexagonVectorCombine::vshuff(IRBuilderBase &Builder, Value *Val0,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2555</td>
    <td class="codeLine">auto HexagonVectorCombine::vshuff(IRBuilderBase &Builder, Value *Val0,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2556</td>
    <td class="codeLine">                                  Value *Val1) const -> Value * { //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2556</td>
    <td class="codeLine">                                  Value *Val1) const -> Value * { //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2557</td>
    <td class="codeLine">  assert(Val0->getType() == Val1->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2557</td>
    <td class="codeLine">  assert(Val0->getType() == Val1->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2558</td>
    <td class="codeLine">  int Len = length(Val0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2558</td>
    <td class="codeLine">  int Len = length(Val0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2559</td>
    <td class="codeLine">  SmallVector<int, 128> Mask(2 * Len);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2559</td>
    <td class="codeLine">  SmallVector<int, 128> Mask(2 * Len);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2560</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2560</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2561</td>
    <td class="codeLine">  for (int i = 0; i != Len; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2561</td>
    <td class="codeLine">  for (int i = 0; i != Len; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2562</td>
    <td class="codeLine">    Mask[2 * i + 0] = i;       // Val0</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2562</td>
    <td class="codeLine">    Mask[2 * i + 0] = i;       // Val0</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2563</td>
    <td class="codeLine">    Mask[2 * i + 1] = i + Len; // Val1</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2563</td>
    <td class="codeLine">    Mask[2 * i + 1] = i + Len; // Val1</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2564</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2564</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2565</td>
    <td class="codeLine">  return Builder.CreateShuffleVector(Val0, Val1, Mask, "shf");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2565</td>
    <td class="codeLine">  return Builder.CreateShuffleVector(Val0, Val1, Mask, "shf");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2566</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2566</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2567</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2567</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2568</td>
    <td class="codeLine">auto HexagonVectorCombine::createHvxIntrinsic(IRBuilderBase &Builder,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2568</td>
    <td class="codeLine">auto HexagonVectorCombine::createHvxIntrinsic(IRBuilderBase &Builder,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2569</td>
    <td class="codeLine">                                              Intrinsic::ID IntID, Type *RetTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2569</td>
    <td class="codeLine">                                              Intrinsic::ID IntID, Type *RetTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2570</td>
    <td class="codeLine">                                              ArrayRef<Value *> Args,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2570</td>
    <td class="codeLine">                                              ArrayRef<Value *> Args,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2571</td>
    <td class="codeLine">                                              ArrayRef<Type *> ArgTys,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2571</td>
    <td class="codeLine">                                              ArrayRef<Type *> ArgTys,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2572</td>
    <td class="codeLine">                                              ArrayRef<Value *> MDSources) const</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2572</td>
    <td class="codeLine">                                              ArrayRef<Value *> MDSources) const</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2573</td>
    <td class="codeLine">    -> Value * {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2573</td>
    <td class="codeLine">    -> Value * {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2574</td>
    <td class="codeLine">  auto getCast = [&](IRBuilderBase &Builder, Value *Val,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2574</td>
    <td class="codeLine">  auto getCast = [&](IRBuilderBase &Builder, Value *Val,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2575</td>
    <td class="codeLine">                     Type *DestTy) -> Value * {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2575</td>
    <td class="codeLine">                     Type *DestTy) -> Value * {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2576</td>
    <td class="codeLine">    Type *SrcTy = Val->getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2576</td>
    <td class="codeLine">    Type *SrcTy = Val->getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2577</td>
    <td class="codeLine">    if (SrcTy == DestTy)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2577</td>
    <td class="codeLine">    if (SrcTy == DestTy)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2578</td>
    <td class="codeLine">      return Val;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2578</td>
    <td class="codeLine">      return Val;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2579</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2579</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2580</td>
    <td class="codeLine">    // Non-HVX type. It should be a scalar, and it should already have</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2580</td>
    <td class="codeLine">    // Non-HVX type. It should be a scalar, and it should already have</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2581</td>
    <td class="codeLine">    // a valid type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2581</td>
    <td class="codeLine">    // a valid type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2582</td>
    <td class="codeLine">    assert(HST.isTypeForHVX(SrcTy, /*IncludeBool=*/true));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2582</td>
    <td class="codeLine">    assert(HST.isTypeForHVX(SrcTy, /*IncludeBool=*/true));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2583</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2583</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2584</td>
    <td class="codeLine">    Type *BoolTy = Type::getInt1Ty(F.getContext());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2584</td>
    <td class="codeLine">    Type *BoolTy = Type::getInt1Ty(F.getContext());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2585</td>
    <td class="codeLine">    if (cast<VectorType>(SrcTy)->getElementType() != BoolTy)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2585</td>
    <td class="codeLine">    if (cast<VectorType>(SrcTy)->getElementType() != BoolTy)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2586</td>
    <td class="codeLine">      return Builder.CreateBitCast(Val, DestTy, "cst");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2586</td>
    <td class="codeLine">      return Builder.CreateBitCast(Val, DestTy, "cst");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2587</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2587</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2588</td>
    <td class="codeLine">    // Predicate HVX vector.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2588</td>
    <td class="codeLine">    // Predicate HVX vector.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2589</td>
    <td class="codeLine">    unsigned HwLen = HST.getVectorLength();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2589</td>
    <td class="codeLine">    unsigned HwLen = HST.getVectorLength();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2590</td>
    <td class="codeLine">    Intrinsic::ID TC = HwLen == 64 ? Intrinsic::hexagon_V6_pred_typecast</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2590</td>
    <td class="codeLine">    Intrinsic::ID TC = HwLen == 64 ? Intrinsic::hexagon_V6_pred_typecast</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2591</td>
    <td class="codeLine">                                   : Intrinsic::hexagon_V6_pred_typecast_128B;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2591</td>
    <td class="codeLine">                                   : Intrinsic::hexagon_V6_pred_typecast_128B;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2592</td>
    <td class="codeLine">    Function *FI =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2592</td>
    <td class="codeLine">    Function *FI =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2593</td>
    <td class="codeLine">        Intrinsic::getDeclaration(F.getParent(), TC, {DestTy, Val->getType()});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2593</td>
    <td class="codeLine">        Intrinsic::getDeclaration(F.getParent(), TC, {DestTy, Val->getType()});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2594</td>
    <td class="codeLine">    return Builder.CreateCall(FI, {Val}, "cup");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2594</td>
    <td class="codeLine">    return Builder.CreateCall(FI, {Val}, "cup");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2595</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2595</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2596</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2596</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2597</td>
    <td class="codeLine">  Function *IntrFn = Intrinsic::getDeclaration(F.getParent(), IntID, ArgTys);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2597</td>
    <td class="codeLine">  Function *IntrFn = Intrinsic::getDeclaration(F.getParent(), IntID, ArgTys);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2598</td>
    <td class="codeLine">  FunctionType *IntrTy = IntrFn->getFunctionType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2598</td>
    <td class="codeLine">  FunctionType *IntrTy = IntrFn->getFunctionType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2599</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2599</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2600</td>
    <td class="codeLine">  SmallVector<Value *, 4> IntrArgs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2600</td>
    <td class="codeLine">  SmallVector<Value *, 4> IntrArgs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2601</td>
    <td class="codeLine">  for (int i = 0, e = Args.size(); i != e; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2601</td>
    <td class="codeLine">  for (int i = 0, e = Args.size(); i != e; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2602</td>
    <td class="codeLine">    Value *A = Args[i];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2602</td>
    <td class="codeLine">    Value *A = Args[i];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2603</td>
    <td class="codeLine">    Type *T = IntrTy->getParamType(i);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2603</td>
    <td class="codeLine">    Type *T = IntrTy->getParamType(i);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2604</td>
    <td class="codeLine">    if (A->getType() != T) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2604</td>
    <td class="codeLine">    if (A->getType() != T) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2605</td>
    <td class="codeLine">      IntrArgs.push_back(getCast(Builder, A, T));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2605</td>
    <td class="codeLine">      IntrArgs.push_back(getCast(Builder, A, T));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2606</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2606</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2607</td>
    <td class="codeLine">      IntrArgs.push_back(A);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2607</td>
    <td class="codeLine">      IntrArgs.push_back(A);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2608</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2608</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2609</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2609</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2610</td>
    <td class="codeLine">  StringRef MaybeName = !IntrTy->getReturnType()->isVoidTy() ? "cup" : "";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2610</td>
    <td class="codeLine">  StringRef MaybeName = !IntrTy->getReturnType()->isVoidTy() ? "cup" : "";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2611</td>
    <td class="codeLine">  CallInst *Call = Builder.CreateCall(IntrFn, IntrArgs, MaybeName);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2611</td>
    <td class="codeLine">  CallInst *Call = Builder.CreateCall(IntrFn, IntrArgs, MaybeName);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2612</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2612</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2613</td>
    <td class="codeLine">  MemoryEffects ME = Call->getAttributes().getMemoryEffects();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2613</td>
    <td class="codeLine">  MemoryEffects ME = Call->getAttributes().getMemoryEffects();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2614</td>
    <td class="codeLine">  if (!ME.doesNotAccessMemory() && !ME.onlyAccessesInaccessibleMem())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2614</td>
    <td class="codeLine">  if (!ME.doesNotAccessMemory() && !ME.onlyAccessesInaccessibleMem())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2615</td>
    <td class="codeLine">    propagateMetadata(Call, MDSources);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2615</td>
    <td class="codeLine">    propagateMetadata(Call, MDSources);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2616</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2616</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2617</td>
    <td class="codeLine">  Type *CallTy = Call->getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2617</td>
    <td class="codeLine">  Type *CallTy = Call->getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2618</td>
    <td class="codeLine">  if (RetTy == nullptr || CallTy == RetTy)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2618</td>
    <td class="codeLine">  if (RetTy == nullptr || CallTy == RetTy)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2619</td>
    <td class="codeLine">    return Call;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2619</td>
    <td class="codeLine">    return Call;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2620</td>
    <td class="codeLine">  // Scalar types should have RetTy matching the call return type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2620</td>
    <td class="codeLine">  // Scalar types should have RetTy matching the call return type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2621</td>
    <td class="codeLine">  assert(HST.isTypeForHVX(CallTy, /*IncludeBool=*/true));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2621</td>
    <td class="codeLine">  assert(HST.isTypeForHVX(CallTy, /*IncludeBool=*/true));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2622</td>
    <td class="codeLine">  return getCast(Builder, Call, RetTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2622</td>
    <td class="codeLine">  return getCast(Builder, Call, RetTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2623</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2623</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2624</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2624</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2625</td>
    <td class="codeLine">auto HexagonVectorCombine::splitVectorElements(IRBuilderBase &Builder,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2625</td>
    <td class="codeLine">auto HexagonVectorCombine::splitVectorElements(IRBuilderBase &Builder,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2626</td>
    <td class="codeLine">                                               Value *Vec,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2626</td>
    <td class="codeLine">                                               Value *Vec,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2627</td>
    <td class="codeLine">                                               unsigned ToWidth) const</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2627</td>
    <td class="codeLine">                                               unsigned ToWidth) const</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2628</td>
    <td class="codeLine">    -> SmallVector<Value *> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2628</td>
    <td class="codeLine">    -> SmallVector<Value *> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2629</td>
    <td class="codeLine">  // Break a vector of wide elements into a series of vectors with narrow</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2629</td>
    <td class="codeLine">  // Break a vector of wide elements into a series of vectors with narrow</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2630</td>
    <td class="codeLine">  // elements:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2630</td>
    <td class="codeLine">  // elements:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2631</td>
    <td class="codeLine">  //   (...c0:b0:a0, ...c1:b1:a1, ...c2:b2:a2, ...)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2631</td>
    <td class="codeLine">  //   (...c0:b0:a0, ...c1:b1:a1, ...c2:b2:a2, ...)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2632</td>
    <td class="codeLine">  // --></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2632</td>
    <td class="codeLine">  // --></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2633</td>
    <td class="codeLine">  //   (a0, a1, a2, ...)    // lowest "ToWidth" bits</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2633</td>
    <td class="codeLine">  //   (a0, a1, a2, ...)    // lowest "ToWidth" bits</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2634</td>
    <td class="codeLine">  //   (b0, b1, b2, ...)    // the next lowest...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2634</td>
    <td class="codeLine">  //   (b0, b1, b2, ...)    // the next lowest...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2635</td>
    <td class="codeLine">  //   (c0, c1, c2, ...)    // ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2635</td>
    <td class="codeLine">  //   (c0, c1, c2, ...)    // ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2636</td>
    <td class="codeLine">  //   ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2636</td>
    <td class="codeLine">  //   ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2637</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2637</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2638</td>
    <td class="codeLine">  // The number of elements in each resulting vector is the same as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2638</td>
    <td class="codeLine">  // The number of elements in each resulting vector is the same as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2639</td>
    <td class="codeLine">  // in the original vector.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2639</td>
    <td class="codeLine">  // in the original vector.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2640</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2640</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2641</td>
    <td class="codeLine">  auto *VecTy = cast<VectorType>(Vec->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2641</td>
    <td class="codeLine">  auto *VecTy = cast<VectorType>(Vec->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2642</td>
    <td class="codeLine">  assert(VecTy->getElementType()->isIntegerTy());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2642</td>
    <td class="codeLine">  assert(VecTy->getElementType()->isIntegerTy());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2643</td>
    <td class="codeLine">  unsigned FromWidth = VecTy->getScalarSizeInBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2643</td>
    <td class="codeLine">  unsigned FromWidth = VecTy->getScalarSizeInBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2644</td>
    <td class="codeLine">  assert(isPowerOf2_32(ToWidth) && isPowerOf2_32(FromWidth));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2644</td>
    <td class="codeLine">  assert(isPowerOf2_32(ToWidth) && isPowerOf2_32(FromWidth));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2645</td>
    <td class="codeLine">  assert(ToWidth <= FromWidth && "Breaking up into wider elements?");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2645</td>
    <td class="codeLine">  assert(ToWidth <= FromWidth && "Breaking up into wider elements?");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2646</td>
    <td class="codeLine">  unsigned NumResults = FromWidth / ToWidth;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2646</td>
    <td class="codeLine">  unsigned NumResults = FromWidth / ToWidth;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2647</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2647</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2648</td>
    <td class="codeLine">  SmallVector<Value *> Results(NumResults);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2648</td>
    <td class="codeLine">  SmallVector<Value *> Results(NumResults);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2649</td>
    <td class="codeLine">  Results[0] = Vec;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2649</td>
    <td class="codeLine">  Results[0] = Vec;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2650</td>
    <td class="codeLine">  unsigned Length = length(VecTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2650</td>
    <td class="codeLine">  unsigned Length = length(VecTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2651</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2651</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2652</td>
    <td class="codeLine">  // Do it by splitting in half, since those operations correspond to deal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2652</td>
    <td class="codeLine">  // Do it by splitting in half, since those operations correspond to deal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2653</td>
    <td class="codeLine">  // instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2653</td>
    <td class="codeLine">  // instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2654</td>
    <td class="codeLine">  auto splitInHalf = [&](unsigned Begin, unsigned End, auto splitFunc) -> void {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2654</td>
    <td class="codeLine">  auto splitInHalf = [&](unsigned Begin, unsigned End, auto splitFunc) -> void {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2655</td>
    <td class="codeLine">    // Take V = Results[Begin], split it in L, H.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2655</td>
    <td class="codeLine">    // Take V = Results[Begin], split it in L, H.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2656</td>
    <td class="codeLine">    // Store Results[Begin] = L, Results[(Begin+End)/2] = H</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2656</td>
    <td class="codeLine">    // Store Results[Begin] = L, Results[(Begin+End)/2] = H</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2657</td>
    <td class="codeLine">    // Call itself recursively split(Begin, Half), split(Half+1, End)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2657</td>
    <td class="codeLine">    // Call itself recursively split(Begin, Half), split(Half+1, End)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2658</td>
    <td class="codeLine">    if (Begin + 1 == End)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2658</td>
    <td class="codeLine">    if (Begin + 1 == End)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2659</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2659</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2660</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2660</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2661</td>
    <td class="codeLine">    Value *Val = Results[Begin];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2661</td>
    <td class="codeLine">    Value *Val = Results[Begin];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2662</td>
    <td class="codeLine">    unsigned Width = Val->getType()->getScalarSizeInBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2662</td>
    <td class="codeLine">    unsigned Width = Val->getType()->getScalarSizeInBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2663</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2663</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2664</td>
    <td class="codeLine">    auto *VTy = VectorType::get(getIntTy(Width / 2), 2 * Length, false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2664</td>
    <td class="codeLine">    auto *VTy = VectorType::get(getIntTy(Width / 2), 2 * Length, false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2665</td>
    <td class="codeLine">    Value *VVal = Builder.CreateBitCast(Val, VTy, "cst");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2665</td>
    <td class="codeLine">    Value *VVal = Builder.CreateBitCast(Val, VTy, "cst");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2666</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2666</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2667</td>
    <td class="codeLine">    Value *Res = vdeal(Builder, sublo(Builder, VVal), subhi(Builder, VVal));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2667</td>
    <td class="codeLine">    Value *Res = vdeal(Builder, sublo(Builder, VVal), subhi(Builder, VVal));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2668</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2668</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2669</td>
    <td class="codeLine">    unsigned Half = (Begin + End) / 2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2669</td>
    <td class="codeLine">    unsigned Half = (Begin + End) / 2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2670</td>
    <td class="codeLine">    Results[Begin] = sublo(Builder, Res);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2670</td>
    <td class="codeLine">    Results[Begin] = sublo(Builder, Res);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2671</td>
    <td class="codeLine">    Results[Half] = subhi(Builder, Res);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2671</td>
    <td class="codeLine">    Results[Half] = subhi(Builder, Res);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2672</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2672</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2673</td>
    <td class="codeLine">    splitFunc(Begin, Half, splitFunc);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2673</td>
    <td class="codeLine">    splitFunc(Begin, Half, splitFunc);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2674</td>
    <td class="codeLine">    splitFunc(Half, End, splitFunc);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2674</td>
    <td class="codeLine">    splitFunc(Half, End, splitFunc);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2675</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2675</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2676</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2676</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2677</td>
    <td class="codeLine">  splitInHalf(0, NumResults, splitInHalf);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2677</td>
    <td class="codeLine">  splitInHalf(0, NumResults, splitInHalf);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2678</td>
    <td class="codeLine">  return Results;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2678</td>
    <td class="codeLine">  return Results;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2679</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2679</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2680</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2680</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2681</td>
    <td class="codeLine">auto HexagonVectorCombine::joinVectorElements(IRBuilderBase &Builder,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2681</td>
    <td class="codeLine">auto HexagonVectorCombine::joinVectorElements(IRBuilderBase &Builder,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2682</td>
    <td class="codeLine">                                              ArrayRef<Value *> Values,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2682</td>
    <td class="codeLine">                                              ArrayRef<Value *> Values,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2683</td>
    <td class="codeLine">                                              VectorType *ToType) const</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2683</td>
    <td class="codeLine">                                              VectorType *ToType) const</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2684</td>
    <td class="codeLine">    -> Value * {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2684</td>
    <td class="codeLine">    -> Value * {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2685</td>
    <td class="codeLine">  assert(ToType->getElementType()->isIntegerTy());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2685</td>
    <td class="codeLine">  assert(ToType->getElementType()->isIntegerTy());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2686</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2686</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2687</td>
    <td class="codeLine">  // If the list of values does not have power-of-2 elements, append copies</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2687</td>
    <td class="codeLine">  // If the list of values does not have power-of-2 elements, append copies</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2688</td>
    <td class="codeLine">  // of the sign bit to it, to make the size be 2^n.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2688</td>
    <td class="codeLine">  // of the sign bit to it, to make the size be 2^n.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2689</td>
    <td class="codeLine">  // The reason for this is that the values will be joined in pairs, because</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2689</td>
    <td class="codeLine">  // The reason for this is that the values will be joined in pairs, because</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2690</td>
    <td class="codeLine">  // otherwise the shuffles will result in convoluted code. With pairwise</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2690</td>
    <td class="codeLine">  // otherwise the shuffles will result in convoluted code. With pairwise</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2691</td>
    <td class="codeLine">  // joins, the shuffles will hopefully be folded into a perfect shuffle.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2691</td>
    <td class="codeLine">  // joins, the shuffles will hopefully be folded into a perfect shuffle.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2692</td>
    <td class="codeLine">  // The output will need to be sign-extended to a type with element width</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2692</td>
    <td class="codeLine">  // The output will need to be sign-extended to a type with element width</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2693</td>
    <td class="codeLine">  // being a power-of-2 anyways.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2693</td>
    <td class="codeLine">  // being a power-of-2 anyways.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2694</td>
    <td class="codeLine">  SmallVector<Value *> Inputs(Values.begin(), Values.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2694</td>
    <td class="codeLine">  SmallVector<Value *> Inputs(Values.begin(), Values.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2695</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2695</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2696</td>
    <td class="codeLine">  unsigned ToWidth = ToType->getScalarSizeInBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2696</td>
    <td class="codeLine">  unsigned ToWidth = ToType->getScalarSizeInBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2697</td>
    <td class="codeLine">  unsigned Width = Inputs.front()->getType()->getScalarSizeInBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2697</td>
    <td class="codeLine">  unsigned Width = Inputs.front()->getType()->getScalarSizeInBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2698</td>
    <td class="codeLine">  assert(Width <= ToWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2698</td>
    <td class="codeLine">  assert(Width <= ToWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2699</td>
    <td class="codeLine">  assert(isPowerOf2_32(Width) && isPowerOf2_32(ToWidth));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2699</td>
    <td class="codeLine">  assert(isPowerOf2_32(Width) && isPowerOf2_32(ToWidth));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2700</td>
    <td class="codeLine">  unsigned Length = length(Inputs.front()->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2700</td>
    <td class="codeLine">  unsigned Length = length(Inputs.front()->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2701</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2701</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2702</td>
    <td class="codeLine">  unsigned NeedInputs = ToWidth / Width;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2702</td>
    <td class="codeLine">  unsigned NeedInputs = ToWidth / Width;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2703</td>
    <td class="codeLine">  if (Inputs.size() != NeedInputs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2703</td>
    <td class="codeLine">  if (Inputs.size() != NeedInputs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2704</td>
    <td class="codeLine">    // Having too many inputs is ok: drop the high bits (usual wrap-around).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2704</td>
    <td class="codeLine">    // Having too many inputs is ok: drop the high bits (usual wrap-around).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2705</td>
    <td class="codeLine">    // If there are too few, fill them with the sign bit.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2705</td>
    <td class="codeLine">    // If there are too few, fill them with the sign bit.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2706</td>
    <td class="codeLine">    Value *Last = Inputs.back();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2706</td>
    <td class="codeLine">    Value *Last = Inputs.back();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2707</td>
    <td class="codeLine">    Value *Sign = Builder.CreateAShr(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2707</td>
    <td class="codeLine">    Value *Sign = Builder.CreateAShr(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2708</td>
    <td class="codeLine">        Last, getConstSplat(Last->getType(), Width - 1), "asr");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2708</td>
    <td class="codeLine">        Last, getConstSplat(Last->getType(), Width - 1), "asr");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2709</td>
    <td class="codeLine">    Inputs.resize(NeedInputs, Sign);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2709</td>
    <td class="codeLine">    Inputs.resize(NeedInputs, Sign);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2710</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2710</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2711</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2711</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2712</td>
    <td class="codeLine">  while (Inputs.size() > 1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2712</td>
    <td class="codeLine">  while (Inputs.size() > 1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2713</td>
    <td class="codeLine">    Width *= 2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2713</td>
    <td class="codeLine">    Width *= 2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2714</td>
    <td class="codeLine">    auto *VTy = VectorType::get(getIntTy(Width), Length, false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2714</td>
    <td class="codeLine">    auto *VTy = VectorType::get(getIntTy(Width), Length, false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2715</td>
    <td class="codeLine">    for (int i = 0, e = Inputs.size(); i < e; i += 2) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2715</td>
    <td class="codeLine">    for (int i = 0, e = Inputs.size(); i < e; i += 2) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2716</td>
    <td class="codeLine">      Value *Res = vshuff(Builder, Inputs[i], Inputs[i + 1]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2716</td>
    <td class="codeLine">      Value *Res = vshuff(Builder, Inputs[i], Inputs[i + 1]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2717</td>
    <td class="codeLine">      Inputs[i / 2] = Builder.CreateBitCast(Res, VTy, "cst");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2717</td>
    <td class="codeLine">      Inputs[i / 2] = Builder.CreateBitCast(Res, VTy, "cst");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2718</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2718</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2719</td>
    <td class="codeLine">    Inputs.resize(Inputs.size() / 2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2719</td>
    <td class="codeLine">    Inputs.resize(Inputs.size() / 2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2720</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2720</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2721</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2721</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2722</td>
    <td class="codeLine">  assert(Inputs.front()->getType() == ToType);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2722</td>
    <td class="codeLine">  assert(Inputs.front()->getType() == ToType);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2723</td>
    <td class="codeLine">  return Inputs.front();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2723</td>
    <td class="codeLine">  return Inputs.front();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2724</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2724</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2725</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2725</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2726</td>
    <td class="codeLine">auto HexagonVectorCombine::calculatePointerDifference(Value *Ptr0,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2726</td>
    <td class="codeLine">auto HexagonVectorCombine::calculatePointerDifference(Value *Ptr0,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2727</td>
    <td class="codeLine">                                                      Value *Ptr1) const</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2727</td>
    <td class="codeLine">                                                      Value *Ptr1) const</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2728</td>
    <td class="codeLine">    -> std::optional<int> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2728</td>
    <td class="codeLine">    -> std::optional<int> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2729</td>
    <td class="codeLine">  // Try SCEV first.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2729</td>
    <td class="codeLine">  // Try SCEV first.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2730</td>
    <td class="codeLine">  const SCEV *Scev0 = SE.getSCEV(Ptr0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2730</td>
    <td class="codeLine">  const SCEV *Scev0 = SE.getSCEV(Ptr0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2731</td>
    <td class="codeLine">  const SCEV *Scev1 = SE.getSCEV(Ptr1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2731</td>
    <td class="codeLine">  const SCEV *Scev1 = SE.getSCEV(Ptr1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2732</td>
    <td class="codeLine">  const SCEV *ScevDiff = SE.getMinusSCEV(Scev0, Scev1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2732</td>
    <td class="codeLine">  const SCEV *ScevDiff = SE.getMinusSCEV(Scev0, Scev1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2733</td>
    <td class="codeLine">  if (auto *Const = dyn_cast<SCEVConstant>(ScevDiff)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2733</td>
    <td class="codeLine">  if (auto *Const = dyn_cast<SCEVConstant>(ScevDiff)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2734</td>
    <td class="codeLine">    APInt V = Const->getAPInt();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2734</td>
    <td class="codeLine">    APInt V = Const->getAPInt();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2735</td>
    <td class="codeLine">    if (V.isSignedIntN(8 * sizeof(int)))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2735</td>
    <td class="codeLine">    if (V.isSignedIntN(8 * sizeof(int)))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2736</td>
    <td class="codeLine">      return static_cast<int>(V.getSExtValue());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2736</td>
    <td class="codeLine">      return static_cast<int>(V.getSExtValue());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2737</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2737</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2738</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2738</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2739</td>
    <td class="codeLine">  struct Builder : IRBuilder<> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2739</td>
    <td class="codeLine">  struct Builder : IRBuilder<> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2740</td>
    <td class="codeLine">    Builder(BasicBlock *B) : IRBuilder<>(B->getTerminator()) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2740</td>
    <td class="codeLine">    Builder(BasicBlock *B) : IRBuilder<>(B->getTerminator()) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2741</td>
    <td class="codeLine">    ~Builder() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2741</td>
    <td class="codeLine">    ~Builder() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2742</td>
    <td class="codeLine">      for (Instruction *I : llvm::reverse(ToErase))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2742</td>
    <td class="codeLine">      for (Instruction *I : llvm::reverse(ToErase))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2743</td>
    <td class="codeLine">        I->eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2743</td>
    <td class="codeLine">        I->eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2744</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2744</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2745</td>
    <td class="codeLine">    SmallVector<Instruction *, 8> ToErase;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2745</td>
    <td class="codeLine">    SmallVector<Instruction *, 8> ToErase;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2746</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2746</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2747</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2747</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2748</td>
    <td class="codeLine">#define CallBuilder(B, F)                                                      \</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2748</td>
    <td class="codeLine">#define CallBuilder(B, F)                                                      \</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2749</td>
    <td class="codeLine">  [&](auto &B_) {                                                              \</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2749</td>
    <td class="codeLine">  [&](auto &B_) {                                                              \</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2750</td>
    <td class="codeLine">    Value *V = B_.F;                                                           \</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2750</td>
    <td class="codeLine">    Value *V = B_.F;                                                           \</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2751</td>
    <td class="codeLine">    if (auto *I = dyn_cast<Instruction>(V))                                    \</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2751</td>
    <td class="codeLine">    if (auto *I = dyn_cast<Instruction>(V))                                    \</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2752</td>
    <td class="codeLine">      B_.ToErase.push_back(I);                                                 \</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2752</td>
    <td class="codeLine">      B_.ToErase.push_back(I);                                                 \</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2753</td>
    <td class="codeLine">    return V;                                                                  \</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2753</td>
    <td class="codeLine">    return V;                                                                  \</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2754</td>
    <td class="codeLine">  }(B)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2754</td>
    <td class="codeLine">  }(B)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2755</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2755</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2756</td>
    <td class="codeLine">  auto Simplify = [this](Value *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2756</td>
    <td class="codeLine">  auto Simplify = [this](Value *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2757</td>
    <td class="codeLine">    if (Value *S = simplify(V))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2757</td>
    <td class="codeLine">    if (Value *S = simplify(V))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2758</td>
    <td class="codeLine">      return S;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2758</td>
    <td class="codeLine">      return S;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2759</td>
    <td class="codeLine">    return V;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2759</td>
    <td class="codeLine">    return V;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2760</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2760</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2761</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2761</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2762</td>
    <td class="codeLine">  auto StripBitCast = [](Value *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2762</td>
    <td class="codeLine">  auto StripBitCast = [](Value *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2763</td>
    <td class="codeLine">    while (auto *C = dyn_cast<BitCastInst>(V))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2763</td>
    <td class="codeLine">    while (auto *C = dyn_cast<BitCastInst>(V))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2764</td>
    <td class="codeLine">      V = C->getOperand(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2764</td>
    <td class="codeLine">      V = C->getOperand(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2765</td>
    <td class="codeLine">    return V;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2765</td>
    <td class="codeLine">    return V;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2766</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2766</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2767</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2767</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2768</td>
    <td class="codeLine">  Ptr0 = StripBitCast(Ptr0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2768</td>
    <td class="codeLine">  Ptr0 = StripBitCast(Ptr0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2769</td>
    <td class="codeLine">  Ptr1 = StripBitCast(Ptr1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2769</td>
    <td class="codeLine">  Ptr1 = StripBitCast(Ptr1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2770</td>
    <td class="codeLine">  if (!isa<GetElementPtrInst>(Ptr0) || !isa<GetElementPtrInst>(Ptr1))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2770</td>
    <td class="codeLine">  if (!isa<GetElementPtrInst>(Ptr0) || !isa<GetElementPtrInst>(Ptr1))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2771</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2771</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2772</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2772</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2773</td>
    <td class="codeLine">  auto *Gep0 = cast<GetElementPtrInst>(Ptr0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2773</td>
    <td class="codeLine">  auto *Gep0 = cast<GetElementPtrInst>(Ptr0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2774</td>
    <td class="codeLine">  auto *Gep1 = cast<GetElementPtrInst>(Ptr1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2774</td>
    <td class="codeLine">  auto *Gep1 = cast<GetElementPtrInst>(Ptr1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2775</td>
    <td class="codeLine">  if (Gep0->getPointerOperand() != Gep1->getPointerOperand())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2775</td>
    <td class="codeLine">  if (Gep0->getPointerOperand() != Gep1->getPointerOperand())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2776</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2776</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2777</td>
    <td class="codeLine">  if (Gep0->getSourceElementType() != Gep1->getSourceElementType())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2777</td>
    <td class="codeLine">  if (Gep0->getSourceElementType() != Gep1->getSourceElementType())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2778</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2778</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2779</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2779</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2780</td>
    <td class="codeLine">  Builder B(Gep0->getParent());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2780</td>
    <td class="codeLine">  Builder B(Gep0->getParent());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2781</td>
    <td class="codeLine">  int Scale = getSizeOf(Gep0->getSourceElementType(), Alloc);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2781</td>
    <td class="codeLine">  int Scale = getSizeOf(Gep0->getSourceElementType(), Alloc);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2782</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2782</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2783</td>
    <td class="codeLine">  // FIXME: for now only check GEPs with a single index.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2783</td>
    <td class="codeLine">  // FIXME: for now only check GEPs with a single index.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2784</td>
    <td class="codeLine">  if (Gep0->getNumOperands() != 2 || Gep1->getNumOperands() != 2)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2784</td>
    <td class="codeLine">  if (Gep0->getNumOperands() != 2 || Gep1->getNumOperands() != 2)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2785</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2785</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2786</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2786</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2787</td>
    <td class="codeLine">  Value *Idx0 = Gep0->getOperand(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2787</td>
    <td class="codeLine">  Value *Idx0 = Gep0->getOperand(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2788</td>
    <td class="codeLine">  Value *Idx1 = Gep1->getOperand(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2788</td>
    <td class="codeLine">  Value *Idx1 = Gep1->getOperand(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2789</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2789</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2790</td>
    <td class="codeLine">  // First, try to simplify the subtraction directly.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2790</td>
    <td class="codeLine">  // First, try to simplify the subtraction directly.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2791</td>
    <td class="codeLine">  if (auto *Diff = dyn_cast<ConstantInt>(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2791</td>
    <td class="codeLine">  if (auto *Diff = dyn_cast<ConstantInt>(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2792</td>
    <td class="codeLine">          Simplify(CallBuilder(B, CreateSub(Idx0, Idx1)))))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2792</td>
    <td class="codeLine">          Simplify(CallBuilder(B, CreateSub(Idx0, Idx1)))))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2793</td>
    <td class="codeLine">    return Diff->getSExtValue() * Scale;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2793</td>
    <td class="codeLine">    return Diff->getSExtValue() * Scale;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2794</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2794</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2795</td>
    <td class="codeLine">  KnownBits Known0 = getKnownBits(Idx0, Gep0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2795</td>
    <td class="codeLine">  KnownBits Known0 = getKnownBits(Idx0, Gep0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2796</td>
    <td class="codeLine">  KnownBits Known1 = getKnownBits(Idx1, Gep1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2796</td>
    <td class="codeLine">  KnownBits Known1 = getKnownBits(Idx1, Gep1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2797</td>
    <td class="codeLine">  APInt Unknown = ~(Known0.Zero | Known0.One) | ~(Known1.Zero | Known1.One);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2797</td>
    <td class="codeLine">  APInt Unknown = ~(Known0.Zero | Known0.One) | ~(Known1.Zero | Known1.One);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2798</td>
    <td class="codeLine">  if (Unknown.isAllOnes())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2798</td>
    <td class="codeLine">  if (Unknown.isAllOnes())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2799</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2799</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2800</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2800</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2801</td>
    <td class="codeLine">  Value *MaskU = ConstantInt::get(Idx0->getType(), Unknown);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2801</td>
    <td class="codeLine">  Value *MaskU = ConstantInt::get(Idx0->getType(), Unknown);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2802</td>
    <td class="codeLine">  Value *AndU0 = Simplify(CallBuilder(B, CreateAnd(Idx0, MaskU)));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2802</td>
    <td class="codeLine">  Value *AndU0 = Simplify(CallBuilder(B, CreateAnd(Idx0, MaskU)));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2803</td>
    <td class="codeLine">  Value *AndU1 = Simplify(CallBuilder(B, CreateAnd(Idx1, MaskU)));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2803</td>
    <td class="codeLine">  Value *AndU1 = Simplify(CallBuilder(B, CreateAnd(Idx1, MaskU)));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2804</td>
    <td class="codeLine">  Value *SubU = Simplify(CallBuilder(B, CreateSub(AndU0, AndU1)));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2804</td>
    <td class="codeLine">  Value *SubU = Simplify(CallBuilder(B, CreateSub(AndU0, AndU1)));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2805</td>
    <td class="codeLine">  int Diff0 = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2805</td>
    <td class="codeLine">  int Diff0 = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2806</td>
    <td class="codeLine">  if (auto *C = dyn_cast<ConstantInt>(SubU)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2806</td>
    <td class="codeLine">  if (auto *C = dyn_cast<ConstantInt>(SubU)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2807</td>
    <td class="codeLine">    Diff0 = C->getSExtValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2807</td>
    <td class="codeLine">    Diff0 = C->getSExtValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2808</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2808</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2809</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2809</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2810</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2810</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2811</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2811</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2812</td>
    <td class="codeLine">  Value *MaskK = ConstantInt::get(MaskU->getType(), ~Unknown);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2812</td>
    <td class="codeLine">  Value *MaskK = ConstantInt::get(MaskU->getType(), ~Unknown);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2813</td>
    <td class="codeLine">  Value *AndK0 = Simplify(CallBuilder(B, CreateAnd(Idx0, MaskK)));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2813</td>
    <td class="codeLine">  Value *AndK0 = Simplify(CallBuilder(B, CreateAnd(Idx0, MaskK)));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2814</td>
    <td class="codeLine">  Value *AndK1 = Simplify(CallBuilder(B, CreateAnd(Idx1, MaskK)));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2814</td>
    <td class="codeLine">  Value *AndK1 = Simplify(CallBuilder(B, CreateAnd(Idx1, MaskK)));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2815</td>
    <td class="codeLine">  Value *SubK = Simplify(CallBuilder(B, CreateSub(AndK0, AndK1)));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2815</td>
    <td class="codeLine">  Value *SubK = Simplify(CallBuilder(B, CreateSub(AndK0, AndK1)));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2816</td>
    <td class="codeLine">  int Diff1 = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2816</td>
    <td class="codeLine">  int Diff1 = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2817</td>
    <td class="codeLine">  if (auto *C = dyn_cast<ConstantInt>(SubK)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2817</td>
    <td class="codeLine">  if (auto *C = dyn_cast<ConstantInt>(SubK)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2818</td>
    <td class="codeLine">    Diff1 = C->getSExtValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2818</td>
    <td class="codeLine">    Diff1 = C->getSExtValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2819</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2819</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2820</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2820</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2821</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2821</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2822</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2822</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2823</td>
    <td class="codeLine">  return (Diff0 + Diff1) * Scale;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2823</td>
    <td class="codeLine">  return (Diff0 + Diff1) * Scale;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2824</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2824</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2825</td>
    <td class="codeLine">#undef CallBuilder</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2825</td>
    <td class="codeLine">#undef CallBuilder</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2826</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2826</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2827</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2827</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2828</td>
    <td class="codeLine">auto HexagonVectorCombine::getNumSignificantBits(const Value *V,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2828</td>
    <td class="codeLine">auto HexagonVectorCombine::getNumSignificantBits(const Value *V,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2829</td>
    <td class="codeLine">                                                 const Instruction *CtxI) const</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2829</td>
    <td class="codeLine">                                                 const Instruction *CtxI) const</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2830</td>
    <td class="codeLine">    -> unsigned {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2830</td>
    <td class="codeLine">    -> unsigned {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2831</td>
    <td class="codeLine">  return ComputeMaxSignificantBits(V, DL, /*Depth=*/0, &AC, CtxI, &DT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2831</td>
    <td class="codeLine">  return ComputeMaxSignificantBits(V, DL, /*Depth=*/0, &AC, CtxI, &DT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2832</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2832</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2833</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2833</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2834</td>
    <td class="codeLine">auto HexagonVectorCombine::getKnownBits(const Value *V,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2834</td>
    <td class="codeLine">auto HexagonVectorCombine::getKnownBits(const Value *V,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2835</td>
    <td class="codeLine">                                        const Instruction *CtxI) const</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2835</td>
    <td class="codeLine">                                        const Instruction *CtxI) const</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2836</td>
    <td class="codeLine">    -> KnownBits {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2836</td>
    <td class="codeLine">    -> KnownBits {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2837</td>
    <td class="codeLine">  return computeKnownBits(V, DL, /*Depth=*/0, &AC, CtxI, &DT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2837</td>
    <td class="codeLine">  return computeKnownBits(V, DL, /*Depth=*/0, &AC, CtxI, &DT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2838</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2838</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2839</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2839</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2840</td>
    <td class="codeLine">auto HexagonVectorCombine::isSafeToClone(const Instruction &In) const -> bool {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2840</td>
    <td class="codeLine">auto HexagonVectorCombine::isSafeToClone(const Instruction &In) const -> bool {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2841</td>
    <td class="codeLine">  if (In.mayHaveSideEffects() || In.isAtomic() || In.isVolatile() ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2841</td>
    <td class="codeLine">  if (In.mayHaveSideEffects() || In.isAtomic() || In.isVolatile() ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2842</td>
    <td class="codeLine">      In.isFenceLike() || In.mayReadOrWriteMemory()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2842</td>
    <td class="codeLine">      In.isFenceLike() || In.mayReadOrWriteMemory()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2843</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2843</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2844</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2844</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2845</td>
    <td class="codeLine">  if (isa<CallBase>(In) || isa<AllocaInst>(In))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2845</td>
    <td class="codeLine">  if (isa<CallBase>(In) || isa<AllocaInst>(In))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2846</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2846</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2847</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2847</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2848</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2848</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2849</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2849</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2850</td>
    <td class="codeLine">template <typename T></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2850</td>
    <td class="codeLine">template <typename T></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2851</td>
    <td class="codeLine">auto HexagonVectorCombine::isSafeToMoveBeforeInBB(const Instruction &In,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2851</td>
    <td class="codeLine">auto HexagonVectorCombine::isSafeToMoveBeforeInBB(const Instruction &In,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2852</td>
    <td class="codeLine">                                                  BasicBlock::const_iterator To,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2852</td>
    <td class="codeLine">                                                  BasicBlock::const_iterator To,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2853</td>
    <td class="codeLine">                                                  const T &IgnoreInsts) const</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2853</td>
    <td class="codeLine">                                                  const T &IgnoreInsts) const</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2854</td>
    <td class="codeLine">    -> bool {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2854</td>
    <td class="codeLine">    -> bool {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2855</td>
    <td class="codeLine">  auto getLocOrNone =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2855</td>
    <td class="codeLine">  auto getLocOrNone =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2856</td>
    <td class="codeLine">      [this](const Instruction &I) -> std::optional<MemoryLocation> {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2856</td>
    <td class="codeLine">      [this](const Instruction &I) -> std::optional<MemoryLocation> {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2857</td>
    <td class="codeLine">    if (const auto *II = dyn_cast<IntrinsicInst>(&I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2857</td>
    <td class="codeLine">    if (const auto *II = dyn_cast<IntrinsicInst>(&I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2858</td>
    <td class="codeLine">      switch (II->getIntrinsicID()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2858</td>
    <td class="codeLine">      switch (II->getIntrinsicID()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2859</td>
    <td class="codeLine">      case Intrinsic::masked_load:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2859</td>
    <td class="codeLine">      case Intrinsic::masked_load:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2860</td>
    <td class="codeLine">        return MemoryLocation::getForArgument(II, 0, TLI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2860</td>
    <td class="codeLine">        return MemoryLocation::getForArgument(II, 0, TLI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2861</td>
    <td class="codeLine">      case Intrinsic::masked_store:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2861</td>
    <td class="codeLine">      case Intrinsic::masked_store:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2862</td>
    <td class="codeLine">        return MemoryLocation::getForArgument(II, 1, TLI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2862</td>
    <td class="codeLine">        return MemoryLocation::getForArgument(II, 1, TLI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2863</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2863</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2864</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2864</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2865</td>
    <td class="codeLine">    return MemoryLocation::getOrNone(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2865</td>
    <td class="codeLine">    return MemoryLocation::getOrNone(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2866</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2866</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2867</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2867</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2868</td>
    <td class="codeLine">  // The source and the destination must be in the same basic block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2868</td>
    <td class="codeLine">  // The source and the destination must be in the same basic block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2869</td>
    <td class="codeLine">  const BasicBlock &Block = *In.getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2869</td>
    <td class="codeLine">  const BasicBlock &Block = *In.getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2870</td>
    <td class="codeLine">  assert(Block.begin() == To || Block.end() == To || To->getParent() == &Block);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2870</td>
    <td class="codeLine">  assert(Block.begin() == To || Block.end() == To || To->getParent() == &Block);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2871</td>
    <td class="codeLine">  // No PHIs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2871</td>
    <td class="codeLine">  // No PHIs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2872</td>
    <td class="codeLine">  if (isa<PHINode>(In) || (To != Block.end() && isa<PHINode>(*To)))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2872</td>
    <td class="codeLine">  if (isa<PHINode>(In) || (To != Block.end() && isa<PHINode>(*To)))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2873</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2873</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2874</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2874</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2875</td>
    <td class="codeLine">  if (!mayHaveNonDefUseDependency(In))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2875</td>
    <td class="codeLine">  if (!mayHaveNonDefUseDependency(In))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2876</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2876</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2877</td>
    <td class="codeLine">  bool MayWrite = In.mayWriteToMemory();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2877</td>
    <td class="codeLine">  bool MayWrite = In.mayWriteToMemory();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2878</td>
    <td class="codeLine">  auto MaybeLoc = getLocOrNone(In);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2878</td>
    <td class="codeLine">  auto MaybeLoc = getLocOrNone(In);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2879</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2879</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2880</td>
    <td class="codeLine">  auto From = In.getIterator();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2880</td>
    <td class="codeLine">  auto From = In.getIterator();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2881</td>
    <td class="codeLine">  if (From == To)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2881</td>
    <td class="codeLine">  if (From == To)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2882</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2882</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2883</td>
    <td class="codeLine">  bool MoveUp = (To != Block.end() && To->comesBefore(&In));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2883</td>
    <td class="codeLine">  bool MoveUp = (To != Block.end() && To->comesBefore(&In));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2884</td>
    <td class="codeLine">  auto Range =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2884</td>
    <td class="codeLine">  auto Range =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2885</td>
    <td class="codeLine">      MoveUp ? std::make_pair(To, From) : std::make_pair(std::next(From), To);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2885</td>
    <td class="codeLine">      MoveUp ? std::make_pair(To, From) : std::make_pair(std::next(From), To);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2886</td>
    <td class="codeLine">  for (auto It = Range.first; It != Range.second; ++It) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2886</td>
    <td class="codeLine">  for (auto It = Range.first; It != Range.second; ++It) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2887</td>
    <td class="codeLine">    const Instruction &I = *It;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2887</td>
    <td class="codeLine">    const Instruction &I = *It;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2888</td>
    <td class="codeLine">    if (llvm::is_contained(IgnoreInsts, &I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2888</td>
    <td class="codeLine">    if (llvm::is_contained(IgnoreInsts, &I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2889</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2889</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2890</td>
    <td class="codeLine">    // assume intrinsic can be ignored</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2890</td>
    <td class="codeLine">    // assume intrinsic can be ignored</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2891</td>
    <td class="codeLine">    if (auto *II = dyn_cast<IntrinsicInst>(&I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2891</td>
    <td class="codeLine">    if (auto *II = dyn_cast<IntrinsicInst>(&I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2892</td>
    <td class="codeLine">      if (II->getIntrinsicID() == Intrinsic::assume)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2892</td>
    <td class="codeLine">      if (II->getIntrinsicID() == Intrinsic::assume)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2893</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2893</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2894</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2894</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2895</td>
    <td class="codeLine">    // Parts based on isSafeToMoveBefore from CoveMoverUtils.cpp.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2895</td>
    <td class="codeLine">    // Parts based on isSafeToMoveBefore from CoveMoverUtils.cpp.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2896</td>
    <td class="codeLine">    if (I.mayThrow())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2896</td>
    <td class="codeLine">    if (I.mayThrow())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2897</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2897</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2898</td>
    <td class="codeLine">    if (auto *CB = dyn_cast<CallBase>(&I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2898</td>
    <td class="codeLine">    if (auto *CB = dyn_cast<CallBase>(&I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2899</td>
    <td class="codeLine">      if (!CB->hasFnAttr(Attribute::WillReturn))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2899</td>
    <td class="codeLine">      if (!CB->hasFnAttr(Attribute::WillReturn))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2900</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2900</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2901</td>
    <td class="codeLine">      if (!CB->hasFnAttr(Attribute::NoSync))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2901</td>
    <td class="codeLine">      if (!CB->hasFnAttr(Attribute::NoSync))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2902</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2902</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2903</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2903</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2904</td>
    <td class="codeLine">    if (I.mayReadOrWriteMemory()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2904</td>
    <td class="codeLine">    if (I.mayReadOrWriteMemory()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2905</td>
    <td class="codeLine">      auto MaybeLocI = getLocOrNone(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2905</td>
    <td class="codeLine">      auto MaybeLocI = getLocOrNone(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2906</td>
    <td class="codeLine">      if (MayWrite || I.mayWriteToMemory()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2906</td>
    <td class="codeLine">      if (MayWrite || I.mayWriteToMemory()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2907</td>
    <td class="codeLine">        if (!MaybeLoc || !MaybeLocI)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2907</td>
    <td class="codeLine">        if (!MaybeLoc || !MaybeLocI)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2908</td>
    <td class="codeLine">          return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2908</td>
    <td class="codeLine">          return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2909</td>
    <td class="codeLine">        if (!AA.isNoAlias(*MaybeLoc, *MaybeLocI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2909</td>
    <td class="codeLine">        if (!AA.isNoAlias(*MaybeLoc, *MaybeLocI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2910</td>
    <td class="codeLine">          return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2910</td>
    <td class="codeLine">          return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2911</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2911</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2912</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2912</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2913</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2913</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2914</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2914</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2915</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2915</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2916</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2916</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2917</td>
    <td class="codeLine">auto HexagonVectorCombine::isByteVecTy(Type *Ty) const -> bool {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2917</td>
    <td class="codeLine">auto HexagonVectorCombine::isByteVecTy(Type *Ty) const -> bool {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2918</td>
    <td class="codeLine">  if (auto *VecTy = dyn_cast<VectorType>(Ty))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2918</td>
    <td class="codeLine">  if (auto *VecTy = dyn_cast<VectorType>(Ty))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2919</td>
    <td class="codeLine">    return VecTy->getElementType() == getByteTy();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2919</td>
    <td class="codeLine">    return VecTy->getElementType() == getByteTy();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2920</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2920</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2921</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2921</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2922</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2922</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2923</td>
    <td class="codeLine">auto HexagonVectorCombine::getElementRange(IRBuilderBase &Builder, Value *Lo,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2923</td>
    <td class="codeLine">auto HexagonVectorCombine::getElementRange(IRBuilderBase &Builder, Value *Lo,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2924</td>
    <td class="codeLine">                                           Value *Hi, int Start,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2924</td>
    <td class="codeLine">                                           Value *Hi, int Start,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2925</td>
    <td class="codeLine">                                           int Length) const -> Value * {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2925</td>
    <td class="codeLine">                                           int Length) const -> Value * {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2926</td>
    <td class="codeLine">  assert(0 <= Start && size_t(Start + Length) < length(Lo) + length(Hi));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2926</td>
    <td class="codeLine">  assert(0 <= Start && size_t(Start + Length) < length(Lo) + length(Hi));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2927</td>
    <td class="codeLine">  SmallVector<int, 128> SMask(Length);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2927</td>
    <td class="codeLine">  SmallVector<int, 128> SMask(Length);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2928</td>
    <td class="codeLine">  std::iota(SMask.begin(), SMask.end(), Start);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2928</td>
    <td class="codeLine">  std::iota(SMask.begin(), SMask.end(), Start);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2929</td>
    <td class="codeLine">  return Builder.CreateShuffleVector(Lo, Hi, SMask, "shf");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2929</td>
    <td class="codeLine">  return Builder.CreateShuffleVector(Lo, Hi, SMask, "shf");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2930</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2930</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2931</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2931</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2932</td>
    <td class="codeLine">// Pass management.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2932</td>
    <td class="codeLine">// Pass management.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2933</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2933</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2934</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2934</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2935</td>
    <td class="codeLine">void initializeHexagonVectorCombineLegacyPass(PassRegistry &);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2935</td>
    <td class="codeLine">void initializeHexagonVectorCombineLegacyPass(PassRegistry &);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2936</td>
    <td class="codeLine">FunctionPass *createHexagonVectorCombineLegacyPass();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2936</td>
    <td class="codeLine">FunctionPass *createHexagonVectorCombineLegacyPass();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2937</td>
    <td class="codeLine">} // namespace llvm</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2937</td>
    <td class="codeLine">} // namespace llvm</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2938</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2938</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2939</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2939</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2940</td>
    <td class="codeLine">class HexagonVectorCombineLegacy : public FunctionPass {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2940</td>
    <td class="codeLine">class HexagonVectorCombineLegacy : public FunctionPass {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2941</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2941</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2942</td>
    <td class="codeLine">  static char ID;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2942</td>
    <td class="codeLine">  static char ID;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2943</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2943</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2944</td>
    <td class="codeLine">  HexagonVectorCombineLegacy() : FunctionPass(ID) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2944</td>
    <td class="codeLine">  HexagonVectorCombineLegacy() : FunctionPass(ID) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2945</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2945</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2946</td>
    <td class="codeLine">  StringRef getPassName() const override { return "Hexagon Vector Combine"; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2946</td>
    <td class="codeLine">  StringRef getPassName() const override { return "Hexagon Vector Combine"; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2947</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2947</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2948</td>
    <td class="codeLine">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2948</td>
    <td class="codeLine">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2949</td>
    <td class="codeLine">    AU.setPreservesCFG();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2949</td>
    <td class="codeLine">    AU.setPreservesCFG();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2950</td>
    <td class="codeLine">    AU.addRequired<AAResultsWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2950</td>
    <td class="codeLine">    AU.addRequired<AAResultsWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2951</td>
    <td class="codeLine">    AU.addRequired<AssumptionCacheTracker>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2951</td>
    <td class="codeLine">    AU.addRequired<AssumptionCacheTracker>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2952</td>
    <td class="codeLine">    AU.addRequired<DominatorTreeWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2952</td>
    <td class="codeLine">    AU.addRequired<DominatorTreeWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2953</td>
    <td class="codeLine">    AU.addRequired<ScalarEvolutionWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2953</td>
    <td class="codeLine">    AU.addRequired<ScalarEvolutionWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2954</td>
    <td class="codeLine">    AU.addRequired<TargetLibraryInfoWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2954</td>
    <td class="codeLine">    AU.addRequired<TargetLibraryInfoWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2955</td>
    <td class="codeLine">    AU.addRequired<TargetPassConfig>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2955</td>
    <td class="codeLine">    AU.addRequired<TargetPassConfig>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2956</td>
    <td class="codeLine">    FunctionPass::getAnalysisUsage(AU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2956</td>
    <td class="codeLine">    FunctionPass::getAnalysisUsage(AU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2957</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2957</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2958</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2958</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2959</td>
    <td class="codeLine">  bool runOnFunction(Function &F) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2959</td>
    <td class="codeLine">  bool runOnFunction(Function &F) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2960</td>
    <td class="codeLine">    if (skipFunction(F))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2960</td>
    <td class="codeLine">    if (skipFunction(F))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2961</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2961</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2962</td>
    <td class="codeLine">    AliasAnalysis &AA = getAnalysis<AAResultsWrapperPass>().getAAResults();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2962</td>
    <td class="codeLine">    AliasAnalysis &AA = getAnalysis<AAResultsWrapperPass>().getAAResults();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2963</td>
    <td class="codeLine">    AssumptionCache &AC =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2963</td>
    <td class="codeLine">    AssumptionCache &AC =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2964</td>
    <td class="codeLine">        getAnalysis<AssumptionCacheTracker>().getAssumptionCache(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2964</td>
    <td class="codeLine">        getAnalysis<AssumptionCacheTracker>().getAssumptionCache(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2965</td>
    <td class="codeLine">    DominatorTree &DT = getAnalysis<DominatorTreeWrapperPass>().getDomTree();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2965</td>
    <td class="codeLine">    DominatorTree &DT = getAnalysis<DominatorTreeWrapperPass>().getDomTree();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2966</td>
    <td class="codeLine">    ScalarEvolution &SE = getAnalysis<ScalarEvolutionWrapperPass>().getSE();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2966</td>
    <td class="codeLine">    ScalarEvolution &SE = getAnalysis<ScalarEvolutionWrapperPass>().getSE();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2967</td>
    <td class="codeLine">    TargetLibraryInfo &TLI =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2967</td>
    <td class="codeLine">    TargetLibraryInfo &TLI =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2968</td>
    <td class="codeLine">        getAnalysis<TargetLibraryInfoWrapperPass>().getTLI(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2968</td>
    <td class="codeLine">        getAnalysis<TargetLibraryInfoWrapperPass>().getTLI(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2969</td>
    <td class="codeLine">    auto &TM = getAnalysis<TargetPassConfig>().getTM<HexagonTargetMachine>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2969</td>
    <td class="codeLine">    auto &TM = getAnalysis<TargetPassConfig>().getTM<HexagonTargetMachine>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2970</td>
    <td class="codeLine">    HexagonVectorCombine HVC(F, AA, AC, DT, SE, TLI, TM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2970</td>
    <td class="codeLine">    HexagonVectorCombine HVC(F, AA, AC, DT, SE, TLI, TM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2971</td>
    <td class="codeLine">    return HVC.run();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2971</td>
    <td class="codeLine">    return HVC.run();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2972</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2972</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2973</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2973</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2974</td>
    <td class="codeLine">} // namespace</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2974</td>
    <td class="codeLine">} // namespace</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2975</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2975</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2976</td>
    <td class="codeLine">char HexagonVectorCombineLegacy::ID = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2976</td>
    <td class="codeLine">char HexagonVectorCombineLegacy::ID = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2977</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2977</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2978</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_BEGIN(HexagonVectorCombineLegacy, DEBUG_TYPE,</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2978</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_BEGIN(HexagonVectorCombineLegacy, DEBUG_TYPE,</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2979</td>
    <td class="codeLine">                      "Hexagon Vector Combine", false, false)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2979</td>
    <td class="codeLine">                      "Hexagon Vector Combine", false, false)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2980</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(AAResultsWrapperPass)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2980</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(AAResultsWrapperPass)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2981</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(AssumptionCacheTracker)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2981</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(AssumptionCacheTracker)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2982</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2982</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2983</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(ScalarEvolutionWrapperPass)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2983</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(ScalarEvolutionWrapperPass)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2984</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(TargetLibraryInfoWrapperPass)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2984</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(TargetLibraryInfoWrapperPass)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2985</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(TargetPassConfig)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2985</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(TargetPassConfig)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2986</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_END(HexagonVectorCombineLegacy, DEBUG_TYPE,</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">2986</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_END(HexagonVectorCombineLegacy, DEBUG_TYPE,</td>
    <td class="lineNumber">2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2987</td>
    <td class="codeLine">                    "Hexagon Vector Combine", false, false)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2987</td>
    <td class="codeLine">                    "Hexagon Vector Combine", false, false)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2988</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2988</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2989</td>
    <td class="codeLine">FunctionPass *llvm::createHexagonVectorCombineLegacyPass() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2989</td>
    <td class="codeLine">FunctionPass *llvm::createHexagonVectorCombineLegacyPass() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2990</td>
    <td class="codeLine">  return new HexagonVectorCombineLegacy();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2990</td>
    <td class="codeLine">  return new HexagonVectorCombineLegacy();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2991</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2991</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2992</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2992</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
</table>
    </div>
    <button id="myBtn" onclick="topFunction()" title="Go to top" type="button">Top</button>
    <script src="../Javascript/drop_down.js"></script>
    <script src="../Javascript/top_button.js"></script>
  </body>
</html>