<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>APInt.cpp</title>
    <link rel="stylesheet" href="../Style/style.css" />
  </head>
  <body>
    <div class="headerDiv">
      <h1>
        Code Coverage
      </h1>
      <p>
        Source file: /home/nikola/Desktop/llvm-project/llvm/lib/Support/APInt.cpp
      </p>
    </div>
    <button class="collapsible" type="button">Open Summary Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Summary Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line number</th>
    <th class="mainTh">Line</th>
    <th class="mainTh">Number of hits</th>
    <th class="mainTh">Tests that cover line</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="">//===-- APInt.cpp - Implement APInt class ---------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="">// This file implements a class to represent arbitrary precision integer</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="">// constant values and provide a variety of arithmetic operations on them.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="">#include "llvm/ADT/APInt.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="">#include "llvm/ADT/ArrayRef.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="">#include "llvm/ADT/FoldingSet.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="">#include "llvm/ADT/Hashing.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="">#include "llvm/ADT/SmallString.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="">#include "llvm/ADT/StringRef.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="">#include "llvm/ADT/bit.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="">#include "llvm/Config/llvm-config.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="">#include "llvm/Support/Alignment.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="">#include "llvm/Support/Debug.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="">#include "llvm/Support/ErrorHandling.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="">#include "llvm/Support/MathExtras.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="">#include "llvm/Support/raw_ostream.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="">#include <cmath></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="">#include <optional></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="">using namespace llvm;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="">#define DEBUG_TYPE "apint"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="">/// A utility function for allocating memory, checking for allocation failures,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="">/// and ensuring the contents are zeroed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="uncoveredLine">inline static uint64_t* getClearedMemory(unsigned numWords) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="uncoveredLine">  uint64_t *result = new uint64_t[numWords];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="uncoveredLine">  memset(result, 0, numWords * sizeof(uint64_t));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="uncoveredLine">  return result;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="">/// A utility function for allocating memory and checking for allocation</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="">/// failure.  The content is not zeroed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="uncoveredLine">inline static uint64_t* getMemory(unsigned numWords) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="uncoveredLine">  return new uint64_t[numWords];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="">/// A utility function that converts a character to a digit.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="coveredLine">inline static unsigned getDigit(char cdigit, uint8_t radix) {</td>
    <td>237</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="">  unsigned r;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="coveredLine">  if (radix == 16 || radix == 36) {</td>
    <td>237</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="uncoveredLine">    r = cdigit - '0';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="uncoveredLine">    if (r <= 9)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="uncoveredLine">      return r;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="uncoveredLine">    r = cdigit - 'A';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="uncoveredLine">    if (r <= radix - 11U)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="uncoveredLine">      return r + 10;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="uncoveredLine">    r = cdigit - 'a';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="uncoveredLine">    if (r <= radix - 11U)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="uncoveredLine">      return r + 10;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="uncoveredLine">    radix = 10;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="coveredLine">  r = cdigit - '0';</td>
    <td>237</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="coveredLine">  if (r < radix)</td>
    <td>237</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="coveredLine">    return r;</td>
    <td>237</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="uncoveredLine">  return UINT_MAX;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="uncoveredLine">void APInt::initSlowCase(uint64_t val, bool isSigned) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="uncoveredLine">  U.pVal = getClearedMemory(getNumWords());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="uncoveredLine">  U.pVal[0] = val;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="uncoveredLine">  if (isSigned && int64_t(val) < 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="uncoveredLine">    for (unsigned i = 1; i < getNumWords(); ++i)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="uncoveredLine">      U.pVal[i] = WORDTYPE_MAX;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="uncoveredLine">  clearUnusedBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="uncoveredLine">void APInt::initSlowCase(const APInt& that) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="uncoveredLine">  U.pVal = getMemory(getNumWords());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="uncoveredLine">  memcpy(U.pVal, that.U.pVal, getNumWords() * APINT_WORD_SIZE);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="uncoveredLine">void APInt::initFromArray(ArrayRef<uint64_t> bigVal) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="uncoveredLine">  assert(bigVal.data() && "Null pointer detected!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="uncoveredLine">  if (isSingleWord())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="uncoveredLine">    U.VAL = bigVal[0];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="">  else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="">    // Get memory, cleared to 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="uncoveredLine">    U.pVal = getClearedMemory(getNumWords());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="">    // Calculate the number of words to copy</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="uncoveredLine">    unsigned words = std::min<unsigned>(bigVal.size(), getNumWords());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="">    // Copy the words from bigVal to pVal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="uncoveredLine">    memcpy(U.pVal, bigVal.data(), words * APINT_WORD_SIZE);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="">  // Make sure unused high bits are cleared</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="uncoveredLine">  clearUnusedBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="uncoveredLine">APInt::APInt(unsigned numBits, ArrayRef<uint64_t> bigVal) : BitWidth(numBits) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="uncoveredLine">  initFromArray(bigVal);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="uncoveredLine">APInt::APInt(unsigned numBits, unsigned numWords, const uint64_t bigVal[])</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="uncoveredLine">    : BitWidth(numBits) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="uncoveredLine">  initFromArray(ArrayRef(bigVal, numWords));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="coveredLine">APInt::APInt(unsigned numbits, StringRef Str, uint8_t radix)</td>
    <td>171</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="coveredLine">    : BitWidth(numbits) {</td>
    <td>171</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="coveredLine">  fromString(numbits, Str, radix);</td>
    <td>171</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="coveredLine">}</td>
    <td>171</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="uncoveredLine">void APInt::reallocate(unsigned NewBitWidth) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="">  // If the number of words is the same we can just change the width and stop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="uncoveredLine">  if (getNumWords() == getNumWords(NewBitWidth)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="uncoveredLine">    BitWidth = NewBitWidth;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="">  // If we have an allocation, delete it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="uncoveredLine">  if (!isSingleWord())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="uncoveredLine">    delete [] U.pVal;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="">  // Update BitWidth.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="uncoveredLine">  BitWidth = NewBitWidth;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="">  // If we are supposed to have an allocation, create it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="uncoveredLine">  if (!isSingleWord())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="uncoveredLine">    U.pVal = getMemory(getNumWords());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="uncoveredLine">void APInt::assignSlowCase(const APInt &RHS) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="">  // Don't do anything for X = X</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="uncoveredLine">  if (this == &RHS)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="">  // Adjust the bit width and handle allocations as necessary.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="uncoveredLine">  reallocate(RHS.getBitWidth());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="">  // Copy the data.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="uncoveredLine">  if (isSingleWord())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="uncoveredLine">    U.VAL = RHS.U.VAL;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="uncoveredLine">    memcpy(U.pVal, RHS.U.pVal, getNumWords() * APINT_WORD_SIZE);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="">/// This method 'profiles' an APInt for use with FoldingSet.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="uncoveredLine">void APInt::Profile(FoldingSetNodeID& ID) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="uncoveredLine">  ID.AddInteger(BitWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="uncoveredLine">  if (isSingleWord()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="uncoveredLine">    ID.AddInteger(U.VAL);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="uncoveredLine">  unsigned NumWords = getNumWords();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="uncoveredLine">  for (unsigned i = 0; i < NumWords; ++i)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="uncoveredLine">    ID.AddInteger(U.pVal[i]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="coveredLine">bool APInt::isAligned(Align A) const {</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="coveredLine">  if (isZero())</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="coveredLine">    return true;</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="uncoveredLine">  const unsigned TrailingZeroes = countr_zero();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="uncoveredLine">  const unsigned MinimumTrailingZeroes = Log2(A);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="uncoveredLine">  return TrailingZeroes >= MinimumTrailingZeroes;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="">/// Prefix increment operator. Increments the APInt by one.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="uncoveredLine">APInt& APInt::operator++() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="uncoveredLine">  if (isSingleWord())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="uncoveredLine">    ++U.VAL;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="uncoveredLine">    tcIncrement(U.pVal, getNumWords());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="uncoveredLine">  return clearUnusedBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="">/// Prefix decrement operator. Decrements the APInt by one.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="uncoveredLine">APInt& APInt::operator--() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="uncoveredLine">  if (isSingleWord())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="uncoveredLine">    --U.VAL;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="uncoveredLine">    tcDecrement(U.pVal, getNumWords());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="uncoveredLine">  return clearUnusedBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="">/// Adds the RHS APInt to this APInt.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="">/// @returns this, after addition of RHS.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="">/// Addition assignment operator.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="uncoveredLine">APInt& APInt::operator+=(const APInt& RHS) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="uncoveredLine">  assert(BitWidth == RHS.BitWidth && "Bit widths must be the same");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="uncoveredLine">  if (isSingleWord())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="uncoveredLine">    U.VAL += RHS.U.VAL;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="uncoveredLine">    tcAdd(U.pVal, RHS.U.pVal, 0, getNumWords());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="uncoveredLine">  return clearUnusedBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="coveredLine">APInt& APInt::operator+=(uint64_t RHS) {</td>
    <td>237</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="coveredLine">  if (isSingleWord())</td>
    <td>237</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="coveredLine">    U.VAL += RHS;</td>
    <td>237</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="uncoveredLine">    tcAddPart(U.pVal, RHS, getNumWords());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="coveredLine">  return clearUnusedBits();</td>
    <td>237</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="">/// Subtracts the RHS APInt from this APInt</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="">/// @returns this, after subtraction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="">/// Subtraction assignment operator.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="uncoveredLine">APInt& APInt::operator-=(const APInt& RHS) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="uncoveredLine">  assert(BitWidth == RHS.BitWidth && "Bit widths must be the same");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="uncoveredLine">  if (isSingleWord())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="uncoveredLine">    U.VAL -= RHS.U.VAL;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="uncoveredLine">    tcSubtract(U.pVal, RHS.U.pVal, 0, getNumWords());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="uncoveredLine">  return clearUnusedBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="uncoveredLine">APInt& APInt::operator-=(uint64_t RHS) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="uncoveredLine">  if (isSingleWord())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="uncoveredLine">    U.VAL -= RHS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="uncoveredLine">    tcSubtractPart(U.pVal, RHS, getNumWords());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="uncoveredLine">  return clearUnusedBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="uncoveredLine">APInt APInt::operator*(const APInt& RHS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="uncoveredLine">  assert(BitWidth == RHS.BitWidth && "Bit widths must be the same");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="uncoveredLine">  if (isSingleWord())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="uncoveredLine">    return APInt(BitWidth, U.VAL * RHS.U.VAL);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="uncoveredLine">  APInt Result(getMemory(getNumWords()), getBitWidth());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="uncoveredLine">  tcMultiply(Result.U.pVal, U.pVal, RHS.U.pVal, getNumWords());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="uncoveredLine">  Result.clearUnusedBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="uncoveredLine">  return Result;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="uncoveredLine">void APInt::andAssignSlowCase(const APInt &RHS) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="uncoveredLine">  WordType *dst = U.pVal, *rhs = RHS.U.pVal;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="uncoveredLine">  for (size_t i = 0, e = getNumWords(); i != e; ++i)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="uncoveredLine">    dst[i] &= rhs[i];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="uncoveredLine">void APInt::orAssignSlowCase(const APInt &RHS) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="uncoveredLine">  WordType *dst = U.pVal, *rhs = RHS.U.pVal;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="uncoveredLine">  for (size_t i = 0, e = getNumWords(); i != e; ++i)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="uncoveredLine">    dst[i] |= rhs[i];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="uncoveredLine">void APInt::xorAssignSlowCase(const APInt &RHS) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="uncoveredLine">  WordType *dst = U.pVal, *rhs = RHS.U.pVal;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="uncoveredLine">  for (size_t i = 0, e = getNumWords(); i != e; ++i)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="uncoveredLine">    dst[i] ^= rhs[i];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="uncoveredLine">APInt &APInt::operator*=(const APInt &RHS) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="uncoveredLine">  *this = *this * RHS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="uncoveredLine">  return *this;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="coveredLine">APInt& APInt::operator*=(uint64_t RHS) {</td>
    <td>132</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="coveredLine">  if (isSingleWord()) {</td>
    <td>132</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="coveredLine">    U.VAL *= RHS;</td>
    <td>132</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="uncoveredLine">    unsigned NumWords = getNumWords();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="uncoveredLine">    tcMultiplyPart(U.pVal, U.pVal, RHS, 0, NumWords, NumWords, false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="coveredLine">  return clearUnusedBits();</td>
    <td>132</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="uncoveredLine">bool APInt::equalSlowCase(const APInt &RHS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="uncoveredLine">  return std::equal(U.pVal, U.pVal + getNumWords(), RHS.U.pVal);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="coveredLine">int APInt::compare(const APInt& RHS) const {</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="coveredLine">  assert(BitWidth == RHS.BitWidth && "Bit widths must be same for comparison");</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="coveredLine">  if (isSingleWord())</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="coveredLine">    return U.VAL < RHS.U.VAL ? -1 : U.VAL > RHS.U.VAL;</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="uncoveredLine">  return tcCompare(U.pVal, RHS.U.pVal, getNumWords());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="uncoveredLine">int APInt::compareSigned(const APInt& RHS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="uncoveredLine">  assert(BitWidth == RHS.BitWidth && "Bit widths must be same for comparison");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="uncoveredLine">  if (isSingleWord()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="uncoveredLine">    int64_t lhsSext = SignExtend64(U.VAL, BitWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="uncoveredLine">    int64_t rhsSext = SignExtend64(RHS.U.VAL, BitWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="uncoveredLine">    return lhsSext < rhsSext ? -1 : lhsSext > rhsSext;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="uncoveredLine">  bool lhsNeg = isNegative();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="uncoveredLine">  bool rhsNeg = RHS.isNegative();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="">  // If the sign bits don't match, then (LHS < RHS) if LHS is negative</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="uncoveredLine">  if (lhsNeg != rhsNeg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="uncoveredLine">    return lhsNeg ? -1 : 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="">  // Otherwise we can just use an unsigned comparison, because even negative</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="">  // numbers compare correctly this way if both have the same signed-ness.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="uncoveredLine">  return tcCompare(U.pVal, RHS.U.pVal, getNumWords());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="uncoveredLine">void APInt::setBitsSlowCase(unsigned loBit, unsigned hiBit) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="uncoveredLine">  unsigned loWord = whichWord(loBit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="uncoveredLine">  unsigned hiWord = whichWord(hiBit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="">  // Create an initial mask for the low word with zeros below loBit.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="uncoveredLine">  uint64_t loMask = WORDTYPE_MAX << whichBit(loBit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="">  // If hiBit is not aligned, we need a high mask.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="uncoveredLine">  unsigned hiShiftAmt = whichBit(hiBit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="uncoveredLine">  if (hiShiftAmt != 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="">    // Create a high mask with zeros above hiBit.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="uncoveredLine">    uint64_t hiMask = WORDTYPE_MAX >> (APINT_BITS_PER_WORD - hiShiftAmt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="">    // If loWord and hiWord are equal, then we combine the masks. Otherwise,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="">    // set the bits in hiWord.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="uncoveredLine">    if (hiWord == loWord)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="uncoveredLine">      loMask &= hiMask;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="uncoveredLine">      U.pVal[hiWord] |= hiMask;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="">  // Apply the mask to the low word.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="uncoveredLine">  U.pVal[loWord] |= loMask;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="">  // Fill any words between loWord and hiWord with all ones.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="uncoveredLine">  for (unsigned word = loWord + 1; word < hiWord; ++word)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="uncoveredLine">    U.pVal[word] = WORDTYPE_MAX;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="">// Complement a bignum in-place.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="uncoveredLine">static void tcComplement(APInt::WordType *dst, unsigned parts) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="uncoveredLine">  for (unsigned i = 0; i < parts; i++)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="uncoveredLine">    dst[i] = ~dst[i];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="">/// Toggle every bit to its opposite value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="uncoveredLine">void APInt::flipAllBitsSlowCase() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="uncoveredLine">  tcComplement(U.pVal, getNumWords());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="uncoveredLine">  clearUnusedBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="">/// Concatenate the bits from "NewLSB" onto the bottom of *this.  This is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="">/// equivalent to:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="">///   (this->zext(NewWidth) << NewLSB.getBitWidth()) | NewLSB.zext(NewWidth)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="">/// In the slow case, we know the result is large.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="uncoveredLine">APInt APInt::concatSlowCase(const APInt &NewLSB) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="uncoveredLine">  unsigned NewWidth = getBitWidth() + NewLSB.getBitWidth();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="uncoveredLine">  APInt Result = NewLSB.zext(NewWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="uncoveredLine">  Result.insertBits(*this, NewLSB.getBitWidth());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="uncoveredLine">  return Result;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="">/// Toggle a given bit to its opposite value whose position is given</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="">/// as "bitPosition".</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="">/// Toggles a given bit to its opposite value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="uncoveredLine">void APInt::flipBit(unsigned bitPosition) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="uncoveredLine">  assert(bitPosition < BitWidth && "Out of the bit-width range!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="uncoveredLine">  setBitVal(bitPosition, !(*this)[bitPosition]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="uncoveredLine">void APInt::insertBits(const APInt &subBits, unsigned bitPosition) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="uncoveredLine">  unsigned subBitWidth = subBits.getBitWidth();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="uncoveredLine">  assert((subBitWidth + bitPosition) <= BitWidth && "Illegal bit insertion");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="">  // inserting no bits is a noop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="uncoveredLine">  if (subBitWidth == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="">  // Insertion is a direct copy.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="uncoveredLine">  if (subBitWidth == BitWidth) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="uncoveredLine">    *this = subBits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="">  // Single word result can be done as a direct bitmask.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="uncoveredLine">  if (isSingleWord()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="uncoveredLine">    uint64_t mask = WORDTYPE_MAX >> (APINT_BITS_PER_WORD - subBitWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="uncoveredLine">    U.VAL &= ~(mask << bitPosition);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="uncoveredLine">    U.VAL |= (subBits.U.VAL << bitPosition);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="uncoveredLine">  unsigned loBit = whichBit(bitPosition);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="uncoveredLine">  unsigned loWord = whichWord(bitPosition);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="uncoveredLine">  unsigned hi1Word = whichWord(bitPosition + subBitWidth - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="">  // Insertion within a single word can be done as a direct bitmask.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="uncoveredLine">  if (loWord == hi1Word) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="uncoveredLine">    uint64_t mask = WORDTYPE_MAX >> (APINT_BITS_PER_WORD - subBitWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="uncoveredLine">    U.pVal[loWord] &= ~(mask << loBit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="uncoveredLine">    U.pVal[loWord] |= (subBits.U.VAL << loBit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="">  // Insert on word boundaries.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="uncoveredLine">  if (loBit == 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="">    // Direct copy whole words.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="uncoveredLine">    unsigned numWholeSubWords = subBitWidth / APINT_BITS_PER_WORD;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="uncoveredLine">    memcpy(U.pVal + loWord, subBits.getRawData(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="uncoveredLine">           numWholeSubWords * APINT_WORD_SIZE);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="">    // Mask+insert remaining bits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="uncoveredLine">    unsigned remainingBits = subBitWidth % APINT_BITS_PER_WORD;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="uncoveredLine">    if (remainingBits != 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="uncoveredLine">      uint64_t mask = WORDTYPE_MAX >> (APINT_BITS_PER_WORD - remainingBits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="uncoveredLine">      U.pVal[hi1Word] &= ~mask;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="uncoveredLine">      U.pVal[hi1Word] |= subBits.getWord(subBitWidth - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="">  // General case - set/clear individual bits in dst based on src.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="">  // TODO - there is scope for optimization here, but at the moment this code</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="">  // path is barely used so prefer readability over performance.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="uncoveredLine">  for (unsigned i = 0; i != subBitWidth; ++i)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="uncoveredLine">    setBitVal(bitPosition + i, subBits[i]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="uncoveredLine">void APInt::insertBits(uint64_t subBits, unsigned bitPosition, unsigned numBits) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="uncoveredLine">  uint64_t maskBits = maskTrailingOnes<uint64_t>(numBits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="uncoveredLine">  subBits &= maskBits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="uncoveredLine">  if (isSingleWord()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="uncoveredLine">    U.VAL &= ~(maskBits << bitPosition);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="uncoveredLine">    U.VAL |= subBits << bitPosition;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="uncoveredLine">  unsigned loBit = whichBit(bitPosition);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="uncoveredLine">  unsigned loWord = whichWord(bitPosition);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="uncoveredLine">  unsigned hiWord = whichWord(bitPosition + numBits - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="uncoveredLine">  if (loWord == hiWord) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="uncoveredLine">    U.pVal[loWord] &= ~(maskBits << loBit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="uncoveredLine">    U.pVal[loWord] |= subBits << loBit;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="">  static_assert(8 * sizeof(WordType) <= 64, "This code assumes only two words affected");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="uncoveredLine">  unsigned wordBits = 8 * sizeof(WordType);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="uncoveredLine">  U.pVal[loWord] &= ~(maskBits << loBit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="uncoveredLine">  U.pVal[loWord] |= subBits << loBit;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="uncoveredLine">  U.pVal[hiWord] &= ~(maskBits >> (wordBits - loBit));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="uncoveredLine">  U.pVal[hiWord] |= subBits >> (wordBits - loBit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="uncoveredLine">APInt APInt::extractBits(unsigned numBits, unsigned bitPosition) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="uncoveredLine">  assert(bitPosition < BitWidth && (numBits + bitPosition) <= BitWidth &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="">         "Illegal bit extraction");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="uncoveredLine">  if (isSingleWord())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="uncoveredLine">    return APInt(numBits, U.VAL >> bitPosition);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="uncoveredLine">  unsigned loBit = whichBit(bitPosition);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="uncoveredLine">  unsigned loWord = whichWord(bitPosition);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="uncoveredLine">  unsigned hiWord = whichWord(bitPosition + numBits - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="">  // Single word result extracting bits from a single word source.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="uncoveredLine">  if (loWord == hiWord)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="uncoveredLine">    return APInt(numBits, U.pVal[loWord] >> loBit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="">  // Extracting bits that start on a source word boundary can be done</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="">  // as a fast memory copy.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="uncoveredLine">  if (loBit == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="uncoveredLine">    return APInt(numBits, ArrayRef(U.pVal + loWord, 1 + hiWord - loWord));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="">  // General case - shift + copy source words directly into place.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="uncoveredLine">  APInt Result(numBits, 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="uncoveredLine">  unsigned NumSrcWords = getNumWords();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="uncoveredLine">  unsigned NumDstWords = Result.getNumWords();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="uncoveredLine">  uint64_t *DestPtr = Result.isSingleWord() ? &Result.U.VAL : Result.U.pVal;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="uncoveredLine">  for (unsigned word = 0; word < NumDstWords; ++word) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="uncoveredLine">    uint64_t w0 = U.pVal[loWord + word];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="uncoveredLine">    uint64_t w1 =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="uncoveredLine">        (loWord + word + 1) < NumSrcWords ? U.pVal[loWord + word + 1] : 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="uncoveredLine">    DestPtr[word] = (w0 >> loBit) | (w1 << (APINT_BITS_PER_WORD - loBit));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="uncoveredLine">  return Result.clearUnusedBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="uncoveredLine">uint64_t APInt::extractBitsAsZExtValue(unsigned numBits,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="">                                       unsigned bitPosition) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="uncoveredLine">  assert(bitPosition < BitWidth && (numBits + bitPosition) <= BitWidth &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="">         "Illegal bit extraction");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="uncoveredLine">  assert(numBits <= 64 && "Illegal bit extraction");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="uncoveredLine">  uint64_t maskBits = maskTrailingOnes<uint64_t>(numBits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="uncoveredLine">  if (isSingleWord())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="uncoveredLine">    return (U.VAL >> bitPosition) & maskBits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="uncoveredLine">  unsigned loBit = whichBit(bitPosition);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="uncoveredLine">  unsigned loWord = whichWord(bitPosition);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="uncoveredLine">  unsigned hiWord = whichWord(bitPosition + numBits - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="uncoveredLine">  if (loWord == hiWord)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="uncoveredLine">    return (U.pVal[loWord] >> loBit) & maskBits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="">  static_assert(8 * sizeof(WordType) <= 64, "This code assumes only two words affected");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="uncoveredLine">  unsigned wordBits = 8 * sizeof(WordType);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="uncoveredLine">  uint64_t retBits = U.pVal[loWord] >> loBit;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="uncoveredLine">  retBits |= U.pVal[hiWord] << (wordBits - loBit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="uncoveredLine">  retBits &= maskBits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="uncoveredLine">  return retBits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="uncoveredLine">unsigned APInt::getSufficientBitsNeeded(StringRef Str, uint8_t Radix) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="uncoveredLine">  assert(!Str.empty() && "Invalid string length");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="uncoveredLine">  size_t StrLen = Str.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="">  // Each computation below needs to know if it's negative.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="uncoveredLine">  unsigned IsNegative = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="uncoveredLine">  if (Str[0] == '-' || Str[0] == '+') {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="uncoveredLine">    IsNegative = Str[0] == '-';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="uncoveredLine">    StrLen--;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="uncoveredLine">    assert(StrLen && "String is only a sign, needs a value.");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="">  // For radixes of power-of-two values, the bits required is accurately and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="">  // easily computed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="uncoveredLine">  if (Radix == 2)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="uncoveredLine">    return StrLen + IsNegative;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="uncoveredLine">  if (Radix == 8)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="uncoveredLine">    return StrLen * 3 + IsNegative;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="uncoveredLine">  if (Radix == 16)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="uncoveredLine">    return StrLen * 4 + IsNegative;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="">  // Compute a sufficient number of bits that is always large enough but might</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="">  // be too large. This avoids the assertion in the constructor. This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="">  // calculation doesn't work appropriately for the numbers 0-9, so just use 4</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="">  // bits in that case.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="uncoveredLine">  if (Radix == 10)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="uncoveredLine">    return (StrLen == 1 ? 4 : StrLen * 64 / 18) + IsNegative;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="uncoveredLine">  assert(Radix == 36);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="uncoveredLine">  return (StrLen == 1 ? 7 : StrLen * 16 / 3) + IsNegative;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="uncoveredLine">unsigned APInt::getBitsNeeded(StringRef str, uint8_t radix) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="">  // Compute a sufficient number of bits that is always large enough but might</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="">  // be too large.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="uncoveredLine">  unsigned sufficient = getSufficientBitsNeeded(str, radix);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="">  // For bases 2, 8, and 16, the sufficient number of bits is exact and we can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="">  // return the value directly. For bases 10 and 36, we need to do extra work.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="uncoveredLine">  if (radix == 2 || radix == 8 || radix == 16)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="uncoveredLine">    return sufficient;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="">  // This is grossly inefficient but accurate. We could probably do something</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="">  // with a computation of roughly slen*64/20 and then adjust by the value of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="">  // the first few digits. But, I'm not sure how accurate that could be.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="uncoveredLine">  size_t slen = str.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="">  // Each computation below needs to know if it's negative.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="uncoveredLine">  StringRef::iterator p = str.begin();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="uncoveredLine">  unsigned isNegative = *p == '-';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="uncoveredLine">  if (*p == '-' || *p == '+') {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="uncoveredLine">    p++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="uncoveredLine">    slen--;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="uncoveredLine">    assert(slen && "String is only a sign, needs a value.");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="">  // Convert to the actual binary value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="uncoveredLine">  APInt tmp(sufficient, StringRef(p, slen), radix);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="">  // Compute how many bits are required. If the log is infinite, assume we need</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="">  // just bit. If the log is exact and value is negative, then the value is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="">  // MinSignedValue with (log + 1) bits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="uncoveredLine">  unsigned log = tmp.logBase2();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="uncoveredLine">  if (log == (unsigned)-1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="uncoveredLine">    return isNegative + 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="uncoveredLine">  } else if (isNegative && tmp.isPowerOf2()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="uncoveredLine">    return isNegative + log;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="uncoveredLine">    return isNegative + log + 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="coveredLine">hash_code llvm::hash_value(const APInt &Arg) {</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="coveredLine">  if (Arg.isSingleWord())</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="coveredLine">    return hash_combine(Arg.BitWidth, Arg.U.VAL);</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="uncoveredLine">  return hash_combine(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="uncoveredLine">      Arg.BitWidth,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="uncoveredLine">      hash_combine_range(Arg.U.pVal, Arg.U.pVal + Arg.getNumWords()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="coveredLine">unsigned DenseMapInfo<APInt, void>::getHashValue(const APInt &Key) {</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="coveredLine">  return static_cast<unsigned>(hash_value(Key));</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="uncoveredLine">bool APInt::isSplat(unsigned SplatSizeInBits) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="uncoveredLine">  assert(getBitWidth() % SplatSizeInBits == 0 &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="">         "SplatSizeInBits must divide width!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="">  // We can check that all parts of an integer are equal by making use of a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="">  // little trick: rotate and check if it's still the same value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="uncoveredLine">  return *this == rotl(SplatSizeInBits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="">/// This function returns the high "numBits" bits of this APInt.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="uncoveredLine">APInt APInt::getHiBits(unsigned numBits) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="uncoveredLine">  return this->lshr(BitWidth - numBits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="">/// This function returns the low "numBits" bits of this APInt.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="uncoveredLine">APInt APInt::getLoBits(unsigned numBits) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="uncoveredLine">  APInt Result(getLowBitsSet(BitWidth, numBits));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="uncoveredLine">  Result &= *this;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="uncoveredLine">  return Result;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="">/// Return a value containing V broadcasted over NewLen bits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="uncoveredLine">APInt APInt::getSplat(unsigned NewLen, const APInt &V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="uncoveredLine">  assert(NewLen >= V.getBitWidth() && "Can't splat to smaller bit width!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="uncoveredLine">  APInt Val = V.zext(NewLen);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="uncoveredLine">  for (unsigned I = V.getBitWidth(); I < NewLen; I <<= 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="uncoveredLine">    Val |= Val << I;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="uncoveredLine">  return Val;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="uncoveredLine">unsigned APInt::countLeadingZerosSlowCase() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="uncoveredLine">  unsigned Count = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="uncoveredLine">  for (int i = getNumWords()-1; i >= 0; --i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="uncoveredLine">    uint64_t V = U.pVal[i];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="uncoveredLine">    if (V == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="uncoveredLine">      Count += APINT_BITS_PER_WORD;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="">    else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="uncoveredLine">      Count += llvm::countl_zero(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="">  // Adjust for unused bits in the most significant word (they are zero).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="uncoveredLine">  unsigned Mod = BitWidth % APINT_BITS_PER_WORD;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="uncoveredLine">  Count -= Mod > 0 ? APINT_BITS_PER_WORD - Mod : 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="uncoveredLine">  return Count;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="uncoveredLine">unsigned APInt::countLeadingOnesSlowCase() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="uncoveredLine">  unsigned highWordBits = BitWidth % APINT_BITS_PER_WORD;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="">  unsigned shift;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="uncoveredLine">  if (!highWordBits) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="uncoveredLine">    highWordBits = APINT_BITS_PER_WORD;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="uncoveredLine">    shift = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="uncoveredLine">    shift = APINT_BITS_PER_WORD - highWordBits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="uncoveredLine">  int i = getNumWords() - 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="uncoveredLine">  unsigned Count = llvm::countl_one(U.pVal[i] << shift);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="uncoveredLine">  if (Count == highWordBits) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="uncoveredLine">    for (i--; i >= 0; --i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="uncoveredLine">      if (U.pVal[i] == WORDTYPE_MAX)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="uncoveredLine">        Count += APINT_BITS_PER_WORD;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="">      else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="uncoveredLine">        Count += llvm::countl_one(U.pVal[i]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="uncoveredLine">  return Count;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="uncoveredLine">unsigned APInt::countTrailingZerosSlowCase() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="uncoveredLine">  unsigned Count = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="uncoveredLine">  unsigned i = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="uncoveredLine">  for (; i < getNumWords() && U.pVal[i] == 0; ++i)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="uncoveredLine">    Count += APINT_BITS_PER_WORD;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="uncoveredLine">  if (i < getNumWords())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="uncoveredLine">    Count += llvm::countr_zero(U.pVal[i]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="uncoveredLine">  return std::min(Count, BitWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="uncoveredLine">unsigned APInt::countTrailingOnesSlowCase() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="uncoveredLine">  unsigned Count = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="uncoveredLine">  unsigned i = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="uncoveredLine">  for (; i < getNumWords() && U.pVal[i] == WORDTYPE_MAX; ++i)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="uncoveredLine">    Count += APINT_BITS_PER_WORD;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="uncoveredLine">  if (i < getNumWords())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="uncoveredLine">    Count += llvm::countr_one(U.pVal[i]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="uncoveredLine">  assert(Count <= BitWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="uncoveredLine">  return Count;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="uncoveredLine">unsigned APInt::countPopulationSlowCase() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="uncoveredLine">  unsigned Count = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="uncoveredLine">  for (unsigned i = 0; i < getNumWords(); ++i)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="uncoveredLine">    Count += llvm::popcount(U.pVal[i]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="uncoveredLine">  return Count;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="uncoveredLine">bool APInt::intersectsSlowCase(const APInt &RHS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="uncoveredLine">  for (unsigned i = 0, e = getNumWords(); i != e; ++i)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="uncoveredLine">    if ((U.pVal[i] & RHS.U.pVal[i]) != 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="uncoveredLine">bool APInt::isSubsetOfSlowCase(const APInt &RHS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="uncoveredLine">  for (unsigned i = 0, e = getNumWords(); i != e; ++i)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="uncoveredLine">    if ((U.pVal[i] & ~RHS.U.pVal[i]) != 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="uncoveredLine">APInt APInt::byteSwap() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="uncoveredLine">  assert(BitWidth >= 16 && BitWidth % 8 == 0 && "Cannot byteswap!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="uncoveredLine">  if (BitWidth == 16)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="uncoveredLine">    return APInt(BitWidth, llvm::byteswap<uint16_t>(U.VAL));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="uncoveredLine">  if (BitWidth == 32)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="uncoveredLine">    return APInt(BitWidth, llvm::byteswap<uint32_t>(U.VAL));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="uncoveredLine">  if (BitWidth <= 64) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="uncoveredLine">    uint64_t Tmp1 = llvm::byteswap<uint64_t>(U.VAL);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="uncoveredLine">    Tmp1 >>= (64 - BitWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="uncoveredLine">    return APInt(BitWidth, Tmp1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="uncoveredLine">  APInt Result(getNumWords() * APINT_BITS_PER_WORD, 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="uncoveredLine">  for (unsigned I = 0, N = getNumWords(); I != N; ++I)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="uncoveredLine">    Result.U.pVal[I] = llvm::byteswap<uint64_t>(U.pVal[N - I - 1]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="uncoveredLine">  if (Result.BitWidth != BitWidth) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="uncoveredLine">    Result.lshrInPlace(Result.BitWidth - BitWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="uncoveredLine">    Result.BitWidth = BitWidth;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="uncoveredLine">  return Result;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="uncoveredLine">APInt APInt::reverseBits() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="uncoveredLine">  switch (BitWidth) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="uncoveredLine">  case 64:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="uncoveredLine">    return APInt(BitWidth, llvm::reverseBits<uint64_t>(U.VAL));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="uncoveredLine">  case 32:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="uncoveredLine">    return APInt(BitWidth, llvm::reverseBits<uint32_t>(U.VAL));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="uncoveredLine">  case 16:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="uncoveredLine">    return APInt(BitWidth, llvm::reverseBits<uint16_t>(U.VAL));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="uncoveredLine">  case 8:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="uncoveredLine">    return APInt(BitWidth, llvm::reverseBits<uint8_t>(U.VAL));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="uncoveredLine">  case 0:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="uncoveredLine">    return *this;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="uncoveredLine">  default:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="uncoveredLine">    break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="uncoveredLine">  APInt Val(*this);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="uncoveredLine">  APInt Reversed(BitWidth, 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="uncoveredLine">  unsigned S = BitWidth;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="uncoveredLine">  for (; Val != 0; Val.lshrInPlace(1)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="uncoveredLine">    Reversed <<= 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="uncoveredLine">    Reversed |= Val[0];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="uncoveredLine">    --S;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="uncoveredLine">  Reversed <<= S;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="uncoveredLine">  return Reversed;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="uncoveredLine">APInt llvm::APIntOps::GreatestCommonDivisor(APInt A, APInt B) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="">  // Fast-path a common case.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="uncoveredLine">  if (A == B) return A;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="">  // Corner cases: if either operand is zero, the other is the gcd.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="uncoveredLine">  if (!A) return B;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="uncoveredLine">  if (!B) return A;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="">  // Count common powers of 2 and remove all other powers of 2.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="">  unsigned Pow2;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="">  {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="uncoveredLine">    unsigned Pow2_A = A.countr_zero();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="uncoveredLine">    unsigned Pow2_B = B.countr_zero();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="uncoveredLine">    if (Pow2_A > Pow2_B) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="uncoveredLine">      A.lshrInPlace(Pow2_A - Pow2_B);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="uncoveredLine">      Pow2 = Pow2_B;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="uncoveredLine">    } else if (Pow2_B > Pow2_A) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="uncoveredLine">      B.lshrInPlace(Pow2_B - Pow2_A);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="uncoveredLine">      Pow2 = Pow2_A;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="uncoveredLine">      Pow2 = Pow2_A;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="">  // Both operands are odd multiples of 2^Pow_2:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="">  //   gcd(a, b) = gcd(|a - b| / 2^i, min(a, b))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="">  // This is a modified version of Stein's algorithm, taking advantage of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="">  // efficient countTrailingZeros().</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="uncoveredLine">  while (A != B) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="uncoveredLine">    if (A.ugt(B)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="uncoveredLine">      A -= B;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="uncoveredLine">      A.lshrInPlace(A.countr_zero() - Pow2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="uncoveredLine">      B -= A;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="uncoveredLine">      B.lshrInPlace(B.countr_zero() - Pow2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="uncoveredLine">  return A;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="uncoveredLine">APInt llvm::APIntOps::RoundDoubleToAPInt(double Double, unsigned width) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="uncoveredLine">  uint64_t I = bit_cast<uint64_t>(Double);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="">  // Get the sign bit from the highest order bit</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="uncoveredLine">  bool isNeg = I >> 63;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="">  // Get the 11-bit exponent and adjust for the 1023 bit bias</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="uncoveredLine">  int64_t exp = ((I >> 52) & 0x7ff) - 1023;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="">  // If the exponent is negative, the value is < 0 so just return 0.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="uncoveredLine">  if (exp < 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="uncoveredLine">    return APInt(width, 0u);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="">  // Extract the mantissa by clearing the top 12 bits (sign + exponent).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="uncoveredLine">  uint64_t mantissa = (I & (~0ULL >> 12)) | 1ULL << 52;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="">  // If the exponent doesn't shift all bits out of the mantissa</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="uncoveredLine">  if (exp < 52)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="uncoveredLine">    return isNeg ? -APInt(width, mantissa >> (52 - exp)) :</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="uncoveredLine">                    APInt(width, mantissa >> (52 - exp));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="">  // If the client didn't provide enough bits for us to shift the mantissa into</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="">  // then the result is undefined, just return 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="uncoveredLine">  if (width <= exp - 52)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="uncoveredLine">    return APInt(width, 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="">  // Otherwise, we have to shift the mantissa bits up to the right location</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="uncoveredLine">  APInt Tmp(width, mantissa);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="uncoveredLine">  Tmp <<= (unsigned)exp - 52;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="uncoveredLine">  return isNeg ? -Tmp : Tmp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="">/// This function converts this APInt to a double.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="">/// The layout for double is as following (IEEE Standard 754):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="">///  --------------------------------------</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="">/// |  Sign    Exponent    Fraction    Bias |</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="">/// |-------------------------------------- |</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="">/// |  1[63]   11[62-52]   52[51-00]   1023 |</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="">///  --------------------------------------</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="uncoveredLine">double APInt::roundToDouble(bool isSigned) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="">  // Handle the simple case where the value is contained in one uint64_t.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="">  // It is wrong to optimize getWord(0) to VAL; there might be more than one word.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="uncoveredLine">  if (isSingleWord() || getActiveBits() <= APINT_BITS_PER_WORD) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="uncoveredLine">    if (isSigned) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="uncoveredLine">      int64_t sext = SignExtend64(getWord(0), BitWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="uncoveredLine">      return double(sext);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="">    } else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="uncoveredLine">      return double(getWord(0));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="">  // Determine if the value is negative.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="uncoveredLine">  bool isNeg = isSigned ? (*this)[BitWidth-1] : false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="">  // Construct the absolute value if we're negative.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="uncoveredLine">  APInt Tmp(isNeg ? -(*this) : (*this));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="">  // Figure out how many bits we're using.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="uncoveredLine">  unsigned n = Tmp.getActiveBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="">  // The exponent (without bias normalization) is just the number of bits</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="">  // we are using. Note that the sign bit is gone since we constructed the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="">  // absolute value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="uncoveredLine">  uint64_t exp = n;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="">  // Return infinity for exponent overflow</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="uncoveredLine">  if (exp > 1023) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="uncoveredLine">    if (!isSigned || !isNeg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="uncoveredLine">      return std::numeric_limits<double>::infinity();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="uncoveredLine">      return -std::numeric_limits<double>::infinity();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="uncoveredLine">  exp += 1023; // Increment for 1023 bias</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="">  // Number of bits in mantissa is 52. To obtain the mantissa value, we must</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="">  // extract the high 52 bits from the correct words in pVal.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="">  uint64_t mantissa;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="uncoveredLine">  unsigned hiWord = whichWord(n-1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="uncoveredLine">  if (hiWord == 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="uncoveredLine">    mantissa = Tmp.U.pVal[0];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="uncoveredLine">    if (n > 52)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="uncoveredLine">      mantissa >>= n - 52; // shift down, we want the top 52 bits.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="uncoveredLine">    assert(hiWord > 0 && "huh?");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="uncoveredLine">    uint64_t hibits = Tmp.U.pVal[hiWord] << (52 - n % APINT_BITS_PER_WORD);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="uncoveredLine">    uint64_t lobits = Tmp.U.pVal[hiWord-1] >> (11 + n % APINT_BITS_PER_WORD);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="uncoveredLine">    mantissa = hibits | lobits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="">  // The leading bit of mantissa is implicit, so get rid of it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="uncoveredLine">  uint64_t sign = isNeg ? (1ULL << (APINT_BITS_PER_WORD - 1)) : 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="uncoveredLine">  uint64_t I = sign | (exp << 52) | mantissa;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="uncoveredLine">  return bit_cast<double>(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="">// Truncate to new width.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="coveredLine">APInt APInt::trunc(unsigned width) const {</td>
    <td>171</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="coveredLine">  assert(width <= BitWidth && "Invalid APInt Truncate request");</td>
    <td>171</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="coveredLine">  if (width <= APINT_BITS_PER_WORD)</td>
    <td>171</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="coveredLine">    return APInt(width, getRawData()[0]);</td>
    <td>171</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="uncoveredLine">  if (width == BitWidth)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="uncoveredLine">    return *this;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="uncoveredLine">  APInt Result(getMemory(getNumWords(width)), width);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="">  // Copy full words.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="">  unsigned i;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="uncoveredLine">  for (i = 0; i != width / APINT_BITS_PER_WORD; i++)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="uncoveredLine">    Result.U.pVal[i] = U.pVal[i];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="">  // Truncate and copy any partial word.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="uncoveredLine">  unsigned bits = (0 - width) % APINT_BITS_PER_WORD;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="uncoveredLine">  if (bits != 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="uncoveredLine">    Result.U.pVal[i] = U.pVal[i] << bits >> bits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="uncoveredLine">  return Result;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="">// Truncate to new width with unsigned saturation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="uncoveredLine">APInt APInt::truncUSat(unsigned width) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="uncoveredLine">  assert(width <= BitWidth && "Invalid APInt Truncate request");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="">  // Can we just losslessly truncate it?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="uncoveredLine">  if (isIntN(width))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="uncoveredLine">    return trunc(width);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="">  // If not, then just return the new limit.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="uncoveredLine">  return APInt::getMaxValue(width);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="">// Truncate to new width with signed saturation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="uncoveredLine">APInt APInt::truncSSat(unsigned width) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="uncoveredLine">  assert(width <= BitWidth && "Invalid APInt Truncate request");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="">  // Can we just losslessly truncate it?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="uncoveredLine">  if (isSignedIntN(width))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="uncoveredLine">    return trunc(width);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="">  // If not, then just return the new limits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="uncoveredLine">  return isNegative() ? APInt::getSignedMinValue(width)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="uncoveredLine">                      : APInt::getSignedMaxValue(width);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="">// Sign extend to a new width.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="uncoveredLine">APInt APInt::sext(unsigned Width) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="uncoveredLine">  assert(Width >= BitWidth && "Invalid APInt SignExtend request");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="uncoveredLine">  if (Width <= APINT_BITS_PER_WORD)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="uncoveredLine">    return APInt(Width, SignExtend64(U.VAL, BitWidth));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="uncoveredLine">  if (Width == BitWidth)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="uncoveredLine">    return *this;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="uncoveredLine">  APInt Result(getMemory(getNumWords(Width)), Width);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="">  // Copy words.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="uncoveredLine">  std::memcpy(Result.U.pVal, getRawData(), getNumWords() * APINT_WORD_SIZE);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="">  // Sign extend the last word since there may be unused bits in the input.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="uncoveredLine">  Result.U.pVal[getNumWords() - 1] =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="uncoveredLine">      SignExtend64(Result.U.pVal[getNumWords() - 1],</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="uncoveredLine">                   ((BitWidth - 1) % APINT_BITS_PER_WORD) + 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="">  // Fill with sign bits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="uncoveredLine">  std::memset(Result.U.pVal + getNumWords(), isNegative() ? -1 : 0,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="uncoveredLine">              (Result.getNumWords() - getNumWords()) * APINT_WORD_SIZE);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="uncoveredLine">  Result.clearUnusedBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="uncoveredLine">  return Result;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="">//  Zero extend to a new width.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="coveredLine">APInt APInt::zext(unsigned width) const {</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="coveredLine">  assert(width >= BitWidth && "Invalid APInt ZeroExtend request");</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="coveredLine">  if (width <= APINT_BITS_PER_WORD)</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="coveredLine">    return APInt(width, U.VAL);</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="uncoveredLine">  if (width == BitWidth)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="uncoveredLine">    return *this;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="uncoveredLine">  APInt Result(getMemory(getNumWords(width)), width);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="">  // Copy words.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="uncoveredLine">  std::memcpy(Result.U.pVal, getRawData(), getNumWords() * APINT_WORD_SIZE);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="">  // Zero remaining words.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="uncoveredLine">  std::memset(Result.U.pVal + getNumWords(), 0,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="uncoveredLine">              (Result.getNumWords() - getNumWords()) * APINT_WORD_SIZE);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="uncoveredLine">  return Result;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="coveredLine">APInt APInt::zextOrTrunc(unsigned width) const {</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="coveredLine">  if (BitWidth < width)</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="coveredLine">    return zext(width);</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="uncoveredLine">  if (BitWidth > width)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="uncoveredLine">    return trunc(width);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="uncoveredLine">  return *this;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="uncoveredLine">APInt APInt::sextOrTrunc(unsigned width) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="uncoveredLine">  if (BitWidth < width)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="uncoveredLine">    return sext(width);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="uncoveredLine">  if (BitWidth > width)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="uncoveredLine">    return trunc(width);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="uncoveredLine">  return *this;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="">/// Arithmetic right-shift this APInt by shiftAmt.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="">/// Arithmetic right-shift function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="uncoveredLine">void APInt::ashrInPlace(const APInt &shiftAmt) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="uncoveredLine">  ashrInPlace((unsigned)shiftAmt.getLimitedValue(BitWidth));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="">/// Arithmetic right-shift this APInt by shiftAmt.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="">/// Arithmetic right-shift function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="uncoveredLine">void APInt::ashrSlowCase(unsigned ShiftAmt) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="">  // Don't bother performing a no-op shift.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="uncoveredLine">  if (!ShiftAmt)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="">  // Save the original sign bit for later.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="uncoveredLine">  bool Negative = isNegative();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="">  // WordShift is the inter-part shift; BitShift is intra-part shift.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="uncoveredLine">  unsigned WordShift = ShiftAmt / APINT_BITS_PER_WORD;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="uncoveredLine">  unsigned BitShift = ShiftAmt % APINT_BITS_PER_WORD;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="uncoveredLine">  unsigned WordsToMove = getNumWords() - WordShift;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="uncoveredLine">  if (WordsToMove != 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="">    // Sign extend the last word to fill in the unused bits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="uncoveredLine">    U.pVal[getNumWords() - 1] = SignExtend64(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="uncoveredLine">        U.pVal[getNumWords() - 1], ((BitWidth - 1) % APINT_BITS_PER_WORD) + 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="">    // Fastpath for moving by whole words.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="uncoveredLine">    if (BitShift == 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="uncoveredLine">      std::memmove(U.pVal, U.pVal + WordShift, WordsToMove * APINT_WORD_SIZE);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="">      // Move the words containing significant bits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="uncoveredLine">      for (unsigned i = 0; i != WordsToMove - 1; ++i)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="uncoveredLine">        U.pVal[i] = (U.pVal[i + WordShift] >> BitShift) |</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="uncoveredLine">                    (U.pVal[i + WordShift + 1] << (APINT_BITS_PER_WORD - BitShift));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="">      // Handle the last word which has no high bits to copy.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="uncoveredLine">      U.pVal[WordsToMove - 1] = U.pVal[WordShift + WordsToMove - 1] >> BitShift;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="">      // Sign extend one more time.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="uncoveredLine">      U.pVal[WordsToMove - 1] =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="uncoveredLine">          SignExtend64(U.pVal[WordsToMove - 1], APINT_BITS_PER_WORD - BitShift);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="">  // Fill in the remainder based on the original sign.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="uncoveredLine">  std::memset(U.pVal + WordsToMove, Negative ? -1 : 0,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="uncoveredLine">              WordShift * APINT_WORD_SIZE);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="uncoveredLine">  clearUnusedBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="">/// Logical right-shift this APInt by shiftAmt.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="">/// Logical right-shift function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="uncoveredLine">void APInt::lshrInPlace(const APInt &shiftAmt) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="uncoveredLine">  lshrInPlace((unsigned)shiftAmt.getLimitedValue(BitWidth));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="">/// Logical right-shift this APInt by shiftAmt.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="">/// Logical right-shift function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="uncoveredLine">void APInt::lshrSlowCase(unsigned ShiftAmt) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="uncoveredLine">  tcShiftRight(U.pVal, getNumWords(), ShiftAmt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="">/// Left-shift this APInt by shiftAmt.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="">/// Left-shift function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="uncoveredLine">APInt &APInt::operator<<=(const APInt &shiftAmt) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="">  // It's undefined behavior in C to shift by BitWidth or greater.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="uncoveredLine">  *this <<= (unsigned)shiftAmt.getLimitedValue(BitWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="uncoveredLine">  return *this;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="uncoveredLine">void APInt::shlSlowCase(unsigned ShiftAmt) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="uncoveredLine">  tcShiftLeft(U.pVal, getNumWords(), ShiftAmt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="uncoveredLine">  clearUnusedBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="">// Calculate the rotate amount modulo the bit width.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="uncoveredLine">static unsigned rotateModulo(unsigned BitWidth, const APInt &rotateAmt) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="uncoveredLine">  if (LLVM_UNLIKELY(BitWidth == 0))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="uncoveredLine">    return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="uncoveredLine">  unsigned rotBitWidth = rotateAmt.getBitWidth();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="uncoveredLine">  APInt rot = rotateAmt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="uncoveredLine">  if (rotBitWidth < BitWidth) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="">    // Extend the rotate APInt, so that the urem doesn't divide by 0.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="">    // e.g. APInt(1, 32) would give APInt(1, 0).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="uncoveredLine">    rot = rotateAmt.zext(BitWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="uncoveredLine">  rot = rot.urem(APInt(rot.getBitWidth(), BitWidth));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="uncoveredLine">  return rot.getLimitedValue(BitWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="uncoveredLine">APInt APInt::rotl(const APInt &rotateAmt) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="uncoveredLine">  return rotl(rotateModulo(BitWidth, rotateAmt));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="uncoveredLine">APInt APInt::rotl(unsigned rotateAmt) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="uncoveredLine">  if (LLVM_UNLIKELY(BitWidth == 0))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="uncoveredLine">    return *this;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="uncoveredLine">  rotateAmt %= BitWidth;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="uncoveredLine">  if (rotateAmt == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="uncoveredLine">    return *this;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="uncoveredLine">  return shl(rotateAmt) | lshr(BitWidth - rotateAmt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="uncoveredLine">APInt APInt::rotr(const APInt &rotateAmt) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="uncoveredLine">  return rotr(rotateModulo(BitWidth, rotateAmt));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="uncoveredLine">APInt APInt::rotr(unsigned rotateAmt) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="uncoveredLine">  if (BitWidth == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="uncoveredLine">    return *this;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="uncoveredLine">  rotateAmt %= BitWidth;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="uncoveredLine">  if (rotateAmt == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="uncoveredLine">    return *this;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="uncoveredLine">  return lshr(rotateAmt) | shl(BitWidth - rotateAmt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="">/// \returns the nearest log base 2 of this APInt. Ties round up.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="">/// NOTE: When we have a BitWidth of 1, we define:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="">///   log2(0) = UINT32_MAX</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="">///   log2(1) = 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="">/// to get around any mathematical concerns resulting from</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="">/// referencing 2 in a space where 2 does no exist.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="uncoveredLine">unsigned APInt::nearestLogBase2() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="">  // Special case when we have a bitwidth of 1. If VAL is 1, then we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="">  // get 0. If VAL is 0, we get WORDTYPE_MAX which gets truncated to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="">  // UINT32_MAX.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="uncoveredLine">  if (BitWidth == 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="uncoveredLine">    return U.VAL - 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="">  // Handle the zero case.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="uncoveredLine">  if (isZero())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="uncoveredLine">    return UINT32_MAX;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="">  // The non-zero case is handled by computing:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="">  //   nearestLogBase2(x) = logBase2(x) + x[logBase2(x)-1].</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="">  // where x[i] is referring to the value of the ith bit of x.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="uncoveredLine">  unsigned lg = logBase2();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="uncoveredLine">  return lg + unsigned((*this)[lg - 1]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="">// Square Root - this method computes and returns the square root of "this".</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="">// Three mechanisms are used for computation. For small values (<= 5 bits),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="">// a table lookup is done. This gets some performance for common cases. For</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="">// values using less than 52 bits, the value is converted to double and then</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="">// the libc sqrt function is called. The result is rounded and then converted</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="">// back to a uint64_t which is then used to construct the result. Finally,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="">// the Babylonian method for computing square roots is used.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="uncoveredLine">APInt APInt::sqrt() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="">  // Determine the magnitude of the value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="uncoveredLine">  unsigned magnitude = getActiveBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="">  // Use a fast table for some small values. This also gets rid of some</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="">  // rounding errors in libc sqrt for small values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="uncoveredLine">  if (magnitude <= 5) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="">    static const uint8_t results[32] = {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="">      /*     0 */ 0,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="">      /*  1- 2 */ 1, 1,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="">      /*  3- 6 */ 2, 2, 2, 2,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="">      /*  7-12 */ 3, 3, 3, 3, 3, 3,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="">      /* 13-20 */ 4, 4, 4, 4, 4, 4, 4, 4,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="">      /* 21-30 */ 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="">      /*    31 */ 6</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="">    };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="uncoveredLine">    return APInt(BitWidth, results[ (isSingleWord() ? U.VAL : U.pVal[0]) ]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="">  // If the magnitude of the value fits in less than 52 bits (the precision of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="">  // an IEEE double precision floating point value), then we can use the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="">  // libc sqrt function which will probably use a hardware sqrt computation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="">  // This should be faster than the algorithm below.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="uncoveredLine">  if (magnitude < 52) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="uncoveredLine">    return APInt(BitWidth,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="uncoveredLine">                 uint64_t(::round(::sqrt(double(isSingleWord() ? U.VAL</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="uncoveredLine">                                                               : U.pVal[0])))));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="">  // Okay, all the short cuts are exhausted. We must compute it. The following</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="">  // is a classical Babylonian method for computing the square root. This code</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="">  // was adapted to APInt from a wikipedia article on such computations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="">  // See http://www.wikipedia.org/ and go to the page named</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="">  // Calculate_an_integer_square_root.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="uncoveredLine">  unsigned nbits = BitWidth, i = 4;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="uncoveredLine">  APInt testy(BitWidth, 16);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="uncoveredLine">  APInt x_old(BitWidth, 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="uncoveredLine">  APInt x_new(BitWidth, 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="uncoveredLine">  APInt two(BitWidth, 2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="">  // Select a good starting value using binary logarithms.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="uncoveredLine">  for (;; i += 2, testy = testy.shl(2))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="uncoveredLine">    if (i >= nbits || this->ule(testy)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="uncoveredLine">      x_old = x_old.shl(i / 2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="">  // Use the Babylonian method to arrive at the integer square root:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="">  for (;;) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="uncoveredLine">    x_new = (this->udiv(x_old) + x_old).udiv(two);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="uncoveredLine">    if (x_old.ule(x_new))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="uncoveredLine">    x_old = x_new;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="">  // Make sure we return the closest approximation</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="">  // NOTE: The rounding calculation below is correct. It will produce an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="">  // off-by-one discrepancy with results from pari/gp. That discrepancy has been</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="">  // determined to be a rounding issue with pari/gp as it begins to use a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="">  // floating point representation after 192 bits. There are no discrepancies</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="">  // between this algorithm and pari/gp for bit widths < 192 bits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="uncoveredLine">  APInt square(x_old * x_old);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="uncoveredLine">  APInt nextSquare((x_old + 1) * (x_old +1));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="uncoveredLine">  if (this->ult(square))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="uncoveredLine">    return x_old;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="uncoveredLine">  assert(this->ule(nextSquare) && "Error in APInt::sqrt computation");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="uncoveredLine">  APInt midpoint((nextSquare - square).udiv(two));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="uncoveredLine">  APInt offset(*this - square);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="uncoveredLine">  if (offset.ult(midpoint))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="uncoveredLine">    return x_old;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="uncoveredLine">  return x_old + 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="">/// Computes the multiplicative inverse of this APInt for a given modulo. The</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="">/// iterative extended Euclidean algorithm is used to solve for this value,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="">/// however we simplify it to speed up calculating only the inverse, and take</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="">/// advantage of div+rem calculations. We also use some tricks to avoid copying</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="">/// (potentially large) APInts around.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="">/// WARNING: a value of '0' may be returned,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="">///          signifying that no multiplicative inverse exists!</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="uncoveredLine">APInt APInt::multiplicativeInverse(const APInt& modulo) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="uncoveredLine">  assert(ult(modulo) && "This APInt must be smaller than the modulo");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="">  // Using the properties listed at the following web page (accessed 06/21/08):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="">  //   http://www.numbertheory.org/php/euclid.html</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="">  // (especially the properties numbered 3, 4 and 9) it can be proved that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="">  // BitWidth bits suffice for all the computations in the algorithm implemented</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="">  // below. More precisely, this number of bits suffice if the multiplicative</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="">  // inverse exists, but may not suffice for the general extended Euclidean</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="">  // algorithm.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="uncoveredLine">  APInt r[2] = { modulo, *this };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="uncoveredLine">  APInt t[2] = { APInt(BitWidth, 0), APInt(BitWidth, 1) };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="uncoveredLine">  APInt q(BitWidth, 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="">  unsigned i;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="uncoveredLine">  for (i = 0; r[i^1] != 0; i ^= 1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="">    // An overview of the math without the confusing bit-flipping:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="">    // q = r[i-2] / r[i-1]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="">    // r[i] = r[i-2] % r[i-1]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="">    // t[i] = t[i-2] - t[i-1] * q</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="uncoveredLine">    udivrem(r[i], r[i^1], q, r[i]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="uncoveredLine">    t[i] -= t[i^1] * q;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="">  // If this APInt and the modulo are not coprime, there is no multiplicative</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="">  // inverse, so return 0. We check this by looking at the next-to-last</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="">  // remainder, which is the gcd(*this,modulo) as calculated by the Euclidean</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="">  // algorithm.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="uncoveredLine">  if (r[i] != 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="uncoveredLine">    return APInt(BitWidth, 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="">  // The next-to-last t is the multiplicative inverse.  However, we are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="">  // interested in a positive inverse. Calculate a positive one from a negative</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="">  // one if necessary. A simple addition of the modulo suffices because</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="">  // abs(t[i]) is known to be less than *this/2 (see the link above).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="uncoveredLine">  if (t[i].isNegative())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="uncoveredLine">    t[i] += modulo;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="uncoveredLine">  return std::move(t[i]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="">/// Implementation of Knuth's Algorithm D (Division of nonnegative integers)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="">/// from "Art of Computer Programming, Volume 2", section 4.3.1, p. 272. The</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="">/// variables here have the same names as in the algorithm. Comments explain</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="">/// the algorithm and any deviation from it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="uncoveredLine">static void KnuthDiv(uint32_t *u, uint32_t *v, uint32_t *q, uint32_t* r,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="">                     unsigned m, unsigned n) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="uncoveredLine">  assert(u && "Must provide dividend");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="uncoveredLine">  assert(v && "Must provide divisor");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="uncoveredLine">  assert(q && "Must provide quotient");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="uncoveredLine">  assert(u != v && u != q && v != q && "Must use different memory");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="uncoveredLine">  assert(n>1 && "n must be > 1");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="">  // b denotes the base of the number system. In our case b is 2^32.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="uncoveredLine">  const uint64_t b = uint64_t(1) << 32;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="">// The DEBUG macros here tend to be spam in the debug output if you're not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="">// debugging this code. Disable them unless KNUTH_DEBUG is defined.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="">#ifdef KNUTH_DEBUG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="">#define DEBUG_KNUTH(X) LLVM_DEBUG(X)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="">#else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="">#define DEBUG_KNUTH(X) do {} while(false)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="">  DEBUG_KNUTH(dbgs() << "KnuthDiv: m=" << m << " n=" << n << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="">  DEBUG_KNUTH(dbgs() << "KnuthDiv: original:");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="">  DEBUG_KNUTH(for (int i = m + n; i >= 0; i--) dbgs() << " " << u[i]);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="">  DEBUG_KNUTH(dbgs() << " by");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="">  DEBUG_KNUTH(for (int i = n; i > 0; i--) dbgs() << " " << v[i - 1]);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="">  DEBUG_KNUTH(dbgs() << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="">  // D1. [Normalize.] Set d = b / (v[n-1] + 1) and multiply all the digits of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="">  // u and v by d. Note that we have taken Knuth's advice here to use a power</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="">  // of 2 value for d such that d * v[n-1] >= b/2 (b is the base). A power of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="">  // 2 allows us to shift instead of multiply and it is easy to determine the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="">  // shift amount from the leading zeros.  We are basically normalizing the u</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="">  // and v so that its high bits are shifted to the top of v's range without</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="">  // overflow. Note that this can require an extra word in u so that u must</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="">  // be of length m+n+1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="uncoveredLine">  unsigned shift = llvm::countl_zero(v[n - 1]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="uncoveredLine">  uint32_t v_carry = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="uncoveredLine">  uint32_t u_carry = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="uncoveredLine">  if (shift) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="uncoveredLine">    for (unsigned i = 0; i < m+n; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="uncoveredLine">      uint32_t u_tmp = u[i] >> (32 - shift);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="uncoveredLine">      u[i] = (u[i] << shift) | u_carry;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="uncoveredLine">      u_carry = u_tmp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="uncoveredLine">    for (unsigned i = 0; i < n; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="uncoveredLine">      uint32_t v_tmp = v[i] >> (32 - shift);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="uncoveredLine">      v[i] = (v[i] << shift) | v_carry;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="uncoveredLine">      v_carry = v_tmp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="uncoveredLine">  u[m+n] = u_carry;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="">  DEBUG_KNUTH(dbgs() << "KnuthDiv:   normal:");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="">  DEBUG_KNUTH(for (int i = m + n; i >= 0; i--) dbgs() << " " << u[i]);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="">  DEBUG_KNUTH(dbgs() << " by");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="">  DEBUG_KNUTH(for (int i = n; i > 0; i--) dbgs() << " " << v[i - 1]);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="">  DEBUG_KNUTH(dbgs() << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="">  // D2. [Initialize j.]  Set j to m. This is the loop counter over the places.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="uncoveredLine">  int j = m;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="">  do {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="">    DEBUG_KNUTH(dbgs() << "KnuthDiv: quotient digit #" << j << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="">    // D3. [Calculate q'.].</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="">    //     Set qp = (u[j+n]*b + u[j+n-1]) / v[n-1]. (qp=qprime=q')</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="">    //     Set rp = (u[j+n]*b + u[j+n-1]) % v[n-1]. (rp=rprime=r')</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="">    // Now test if qp == b or qp*v[n-2] > b*rp + u[j+n-2]; if so, decrease</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="">    // qp by 1, increase rp by v[n-1], and repeat this test if rp < b. The test</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="">    // on v[n-2] determines at high speed most of the cases in which the trial</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="">    // value qp is one too large, and it eliminates all cases where qp is two</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="">    // too large.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="uncoveredLine">    uint64_t dividend = Make_64(u[j+n], u[j+n-1]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="">    DEBUG_KNUTH(dbgs() << "KnuthDiv: dividend == " << dividend << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="uncoveredLine">    uint64_t qp = dividend / v[n-1];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="uncoveredLine">    uint64_t rp = dividend % v[n-1];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="uncoveredLine">    if (qp == b || qp*v[n-2] > b*rp + u[j+n-2]) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="uncoveredLine">      qp--;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="uncoveredLine">      rp += v[n-1];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="uncoveredLine">      if (rp < b && (qp == b || qp*v[n-2] > b*rp + u[j+n-2]))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="uncoveredLine">        qp--;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="">    DEBUG_KNUTH(dbgs() << "KnuthDiv: qp == " << qp << ", rp == " << rp << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="">    // D4. [Multiply and subtract.] Replace (u[j+n]u[j+n-1]...u[j]) with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="">    // (u[j+n]u[j+n-1]..u[j]) - qp * (v[n-1]...v[1]v[0]). This computation</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="">    // consists of a simple multiplication by a one-place number, combined with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="">    // a subtraction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="">    // The digits (u[j+n]...u[j]) should be kept positive; if the result of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="">    // this step is actually negative, (u[j+n]...u[j]) should be left as the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="">    // true value plus b**(n+1), namely as the b's complement of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="">    // the true value, and a "borrow" to the left should be remembered.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="uncoveredLine">    int64_t borrow = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="uncoveredLine">    for (unsigned i = 0; i < n; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="uncoveredLine">      uint64_t p = uint64_t(qp) * uint64_t(v[i]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="uncoveredLine">      int64_t subres = int64_t(u[j+i]) - borrow - Lo_32(p);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="uncoveredLine">      u[j+i] = Lo_32(subres);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="uncoveredLine">      borrow = Hi_32(p) - Hi_32(subres);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="">      DEBUG_KNUTH(dbgs() << "KnuthDiv: u[j+i] = " << u[j + i]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="">                        << ", borrow = " << borrow << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="uncoveredLine">    bool isNeg = u[j+n] < borrow;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="uncoveredLine">    u[j+n] -= Lo_32(borrow);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="">    DEBUG_KNUTH(dbgs() << "KnuthDiv: after subtraction:");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="">    DEBUG_KNUTH(for (int i = m + n; i >= 0; i--) dbgs() << " " << u[i]);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="">    DEBUG_KNUTH(dbgs() << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="">    // D5. [Test remainder.] Set q[j] = qp. If the result of step D4 was</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="">    // negative, go to step D6; otherwise go on to step D7.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="uncoveredLine">    q[j] = Lo_32(qp);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="uncoveredLine">    if (isNeg) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="">      // D6. [Add back]. The probability that this step is necessary is very</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="">      // small, on the order of only 2/b. Make sure that test data accounts for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="">      // this possibility. Decrease q[j] by 1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="uncoveredLine">      q[j]--;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="">      // and add (0v[n-1]...v[1]v[0]) to (u[j+n]u[j+n-1]...u[j+1]u[j]).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="">      // A carry will occur to the left of u[j+n], and it should be ignored</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="">      // since it cancels with the borrow that occurred in D4.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="uncoveredLine">      bool carry = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="uncoveredLine">      for (unsigned i = 0; i < n; i++) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="uncoveredLine">        uint32_t limit = std::min(u[j+i],v[i]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="uncoveredLine">        u[j+i] += v[i] + carry;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="uncoveredLine">        carry = u[j+i] < limit || (carry && u[j+i] == limit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="uncoveredLine">      u[j+n] += carry;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="">    DEBUG_KNUTH(dbgs() << "KnuthDiv: after correction:");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="">    DEBUG_KNUTH(for (int i = m + n; i >= 0; i--) dbgs() << " " << u[i]);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="">    DEBUG_KNUTH(dbgs() << "\nKnuthDiv: digit result = " << q[j] << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="">    // D7. [Loop on j.]  Decrease j by one. Now if j >= 0, go back to D3.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="uncoveredLine">  } while (--j >= 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="">  DEBUG_KNUTH(dbgs() << "KnuthDiv: quotient:");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="">  DEBUG_KNUTH(for (int i = m; i >= 0; i--) dbgs() << " " << q[i]);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="">  DEBUG_KNUTH(dbgs() << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="">  // D8. [Unnormalize]. Now q[...] is the desired quotient, and the desired</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="">  // remainder may be obtained by dividing u[...] by d. If r is non-null we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="">  // compute the remainder (urem uses this).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="uncoveredLine">  if (r) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="">    // The value d is expressed by the "shift" value above since we avoided</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="">    // multiplication by d by using a shift left. So, all we have to do is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="">    // shift right here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="uncoveredLine">    if (shift) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="uncoveredLine">      uint32_t carry = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="">      DEBUG_KNUTH(dbgs() << "KnuthDiv: remainder:");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="uncoveredLine">      for (int i = n-1; i >= 0; i--) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="uncoveredLine">        r[i] = (u[i] >> shift) | carry;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="uncoveredLine">        carry = u[i] << (32 - shift);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="">        DEBUG_KNUTH(dbgs() << " " << r[i]);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="uncoveredLine">      for (int i = n-1; i >= 0; i--) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="uncoveredLine">        r[i] = u[i];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="">        DEBUG_KNUTH(dbgs() << " " << r[i]);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="">    DEBUG_KNUTH(dbgs() << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="">  DEBUG_KNUTH(dbgs() << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="uncoveredLine">void APInt::divide(const WordType *LHS, unsigned lhsWords, const WordType *RHS,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="">                   unsigned rhsWords, WordType *Quotient, WordType *Remainder) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="uncoveredLine">  assert(lhsWords >= rhsWords && "Fractional result");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="">  // First, compose the values into an array of 32-bit words instead of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="">  // 64-bit words. This is a necessity of both the "short division" algorithm</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="">  // and the Knuth "classical algorithm" which requires there to be native</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="">  // operations for +, -, and * on an m bit value with an m*2 bit result. We</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="">  // can't use 64-bit operands here because we don't have native results of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="">  // 128-bits. Furthermore, casting the 64-bit values to 32-bit values won't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="">  // work on large-endian machines.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="uncoveredLine">  unsigned n = rhsWords * 2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="uncoveredLine">  unsigned m = (lhsWords * 2) - n;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="">  // Allocate space for the temporary values we need either on the stack, if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="">  // it will fit, or on the heap if it won't.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="">  uint32_t SPACE[128];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="uncoveredLine">  uint32_t *U = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="uncoveredLine">  uint32_t *V = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="uncoveredLine">  uint32_t *Q = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="uncoveredLine">  uint32_t *R = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="uncoveredLine">  if ((Remainder?4:3)*n+2*m+1 <= 128) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="uncoveredLine">    U = &SPACE[0];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="uncoveredLine">    V = &SPACE[m+n+1];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="uncoveredLine">    Q = &SPACE[(m+n+1) + n];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="uncoveredLine">    if (Remainder)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="uncoveredLine">      R = &SPACE[(m+n+1) + n + (m+n)];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="uncoveredLine">    U = new uint32_t[m + n + 1];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="uncoveredLine">    V = new uint32_t[n];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="uncoveredLine">    Q = new uint32_t[m+n];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="uncoveredLine">    if (Remainder)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="uncoveredLine">      R = new uint32_t[n];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="">  // Initialize the dividend</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="uncoveredLine">  memset(U, 0, (m+n+1)*sizeof(uint32_t));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="uncoveredLine">  for (unsigned i = 0; i < lhsWords; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="uncoveredLine">    uint64_t tmp = LHS[i];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="uncoveredLine">    U[i * 2] = Lo_32(tmp);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="uncoveredLine">    U[i * 2 + 1] = Hi_32(tmp);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="uncoveredLine">  U[m+n] = 0; // this extra word is for "spill" in the Knuth algorithm.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="">  // Initialize the divisor</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="uncoveredLine">  memset(V, 0, (n)*sizeof(uint32_t));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="uncoveredLine">  for (unsigned i = 0; i < rhsWords; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="uncoveredLine">    uint64_t tmp = RHS[i];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="uncoveredLine">    V[i * 2] = Lo_32(tmp);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="uncoveredLine">    V[i * 2 + 1] = Hi_32(tmp);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="">  // initialize the quotient and remainder</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="uncoveredLine">  memset(Q, 0, (m+n) * sizeof(uint32_t));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="uncoveredLine">  if (Remainder)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="uncoveredLine">    memset(R, 0, n * sizeof(uint32_t));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="">  // Now, adjust m and n for the Knuth division. n is the number of words in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="">  // the divisor. m is the number of words by which the dividend exceeds the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="">  // divisor (i.e. m+n is the length of the dividend). These sizes must not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="">  // contain any zero words or the Knuth algorithm fails.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="uncoveredLine">  for (unsigned i = n; i > 0 && V[i-1] == 0; i--) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="uncoveredLine">    n--;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="uncoveredLine">    m++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="uncoveredLine">  for (unsigned i = m+n; i > 0 && U[i-1] == 0; i--)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="uncoveredLine">    m--;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="">  // If we're left with only a single word for the divisor, Knuth doesn't work</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="">  // so we implement the short division algorithm here. This is much simpler</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="">  // and faster because we are certain that we can divide a 64-bit quantity</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="">  // by a 32-bit quantity at hardware speed and short division is simply a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="">  // series of such operations. This is just like doing short division but we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="">  // are using base 2^32 instead of base 10.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="uncoveredLine">  assert(n != 0 && "Divide by zero?");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="uncoveredLine">  if (n == 1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="uncoveredLine">    uint32_t divisor = V[0];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="uncoveredLine">    uint32_t remainder = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="uncoveredLine">    for (int i = m; i >= 0; i--) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="uncoveredLine">      uint64_t partial_dividend = Make_64(remainder, U[i]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="uncoveredLine">      if (partial_dividend == 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="uncoveredLine">        Q[i] = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="uncoveredLine">        remainder = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="uncoveredLine">      } else if (partial_dividend < divisor) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="uncoveredLine">        Q[i] = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="uncoveredLine">        remainder = Lo_32(partial_dividend);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="uncoveredLine">      } else if (partial_dividend == divisor) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="uncoveredLine">        Q[i] = 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="uncoveredLine">        remainder = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="uncoveredLine">        Q[i] = Lo_32(partial_dividend / divisor);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="uncoveredLine">        remainder = Lo_32(partial_dividend - (Q[i] * divisor));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="uncoveredLine">    if (R)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="uncoveredLine">      R[0] = remainder;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="">    // Now we're ready to invoke the Knuth classical divide algorithm. In this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="">    // case n > 1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="uncoveredLine">    KnuthDiv(U, V, Q, R, m, n);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="">  // If the caller wants the quotient</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="uncoveredLine">  if (Quotient) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="uncoveredLine">    for (unsigned i = 0; i < lhsWords; ++i)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="uncoveredLine">      Quotient[i] = Make_64(Q[i*2+1], Q[i*2]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="">  // If the caller wants the remainder</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="uncoveredLine">  if (Remainder) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="uncoveredLine">    for (unsigned i = 0; i < rhsWords; ++i)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="uncoveredLine">      Remainder[i] = Make_64(R[i*2+1], R[i*2]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="">  // Clean up the memory we allocated.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="uncoveredLine">  if (U != &SPACE[0]) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="uncoveredLine">    delete [] U;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="uncoveredLine">    delete [] V;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="uncoveredLine">    delete [] Q;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="uncoveredLine">    delete [] R;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="uncoveredLine">APInt APInt::udiv(const APInt &RHS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="uncoveredLine">  assert(BitWidth == RHS.BitWidth && "Bit widths must be the same");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="">  // First, deal with the easy case</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="uncoveredLine">  if (isSingleWord()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="uncoveredLine">    assert(RHS.U.VAL != 0 && "Divide by zero?");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="uncoveredLine">    return APInt(BitWidth, U.VAL / RHS.U.VAL);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="">  // Get some facts about the LHS and RHS number of bits and words</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="uncoveredLine">  unsigned lhsWords = getNumWords(getActiveBits());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="uncoveredLine">  unsigned rhsBits  = RHS.getActiveBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="uncoveredLine">  unsigned rhsWords = getNumWords(rhsBits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="uncoveredLine">  assert(rhsWords && "Divided by zero???");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="">  // Deal with some degenerate cases</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="uncoveredLine">  if (!lhsWords)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="">    // 0 / X ===> 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="uncoveredLine">    return APInt(BitWidth, 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="uncoveredLine">  if (rhsBits == 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="">    // X / 1 ===> X</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="uncoveredLine">    return *this;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="uncoveredLine">  if (lhsWords < rhsWords || this->ult(RHS))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="">    // X / Y ===> 0, iff X < Y</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="uncoveredLine">    return APInt(BitWidth, 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="uncoveredLine">  if (*this == RHS)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="">    // X / X ===> 1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="uncoveredLine">    return APInt(BitWidth, 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="uncoveredLine">  if (lhsWords == 1) // rhsWords is 1 if lhsWords is 1.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="">    // All high words are zero, just use native divide</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="uncoveredLine">    return APInt(BitWidth, this->U.pVal[0] / RHS.U.pVal[0]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="">  // We have to compute it the hard way. Invoke the Knuth divide algorithm.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="uncoveredLine">  APInt Quotient(BitWidth, 0); // to hold result.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="uncoveredLine">  divide(U.pVal, lhsWords, RHS.U.pVal, rhsWords, Quotient.U.pVal, nullptr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="uncoveredLine">  return Quotient;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="uncoveredLine">APInt APInt::udiv(uint64_t RHS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="uncoveredLine">  assert(RHS != 0 && "Divide by zero?");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="">  // First, deal with the easy case</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="uncoveredLine">  if (isSingleWord())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="uncoveredLine">    return APInt(BitWidth, U.VAL / RHS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="">  // Get some facts about the LHS words.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="uncoveredLine">  unsigned lhsWords = getNumWords(getActiveBits());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="">  // Deal with some degenerate cases</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="uncoveredLine">  if (!lhsWords)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="">    // 0 / X ===> 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="uncoveredLine">    return APInt(BitWidth, 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="uncoveredLine">  if (RHS == 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="">    // X / 1 ===> X</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="uncoveredLine">    return *this;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="uncoveredLine">  if (this->ult(RHS))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="">    // X / Y ===> 0, iff X < Y</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="uncoveredLine">    return APInt(BitWidth, 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="uncoveredLine">  if (*this == RHS)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="">    // X / X ===> 1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="uncoveredLine">    return APInt(BitWidth, 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="uncoveredLine">  if (lhsWords == 1) // rhsWords is 1 if lhsWords is 1.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="">    // All high words are zero, just use native divide</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="uncoveredLine">    return APInt(BitWidth, this->U.pVal[0] / RHS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="">  // We have to compute it the hard way. Invoke the Knuth divide algorithm.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="uncoveredLine">  APInt Quotient(BitWidth, 0); // to hold result.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="uncoveredLine">  divide(U.pVal, lhsWords, &RHS, 1, Quotient.U.pVal, nullptr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="uncoveredLine">  return Quotient;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="uncoveredLine">APInt APInt::sdiv(const APInt &RHS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="uncoveredLine">  if (isNegative()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="uncoveredLine">    if (RHS.isNegative())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="uncoveredLine">      return (-(*this)).udiv(-RHS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="uncoveredLine">    return -((-(*this)).udiv(RHS));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="uncoveredLine">  if (RHS.isNegative())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="uncoveredLine">    return -(this->udiv(-RHS));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="uncoveredLine">  return this->udiv(RHS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="uncoveredLine">APInt APInt::sdiv(int64_t RHS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="uncoveredLine">  if (isNegative()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="uncoveredLine">    if (RHS < 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="uncoveredLine">      return (-(*this)).udiv(-RHS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="uncoveredLine">    return -((-(*this)).udiv(RHS));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="uncoveredLine">  if (RHS < 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="uncoveredLine">    return -(this->udiv(-RHS));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="uncoveredLine">  return this->udiv(RHS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="uncoveredLine">APInt APInt::urem(const APInt &RHS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="uncoveredLine">  assert(BitWidth == RHS.BitWidth && "Bit widths must be the same");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="uncoveredLine">  if (isSingleWord()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="uncoveredLine">    assert(RHS.U.VAL != 0 && "Remainder by zero?");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="uncoveredLine">    return APInt(BitWidth, U.VAL % RHS.U.VAL);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="">  // Get some facts about the LHS</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="uncoveredLine">  unsigned lhsWords = getNumWords(getActiveBits());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="">  // Get some facts about the RHS</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="uncoveredLine">  unsigned rhsBits = RHS.getActiveBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="uncoveredLine">  unsigned rhsWords = getNumWords(rhsBits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="uncoveredLine">  assert(rhsWords && "Performing remainder operation by zero ???");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="">  // Check the degenerate cases</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="uncoveredLine">  if (lhsWords == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="">    // 0 % Y ===> 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="uncoveredLine">    return APInt(BitWidth, 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="uncoveredLine">  if (rhsBits == 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="">    // X % 1 ===> 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="uncoveredLine">    return APInt(BitWidth, 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="uncoveredLine">  if (lhsWords < rhsWords || this->ult(RHS))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="">    // X % Y ===> X, iff X < Y</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="uncoveredLine">    return *this;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="uncoveredLine">  if (*this == RHS)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="">    // X % X == 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="uncoveredLine">    return APInt(BitWidth, 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="uncoveredLine">  if (lhsWords == 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="">    // All high words are zero, just use native remainder</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="uncoveredLine">    return APInt(BitWidth, U.pVal[0] % RHS.U.pVal[0]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="">  // We have to compute it the hard way. Invoke the Knuth divide algorithm.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="uncoveredLine">  APInt Remainder(BitWidth, 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="uncoveredLine">  divide(U.pVal, lhsWords, RHS.U.pVal, rhsWords, nullptr, Remainder.U.pVal);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="uncoveredLine">  return Remainder;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="uncoveredLine">uint64_t APInt::urem(uint64_t RHS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="uncoveredLine">  assert(RHS != 0 && "Remainder by zero?");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="uncoveredLine">  if (isSingleWord())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="uncoveredLine">    return U.VAL % RHS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="">  // Get some facts about the LHS</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="uncoveredLine">  unsigned lhsWords = getNumWords(getActiveBits());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="">  // Check the degenerate cases</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="uncoveredLine">  if (lhsWords == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="">    // 0 % Y ===> 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="uncoveredLine">    return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="uncoveredLine">  if (RHS == 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="">    // X % 1 ===> 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="uncoveredLine">    return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="uncoveredLine">  if (this->ult(RHS))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="">    // X % Y ===> X, iff X < Y</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="uncoveredLine">    return getZExtValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="uncoveredLine">  if (*this == RHS)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="">    // X % X == 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="uncoveredLine">    return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="uncoveredLine">  if (lhsWords == 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="">    // All high words are zero, just use native remainder</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="uncoveredLine">    return U.pVal[0] % RHS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="">  // We have to compute it the hard way. Invoke the Knuth divide algorithm.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="">  uint64_t Remainder;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="uncoveredLine">  divide(U.pVal, lhsWords, &RHS, 1, nullptr, &Remainder);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="uncoveredLine">  return Remainder;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="uncoveredLine">APInt APInt::srem(const APInt &RHS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="uncoveredLine">  if (isNegative()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="uncoveredLine">    if (RHS.isNegative())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="uncoveredLine">      return -((-(*this)).urem(-RHS));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="uncoveredLine">    return -((-(*this)).urem(RHS));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="uncoveredLine">  if (RHS.isNegative())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="uncoveredLine">    return this->urem(-RHS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="uncoveredLine">  return this->urem(RHS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="uncoveredLine">int64_t APInt::srem(int64_t RHS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="uncoveredLine">  if (isNegative()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="uncoveredLine">    if (RHS < 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="uncoveredLine">      return -((-(*this)).urem(-RHS));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="uncoveredLine">    return -((-(*this)).urem(RHS));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="uncoveredLine">  if (RHS < 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="uncoveredLine">    return this->urem(-RHS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="uncoveredLine">  return this->urem(RHS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="uncoveredLine">void APInt::udivrem(const APInt &LHS, const APInt &RHS,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="">                    APInt &Quotient, APInt &Remainder) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="uncoveredLine">  assert(LHS.BitWidth == RHS.BitWidth && "Bit widths must be the same");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="uncoveredLine">  unsigned BitWidth = LHS.BitWidth;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="">  // First, deal with the easy case</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="uncoveredLine">  if (LHS.isSingleWord()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="uncoveredLine">    assert(RHS.U.VAL != 0 && "Divide by zero?");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="uncoveredLine">    uint64_t QuotVal = LHS.U.VAL / RHS.U.VAL;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="uncoveredLine">    uint64_t RemVal = LHS.U.VAL % RHS.U.VAL;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="uncoveredLine">    Quotient = APInt(BitWidth, QuotVal);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="uncoveredLine">    Remainder = APInt(BitWidth, RemVal);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="">  // Get some size facts about the dividend and divisor</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="uncoveredLine">  unsigned lhsWords = getNumWords(LHS.getActiveBits());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="uncoveredLine">  unsigned rhsBits  = RHS.getActiveBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="uncoveredLine">  unsigned rhsWords = getNumWords(rhsBits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="uncoveredLine">  assert(rhsWords && "Performing divrem operation by zero ???");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="">  // Check the degenerate cases</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="uncoveredLine">  if (lhsWords == 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="uncoveredLine">    Quotient = APInt(BitWidth, 0);    // 0 / Y ===> 0</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="uncoveredLine">    Remainder = APInt(BitWidth, 0);   // 0 % Y ===> 0</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="uncoveredLine">  if (rhsBits == 1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="uncoveredLine">    Quotient = LHS;                   // X / 1 ===> X</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="uncoveredLine">    Remainder = APInt(BitWidth, 0);   // X % 1 ===> 0</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="uncoveredLine">  if (lhsWords < rhsWords || LHS.ult(RHS)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="uncoveredLine">    Remainder = LHS;                  // X % Y ===> X, iff X < Y</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="uncoveredLine">    Quotient = APInt(BitWidth, 0);    // X / Y ===> 0, iff X < Y</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="uncoveredLine">  if (LHS == RHS) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="uncoveredLine">    Quotient  = APInt(BitWidth, 1);   // X / X ===> 1</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="uncoveredLine">    Remainder = APInt(BitWidth, 0);   // X % X ===> 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="">  // Make sure there is enough space to hold the results.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="">  // NOTE: This assumes that reallocate won't affect any bits if it doesn't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="">  // change the size. This is necessary if Quotient or Remainder is aliased</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="">  // with LHS or RHS.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="uncoveredLine">  Quotient.reallocate(BitWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="uncoveredLine">  Remainder.reallocate(BitWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="uncoveredLine">  if (lhsWords == 1) { // rhsWords is 1 if lhsWords is 1.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="">    // There is only one word to consider so use the native versions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="uncoveredLine">    uint64_t lhsValue = LHS.U.pVal[0];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="uncoveredLine">    uint64_t rhsValue = RHS.U.pVal[0];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="uncoveredLine">    Quotient = lhsValue / rhsValue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="uncoveredLine">    Remainder = lhsValue % rhsValue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="">  // Okay, lets do it the long way</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="uncoveredLine">  divide(LHS.U.pVal, lhsWords, RHS.U.pVal, rhsWords, Quotient.U.pVal,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="">         Remainder.U.pVal);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="">  // Clear the rest of the Quotient and Remainder.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="uncoveredLine">  std::memset(Quotient.U.pVal + lhsWords, 0,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="uncoveredLine">              (getNumWords(BitWidth) - lhsWords) * APINT_WORD_SIZE);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="uncoveredLine">  std::memset(Remainder.U.pVal + rhsWords, 0,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="uncoveredLine">              (getNumWords(BitWidth) - rhsWords) * APINT_WORD_SIZE);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="uncoveredLine">void APInt::udivrem(const APInt &LHS, uint64_t RHS, APInt &Quotient,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="">                    uint64_t &Remainder) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="uncoveredLine">  assert(RHS != 0 && "Divide by zero?");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="uncoveredLine">  unsigned BitWidth = LHS.BitWidth;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="">  // First, deal with the easy case</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="uncoveredLine">  if (LHS.isSingleWord()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="uncoveredLine">    uint64_t QuotVal = LHS.U.VAL / RHS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="uncoveredLine">    Remainder = LHS.U.VAL % RHS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="uncoveredLine">    Quotient = APInt(BitWidth, QuotVal);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="">  // Get some size facts about the dividend and divisor</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="uncoveredLine">  unsigned lhsWords = getNumWords(LHS.getActiveBits());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="">  // Check the degenerate cases</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="uncoveredLine">  if (lhsWords == 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="uncoveredLine">    Quotient = APInt(BitWidth, 0);    // 0 / Y ===> 0</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="uncoveredLine">    Remainder = 0;                    // 0 % Y ===> 0</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="uncoveredLine">  if (RHS == 1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="uncoveredLine">    Quotient = LHS;                   // X / 1 ===> X</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="uncoveredLine">    Remainder = 0;                    // X % 1 ===> 0</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="uncoveredLine">  if (LHS.ult(RHS)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="uncoveredLine">    Remainder = LHS.getZExtValue();   // X % Y ===> X, iff X < Y</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="uncoveredLine">    Quotient = APInt(BitWidth, 0);    // X / Y ===> 0, iff X < Y</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="uncoveredLine">  if (LHS == RHS) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="uncoveredLine">    Quotient  = APInt(BitWidth, 1);   // X / X ===> 1</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="uncoveredLine">    Remainder = 0;                    // X % X ===> 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="">  // Make sure there is enough space to hold the results.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="">  // NOTE: This assumes that reallocate won't affect any bits if it doesn't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="">  // change the size. This is necessary if Quotient is aliased with LHS.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="uncoveredLine">  Quotient.reallocate(BitWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="uncoveredLine">  if (lhsWords == 1) { // rhsWords is 1 if lhsWords is 1.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="">    // There is only one word to consider so use the native versions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="uncoveredLine">    uint64_t lhsValue = LHS.U.pVal[0];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="uncoveredLine">    Quotient = lhsValue / RHS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="uncoveredLine">    Remainder = lhsValue % RHS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="">  // Okay, lets do it the long way</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="uncoveredLine">  divide(LHS.U.pVal, lhsWords, &RHS, 1, Quotient.U.pVal, &Remainder);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="">  // Clear the rest of the Quotient.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="uncoveredLine">  std::memset(Quotient.U.pVal + lhsWords, 0,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="uncoveredLine">              (getNumWords(BitWidth) - lhsWords) * APINT_WORD_SIZE);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="uncoveredLine">void APInt::sdivrem(const APInt &LHS, const APInt &RHS,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="">                    APInt &Quotient, APInt &Remainder) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="uncoveredLine">  if (LHS.isNegative()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="uncoveredLine">    if (RHS.isNegative())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="uncoveredLine">      APInt::udivrem(-LHS, -RHS, Quotient, Remainder);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="">    else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="uncoveredLine">      APInt::udivrem(-LHS, RHS, Quotient, Remainder);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="uncoveredLine">      Quotient.negate();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="uncoveredLine">    Remainder.negate();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="uncoveredLine">  } else if (RHS.isNegative()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="uncoveredLine">    APInt::udivrem(LHS, -RHS, Quotient, Remainder);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="uncoveredLine">    Quotient.negate();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="uncoveredLine">    APInt::udivrem(LHS, RHS, Quotient, Remainder);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="uncoveredLine">void APInt::sdivrem(const APInt &LHS, int64_t RHS,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="">                    APInt &Quotient, int64_t &Remainder) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="uncoveredLine">  uint64_t R = Remainder;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="uncoveredLine">  if (LHS.isNegative()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="uncoveredLine">    if (RHS < 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="uncoveredLine">      APInt::udivrem(-LHS, -RHS, Quotient, R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="">    else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="uncoveredLine">      APInt::udivrem(-LHS, RHS, Quotient, R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="uncoveredLine">      Quotient.negate();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="uncoveredLine">    R = -R;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="uncoveredLine">  } else if (RHS < 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="uncoveredLine">    APInt::udivrem(LHS, -RHS, Quotient, R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="uncoveredLine">    Quotient.negate();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="uncoveredLine">    APInt::udivrem(LHS, RHS, Quotient, R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="uncoveredLine">  Remainder = R;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="uncoveredLine">APInt APInt::sadd_ov(const APInt &RHS, bool &Overflow) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="uncoveredLine">  APInt Res = *this+RHS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="uncoveredLine">  Overflow = isNonNegative() == RHS.isNonNegative() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="uncoveredLine">             Res.isNonNegative() != isNonNegative();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="uncoveredLine">  return Res;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="uncoveredLine">APInt APInt::uadd_ov(const APInt &RHS, bool &Overflow) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="uncoveredLine">  APInt Res = *this+RHS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="uncoveredLine">  Overflow = Res.ult(RHS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="uncoveredLine">  return Res;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="uncoveredLine">APInt APInt::ssub_ov(const APInt &RHS, bool &Overflow) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="uncoveredLine">  APInt Res = *this - RHS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="uncoveredLine">  Overflow = isNonNegative() != RHS.isNonNegative() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="uncoveredLine">             Res.isNonNegative() != isNonNegative();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="uncoveredLine">  return Res;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="uncoveredLine">APInt APInt::usub_ov(const APInt &RHS, bool &Overflow) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="uncoveredLine">  APInt Res = *this-RHS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="uncoveredLine">  Overflow = Res.ugt(*this);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="uncoveredLine">  return Res;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="uncoveredLine">APInt APInt::sdiv_ov(const APInt &RHS, bool &Overflow) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="">  // MININT/-1  -->  overflow.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="uncoveredLine">  Overflow = isMinSignedValue() && RHS.isAllOnes();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="uncoveredLine">  return sdiv(RHS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="uncoveredLine">APInt APInt::smul_ov(const APInt &RHS, bool &Overflow) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="uncoveredLine">  APInt Res = *this * RHS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="uncoveredLine">  if (RHS != 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="uncoveredLine">    Overflow = Res.sdiv(RHS) != *this ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="uncoveredLine">               (isMinSignedValue() && RHS.isAllOnes());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="uncoveredLine">    Overflow = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="uncoveredLine">  return Res;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="uncoveredLine">APInt APInt::umul_ov(const APInt &RHS, bool &Overflow) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="uncoveredLine">  if (countl_zero() + RHS.countl_zero() + 2 <= BitWidth) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="uncoveredLine">    Overflow = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="uncoveredLine">    return *this * RHS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="uncoveredLine">  APInt Res = lshr(1) * RHS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="uncoveredLine">  Overflow = Res.isNegative();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="uncoveredLine">  Res <<= 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="uncoveredLine">  if ((*this)[0]) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="uncoveredLine">    Res += RHS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="uncoveredLine">    if (Res.ult(RHS))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="uncoveredLine">      Overflow = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="uncoveredLine">  return Res;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="uncoveredLine">APInt APInt::sshl_ov(const APInt &ShAmt, bool &Overflow) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="uncoveredLine">  return sshl_ov(ShAmt.getLimitedValue(getBitWidth()), Overflow);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="uncoveredLine">APInt APInt::sshl_ov(unsigned ShAmt, bool &Overflow) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="uncoveredLine">  Overflow = ShAmt >= getBitWidth();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="uncoveredLine">  if (Overflow)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="uncoveredLine">    return APInt(BitWidth, 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="uncoveredLine">  if (isNonNegative()) // Don't allow sign change.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="uncoveredLine">    Overflow = ShAmt >= countl_zero();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="uncoveredLine">    Overflow = ShAmt >= countl_one();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="uncoveredLine">  return *this << ShAmt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="uncoveredLine">APInt APInt::ushl_ov(const APInt &ShAmt, bool &Overflow) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="uncoveredLine">  return ushl_ov(ShAmt.getLimitedValue(getBitWidth()), Overflow);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="uncoveredLine">APInt APInt::ushl_ov(unsigned ShAmt, bool &Overflow) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="uncoveredLine">  Overflow = ShAmt >= getBitWidth();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="uncoveredLine">  if (Overflow)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="uncoveredLine">    return APInt(BitWidth, 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="uncoveredLine">  Overflow = ShAmt > countl_zero();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="uncoveredLine">  return *this << ShAmt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="uncoveredLine">APInt APInt::sadd_sat(const APInt &RHS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="">  bool Overflow;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="uncoveredLine">  APInt Res = sadd_ov(RHS, Overflow);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="uncoveredLine">  if (!Overflow)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="uncoveredLine">    return Res;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="uncoveredLine">  return isNegative() ? APInt::getSignedMinValue(BitWidth)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="uncoveredLine">                      : APInt::getSignedMaxValue(BitWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="uncoveredLine">APInt APInt::uadd_sat(const APInt &RHS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="">  bool Overflow;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="uncoveredLine">  APInt Res = uadd_ov(RHS, Overflow);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="uncoveredLine">  if (!Overflow)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="uncoveredLine">    return Res;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="uncoveredLine">  return APInt::getMaxValue(BitWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="uncoveredLine">APInt APInt::ssub_sat(const APInt &RHS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="">  bool Overflow;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="uncoveredLine">  APInt Res = ssub_ov(RHS, Overflow);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="uncoveredLine">  if (!Overflow)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="uncoveredLine">    return Res;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="uncoveredLine">  return isNegative() ? APInt::getSignedMinValue(BitWidth)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="uncoveredLine">                      : APInt::getSignedMaxValue(BitWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="uncoveredLine">APInt APInt::usub_sat(const APInt &RHS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="">  bool Overflow;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="uncoveredLine">  APInt Res = usub_ov(RHS, Overflow);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="uncoveredLine">  if (!Overflow)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="uncoveredLine">    return Res;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="uncoveredLine">  return APInt(BitWidth, 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="uncoveredLine">APInt APInt::smul_sat(const APInt &RHS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="">  bool Overflow;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="uncoveredLine">  APInt Res = smul_ov(RHS, Overflow);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="uncoveredLine">  if (!Overflow)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="uncoveredLine">    return Res;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="">  // The result is negative if one and only one of inputs is negative.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="uncoveredLine">  bool ResIsNegative = isNegative() ^ RHS.isNegative();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="uncoveredLine">  return ResIsNegative ? APInt::getSignedMinValue(BitWidth)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="uncoveredLine">                       : APInt::getSignedMaxValue(BitWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="uncoveredLine">APInt APInt::umul_sat(const APInt &RHS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="">  bool Overflow;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="uncoveredLine">  APInt Res = umul_ov(RHS, Overflow);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="uncoveredLine">  if (!Overflow)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="uncoveredLine">    return Res;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="uncoveredLine">  return APInt::getMaxValue(BitWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="uncoveredLine">APInt APInt::sshl_sat(const APInt &RHS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="uncoveredLine">  return sshl_sat(RHS.getLimitedValue(getBitWidth()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="uncoveredLine">APInt APInt::sshl_sat(unsigned RHS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="">  bool Overflow;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="uncoveredLine">  APInt Res = sshl_ov(RHS, Overflow);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="uncoveredLine">  if (!Overflow)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="uncoveredLine">    return Res;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="uncoveredLine">  return isNegative() ? APInt::getSignedMinValue(BitWidth)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="uncoveredLine">                      : APInt::getSignedMaxValue(BitWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="uncoveredLine">APInt APInt::ushl_sat(const APInt &RHS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="uncoveredLine">  return ushl_sat(RHS.getLimitedValue(getBitWidth()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="uncoveredLine">APInt APInt::ushl_sat(unsigned RHS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="">  bool Overflow;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="uncoveredLine">  APInt Res = ushl_ov(RHS, Overflow);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="uncoveredLine">  if (!Overflow)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="uncoveredLine">    return Res;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="uncoveredLine">  return APInt::getMaxValue(BitWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="coveredLine">void APInt::fromString(unsigned numbits, StringRef str, uint8_t radix) {</td>
    <td>171</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="">  // Check our assumptions here</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="coveredLine">  assert(!str.empty() && "Invalid string length");</td>
    <td>171</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="coveredLine">  assert((radix == 10 || radix == 8 || radix == 16 || radix == 2 ||</td>
    <td>171</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="">          radix == 36) &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="">         "Radix should be 2, 8, 10, 16, or 36!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="coveredLine">  StringRef::iterator p = str.begin();</td>
    <td>171</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="coveredLine">  size_t slen = str.size();</td>
    <td>171</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="coveredLine">  bool isNeg = *p == '-';</td>
    <td>171</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="coveredLine">  if (*p == '-' || *p == '+') {</td>
    <td>171</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="uncoveredLine">    p++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="uncoveredLine">    slen--;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="uncoveredLine">    assert(slen && "String is only a sign, needs a value.");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="coveredLine">  assert((slen <= numbits || radix != 2) && "Insufficient bit width");</td>
    <td>171</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="coveredLine">  assert(((slen-1)*3 <= numbits || radix != 8) && "Insufficient bit width");</td>
    <td>171</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="coveredLine">  assert(((slen-1)*4 <= numbits || radix != 16) && "Insufficient bit width");</td>
    <td>171</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="coveredLine">  assert((((slen-1)*64)/22 <= numbits || radix != 10) &&</td>
    <td>171</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="">         "Insufficient bit width");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="">  // Allocate memory if needed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="coveredLine">  if (isSingleWord())</td>
    <td>171</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="coveredLine">    U.VAL = 0;</td>
    <td>171</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="uncoveredLine">    U.pVal = getClearedMemory(getNumWords());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="">  // Figure out if we can shift instead of multiply</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="coveredLine">  unsigned shift = (radix == 16 ? 4 : radix == 8 ? 3 : radix == 2 ? 1 : 0);</td>
    <td>171</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="">  // Enter digit traversal loop</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="coveredLine">  for (StringRef::iterator e = str.end(); p != e; ++p) {</td>
    <td>408</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="coveredLine">    unsigned digit = getDigit(*p, radix);</td>
    <td>237</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="coveredLine">    assert(digit < radix && "Invalid character in digit string");</td>
    <td>237</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="">    // Shift or multiply the value by the radix</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="coveredLine">    if (slen > 1) {</td>
    <td>237</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="coveredLine">      if (shift)</td>
    <td>132</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="uncoveredLine">        *this <<= shift;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="">      else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="coveredLine">        *this *= radix;</td>
    <td>132</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="">    // Add in the digit we just interpreted</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="coveredLine">    *this += digit;</td>
    <td>237</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="">  // If its negative, put it in two's complement form</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="coveredLine">  if (isNeg)</td>
    <td>171</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="uncoveredLine">    this->negate();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="coveredLine">}</td>
    <td>171</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="uncoveredLine">void APInt::toString(SmallVectorImpl<char> &Str, unsigned Radix, bool Signed,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="">                     bool formatAsCLiteral, bool UpperCase) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="uncoveredLine">  assert((Radix == 10 || Radix == 8 || Radix == 16 || Radix == 2 ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="">          Radix == 36) &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="">         "Radix should be 2, 8, 10, 16, or 36!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="uncoveredLine">  const char *Prefix = "";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="uncoveredLine">  if (formatAsCLiteral) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="uncoveredLine">    switch (Radix) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="uncoveredLine">      case 2:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="">        // Binary literals are a non-standard extension added in gcc 4.3:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="">        // http://gcc.gnu.org/onlinedocs/gcc-4.3.0/gcc/Binary-constants.html</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="uncoveredLine">        Prefix = "0b";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="uncoveredLine">      case 8:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="uncoveredLine">        Prefix = "0";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="uncoveredLine">      case 10:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="uncoveredLine">        break; // No prefix</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="uncoveredLine">      case 16:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="uncoveredLine">        Prefix = "0x";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="uncoveredLine">      default:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="uncoveredLine">        llvm_unreachable("Invalid radix!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="">  // First, check for a zero value and just short circuit the logic below.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="uncoveredLine">  if (isZero()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="uncoveredLine">    while (*Prefix) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="uncoveredLine">      Str.push_back(*Prefix);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="uncoveredLine">      ++Prefix;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="">    };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="uncoveredLine">    Str.push_back('0');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="">  static const char BothDigits[] = "0123456789abcdefghijklmnopqrstuvwxyz"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="">                                   "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="uncoveredLine">  const char *Digits = BothDigits + (UpperCase ? 36 : 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="uncoveredLine">  if (isSingleWord()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="">    char Buffer[65];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="uncoveredLine">    char *BufPtr = std::end(Buffer);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="">    uint64_t N;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="uncoveredLine">    if (!Signed) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="uncoveredLine">      N = getZExtValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="uncoveredLine">      int64_t I = getSExtValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="uncoveredLine">      if (I >= 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="uncoveredLine">        N = I;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="uncoveredLine">        Str.push_back('-');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="uncoveredLine">        N = -(uint64_t)I;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="uncoveredLine">    while (*Prefix) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="uncoveredLine">      Str.push_back(*Prefix);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="uncoveredLine">      ++Prefix;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="">    };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="uncoveredLine">    while (N) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="uncoveredLine">      *--BufPtr = Digits[N % Radix];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="uncoveredLine">      N /= Radix;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="uncoveredLine">    Str.append(BufPtr, std::end(Buffer));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="uncoveredLine">  APInt Tmp(*this);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="uncoveredLine">  if (Signed && isNegative()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="">    // They want to print the signed version and it is a negative value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="">    // Flip the bits and add one to turn it into the equivalent positive</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="">    // value and put a '-' in the result.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="uncoveredLine">    Tmp.negate();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="uncoveredLine">    Str.push_back('-');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="uncoveredLine">  while (*Prefix) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="uncoveredLine">    Str.push_back(*Prefix);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="uncoveredLine">    ++Prefix;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="">  // We insert the digits backward, then reverse them to get the right order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="uncoveredLine">  unsigned StartDig = Str.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="">  // For the 2, 8 and 16 bit cases, we can just shift instead of divide</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="">  // because the number of bits per digit (1, 3 and 4 respectively) divides</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="">  // equally.  We just shift until the value is zero.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="uncoveredLine">  if (Radix == 2 || Radix == 8 || Radix == 16) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="">    // Just shift tmp right for each digit width until it becomes zero</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="uncoveredLine">    unsigned ShiftAmt = (Radix == 16 ? 4 : (Radix == 8 ? 3 : 1));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="uncoveredLine">    unsigned MaskAmt = Radix - 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="uncoveredLine">    while (Tmp.getBoolValue()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="uncoveredLine">      unsigned Digit = unsigned(Tmp.getRawData()[0]) & MaskAmt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="uncoveredLine">      Str.push_back(Digits[Digit]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="uncoveredLine">      Tmp.lshrInPlace(ShiftAmt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="uncoveredLine">  } else {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="uncoveredLine">    while (Tmp.getBoolValue()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="">      uint64_t Digit;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="uncoveredLine">      udivrem(Tmp, Radix, Tmp, Digit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="uncoveredLine">      assert(Digit < Radix && "divide failed");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="uncoveredLine">      Str.push_back(Digits[Digit]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="">  // Reverse the digits before returning.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="uncoveredLine">  std::reverse(Str.begin()+StartDig, Str.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="uncoveredLine">LLVM_DUMP_METHOD void APInt::dump() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="uncoveredLine">  SmallString<40> S, U;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="uncoveredLine">  this->toStringUnsigned(U);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="uncoveredLine">  this->toStringSigned(S);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="uncoveredLine">  dbgs() << "APInt(" << BitWidth << "b, "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="uncoveredLine">         << U << "u " << S << "s)\n";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="uncoveredLine">void APInt::print(raw_ostream &OS, bool isSigned) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="uncoveredLine">  SmallString<40> S;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="uncoveredLine">  this->toString(S, 10, isSigned, /* formatAsCLiteral = */false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="uncoveredLine">  OS << S;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="">// This implements a variety of operations on a representation of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="">// arbitrary precision, two's-complement, bignum integer values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="">// Assumed by lowHalf, highHalf, partMSB and partLSB.  A fairly safe</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="">// and unrestricting assumption.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="">static_assert(APInt::APINT_BITS_PER_WORD % 2 == 0,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="">              "Part width must be divisible by 2!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="">// Returns the integer part with the least significant BITS set.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="">// BITS cannot be zero.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="uncoveredLine">static inline APInt::WordType lowBitMask(unsigned bits) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="uncoveredLine">  assert(bits != 0 && bits <= APInt::APINT_BITS_PER_WORD);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="uncoveredLine">  return ~(APInt::WordType) 0 >> (APInt::APINT_BITS_PER_WORD - bits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="">/// Returns the value of the lower half of PART.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="uncoveredLine">static inline APInt::WordType lowHalf(APInt::WordType part) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="uncoveredLine">  return part & lowBitMask(APInt::APINT_BITS_PER_WORD / 2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="">/// Returns the value of the upper half of PART.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="uncoveredLine">static inline APInt::WordType highHalf(APInt::WordType part) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="uncoveredLine">  return part >> (APInt::APINT_BITS_PER_WORD / 2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="">/// Sets the least significant part of a bignum to the input value, and zeroes</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="">/// out higher parts.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="coveredLine">void APInt::tcSet(WordType *dst, WordType part, unsigned parts) {</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="coveredLine">  assert(parts > 0);</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="coveredLine">  dst[0] = part;</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="coveredLine">  for (unsigned i = 1; i < parts; i++)</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="uncoveredLine">    dst[i] = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="coveredLine">}</td>
    <td>67</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="">/// Assign one bignum to another.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="uncoveredLine">void APInt::tcAssign(WordType *dst, const WordType *src, unsigned parts) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="uncoveredLine">  for (unsigned i = 0; i < parts; i++)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="uncoveredLine">    dst[i] = src[i];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="">/// Returns true if a bignum is zero, false otherwise.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="uncoveredLine">bool APInt::tcIsZero(const WordType *src, unsigned parts) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="uncoveredLine">  for (unsigned i = 0; i < parts; i++)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="uncoveredLine">    if (src[i])</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="">/// Extract the given bit of a bignum; returns 0 or 1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="uncoveredLine">int APInt::tcExtractBit(const WordType *parts, unsigned bit) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="uncoveredLine">  return (parts[whichWord(bit)] & maskBit(bit)) != 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="">/// Set the given bit of a bignum.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="uncoveredLine">void APInt::tcSetBit(WordType *parts, unsigned bit) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="uncoveredLine">  parts[whichWord(bit)] |= maskBit(bit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="">/// Clears the given bit of a bignum.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="uncoveredLine">void APInt::tcClearBit(WordType *parts, unsigned bit) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="uncoveredLine">  parts[whichWord(bit)] &= ~maskBit(bit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="">/// Returns the bit number of the least significant set bit of a number.  If the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="">/// input number has no bits set UINT_MAX is returned.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="uncoveredLine">unsigned APInt::tcLSB(const WordType *parts, unsigned n) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="uncoveredLine">  for (unsigned i = 0; i < n; i++) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="uncoveredLine">    if (parts[i] != 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="uncoveredLine">      unsigned lsb = llvm::countr_zero(parts[i]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="uncoveredLine">      return lsb + i * APINT_BITS_PER_WORD;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="uncoveredLine">  return UINT_MAX;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="">/// Returns the bit number of the most significant set bit of a number.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="">/// If the input number has no bits set UINT_MAX is returned.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="uncoveredLine">unsigned APInt::tcMSB(const WordType *parts, unsigned n) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="">  do {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="uncoveredLine">    --n;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="uncoveredLine">    if (parts[n] != 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="">      static_assert(sizeof(parts[n]) <= sizeof(uint64_t));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="uncoveredLine">      unsigned msb = llvm::Log2_64(parts[n]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="uncoveredLine">      return msb + n * APINT_BITS_PER_WORD;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="uncoveredLine">  } while (n);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="uncoveredLine">  return UINT_MAX;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="">/// Copy the bit vector of width srcBITS from SRC, starting at bit srcLSB, to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="">/// DST, of dstCOUNT parts, such that the bit srcLSB becomes the least</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="">/// significant bit of DST.  All high bits above srcBITS in DST are zero-filled.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="">/// */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="">void</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="uncoveredLine">APInt::tcExtract(WordType *dst, unsigned dstCount, const WordType *src,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="">                 unsigned srcBits, unsigned srcLSB) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="uncoveredLine">  unsigned dstParts = (srcBits + APINT_BITS_PER_WORD - 1) / APINT_BITS_PER_WORD;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="uncoveredLine">  assert(dstParts <= dstCount);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="uncoveredLine">  unsigned firstSrcPart = srcLSB / APINT_BITS_PER_WORD;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="uncoveredLine">  tcAssign(dst, src + firstSrcPart, dstParts);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="uncoveredLine">  unsigned shift = srcLSB % APINT_BITS_PER_WORD;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="uncoveredLine">  tcShiftRight(dst, dstParts, shift);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="">  // We now have (dstParts * APINT_BITS_PER_WORD - shift) bits from SRC</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="">  // in DST.  If this is less that srcBits, append the rest, else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="">  // clear the high bits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="uncoveredLine">  unsigned n = dstParts * APINT_BITS_PER_WORD - shift;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="uncoveredLine">  if (n < srcBits) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="uncoveredLine">    WordType mask = lowBitMask (srcBits - n);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="uncoveredLine">    dst[dstParts - 1] |= ((src[firstSrcPart + dstParts] & mask)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="uncoveredLine">                          << n % APINT_BITS_PER_WORD);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="uncoveredLine">  } else if (n > srcBits) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="uncoveredLine">    if (srcBits % APINT_BITS_PER_WORD)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="uncoveredLine">      dst[dstParts - 1] &= lowBitMask (srcBits % APINT_BITS_PER_WORD);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="">  // Clear high parts.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="uncoveredLine">  while (dstParts < dstCount)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="uncoveredLine">    dst[dstParts++] = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="">//// DST += RHS + C where C is zero or one.  Returns the carry flag.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="uncoveredLine">APInt::WordType APInt::tcAdd(WordType *dst, const WordType *rhs,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="">                             WordType c, unsigned parts) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="uncoveredLine">  assert(c <= 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="uncoveredLine">  for (unsigned i = 0; i < parts; i++) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="uncoveredLine">    WordType l = dst[i];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="uncoveredLine">    if (c) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="uncoveredLine">      dst[i] += rhs[i] + 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="uncoveredLine">      c = (dst[i] <= l);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="uncoveredLine">      dst[i] += rhs[i];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="uncoveredLine">      c = (dst[i] < l);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="uncoveredLine">  return c;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="">/// This function adds a single "word" integer, src, to the multiple</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="">/// "word" integer array, dst[]. dst[] is modified to reflect the addition and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="">/// 1 is returned if there is a carry out, otherwise 0 is returned.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="">/// @returns the carry of the addition.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="uncoveredLine">APInt::WordType APInt::tcAddPart(WordType *dst, WordType src,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="">                                 unsigned parts) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="uncoveredLine">  for (unsigned i = 0; i < parts; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="uncoveredLine">    dst[i] += src;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="uncoveredLine">    if (dst[i] >= src)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="uncoveredLine">      return 0; // No need to carry so exit early.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="uncoveredLine">    src = 1; // Carry one to next digit.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="uncoveredLine">  return 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="">/// DST -= RHS + C where C is zero or one.  Returns the carry flag.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="uncoveredLine">APInt::WordType APInt::tcSubtract(WordType *dst, const WordType *rhs,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="">                                  WordType c, unsigned parts) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="uncoveredLine">  assert(c <= 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="uncoveredLine">  for (unsigned i = 0; i < parts; i++) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="uncoveredLine">    WordType l = dst[i];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="uncoveredLine">    if (c) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="uncoveredLine">      dst[i] -= rhs[i] + 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="uncoveredLine">      c = (dst[i] >= l);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="uncoveredLine">      dst[i] -= rhs[i];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="uncoveredLine">      c = (dst[i] > l);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="uncoveredLine">  return c;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2475</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2476</td>
    <td class="">/// This function subtracts a single "word" (64-bit word), src, from</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2477</td>
    <td class="">/// the multi-word integer array, dst[], propagating the borrowed 1 value until</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2478</td>
    <td class="">/// no further borrowing is needed or it runs out of "words" in dst.  The result</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2479</td>
    <td class="">/// is 1 if "borrowing" exhausted the digits in dst, or 0 if dst was not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2480</td>
    <td class="">/// exhausted. In other words, if src > dst then this function returns 1,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2481</td>
    <td class="">/// otherwise 0.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2482</td>
    <td class="">/// @returns the borrow out of the subtraction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2483</td>
    <td class="uncoveredLine">APInt::WordType APInt::tcSubtractPart(WordType *dst, WordType src,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2484</td>
    <td class="">                                      unsigned parts) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2485</td>
    <td class="uncoveredLine">  for (unsigned i = 0; i < parts; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2486</td>
    <td class="uncoveredLine">    WordType Dst = dst[i];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2487</td>
    <td class="uncoveredLine">    dst[i] -= src;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2488</td>
    <td class="uncoveredLine">    if (src <= Dst)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2489</td>
    <td class="uncoveredLine">      return 0; // No need to borrow so exit early.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2490</td>
    <td class="uncoveredLine">    src = 1; // We have to "borrow 1" from next "word"</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2491</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2492</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2493</td>
    <td class="uncoveredLine">  return 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2494</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2495</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2496</td>
    <td class="">/// Negate a bignum in-place.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2497</td>
    <td class="uncoveredLine">void APInt::tcNegate(WordType *dst, unsigned parts) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2498</td>
    <td class="uncoveredLine">  tcComplement(dst, parts);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2499</td>
    <td class="uncoveredLine">  tcIncrement(dst, parts);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2500</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2501</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2502</td>
    <td class="">/// DST += SRC * MULTIPLIER + CARRY   if add is true</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2503</td>
    <td class="">/// DST  = SRC * MULTIPLIER + CARRY   if add is false</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2504</td>
    <td class="">/// Requires 0 <= DSTPARTS <= SRCPARTS + 1.  If DST overlaps SRC</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2505</td>
    <td class="">/// they must start at the same point, i.e. DST == SRC.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2506</td>
    <td class="">/// If DSTPARTS == SRCPARTS + 1 no overflow occurs and zero is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2507</td>
    <td class="">/// returned.  Otherwise DST is filled with the least significant</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2508</td>
    <td class="">/// DSTPARTS parts of the result, and if all of the omitted higher</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2509</td>
    <td class="">/// parts were zero return zero, otherwise overflow occurred and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2510</td>
    <td class="">/// return one.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2511</td>
    <td class="uncoveredLine">int APInt::tcMultiplyPart(WordType *dst, const WordType *src,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2512</td>
    <td class="">                          WordType multiplier, WordType carry,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2513</td>
    <td class="">                          unsigned srcParts, unsigned dstParts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2514</td>
    <td class="">                          bool add) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2515</td>
    <td class="">  // Otherwise our writes of DST kill our later reads of SRC.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2516</td>
    <td class="uncoveredLine">  assert(dst <= src || dst >= src + srcParts);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2517</td>
    <td class="uncoveredLine">  assert(dstParts <= srcParts + 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2518</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2519</td>
    <td class="">  // N loops; minimum of dstParts and srcParts.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2520</td>
    <td class="uncoveredLine">  unsigned n = std::min(dstParts, srcParts);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2521</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2522</td>
    <td class="uncoveredLine">  for (unsigned i = 0; i < n; i++) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2523</td>
    <td class="">    // [LOW, HIGH] = MULTIPLIER * SRC[i] + DST[i] + CARRY.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2524</td>
    <td class="">    // This cannot overflow, because:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2525</td>
    <td class="">    //   (n - 1) * (n - 1) + 2 (n - 1) = (n - 1) * (n + 1)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2526</td>
    <td class="">    // which is less than n^2.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2527</td>
    <td class="uncoveredLine">    WordType srcPart = src[i];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2528</td>
    <td class="">    WordType low, mid, high;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2529</td>
    <td class="uncoveredLine">    if (multiplier == 0 || srcPart == 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2530</td>
    <td class="uncoveredLine">      low = carry;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2531</td>
    <td class="uncoveredLine">      high = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2532</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2533</td>
    <td class="uncoveredLine">      low = lowHalf(srcPart) * lowHalf(multiplier);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2534</td>
    <td class="uncoveredLine">      high = highHalf(srcPart) * highHalf(multiplier);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2535</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2536</td>
    <td class="uncoveredLine">      mid = lowHalf(srcPart) * highHalf(multiplier);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2537</td>
    <td class="uncoveredLine">      high += highHalf(mid);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2538</td>
    <td class="uncoveredLine">      mid <<= APINT_BITS_PER_WORD / 2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2539</td>
    <td class="uncoveredLine">      if (low + mid < low)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2540</td>
    <td class="uncoveredLine">        high++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2541</td>
    <td class="uncoveredLine">      low += mid;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2542</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2543</td>
    <td class="uncoveredLine">      mid = highHalf(srcPart) * lowHalf(multiplier);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2544</td>
    <td class="uncoveredLine">      high += highHalf(mid);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2545</td>
    <td class="uncoveredLine">      mid <<= APINT_BITS_PER_WORD / 2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2546</td>
    <td class="uncoveredLine">      if (low + mid < low)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2547</td>
    <td class="uncoveredLine">        high++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2548</td>
    <td class="uncoveredLine">      low += mid;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2549</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2550</td>
    <td class="">      // Now add carry.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2551</td>
    <td class="uncoveredLine">      if (low + carry < low)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2552</td>
    <td class="uncoveredLine">        high++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2553</td>
    <td class="uncoveredLine">      low += carry;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2554</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2555</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2556</td>
    <td class="uncoveredLine">    if (add) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2557</td>
    <td class="">      // And now DST[i], and store the new low part there.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2558</td>
    <td class="uncoveredLine">      if (low + dst[i] < low)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2559</td>
    <td class="uncoveredLine">        high++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2560</td>
    <td class="uncoveredLine">      dst[i] += low;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2561</td>
    <td class="">    } else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2562</td>
    <td class="uncoveredLine">      dst[i] = low;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2563</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2564</td>
    <td class="uncoveredLine">    carry = high;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2565</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2566</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2567</td>
    <td class="uncoveredLine">  if (srcParts < dstParts) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2568</td>
    <td class="">    // Full multiplication, there is no overflow.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2569</td>
    <td class="uncoveredLine">    assert(srcParts + 1 == dstParts);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2570</td>
    <td class="uncoveredLine">    dst[srcParts] = carry;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2571</td>
    <td class="uncoveredLine">    return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2572</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2573</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2574</td>
    <td class="">  // We overflowed if there is carry.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2575</td>
    <td class="uncoveredLine">  if (carry)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2576</td>
    <td class="uncoveredLine">    return 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2577</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2578</td>
    <td class="">  // We would overflow if any significant unwritten parts would be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2579</td>
    <td class="">  // non-zero.  This is true if any remaining src parts are non-zero</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2580</td>
    <td class="">  // and the multiplier is non-zero.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2581</td>
    <td class="uncoveredLine">  if (multiplier)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2582</td>
    <td class="uncoveredLine">    for (unsigned i = dstParts; i < srcParts; i++)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2583</td>
    <td class="uncoveredLine">      if (src[i])</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2584</td>
    <td class="uncoveredLine">        return 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2585</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2586</td>
    <td class="">  // We fitted in the narrow destination.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2587</td>
    <td class="uncoveredLine">  return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2588</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2589</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2590</td>
    <td class="">/// DST = LHS * RHS, where DST has the same width as the operands and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2591</td>
    <td class="">/// is filled with the least significant parts of the result.  Returns</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2592</td>
    <td class="">/// one if overflow occurred, otherwise zero.  DST must be disjoint</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2593</td>
    <td class="">/// from both operands.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2594</td>
    <td class="uncoveredLine">int APInt::tcMultiply(WordType *dst, const WordType *lhs,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2595</td>
    <td class="">                      const WordType *rhs, unsigned parts) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2596</td>
    <td class="uncoveredLine">  assert(dst != lhs && dst != rhs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2597</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2598</td>
    <td class="uncoveredLine">  int overflow = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2599</td>
    <td class="uncoveredLine">  tcSet(dst, 0, parts);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2600</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2601</td>
    <td class="uncoveredLine">  for (unsigned i = 0; i < parts; i++)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2602</td>
    <td class="uncoveredLine">    overflow |= tcMultiplyPart(&dst[i], lhs, rhs[i], 0, parts,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2603</td>
    <td class="">                               parts - i, true);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2604</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2605</td>
    <td class="uncoveredLine">  return overflow;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2606</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2607</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2608</td>
    <td class="">/// DST = LHS * RHS, where DST has width the sum of the widths of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2609</td>
    <td class="">/// operands. No overflow occurs. DST must be disjoint from both operands.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2610</td>
    <td class="uncoveredLine">void APInt::tcFullMultiply(WordType *dst, const WordType *lhs,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2611</td>
    <td class="">                           const WordType *rhs, unsigned lhsParts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2612</td>
    <td class="">                           unsigned rhsParts) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2613</td>
    <td class="">  // Put the narrower number on the LHS for less loops below.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2614</td>
    <td class="uncoveredLine">  if (lhsParts > rhsParts)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2615</td>
    <td class="uncoveredLine">    return tcFullMultiply (dst, rhs, lhs, rhsParts, lhsParts);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2616</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2617</td>
    <td class="uncoveredLine">  assert(dst != lhs && dst != rhs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2618</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2619</td>
    <td class="uncoveredLine">  tcSet(dst, 0, rhsParts);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2620</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2621</td>
    <td class="uncoveredLine">  for (unsigned i = 0; i < lhsParts; i++)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2622</td>
    <td class="uncoveredLine">    tcMultiplyPart(&dst[i], rhs, lhs[i], 0, rhsParts, rhsParts + 1, true);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2623</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2624</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2625</td>
    <td class="">// If RHS is zero LHS and REMAINDER are left unchanged, return one.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2626</td>
    <td class="">// Otherwise set LHS to LHS / RHS with the fractional part discarded,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2627</td>
    <td class="">// set REMAINDER to the remainder, return zero.  i.e.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2628</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2629</td>
    <td class="">//   OLD_LHS = RHS * LHS + REMAINDER</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2630</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2631</td>
    <td class="">// SCRATCH is a bignum of the same size as the operands and result for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2632</td>
    <td class="">// use by the routine; its contents need not be initialized and are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2633</td>
    <td class="">// destroyed.  LHS, REMAINDER and SCRATCH must be distinct.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2634</td>
    <td class="uncoveredLine">int APInt::tcDivide(WordType *lhs, const WordType *rhs,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2635</td>
    <td class="">                    WordType *remainder, WordType *srhs,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2636</td>
    <td class="">                    unsigned parts) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2637</td>
    <td class="uncoveredLine">  assert(lhs != remainder && lhs != srhs && remainder != srhs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2638</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2639</td>
    <td class="uncoveredLine">  unsigned shiftCount = tcMSB(rhs, parts) + 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2640</td>
    <td class="uncoveredLine">  if (shiftCount == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2641</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2642</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2643</td>
    <td class="uncoveredLine">  shiftCount = parts * APINT_BITS_PER_WORD - shiftCount;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2644</td>
    <td class="uncoveredLine">  unsigned n = shiftCount / APINT_BITS_PER_WORD;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2645</td>
    <td class="uncoveredLine">  WordType mask = (WordType) 1 << (shiftCount % APINT_BITS_PER_WORD);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2646</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2647</td>
    <td class="uncoveredLine">  tcAssign(srhs, rhs, parts);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2648</td>
    <td class="uncoveredLine">  tcShiftLeft(srhs, parts, shiftCount);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2649</td>
    <td class="uncoveredLine">  tcAssign(remainder, lhs, parts);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2650</td>
    <td class="uncoveredLine">  tcSet(lhs, 0, parts);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2651</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2652</td>
    <td class="">  // Loop, subtracting SRHS if REMAINDER is greater and adding that to the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2653</td>
    <td class="">  // total.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2654</td>
    <td class="">  for (;;) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2655</td>
    <td class="uncoveredLine">    int compare = tcCompare(remainder, srhs, parts);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2656</td>
    <td class="uncoveredLine">    if (compare >= 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2657</td>
    <td class="uncoveredLine">      tcSubtract(remainder, srhs, 0, parts);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2658</td>
    <td class="uncoveredLine">      lhs[n] |= mask;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2659</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2660</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2661</td>
    <td class="uncoveredLine">    if (shiftCount == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2662</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2663</td>
    <td class="uncoveredLine">    shiftCount--;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2664</td>
    <td class="uncoveredLine">    tcShiftRight(srhs, parts, 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2665</td>
    <td class="uncoveredLine">    if ((mask >>= 1) == 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2666</td>
    <td class="uncoveredLine">      mask = (WordType) 1 << (APINT_BITS_PER_WORD - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2667</td>
    <td class="uncoveredLine">      n--;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2668</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2669</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2670</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2671</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2672</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2673</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2674</td>
    <td class="">/// Shift a bignum left Cound bits in-place. Shifted in bits are zero. There are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2675</td>
    <td class="">/// no restrictions on Count.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2676</td>
    <td class="uncoveredLine">void APInt::tcShiftLeft(WordType *Dst, unsigned Words, unsigned Count) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2677</td>
    <td class="">  // Don't bother performing a no-op shift.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2678</td>
    <td class="uncoveredLine">  if (!Count)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2679</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2680</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2681</td>
    <td class="">  // WordShift is the inter-part shift; BitShift is the intra-part shift.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2682</td>
    <td class="uncoveredLine">  unsigned WordShift = std::min(Count / APINT_BITS_PER_WORD, Words);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2683</td>
    <td class="uncoveredLine">  unsigned BitShift = Count % APINT_BITS_PER_WORD;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2684</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2685</td>
    <td class="">  // Fastpath for moving by whole words.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2686</td>
    <td class="uncoveredLine">  if (BitShift == 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2687</td>
    <td class="uncoveredLine">    std::memmove(Dst + WordShift, Dst, (Words - WordShift) * APINT_WORD_SIZE);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2688</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2689</td>
    <td class="uncoveredLine">    while (Words-- > WordShift) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2690</td>
    <td class="uncoveredLine">      Dst[Words] = Dst[Words - WordShift] << BitShift;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2691</td>
    <td class="uncoveredLine">      if (Words > WordShift)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2692</td>
    <td class="uncoveredLine">        Dst[Words] |=</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2693</td>
    <td class="uncoveredLine">          Dst[Words - WordShift - 1] >> (APINT_BITS_PER_WORD - BitShift);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2694</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2695</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2696</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2697</td>
    <td class="">  // Fill in the remainder with 0s.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2698</td>
    <td class="uncoveredLine">  std::memset(Dst, 0, WordShift * APINT_WORD_SIZE);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2699</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2700</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2701</td>
    <td class="">/// Shift a bignum right Count bits in-place. Shifted in bits are zero. There</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2702</td>
    <td class="">/// are no restrictions on Count.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2703</td>
    <td class="uncoveredLine">void APInt::tcShiftRight(WordType *Dst, unsigned Words, unsigned Count) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2704</td>
    <td class="">  // Don't bother performing a no-op shift.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2705</td>
    <td class="uncoveredLine">  if (!Count)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2706</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2707</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2708</td>
    <td class="">  // WordShift is the inter-part shift; BitShift is the intra-part shift.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2709</td>
    <td class="uncoveredLine">  unsigned WordShift = std::min(Count / APINT_BITS_PER_WORD, Words);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2710</td>
    <td class="uncoveredLine">  unsigned BitShift = Count % APINT_BITS_PER_WORD;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2711</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2712</td>
    <td class="uncoveredLine">  unsigned WordsToMove = Words - WordShift;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2713</td>
    <td class="">  // Fastpath for moving by whole words.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2714</td>
    <td class="uncoveredLine">  if (BitShift == 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2715</td>
    <td class="uncoveredLine">    std::memmove(Dst, Dst + WordShift, WordsToMove * APINT_WORD_SIZE);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2716</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2717</td>
    <td class="uncoveredLine">    for (unsigned i = 0; i != WordsToMove; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2718</td>
    <td class="uncoveredLine">      Dst[i] = Dst[i + WordShift] >> BitShift;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2719</td>
    <td class="uncoveredLine">      if (i + 1 != WordsToMove)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2720</td>
    <td class="uncoveredLine">        Dst[i] |= Dst[i + WordShift + 1] << (APINT_BITS_PER_WORD - BitShift);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2721</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2722</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2723</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2724</td>
    <td class="">  // Fill in the remainder with 0s.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2725</td>
    <td class="uncoveredLine">  std::memset(Dst + WordsToMove, 0, WordShift * APINT_WORD_SIZE);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2726</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2727</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2728</td>
    <td class="">// Comparison (unsigned) of two bignums.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2729</td>
    <td class="uncoveredLine">int APInt::tcCompare(const WordType *lhs, const WordType *rhs,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2730</td>
    <td class="">                     unsigned parts) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2731</td>
    <td class="uncoveredLine">  while (parts) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2732</td>
    <td class="uncoveredLine">    parts--;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2733</td>
    <td class="uncoveredLine">    if (lhs[parts] != rhs[parts])</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2734</td>
    <td class="uncoveredLine">      return (lhs[parts] > rhs[parts]) ? 1 : -1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2735</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2736</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2737</td>
    <td class="uncoveredLine">  return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2738</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2739</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2740</td>
    <td class="uncoveredLine">APInt llvm::APIntOps::RoundingUDiv(const APInt &A, const APInt &B,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2741</td>
    <td class="">                                   APInt::Rounding RM) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2742</td>
    <td class="">  // Currently udivrem always rounds down.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2743</td>
    <td class="uncoveredLine">  switch (RM) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2744</td>
    <td class="uncoveredLine">  case APInt::Rounding::DOWN:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2745</td>
    <td class="">  case APInt::Rounding::TOWARD_ZERO:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2746</td>
    <td class="uncoveredLine">    return A.udiv(B);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2747</td>
    <td class="uncoveredLine">  case APInt::Rounding::UP: {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2748</td>
    <td class="uncoveredLine">    APInt Quo, Rem;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2749</td>
    <td class="uncoveredLine">    APInt::udivrem(A, B, Quo, Rem);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2750</td>
    <td class="uncoveredLine">    if (Rem.isZero())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2751</td>
    <td class="uncoveredLine">      return Quo;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2752</td>
    <td class="uncoveredLine">    return Quo + 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2753</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2754</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2755</td>
    <td class="uncoveredLine">  llvm_unreachable("Unknown APInt::Rounding enum");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2756</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2757</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2758</td>
    <td class="uncoveredLine">APInt llvm::APIntOps::RoundingSDiv(const APInt &A, const APInt &B,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2759</td>
    <td class="">                                   APInt::Rounding RM) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2760</td>
    <td class="uncoveredLine">  switch (RM) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2761</td>
    <td class="uncoveredLine">  case APInt::Rounding::DOWN:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2762</td>
    <td class="">  case APInt::Rounding::UP: {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2763</td>
    <td class="uncoveredLine">    APInt Quo, Rem;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2764</td>
    <td class="uncoveredLine">    APInt::sdivrem(A, B, Quo, Rem);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2765</td>
    <td class="uncoveredLine">    if (Rem.isZero())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2766</td>
    <td class="uncoveredLine">      return Quo;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2767</td>
    <td class="">    // This algorithm deals with arbitrary rounding mode used by sdivrem.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2768</td>
    <td class="">    // We want to check whether the non-integer part of the mathematical value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2769</td>
    <td class="">    // is negative or not. If the non-integer part is negative, we need to round</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2770</td>
    <td class="">    // down from Quo; otherwise, if it's positive or 0, we return Quo, as it's</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2771</td>
    <td class="">    // already rounded down.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2772</td>
    <td class="uncoveredLine">    if (RM == APInt::Rounding::DOWN) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2773</td>
    <td class="uncoveredLine">      if (Rem.isNegative() != B.isNegative())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2774</td>
    <td class="uncoveredLine">        return Quo - 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2775</td>
    <td class="uncoveredLine">      return Quo;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2776</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2777</td>
    <td class="uncoveredLine">    if (Rem.isNegative() != B.isNegative())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2778</td>
    <td class="uncoveredLine">      return Quo;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2779</td>
    <td class="uncoveredLine">    return Quo + 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2780</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2781</td>
    <td class="">  // Currently sdiv rounds towards zero.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2782</td>
    <td class="uncoveredLine">  case APInt::Rounding::TOWARD_ZERO:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2783</td>
    <td class="uncoveredLine">    return A.sdiv(B);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2784</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2785</td>
    <td class="uncoveredLine">  llvm_unreachable("Unknown APInt::Rounding enum");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2786</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2787</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2788</td>
    <td class="">std::optional<APInt></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2789</td>
    <td class="uncoveredLine">llvm::APIntOps::SolveQuadraticEquationWrap(APInt A, APInt B, APInt C,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2790</td>
    <td class="">                                           unsigned RangeWidth) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2791</td>
    <td class="uncoveredLine">  unsigned CoeffWidth = A.getBitWidth();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2792</td>
    <td class="uncoveredLine">  assert(CoeffWidth == B.getBitWidth() && CoeffWidth == C.getBitWidth());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2793</td>
    <td class="uncoveredLine">  assert(RangeWidth <= CoeffWidth &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2794</td>
    <td class="">         "Value range width should be less than coefficient width");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2795</td>
    <td class="uncoveredLine">  assert(RangeWidth > 1 && "Value range bit width should be > 1");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2796</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2797</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << __func__ << ": solving " << A << "x^2 + " << B</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2798</td>
    <td class="">                    << "x + " << C << ", rw:" << RangeWidth << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2799</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2800</td>
    <td class="">  // Identify 0 as a (non)solution immediately.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2801</td>
    <td class="uncoveredLine">  if (C.sextOrTrunc(RangeWidth).isZero()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2802</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << __func__ << ": zero solution\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2803</td>
    <td class="uncoveredLine">    return APInt(CoeffWidth, 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2804</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2805</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2806</td>
    <td class="">  // The result of APInt arithmetic has the same bit width as the operands,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2807</td>
    <td class="">  // so it can actually lose high bits. A product of two n-bit integers needs</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2808</td>
    <td class="">  // 2n-1 bits to represent the full value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2809</td>
    <td class="">  // The operation done below (on quadratic coefficients) that can produce</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2810</td>
    <td class="">  // the largest value is the evaluation of the equation during bisection,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2811</td>
    <td class="">  // which needs 3 times the bitwidth of the coefficient, so the total number</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2812</td>
    <td class="">  // of required bits is 3n.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2813</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2814</td>
    <td class="">  // The purpose of this extension is to simulate the set Z of all integers,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2815</td>
    <td class="">  // where n+1 > n for all n in Z. In Z it makes sense to talk about positive</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2816</td>
    <td class="">  // and negative numbers (not so much in a modulo arithmetic). The method</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2817</td>
    <td class="">  // used to solve the equation is based on the standard formula for real</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2818</td>
    <td class="">  // numbers, and uses the concepts of "positive" and "negative" with their</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2819</td>
    <td class="">  // usual meanings.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2820</td>
    <td class="uncoveredLine">  CoeffWidth *= 3;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2821</td>
    <td class="uncoveredLine">  A = A.sext(CoeffWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2822</td>
    <td class="uncoveredLine">  B = B.sext(CoeffWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2823</td>
    <td class="uncoveredLine">  C = C.sext(CoeffWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2824</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2825</td>
    <td class="">  // Make A > 0 for simplicity. Negate cannot overflow at this point because</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2826</td>
    <td class="">  // the bit width has increased.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2827</td>
    <td class="uncoveredLine">  if (A.isNegative()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2828</td>
    <td class="uncoveredLine">    A.negate();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2829</td>
    <td class="uncoveredLine">    B.negate();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2830</td>
    <td class="uncoveredLine">    C.negate();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2831</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2832</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2833</td>
    <td class="">  // Solving an equation q(x) = 0 with coefficients in modular arithmetic</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2834</td>
    <td class="">  // is really solving a set of equations q(x) = kR for k = 0, 1, 2, ...,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2835</td>
    <td class="">  // and R = 2^BitWidth.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2836</td>
    <td class="">  // Since we're trying not only to find exact solutions, but also values</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2837</td>
    <td class="">  // that "wrap around", such a set will always have a solution, i.e. an x</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2838</td>
    <td class="">  // that satisfies at least one of the equations, or such that |q(x)|</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2839</td>
    <td class="">  // exceeds kR, while |q(x-1)| for the same k does not.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2840</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2841</td>
    <td class="">  // We need to find a value k, such that Ax^2 + Bx + C = kR will have a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2842</td>
    <td class="">  // positive solution n (in the above sense), and also such that the n</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2843</td>
    <td class="">  // will be the least among all solutions corresponding to k = 0, 1, ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2844</td>
    <td class="">  // (more precisely, the least element in the set</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2845</td>
    <td class="">  //   { n(k) | k is such that a solution n(k) exists }).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2846</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2847</td>
    <td class="">  // Consider the parabola (over real numbers) that corresponds to the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2848</td>
    <td class="">  // quadratic equation. Since A > 0, the arms of the parabola will point</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2849</td>
    <td class="">  // up. Picking different values of k will shift it up and down by R.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2850</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2851</td>
    <td class="">  // We want to shift the parabola in such a way as to reduce the problem</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2852</td>
    <td class="">  // of solving q(x) = kR to solving shifted_q(x) = 0.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2853</td>
    <td class="">  // (The interesting solutions are the ceilings of the real number</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2854</td>
    <td class="">  // solutions.)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2855</td>
    <td class="uncoveredLine">  APInt R = APInt::getOneBitSet(CoeffWidth, RangeWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2856</td>
    <td class="uncoveredLine">  APInt TwoA = 2 * A;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2857</td>
    <td class="uncoveredLine">  APInt SqrB = B * B;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2858</td>
    <td class="">  bool PickLow;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2859</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2860</td>
    <td class="uncoveredLine">  auto RoundUp = [] (const APInt &V, const APInt &A) -> APInt {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2861</td>
    <td class="uncoveredLine">    assert(A.isStrictlyPositive());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2862</td>
    <td class="uncoveredLine">    APInt T = V.abs().urem(A);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2863</td>
    <td class="uncoveredLine">    if (T.isZero())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2864</td>
    <td class="uncoveredLine">      return V;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2865</td>
    <td class="uncoveredLine">    return V.isNegative() ? V+T : V+(A-T);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2866</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2867</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2868</td>
    <td class="">  // The vertex of the parabola is at -B/2A, but since A > 0, it's negative</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2869</td>
    <td class="">  // iff B is positive.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2870</td>
    <td class="uncoveredLine">  if (B.isNonNegative()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2871</td>
    <td class="">    // If B >= 0, the vertex it at a negative location (or at 0), so in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2872</td>
    <td class="">    // order to have a non-negative solution we need to pick k that makes</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2873</td>
    <td class="">    // C-kR negative. To satisfy all the requirements for the solution</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2874</td>
    <td class="">    // that we are looking for, it needs to be closest to 0 of all k.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2875</td>
    <td class="uncoveredLine">    C = C.srem(R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2876</td>
    <td class="uncoveredLine">    if (C.isStrictlyPositive())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2877</td>
    <td class="uncoveredLine">      C -= R;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2878</td>
    <td class="">    // Pick the greater solution.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2879</td>
    <td class="uncoveredLine">    PickLow = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2880</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2881</td>
    <td class="">    // If B < 0, the vertex is at a positive location. For any solution</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2882</td>
    <td class="">    // to exist, the discriminant must be non-negative. This means that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2883</td>
    <td class="">    // C-kR <= B^2/4A is a necessary condition for k, i.e. there is a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2884</td>
    <td class="">    // lower bound on values of k: kR >= C - B^2/4A.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2885</td>
    <td class="uncoveredLine">    APInt LowkR = C - SqrB.udiv(2*TwoA); // udiv because all values > 0.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2886</td>
    <td class="">    // Round LowkR up (towards +inf) to the nearest kR.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2887</td>
    <td class="uncoveredLine">    LowkR = RoundUp(LowkR, R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2888</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2889</td>
    <td class="">    // If there exists k meeting the condition above, and such that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2890</td>
    <td class="">    // C-kR > 0, there will be two positive real number solutions of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2891</td>
    <td class="">    // q(x) = kR. Out of all such values of k, pick the one that makes</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2892</td>
    <td class="">    // C-kR closest to 0, (i.e. pick maximum k such that C-kR > 0).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2893</td>
    <td class="">    // In other words, find maximum k such that LowkR <= kR < C.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2894</td>
    <td class="uncoveredLine">    if (C.sgt(LowkR)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2895</td>
    <td class="">      // If LowkR < C, then such a k is guaranteed to exist because</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2896</td>
    <td class="">      // LowkR itself is a multiple of R.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2897</td>
    <td class="uncoveredLine">      C -= -RoundUp(-C, R);      // C = C - RoundDown(C, R)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2898</td>
    <td class="">      // Pick the smaller solution.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2899</td>
    <td class="uncoveredLine">      PickLow = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2900</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2901</td>
    <td class="">      // If C-kR < 0 for all potential k's, it means that one solution</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2902</td>
    <td class="">      // will be negative, while the other will be positive. The positive</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2903</td>
    <td class="">      // solution will shift towards 0 if the parabola is moved up.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2904</td>
    <td class="">      // Pick the kR closest to the lower bound (i.e. make C-kR closest</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2905</td>
    <td class="">      // to 0, or in other words, out of all parabolas that have solutions,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2906</td>
    <td class="">      // pick the one that is the farthest "up").</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2907</td>
    <td class="">      // Since LowkR is itself a multiple of R, simply take C-LowkR.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2908</td>
    <td class="uncoveredLine">      C -= LowkR;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2909</td>
    <td class="">      // Pick the greater solution.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2910</td>
    <td class="uncoveredLine">      PickLow = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2911</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2912</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2913</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2914</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << __func__ << ": updated coefficients " << A << "x^2 + "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2915</td>
    <td class="">                    << B << "x + " << C << ", rw:" << RangeWidth << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2916</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2917</td>
    <td class="uncoveredLine">  APInt D = SqrB - 4*A*C;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2918</td>
    <td class="uncoveredLine">  assert(D.isNonNegative() && "Negative discriminant");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2919</td>
    <td class="uncoveredLine">  APInt SQ = D.sqrt();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2920</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2921</td>
    <td class="uncoveredLine">  APInt Q = SQ * SQ;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2922</td>
    <td class="uncoveredLine">  bool InexactSQ = Q != D;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2923</td>
    <td class="">  // The calculated SQ may actually be greater than the exact (non-integer)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2924</td>
    <td class="">  // value. If that's the case, decrement SQ to get a value that is lower.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2925</td>
    <td class="uncoveredLine">  if (Q.sgt(D))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2926</td>
    <td class="uncoveredLine">    SQ -= 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2927</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2928</td>
    <td class="uncoveredLine">  APInt X;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2929</td>
    <td class="uncoveredLine">  APInt Rem;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2930</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2931</td>
    <td class="">  // SQ is rounded down (i.e SQ * SQ <= D), so the roots may be inexact.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2932</td>
    <td class="">  // When using the quadratic formula directly, the calculated low root</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2933</td>
    <td class="">  // may be greater than the exact one, since we would be subtracting SQ.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2934</td>
    <td class="">  // To make sure that the calculated root is not greater than the exact</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2935</td>
    <td class="">  // one, subtract SQ+1 when calculating the low root (for inexact value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2936</td>
    <td class="">  // of SQ).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2937</td>
    <td class="uncoveredLine">  if (PickLow)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2938</td>
    <td class="uncoveredLine">    APInt::sdivrem(-B - (SQ+InexactSQ), TwoA, X, Rem);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2939</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2940</td>
    <td class="uncoveredLine">    APInt::sdivrem(-B + SQ, TwoA, X, Rem);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2941</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2942</td>
    <td class="">  // The updated coefficients should be such that the (exact) solution is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2943</td>
    <td class="">  // positive. Since APInt division rounds towards 0, the calculated one</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2944</td>
    <td class="">  // can be 0, but cannot be negative.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2945</td>
    <td class="uncoveredLine">  assert(X.isNonNegative() && "Solution should be non-negative");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2946</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2947</td>
    <td class="uncoveredLine">  if (!InexactSQ && Rem.isZero()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2948</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << __func__ << ": solution (root): " << X << '\n');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2949</td>
    <td class="uncoveredLine">    return X;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2950</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2951</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2952</td>
    <td class="uncoveredLine">  assert((SQ*SQ).sle(D) && "SQ = |_sqrt(D)_|, so SQ*SQ <= D");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2953</td>
    <td class="">  // The exact value of the square root of D should be between SQ and SQ+1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2954</td>
    <td class="">  // This implies that the solution should be between that corresponding to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2955</td>
    <td class="">  // SQ (i.e. X) and that corresponding to SQ+1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2956</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2957</td>
    <td class="">  // The calculated X cannot be greater than the exact (real) solution.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2958</td>
    <td class="">  // Actually it must be strictly less than the exact solution, while</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2959</td>
    <td class="">  // X+1 will be greater than or equal to it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2960</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2961</td>
    <td class="uncoveredLine">  APInt VX = (A*X + B)*X + C;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2962</td>
    <td class="uncoveredLine">  APInt VY = VX + TwoA*X + A + B;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2963</td>
    <td class="">  bool SignChange =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2964</td>
    <td class="uncoveredLine">      VX.isNegative() != VY.isNegative() || VX.isZero() != VY.isZero();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2965</td>
    <td class="">  // If the sign did not change between X and X+1, X is not a valid solution.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2966</td>
    <td class="">  // This could happen when the actual (exact) roots don't have an integer</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2967</td>
    <td class="">  // between them, so they would both be contained between X and X+1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2968</td>
    <td class="uncoveredLine">  if (!SignChange) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2969</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << __func__ << ": no valid solution\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2970</td>
    <td class="uncoveredLine">    return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2971</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2972</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2973</td>
    <td class="uncoveredLine">  X += 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2974</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << __func__ << ": solution (wrap): " << X << '\n');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2975</td>
    <td class="uncoveredLine">  return X;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2976</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2977</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2978</td>
    <td class="">std::optional<unsigned></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2979</td>
    <td class="uncoveredLine">llvm::APIntOps::GetMostSignificantDifferentBit(const APInt &A, const APInt &B) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2980</td>
    <td class="uncoveredLine">  assert(A.getBitWidth() == B.getBitWidth() && "Must have the same bitwidth");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2981</td>
    <td class="uncoveredLine">  if (A == B)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2982</td>
    <td class="uncoveredLine">    return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2983</td>
    <td class="uncoveredLine">  return A.getBitWidth() - ((A ^ B).countl_zero() + 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2984</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2985</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2986</td>
    <td class="uncoveredLine">APInt llvm::APIntOps::ScaleBitMask(const APInt &A, unsigned NewBitWidth,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2987</td>
    <td class="">                                   bool MatchAllBits) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2988</td>
    <td class="uncoveredLine">  unsigned OldBitWidth = A.getBitWidth();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2989</td>
    <td class="uncoveredLine">  assert((((OldBitWidth % NewBitWidth) == 0) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2990</td>
    <td class="">          ((NewBitWidth % OldBitWidth) == 0)) &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2991</td>
    <td class="">         "One size should be a multiple of the other one. "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2992</td>
    <td class="">         "Can't do fractional scaling.");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2993</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2994</td>
    <td class="">  // Check for matching bitwidths.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2995</td>
    <td class="uncoveredLine">  if (OldBitWidth == NewBitWidth)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2996</td>
    <td class="uncoveredLine">    return A;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2997</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2998</td>
    <td class="uncoveredLine">  APInt NewA = APInt::getZero(NewBitWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2999</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3000</td>
    <td class="">  // Check for null input.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3001</td>
    <td class="uncoveredLine">  if (A.isZero())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3002</td>
    <td class="uncoveredLine">    return NewA;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3003</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3004</td>
    <td class="uncoveredLine">  if (NewBitWidth > OldBitWidth) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3005</td>
    <td class="">    // Repeat bits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3006</td>
    <td class="uncoveredLine">    unsigned Scale = NewBitWidth / OldBitWidth;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3007</td>
    <td class="uncoveredLine">    for (unsigned i = 0; i != OldBitWidth; ++i)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3008</td>
    <td class="uncoveredLine">      if (A[i])</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3009</td>
    <td class="uncoveredLine">        NewA.setBits(i * Scale, (i + 1) * Scale);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3010</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3011</td>
    <td class="uncoveredLine">    unsigned Scale = OldBitWidth / NewBitWidth;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3012</td>
    <td class="uncoveredLine">    for (unsigned i = 0; i != NewBitWidth; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3013</td>
    <td class="uncoveredLine">      if (MatchAllBits) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3014</td>
    <td class="uncoveredLine">        if (A.extractBits(Scale, i * Scale).isAllOnes())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3015</td>
    <td class="uncoveredLine">          NewA.setBit(i);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3016</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3017</td>
    <td class="uncoveredLine">        if (!A.extractBits(Scale, i * Scale).isZero())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3018</td>
    <td class="uncoveredLine">          NewA.setBit(i);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3019</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3020</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3021</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3022</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3023</td>
    <td class="uncoveredLine">  return NewA;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3024</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3025</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3026</td>
    <td class="">/// StoreIntToMemory - Fills the StoreBytes bytes of memory starting from Dst</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3027</td>
    <td class="">/// with the integer held in IntVal.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3028</td>
    <td class="uncoveredLine">void llvm::StoreIntToMemory(const APInt &IntVal, uint8_t *Dst,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3029</td>
    <td class="">                            unsigned StoreBytes) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3030</td>
    <td class="uncoveredLine">  assert((IntVal.getBitWidth()+7)/8 >= StoreBytes && "Integer too small!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3031</td>
    <td class="uncoveredLine">  const uint8_t *Src = (const uint8_t *)IntVal.getRawData();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3032</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3033</td>
    <td class="">  if (sys::IsLittleEndianHost) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3034</td>
    <td class="">    // Little-endian host - the source is ordered from LSB to MSB.  Order the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3035</td>
    <td class="">    // destination from LSB to MSB: Do a straight copy.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3036</td>
    <td class="uncoveredLine">    memcpy(Dst, Src, StoreBytes);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3037</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3038</td>
    <td class="">    // Big-endian host - the source is an array of 64 bit words ordered from</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3039</td>
    <td class="">    // LSW to MSW.  Each word is ordered from MSB to LSB.  Order the destination</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3040</td>
    <td class="">    // from MSB to LSB: Reverse the word order, but not the bytes in a word.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3041</td>
    <td class="">    while (StoreBytes > sizeof(uint64_t)) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3042</td>
    <td class="">      StoreBytes -= sizeof(uint64_t);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3043</td>
    <td class="">      // May not be aligned so use memcpy.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3044</td>
    <td class="">      memcpy(Dst + StoreBytes, Src, sizeof(uint64_t));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3045</td>
    <td class="">      Src += sizeof(uint64_t);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3046</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3047</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3048</td>
    <td class="">    memcpy(Dst, Src + sizeof(uint64_t) - StoreBytes, StoreBytes);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3049</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3050</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3051</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3052</td>
    <td class="">/// LoadIntFromMemory - Loads the integer stored in the LoadBytes bytes starting</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3053</td>
    <td class="">/// from Src into IntVal, which is assumed to be wide enough and to hold zero.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3054</td>
    <td class="uncoveredLine">void llvm::LoadIntFromMemory(APInt &IntVal, const uint8_t *Src,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3055</td>
    <td class="">                             unsigned LoadBytes) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3056</td>
    <td class="uncoveredLine">  assert((IntVal.getBitWidth()+7)/8 >= LoadBytes && "Integer too small!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3057</td>
    <td class="">  uint8_t *Dst = reinterpret_cast<uint8_t *>(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3058</td>
    <td class="uncoveredLine">                   const_cast<uint64_t *>(IntVal.getRawData()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3059</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3060</td>
    <td class="">  if (sys::IsLittleEndianHost)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3061</td>
    <td class="">    // Little-endian host - the destination must be ordered from LSB to MSB.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3062</td>
    <td class="">    // The source is ordered from LSB to MSB: Do a straight copy.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3063</td>
    <td class="uncoveredLine">    memcpy(Dst, Src, LoadBytes);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3064</td>
    <td class="">  else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3065</td>
    <td class="">    // Big-endian - the destination is an array of 64 bit words ordered from</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3066</td>
    <td class="">    // LSW to MSW.  Each word must be ordered from MSB to LSB.  The source is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3067</td>
    <td class="">    // ordered from MSB to LSB: Reverse the word order, but not the bytes in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3068</td>
    <td class="">    // a word.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3069</td>
    <td class="">    while (LoadBytes > sizeof(uint64_t)) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3070</td>
    <td class="">      LoadBytes -= sizeof(uint64_t);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3071</td>
    <td class="">      // May not be aligned so use memcpy.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3072</td>
    <td class="">      memcpy(Dst, Src + LoadBytes, sizeof(uint64_t));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3073</td>
    <td class="">      Dst += sizeof(uint64_t);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3074</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3075</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3076</td>
    <td class="">    memcpy(Dst + sizeof(uint64_t) - LoadBytes, Src, LoadBytes);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3077</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3078</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3079</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Functions Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Functions Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Function name</th>
    <th class="mainTh">Number of hits</th>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL16getClearedMemoryj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL9getMemoryj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL8getDigitch</td>
    <td class="numberOfCalls">237</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt12initSlowCaseEmb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt12initSlowCaseERKS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt13initFromArrayENS_8ArrayRefImEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APIntC2EjNS_8ArrayRefImEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APIntC2EjjPKm</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APIntC2EjNS_9StringRefEh</td>
    <td class="numberOfCalls">171</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt10reallocateEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt14assignSlowCaseERKS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt7ProfileERNS_16FoldingSetNodeIDE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt9isAlignedENS_5AlignE</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APIntppEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APIntmmEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APIntpLERKS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APIntpLEm</td>
    <td class="numberOfCalls">237</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APIntmIERKS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APIntmIEm</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APIntmlERKS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt17andAssignSlowCaseERKS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt16orAssignSlowCaseERKS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt17xorAssignSlowCaseERKS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APIntmLERKS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APIntmLEm</td>
    <td class="numberOfCalls">132</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt13equalSlowCaseERKS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt7compareERKS0_</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt13compareSignedERKS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt15setBitsSlowCaseEjj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL12tcComplementPmj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt19flipAllBitsSlowCaseEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt14concatSlowCaseERKS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt7flipBitEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt10insertBitsERKS0_j</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt10insertBitsEmjj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt11extractBitsEjj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt22extractBitsAsZExtValueEjj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt23getSufficientBitsNeededENS_9StringRefEh</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt13getBitsNeededENS_9StringRefEh</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm10hash_valueERKNS_5APIntE</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12DenseMapInfoINS_5APIntEvE12getHashValueERKS1_</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt7isSplatEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt9getHiBitsEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt9getLoBitsEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt8getSplatEjRKS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt25countLeadingZerosSlowCaseEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt24countLeadingOnesSlowCaseEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt26countTrailingZerosSlowCaseEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt25countTrailingOnesSlowCaseEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt23countPopulationSlowCaseEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt18intersectsSlowCaseERKS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt18isSubsetOfSlowCaseERKS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt8byteSwapEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt11reverseBitsEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8APIntOps21GreatestCommonDivisorENS_5APIntES1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8APIntOps18RoundDoubleToAPIntEdj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt13roundToDoubleEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt5truncEj</td>
    <td class="numberOfCalls">171</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt9truncUSatEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt9truncSSatEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt4sextEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt4zextEj</td>
    <td class="numberOfCalls">12</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt11zextOrTruncEj</td>
    <td class="numberOfCalls">12</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt11sextOrTruncEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt11ashrInPlaceERKS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt12ashrSlowCaseEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt11lshrInPlaceERKS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt12lshrSlowCaseEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APIntlSERKS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt11shlSlowCaseEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL12rotateModulojRKN4llvm5APIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt4rotlERKS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt4rotlEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt4rotrERKS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt4rotrEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt15nearestLogBase2Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt4sqrtEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt21multiplicativeInverseERKS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL8KnuthDivPjS_S_S_jj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt6divideEPKmjS2_jPmS3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt4udivERKS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt4udivEm</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt4sdivERKS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt4sdivEl</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt4uremERKS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt4uremEm</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt4sremERKS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt4sremEl</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt7udivremERKS0_S2_RS0_S3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt7udivremERKS0_mRS0_Rm</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt7sdivremERKS0_S2_RS0_S3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt7sdivremERKS0_lRS0_Rl</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt7sadd_ovERKS0_Rb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt7uadd_ovERKS0_Rb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt7ssub_ovERKS0_Rb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt7usub_ovERKS0_Rb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt7sdiv_ovERKS0_Rb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt7smul_ovERKS0_Rb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt7umul_ovERKS0_Rb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt7sshl_ovERKS0_Rb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt7sshl_ovEjRb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt7ushl_ovERKS0_Rb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt7ushl_ovEjRb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt8sadd_satERKS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt8uadd_satERKS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt8ssub_satERKS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt8usub_satERKS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt8smul_satERKS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt8umul_satERKS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt8sshl_satERKS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt8sshl_satEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt8ushl_satERKS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt8ushl_satEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt10fromStringEjNS_9StringRefEh</td>
    <td class="numberOfCalls">171</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt8toStringERNS_15SmallVectorImplIcEEjbbb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt4dumpEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5APInt5printERNS_11raw_ostreamEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL10lowBitMaskj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL7lowHalfm</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL8highHalfm</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt5tcSetEPmmj</td>
    <td class="numberOfCalls">67</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt8tcAssignEPmPKmj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt8tcIsZeroEPKmj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt12tcExtractBitEPKmj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt8tcSetBitEPmj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt10tcClearBitEPmj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt5tcLSBEPKmj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt5tcMSBEPKmj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt9tcExtractEPmjPKmjj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt5tcAddEPmPKmmj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt9tcAddPartEPmmj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt10tcSubtractEPmPKmmj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt14tcSubtractPartEPmmj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt8tcNegateEPmj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt14tcMultiplyPartEPmPKmmmjjb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt10tcMultiplyEPmPKmS3_j</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt14tcFullMultiplyEPmPKmS3_jj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt8tcDivideEPmPKmS1_S1_j</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt11tcShiftLeftEPmjj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt12tcShiftRightEPmjj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5APInt9tcCompareEPKmS2_j</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8APIntOps12RoundingUDivERKNS_5APIntES3_NS1_8RoundingE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8APIntOps12RoundingSDivERKNS_5APIntES3_NS1_8RoundingE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8APIntOps26SolveQuadraticEquationWrapENS_5APIntES1_S1_j</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm8APIntOps26SolveQuadraticEquationWrapENS_5APIntES1_S1_jENKUlRKS1_S3_E_clES3_S3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8APIntOps30GetMostSignificantDifferentBitERKNS_5APIntES3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8APIntOps12ScaleBitMaskERKNS_5APIntEjb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16StoreIntToMemoryERKNS_5APIntEPhj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17LoadIntFromMemoryERNS_5APIntEPKhj</td>
    <td class="numberOfCalls">0</td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Coverage Diff</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Coverage Diff</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeline">//===-- APInt.cpp - Implement APInt class ---------------------------------===//</td>
    <td class="lineNumber">1</td>
    <td class="codeline">//===-- APInt.cpp - Implement APInt class ---------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeline">// This file implements a class to represent arbitrary precision integer</td>
    <td class="lineNumber">9</td>
    <td class="codeline">// This file implements a class to represent arbitrary precision integer</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeline">// constant values and provide a variety of arithmetic operations on them.</td>
    <td class="lineNumber">10</td>
    <td class="codeline">// constant values and provide a variety of arithmetic operations on them.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeline">//</td>
    <td class="lineNumber">11</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">12</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeline"></td>
    <td class="lineNumber">13</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeline">#include "llvm/ADT/APInt.h"</td>
    <td class="lineNumber">14</td>
    <td class="codeline">#include "llvm/ADT/APInt.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeline">#include "llvm/ADT/ArrayRef.h"</td>
    <td class="lineNumber">15</td>
    <td class="codeline">#include "llvm/ADT/ArrayRef.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeline">#include "llvm/ADT/FoldingSet.h"</td>
    <td class="lineNumber">16</td>
    <td class="codeline">#include "llvm/ADT/FoldingSet.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeline">#include "llvm/ADT/Hashing.h"</td>
    <td class="lineNumber">17</td>
    <td class="codeline">#include "llvm/ADT/Hashing.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeline">#include "llvm/ADT/SmallString.h"</td>
    <td class="lineNumber">18</td>
    <td class="codeline">#include "llvm/ADT/SmallString.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeline">#include "llvm/ADT/StringRef.h"</td>
    <td class="lineNumber">19</td>
    <td class="codeline">#include "llvm/ADT/StringRef.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeline">#include "llvm/ADT/bit.h"</td>
    <td class="lineNumber">20</td>
    <td class="codeline">#include "llvm/ADT/bit.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeline">#include "llvm/Config/llvm-config.h"</td>
    <td class="lineNumber">21</td>
    <td class="codeline">#include "llvm/Config/llvm-config.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeline">#include "llvm/Support/Alignment.h"</td>
    <td class="lineNumber">22</td>
    <td class="codeline">#include "llvm/Support/Alignment.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/Support/Debug.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/Support/ErrorHandling.h"</td>
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/Support/ErrorHandling.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/Support/MathExtras.h"</td>
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/Support/MathExtras.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/Support/raw_ostream.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeline">#include <cmath></td>
    <td class="lineNumber">27</td>
    <td class="codeline">#include <cmath></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeline">#include <optional></td>
    <td class="lineNumber">28</td>
    <td class="codeline">#include <optional></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeline"></td>
    <td class="lineNumber">29</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeline">using namespace llvm;</td>
    <td class="lineNumber">30</td>
    <td class="codeline">using namespace llvm;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeline"></td>
    <td class="lineNumber">31</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeline">#define DEBUG_TYPE "apint"</td>
    <td class="lineNumber">32</td>
    <td class="codeline">#define DEBUG_TYPE "apint"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeline"></td>
    <td class="lineNumber">33</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeline">/// A utility function for allocating memory, checking for allocation failures,</td>
    <td class="lineNumber">34</td>
    <td class="codeline">/// A utility function for allocating memory, checking for allocation failures,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeline">/// and ensuring the contents are zeroed.</td>
    <td class="lineNumber">35</td>
    <td class="codeline">/// and ensuring the contents are zeroed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeline">inline static uint64_t* getClearedMemory(unsigned numWords) {</td>
    <td class="lineNumber">36</td>
    <td class="codeline">inline static uint64_t* getClearedMemory(unsigned numWords) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeline">  uint64_t *result = new uint64_t[numWords];</td>
    <td class="lineNumber">37</td>
    <td class="codeline">  uint64_t *result = new uint64_t[numWords];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeline">  memset(result, 0, numWords * sizeof(uint64_t));</td>
    <td class="lineNumber">38</td>
    <td class="codeline">  memset(result, 0, numWords * sizeof(uint64_t));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeline">  return result;</td>
    <td class="lineNumber">39</td>
    <td class="codeline">  return result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeline">}</td>
    <td class="lineNumber">40</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeline"></td>
    <td class="lineNumber">41</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeline">/// A utility function for allocating memory and checking for allocation</td>
    <td class="lineNumber">42</td>
    <td class="codeline">/// A utility function for allocating memory and checking for allocation</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeline">/// failure.  The content is not zeroed.</td>
    <td class="lineNumber">43</td>
    <td class="codeline">/// failure.  The content is not zeroed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeline">inline static uint64_t* getMemory(unsigned numWords) {</td>
    <td class="lineNumber">44</td>
    <td class="codeline">inline static uint64_t* getMemory(unsigned numWords) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeline">  return new uint64_t[numWords];</td>
    <td class="lineNumber">45</td>
    <td class="codeline">  return new uint64_t[numWords];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeline">}</td>
    <td class="lineNumber">46</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeline"></td>
    <td class="lineNumber">47</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeline">/// A utility function that converts a character to a digit.</td>
    <td class="lineNumber">48</td>
    <td class="codeline">/// A utility function that converts a character to a digit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeline">inline static unsigned getDigit(char cdigit, uint8_t radix) {</td>
    <td class="lineNumber">49</td>
    <td class="codeline">inline static unsigned getDigit(char cdigit, uint8_t radix) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeline">  unsigned r;</td>
    <td class="lineNumber">50</td>
    <td class="codeline">  unsigned r;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeline"></td>
    <td class="lineNumber">51</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeline">  if (radix == 16 || radix == 36) {</td>
    <td class="lineNumber">52</td>
    <td class="codeline">  if (radix == 16 || radix == 36) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeline">    r = cdigit - '0';</td>
    <td class="lineNumber">53</td>
    <td class="codeline">    r = cdigit - '0';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeline">    if (r <= 9)</td>
    <td class="lineNumber">54</td>
    <td class="codeline">    if (r <= 9)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeline">      return r;</td>
    <td class="lineNumber">55</td>
    <td class="codeline">      return r;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeline"></td>
    <td class="lineNumber">56</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeline">    r = cdigit - 'A';</td>
    <td class="lineNumber">57</td>
    <td class="codeline">    r = cdigit - 'A';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeline">    if (r <= radix - 11U)</td>
    <td class="lineNumber">58</td>
    <td class="codeline">    if (r <= radix - 11U)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeline">      return r + 10;</td>
    <td class="lineNumber">59</td>
    <td class="codeline">      return r + 10;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeline"></td>
    <td class="lineNumber">60</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeline">    r = cdigit - 'a';</td>
    <td class="lineNumber">61</td>
    <td class="codeline">    r = cdigit - 'a';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeline">    if (r <= radix - 11U)</td>
    <td class="lineNumber">62</td>
    <td class="codeline">    if (r <= radix - 11U)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeline">      return r + 10;</td>
    <td class="lineNumber">63</td>
    <td class="codeline">      return r + 10;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeline"></td>
    <td class="lineNumber">64</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeline">    radix = 10;</td>
    <td class="lineNumber">65</td>
    <td class="codeline">    radix = 10;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">66</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeline"></td>
    <td class="lineNumber">67</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeline">  r = cdigit - '0';</td>
    <td class="lineNumber">68</td>
    <td class="codeline">  r = cdigit - '0';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeline">  if (r < radix)</td>
    <td class="lineNumber">69</td>
    <td class="codeline">  if (r < radix)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeline">    return r;</td>
    <td class="lineNumber">70</td>
    <td class="codeline">    return r;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeline"></td>
    <td class="lineNumber">71</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeline">  return UINT_MAX;</td>
    <td class="lineNumber">72</td>
    <td class="codeline">  return UINT_MAX;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeline">}</td>
    <td class="lineNumber">73</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeline"></td>
    <td class="lineNumber">74</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeline"></td>
    <td class="lineNumber">75</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeline">void APInt::initSlowCase(uint64_t val, bool isSigned) {</td>
    <td class="lineNumber">76</td>
    <td class="codeline">void APInt::initSlowCase(uint64_t val, bool isSigned) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeline">  U.pVal = getClearedMemory(getNumWords());</td>
    <td class="lineNumber">77</td>
    <td class="codeline">  U.pVal = getClearedMemory(getNumWords());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeline">  U.pVal[0] = val;</td>
    <td class="lineNumber">78</td>
    <td class="codeline">  U.pVal[0] = val;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeline">  if (isSigned && int64_t(val) < 0)</td>
    <td class="lineNumber">79</td>
    <td class="codeline">  if (isSigned && int64_t(val) < 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeline">    for (unsigned i = 1; i < getNumWords(); ++i)</td>
    <td class="lineNumber">80</td>
    <td class="codeline">    for (unsigned i = 1; i < getNumWords(); ++i)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeline">      U.pVal[i] = WORDTYPE_MAX;</td>
    <td class="lineNumber">81</td>
    <td class="codeline">      U.pVal[i] = WORDTYPE_MAX;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeline">  clearUnusedBits();</td>
    <td class="lineNumber">82</td>
    <td class="codeline">  clearUnusedBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeline">}</td>
    <td class="lineNumber">83</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeline"></td>
    <td class="lineNumber">84</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeline">void APInt::initSlowCase(const APInt& that) {</td>
    <td class="lineNumber">85</td>
    <td class="codeline">void APInt::initSlowCase(const APInt& that) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeline">  U.pVal = getMemory(getNumWords());</td>
    <td class="lineNumber">86</td>
    <td class="codeline">  U.pVal = getMemory(getNumWords());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeline">  memcpy(U.pVal, that.U.pVal, getNumWords() * APINT_WORD_SIZE);</td>
    <td class="lineNumber">87</td>
    <td class="codeline">  memcpy(U.pVal, that.U.pVal, getNumWords() * APINT_WORD_SIZE);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeline">}</td>
    <td class="lineNumber">88</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeline"></td>
    <td class="lineNumber">89</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeline">void APInt::initFromArray(ArrayRef<uint64_t> bigVal) {</td>
    <td class="lineNumber">90</td>
    <td class="codeline">void APInt::initFromArray(ArrayRef<uint64_t> bigVal) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeline">  assert(bigVal.data() && "Null pointer detected!");</td>
    <td class="lineNumber">91</td>
    <td class="codeline">  assert(bigVal.data() && "Null pointer detected!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeline">  if (isSingleWord())</td>
    <td class="lineNumber">92</td>
    <td class="codeline">  if (isSingleWord())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeline">    U.VAL = bigVal[0];</td>
    <td class="lineNumber">93</td>
    <td class="codeline">    U.VAL = bigVal[0];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeline">  else {</td>
    <td class="lineNumber">94</td>
    <td class="codeline">  else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeline">    // Get memory, cleared to 0</td>
    <td class="lineNumber">95</td>
    <td class="codeline">    // Get memory, cleared to 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeline">    U.pVal = getClearedMemory(getNumWords());</td>
    <td class="lineNumber">96</td>
    <td class="codeline">    U.pVal = getClearedMemory(getNumWords());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeline">    // Calculate the number of words to copy</td>
    <td class="lineNumber">97</td>
    <td class="codeline">    // Calculate the number of words to copy</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeline">    unsigned words = std::min<unsigned>(bigVal.size(), getNumWords());</td>
    <td class="lineNumber">98</td>
    <td class="codeline">    unsigned words = std::min<unsigned>(bigVal.size(), getNumWords());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeline">    // Copy the words from bigVal to pVal</td>
    <td class="lineNumber">99</td>
    <td class="codeline">    // Copy the words from bigVal to pVal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeline">    memcpy(U.pVal, bigVal.data(), words * APINT_WORD_SIZE);</td>
    <td class="lineNumber">100</td>
    <td class="codeline">    memcpy(U.pVal, bigVal.data(), words * APINT_WORD_SIZE);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">101</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeline">  // Make sure unused high bits are cleared</td>
    <td class="lineNumber">102</td>
    <td class="codeline">  // Make sure unused high bits are cleared</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeline">  clearUnusedBits();</td>
    <td class="lineNumber">103</td>
    <td class="codeline">  clearUnusedBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeline">}</td>
    <td class="lineNumber">104</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeline"></td>
    <td class="lineNumber">105</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeline">APInt::APInt(unsigned numBits, ArrayRef<uint64_t> bigVal) : BitWidth(numBits) {</td>
    <td class="lineNumber">106</td>
    <td class="codeline">APInt::APInt(unsigned numBits, ArrayRef<uint64_t> bigVal) : BitWidth(numBits) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeline">  initFromArray(bigVal);</td>
    <td class="lineNumber">107</td>
    <td class="codeline">  initFromArray(bigVal);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeline">}</td>
    <td class="lineNumber">108</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeline"></td>
    <td class="lineNumber">109</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeline">APInt::APInt(unsigned numBits, unsigned numWords, const uint64_t bigVal[])</td>
    <td class="lineNumber">110</td>
    <td class="codeline">APInt::APInt(unsigned numBits, unsigned numWords, const uint64_t bigVal[])</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeline">    : BitWidth(numBits) {</td>
    <td class="lineNumber">111</td>
    <td class="codeline">    : BitWidth(numBits) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeline">  initFromArray(ArrayRef(bigVal, numWords));</td>
    <td class="lineNumber">112</td>
    <td class="codeline">  initFromArray(ArrayRef(bigVal, numWords));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeline">}</td>
    <td class="lineNumber">113</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeline"></td>
    <td class="lineNumber">114</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeline">APInt::APInt(unsigned numbits, StringRef Str, uint8_t radix)</td>
    <td class="lineNumber">115</td>
    <td class="codeline">APInt::APInt(unsigned numbits, StringRef Str, uint8_t radix)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeline">    : BitWidth(numbits) {</td>
    <td class="lineNumber">116</td>
    <td class="codeline">    : BitWidth(numbits) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeline">  fromString(numbits, Str, radix);</td>
    <td class="lineNumber">117</td>
    <td class="codeline">  fromString(numbits, Str, radix);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeline">}</td>
    <td class="lineNumber">118</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeline"></td>
    <td class="lineNumber">119</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeline">void APInt::reallocate(unsigned NewBitWidth) {</td>
    <td class="lineNumber">120</td>
    <td class="codeline">void APInt::reallocate(unsigned NewBitWidth) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeline">  // If the number of words is the same we can just change the width and stop.</td>
    <td class="lineNumber">121</td>
    <td class="codeline">  // If the number of words is the same we can just change the width and stop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeline">  if (getNumWords() == getNumWords(NewBitWidth)) {</td>
    <td class="lineNumber">122</td>
    <td class="codeline">  if (getNumWords() == getNumWords(NewBitWidth)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeline">    BitWidth = NewBitWidth;</td>
    <td class="lineNumber">123</td>
    <td class="codeline">    BitWidth = NewBitWidth;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">124</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">125</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeline"></td>
    <td class="lineNumber">126</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeline">  // If we have an allocation, delete it.</td>
    <td class="lineNumber">127</td>
    <td class="codeline">  // If we have an allocation, delete it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeline">  if (!isSingleWord())</td>
    <td class="lineNumber">128</td>
    <td class="codeline">  if (!isSingleWord())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeline">    delete [] U.pVal;</td>
    <td class="lineNumber">129</td>
    <td class="codeline">    delete [] U.pVal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeline"></td>
    <td class="lineNumber">130</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeline">  // Update BitWidth.</td>
    <td class="lineNumber">131</td>
    <td class="codeline">  // Update BitWidth.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeline">  BitWidth = NewBitWidth;</td>
    <td class="lineNumber">132</td>
    <td class="codeline">  BitWidth = NewBitWidth;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeline"></td>
    <td class="lineNumber">133</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeline">  // If we are supposed to have an allocation, create it.</td>
    <td class="lineNumber">134</td>
    <td class="codeline">  // If we are supposed to have an allocation, create it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeline">  if (!isSingleWord())</td>
    <td class="lineNumber">135</td>
    <td class="codeline">  if (!isSingleWord())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeline">    U.pVal = getMemory(getNumWords());</td>
    <td class="lineNumber">136</td>
    <td class="codeline">    U.pVal = getMemory(getNumWords());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeline">}</td>
    <td class="lineNumber">137</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeline"></td>
    <td class="lineNumber">138</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeline">void APInt::assignSlowCase(const APInt &RHS) {</td>
    <td class="lineNumber">139</td>
    <td class="codeline">void APInt::assignSlowCase(const APInt &RHS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeline">  // Don't do anything for X = X</td>
    <td class="lineNumber">140</td>
    <td class="codeline">  // Don't do anything for X = X</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeline">  if (this == &RHS)</td>
    <td class="lineNumber">141</td>
    <td class="codeline">  if (this == &RHS)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">142</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeline"></td>
    <td class="lineNumber">143</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeline">  // Adjust the bit width and handle allocations as necessary.</td>
    <td class="lineNumber">144</td>
    <td class="codeline">  // Adjust the bit width and handle allocations as necessary.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeline">  reallocate(RHS.getBitWidth());</td>
    <td class="lineNumber">145</td>
    <td class="codeline">  reallocate(RHS.getBitWidth());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeline"></td>
    <td class="lineNumber">146</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeline">  // Copy the data.</td>
    <td class="lineNumber">147</td>
    <td class="codeline">  // Copy the data.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeline">  if (isSingleWord())</td>
    <td class="lineNumber">148</td>
    <td class="codeline">  if (isSingleWord())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeline">    U.VAL = RHS.U.VAL;</td>
    <td class="lineNumber">149</td>
    <td class="codeline">    U.VAL = RHS.U.VAL;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">150</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeline">    memcpy(U.pVal, RHS.U.pVal, getNumWords() * APINT_WORD_SIZE);</td>
    <td class="lineNumber">151</td>
    <td class="codeline">    memcpy(U.pVal, RHS.U.pVal, getNumWords() * APINT_WORD_SIZE);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeline">}</td>
    <td class="lineNumber">152</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeline"></td>
    <td class="lineNumber">153</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeline">/// This method 'profiles' an APInt for use with FoldingSet.</td>
    <td class="lineNumber">154</td>
    <td class="codeline">/// This method 'profiles' an APInt for use with FoldingSet.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeline">void APInt::Profile(FoldingSetNodeID& ID) const {</td>
    <td class="lineNumber">155</td>
    <td class="codeline">void APInt::Profile(FoldingSetNodeID& ID) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeline">  ID.AddInteger(BitWidth);</td>
    <td class="lineNumber">156</td>
    <td class="codeline">  ID.AddInteger(BitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeline"></td>
    <td class="lineNumber">157</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeline">  if (isSingleWord()) {</td>
    <td class="lineNumber">158</td>
    <td class="codeline">  if (isSingleWord()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeline">    ID.AddInteger(U.VAL);</td>
    <td class="lineNumber">159</td>
    <td class="codeline">    ID.AddInteger(U.VAL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">160</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">161</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeline"></td>
    <td class="lineNumber">162</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeline">  unsigned NumWords = getNumWords();</td>
    <td class="lineNumber">163</td>
    <td class="codeline">  unsigned NumWords = getNumWords();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeline">  for (unsigned i = 0; i < NumWords; ++i)</td>
    <td class="lineNumber">164</td>
    <td class="codeline">  for (unsigned i = 0; i < NumWords; ++i)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeline">    ID.AddInteger(U.pVal[i]);</td>
    <td class="lineNumber">165</td>
    <td class="codeline">    ID.AddInteger(U.pVal[i]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeline">}</td>
    <td class="lineNumber">166</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeline"></td>
    <td class="lineNumber">167</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeline">bool APInt::isAligned(Align A) const {</td>
    <td class="lineNumber">168</td>
    <td class="codeline">bool APInt::isAligned(Align A) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeline">  if (isZero())</td>
    <td class="lineNumber">169</td>
    <td class="codeline">  if (isZero())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">170</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeline">  const unsigned TrailingZeroes = countr_zero();</td>
    <td class="lineNumber">171</td>
    <td class="codeline">  const unsigned TrailingZeroes = countr_zero();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeline">  const unsigned MinimumTrailingZeroes = Log2(A);</td>
    <td class="lineNumber">172</td>
    <td class="codeline">  const unsigned MinimumTrailingZeroes = Log2(A);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeline">  return TrailingZeroes >= MinimumTrailingZeroes;</td>
    <td class="lineNumber">173</td>
    <td class="codeline">  return TrailingZeroes >= MinimumTrailingZeroes;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeline">}</td>
    <td class="lineNumber">174</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeline"></td>
    <td class="lineNumber">175</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeline">/// Prefix increment operator. Increments the APInt by one.</td>
    <td class="lineNumber">176</td>
    <td class="codeline">/// Prefix increment operator. Increments the APInt by one.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeline">APInt& APInt::operator++() {</td>
    <td class="lineNumber">177</td>
    <td class="codeline">APInt& APInt::operator++() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeline">  if (isSingleWord())</td>
    <td class="lineNumber">178</td>
    <td class="codeline">  if (isSingleWord())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeline">    ++U.VAL;</td>
    <td class="lineNumber">179</td>
    <td class="codeline">    ++U.VAL;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">180</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeline">    tcIncrement(U.pVal, getNumWords());</td>
    <td class="lineNumber">181</td>
    <td class="codeline">    tcIncrement(U.pVal, getNumWords());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeline">  return clearUnusedBits();</td>
    <td class="lineNumber">182</td>
    <td class="codeline">  return clearUnusedBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeline">}</td>
    <td class="lineNumber">183</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeline"></td>
    <td class="lineNumber">184</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeline">/// Prefix decrement operator. Decrements the APInt by one.</td>
    <td class="lineNumber">185</td>
    <td class="codeline">/// Prefix decrement operator. Decrements the APInt by one.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeline">APInt& APInt::operator--() {</td>
    <td class="lineNumber">186</td>
    <td class="codeline">APInt& APInt::operator--() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeline">  if (isSingleWord())</td>
    <td class="lineNumber">187</td>
    <td class="codeline">  if (isSingleWord())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeline">    --U.VAL;</td>
    <td class="lineNumber">188</td>
    <td class="codeline">    --U.VAL;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">189</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeline">    tcDecrement(U.pVal, getNumWords());</td>
    <td class="lineNumber">190</td>
    <td class="codeline">    tcDecrement(U.pVal, getNumWords());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeline">  return clearUnusedBits();</td>
    <td class="lineNumber">191</td>
    <td class="codeline">  return clearUnusedBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeline">}</td>
    <td class="lineNumber">192</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeline"></td>
    <td class="lineNumber">193</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeline">/// Adds the RHS APInt to this APInt.</td>
    <td class="lineNumber">194</td>
    <td class="codeline">/// Adds the RHS APInt to this APInt.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeline">/// @returns this, after addition of RHS.</td>
    <td class="lineNumber">195</td>
    <td class="codeline">/// @returns this, after addition of RHS.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeline">/// Addition assignment operator.</td>
    <td class="lineNumber">196</td>
    <td class="codeline">/// Addition assignment operator.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeline">APInt& APInt::operator+=(const APInt& RHS) {</td>
    <td class="lineNumber">197</td>
    <td class="codeline">APInt& APInt::operator+=(const APInt& RHS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeline">  assert(BitWidth == RHS.BitWidth && "Bit widths must be the same");</td>
    <td class="lineNumber">198</td>
    <td class="codeline">  assert(BitWidth == RHS.BitWidth && "Bit widths must be the same");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeline">  if (isSingleWord())</td>
    <td class="lineNumber">199</td>
    <td class="codeline">  if (isSingleWord())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeline">    U.VAL += RHS.U.VAL;</td>
    <td class="lineNumber">200</td>
    <td class="codeline">    U.VAL += RHS.U.VAL;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">201</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeline">    tcAdd(U.pVal, RHS.U.pVal, 0, getNumWords());</td>
    <td class="lineNumber">202</td>
    <td class="codeline">    tcAdd(U.pVal, RHS.U.pVal, 0, getNumWords());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeline">  return clearUnusedBits();</td>
    <td class="lineNumber">203</td>
    <td class="codeline">  return clearUnusedBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeline">}</td>
    <td class="lineNumber">204</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeline"></td>
    <td class="lineNumber">205</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeline">APInt& APInt::operator+=(uint64_t RHS) {</td>
    <td class="lineNumber">206</td>
    <td class="codeline">APInt& APInt::operator+=(uint64_t RHS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeline">  if (isSingleWord())</td>
    <td class="lineNumber">207</td>
    <td class="codeline">  if (isSingleWord())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeline">    U.VAL += RHS;</td>
    <td class="lineNumber">208</td>
    <td class="codeline">    U.VAL += RHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">209</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeline">    tcAddPart(U.pVal, RHS, getNumWords());</td>
    <td class="lineNumber">210</td>
    <td class="codeline">    tcAddPart(U.pVal, RHS, getNumWords());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeline">  return clearUnusedBits();</td>
    <td class="lineNumber">211</td>
    <td class="codeline">  return clearUnusedBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeline">}</td>
    <td class="lineNumber">212</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeline"></td>
    <td class="lineNumber">213</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeline">/// Subtracts the RHS APInt from this APInt</td>
    <td class="lineNumber">214</td>
    <td class="codeline">/// Subtracts the RHS APInt from this APInt</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeline">/// @returns this, after subtraction</td>
    <td class="lineNumber">215</td>
    <td class="codeline">/// @returns this, after subtraction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeline">/// Subtraction assignment operator.</td>
    <td class="lineNumber">216</td>
    <td class="codeline">/// Subtraction assignment operator.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeline">APInt& APInt::operator-=(const APInt& RHS) {</td>
    <td class="lineNumber">217</td>
    <td class="codeline">APInt& APInt::operator-=(const APInt& RHS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeline">  assert(BitWidth == RHS.BitWidth && "Bit widths must be the same");</td>
    <td class="lineNumber">218</td>
    <td class="codeline">  assert(BitWidth == RHS.BitWidth && "Bit widths must be the same");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeline">  if (isSingleWord())</td>
    <td class="lineNumber">219</td>
    <td class="codeline">  if (isSingleWord())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeline">    U.VAL -= RHS.U.VAL;</td>
    <td class="lineNumber">220</td>
    <td class="codeline">    U.VAL -= RHS.U.VAL;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">221</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeline">    tcSubtract(U.pVal, RHS.U.pVal, 0, getNumWords());</td>
    <td class="lineNumber">222</td>
    <td class="codeline">    tcSubtract(U.pVal, RHS.U.pVal, 0, getNumWords());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeline">  return clearUnusedBits();</td>
    <td class="lineNumber">223</td>
    <td class="codeline">  return clearUnusedBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeline">}</td>
    <td class="lineNumber">224</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeline"></td>
    <td class="lineNumber">225</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeline">APInt& APInt::operator-=(uint64_t RHS) {</td>
    <td class="lineNumber">226</td>
    <td class="codeline">APInt& APInt::operator-=(uint64_t RHS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeline">  if (isSingleWord())</td>
    <td class="lineNumber">227</td>
    <td class="codeline">  if (isSingleWord())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeline">    U.VAL -= RHS;</td>
    <td class="lineNumber">228</td>
    <td class="codeline">    U.VAL -= RHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">229</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeline">    tcSubtractPart(U.pVal, RHS, getNumWords());</td>
    <td class="lineNumber">230</td>
    <td class="codeline">    tcSubtractPart(U.pVal, RHS, getNumWords());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeline">  return clearUnusedBits();</td>
    <td class="lineNumber">231</td>
    <td class="codeline">  return clearUnusedBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeline">}</td>
    <td class="lineNumber">232</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeline"></td>
    <td class="lineNumber">233</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeline">APInt APInt::operator*(const APInt& RHS) const {</td>
    <td class="lineNumber">234</td>
    <td class="codeline">APInt APInt::operator*(const APInt& RHS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeline">  assert(BitWidth == RHS.BitWidth && "Bit widths must be the same");</td>
    <td class="lineNumber">235</td>
    <td class="codeline">  assert(BitWidth == RHS.BitWidth && "Bit widths must be the same");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeline">  if (isSingleWord())</td>
    <td class="lineNumber">236</td>
    <td class="codeline">  if (isSingleWord())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeline">    return APInt(BitWidth, U.VAL * RHS.U.VAL);</td>
    <td class="lineNumber">237</td>
    <td class="codeline">    return APInt(BitWidth, U.VAL * RHS.U.VAL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeline"></td>
    <td class="lineNumber">238</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeline">  APInt Result(getMemory(getNumWords()), getBitWidth());</td>
    <td class="lineNumber">239</td>
    <td class="codeline">  APInt Result(getMemory(getNumWords()), getBitWidth());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeline">  tcMultiply(Result.U.pVal, U.pVal, RHS.U.pVal, getNumWords());</td>
    <td class="lineNumber">240</td>
    <td class="codeline">  tcMultiply(Result.U.pVal, U.pVal, RHS.U.pVal, getNumWords());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeline">  Result.clearUnusedBits();</td>
    <td class="lineNumber">241</td>
    <td class="codeline">  Result.clearUnusedBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeline">  return Result;</td>
    <td class="lineNumber">242</td>
    <td class="codeline">  return Result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeline">}</td>
    <td class="lineNumber">243</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeline"></td>
    <td class="lineNumber">244</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeline">void APInt::andAssignSlowCase(const APInt &RHS) {</td>
    <td class="lineNumber">245</td>
    <td class="codeline">void APInt::andAssignSlowCase(const APInt &RHS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeline">  WordType *dst = U.pVal, *rhs = RHS.U.pVal;</td>
    <td class="lineNumber">246</td>
    <td class="codeline">  WordType *dst = U.pVal, *rhs = RHS.U.pVal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeline">  for (size_t i = 0, e = getNumWords(); i != e; ++i)</td>
    <td class="lineNumber">247</td>
    <td class="codeline">  for (size_t i = 0, e = getNumWords(); i != e; ++i)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeline">    dst[i] &= rhs[i];</td>
    <td class="lineNumber">248</td>
    <td class="codeline">    dst[i] &= rhs[i];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeline">}</td>
    <td class="lineNumber">249</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeline"></td>
    <td class="lineNumber">250</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeline">void APInt::orAssignSlowCase(const APInt &RHS) {</td>
    <td class="lineNumber">251</td>
    <td class="codeline">void APInt::orAssignSlowCase(const APInt &RHS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeline">  WordType *dst = U.pVal, *rhs = RHS.U.pVal;</td>
    <td class="lineNumber">252</td>
    <td class="codeline">  WordType *dst = U.pVal, *rhs = RHS.U.pVal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeline">  for (size_t i = 0, e = getNumWords(); i != e; ++i)</td>
    <td class="lineNumber">253</td>
    <td class="codeline">  for (size_t i = 0, e = getNumWords(); i != e; ++i)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeline">    dst[i] |= rhs[i];</td>
    <td class="lineNumber">254</td>
    <td class="codeline">    dst[i] |= rhs[i];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeline">}</td>
    <td class="lineNumber">255</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeline"></td>
    <td class="lineNumber">256</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeline">void APInt::xorAssignSlowCase(const APInt &RHS) {</td>
    <td class="lineNumber">257</td>
    <td class="codeline">void APInt::xorAssignSlowCase(const APInt &RHS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeline">  WordType *dst = U.pVal, *rhs = RHS.U.pVal;</td>
    <td class="lineNumber">258</td>
    <td class="codeline">  WordType *dst = U.pVal, *rhs = RHS.U.pVal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeline">  for (size_t i = 0, e = getNumWords(); i != e; ++i)</td>
    <td class="lineNumber">259</td>
    <td class="codeline">  for (size_t i = 0, e = getNumWords(); i != e; ++i)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeline">    dst[i] ^= rhs[i];</td>
    <td class="lineNumber">260</td>
    <td class="codeline">    dst[i] ^= rhs[i];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeline">}</td>
    <td class="lineNumber">261</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeline"></td>
    <td class="lineNumber">262</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeline">APInt &APInt::operator*=(const APInt &RHS) {</td>
    <td class="lineNumber">263</td>
    <td class="codeline">APInt &APInt::operator*=(const APInt &RHS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeline">  *this = *this * RHS;</td>
    <td class="lineNumber">264</td>
    <td class="codeline">  *this = *this * RHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeline">  return *this;</td>
    <td class="lineNumber">265</td>
    <td class="codeline">  return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeline">}</td>
    <td class="lineNumber">266</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeline"></td>
    <td class="lineNumber">267</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeLine diffFirst">APInt& APInt::operator*=(uint64_t RHS) {</td>
    <td class="lineNumber">268</td>
    <td class="codeline">APInt& APInt::operator*=(uint64_t RHS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeLine diffFirst">  if (isSingleWord()) {</td>
    <td class="lineNumber">269</td>
    <td class="codeline">  if (isSingleWord()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeLine diffFirst">    U.VAL *= RHS;</td>
    <td class="lineNumber">270</td>
    <td class="codeline">    U.VAL *= RHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">271</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeline">    unsigned NumWords = getNumWords();</td>
    <td class="lineNumber">272</td>
    <td class="codeline">    unsigned NumWords = getNumWords();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeline">    tcMultiplyPart(U.pVal, U.pVal, RHS, 0, NumWords, NumWords, false);</td>
    <td class="lineNumber">273</td>
    <td class="codeline">    tcMultiplyPart(U.pVal, U.pVal, RHS, 0, NumWords, NumWords, false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">274</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeLine diffFirst">  return clearUnusedBits();</td>
    <td class="lineNumber">275</td>
    <td class="codeline">  return clearUnusedBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeline">}</td>
    <td class="lineNumber">276</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeline"></td>
    <td class="lineNumber">277</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeline">bool APInt::equalSlowCase(const APInt &RHS) const {</td>
    <td class="lineNumber">278</td>
    <td class="codeline">bool APInt::equalSlowCase(const APInt &RHS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeline">  return std::equal(U.pVal, U.pVal + getNumWords(), RHS.U.pVal);</td>
    <td class="lineNumber">279</td>
    <td class="codeline">  return std::equal(U.pVal, U.pVal + getNumWords(), RHS.U.pVal);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeline">}</td>
    <td class="lineNumber">280</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeline"></td>
    <td class="lineNumber">281</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeline">int APInt::compare(const APInt& RHS) const {</td>
    <td class="lineNumber">282</td>
    <td class="codeline">int APInt::compare(const APInt& RHS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeline">  assert(BitWidth == RHS.BitWidth && "Bit widths must be same for comparison");</td>
    <td class="lineNumber">283</td>
    <td class="codeline">  assert(BitWidth == RHS.BitWidth && "Bit widths must be same for comparison");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeline">  if (isSingleWord())</td>
    <td class="lineNumber">284</td>
    <td class="codeline">  if (isSingleWord())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeline">    return U.VAL < RHS.U.VAL ? -1 : U.VAL > RHS.U.VAL;</td>
    <td class="lineNumber">285</td>
    <td class="codeline">    return U.VAL < RHS.U.VAL ? -1 : U.VAL > RHS.U.VAL;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeline"></td>
    <td class="lineNumber">286</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeline">  return tcCompare(U.pVal, RHS.U.pVal, getNumWords());</td>
    <td class="lineNumber">287</td>
    <td class="codeline">  return tcCompare(U.pVal, RHS.U.pVal, getNumWords());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeline">}</td>
    <td class="lineNumber">288</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeline"></td>
    <td class="lineNumber">289</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeline">int APInt::compareSigned(const APInt& RHS) const {</td>
    <td class="lineNumber">290</td>
    <td class="codeline">int APInt::compareSigned(const APInt& RHS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeline">  assert(BitWidth == RHS.BitWidth && "Bit widths must be same for comparison");</td>
    <td class="lineNumber">291</td>
    <td class="codeline">  assert(BitWidth == RHS.BitWidth && "Bit widths must be same for comparison");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeline">  if (isSingleWord()) {</td>
    <td class="lineNumber">292</td>
    <td class="codeline">  if (isSingleWord()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeline">    int64_t lhsSext = SignExtend64(U.VAL, BitWidth);</td>
    <td class="lineNumber">293</td>
    <td class="codeline">    int64_t lhsSext = SignExtend64(U.VAL, BitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeline">    int64_t rhsSext = SignExtend64(RHS.U.VAL, BitWidth);</td>
    <td class="lineNumber">294</td>
    <td class="codeline">    int64_t rhsSext = SignExtend64(RHS.U.VAL, BitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeline">    return lhsSext < rhsSext ? -1 : lhsSext > rhsSext;</td>
    <td class="lineNumber">295</td>
    <td class="codeline">    return lhsSext < rhsSext ? -1 : lhsSext > rhsSext;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">296</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeline"></td>
    <td class="lineNumber">297</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeline">  bool lhsNeg = isNegative();</td>
    <td class="lineNumber">298</td>
    <td class="codeline">  bool lhsNeg = isNegative();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeline">  bool rhsNeg = RHS.isNegative();</td>
    <td class="lineNumber">299</td>
    <td class="codeline">  bool rhsNeg = RHS.isNegative();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeline"></td>
    <td class="lineNumber">300</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeline">  // If the sign bits don't match, then (LHS < RHS) if LHS is negative</td>
    <td class="lineNumber">301</td>
    <td class="codeline">  // If the sign bits don't match, then (LHS < RHS) if LHS is negative</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeline">  if (lhsNeg != rhsNeg)</td>
    <td class="lineNumber">302</td>
    <td class="codeline">  if (lhsNeg != rhsNeg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeline">    return lhsNeg ? -1 : 1;</td>
    <td class="lineNumber">303</td>
    <td class="codeline">    return lhsNeg ? -1 : 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeline"></td>
    <td class="lineNumber">304</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeline">  // Otherwise we can just use an unsigned comparison, because even negative</td>
    <td class="lineNumber">305</td>
    <td class="codeline">  // Otherwise we can just use an unsigned comparison, because even negative</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeline">  // numbers compare correctly this way if both have the same signed-ness.</td>
    <td class="lineNumber">306</td>
    <td class="codeline">  // numbers compare correctly this way if both have the same signed-ness.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeline">  return tcCompare(U.pVal, RHS.U.pVal, getNumWords());</td>
    <td class="lineNumber">307</td>
    <td class="codeline">  return tcCompare(U.pVal, RHS.U.pVal, getNumWords());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeline">}</td>
    <td class="lineNumber">308</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeline"></td>
    <td class="lineNumber">309</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeline">void APInt::setBitsSlowCase(unsigned loBit, unsigned hiBit) {</td>
    <td class="lineNumber">310</td>
    <td class="codeline">void APInt::setBitsSlowCase(unsigned loBit, unsigned hiBit) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeline">  unsigned loWord = whichWord(loBit);</td>
    <td class="lineNumber">311</td>
    <td class="codeline">  unsigned loWord = whichWord(loBit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeline">  unsigned hiWord = whichWord(hiBit);</td>
    <td class="lineNumber">312</td>
    <td class="codeline">  unsigned hiWord = whichWord(hiBit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeline"></td>
    <td class="lineNumber">313</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeline">  // Create an initial mask for the low word with zeros below loBit.</td>
    <td class="lineNumber">314</td>
    <td class="codeline">  // Create an initial mask for the low word with zeros below loBit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeline">  uint64_t loMask = WORDTYPE_MAX << whichBit(loBit);</td>
    <td class="lineNumber">315</td>
    <td class="codeline">  uint64_t loMask = WORDTYPE_MAX << whichBit(loBit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeline"></td>
    <td class="lineNumber">316</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeline">  // If hiBit is not aligned, we need a high mask.</td>
    <td class="lineNumber">317</td>
    <td class="codeline">  // If hiBit is not aligned, we need a high mask.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeline">  unsigned hiShiftAmt = whichBit(hiBit);</td>
    <td class="lineNumber">318</td>
    <td class="codeline">  unsigned hiShiftAmt = whichBit(hiBit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeline">  if (hiShiftAmt != 0) {</td>
    <td class="lineNumber">319</td>
    <td class="codeline">  if (hiShiftAmt != 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeline">    // Create a high mask with zeros above hiBit.</td>
    <td class="lineNumber">320</td>
    <td class="codeline">    // Create a high mask with zeros above hiBit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeline">    uint64_t hiMask = WORDTYPE_MAX >> (APINT_BITS_PER_WORD - hiShiftAmt);</td>
    <td class="lineNumber">321</td>
    <td class="codeline">    uint64_t hiMask = WORDTYPE_MAX >> (APINT_BITS_PER_WORD - hiShiftAmt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeline">    // If loWord and hiWord are equal, then we combine the masks. Otherwise,</td>
    <td class="lineNumber">322</td>
    <td class="codeline">    // If loWord and hiWord are equal, then we combine the masks. Otherwise,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeline">    // set the bits in hiWord.</td>
    <td class="lineNumber">323</td>
    <td class="codeline">    // set the bits in hiWord.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeline">    if (hiWord == loWord)</td>
    <td class="lineNumber">324</td>
    <td class="codeline">    if (hiWord == loWord)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeline">      loMask &= hiMask;</td>
    <td class="lineNumber">325</td>
    <td class="codeline">      loMask &= hiMask;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">326</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeline">      U.pVal[hiWord] |= hiMask;</td>
    <td class="lineNumber">327</td>
    <td class="codeline">      U.pVal[hiWord] |= hiMask;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">328</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeline">  // Apply the mask to the low word.</td>
    <td class="lineNumber">329</td>
    <td class="codeline">  // Apply the mask to the low word.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeline">  U.pVal[loWord] |= loMask;</td>
    <td class="lineNumber">330</td>
    <td class="codeline">  U.pVal[loWord] |= loMask;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeline"></td>
    <td class="lineNumber">331</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeline">  // Fill any words between loWord and hiWord with all ones.</td>
    <td class="lineNumber">332</td>
    <td class="codeline">  // Fill any words between loWord and hiWord with all ones.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeline">  for (unsigned word = loWord + 1; word < hiWord; ++word)</td>
    <td class="lineNumber">333</td>
    <td class="codeline">  for (unsigned word = loWord + 1; word < hiWord; ++word)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeline">    U.pVal[word] = WORDTYPE_MAX;</td>
    <td class="lineNumber">334</td>
    <td class="codeline">    U.pVal[word] = WORDTYPE_MAX;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeline">}</td>
    <td class="lineNumber">335</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeline"></td>
    <td class="lineNumber">336</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeline">// Complement a bignum in-place.</td>
    <td class="lineNumber">337</td>
    <td class="codeline">// Complement a bignum in-place.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeline">static void tcComplement(APInt::WordType *dst, unsigned parts) {</td>
    <td class="lineNumber">338</td>
    <td class="codeline">static void tcComplement(APInt::WordType *dst, unsigned parts) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeline">  for (unsigned i = 0; i < parts; i++)</td>
    <td class="lineNumber">339</td>
    <td class="codeline">  for (unsigned i = 0; i < parts; i++)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeline">    dst[i] = ~dst[i];</td>
    <td class="lineNumber">340</td>
    <td class="codeline">    dst[i] = ~dst[i];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeline">}</td>
    <td class="lineNumber">341</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeline"></td>
    <td class="lineNumber">342</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeline">/// Toggle every bit to its opposite value.</td>
    <td class="lineNumber">343</td>
    <td class="codeline">/// Toggle every bit to its opposite value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeline">void APInt::flipAllBitsSlowCase() {</td>
    <td class="lineNumber">344</td>
    <td class="codeline">void APInt::flipAllBitsSlowCase() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeline">  tcComplement(U.pVal, getNumWords());</td>
    <td class="lineNumber">345</td>
    <td class="codeline">  tcComplement(U.pVal, getNumWords());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeline">  clearUnusedBits();</td>
    <td class="lineNumber">346</td>
    <td class="codeline">  clearUnusedBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeline">}</td>
    <td class="lineNumber">347</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeline"></td>
    <td class="lineNumber">348</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeline">/// Concatenate the bits from "NewLSB" onto the bottom of *this.  This is</td>
    <td class="lineNumber">349</td>
    <td class="codeline">/// Concatenate the bits from "NewLSB" onto the bottom of *this.  This is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeline">/// equivalent to:</td>
    <td class="lineNumber">350</td>
    <td class="codeline">/// equivalent to:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeline">///   (this->zext(NewWidth) << NewLSB.getBitWidth()) | NewLSB.zext(NewWidth)</td>
    <td class="lineNumber">351</td>
    <td class="codeline">///   (this->zext(NewWidth) << NewLSB.getBitWidth()) | NewLSB.zext(NewWidth)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeline">/// In the slow case, we know the result is large.</td>
    <td class="lineNumber">352</td>
    <td class="codeline">/// In the slow case, we know the result is large.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeline">APInt APInt::concatSlowCase(const APInt &NewLSB) const {</td>
    <td class="lineNumber">353</td>
    <td class="codeline">APInt APInt::concatSlowCase(const APInt &NewLSB) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeline">  unsigned NewWidth = getBitWidth() + NewLSB.getBitWidth();</td>
    <td class="lineNumber">354</td>
    <td class="codeline">  unsigned NewWidth = getBitWidth() + NewLSB.getBitWidth();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeline">  APInt Result = NewLSB.zext(NewWidth);</td>
    <td class="lineNumber">355</td>
    <td class="codeline">  APInt Result = NewLSB.zext(NewWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeline">  Result.insertBits(*this, NewLSB.getBitWidth());</td>
    <td class="lineNumber">356</td>
    <td class="codeline">  Result.insertBits(*this, NewLSB.getBitWidth());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeline">  return Result;</td>
    <td class="lineNumber">357</td>
    <td class="codeline">  return Result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeline">}</td>
    <td class="lineNumber">358</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeline"></td>
    <td class="lineNumber">359</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeline">/// Toggle a given bit to its opposite value whose position is given</td>
    <td class="lineNumber">360</td>
    <td class="codeline">/// Toggle a given bit to its opposite value whose position is given</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeline">/// as "bitPosition".</td>
    <td class="lineNumber">361</td>
    <td class="codeline">/// as "bitPosition".</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeline">/// Toggles a given bit to its opposite value.</td>
    <td class="lineNumber">362</td>
    <td class="codeline">/// Toggles a given bit to its opposite value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeline">void APInt::flipBit(unsigned bitPosition) {</td>
    <td class="lineNumber">363</td>
    <td class="codeline">void APInt::flipBit(unsigned bitPosition) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeline">  assert(bitPosition < BitWidth && "Out of the bit-width range!");</td>
    <td class="lineNumber">364</td>
    <td class="codeline">  assert(bitPosition < BitWidth && "Out of the bit-width range!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeline">  setBitVal(bitPosition, !(*this)[bitPosition]);</td>
    <td class="lineNumber">365</td>
    <td class="codeline">  setBitVal(bitPosition, !(*this)[bitPosition]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeline">}</td>
    <td class="lineNumber">366</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeline"></td>
    <td class="lineNumber">367</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeline">void APInt::insertBits(const APInt &subBits, unsigned bitPosition) {</td>
    <td class="lineNumber">368</td>
    <td class="codeline">void APInt::insertBits(const APInt &subBits, unsigned bitPosition) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeline">  unsigned subBitWidth = subBits.getBitWidth();</td>
    <td class="lineNumber">369</td>
    <td class="codeline">  unsigned subBitWidth = subBits.getBitWidth();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeline">  assert((subBitWidth + bitPosition) <= BitWidth && "Illegal bit insertion");</td>
    <td class="lineNumber">370</td>
    <td class="codeline">  assert((subBitWidth + bitPosition) <= BitWidth && "Illegal bit insertion");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeline"></td>
    <td class="lineNumber">371</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeline">  // inserting no bits is a noop.</td>
    <td class="lineNumber">372</td>
    <td class="codeline">  // inserting no bits is a noop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeline">  if (subBitWidth == 0)</td>
    <td class="lineNumber">373</td>
    <td class="codeline">  if (subBitWidth == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">374</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeline"></td>
    <td class="lineNumber">375</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeline">  // Insertion is a direct copy.</td>
    <td class="lineNumber">376</td>
    <td class="codeline">  // Insertion is a direct copy.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeline">  if (subBitWidth == BitWidth) {</td>
    <td class="lineNumber">377</td>
    <td class="codeline">  if (subBitWidth == BitWidth) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeline">    *this = subBits;</td>
    <td class="lineNumber">378</td>
    <td class="codeline">    *this = subBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">379</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">380</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeline"></td>
    <td class="lineNumber">381</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeline">  // Single word result can be done as a direct bitmask.</td>
    <td class="lineNumber">382</td>
    <td class="codeline">  // Single word result can be done as a direct bitmask.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeline">  if (isSingleWord()) {</td>
    <td class="lineNumber">383</td>
    <td class="codeline">  if (isSingleWord()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeline">    uint64_t mask = WORDTYPE_MAX >> (APINT_BITS_PER_WORD - subBitWidth);</td>
    <td class="lineNumber">384</td>
    <td class="codeline">    uint64_t mask = WORDTYPE_MAX >> (APINT_BITS_PER_WORD - subBitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeline">    U.VAL &= ~(mask << bitPosition);</td>
    <td class="lineNumber">385</td>
    <td class="codeline">    U.VAL &= ~(mask << bitPosition);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeline">    U.VAL |= (subBits.U.VAL << bitPosition);</td>
    <td class="lineNumber">386</td>
    <td class="codeline">    U.VAL |= (subBits.U.VAL << bitPosition);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">387</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">388</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeline"></td>
    <td class="lineNumber">389</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeline">  unsigned loBit = whichBit(bitPosition);</td>
    <td class="lineNumber">390</td>
    <td class="codeline">  unsigned loBit = whichBit(bitPosition);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeline">  unsigned loWord = whichWord(bitPosition);</td>
    <td class="lineNumber">391</td>
    <td class="codeline">  unsigned loWord = whichWord(bitPosition);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeline">  unsigned hi1Word = whichWord(bitPosition + subBitWidth - 1);</td>
    <td class="lineNumber">392</td>
    <td class="codeline">  unsigned hi1Word = whichWord(bitPosition + subBitWidth - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeline"></td>
    <td class="lineNumber">393</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeline">  // Insertion within a single word can be done as a direct bitmask.</td>
    <td class="lineNumber">394</td>
    <td class="codeline">  // Insertion within a single word can be done as a direct bitmask.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeline">  if (loWord == hi1Word) {</td>
    <td class="lineNumber">395</td>
    <td class="codeline">  if (loWord == hi1Word) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeline">    uint64_t mask = WORDTYPE_MAX >> (APINT_BITS_PER_WORD - subBitWidth);</td>
    <td class="lineNumber">396</td>
    <td class="codeline">    uint64_t mask = WORDTYPE_MAX >> (APINT_BITS_PER_WORD - subBitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeline">    U.pVal[loWord] &= ~(mask << loBit);</td>
    <td class="lineNumber">397</td>
    <td class="codeline">    U.pVal[loWord] &= ~(mask << loBit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeline">    U.pVal[loWord] |= (subBits.U.VAL << loBit);</td>
    <td class="lineNumber">398</td>
    <td class="codeline">    U.pVal[loWord] |= (subBits.U.VAL << loBit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">399</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">400</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeline"></td>
    <td class="lineNumber">401</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeline">  // Insert on word boundaries.</td>
    <td class="lineNumber">402</td>
    <td class="codeline">  // Insert on word boundaries.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeline">  if (loBit == 0) {</td>
    <td class="lineNumber">403</td>
    <td class="codeline">  if (loBit == 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeline">    // Direct copy whole words.</td>
    <td class="lineNumber">404</td>
    <td class="codeline">    // Direct copy whole words.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeline">    unsigned numWholeSubWords = subBitWidth / APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">405</td>
    <td class="codeline">    unsigned numWholeSubWords = subBitWidth / APINT_BITS_PER_WORD;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeline">    memcpy(U.pVal + loWord, subBits.getRawData(),</td>
    <td class="lineNumber">406</td>
    <td class="codeline">    memcpy(U.pVal + loWord, subBits.getRawData(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeline">           numWholeSubWords * APINT_WORD_SIZE);</td>
    <td class="lineNumber">407</td>
    <td class="codeline">           numWholeSubWords * APINT_WORD_SIZE);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeline"></td>
    <td class="lineNumber">408</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeline">    // Mask+insert remaining bits.</td>
    <td class="lineNumber">409</td>
    <td class="codeline">    // Mask+insert remaining bits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeline">    unsigned remainingBits = subBitWidth % APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">410</td>
    <td class="codeline">    unsigned remainingBits = subBitWidth % APINT_BITS_PER_WORD;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeline">    if (remainingBits != 0) {</td>
    <td class="lineNumber">411</td>
    <td class="codeline">    if (remainingBits != 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeline">      uint64_t mask = WORDTYPE_MAX >> (APINT_BITS_PER_WORD - remainingBits);</td>
    <td class="lineNumber">412</td>
    <td class="codeline">      uint64_t mask = WORDTYPE_MAX >> (APINT_BITS_PER_WORD - remainingBits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeline">      U.pVal[hi1Word] &= ~mask;</td>
    <td class="lineNumber">413</td>
    <td class="codeline">      U.pVal[hi1Word] &= ~mask;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeline">      U.pVal[hi1Word] |= subBits.getWord(subBitWidth - 1);</td>
    <td class="lineNumber">414</td>
    <td class="codeline">      U.pVal[hi1Word] |= subBits.getWord(subBitWidth - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">415</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">416</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">417</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeline"></td>
    <td class="lineNumber">418</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeline">  // General case - set/clear individual bits in dst based on src.</td>
    <td class="lineNumber">419</td>
    <td class="codeline">  // General case - set/clear individual bits in dst based on src.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeline">  // TODO - there is scope for optimization here, but at the moment this code</td>
    <td class="lineNumber">420</td>
    <td class="codeline">  // TODO - there is scope for optimization here, but at the moment this code</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeline">  // path is barely used so prefer readability over performance.</td>
    <td class="lineNumber">421</td>
    <td class="codeline">  // path is barely used so prefer readability over performance.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeline">  for (unsigned i = 0; i != subBitWidth; ++i)</td>
    <td class="lineNumber">422</td>
    <td class="codeline">  for (unsigned i = 0; i != subBitWidth; ++i)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeline">    setBitVal(bitPosition + i, subBits[i]);</td>
    <td class="lineNumber">423</td>
    <td class="codeline">    setBitVal(bitPosition + i, subBits[i]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeline">}</td>
    <td class="lineNumber">424</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeline"></td>
    <td class="lineNumber">425</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeline">void APInt::insertBits(uint64_t subBits, unsigned bitPosition, unsigned numBits) {</td>
    <td class="lineNumber">426</td>
    <td class="codeline">void APInt::insertBits(uint64_t subBits, unsigned bitPosition, unsigned numBits) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeline">  uint64_t maskBits = maskTrailingOnes<uint64_t>(numBits);</td>
    <td class="lineNumber">427</td>
    <td class="codeline">  uint64_t maskBits = maskTrailingOnes<uint64_t>(numBits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeline">  subBits &= maskBits;</td>
    <td class="lineNumber">428</td>
    <td class="codeline">  subBits &= maskBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeline">  if (isSingleWord()) {</td>
    <td class="lineNumber">429</td>
    <td class="codeline">  if (isSingleWord()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeline">    U.VAL &= ~(maskBits << bitPosition);</td>
    <td class="lineNumber">430</td>
    <td class="codeline">    U.VAL &= ~(maskBits << bitPosition);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeline">    U.VAL |= subBits << bitPosition;</td>
    <td class="lineNumber">431</td>
    <td class="codeline">    U.VAL |= subBits << bitPosition;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">432</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">433</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeline"></td>
    <td class="lineNumber">434</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeline">  unsigned loBit = whichBit(bitPosition);</td>
    <td class="lineNumber">435</td>
    <td class="codeline">  unsigned loBit = whichBit(bitPosition);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeline">  unsigned loWord = whichWord(bitPosition);</td>
    <td class="lineNumber">436</td>
    <td class="codeline">  unsigned loWord = whichWord(bitPosition);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeline">  unsigned hiWord = whichWord(bitPosition + numBits - 1);</td>
    <td class="lineNumber">437</td>
    <td class="codeline">  unsigned hiWord = whichWord(bitPosition + numBits - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeline">  if (loWord == hiWord) {</td>
    <td class="lineNumber">438</td>
    <td class="codeline">  if (loWord == hiWord) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeline">    U.pVal[loWord] &= ~(maskBits << loBit);</td>
    <td class="lineNumber">439</td>
    <td class="codeline">    U.pVal[loWord] &= ~(maskBits << loBit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeline">    U.pVal[loWord] |= subBits << loBit;</td>
    <td class="lineNumber">440</td>
    <td class="codeline">    U.pVal[loWord] |= subBits << loBit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">441</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">442</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeline"></td>
    <td class="lineNumber">443</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeline">  static_assert(8 * sizeof(WordType) <= 64, "This code assumes only two words affected");</td>
    <td class="lineNumber">444</td>
    <td class="codeline">  static_assert(8 * sizeof(WordType) <= 64, "This code assumes only two words affected");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeline">  unsigned wordBits = 8 * sizeof(WordType);</td>
    <td class="lineNumber">445</td>
    <td class="codeline">  unsigned wordBits = 8 * sizeof(WordType);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeline">  U.pVal[loWord] &= ~(maskBits << loBit);</td>
    <td class="lineNumber">446</td>
    <td class="codeline">  U.pVal[loWord] &= ~(maskBits << loBit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeline">  U.pVal[loWord] |= subBits << loBit;</td>
    <td class="lineNumber">447</td>
    <td class="codeline">  U.pVal[loWord] |= subBits << loBit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeline"></td>
    <td class="lineNumber">448</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeline">  U.pVal[hiWord] &= ~(maskBits >> (wordBits - loBit));</td>
    <td class="lineNumber">449</td>
    <td class="codeline">  U.pVal[hiWord] &= ~(maskBits >> (wordBits - loBit));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeline">  U.pVal[hiWord] |= subBits >> (wordBits - loBit);</td>
    <td class="lineNumber">450</td>
    <td class="codeline">  U.pVal[hiWord] |= subBits >> (wordBits - loBit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeline">}</td>
    <td class="lineNumber">451</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeline"></td>
    <td class="lineNumber">452</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeline">APInt APInt::extractBits(unsigned numBits, unsigned bitPosition) const {</td>
    <td class="lineNumber">453</td>
    <td class="codeline">APInt APInt::extractBits(unsigned numBits, unsigned bitPosition) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeline">  assert(bitPosition < BitWidth && (numBits + bitPosition) <= BitWidth &&</td>
    <td class="lineNumber">454</td>
    <td class="codeline">  assert(bitPosition < BitWidth && (numBits + bitPosition) <= BitWidth &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeline">         "Illegal bit extraction");</td>
    <td class="lineNumber">455</td>
    <td class="codeline">         "Illegal bit extraction");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeline"></td>
    <td class="lineNumber">456</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeline">  if (isSingleWord())</td>
    <td class="lineNumber">457</td>
    <td class="codeline">  if (isSingleWord())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeline">    return APInt(numBits, U.VAL >> bitPosition);</td>
    <td class="lineNumber">458</td>
    <td class="codeline">    return APInt(numBits, U.VAL >> bitPosition);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeline"></td>
    <td class="lineNumber">459</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeline">  unsigned loBit = whichBit(bitPosition);</td>
    <td class="lineNumber">460</td>
    <td class="codeline">  unsigned loBit = whichBit(bitPosition);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeline">  unsigned loWord = whichWord(bitPosition);</td>
    <td class="lineNumber">461</td>
    <td class="codeline">  unsigned loWord = whichWord(bitPosition);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeline">  unsigned hiWord = whichWord(bitPosition + numBits - 1);</td>
    <td class="lineNumber">462</td>
    <td class="codeline">  unsigned hiWord = whichWord(bitPosition + numBits - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeline"></td>
    <td class="lineNumber">463</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeline">  // Single word result extracting bits from a single word source.</td>
    <td class="lineNumber">464</td>
    <td class="codeline">  // Single word result extracting bits from a single word source.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeline">  if (loWord == hiWord)</td>
    <td class="lineNumber">465</td>
    <td class="codeline">  if (loWord == hiWord)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeline">    return APInt(numBits, U.pVal[loWord] >> loBit);</td>
    <td class="lineNumber">466</td>
    <td class="codeline">    return APInt(numBits, U.pVal[loWord] >> loBit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeline"></td>
    <td class="lineNumber">467</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeline">  // Extracting bits that start on a source word boundary can be done</td>
    <td class="lineNumber">468</td>
    <td class="codeline">  // Extracting bits that start on a source word boundary can be done</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeline">  // as a fast memory copy.</td>
    <td class="lineNumber">469</td>
    <td class="codeline">  // as a fast memory copy.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeline">  if (loBit == 0)</td>
    <td class="lineNumber">470</td>
    <td class="codeline">  if (loBit == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeline">    return APInt(numBits, ArrayRef(U.pVal + loWord, 1 + hiWord - loWord));</td>
    <td class="lineNumber">471</td>
    <td class="codeline">    return APInt(numBits, ArrayRef(U.pVal + loWord, 1 + hiWord - loWord));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeline"></td>
    <td class="lineNumber">472</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeline">  // General case - shift + copy source words directly into place.</td>
    <td class="lineNumber">473</td>
    <td class="codeline">  // General case - shift + copy source words directly into place.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeline">  APInt Result(numBits, 0);</td>
    <td class="lineNumber">474</td>
    <td class="codeline">  APInt Result(numBits, 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeline">  unsigned NumSrcWords = getNumWords();</td>
    <td class="lineNumber">475</td>
    <td class="codeline">  unsigned NumSrcWords = getNumWords();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeline">  unsigned NumDstWords = Result.getNumWords();</td>
    <td class="lineNumber">476</td>
    <td class="codeline">  unsigned NumDstWords = Result.getNumWords();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeline"></td>
    <td class="lineNumber">477</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeline">  uint64_t *DestPtr = Result.isSingleWord() ? &Result.U.VAL : Result.U.pVal;</td>
    <td class="lineNumber">478</td>
    <td class="codeline">  uint64_t *DestPtr = Result.isSingleWord() ? &Result.U.VAL : Result.U.pVal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeline">  for (unsigned word = 0; word < NumDstWords; ++word) {</td>
    <td class="lineNumber">479</td>
    <td class="codeline">  for (unsigned word = 0; word < NumDstWords; ++word) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeline">    uint64_t w0 = U.pVal[loWord + word];</td>
    <td class="lineNumber">480</td>
    <td class="codeline">    uint64_t w0 = U.pVal[loWord + word];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeline">    uint64_t w1 =</td>
    <td class="lineNumber">481</td>
    <td class="codeline">    uint64_t w1 =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeline">        (loWord + word + 1) < NumSrcWords ? U.pVal[loWord + word + 1] : 0;</td>
    <td class="lineNumber">482</td>
    <td class="codeline">        (loWord + word + 1) < NumSrcWords ? U.pVal[loWord + word + 1] : 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeline">    DestPtr[word] = (w0 >> loBit) | (w1 << (APINT_BITS_PER_WORD - loBit));</td>
    <td class="lineNumber">483</td>
    <td class="codeline">    DestPtr[word] = (w0 >> loBit) | (w1 << (APINT_BITS_PER_WORD - loBit));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">484</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeline"></td>
    <td class="lineNumber">485</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeline">  return Result.clearUnusedBits();</td>
    <td class="lineNumber">486</td>
    <td class="codeline">  return Result.clearUnusedBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeline">}</td>
    <td class="lineNumber">487</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeline"></td>
    <td class="lineNumber">488</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeline">uint64_t APInt::extractBitsAsZExtValue(unsigned numBits,</td>
    <td class="lineNumber">489</td>
    <td class="codeline">uint64_t APInt::extractBitsAsZExtValue(unsigned numBits,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeline">                                       unsigned bitPosition) const {</td>
    <td class="lineNumber">490</td>
    <td class="codeline">                                       unsigned bitPosition) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeline">  assert(bitPosition < BitWidth && (numBits + bitPosition) <= BitWidth &&</td>
    <td class="lineNumber">491</td>
    <td class="codeline">  assert(bitPosition < BitWidth && (numBits + bitPosition) <= BitWidth &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeline">         "Illegal bit extraction");</td>
    <td class="lineNumber">492</td>
    <td class="codeline">         "Illegal bit extraction");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeline">  assert(numBits <= 64 && "Illegal bit extraction");</td>
    <td class="lineNumber">493</td>
    <td class="codeline">  assert(numBits <= 64 && "Illegal bit extraction");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeline"></td>
    <td class="lineNumber">494</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeline">  uint64_t maskBits = maskTrailingOnes<uint64_t>(numBits);</td>
    <td class="lineNumber">495</td>
    <td class="codeline">  uint64_t maskBits = maskTrailingOnes<uint64_t>(numBits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeline">  if (isSingleWord())</td>
    <td class="lineNumber">496</td>
    <td class="codeline">  if (isSingleWord())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeline">    return (U.VAL >> bitPosition) & maskBits;</td>
    <td class="lineNumber">497</td>
    <td class="codeline">    return (U.VAL >> bitPosition) & maskBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeline"></td>
    <td class="lineNumber">498</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeline">  unsigned loBit = whichBit(bitPosition);</td>
    <td class="lineNumber">499</td>
    <td class="codeline">  unsigned loBit = whichBit(bitPosition);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeline">  unsigned loWord = whichWord(bitPosition);</td>
    <td class="lineNumber">500</td>
    <td class="codeline">  unsigned loWord = whichWord(bitPosition);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeline">  unsigned hiWord = whichWord(bitPosition + numBits - 1);</td>
    <td class="lineNumber">501</td>
    <td class="codeline">  unsigned hiWord = whichWord(bitPosition + numBits - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeline">  if (loWord == hiWord)</td>
    <td class="lineNumber">502</td>
    <td class="codeline">  if (loWord == hiWord)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeline">    return (U.pVal[loWord] >> loBit) & maskBits;</td>
    <td class="lineNumber">503</td>
    <td class="codeline">    return (U.pVal[loWord] >> loBit) & maskBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeline"></td>
    <td class="lineNumber">504</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeline">  static_assert(8 * sizeof(WordType) <= 64, "This code assumes only two words affected");</td>
    <td class="lineNumber">505</td>
    <td class="codeline">  static_assert(8 * sizeof(WordType) <= 64, "This code assumes only two words affected");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeline">  unsigned wordBits = 8 * sizeof(WordType);</td>
    <td class="lineNumber">506</td>
    <td class="codeline">  unsigned wordBits = 8 * sizeof(WordType);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeline">  uint64_t retBits = U.pVal[loWord] >> loBit;</td>
    <td class="lineNumber">507</td>
    <td class="codeline">  uint64_t retBits = U.pVal[loWord] >> loBit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeline">  retBits |= U.pVal[hiWord] << (wordBits - loBit);</td>
    <td class="lineNumber">508</td>
    <td class="codeline">  retBits |= U.pVal[hiWord] << (wordBits - loBit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeline">  retBits &= maskBits;</td>
    <td class="lineNumber">509</td>
    <td class="codeline">  retBits &= maskBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeline">  return retBits;</td>
    <td class="lineNumber">510</td>
    <td class="codeline">  return retBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeline">}</td>
    <td class="lineNumber">511</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeline"></td>
    <td class="lineNumber">512</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeline">unsigned APInt::getSufficientBitsNeeded(StringRef Str, uint8_t Radix) {</td>
    <td class="lineNumber">513</td>
    <td class="codeline">unsigned APInt::getSufficientBitsNeeded(StringRef Str, uint8_t Radix) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeline">  assert(!Str.empty() && "Invalid string length");</td>
    <td class="lineNumber">514</td>
    <td class="codeline">  assert(!Str.empty() && "Invalid string length");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeline">  size_t StrLen = Str.size();</td>
    <td class="lineNumber">515</td>
    <td class="codeline">  size_t StrLen = Str.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeline"></td>
    <td class="lineNumber">516</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeline">  // Each computation below needs to know if it's negative.</td>
    <td class="lineNumber">517</td>
    <td class="codeline">  // Each computation below needs to know if it's negative.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeline">  unsigned IsNegative = false;</td>
    <td class="lineNumber">518</td>
    <td class="codeline">  unsigned IsNegative = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeline">  if (Str[0] == '-' || Str[0] == '+') {</td>
    <td class="lineNumber">519</td>
    <td class="codeline">  if (Str[0] == '-' || Str[0] == '+') {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeline">    IsNegative = Str[0] == '-';</td>
    <td class="lineNumber">520</td>
    <td class="codeline">    IsNegative = Str[0] == '-';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeline">    StrLen--;</td>
    <td class="lineNumber">521</td>
    <td class="codeline">    StrLen--;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeline">    assert(StrLen && "String is only a sign, needs a value.");</td>
    <td class="lineNumber">522</td>
    <td class="codeline">    assert(StrLen && "String is only a sign, needs a value.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">523</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeline"></td>
    <td class="lineNumber">524</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeline">  // For radixes of power-of-two values, the bits required is accurately and</td>
    <td class="lineNumber">525</td>
    <td class="codeline">  // For radixes of power-of-two values, the bits required is accurately and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeline">  // easily computed.</td>
    <td class="lineNumber">526</td>
    <td class="codeline">  // easily computed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeline">  if (Radix == 2)</td>
    <td class="lineNumber">527</td>
    <td class="codeline">  if (Radix == 2)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeline">    return StrLen + IsNegative;</td>
    <td class="lineNumber">528</td>
    <td class="codeline">    return StrLen + IsNegative;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeline">  if (Radix == 8)</td>
    <td class="lineNumber">529</td>
    <td class="codeline">  if (Radix == 8)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeline">    return StrLen * 3 + IsNegative;</td>
    <td class="lineNumber">530</td>
    <td class="codeline">    return StrLen * 3 + IsNegative;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeline">  if (Radix == 16)</td>
    <td class="lineNumber">531</td>
    <td class="codeline">  if (Radix == 16)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeline">    return StrLen * 4 + IsNegative;</td>
    <td class="lineNumber">532</td>
    <td class="codeline">    return StrLen * 4 + IsNegative;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeline"></td>
    <td class="lineNumber">533</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeline">  // Compute a sufficient number of bits that is always large enough but might</td>
    <td class="lineNumber">534</td>
    <td class="codeline">  // Compute a sufficient number of bits that is always large enough but might</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeline">  // be too large. This avoids the assertion in the constructor. This</td>
    <td class="lineNumber">535</td>
    <td class="codeline">  // be too large. This avoids the assertion in the constructor. This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeline">  // calculation doesn't work appropriately for the numbers 0-9, so just use 4</td>
    <td class="lineNumber">536</td>
    <td class="codeline">  // calculation doesn't work appropriately for the numbers 0-9, so just use 4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeline">  // bits in that case.</td>
    <td class="lineNumber">537</td>
    <td class="codeline">  // bits in that case.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeline">  if (Radix == 10)</td>
    <td class="lineNumber">538</td>
    <td class="codeline">  if (Radix == 10)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeline">    return (StrLen == 1 ? 4 : StrLen * 64 / 18) + IsNegative;</td>
    <td class="lineNumber">539</td>
    <td class="codeline">    return (StrLen == 1 ? 4 : StrLen * 64 / 18) + IsNegative;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeline"></td>
    <td class="lineNumber">540</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeline">  assert(Radix == 36);</td>
    <td class="lineNumber">541</td>
    <td class="codeline">  assert(Radix == 36);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeline">  return (StrLen == 1 ? 7 : StrLen * 16 / 3) + IsNegative;</td>
    <td class="lineNumber">542</td>
    <td class="codeline">  return (StrLen == 1 ? 7 : StrLen * 16 / 3) + IsNegative;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeline">}</td>
    <td class="lineNumber">543</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeline"></td>
    <td class="lineNumber">544</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeline">unsigned APInt::getBitsNeeded(StringRef str, uint8_t radix) {</td>
    <td class="lineNumber">545</td>
    <td class="codeline">unsigned APInt::getBitsNeeded(StringRef str, uint8_t radix) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeline">  // Compute a sufficient number of bits that is always large enough but might</td>
    <td class="lineNumber">546</td>
    <td class="codeline">  // Compute a sufficient number of bits that is always large enough but might</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeline">  // be too large.</td>
    <td class="lineNumber">547</td>
    <td class="codeline">  // be too large.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeline">  unsigned sufficient = getSufficientBitsNeeded(str, radix);</td>
    <td class="lineNumber">548</td>
    <td class="codeline">  unsigned sufficient = getSufficientBitsNeeded(str, radix);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeline"></td>
    <td class="lineNumber">549</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeline">  // For bases 2, 8, and 16, the sufficient number of bits is exact and we can</td>
    <td class="lineNumber">550</td>
    <td class="codeline">  // For bases 2, 8, and 16, the sufficient number of bits is exact and we can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeline">  // return the value directly. For bases 10 and 36, we need to do extra work.</td>
    <td class="lineNumber">551</td>
    <td class="codeline">  // return the value directly. For bases 10 and 36, we need to do extra work.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeline">  if (radix == 2 || radix == 8 || radix == 16)</td>
    <td class="lineNumber">552</td>
    <td class="codeline">  if (radix == 2 || radix == 8 || radix == 16)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeline">    return sufficient;</td>
    <td class="lineNumber">553</td>
    <td class="codeline">    return sufficient;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeline"></td>
    <td class="lineNumber">554</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeline">  // This is grossly inefficient but accurate. We could probably do something</td>
    <td class="lineNumber">555</td>
    <td class="codeline">  // This is grossly inefficient but accurate. We could probably do something</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeline">  // with a computation of roughly slen*64/20 and then adjust by the value of</td>
    <td class="lineNumber">556</td>
    <td class="codeline">  // with a computation of roughly slen*64/20 and then adjust by the value of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeline">  // the first few digits. But, I'm not sure how accurate that could be.</td>
    <td class="lineNumber">557</td>
    <td class="codeline">  // the first few digits. But, I'm not sure how accurate that could be.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeline">  size_t slen = str.size();</td>
    <td class="lineNumber">558</td>
    <td class="codeline">  size_t slen = str.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeline"></td>
    <td class="lineNumber">559</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeline">  // Each computation below needs to know if it's negative.</td>
    <td class="lineNumber">560</td>
    <td class="codeline">  // Each computation below needs to know if it's negative.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeline">  StringRef::iterator p = str.begin();</td>
    <td class="lineNumber">561</td>
    <td class="codeline">  StringRef::iterator p = str.begin();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeline">  unsigned isNegative = *p == '-';</td>
    <td class="lineNumber">562</td>
    <td class="codeline">  unsigned isNegative = *p == '-';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeline">  if (*p == '-' || *p == '+') {</td>
    <td class="lineNumber">563</td>
    <td class="codeline">  if (*p == '-' || *p == '+') {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeline">    p++;</td>
    <td class="lineNumber">564</td>
    <td class="codeline">    p++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeline">    slen--;</td>
    <td class="lineNumber">565</td>
    <td class="codeline">    slen--;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeline">    assert(slen && "String is only a sign, needs a value.");</td>
    <td class="lineNumber">566</td>
    <td class="codeline">    assert(slen && "String is only a sign, needs a value.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">567</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeline"></td>
    <td class="lineNumber">568</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeline"></td>
    <td class="lineNumber">569</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeline">  // Convert to the actual binary value.</td>
    <td class="lineNumber">570</td>
    <td class="codeline">  // Convert to the actual binary value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeline">  APInt tmp(sufficient, StringRef(p, slen), radix);</td>
    <td class="lineNumber">571</td>
    <td class="codeline">  APInt tmp(sufficient, StringRef(p, slen), radix);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeline"></td>
    <td class="lineNumber">572</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeline">  // Compute how many bits are required. If the log is infinite, assume we need</td>
    <td class="lineNumber">573</td>
    <td class="codeline">  // Compute how many bits are required. If the log is infinite, assume we need</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeline">  // just bit. If the log is exact and value is negative, then the value is</td>
    <td class="lineNumber">574</td>
    <td class="codeline">  // just bit. If the log is exact and value is negative, then the value is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeline">  // MinSignedValue with (log + 1) bits.</td>
    <td class="lineNumber">575</td>
    <td class="codeline">  // MinSignedValue with (log + 1) bits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeline">  unsigned log = tmp.logBase2();</td>
    <td class="lineNumber">576</td>
    <td class="codeline">  unsigned log = tmp.logBase2();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeline">  if (log == (unsigned)-1) {</td>
    <td class="lineNumber">577</td>
    <td class="codeline">  if (log == (unsigned)-1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeline">    return isNegative + 1;</td>
    <td class="lineNumber">578</td>
    <td class="codeline">    return isNegative + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeline">  } else if (isNegative && tmp.isPowerOf2()) {</td>
    <td class="lineNumber">579</td>
    <td class="codeline">  } else if (isNegative && tmp.isPowerOf2()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeline">    return isNegative + log;</td>
    <td class="lineNumber">580</td>
    <td class="codeline">    return isNegative + log;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">581</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeline">    return isNegative + log + 1;</td>
    <td class="lineNumber">582</td>
    <td class="codeline">    return isNegative + log + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">583</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeline">}</td>
    <td class="lineNumber">584</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeline"></td>
    <td class="lineNumber">585</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeline">hash_code llvm::hash_value(const APInt &Arg) {</td>
    <td class="lineNumber">586</td>
    <td class="codeline">hash_code llvm::hash_value(const APInt &Arg) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeline">  if (Arg.isSingleWord())</td>
    <td class="lineNumber">587</td>
    <td class="codeline">  if (Arg.isSingleWord())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeline">    return hash_combine(Arg.BitWidth, Arg.U.VAL);</td>
    <td class="lineNumber">588</td>
    <td class="codeline">    return hash_combine(Arg.BitWidth, Arg.U.VAL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeline"></td>
    <td class="lineNumber">589</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeline">  return hash_combine(</td>
    <td class="lineNumber">590</td>
    <td class="codeline">  return hash_combine(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeline">      Arg.BitWidth,</td>
    <td class="lineNumber">591</td>
    <td class="codeline">      Arg.BitWidth,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeline">      hash_combine_range(Arg.U.pVal, Arg.U.pVal + Arg.getNumWords()));</td>
    <td class="lineNumber">592</td>
    <td class="codeline">      hash_combine_range(Arg.U.pVal, Arg.U.pVal + Arg.getNumWords()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeline">}</td>
    <td class="lineNumber">593</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeline"></td>
    <td class="lineNumber">594</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeline">unsigned DenseMapInfo<APInt, void>::getHashValue(const APInt &Key) {</td>
    <td class="lineNumber">595</td>
    <td class="codeline">unsigned DenseMapInfo<APInt, void>::getHashValue(const APInt &Key) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeline">  return static_cast<unsigned>(hash_value(Key));</td>
    <td class="lineNumber">596</td>
    <td class="codeline">  return static_cast<unsigned>(hash_value(Key));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeline">}</td>
    <td class="lineNumber">597</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeline"></td>
    <td class="lineNumber">598</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeline">bool APInt::isSplat(unsigned SplatSizeInBits) const {</td>
    <td class="lineNumber">599</td>
    <td class="codeline">bool APInt::isSplat(unsigned SplatSizeInBits) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeline">  assert(getBitWidth() % SplatSizeInBits == 0 &&</td>
    <td class="lineNumber">600</td>
    <td class="codeline">  assert(getBitWidth() % SplatSizeInBits == 0 &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeline">         "SplatSizeInBits must divide width!");</td>
    <td class="lineNumber">601</td>
    <td class="codeline">         "SplatSizeInBits must divide width!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeline">  // We can check that all parts of an integer are equal by making use of a</td>
    <td class="lineNumber">602</td>
    <td class="codeline">  // We can check that all parts of an integer are equal by making use of a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeline">  // little trick: rotate and check if it's still the same value.</td>
    <td class="lineNumber">603</td>
    <td class="codeline">  // little trick: rotate and check if it's still the same value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeline">  return *this == rotl(SplatSizeInBits);</td>
    <td class="lineNumber">604</td>
    <td class="codeline">  return *this == rotl(SplatSizeInBits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeline">}</td>
    <td class="lineNumber">605</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeline"></td>
    <td class="lineNumber">606</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeline">/// This function returns the high "numBits" bits of this APInt.</td>
    <td class="lineNumber">607</td>
    <td class="codeline">/// This function returns the high "numBits" bits of this APInt.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeline">APInt APInt::getHiBits(unsigned numBits) const {</td>
    <td class="lineNumber">608</td>
    <td class="codeline">APInt APInt::getHiBits(unsigned numBits) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeline">  return this->lshr(BitWidth - numBits);</td>
    <td class="lineNumber">609</td>
    <td class="codeline">  return this->lshr(BitWidth - numBits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeline">}</td>
    <td class="lineNumber">610</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeline"></td>
    <td class="lineNumber">611</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeline">/// This function returns the low "numBits" bits of this APInt.</td>
    <td class="lineNumber">612</td>
    <td class="codeline">/// This function returns the low "numBits" bits of this APInt.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeline">APInt APInt::getLoBits(unsigned numBits) const {</td>
    <td class="lineNumber">613</td>
    <td class="codeline">APInt APInt::getLoBits(unsigned numBits) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeline">  APInt Result(getLowBitsSet(BitWidth, numBits));</td>
    <td class="lineNumber">614</td>
    <td class="codeline">  APInt Result(getLowBitsSet(BitWidth, numBits));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeline">  Result &= *this;</td>
    <td class="lineNumber">615</td>
    <td class="codeline">  Result &= *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeline">  return Result;</td>
    <td class="lineNumber">616</td>
    <td class="codeline">  return Result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeline">}</td>
    <td class="lineNumber">617</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeline"></td>
    <td class="lineNumber">618</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeline">/// Return a value containing V broadcasted over NewLen bits.</td>
    <td class="lineNumber">619</td>
    <td class="codeline">/// Return a value containing V broadcasted over NewLen bits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeline">APInt APInt::getSplat(unsigned NewLen, const APInt &V) {</td>
    <td class="lineNumber">620</td>
    <td class="codeline">APInt APInt::getSplat(unsigned NewLen, const APInt &V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeline">  assert(NewLen >= V.getBitWidth() && "Can't splat to smaller bit width!");</td>
    <td class="lineNumber">621</td>
    <td class="codeline">  assert(NewLen >= V.getBitWidth() && "Can't splat to smaller bit width!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeline"></td>
    <td class="lineNumber">622</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeline">  APInt Val = V.zext(NewLen);</td>
    <td class="lineNumber">623</td>
    <td class="codeline">  APInt Val = V.zext(NewLen);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeline">  for (unsigned I = V.getBitWidth(); I < NewLen; I <<= 1)</td>
    <td class="lineNumber">624</td>
    <td class="codeline">  for (unsigned I = V.getBitWidth(); I < NewLen; I <<= 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeline">    Val |= Val << I;</td>
    <td class="lineNumber">625</td>
    <td class="codeline">    Val |= Val << I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeline"></td>
    <td class="lineNumber">626</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeline">  return Val;</td>
    <td class="lineNumber">627</td>
    <td class="codeline">  return Val;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeline">}</td>
    <td class="lineNumber">628</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeline"></td>
    <td class="lineNumber">629</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeline">unsigned APInt::countLeadingZerosSlowCase() const {</td>
    <td class="lineNumber">630</td>
    <td class="codeline">unsigned APInt::countLeadingZerosSlowCase() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeline">  unsigned Count = 0;</td>
    <td class="lineNumber">631</td>
    <td class="codeline">  unsigned Count = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeline">  for (int i = getNumWords()-1; i >= 0; --i) {</td>
    <td class="lineNumber">632</td>
    <td class="codeline">  for (int i = getNumWords()-1; i >= 0; --i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeline">    uint64_t V = U.pVal[i];</td>
    <td class="lineNumber">633</td>
    <td class="codeline">    uint64_t V = U.pVal[i];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeline">    if (V == 0)</td>
    <td class="lineNumber">634</td>
    <td class="codeline">    if (V == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeline">      Count += APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">635</td>
    <td class="codeline">      Count += APINT_BITS_PER_WORD;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeline">    else {</td>
    <td class="lineNumber">636</td>
    <td class="codeline">    else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeline">      Count += llvm::countl_zero(V);</td>
    <td class="lineNumber">637</td>
    <td class="codeline">      Count += llvm::countl_zero(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">638</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">639</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">640</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeline">  // Adjust for unused bits in the most significant word (they are zero).</td>
    <td class="lineNumber">641</td>
    <td class="codeline">  // Adjust for unused bits in the most significant word (they are zero).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeline">  unsigned Mod = BitWidth % APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">642</td>
    <td class="codeline">  unsigned Mod = BitWidth % APINT_BITS_PER_WORD;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeline">  Count -= Mod > 0 ? APINT_BITS_PER_WORD - Mod : 0;</td>
    <td class="lineNumber">643</td>
    <td class="codeline">  Count -= Mod > 0 ? APINT_BITS_PER_WORD - Mod : 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeline">  return Count;</td>
    <td class="lineNumber">644</td>
    <td class="codeline">  return Count;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeline">}</td>
    <td class="lineNumber">645</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeline"></td>
    <td class="lineNumber">646</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeline">unsigned APInt::countLeadingOnesSlowCase() const {</td>
    <td class="lineNumber">647</td>
    <td class="codeline">unsigned APInt::countLeadingOnesSlowCase() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeline">  unsigned highWordBits = BitWidth % APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">648</td>
    <td class="codeline">  unsigned highWordBits = BitWidth % APINT_BITS_PER_WORD;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeline">  unsigned shift;</td>
    <td class="lineNumber">649</td>
    <td class="codeline">  unsigned shift;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeline">  if (!highWordBits) {</td>
    <td class="lineNumber">650</td>
    <td class="codeline">  if (!highWordBits) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeline">    highWordBits = APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">651</td>
    <td class="codeline">    highWordBits = APINT_BITS_PER_WORD;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeline">    shift = 0;</td>
    <td class="lineNumber">652</td>
    <td class="codeline">    shift = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">653</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeline">    shift = APINT_BITS_PER_WORD - highWordBits;</td>
    <td class="lineNumber">654</td>
    <td class="codeline">    shift = APINT_BITS_PER_WORD - highWordBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">655</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeline">  int i = getNumWords() - 1;</td>
    <td class="lineNumber">656</td>
    <td class="codeline">  int i = getNumWords() - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeline">  unsigned Count = llvm::countl_one(U.pVal[i] << shift);</td>
    <td class="lineNumber">657</td>
    <td class="codeline">  unsigned Count = llvm::countl_one(U.pVal[i] << shift);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeline">  if (Count == highWordBits) {</td>
    <td class="lineNumber">658</td>
    <td class="codeline">  if (Count == highWordBits) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeline">    for (i--; i >= 0; --i) {</td>
    <td class="lineNumber">659</td>
    <td class="codeline">    for (i--; i >= 0; --i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeline">      if (U.pVal[i] == WORDTYPE_MAX)</td>
    <td class="lineNumber">660</td>
    <td class="codeline">      if (U.pVal[i] == WORDTYPE_MAX)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeline">        Count += APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">661</td>
    <td class="codeline">        Count += APINT_BITS_PER_WORD;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeline">      else {</td>
    <td class="lineNumber">662</td>
    <td class="codeline">      else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeline">        Count += llvm::countl_one(U.pVal[i]);</td>
    <td class="lineNumber">663</td>
    <td class="codeline">        Count += llvm::countl_one(U.pVal[i]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">664</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">665</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">666</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">667</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeline">  return Count;</td>
    <td class="lineNumber">668</td>
    <td class="codeline">  return Count;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeline">}</td>
    <td class="lineNumber">669</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeline"></td>
    <td class="lineNumber">670</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeline">unsigned APInt::countTrailingZerosSlowCase() const {</td>
    <td class="lineNumber">671</td>
    <td class="codeline">unsigned APInt::countTrailingZerosSlowCase() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeline">  unsigned Count = 0;</td>
    <td class="lineNumber">672</td>
    <td class="codeline">  unsigned Count = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeline">  unsigned i = 0;</td>
    <td class="lineNumber">673</td>
    <td class="codeline">  unsigned i = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeline">  for (; i < getNumWords() && U.pVal[i] == 0; ++i)</td>
    <td class="lineNumber">674</td>
    <td class="codeline">  for (; i < getNumWords() && U.pVal[i] == 0; ++i)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeline">    Count += APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">675</td>
    <td class="codeline">    Count += APINT_BITS_PER_WORD;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeline">  if (i < getNumWords())</td>
    <td class="lineNumber">676</td>
    <td class="codeline">  if (i < getNumWords())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeline">    Count += llvm::countr_zero(U.pVal[i]);</td>
    <td class="lineNumber">677</td>
    <td class="codeline">    Count += llvm::countr_zero(U.pVal[i]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeline">  return std::min(Count, BitWidth);</td>
    <td class="lineNumber">678</td>
    <td class="codeline">  return std::min(Count, BitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeline">}</td>
    <td class="lineNumber">679</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeline"></td>
    <td class="lineNumber">680</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeline">unsigned APInt::countTrailingOnesSlowCase() const {</td>
    <td class="lineNumber">681</td>
    <td class="codeline">unsigned APInt::countTrailingOnesSlowCase() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeline">  unsigned Count = 0;</td>
    <td class="lineNumber">682</td>
    <td class="codeline">  unsigned Count = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeline">  unsigned i = 0;</td>
    <td class="lineNumber">683</td>
    <td class="codeline">  unsigned i = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeline">  for (; i < getNumWords() && U.pVal[i] == WORDTYPE_MAX; ++i)</td>
    <td class="lineNumber">684</td>
    <td class="codeline">  for (; i < getNumWords() && U.pVal[i] == WORDTYPE_MAX; ++i)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeline">    Count += APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">685</td>
    <td class="codeline">    Count += APINT_BITS_PER_WORD;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeline">  if (i < getNumWords())</td>
    <td class="lineNumber">686</td>
    <td class="codeline">  if (i < getNumWords())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeline">    Count += llvm::countr_one(U.pVal[i]);</td>
    <td class="lineNumber">687</td>
    <td class="codeline">    Count += llvm::countr_one(U.pVal[i]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeline">  assert(Count <= BitWidth);</td>
    <td class="lineNumber">688</td>
    <td class="codeline">  assert(Count <= BitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeline">  return Count;</td>
    <td class="lineNumber">689</td>
    <td class="codeline">  return Count;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeline">}</td>
    <td class="lineNumber">690</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeline"></td>
    <td class="lineNumber">691</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeline">unsigned APInt::countPopulationSlowCase() const {</td>
    <td class="lineNumber">692</td>
    <td class="codeline">unsigned APInt::countPopulationSlowCase() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeline">  unsigned Count = 0;</td>
    <td class="lineNumber">693</td>
    <td class="codeline">  unsigned Count = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeline">  for (unsigned i = 0; i < getNumWords(); ++i)</td>
    <td class="lineNumber">694</td>
    <td class="codeline">  for (unsigned i = 0; i < getNumWords(); ++i)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeline">    Count += llvm::popcount(U.pVal[i]);</td>
    <td class="lineNumber">695</td>
    <td class="codeline">    Count += llvm::popcount(U.pVal[i]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeline">  return Count;</td>
    <td class="lineNumber">696</td>
    <td class="codeline">  return Count;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeline">}</td>
    <td class="lineNumber">697</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeline"></td>
    <td class="lineNumber">698</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeline">bool APInt::intersectsSlowCase(const APInt &RHS) const {</td>
    <td class="lineNumber">699</td>
    <td class="codeline">bool APInt::intersectsSlowCase(const APInt &RHS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeline">  for (unsigned i = 0, e = getNumWords(); i != e; ++i)</td>
    <td class="lineNumber">700</td>
    <td class="codeline">  for (unsigned i = 0, e = getNumWords(); i != e; ++i)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeline">    if ((U.pVal[i] & RHS.U.pVal[i]) != 0)</td>
    <td class="lineNumber">701</td>
    <td class="codeline">    if ((U.pVal[i] & RHS.U.pVal[i]) != 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">702</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeline"></td>
    <td class="lineNumber">703</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">704</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeline">}</td>
    <td class="lineNumber">705</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeline"></td>
    <td class="lineNumber">706</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeline">bool APInt::isSubsetOfSlowCase(const APInt &RHS) const {</td>
    <td class="lineNumber">707</td>
    <td class="codeline">bool APInt::isSubsetOfSlowCase(const APInt &RHS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeline">  for (unsigned i = 0, e = getNumWords(); i != e; ++i)</td>
    <td class="lineNumber">708</td>
    <td class="codeline">  for (unsigned i = 0, e = getNumWords(); i != e; ++i)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeline">    if ((U.pVal[i] & ~RHS.U.pVal[i]) != 0)</td>
    <td class="lineNumber">709</td>
    <td class="codeline">    if ((U.pVal[i] & ~RHS.U.pVal[i]) != 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">710</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeline"></td>
    <td class="lineNumber">711</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">712</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeline">}</td>
    <td class="lineNumber">713</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeline"></td>
    <td class="lineNumber">714</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeline">APInt APInt::byteSwap() const {</td>
    <td class="lineNumber">715</td>
    <td class="codeline">APInt APInt::byteSwap() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeline">  assert(BitWidth >= 16 && BitWidth % 8 == 0 && "Cannot byteswap!");</td>
    <td class="lineNumber">716</td>
    <td class="codeline">  assert(BitWidth >= 16 && BitWidth % 8 == 0 && "Cannot byteswap!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeline">  if (BitWidth == 16)</td>
    <td class="lineNumber">717</td>
    <td class="codeline">  if (BitWidth == 16)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeline">    return APInt(BitWidth, llvm::byteswap<uint16_t>(U.VAL));</td>
    <td class="lineNumber">718</td>
    <td class="codeline">    return APInt(BitWidth, llvm::byteswap<uint16_t>(U.VAL));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeline">  if (BitWidth == 32)</td>
    <td class="lineNumber">719</td>
    <td class="codeline">  if (BitWidth == 32)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeline">    return APInt(BitWidth, llvm::byteswap<uint32_t>(U.VAL));</td>
    <td class="lineNumber">720</td>
    <td class="codeline">    return APInt(BitWidth, llvm::byteswap<uint32_t>(U.VAL));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeline">  if (BitWidth <= 64) {</td>
    <td class="lineNumber">721</td>
    <td class="codeline">  if (BitWidth <= 64) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeline">    uint64_t Tmp1 = llvm::byteswap<uint64_t>(U.VAL);</td>
    <td class="lineNumber">722</td>
    <td class="codeline">    uint64_t Tmp1 = llvm::byteswap<uint64_t>(U.VAL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeline">    Tmp1 >>= (64 - BitWidth);</td>
    <td class="lineNumber">723</td>
    <td class="codeline">    Tmp1 >>= (64 - BitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeline">    return APInt(BitWidth, Tmp1);</td>
    <td class="lineNumber">724</td>
    <td class="codeline">    return APInt(BitWidth, Tmp1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">725</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeline"></td>
    <td class="lineNumber">726</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeline">  APInt Result(getNumWords() * APINT_BITS_PER_WORD, 0);</td>
    <td class="lineNumber">727</td>
    <td class="codeline">  APInt Result(getNumWords() * APINT_BITS_PER_WORD, 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeline">  for (unsigned I = 0, N = getNumWords(); I != N; ++I)</td>
    <td class="lineNumber">728</td>
    <td class="codeline">  for (unsigned I = 0, N = getNumWords(); I != N; ++I)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeline">    Result.U.pVal[I] = llvm::byteswap<uint64_t>(U.pVal[N - I - 1]);</td>
    <td class="lineNumber">729</td>
    <td class="codeline">    Result.U.pVal[I] = llvm::byteswap<uint64_t>(U.pVal[N - I - 1]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeline">  if (Result.BitWidth != BitWidth) {</td>
    <td class="lineNumber">730</td>
    <td class="codeline">  if (Result.BitWidth != BitWidth) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeline">    Result.lshrInPlace(Result.BitWidth - BitWidth);</td>
    <td class="lineNumber">731</td>
    <td class="codeline">    Result.lshrInPlace(Result.BitWidth - BitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeline">    Result.BitWidth = BitWidth;</td>
    <td class="lineNumber">732</td>
    <td class="codeline">    Result.BitWidth = BitWidth;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">733</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeline">  return Result;</td>
    <td class="lineNumber">734</td>
    <td class="codeline">  return Result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeline">}</td>
    <td class="lineNumber">735</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeline"></td>
    <td class="lineNumber">736</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeline">APInt APInt::reverseBits() const {</td>
    <td class="lineNumber">737</td>
    <td class="codeline">APInt APInt::reverseBits() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeline">  switch (BitWidth) {</td>
    <td class="lineNumber">738</td>
    <td class="codeline">  switch (BitWidth) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeline">  case 64:</td>
    <td class="lineNumber">739</td>
    <td class="codeline">  case 64:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeline">    return APInt(BitWidth, llvm::reverseBits<uint64_t>(U.VAL));</td>
    <td class="lineNumber">740</td>
    <td class="codeline">    return APInt(BitWidth, llvm::reverseBits<uint64_t>(U.VAL));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeline">  case 32:</td>
    <td class="lineNumber">741</td>
    <td class="codeline">  case 32:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeline">    return APInt(BitWidth, llvm::reverseBits<uint32_t>(U.VAL));</td>
    <td class="lineNumber">742</td>
    <td class="codeline">    return APInt(BitWidth, llvm::reverseBits<uint32_t>(U.VAL));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeline">  case 16:</td>
    <td class="lineNumber">743</td>
    <td class="codeline">  case 16:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeline">    return APInt(BitWidth, llvm::reverseBits<uint16_t>(U.VAL));</td>
    <td class="lineNumber">744</td>
    <td class="codeline">    return APInt(BitWidth, llvm::reverseBits<uint16_t>(U.VAL));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeline">  case 8:</td>
    <td class="lineNumber">745</td>
    <td class="codeline">  case 8:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeline">    return APInt(BitWidth, llvm::reverseBits<uint8_t>(U.VAL));</td>
    <td class="lineNumber">746</td>
    <td class="codeline">    return APInt(BitWidth, llvm::reverseBits<uint8_t>(U.VAL));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeline">  case 0:</td>
    <td class="lineNumber">747</td>
    <td class="codeline">  case 0:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeline">    return *this;</td>
    <td class="lineNumber">748</td>
    <td class="codeline">    return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeline">  default:</td>
    <td class="lineNumber">749</td>
    <td class="codeline">  default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeline">    break;</td>
    <td class="lineNumber">750</td>
    <td class="codeline">    break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">751</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeline"></td>
    <td class="lineNumber">752</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeline">  APInt Val(*this);</td>
    <td class="lineNumber">753</td>
    <td class="codeline">  APInt Val(*this);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeline">  APInt Reversed(BitWidth, 0);</td>
    <td class="lineNumber">754</td>
    <td class="codeline">  APInt Reversed(BitWidth, 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeline">  unsigned S = BitWidth;</td>
    <td class="lineNumber">755</td>
    <td class="codeline">  unsigned S = BitWidth;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeline"></td>
    <td class="lineNumber">756</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeline">  for (; Val != 0; Val.lshrInPlace(1)) {</td>
    <td class="lineNumber">757</td>
    <td class="codeline">  for (; Val != 0; Val.lshrInPlace(1)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeline">    Reversed <<= 1;</td>
    <td class="lineNumber">758</td>
    <td class="codeline">    Reversed <<= 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeline">    Reversed |= Val[0];</td>
    <td class="lineNumber">759</td>
    <td class="codeline">    Reversed |= Val[0];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeline">    --S;</td>
    <td class="lineNumber">760</td>
    <td class="codeline">    --S;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">761</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeline"></td>
    <td class="lineNumber">762</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeline">  Reversed <<= S;</td>
    <td class="lineNumber">763</td>
    <td class="codeline">  Reversed <<= S;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeline">  return Reversed;</td>
    <td class="lineNumber">764</td>
    <td class="codeline">  return Reversed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeline">}</td>
    <td class="lineNumber">765</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeline"></td>
    <td class="lineNumber">766</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeline">APInt llvm::APIntOps::GreatestCommonDivisor(APInt A, APInt B) {</td>
    <td class="lineNumber">767</td>
    <td class="codeline">APInt llvm::APIntOps::GreatestCommonDivisor(APInt A, APInt B) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeline">  // Fast-path a common case.</td>
    <td class="lineNumber">768</td>
    <td class="codeline">  // Fast-path a common case.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeline">  if (A == B) return A;</td>
    <td class="lineNumber">769</td>
    <td class="codeline">  if (A == B) return A;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeline"></td>
    <td class="lineNumber">770</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeline">  // Corner cases: if either operand is zero, the other is the gcd.</td>
    <td class="lineNumber">771</td>
    <td class="codeline">  // Corner cases: if either operand is zero, the other is the gcd.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeline">  if (!A) return B;</td>
    <td class="lineNumber">772</td>
    <td class="codeline">  if (!A) return B;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeline">  if (!B) return A;</td>
    <td class="lineNumber">773</td>
    <td class="codeline">  if (!B) return A;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeline"></td>
    <td class="lineNumber">774</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeline">  // Count common powers of 2 and remove all other powers of 2.</td>
    <td class="lineNumber">775</td>
    <td class="codeline">  // Count common powers of 2 and remove all other powers of 2.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeline">  unsigned Pow2;</td>
    <td class="lineNumber">776</td>
    <td class="codeline">  unsigned Pow2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeline">  {</td>
    <td class="lineNumber">777</td>
    <td class="codeline">  {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeline">    unsigned Pow2_A = A.countr_zero();</td>
    <td class="lineNumber">778</td>
    <td class="codeline">    unsigned Pow2_A = A.countr_zero();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeline">    unsigned Pow2_B = B.countr_zero();</td>
    <td class="lineNumber">779</td>
    <td class="codeline">    unsigned Pow2_B = B.countr_zero();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeline">    if (Pow2_A > Pow2_B) {</td>
    <td class="lineNumber">780</td>
    <td class="codeline">    if (Pow2_A > Pow2_B) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeline">      A.lshrInPlace(Pow2_A - Pow2_B);</td>
    <td class="lineNumber">781</td>
    <td class="codeline">      A.lshrInPlace(Pow2_A - Pow2_B);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeline">      Pow2 = Pow2_B;</td>
    <td class="lineNumber">782</td>
    <td class="codeline">      Pow2 = Pow2_B;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeline">    } else if (Pow2_B > Pow2_A) {</td>
    <td class="lineNumber">783</td>
    <td class="codeline">    } else if (Pow2_B > Pow2_A) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeline">      B.lshrInPlace(Pow2_B - Pow2_A);</td>
    <td class="lineNumber">784</td>
    <td class="codeline">      B.lshrInPlace(Pow2_B - Pow2_A);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeline">      Pow2 = Pow2_A;</td>
    <td class="lineNumber">785</td>
    <td class="codeline">      Pow2 = Pow2_A;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">786</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeline">      Pow2 = Pow2_A;</td>
    <td class="lineNumber">787</td>
    <td class="codeline">      Pow2 = Pow2_A;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">788</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">789</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeline"></td>
    <td class="lineNumber">790</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeline">  // Both operands are odd multiples of 2^Pow_2:</td>
    <td class="lineNumber">791</td>
    <td class="codeline">  // Both operands are odd multiples of 2^Pow_2:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">792</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeline">  //   gcd(a, b) = gcd(|a - b| / 2^i, min(a, b))</td>
    <td class="lineNumber">793</td>
    <td class="codeline">  //   gcd(a, b) = gcd(|a - b| / 2^i, min(a, b))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">794</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeline">  // This is a modified version of Stein's algorithm, taking advantage of</td>
    <td class="lineNumber">795</td>
    <td class="codeline">  // This is a modified version of Stein's algorithm, taking advantage of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeline">  // efficient countTrailingZeros().</td>
    <td class="lineNumber">796</td>
    <td class="codeline">  // efficient countTrailingZeros().</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeline">  while (A != B) {</td>
    <td class="lineNumber">797</td>
    <td class="codeline">  while (A != B) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeline">    if (A.ugt(B)) {</td>
    <td class="lineNumber">798</td>
    <td class="codeline">    if (A.ugt(B)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeline">      A -= B;</td>
    <td class="lineNumber">799</td>
    <td class="codeline">      A -= B;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeline">      A.lshrInPlace(A.countr_zero() - Pow2);</td>
    <td class="lineNumber">800</td>
    <td class="codeline">      A.lshrInPlace(A.countr_zero() - Pow2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">801</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeline">      B -= A;</td>
    <td class="lineNumber">802</td>
    <td class="codeline">      B -= A;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeline">      B.lshrInPlace(B.countr_zero() - Pow2);</td>
    <td class="lineNumber">803</td>
    <td class="codeline">      B.lshrInPlace(B.countr_zero() - Pow2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">804</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">805</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeline"></td>
    <td class="lineNumber">806</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeline">  return A;</td>
    <td class="lineNumber">807</td>
    <td class="codeline">  return A;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeline">}</td>
    <td class="lineNumber">808</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeline"></td>
    <td class="lineNumber">809</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeline">APInt llvm::APIntOps::RoundDoubleToAPInt(double Double, unsigned width) {</td>
    <td class="lineNumber">810</td>
    <td class="codeline">APInt llvm::APIntOps::RoundDoubleToAPInt(double Double, unsigned width) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeline">  uint64_t I = bit_cast<uint64_t>(Double);</td>
    <td class="lineNumber">811</td>
    <td class="codeline">  uint64_t I = bit_cast<uint64_t>(Double);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeline"></td>
    <td class="lineNumber">812</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeline">  // Get the sign bit from the highest order bit</td>
    <td class="lineNumber">813</td>
    <td class="codeline">  // Get the sign bit from the highest order bit</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeline">  bool isNeg = I >> 63;</td>
    <td class="lineNumber">814</td>
    <td class="codeline">  bool isNeg = I >> 63;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeline"></td>
    <td class="lineNumber">815</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeline">  // Get the 11-bit exponent and adjust for the 1023 bit bias</td>
    <td class="lineNumber">816</td>
    <td class="codeline">  // Get the 11-bit exponent and adjust for the 1023 bit bias</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeline">  int64_t exp = ((I >> 52) & 0x7ff) - 1023;</td>
    <td class="lineNumber">817</td>
    <td class="codeline">  int64_t exp = ((I >> 52) & 0x7ff) - 1023;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeline"></td>
    <td class="lineNumber">818</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeline">  // If the exponent is negative, the value is < 0 so just return 0.</td>
    <td class="lineNumber">819</td>
    <td class="codeline">  // If the exponent is negative, the value is < 0 so just return 0.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeline">  if (exp < 0)</td>
    <td class="lineNumber">820</td>
    <td class="codeline">  if (exp < 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeline">    return APInt(width, 0u);</td>
    <td class="lineNumber">821</td>
    <td class="codeline">    return APInt(width, 0u);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeline"></td>
    <td class="lineNumber">822</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeline">  // Extract the mantissa by clearing the top 12 bits (sign + exponent).</td>
    <td class="lineNumber">823</td>
    <td class="codeline">  // Extract the mantissa by clearing the top 12 bits (sign + exponent).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeline">  uint64_t mantissa = (I & (~0ULL >> 12)) | 1ULL << 52;</td>
    <td class="lineNumber">824</td>
    <td class="codeline">  uint64_t mantissa = (I & (~0ULL >> 12)) | 1ULL << 52;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeline"></td>
    <td class="lineNumber">825</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeline">  // If the exponent doesn't shift all bits out of the mantissa</td>
    <td class="lineNumber">826</td>
    <td class="codeline">  // If the exponent doesn't shift all bits out of the mantissa</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeline">  if (exp < 52)</td>
    <td class="lineNumber">827</td>
    <td class="codeline">  if (exp < 52)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeline">    return isNeg ? -APInt(width, mantissa >> (52 - exp)) :</td>
    <td class="lineNumber">828</td>
    <td class="codeline">    return isNeg ? -APInt(width, mantissa >> (52 - exp)) :</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeline">                    APInt(width, mantissa >> (52 - exp));</td>
    <td class="lineNumber">829</td>
    <td class="codeline">                    APInt(width, mantissa >> (52 - exp));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeline"></td>
    <td class="lineNumber">830</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeline">  // If the client didn't provide enough bits for us to shift the mantissa into</td>
    <td class="lineNumber">831</td>
    <td class="codeline">  // If the client didn't provide enough bits for us to shift the mantissa into</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeline">  // then the result is undefined, just return 0</td>
    <td class="lineNumber">832</td>
    <td class="codeline">  // then the result is undefined, just return 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeline">  if (width <= exp - 52)</td>
    <td class="lineNumber">833</td>
    <td class="codeline">  if (width <= exp - 52)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeline">    return APInt(width, 0);</td>
    <td class="lineNumber">834</td>
    <td class="codeline">    return APInt(width, 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeline"></td>
    <td class="lineNumber">835</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeline">  // Otherwise, we have to shift the mantissa bits up to the right location</td>
    <td class="lineNumber">836</td>
    <td class="codeline">  // Otherwise, we have to shift the mantissa bits up to the right location</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeline">  APInt Tmp(width, mantissa);</td>
    <td class="lineNumber">837</td>
    <td class="codeline">  APInt Tmp(width, mantissa);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeline">  Tmp <<= (unsigned)exp - 52;</td>
    <td class="lineNumber">838</td>
    <td class="codeline">  Tmp <<= (unsigned)exp - 52;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeline">  return isNeg ? -Tmp : Tmp;</td>
    <td class="lineNumber">839</td>
    <td class="codeline">  return isNeg ? -Tmp : Tmp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeline">}</td>
    <td class="lineNumber">840</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeline"></td>
    <td class="lineNumber">841</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeline">/// This function converts this APInt to a double.</td>
    <td class="lineNumber">842</td>
    <td class="codeline">/// This function converts this APInt to a double.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeline">/// The layout for double is as following (IEEE Standard 754):</td>
    <td class="lineNumber">843</td>
    <td class="codeline">/// The layout for double is as following (IEEE Standard 754):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeline">///  --------------------------------------</td>
    <td class="lineNumber">844</td>
    <td class="codeline">///  --------------------------------------</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeline">/// |  Sign    Exponent    Fraction    Bias |</td>
    <td class="lineNumber">845</td>
    <td class="codeline">/// |  Sign    Exponent    Fraction    Bias |</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeline">/// |-------------------------------------- |</td>
    <td class="lineNumber">846</td>
    <td class="codeline">/// |-------------------------------------- |</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeline">/// |  1[63]   11[62-52]   52[51-00]   1023 |</td>
    <td class="lineNumber">847</td>
    <td class="codeline">/// |  1[63]   11[62-52]   52[51-00]   1023 |</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeline">///  --------------------------------------</td>
    <td class="lineNumber">848</td>
    <td class="codeline">///  --------------------------------------</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeline">double APInt::roundToDouble(bool isSigned) const {</td>
    <td class="lineNumber">849</td>
    <td class="codeline">double APInt::roundToDouble(bool isSigned) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeline"></td>
    <td class="lineNumber">850</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeline">  // Handle the simple case where the value is contained in one uint64_t.</td>
    <td class="lineNumber">851</td>
    <td class="codeline">  // Handle the simple case where the value is contained in one uint64_t.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeline">  // It is wrong to optimize getWord(0) to VAL; there might be more than one word.</td>
    <td class="lineNumber">852</td>
    <td class="codeline">  // It is wrong to optimize getWord(0) to VAL; there might be more than one word.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeline">  if (isSingleWord() || getActiveBits() <= APINT_BITS_PER_WORD) {</td>
    <td class="lineNumber">853</td>
    <td class="codeline">  if (isSingleWord() || getActiveBits() <= APINT_BITS_PER_WORD) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeline">    if (isSigned) {</td>
    <td class="lineNumber">854</td>
    <td class="codeline">    if (isSigned) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeline">      int64_t sext = SignExtend64(getWord(0), BitWidth);</td>
    <td class="lineNumber">855</td>
    <td class="codeline">      int64_t sext = SignExtend64(getWord(0), BitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeline">      return double(sext);</td>
    <td class="lineNumber">856</td>
    <td class="codeline">      return double(sext);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeline">    } else</td>
    <td class="lineNumber">857</td>
    <td class="codeline">    } else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeline">      return double(getWord(0));</td>
    <td class="lineNumber">858</td>
    <td class="codeline">      return double(getWord(0));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">859</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeline"></td>
    <td class="lineNumber">860</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeline">  // Determine if the value is negative.</td>
    <td class="lineNumber">861</td>
    <td class="codeline">  // Determine if the value is negative.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeline">  bool isNeg = isSigned ? (*this)[BitWidth-1] : false;</td>
    <td class="lineNumber">862</td>
    <td class="codeline">  bool isNeg = isSigned ? (*this)[BitWidth-1] : false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeline"></td>
    <td class="lineNumber">863</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeline">  // Construct the absolute value if we're negative.</td>
    <td class="lineNumber">864</td>
    <td class="codeline">  // Construct the absolute value if we're negative.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeline">  APInt Tmp(isNeg ? -(*this) : (*this));</td>
    <td class="lineNumber">865</td>
    <td class="codeline">  APInt Tmp(isNeg ? -(*this) : (*this));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeline"></td>
    <td class="lineNumber">866</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeline">  // Figure out how many bits we're using.</td>
    <td class="lineNumber">867</td>
    <td class="codeline">  // Figure out how many bits we're using.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeline">  unsigned n = Tmp.getActiveBits();</td>
    <td class="lineNumber">868</td>
    <td class="codeline">  unsigned n = Tmp.getActiveBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeline"></td>
    <td class="lineNumber">869</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeline">  // The exponent (without bias normalization) is just the number of bits</td>
    <td class="lineNumber">870</td>
    <td class="codeline">  // The exponent (without bias normalization) is just the number of bits</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeline">  // we are using. Note that the sign bit is gone since we constructed the</td>
    <td class="lineNumber">871</td>
    <td class="codeline">  // we are using. Note that the sign bit is gone since we constructed the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeline">  // absolute value.</td>
    <td class="lineNumber">872</td>
    <td class="codeline">  // absolute value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeline">  uint64_t exp = n;</td>
    <td class="lineNumber">873</td>
    <td class="codeline">  uint64_t exp = n;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeline"></td>
    <td class="lineNumber">874</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeline">  // Return infinity for exponent overflow</td>
    <td class="lineNumber">875</td>
    <td class="codeline">  // Return infinity for exponent overflow</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeline">  if (exp > 1023) {</td>
    <td class="lineNumber">876</td>
    <td class="codeline">  if (exp > 1023) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeline">    if (!isSigned || !isNeg)</td>
    <td class="lineNumber">877</td>
    <td class="codeline">    if (!isSigned || !isNeg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeline">      return std::numeric_limits<double>::infinity();</td>
    <td class="lineNumber">878</td>
    <td class="codeline">      return std::numeric_limits<double>::infinity();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">879</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeline">      return -std::numeric_limits<double>::infinity();</td>
    <td class="lineNumber">880</td>
    <td class="codeline">      return -std::numeric_limits<double>::infinity();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">881</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeline">  exp += 1023; // Increment for 1023 bias</td>
    <td class="lineNumber">882</td>
    <td class="codeline">  exp += 1023; // Increment for 1023 bias</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeline"></td>
    <td class="lineNumber">883</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeline">  // Number of bits in mantissa is 52. To obtain the mantissa value, we must</td>
    <td class="lineNumber">884</td>
    <td class="codeline">  // Number of bits in mantissa is 52. To obtain the mantissa value, we must</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeline">  // extract the high 52 bits from the correct words in pVal.</td>
    <td class="lineNumber">885</td>
    <td class="codeline">  // extract the high 52 bits from the correct words in pVal.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeline">  uint64_t mantissa;</td>
    <td class="lineNumber">886</td>
    <td class="codeline">  uint64_t mantissa;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeline">  unsigned hiWord = whichWord(n-1);</td>
    <td class="lineNumber">887</td>
    <td class="codeline">  unsigned hiWord = whichWord(n-1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeline">  if (hiWord == 0) {</td>
    <td class="lineNumber">888</td>
    <td class="codeline">  if (hiWord == 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeline">    mantissa = Tmp.U.pVal[0];</td>
    <td class="lineNumber">889</td>
    <td class="codeline">    mantissa = Tmp.U.pVal[0];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeline">    if (n > 52)</td>
    <td class="lineNumber">890</td>
    <td class="codeline">    if (n > 52)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeline">      mantissa >>= n - 52; // shift down, we want the top 52 bits.</td>
    <td class="lineNumber">891</td>
    <td class="codeline">      mantissa >>= n - 52; // shift down, we want the top 52 bits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">892</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeline">    assert(hiWord > 0 && "huh?");</td>
    <td class="lineNumber">893</td>
    <td class="codeline">    assert(hiWord > 0 && "huh?");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeline">    uint64_t hibits = Tmp.U.pVal[hiWord] << (52 - n % APINT_BITS_PER_WORD);</td>
    <td class="lineNumber">894</td>
    <td class="codeline">    uint64_t hibits = Tmp.U.pVal[hiWord] << (52 - n % APINT_BITS_PER_WORD);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeline">    uint64_t lobits = Tmp.U.pVal[hiWord-1] >> (11 + n % APINT_BITS_PER_WORD);</td>
    <td class="lineNumber">895</td>
    <td class="codeline">    uint64_t lobits = Tmp.U.pVal[hiWord-1] >> (11 + n % APINT_BITS_PER_WORD);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeline">    mantissa = hibits | lobits;</td>
    <td class="lineNumber">896</td>
    <td class="codeline">    mantissa = hibits | lobits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">897</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeline"></td>
    <td class="lineNumber">898</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeline">  // The leading bit of mantissa is implicit, so get rid of it.</td>
    <td class="lineNumber">899</td>
    <td class="codeline">  // The leading bit of mantissa is implicit, so get rid of it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeline">  uint64_t sign = isNeg ? (1ULL << (APINT_BITS_PER_WORD - 1)) : 0;</td>
    <td class="lineNumber">900</td>
    <td class="codeline">  uint64_t sign = isNeg ? (1ULL << (APINT_BITS_PER_WORD - 1)) : 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeline">  uint64_t I = sign | (exp << 52) | mantissa;</td>
    <td class="lineNumber">901</td>
    <td class="codeline">  uint64_t I = sign | (exp << 52) | mantissa;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeline">  return bit_cast<double>(I);</td>
    <td class="lineNumber">902</td>
    <td class="codeline">  return bit_cast<double>(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeline">}</td>
    <td class="lineNumber">903</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeline"></td>
    <td class="lineNumber">904</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeline">// Truncate to new width.</td>
    <td class="lineNumber">905</td>
    <td class="codeline">// Truncate to new width.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeline">APInt APInt::trunc(unsigned width) const {</td>
    <td class="lineNumber">906</td>
    <td class="codeline">APInt APInt::trunc(unsigned width) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeline">  assert(width <= BitWidth && "Invalid APInt Truncate request");</td>
    <td class="lineNumber">907</td>
    <td class="codeline">  assert(width <= BitWidth && "Invalid APInt Truncate request");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeline"></td>
    <td class="lineNumber">908</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeline">  if (width <= APINT_BITS_PER_WORD)</td>
    <td class="lineNumber">909</td>
    <td class="codeline">  if (width <= APINT_BITS_PER_WORD)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeline">    return APInt(width, getRawData()[0]);</td>
    <td class="lineNumber">910</td>
    <td class="codeline">    return APInt(width, getRawData()[0]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeline"></td>
    <td class="lineNumber">911</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeline">  if (width == BitWidth)</td>
    <td class="lineNumber">912</td>
    <td class="codeline">  if (width == BitWidth)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeline">    return *this;</td>
    <td class="lineNumber">913</td>
    <td class="codeline">    return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeline"></td>
    <td class="lineNumber">914</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeline">  APInt Result(getMemory(getNumWords(width)), width);</td>
    <td class="lineNumber">915</td>
    <td class="codeline">  APInt Result(getMemory(getNumWords(width)), width);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeline"></td>
    <td class="lineNumber">916</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeline">  // Copy full words.</td>
    <td class="lineNumber">917</td>
    <td class="codeline">  // Copy full words.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeline">  unsigned i;</td>
    <td class="lineNumber">918</td>
    <td class="codeline">  unsigned i;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeline">  for (i = 0; i != width / APINT_BITS_PER_WORD; i++)</td>
    <td class="lineNumber">919</td>
    <td class="codeline">  for (i = 0; i != width / APINT_BITS_PER_WORD; i++)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeline">    Result.U.pVal[i] = U.pVal[i];</td>
    <td class="lineNumber">920</td>
    <td class="codeline">    Result.U.pVal[i] = U.pVal[i];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeline"></td>
    <td class="lineNumber">921</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeline">  // Truncate and copy any partial word.</td>
    <td class="lineNumber">922</td>
    <td class="codeline">  // Truncate and copy any partial word.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeline">  unsigned bits = (0 - width) % APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">923</td>
    <td class="codeline">  unsigned bits = (0 - width) % APINT_BITS_PER_WORD;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeline">  if (bits != 0)</td>
    <td class="lineNumber">924</td>
    <td class="codeline">  if (bits != 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeline">    Result.U.pVal[i] = U.pVal[i] << bits >> bits;</td>
    <td class="lineNumber">925</td>
    <td class="codeline">    Result.U.pVal[i] = U.pVal[i] << bits >> bits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeline"></td>
    <td class="lineNumber">926</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeline">  return Result;</td>
    <td class="lineNumber">927</td>
    <td class="codeline">  return Result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeline">}</td>
    <td class="lineNumber">928</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeline"></td>
    <td class="lineNumber">929</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeline">// Truncate to new width with unsigned saturation.</td>
    <td class="lineNumber">930</td>
    <td class="codeline">// Truncate to new width with unsigned saturation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeline">APInt APInt::truncUSat(unsigned width) const {</td>
    <td class="lineNumber">931</td>
    <td class="codeline">APInt APInt::truncUSat(unsigned width) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeline">  assert(width <= BitWidth && "Invalid APInt Truncate request");</td>
    <td class="lineNumber">932</td>
    <td class="codeline">  assert(width <= BitWidth && "Invalid APInt Truncate request");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeline"></td>
    <td class="lineNumber">933</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeline">  // Can we just losslessly truncate it?</td>
    <td class="lineNumber">934</td>
    <td class="codeline">  // Can we just losslessly truncate it?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeline">  if (isIntN(width))</td>
    <td class="lineNumber">935</td>
    <td class="codeline">  if (isIntN(width))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeline">    return trunc(width);</td>
    <td class="lineNumber">936</td>
    <td class="codeline">    return trunc(width);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeline">  // If not, then just return the new limit.</td>
    <td class="lineNumber">937</td>
    <td class="codeline">  // If not, then just return the new limit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeline">  return APInt::getMaxValue(width);</td>
    <td class="lineNumber">938</td>
    <td class="codeline">  return APInt::getMaxValue(width);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeline">}</td>
    <td class="lineNumber">939</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeline"></td>
    <td class="lineNumber">940</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeline">// Truncate to new width with signed saturation.</td>
    <td class="lineNumber">941</td>
    <td class="codeline">// Truncate to new width with signed saturation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeline">APInt APInt::truncSSat(unsigned width) const {</td>
    <td class="lineNumber">942</td>
    <td class="codeline">APInt APInt::truncSSat(unsigned width) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeline">  assert(width <= BitWidth && "Invalid APInt Truncate request");</td>
    <td class="lineNumber">943</td>
    <td class="codeline">  assert(width <= BitWidth && "Invalid APInt Truncate request");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeline"></td>
    <td class="lineNumber">944</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeline">  // Can we just losslessly truncate it?</td>
    <td class="lineNumber">945</td>
    <td class="codeline">  // Can we just losslessly truncate it?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeline">  if (isSignedIntN(width))</td>
    <td class="lineNumber">946</td>
    <td class="codeline">  if (isSignedIntN(width))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeline">    return trunc(width);</td>
    <td class="lineNumber">947</td>
    <td class="codeline">    return trunc(width);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeline">  // If not, then just return the new limits.</td>
    <td class="lineNumber">948</td>
    <td class="codeline">  // If not, then just return the new limits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeline">  return isNegative() ? APInt::getSignedMinValue(width)</td>
    <td class="lineNumber">949</td>
    <td class="codeline">  return isNegative() ? APInt::getSignedMinValue(width)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeline">                      : APInt::getSignedMaxValue(width);</td>
    <td class="lineNumber">950</td>
    <td class="codeline">                      : APInt::getSignedMaxValue(width);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeline">}</td>
    <td class="lineNumber">951</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeline"></td>
    <td class="lineNumber">952</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeline">// Sign extend to a new width.</td>
    <td class="lineNumber">953</td>
    <td class="codeline">// Sign extend to a new width.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeline">APInt APInt::sext(unsigned Width) const {</td>
    <td class="lineNumber">954</td>
    <td class="codeline">APInt APInt::sext(unsigned Width) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeline">  assert(Width >= BitWidth && "Invalid APInt SignExtend request");</td>
    <td class="lineNumber">955</td>
    <td class="codeline">  assert(Width >= BitWidth && "Invalid APInt SignExtend request");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeline"></td>
    <td class="lineNumber">956</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeline">  if (Width <= APINT_BITS_PER_WORD)</td>
    <td class="lineNumber">957</td>
    <td class="codeline">  if (Width <= APINT_BITS_PER_WORD)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeline">    return APInt(Width, SignExtend64(U.VAL, BitWidth));</td>
    <td class="lineNumber">958</td>
    <td class="codeline">    return APInt(Width, SignExtend64(U.VAL, BitWidth));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeline"></td>
    <td class="lineNumber">959</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeline">  if (Width == BitWidth)</td>
    <td class="lineNumber">960</td>
    <td class="codeline">  if (Width == BitWidth)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeline">    return *this;</td>
    <td class="lineNumber">961</td>
    <td class="codeline">    return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeline"></td>
    <td class="lineNumber">962</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeline">  APInt Result(getMemory(getNumWords(Width)), Width);</td>
    <td class="lineNumber">963</td>
    <td class="codeline">  APInt Result(getMemory(getNumWords(Width)), Width);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeline"></td>
    <td class="lineNumber">964</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeline">  // Copy words.</td>
    <td class="lineNumber">965</td>
    <td class="codeline">  // Copy words.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeline">  std::memcpy(Result.U.pVal, getRawData(), getNumWords() * APINT_WORD_SIZE);</td>
    <td class="lineNumber">966</td>
    <td class="codeline">  std::memcpy(Result.U.pVal, getRawData(), getNumWords() * APINT_WORD_SIZE);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeline"></td>
    <td class="lineNumber">967</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeline">  // Sign extend the last word since there may be unused bits in the input.</td>
    <td class="lineNumber">968</td>
    <td class="codeline">  // Sign extend the last word since there may be unused bits in the input.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeline">  Result.U.pVal[getNumWords() - 1] =</td>
    <td class="lineNumber">969</td>
    <td class="codeline">  Result.U.pVal[getNumWords() - 1] =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeline">      SignExtend64(Result.U.pVal[getNumWords() - 1],</td>
    <td class="lineNumber">970</td>
    <td class="codeline">      SignExtend64(Result.U.pVal[getNumWords() - 1],</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeline">                   ((BitWidth - 1) % APINT_BITS_PER_WORD) + 1);</td>
    <td class="lineNumber">971</td>
    <td class="codeline">                   ((BitWidth - 1) % APINT_BITS_PER_WORD) + 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeline"></td>
    <td class="lineNumber">972</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeline">  // Fill with sign bits.</td>
    <td class="lineNumber">973</td>
    <td class="codeline">  // Fill with sign bits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeline">  std::memset(Result.U.pVal + getNumWords(), isNegative() ? -1 : 0,</td>
    <td class="lineNumber">974</td>
    <td class="codeline">  std::memset(Result.U.pVal + getNumWords(), isNegative() ? -1 : 0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeline">              (Result.getNumWords() - getNumWords()) * APINT_WORD_SIZE);</td>
    <td class="lineNumber">975</td>
    <td class="codeline">              (Result.getNumWords() - getNumWords()) * APINT_WORD_SIZE);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeline">  Result.clearUnusedBits();</td>
    <td class="lineNumber">976</td>
    <td class="codeline">  Result.clearUnusedBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeline">  return Result;</td>
    <td class="lineNumber">977</td>
    <td class="codeline">  return Result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeline">}</td>
    <td class="lineNumber">978</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeline"></td>
    <td class="lineNumber">979</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeline">//  Zero extend to a new width.</td>
    <td class="lineNumber">980</td>
    <td class="codeline">//  Zero extend to a new width.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeline">APInt APInt::zext(unsigned width) const {</td>
    <td class="lineNumber">981</td>
    <td class="codeline">APInt APInt::zext(unsigned width) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeline">  assert(width >= BitWidth && "Invalid APInt ZeroExtend request");</td>
    <td class="lineNumber">982</td>
    <td class="codeline">  assert(width >= BitWidth && "Invalid APInt ZeroExtend request");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeline"></td>
    <td class="lineNumber">983</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeline">  if (width <= APINT_BITS_PER_WORD)</td>
    <td class="lineNumber">984</td>
    <td class="codeline">  if (width <= APINT_BITS_PER_WORD)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeline">    return APInt(width, U.VAL);</td>
    <td class="lineNumber">985</td>
    <td class="codeline">    return APInt(width, U.VAL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeline"></td>
    <td class="lineNumber">986</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeline">  if (width == BitWidth)</td>
    <td class="lineNumber">987</td>
    <td class="codeline">  if (width == BitWidth)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeline">    return *this;</td>
    <td class="lineNumber">988</td>
    <td class="codeline">    return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeline"></td>
    <td class="lineNumber">989</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeline">  APInt Result(getMemory(getNumWords(width)), width);</td>
    <td class="lineNumber">990</td>
    <td class="codeline">  APInt Result(getMemory(getNumWords(width)), width);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeline"></td>
    <td class="lineNumber">991</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeline">  // Copy words.</td>
    <td class="lineNumber">992</td>
    <td class="codeline">  // Copy words.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeline">  std::memcpy(Result.U.pVal, getRawData(), getNumWords() * APINT_WORD_SIZE);</td>
    <td class="lineNumber">993</td>
    <td class="codeline">  std::memcpy(Result.U.pVal, getRawData(), getNumWords() * APINT_WORD_SIZE);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeline"></td>
    <td class="lineNumber">994</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeline">  // Zero remaining words.</td>
    <td class="lineNumber">995</td>
    <td class="codeline">  // Zero remaining words.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeline">  std::memset(Result.U.pVal + getNumWords(), 0,</td>
    <td class="lineNumber">996</td>
    <td class="codeline">  std::memset(Result.U.pVal + getNumWords(), 0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeline">              (Result.getNumWords() - getNumWords()) * APINT_WORD_SIZE);</td>
    <td class="lineNumber">997</td>
    <td class="codeline">              (Result.getNumWords() - getNumWords()) * APINT_WORD_SIZE);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeline"></td>
    <td class="lineNumber">998</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeline">  return Result;</td>
    <td class="lineNumber">999</td>
    <td class="codeline">  return Result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1000</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeline"></td>
    <td class="lineNumber">1001</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeline">APInt APInt::zextOrTrunc(unsigned width) const {</td>
    <td class="lineNumber">1002</td>
    <td class="codeline">APInt APInt::zextOrTrunc(unsigned width) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeline">  if (BitWidth < width)</td>
    <td class="lineNumber">1003</td>
    <td class="codeline">  if (BitWidth < width)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeline">    return zext(width);</td>
    <td class="lineNumber">1004</td>
    <td class="codeline">    return zext(width);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeline">  if (BitWidth > width)</td>
    <td class="lineNumber">1005</td>
    <td class="codeline">  if (BitWidth > width)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeline">    return trunc(width);</td>
    <td class="lineNumber">1006</td>
    <td class="codeline">    return trunc(width);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeline">  return *this;</td>
    <td class="lineNumber">1007</td>
    <td class="codeline">  return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1008</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeline"></td>
    <td class="lineNumber">1009</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeline">APInt APInt::sextOrTrunc(unsigned width) const {</td>
    <td class="lineNumber">1010</td>
    <td class="codeline">APInt APInt::sextOrTrunc(unsigned width) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeline">  if (BitWidth < width)</td>
    <td class="lineNumber">1011</td>
    <td class="codeline">  if (BitWidth < width)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeline">    return sext(width);</td>
    <td class="lineNumber">1012</td>
    <td class="codeline">    return sext(width);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeline">  if (BitWidth > width)</td>
    <td class="lineNumber">1013</td>
    <td class="codeline">  if (BitWidth > width)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeline">    return trunc(width);</td>
    <td class="lineNumber">1014</td>
    <td class="codeline">    return trunc(width);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeline">  return *this;</td>
    <td class="lineNumber">1015</td>
    <td class="codeline">  return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1016</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeline"></td>
    <td class="lineNumber">1017</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeline">/// Arithmetic right-shift this APInt by shiftAmt.</td>
    <td class="lineNumber">1018</td>
    <td class="codeline">/// Arithmetic right-shift this APInt by shiftAmt.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeline">/// Arithmetic right-shift function.</td>
    <td class="lineNumber">1019</td>
    <td class="codeline">/// Arithmetic right-shift function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeline">void APInt::ashrInPlace(const APInt &shiftAmt) {</td>
    <td class="lineNumber">1020</td>
    <td class="codeline">void APInt::ashrInPlace(const APInt &shiftAmt) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeline">  ashrInPlace((unsigned)shiftAmt.getLimitedValue(BitWidth));</td>
    <td class="lineNumber">1021</td>
    <td class="codeline">  ashrInPlace((unsigned)shiftAmt.getLimitedValue(BitWidth));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1022</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeline"></td>
    <td class="lineNumber">1023</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeline">/// Arithmetic right-shift this APInt by shiftAmt.</td>
    <td class="lineNumber">1024</td>
    <td class="codeline">/// Arithmetic right-shift this APInt by shiftAmt.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeline">/// Arithmetic right-shift function.</td>
    <td class="lineNumber">1025</td>
    <td class="codeline">/// Arithmetic right-shift function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeline">void APInt::ashrSlowCase(unsigned ShiftAmt) {</td>
    <td class="lineNumber">1026</td>
    <td class="codeline">void APInt::ashrSlowCase(unsigned ShiftAmt) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeline">  // Don't bother performing a no-op shift.</td>
    <td class="lineNumber">1027</td>
    <td class="codeline">  // Don't bother performing a no-op shift.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeline">  if (!ShiftAmt)</td>
    <td class="lineNumber">1028</td>
    <td class="codeline">  if (!ShiftAmt)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">1029</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeline"></td>
    <td class="lineNumber">1030</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeline">  // Save the original sign bit for later.</td>
    <td class="lineNumber">1031</td>
    <td class="codeline">  // Save the original sign bit for later.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeline">  bool Negative = isNegative();</td>
    <td class="lineNumber">1032</td>
    <td class="codeline">  bool Negative = isNegative();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeline"></td>
    <td class="lineNumber">1033</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeline">  // WordShift is the inter-part shift; BitShift is intra-part shift.</td>
    <td class="lineNumber">1034</td>
    <td class="codeline">  // WordShift is the inter-part shift; BitShift is intra-part shift.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeline">  unsigned WordShift = ShiftAmt / APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">1035</td>
    <td class="codeline">  unsigned WordShift = ShiftAmt / APINT_BITS_PER_WORD;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeline">  unsigned BitShift = ShiftAmt % APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">1036</td>
    <td class="codeline">  unsigned BitShift = ShiftAmt % APINT_BITS_PER_WORD;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeline"></td>
    <td class="lineNumber">1037</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeline">  unsigned WordsToMove = getNumWords() - WordShift;</td>
    <td class="lineNumber">1038</td>
    <td class="codeline">  unsigned WordsToMove = getNumWords() - WordShift;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeline">  if (WordsToMove != 0) {</td>
    <td class="lineNumber">1039</td>
    <td class="codeline">  if (WordsToMove != 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeline">    // Sign extend the last word to fill in the unused bits.</td>
    <td class="lineNumber">1040</td>
    <td class="codeline">    // Sign extend the last word to fill in the unused bits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeline">    U.pVal[getNumWords() - 1] = SignExtend64(</td>
    <td class="lineNumber">1041</td>
    <td class="codeline">    U.pVal[getNumWords() - 1] = SignExtend64(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeline">        U.pVal[getNumWords() - 1], ((BitWidth - 1) % APINT_BITS_PER_WORD) + 1);</td>
    <td class="lineNumber">1042</td>
    <td class="codeline">        U.pVal[getNumWords() - 1], ((BitWidth - 1) % APINT_BITS_PER_WORD) + 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeline"></td>
    <td class="lineNumber">1043</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeline">    // Fastpath for moving by whole words.</td>
    <td class="lineNumber">1044</td>
    <td class="codeline">    // Fastpath for moving by whole words.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeline">    if (BitShift == 0) {</td>
    <td class="lineNumber">1045</td>
    <td class="codeline">    if (BitShift == 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeline">      std::memmove(U.pVal, U.pVal + WordShift, WordsToMove * APINT_WORD_SIZE);</td>
    <td class="lineNumber">1046</td>
    <td class="codeline">      std::memmove(U.pVal, U.pVal + WordShift, WordsToMove * APINT_WORD_SIZE);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">1047</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeline">      // Move the words containing significant bits.</td>
    <td class="lineNumber">1048</td>
    <td class="codeline">      // Move the words containing significant bits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeline">      for (unsigned i = 0; i != WordsToMove - 1; ++i)</td>
    <td class="lineNumber">1049</td>
    <td class="codeline">      for (unsigned i = 0; i != WordsToMove - 1; ++i)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeline">        U.pVal[i] = (U.pVal[i + WordShift] >> BitShift) |</td>
    <td class="lineNumber">1050</td>
    <td class="codeline">        U.pVal[i] = (U.pVal[i + WordShift] >> BitShift) |</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeline">                    (U.pVal[i + WordShift + 1] << (APINT_BITS_PER_WORD - BitShift));</td>
    <td class="lineNumber">1051</td>
    <td class="codeline">                    (U.pVal[i + WordShift + 1] << (APINT_BITS_PER_WORD - BitShift));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeline"></td>
    <td class="lineNumber">1052</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeline">      // Handle the last word which has no high bits to copy.</td>
    <td class="lineNumber">1053</td>
    <td class="codeline">      // Handle the last word which has no high bits to copy.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeline">      U.pVal[WordsToMove - 1] = U.pVal[WordShift + WordsToMove - 1] >> BitShift;</td>
    <td class="lineNumber">1054</td>
    <td class="codeline">      U.pVal[WordsToMove - 1] = U.pVal[WordShift + WordsToMove - 1] >> BitShift;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeline">      // Sign extend one more time.</td>
    <td class="lineNumber">1055</td>
    <td class="codeline">      // Sign extend one more time.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeline">      U.pVal[WordsToMove - 1] =</td>
    <td class="lineNumber">1056</td>
    <td class="codeline">      U.pVal[WordsToMove - 1] =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeline">          SignExtend64(U.pVal[WordsToMove - 1], APINT_BITS_PER_WORD - BitShift);</td>
    <td class="lineNumber">1057</td>
    <td class="codeline">          SignExtend64(U.pVal[WordsToMove - 1], APINT_BITS_PER_WORD - BitShift);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1058</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1059</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeline"></td>
    <td class="lineNumber">1060</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeline">  // Fill in the remainder based on the original sign.</td>
    <td class="lineNumber">1061</td>
    <td class="codeline">  // Fill in the remainder based on the original sign.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeline">  std::memset(U.pVal + WordsToMove, Negative ? -1 : 0,</td>
    <td class="lineNumber">1062</td>
    <td class="codeline">  std::memset(U.pVal + WordsToMove, Negative ? -1 : 0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeline">              WordShift * APINT_WORD_SIZE);</td>
    <td class="lineNumber">1063</td>
    <td class="codeline">              WordShift * APINT_WORD_SIZE);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeline">  clearUnusedBits();</td>
    <td class="lineNumber">1064</td>
    <td class="codeline">  clearUnusedBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1065</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeline"></td>
    <td class="lineNumber">1066</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeline">/// Logical right-shift this APInt by shiftAmt.</td>
    <td class="lineNumber">1067</td>
    <td class="codeline">/// Logical right-shift this APInt by shiftAmt.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeline">/// Logical right-shift function.</td>
    <td class="lineNumber">1068</td>
    <td class="codeline">/// Logical right-shift function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeline">void APInt::lshrInPlace(const APInt &shiftAmt) {</td>
    <td class="lineNumber">1069</td>
    <td class="codeline">void APInt::lshrInPlace(const APInt &shiftAmt) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeline">  lshrInPlace((unsigned)shiftAmt.getLimitedValue(BitWidth));</td>
    <td class="lineNumber">1070</td>
    <td class="codeline">  lshrInPlace((unsigned)shiftAmt.getLimitedValue(BitWidth));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1071</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeline"></td>
    <td class="lineNumber">1072</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeline">/// Logical right-shift this APInt by shiftAmt.</td>
    <td class="lineNumber">1073</td>
    <td class="codeline">/// Logical right-shift this APInt by shiftAmt.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeline">/// Logical right-shift function.</td>
    <td class="lineNumber">1074</td>
    <td class="codeline">/// Logical right-shift function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeline">void APInt::lshrSlowCase(unsigned ShiftAmt) {</td>
    <td class="lineNumber">1075</td>
    <td class="codeline">void APInt::lshrSlowCase(unsigned ShiftAmt) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeline">  tcShiftRight(U.pVal, getNumWords(), ShiftAmt);</td>
    <td class="lineNumber">1076</td>
    <td class="codeline">  tcShiftRight(U.pVal, getNumWords(), ShiftAmt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1077</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeline"></td>
    <td class="lineNumber">1078</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeline">/// Left-shift this APInt by shiftAmt.</td>
    <td class="lineNumber">1079</td>
    <td class="codeline">/// Left-shift this APInt by shiftAmt.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeline">/// Left-shift function.</td>
    <td class="lineNumber">1080</td>
    <td class="codeline">/// Left-shift function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeline">APInt &APInt::operator<<=(const APInt &shiftAmt) {</td>
    <td class="lineNumber">1081</td>
    <td class="codeline">APInt &APInt::operator<<=(const APInt &shiftAmt) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeline">  // It's undefined behavior in C to shift by BitWidth or greater.</td>
    <td class="lineNumber">1082</td>
    <td class="codeline">  // It's undefined behavior in C to shift by BitWidth or greater.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeline">  *this <<= (unsigned)shiftAmt.getLimitedValue(BitWidth);</td>
    <td class="lineNumber">1083</td>
    <td class="codeline">  *this <<= (unsigned)shiftAmt.getLimitedValue(BitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeline">  return *this;</td>
    <td class="lineNumber">1084</td>
    <td class="codeline">  return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1085</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeline"></td>
    <td class="lineNumber">1086</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeline">void APInt::shlSlowCase(unsigned ShiftAmt) {</td>
    <td class="lineNumber">1087</td>
    <td class="codeline">void APInt::shlSlowCase(unsigned ShiftAmt) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeline">  tcShiftLeft(U.pVal, getNumWords(), ShiftAmt);</td>
    <td class="lineNumber">1088</td>
    <td class="codeline">  tcShiftLeft(U.pVal, getNumWords(), ShiftAmt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeline">  clearUnusedBits();</td>
    <td class="lineNumber">1089</td>
    <td class="codeline">  clearUnusedBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1090</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeline"></td>
    <td class="lineNumber">1091</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeline">// Calculate the rotate amount modulo the bit width.</td>
    <td class="lineNumber">1092</td>
    <td class="codeline">// Calculate the rotate amount modulo the bit width.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeline">static unsigned rotateModulo(unsigned BitWidth, const APInt &rotateAmt) {</td>
    <td class="lineNumber">1093</td>
    <td class="codeline">static unsigned rotateModulo(unsigned BitWidth, const APInt &rotateAmt) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeline">  if (LLVM_UNLIKELY(BitWidth == 0))</td>
    <td class="lineNumber">1094</td>
    <td class="codeline">  if (LLVM_UNLIKELY(BitWidth == 0))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeline">    return 0;</td>
    <td class="lineNumber">1095</td>
    <td class="codeline">    return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeline">  unsigned rotBitWidth = rotateAmt.getBitWidth();</td>
    <td class="lineNumber">1096</td>
    <td class="codeline">  unsigned rotBitWidth = rotateAmt.getBitWidth();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeline">  APInt rot = rotateAmt;</td>
    <td class="lineNumber">1097</td>
    <td class="codeline">  APInt rot = rotateAmt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeline">  if (rotBitWidth < BitWidth) {</td>
    <td class="lineNumber">1098</td>
    <td class="codeline">  if (rotBitWidth < BitWidth) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeline">    // Extend the rotate APInt, so that the urem doesn't divide by 0.</td>
    <td class="lineNumber">1099</td>
    <td class="codeline">    // Extend the rotate APInt, so that the urem doesn't divide by 0.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeline">    // e.g. APInt(1, 32) would give APInt(1, 0).</td>
    <td class="lineNumber">1100</td>
    <td class="codeline">    // e.g. APInt(1, 32) would give APInt(1, 0).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeline">    rot = rotateAmt.zext(BitWidth);</td>
    <td class="lineNumber">1101</td>
    <td class="codeline">    rot = rotateAmt.zext(BitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1102</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeline">  rot = rot.urem(APInt(rot.getBitWidth(), BitWidth));</td>
    <td class="lineNumber">1103</td>
    <td class="codeline">  rot = rot.urem(APInt(rot.getBitWidth(), BitWidth));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeline">  return rot.getLimitedValue(BitWidth);</td>
    <td class="lineNumber">1104</td>
    <td class="codeline">  return rot.getLimitedValue(BitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1105</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeline"></td>
    <td class="lineNumber">1106</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeline">APInt APInt::rotl(const APInt &rotateAmt) const {</td>
    <td class="lineNumber">1107</td>
    <td class="codeline">APInt APInt::rotl(const APInt &rotateAmt) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeline">  return rotl(rotateModulo(BitWidth, rotateAmt));</td>
    <td class="lineNumber">1108</td>
    <td class="codeline">  return rotl(rotateModulo(BitWidth, rotateAmt));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1109</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeline"></td>
    <td class="lineNumber">1110</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeline">APInt APInt::rotl(unsigned rotateAmt) const {</td>
    <td class="lineNumber">1111</td>
    <td class="codeline">APInt APInt::rotl(unsigned rotateAmt) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeline">  if (LLVM_UNLIKELY(BitWidth == 0))</td>
    <td class="lineNumber">1112</td>
    <td class="codeline">  if (LLVM_UNLIKELY(BitWidth == 0))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeline">    return *this;</td>
    <td class="lineNumber">1113</td>
    <td class="codeline">    return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeline">  rotateAmt %= BitWidth;</td>
    <td class="lineNumber">1114</td>
    <td class="codeline">  rotateAmt %= BitWidth;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeline">  if (rotateAmt == 0)</td>
    <td class="lineNumber">1115</td>
    <td class="codeline">  if (rotateAmt == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeline">    return *this;</td>
    <td class="lineNumber">1116</td>
    <td class="codeline">    return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeline">  return shl(rotateAmt) | lshr(BitWidth - rotateAmt);</td>
    <td class="lineNumber">1117</td>
    <td class="codeline">  return shl(rotateAmt) | lshr(BitWidth - rotateAmt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1118</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeline"></td>
    <td class="lineNumber">1119</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeline">APInt APInt::rotr(const APInt &rotateAmt) const {</td>
    <td class="lineNumber">1120</td>
    <td class="codeline">APInt APInt::rotr(const APInt &rotateAmt) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeline">  return rotr(rotateModulo(BitWidth, rotateAmt));</td>
    <td class="lineNumber">1121</td>
    <td class="codeline">  return rotr(rotateModulo(BitWidth, rotateAmt));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1122</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeline"></td>
    <td class="lineNumber">1123</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeline">APInt APInt::rotr(unsigned rotateAmt) const {</td>
    <td class="lineNumber">1124</td>
    <td class="codeline">APInt APInt::rotr(unsigned rotateAmt) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeline">  if (BitWidth == 0)</td>
    <td class="lineNumber">1125</td>
    <td class="codeline">  if (BitWidth == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeline">    return *this;</td>
    <td class="lineNumber">1126</td>
    <td class="codeline">    return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeline">  rotateAmt %= BitWidth;</td>
    <td class="lineNumber">1127</td>
    <td class="codeline">  rotateAmt %= BitWidth;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeline">  if (rotateAmt == 0)</td>
    <td class="lineNumber">1128</td>
    <td class="codeline">  if (rotateAmt == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeline">    return *this;</td>
    <td class="lineNumber">1129</td>
    <td class="codeline">    return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeline">  return lshr(rotateAmt) | shl(BitWidth - rotateAmt);</td>
    <td class="lineNumber">1130</td>
    <td class="codeline">  return lshr(rotateAmt) | shl(BitWidth - rotateAmt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1131</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeline"></td>
    <td class="lineNumber">1132</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeline">/// \returns the nearest log base 2 of this APInt. Ties round up.</td>
    <td class="lineNumber">1133</td>
    <td class="codeline">/// \returns the nearest log base 2 of this APInt. Ties round up.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1134</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeline">/// NOTE: When we have a BitWidth of 1, we define:</td>
    <td class="lineNumber">1135</td>
    <td class="codeline">/// NOTE: When we have a BitWidth of 1, we define:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1136</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeline">///   log2(0) = UINT32_MAX</td>
    <td class="lineNumber">1137</td>
    <td class="codeline">///   log2(0) = UINT32_MAX</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeline">///   log2(1) = 0</td>
    <td class="lineNumber">1138</td>
    <td class="codeline">///   log2(1) = 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1139</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeline">/// to get around any mathematical concerns resulting from</td>
    <td class="lineNumber">1140</td>
    <td class="codeline">/// to get around any mathematical concerns resulting from</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeline">/// referencing 2 in a space where 2 does no exist.</td>
    <td class="lineNumber">1141</td>
    <td class="codeline">/// referencing 2 in a space where 2 does no exist.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeline">unsigned APInt::nearestLogBase2() const {</td>
    <td class="lineNumber">1142</td>
    <td class="codeline">unsigned APInt::nearestLogBase2() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeline">  // Special case when we have a bitwidth of 1. If VAL is 1, then we</td>
    <td class="lineNumber">1143</td>
    <td class="codeline">  // Special case when we have a bitwidth of 1. If VAL is 1, then we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeline">  // get 0. If VAL is 0, we get WORDTYPE_MAX which gets truncated to</td>
    <td class="lineNumber">1144</td>
    <td class="codeline">  // get 0. If VAL is 0, we get WORDTYPE_MAX which gets truncated to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeline">  // UINT32_MAX.</td>
    <td class="lineNumber">1145</td>
    <td class="codeline">  // UINT32_MAX.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeline">  if (BitWidth == 1)</td>
    <td class="lineNumber">1146</td>
    <td class="codeline">  if (BitWidth == 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeline">    return U.VAL - 1;</td>
    <td class="lineNumber">1147</td>
    <td class="codeline">    return U.VAL - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeline"></td>
    <td class="lineNumber">1148</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeline">  // Handle the zero case.</td>
    <td class="lineNumber">1149</td>
    <td class="codeline">  // Handle the zero case.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeline">  if (isZero())</td>
    <td class="lineNumber">1150</td>
    <td class="codeline">  if (isZero())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeline">    return UINT32_MAX;</td>
    <td class="lineNumber">1151</td>
    <td class="codeline">    return UINT32_MAX;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeline"></td>
    <td class="lineNumber">1152</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeline">  // The non-zero case is handled by computing:</td>
    <td class="lineNumber">1153</td>
    <td class="codeline">  // The non-zero case is handled by computing:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1154</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeline">  //   nearestLogBase2(x) = logBase2(x) + x[logBase2(x)-1].</td>
    <td class="lineNumber">1155</td>
    <td class="codeline">  //   nearestLogBase2(x) = logBase2(x) + x[logBase2(x)-1].</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1156</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeline">  // where x[i] is referring to the value of the ith bit of x.</td>
    <td class="lineNumber">1157</td>
    <td class="codeline">  // where x[i] is referring to the value of the ith bit of x.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeline">  unsigned lg = logBase2();</td>
    <td class="lineNumber">1158</td>
    <td class="codeline">  unsigned lg = logBase2();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeline">  return lg + unsigned((*this)[lg - 1]);</td>
    <td class="lineNumber">1159</td>
    <td class="codeline">  return lg + unsigned((*this)[lg - 1]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1160</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeline"></td>
    <td class="lineNumber">1161</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeline">// Square Root - this method computes and returns the square root of "this".</td>
    <td class="lineNumber">1162</td>
    <td class="codeline">// Square Root - this method computes and returns the square root of "this".</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeline">// Three mechanisms are used for computation. For small values (<= 5 bits),</td>
    <td class="lineNumber">1163</td>
    <td class="codeline">// Three mechanisms are used for computation. For small values (<= 5 bits),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeline">// a table lookup is done. This gets some performance for common cases. For</td>
    <td class="lineNumber">1164</td>
    <td class="codeline">// a table lookup is done. This gets some performance for common cases. For</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeline">// values using less than 52 bits, the value is converted to double and then</td>
    <td class="lineNumber">1165</td>
    <td class="codeline">// values using less than 52 bits, the value is converted to double and then</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeline">// the libc sqrt function is called. The result is rounded and then converted</td>
    <td class="lineNumber">1166</td>
    <td class="codeline">// the libc sqrt function is called. The result is rounded and then converted</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeline">// back to a uint64_t which is then used to construct the result. Finally,</td>
    <td class="lineNumber">1167</td>
    <td class="codeline">// back to a uint64_t which is then used to construct the result. Finally,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeline">// the Babylonian method for computing square roots is used.</td>
    <td class="lineNumber">1168</td>
    <td class="codeline">// the Babylonian method for computing square roots is used.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeline">APInt APInt::sqrt() const {</td>
    <td class="lineNumber">1169</td>
    <td class="codeline">APInt APInt::sqrt() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeline"></td>
    <td class="lineNumber">1170</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeline">  // Determine the magnitude of the value.</td>
    <td class="lineNumber">1171</td>
    <td class="codeline">  // Determine the magnitude of the value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeline">  unsigned magnitude = getActiveBits();</td>
    <td class="lineNumber">1172</td>
    <td class="codeline">  unsigned magnitude = getActiveBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeline"></td>
    <td class="lineNumber">1173</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeline">  // Use a fast table for some small values. This also gets rid of some</td>
    <td class="lineNumber">1174</td>
    <td class="codeline">  // Use a fast table for some small values. This also gets rid of some</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeline">  // rounding errors in libc sqrt for small values.</td>
    <td class="lineNumber">1175</td>
    <td class="codeline">  // rounding errors in libc sqrt for small values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeline">  if (magnitude <= 5) {</td>
    <td class="lineNumber">1176</td>
    <td class="codeline">  if (magnitude <= 5) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeline">    static const uint8_t results[32] = {</td>
    <td class="lineNumber">1177</td>
    <td class="codeline">    static const uint8_t results[32] = {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeline">      /*     0 */ 0,</td>
    <td class="lineNumber">1178</td>
    <td class="codeline">      /*     0 */ 0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeline">      /*  1- 2 */ 1, 1,</td>
    <td class="lineNumber">1179</td>
    <td class="codeline">      /*  1- 2 */ 1, 1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeline">      /*  3- 6 */ 2, 2, 2, 2,</td>
    <td class="lineNumber">1180</td>
    <td class="codeline">      /*  3- 6 */ 2, 2, 2, 2,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeline">      /*  7-12 */ 3, 3, 3, 3, 3, 3,</td>
    <td class="lineNumber">1181</td>
    <td class="codeline">      /*  7-12 */ 3, 3, 3, 3, 3, 3,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeline">      /* 13-20 */ 4, 4, 4, 4, 4, 4, 4, 4,</td>
    <td class="lineNumber">1182</td>
    <td class="codeline">      /* 13-20 */ 4, 4, 4, 4, 4, 4, 4, 4,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeline">      /* 21-30 */ 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,</td>
    <td class="lineNumber">1183</td>
    <td class="codeline">      /* 21-30 */ 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeline">      /*    31 */ 6</td>
    <td class="lineNumber">1184</td>
    <td class="codeline">      /*    31 */ 6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeline">    };</td>
    <td class="lineNumber">1185</td>
    <td class="codeline">    };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeline">    return APInt(BitWidth, results[ (isSingleWord() ? U.VAL : U.pVal[0]) ]);</td>
    <td class="lineNumber">1186</td>
    <td class="codeline">    return APInt(BitWidth, results[ (isSingleWord() ? U.VAL : U.pVal[0]) ]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1187</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeline"></td>
    <td class="lineNumber">1188</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeline">  // If the magnitude of the value fits in less than 52 bits (the precision of</td>
    <td class="lineNumber">1189</td>
    <td class="codeline">  // If the magnitude of the value fits in less than 52 bits (the precision of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeline">  // an IEEE double precision floating point value), then we can use the</td>
    <td class="lineNumber">1190</td>
    <td class="codeline">  // an IEEE double precision floating point value), then we can use the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeline">  // libc sqrt function which will probably use a hardware sqrt computation.</td>
    <td class="lineNumber">1191</td>
    <td class="codeline">  // libc sqrt function which will probably use a hardware sqrt computation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeline">  // This should be faster than the algorithm below.</td>
    <td class="lineNumber">1192</td>
    <td class="codeline">  // This should be faster than the algorithm below.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeline">  if (magnitude < 52) {</td>
    <td class="lineNumber">1193</td>
    <td class="codeline">  if (magnitude < 52) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeline">    return APInt(BitWidth,</td>
    <td class="lineNumber">1194</td>
    <td class="codeline">    return APInt(BitWidth,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeline">                 uint64_t(::round(::sqrt(double(isSingleWord() ? U.VAL</td>
    <td class="lineNumber">1195</td>
    <td class="codeline">                 uint64_t(::round(::sqrt(double(isSingleWord() ? U.VAL</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeline">                                                               : U.pVal[0])))));</td>
    <td class="lineNumber">1196</td>
    <td class="codeline">                                                               : U.pVal[0])))));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1197</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeline"></td>
    <td class="lineNumber">1198</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeline">  // Okay, all the short cuts are exhausted. We must compute it. The following</td>
    <td class="lineNumber">1199</td>
    <td class="codeline">  // Okay, all the short cuts are exhausted. We must compute it. The following</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeline">  // is a classical Babylonian method for computing the square root. This code</td>
    <td class="lineNumber">1200</td>
    <td class="codeline">  // is a classical Babylonian method for computing the square root. This code</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeline">  // was adapted to APInt from a wikipedia article on such computations.</td>
    <td class="lineNumber">1201</td>
    <td class="codeline">  // was adapted to APInt from a wikipedia article on such computations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeline">  // See http://www.wikipedia.org/ and go to the page named</td>
    <td class="lineNumber">1202</td>
    <td class="codeline">  // See http://www.wikipedia.org/ and go to the page named</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeline">  // Calculate_an_integer_square_root.</td>
    <td class="lineNumber">1203</td>
    <td class="codeline">  // Calculate_an_integer_square_root.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeline">  unsigned nbits = BitWidth, i = 4;</td>
    <td class="lineNumber">1204</td>
    <td class="codeline">  unsigned nbits = BitWidth, i = 4;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeline">  APInt testy(BitWidth, 16);</td>
    <td class="lineNumber">1205</td>
    <td class="codeline">  APInt testy(BitWidth, 16);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeline">  APInt x_old(BitWidth, 1);</td>
    <td class="lineNumber">1206</td>
    <td class="codeline">  APInt x_old(BitWidth, 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeline">  APInt x_new(BitWidth, 0);</td>
    <td class="lineNumber">1207</td>
    <td class="codeline">  APInt x_new(BitWidth, 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeline">  APInt two(BitWidth, 2);</td>
    <td class="lineNumber">1208</td>
    <td class="codeline">  APInt two(BitWidth, 2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeline"></td>
    <td class="lineNumber">1209</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeline">  // Select a good starting value using binary logarithms.</td>
    <td class="lineNumber">1210</td>
    <td class="codeline">  // Select a good starting value using binary logarithms.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeline">  for (;; i += 2, testy = testy.shl(2))</td>
    <td class="lineNumber">1211</td>
    <td class="codeline">  for (;; i += 2, testy = testy.shl(2))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeline">    if (i >= nbits || this->ule(testy)) {</td>
    <td class="lineNumber">1212</td>
    <td class="codeline">    if (i >= nbits || this->ule(testy)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeline">      x_old = x_old.shl(i / 2);</td>
    <td class="lineNumber">1213</td>
    <td class="codeline">      x_old = x_old.shl(i / 2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1214</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1215</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeline"></td>
    <td class="lineNumber">1216</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeline">  // Use the Babylonian method to arrive at the integer square root:</td>
    <td class="lineNumber">1217</td>
    <td class="codeline">  // Use the Babylonian method to arrive at the integer square root:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeline">  for (;;) {</td>
    <td class="lineNumber">1218</td>
    <td class="codeline">  for (;;) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeline">    x_new = (this->udiv(x_old) + x_old).udiv(two);</td>
    <td class="lineNumber">1219</td>
    <td class="codeline">    x_new = (this->udiv(x_old) + x_old).udiv(two);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeline">    if (x_old.ule(x_new))</td>
    <td class="lineNumber">1220</td>
    <td class="codeline">    if (x_old.ule(x_new))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1221</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeline">    x_old = x_new;</td>
    <td class="lineNumber">1222</td>
    <td class="codeline">    x_old = x_new;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1223</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeline"></td>
    <td class="lineNumber">1224</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeline">  // Make sure we return the closest approximation</td>
    <td class="lineNumber">1225</td>
    <td class="codeline">  // Make sure we return the closest approximation</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeline">  // NOTE: The rounding calculation below is correct. It will produce an</td>
    <td class="lineNumber">1226</td>
    <td class="codeline">  // NOTE: The rounding calculation below is correct. It will produce an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeline">  // off-by-one discrepancy with results from pari/gp. That discrepancy has been</td>
    <td class="lineNumber">1227</td>
    <td class="codeline">  // off-by-one discrepancy with results from pari/gp. That discrepancy has been</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeline">  // determined to be a rounding issue with pari/gp as it begins to use a</td>
    <td class="lineNumber">1228</td>
    <td class="codeline">  // determined to be a rounding issue with pari/gp as it begins to use a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeline">  // floating point representation after 192 bits. There are no discrepancies</td>
    <td class="lineNumber">1229</td>
    <td class="codeline">  // floating point representation after 192 bits. There are no discrepancies</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeline">  // between this algorithm and pari/gp for bit widths < 192 bits.</td>
    <td class="lineNumber">1230</td>
    <td class="codeline">  // between this algorithm and pari/gp for bit widths < 192 bits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeline">  APInt square(x_old * x_old);</td>
    <td class="lineNumber">1231</td>
    <td class="codeline">  APInt square(x_old * x_old);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeline">  APInt nextSquare((x_old + 1) * (x_old +1));</td>
    <td class="lineNumber">1232</td>
    <td class="codeline">  APInt nextSquare((x_old + 1) * (x_old +1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeline">  if (this->ult(square))</td>
    <td class="lineNumber">1233</td>
    <td class="codeline">  if (this->ult(square))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeline">    return x_old;</td>
    <td class="lineNumber">1234</td>
    <td class="codeline">    return x_old;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeline">  assert(this->ule(nextSquare) && "Error in APInt::sqrt computation");</td>
    <td class="lineNumber">1235</td>
    <td class="codeline">  assert(this->ule(nextSquare) && "Error in APInt::sqrt computation");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeline">  APInt midpoint((nextSquare - square).udiv(two));</td>
    <td class="lineNumber">1236</td>
    <td class="codeline">  APInt midpoint((nextSquare - square).udiv(two));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeline">  APInt offset(*this - square);</td>
    <td class="lineNumber">1237</td>
    <td class="codeline">  APInt offset(*this - square);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeline">  if (offset.ult(midpoint))</td>
    <td class="lineNumber">1238</td>
    <td class="codeline">  if (offset.ult(midpoint))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeline">    return x_old;</td>
    <td class="lineNumber">1239</td>
    <td class="codeline">    return x_old;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeline">  return x_old + 1;</td>
    <td class="lineNumber">1240</td>
    <td class="codeline">  return x_old + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1241</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeline"></td>
    <td class="lineNumber">1242</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeline">/// Computes the multiplicative inverse of this APInt for a given modulo. The</td>
    <td class="lineNumber">1243</td>
    <td class="codeline">/// Computes the multiplicative inverse of this APInt for a given modulo. The</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeline">/// iterative extended Euclidean algorithm is used to solve for this value,</td>
    <td class="lineNumber">1244</td>
    <td class="codeline">/// iterative extended Euclidean algorithm is used to solve for this value,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeline">/// however we simplify it to speed up calculating only the inverse, and take</td>
    <td class="lineNumber">1245</td>
    <td class="codeline">/// however we simplify it to speed up calculating only the inverse, and take</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeline">/// advantage of div+rem calculations. We also use some tricks to avoid copying</td>
    <td class="lineNumber">1246</td>
    <td class="codeline">/// advantage of div+rem calculations. We also use some tricks to avoid copying</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeline">/// (potentially large) APInts around.</td>
    <td class="lineNumber">1247</td>
    <td class="codeline">/// (potentially large) APInts around.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeline">/// WARNING: a value of '0' may be returned,</td>
    <td class="lineNumber">1248</td>
    <td class="codeline">/// WARNING: a value of '0' may be returned,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeline">///          signifying that no multiplicative inverse exists!</td>
    <td class="lineNumber">1249</td>
    <td class="codeline">///          signifying that no multiplicative inverse exists!</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeline">APInt APInt::multiplicativeInverse(const APInt& modulo) const {</td>
    <td class="lineNumber">1250</td>
    <td class="codeline">APInt APInt::multiplicativeInverse(const APInt& modulo) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeline">  assert(ult(modulo) && "This APInt must be smaller than the modulo");</td>
    <td class="lineNumber">1251</td>
    <td class="codeline">  assert(ult(modulo) && "This APInt must be smaller than the modulo");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeline"></td>
    <td class="lineNumber">1252</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeline">  // Using the properties listed at the following web page (accessed 06/21/08):</td>
    <td class="lineNumber">1253</td>
    <td class="codeline">  // Using the properties listed at the following web page (accessed 06/21/08):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeline">  //   http://www.numbertheory.org/php/euclid.html</td>
    <td class="lineNumber">1254</td>
    <td class="codeline">  //   http://www.numbertheory.org/php/euclid.html</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeline">  // (especially the properties numbered 3, 4 and 9) it can be proved that</td>
    <td class="lineNumber">1255</td>
    <td class="codeline">  // (especially the properties numbered 3, 4 and 9) it can be proved that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeline">  // BitWidth bits suffice for all the computations in the algorithm implemented</td>
    <td class="lineNumber">1256</td>
    <td class="codeline">  // BitWidth bits suffice for all the computations in the algorithm implemented</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeline">  // below. More precisely, this number of bits suffice if the multiplicative</td>
    <td class="lineNumber">1257</td>
    <td class="codeline">  // below. More precisely, this number of bits suffice if the multiplicative</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeline">  // inverse exists, but may not suffice for the general extended Euclidean</td>
    <td class="lineNumber">1258</td>
    <td class="codeline">  // inverse exists, but may not suffice for the general extended Euclidean</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeline">  // algorithm.</td>
    <td class="lineNumber">1259</td>
    <td class="codeline">  // algorithm.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeline"></td>
    <td class="lineNumber">1260</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeline">  APInt r[2] = { modulo, *this };</td>
    <td class="lineNumber">1261</td>
    <td class="codeline">  APInt r[2] = { modulo, *this };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeline">  APInt t[2] = { APInt(BitWidth, 0), APInt(BitWidth, 1) };</td>
    <td class="lineNumber">1262</td>
    <td class="codeline">  APInt t[2] = { APInt(BitWidth, 0), APInt(BitWidth, 1) };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeline">  APInt q(BitWidth, 0);</td>
    <td class="lineNumber">1263</td>
    <td class="codeline">  APInt q(BitWidth, 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeline"></td>
    <td class="lineNumber">1264</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeline">  unsigned i;</td>
    <td class="lineNumber">1265</td>
    <td class="codeline">  unsigned i;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeline">  for (i = 0; r[i^1] != 0; i ^= 1) {</td>
    <td class="lineNumber">1266</td>
    <td class="codeline">  for (i = 0; r[i^1] != 0; i ^= 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeline">    // An overview of the math without the confusing bit-flipping:</td>
    <td class="lineNumber">1267</td>
    <td class="codeline">    // An overview of the math without the confusing bit-flipping:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeline">    // q = r[i-2] / r[i-1]</td>
    <td class="lineNumber">1268</td>
    <td class="codeline">    // q = r[i-2] / r[i-1]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeline">    // r[i] = r[i-2] % r[i-1]</td>
    <td class="lineNumber">1269</td>
    <td class="codeline">    // r[i] = r[i-2] % r[i-1]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeline">    // t[i] = t[i-2] - t[i-1] * q</td>
    <td class="lineNumber">1270</td>
    <td class="codeline">    // t[i] = t[i-2] - t[i-1] * q</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeline">    udivrem(r[i], r[i^1], q, r[i]);</td>
    <td class="lineNumber">1271</td>
    <td class="codeline">    udivrem(r[i], r[i^1], q, r[i]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeline">    t[i] -= t[i^1] * q;</td>
    <td class="lineNumber">1272</td>
    <td class="codeline">    t[i] -= t[i^1] * q;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1273</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeline"></td>
    <td class="lineNumber">1274</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeline">  // If this APInt and the modulo are not coprime, there is no multiplicative</td>
    <td class="lineNumber">1275</td>
    <td class="codeline">  // If this APInt and the modulo are not coprime, there is no multiplicative</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeline">  // inverse, so return 0. We check this by looking at the next-to-last</td>
    <td class="lineNumber">1276</td>
    <td class="codeline">  // inverse, so return 0. We check this by looking at the next-to-last</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeline">  // remainder, which is the gcd(*this,modulo) as calculated by the Euclidean</td>
    <td class="lineNumber">1277</td>
    <td class="codeline">  // remainder, which is the gcd(*this,modulo) as calculated by the Euclidean</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeline">  // algorithm.</td>
    <td class="lineNumber">1278</td>
    <td class="codeline">  // algorithm.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeline">  if (r[i] != 1)</td>
    <td class="lineNumber">1279</td>
    <td class="codeline">  if (r[i] != 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeline">    return APInt(BitWidth, 0);</td>
    <td class="lineNumber">1280</td>
    <td class="codeline">    return APInt(BitWidth, 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeline"></td>
    <td class="lineNumber">1281</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeline">  // The next-to-last t is the multiplicative inverse.  However, we are</td>
    <td class="lineNumber">1282</td>
    <td class="codeline">  // The next-to-last t is the multiplicative inverse.  However, we are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeline">  // interested in a positive inverse. Calculate a positive one from a negative</td>
    <td class="lineNumber">1283</td>
    <td class="codeline">  // interested in a positive inverse. Calculate a positive one from a negative</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeline">  // one if necessary. A simple addition of the modulo suffices because</td>
    <td class="lineNumber">1284</td>
    <td class="codeline">  // one if necessary. A simple addition of the modulo suffices because</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeline">  // abs(t[i]) is known to be less than *this/2 (see the link above).</td>
    <td class="lineNumber">1285</td>
    <td class="codeline">  // abs(t[i]) is known to be less than *this/2 (see the link above).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeline">  if (t[i].isNegative())</td>
    <td class="lineNumber">1286</td>
    <td class="codeline">  if (t[i].isNegative())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeline">    t[i] += modulo;</td>
    <td class="lineNumber">1287</td>
    <td class="codeline">    t[i] += modulo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeline"></td>
    <td class="lineNumber">1288</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeline">  return std::move(t[i]);</td>
    <td class="lineNumber">1289</td>
    <td class="codeline">  return std::move(t[i]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1290</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeline"></td>
    <td class="lineNumber">1291</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeline">/// Implementation of Knuth's Algorithm D (Division of nonnegative integers)</td>
    <td class="lineNumber">1292</td>
    <td class="codeline">/// Implementation of Knuth's Algorithm D (Division of nonnegative integers)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeline">/// from "Art of Computer Programming, Volume 2", section 4.3.1, p. 272. The</td>
    <td class="lineNumber">1293</td>
    <td class="codeline">/// from "Art of Computer Programming, Volume 2", section 4.3.1, p. 272. The</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeline">/// variables here have the same names as in the algorithm. Comments explain</td>
    <td class="lineNumber">1294</td>
    <td class="codeline">/// variables here have the same names as in the algorithm. Comments explain</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeline">/// the algorithm and any deviation from it.</td>
    <td class="lineNumber">1295</td>
    <td class="codeline">/// the algorithm and any deviation from it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeline">static void KnuthDiv(uint32_t *u, uint32_t *v, uint32_t *q, uint32_t* r,</td>
    <td class="lineNumber">1296</td>
    <td class="codeline">static void KnuthDiv(uint32_t *u, uint32_t *v, uint32_t *q, uint32_t* r,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeline">                     unsigned m, unsigned n) {</td>
    <td class="lineNumber">1297</td>
    <td class="codeline">                     unsigned m, unsigned n) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeline">  assert(u && "Must provide dividend");</td>
    <td class="lineNumber">1298</td>
    <td class="codeline">  assert(u && "Must provide dividend");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeline">  assert(v && "Must provide divisor");</td>
    <td class="lineNumber">1299</td>
    <td class="codeline">  assert(v && "Must provide divisor");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeline">  assert(q && "Must provide quotient");</td>
    <td class="lineNumber">1300</td>
    <td class="codeline">  assert(q && "Must provide quotient");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeline">  assert(u != v && u != q && v != q && "Must use different memory");</td>
    <td class="lineNumber">1301</td>
    <td class="codeline">  assert(u != v && u != q && v != q && "Must use different memory");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeline">  assert(n>1 && "n must be > 1");</td>
    <td class="lineNumber">1302</td>
    <td class="codeline">  assert(n>1 && "n must be > 1");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeline"></td>
    <td class="lineNumber">1303</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeline">  // b denotes the base of the number system. In our case b is 2^32.</td>
    <td class="lineNumber">1304</td>
    <td class="codeline">  // b denotes the base of the number system. In our case b is 2^32.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeline">  const uint64_t b = uint64_t(1) << 32;</td>
    <td class="lineNumber">1305</td>
    <td class="codeline">  const uint64_t b = uint64_t(1) << 32;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeline"></td>
    <td class="lineNumber">1306</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeline">// The DEBUG macros here tend to be spam in the debug output if you're not</td>
    <td class="lineNumber">1307</td>
    <td class="codeline">// The DEBUG macros here tend to be spam in the debug output if you're not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeline">// debugging this code. Disable them unless KNUTH_DEBUG is defined.</td>
    <td class="lineNumber">1308</td>
    <td class="codeline">// debugging this code. Disable them unless KNUTH_DEBUG is defined.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeline">#ifdef KNUTH_DEBUG</td>
    <td class="lineNumber">1309</td>
    <td class="codeline">#ifdef KNUTH_DEBUG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeline">#define DEBUG_KNUTH(X) LLVM_DEBUG(X)</td>
    <td class="lineNumber">1310</td>
    <td class="codeline">#define DEBUG_KNUTH(X) LLVM_DEBUG(X)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeline">#else</td>
    <td class="lineNumber">1311</td>
    <td class="codeline">#else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeline">#define DEBUG_KNUTH(X) do {} while(false)</td>
    <td class="lineNumber">1312</td>
    <td class="codeline">#define DEBUG_KNUTH(X) do {} while(false)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">1313</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeline"></td>
    <td class="lineNumber">1314</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeline">  DEBUG_KNUTH(dbgs() << "KnuthDiv: m=" << m << " n=" << n << '\n');</td>
    <td class="lineNumber">1315</td>
    <td class="codeline">  DEBUG_KNUTH(dbgs() << "KnuthDiv: m=" << m << " n=" << n << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeline">  DEBUG_KNUTH(dbgs() << "KnuthDiv: original:");</td>
    <td class="lineNumber">1316</td>
    <td class="codeline">  DEBUG_KNUTH(dbgs() << "KnuthDiv: original:");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeline">  DEBUG_KNUTH(for (int i = m + n; i >= 0; i--) dbgs() << " " << u[i]);</td>
    <td class="lineNumber">1317</td>
    <td class="codeline">  DEBUG_KNUTH(for (int i = m + n; i >= 0; i--) dbgs() << " " << u[i]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeline">  DEBUG_KNUTH(dbgs() << " by");</td>
    <td class="lineNumber">1318</td>
    <td class="codeline">  DEBUG_KNUTH(dbgs() << " by");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeline">  DEBUG_KNUTH(for (int i = n; i > 0; i--) dbgs() << " " << v[i - 1]);</td>
    <td class="lineNumber">1319</td>
    <td class="codeline">  DEBUG_KNUTH(for (int i = n; i > 0; i--) dbgs() << " " << v[i - 1]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeline">  DEBUG_KNUTH(dbgs() << '\n');</td>
    <td class="lineNumber">1320</td>
    <td class="codeline">  DEBUG_KNUTH(dbgs() << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeline">  // D1. [Normalize.] Set d = b / (v[n-1] + 1) and multiply all the digits of</td>
    <td class="lineNumber">1321</td>
    <td class="codeline">  // D1. [Normalize.] Set d = b / (v[n-1] + 1) and multiply all the digits of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeline">  // u and v by d. Note that we have taken Knuth's advice here to use a power</td>
    <td class="lineNumber">1322</td>
    <td class="codeline">  // u and v by d. Note that we have taken Knuth's advice here to use a power</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeline">  // of 2 value for d such that d * v[n-1] >= b/2 (b is the base). A power of</td>
    <td class="lineNumber">1323</td>
    <td class="codeline">  // of 2 value for d such that d * v[n-1] >= b/2 (b is the base). A power of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeline">  // 2 allows us to shift instead of multiply and it is easy to determine the</td>
    <td class="lineNumber">1324</td>
    <td class="codeline">  // 2 allows us to shift instead of multiply and it is easy to determine the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeline">  // shift amount from the leading zeros.  We are basically normalizing the u</td>
    <td class="lineNumber">1325</td>
    <td class="codeline">  // shift amount from the leading zeros.  We are basically normalizing the u</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeline">  // and v so that its high bits are shifted to the top of v's range without</td>
    <td class="lineNumber">1326</td>
    <td class="codeline">  // and v so that its high bits are shifted to the top of v's range without</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeline">  // overflow. Note that this can require an extra word in u so that u must</td>
    <td class="lineNumber">1327</td>
    <td class="codeline">  // overflow. Note that this can require an extra word in u so that u must</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeline">  // be of length m+n+1.</td>
    <td class="lineNumber">1328</td>
    <td class="codeline">  // be of length m+n+1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeline">  unsigned shift = llvm::countl_zero(v[n - 1]);</td>
    <td class="lineNumber">1329</td>
    <td class="codeline">  unsigned shift = llvm::countl_zero(v[n - 1]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeline">  uint32_t v_carry = 0;</td>
    <td class="lineNumber">1330</td>
    <td class="codeline">  uint32_t v_carry = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeline">  uint32_t u_carry = 0;</td>
    <td class="lineNumber">1331</td>
    <td class="codeline">  uint32_t u_carry = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeline">  if (shift) {</td>
    <td class="lineNumber">1332</td>
    <td class="codeline">  if (shift) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeline">    for (unsigned i = 0; i < m+n; ++i) {</td>
    <td class="lineNumber">1333</td>
    <td class="codeline">    for (unsigned i = 0; i < m+n; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeline">      uint32_t u_tmp = u[i] >> (32 - shift);</td>
    <td class="lineNumber">1334</td>
    <td class="codeline">      uint32_t u_tmp = u[i] >> (32 - shift);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeline">      u[i] = (u[i] << shift) | u_carry;</td>
    <td class="lineNumber">1335</td>
    <td class="codeline">      u[i] = (u[i] << shift) | u_carry;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeline">      u_carry = u_tmp;</td>
    <td class="lineNumber">1336</td>
    <td class="codeline">      u_carry = u_tmp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1337</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeline">    for (unsigned i = 0; i < n; ++i) {</td>
    <td class="lineNumber">1338</td>
    <td class="codeline">    for (unsigned i = 0; i < n; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeline">      uint32_t v_tmp = v[i] >> (32 - shift);</td>
    <td class="lineNumber">1339</td>
    <td class="codeline">      uint32_t v_tmp = v[i] >> (32 - shift);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeline">      v[i] = (v[i] << shift) | v_carry;</td>
    <td class="lineNumber">1340</td>
    <td class="codeline">      v[i] = (v[i] << shift) | v_carry;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeline">      v_carry = v_tmp;</td>
    <td class="lineNumber">1341</td>
    <td class="codeline">      v_carry = v_tmp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1342</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1343</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeline">  u[m+n] = u_carry;</td>
    <td class="lineNumber">1344</td>
    <td class="codeline">  u[m+n] = u_carry;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeline"></td>
    <td class="lineNumber">1345</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeline">  DEBUG_KNUTH(dbgs() << "KnuthDiv:   normal:");</td>
    <td class="lineNumber">1346</td>
    <td class="codeline">  DEBUG_KNUTH(dbgs() << "KnuthDiv:   normal:");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeline">  DEBUG_KNUTH(for (int i = m + n; i >= 0; i--) dbgs() << " " << u[i]);</td>
    <td class="lineNumber">1347</td>
    <td class="codeline">  DEBUG_KNUTH(for (int i = m + n; i >= 0; i--) dbgs() << " " << u[i]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeline">  DEBUG_KNUTH(dbgs() << " by");</td>
    <td class="lineNumber">1348</td>
    <td class="codeline">  DEBUG_KNUTH(dbgs() << " by");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeline">  DEBUG_KNUTH(for (int i = n; i > 0; i--) dbgs() << " " << v[i - 1]);</td>
    <td class="lineNumber">1349</td>
    <td class="codeline">  DEBUG_KNUTH(for (int i = n; i > 0; i--) dbgs() << " " << v[i - 1]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeline">  DEBUG_KNUTH(dbgs() << '\n');</td>
    <td class="lineNumber">1350</td>
    <td class="codeline">  DEBUG_KNUTH(dbgs() << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeline"></td>
    <td class="lineNumber">1351</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeline">  // D2. [Initialize j.]  Set j to m. This is the loop counter over the places.</td>
    <td class="lineNumber">1352</td>
    <td class="codeline">  // D2. [Initialize j.]  Set j to m. This is the loop counter over the places.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeline">  int j = m;</td>
    <td class="lineNumber">1353</td>
    <td class="codeline">  int j = m;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeline">  do {</td>
    <td class="lineNumber">1354</td>
    <td class="codeline">  do {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeline">    DEBUG_KNUTH(dbgs() << "KnuthDiv: quotient digit #" << j << '\n');</td>
    <td class="lineNumber">1355</td>
    <td class="codeline">    DEBUG_KNUTH(dbgs() << "KnuthDiv: quotient digit #" << j << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeline">    // D3. [Calculate q'.].</td>
    <td class="lineNumber">1356</td>
    <td class="codeline">    // D3. [Calculate q'.].</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeline">    //     Set qp = (u[j+n]*b + u[j+n-1]) / v[n-1]. (qp=qprime=q')</td>
    <td class="lineNumber">1357</td>
    <td class="codeline">    //     Set qp = (u[j+n]*b + u[j+n-1]) / v[n-1]. (qp=qprime=q')</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeline">    //     Set rp = (u[j+n]*b + u[j+n-1]) % v[n-1]. (rp=rprime=r')</td>
    <td class="lineNumber">1358</td>
    <td class="codeline">    //     Set rp = (u[j+n]*b + u[j+n-1]) % v[n-1]. (rp=rprime=r')</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeline">    // Now test if qp == b or qp*v[n-2] > b*rp + u[j+n-2]; if so, decrease</td>
    <td class="lineNumber">1359</td>
    <td class="codeline">    // Now test if qp == b or qp*v[n-2] > b*rp + u[j+n-2]; if so, decrease</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeline">    // qp by 1, increase rp by v[n-1], and repeat this test if rp < b. The test</td>
    <td class="lineNumber">1360</td>
    <td class="codeline">    // qp by 1, increase rp by v[n-1], and repeat this test if rp < b. The test</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeline">    // on v[n-2] determines at high speed most of the cases in which the trial</td>
    <td class="lineNumber">1361</td>
    <td class="codeline">    // on v[n-2] determines at high speed most of the cases in which the trial</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeline">    // value qp is one too large, and it eliminates all cases where qp is two</td>
    <td class="lineNumber">1362</td>
    <td class="codeline">    // value qp is one too large, and it eliminates all cases where qp is two</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeline">    // too large.</td>
    <td class="lineNumber">1363</td>
    <td class="codeline">    // too large.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeline">    uint64_t dividend = Make_64(u[j+n], u[j+n-1]);</td>
    <td class="lineNumber">1364</td>
    <td class="codeline">    uint64_t dividend = Make_64(u[j+n], u[j+n-1]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeline">    DEBUG_KNUTH(dbgs() << "KnuthDiv: dividend == " << dividend << '\n');</td>
    <td class="lineNumber">1365</td>
    <td class="codeline">    DEBUG_KNUTH(dbgs() << "KnuthDiv: dividend == " << dividend << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeline">    uint64_t qp = dividend / v[n-1];</td>
    <td class="lineNumber">1366</td>
    <td class="codeline">    uint64_t qp = dividend / v[n-1];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeline">    uint64_t rp = dividend % v[n-1];</td>
    <td class="lineNumber">1367</td>
    <td class="codeline">    uint64_t rp = dividend % v[n-1];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeline">    if (qp == b || qp*v[n-2] > b*rp + u[j+n-2]) {</td>
    <td class="lineNumber">1368</td>
    <td class="codeline">    if (qp == b || qp*v[n-2] > b*rp + u[j+n-2]) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeline">      qp--;</td>
    <td class="lineNumber">1369</td>
    <td class="codeline">      qp--;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeline">      rp += v[n-1];</td>
    <td class="lineNumber">1370</td>
    <td class="codeline">      rp += v[n-1];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeline">      if (rp < b && (qp == b || qp*v[n-2] > b*rp + u[j+n-2]))</td>
    <td class="lineNumber">1371</td>
    <td class="codeline">      if (rp < b && (qp == b || qp*v[n-2] > b*rp + u[j+n-2]))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeline">        qp--;</td>
    <td class="lineNumber">1372</td>
    <td class="codeline">        qp--;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1373</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeline">    DEBUG_KNUTH(dbgs() << "KnuthDiv: qp == " << qp << ", rp == " << rp << '\n');</td>
    <td class="lineNumber">1374</td>
    <td class="codeline">    DEBUG_KNUTH(dbgs() << "KnuthDiv: qp == " << qp << ", rp == " << rp << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeline"></td>
    <td class="lineNumber">1375</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeline">    // D4. [Multiply and subtract.] Replace (u[j+n]u[j+n-1]...u[j]) with</td>
    <td class="lineNumber">1376</td>
    <td class="codeline">    // D4. [Multiply and subtract.] Replace (u[j+n]u[j+n-1]...u[j]) with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeline">    // (u[j+n]u[j+n-1]..u[j]) - qp * (v[n-1]...v[1]v[0]). This computation</td>
    <td class="lineNumber">1377</td>
    <td class="codeline">    // (u[j+n]u[j+n-1]..u[j]) - qp * (v[n-1]...v[1]v[0]). This computation</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeline">    // consists of a simple multiplication by a one-place number, combined with</td>
    <td class="lineNumber">1378</td>
    <td class="codeline">    // consists of a simple multiplication by a one-place number, combined with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeline">    // a subtraction.</td>
    <td class="lineNumber">1379</td>
    <td class="codeline">    // a subtraction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeline">    // The digits (u[j+n]...u[j]) should be kept positive; if the result of</td>
    <td class="lineNumber">1380</td>
    <td class="codeline">    // The digits (u[j+n]...u[j]) should be kept positive; if the result of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeline">    // this step is actually negative, (u[j+n]...u[j]) should be left as the</td>
    <td class="lineNumber">1381</td>
    <td class="codeline">    // this step is actually negative, (u[j+n]...u[j]) should be left as the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeline">    // true value plus b**(n+1), namely as the b's complement of</td>
    <td class="lineNumber">1382</td>
    <td class="codeline">    // true value plus b**(n+1), namely as the b's complement of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeline">    // the true value, and a "borrow" to the left should be remembered.</td>
    <td class="lineNumber">1383</td>
    <td class="codeline">    // the true value, and a "borrow" to the left should be remembered.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeline">    int64_t borrow = 0;</td>
    <td class="lineNumber">1384</td>
    <td class="codeline">    int64_t borrow = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeline">    for (unsigned i = 0; i < n; ++i) {</td>
    <td class="lineNumber">1385</td>
    <td class="codeline">    for (unsigned i = 0; i < n; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeline">      uint64_t p = uint64_t(qp) * uint64_t(v[i]);</td>
    <td class="lineNumber">1386</td>
    <td class="codeline">      uint64_t p = uint64_t(qp) * uint64_t(v[i]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeline">      int64_t subres = int64_t(u[j+i]) - borrow - Lo_32(p);</td>
    <td class="lineNumber">1387</td>
    <td class="codeline">      int64_t subres = int64_t(u[j+i]) - borrow - Lo_32(p);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeline">      u[j+i] = Lo_32(subres);</td>
    <td class="lineNumber">1388</td>
    <td class="codeline">      u[j+i] = Lo_32(subres);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeline">      borrow = Hi_32(p) - Hi_32(subres);</td>
    <td class="lineNumber">1389</td>
    <td class="codeline">      borrow = Hi_32(p) - Hi_32(subres);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeline">      DEBUG_KNUTH(dbgs() << "KnuthDiv: u[j+i] = " << u[j + i]</td>
    <td class="lineNumber">1390</td>
    <td class="codeline">      DEBUG_KNUTH(dbgs() << "KnuthDiv: u[j+i] = " << u[j + i]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeline">                        << ", borrow = " << borrow << '\n');</td>
    <td class="lineNumber">1391</td>
    <td class="codeline">                        << ", borrow = " << borrow << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1392</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeline">    bool isNeg = u[j+n] < borrow;</td>
    <td class="lineNumber">1393</td>
    <td class="codeline">    bool isNeg = u[j+n] < borrow;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeline">    u[j+n] -= Lo_32(borrow);</td>
    <td class="lineNumber">1394</td>
    <td class="codeline">    u[j+n] -= Lo_32(borrow);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeline"></td>
    <td class="lineNumber">1395</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeline">    DEBUG_KNUTH(dbgs() << "KnuthDiv: after subtraction:");</td>
    <td class="lineNumber">1396</td>
    <td class="codeline">    DEBUG_KNUTH(dbgs() << "KnuthDiv: after subtraction:");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeline">    DEBUG_KNUTH(for (int i = m + n; i >= 0; i--) dbgs() << " " << u[i]);</td>
    <td class="lineNumber">1397</td>
    <td class="codeline">    DEBUG_KNUTH(for (int i = m + n; i >= 0; i--) dbgs() << " " << u[i]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeline">    DEBUG_KNUTH(dbgs() << '\n');</td>
    <td class="lineNumber">1398</td>
    <td class="codeline">    DEBUG_KNUTH(dbgs() << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeline"></td>
    <td class="lineNumber">1399</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeline">    // D5. [Test remainder.] Set q[j] = qp. If the result of step D4 was</td>
    <td class="lineNumber">1400</td>
    <td class="codeline">    // D5. [Test remainder.] Set q[j] = qp. If the result of step D4 was</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeline">    // negative, go to step D6; otherwise go on to step D7.</td>
    <td class="lineNumber">1401</td>
    <td class="codeline">    // negative, go to step D6; otherwise go on to step D7.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeline">    q[j] = Lo_32(qp);</td>
    <td class="lineNumber">1402</td>
    <td class="codeline">    q[j] = Lo_32(qp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeline">    if (isNeg) {</td>
    <td class="lineNumber">1403</td>
    <td class="codeline">    if (isNeg) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeline">      // D6. [Add back]. The probability that this step is necessary is very</td>
    <td class="lineNumber">1404</td>
    <td class="codeline">      // D6. [Add back]. The probability that this step is necessary is very</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeline">      // small, on the order of only 2/b. Make sure that test data accounts for</td>
    <td class="lineNumber">1405</td>
    <td class="codeline">      // small, on the order of only 2/b. Make sure that test data accounts for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeline">      // this possibility. Decrease q[j] by 1</td>
    <td class="lineNumber">1406</td>
    <td class="codeline">      // this possibility. Decrease q[j] by 1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeline">      q[j]--;</td>
    <td class="lineNumber">1407</td>
    <td class="codeline">      q[j]--;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeline">      // and add (0v[n-1]...v[1]v[0]) to (u[j+n]u[j+n-1]...u[j+1]u[j]).</td>
    <td class="lineNumber">1408</td>
    <td class="codeline">      // and add (0v[n-1]...v[1]v[0]) to (u[j+n]u[j+n-1]...u[j+1]u[j]).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeline">      // A carry will occur to the left of u[j+n], and it should be ignored</td>
    <td class="lineNumber">1409</td>
    <td class="codeline">      // A carry will occur to the left of u[j+n], and it should be ignored</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeline">      // since it cancels with the borrow that occurred in D4.</td>
    <td class="lineNumber">1410</td>
    <td class="codeline">      // since it cancels with the borrow that occurred in D4.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeline">      bool carry = false;</td>
    <td class="lineNumber">1411</td>
    <td class="codeline">      bool carry = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeline">      for (unsigned i = 0; i < n; i++) {</td>
    <td class="lineNumber">1412</td>
    <td class="codeline">      for (unsigned i = 0; i < n; i++) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeline">        uint32_t limit = std::min(u[j+i],v[i]);</td>
    <td class="lineNumber">1413</td>
    <td class="codeline">        uint32_t limit = std::min(u[j+i],v[i]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeline">        u[j+i] += v[i] + carry;</td>
    <td class="lineNumber">1414</td>
    <td class="codeline">        u[j+i] += v[i] + carry;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeline">        carry = u[j+i] < limit || (carry && u[j+i] == limit);</td>
    <td class="lineNumber">1415</td>
    <td class="codeline">        carry = u[j+i] < limit || (carry && u[j+i] == limit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1416</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeline">      u[j+n] += carry;</td>
    <td class="lineNumber">1417</td>
    <td class="codeline">      u[j+n] += carry;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1418</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeline">    DEBUG_KNUTH(dbgs() << "KnuthDiv: after correction:");</td>
    <td class="lineNumber">1419</td>
    <td class="codeline">    DEBUG_KNUTH(dbgs() << "KnuthDiv: after correction:");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeline">    DEBUG_KNUTH(for (int i = m + n; i >= 0; i--) dbgs() << " " << u[i]);</td>
    <td class="lineNumber">1420</td>
    <td class="codeline">    DEBUG_KNUTH(for (int i = m + n; i >= 0; i--) dbgs() << " " << u[i]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeline">    DEBUG_KNUTH(dbgs() << "\nKnuthDiv: digit result = " << q[j] << '\n');</td>
    <td class="lineNumber">1421</td>
    <td class="codeline">    DEBUG_KNUTH(dbgs() << "\nKnuthDiv: digit result = " << q[j] << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeline"></td>
    <td class="lineNumber">1422</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeline">    // D7. [Loop on j.]  Decrease j by one. Now if j >= 0, go back to D3.</td>
    <td class="lineNumber">1423</td>
    <td class="codeline">    // D7. [Loop on j.]  Decrease j by one. Now if j >= 0, go back to D3.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeline">  } while (--j >= 0);</td>
    <td class="lineNumber">1424</td>
    <td class="codeline">  } while (--j >= 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeline"></td>
    <td class="lineNumber">1425</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeline">  DEBUG_KNUTH(dbgs() << "KnuthDiv: quotient:");</td>
    <td class="lineNumber">1426</td>
    <td class="codeline">  DEBUG_KNUTH(dbgs() << "KnuthDiv: quotient:");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeline">  DEBUG_KNUTH(for (int i = m; i >= 0; i--) dbgs() << " " << q[i]);</td>
    <td class="lineNumber">1427</td>
    <td class="codeline">  DEBUG_KNUTH(for (int i = m; i >= 0; i--) dbgs() << " " << q[i]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeline">  DEBUG_KNUTH(dbgs() << '\n');</td>
    <td class="lineNumber">1428</td>
    <td class="codeline">  DEBUG_KNUTH(dbgs() << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeline"></td>
    <td class="lineNumber">1429</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeline">  // D8. [Unnormalize]. Now q[...] is the desired quotient, and the desired</td>
    <td class="lineNumber">1430</td>
    <td class="codeline">  // D8. [Unnormalize]. Now q[...] is the desired quotient, and the desired</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeline">  // remainder may be obtained by dividing u[...] by d. If r is non-null we</td>
    <td class="lineNumber">1431</td>
    <td class="codeline">  // remainder may be obtained by dividing u[...] by d. If r is non-null we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeline">  // compute the remainder (urem uses this).</td>
    <td class="lineNumber">1432</td>
    <td class="codeline">  // compute the remainder (urem uses this).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeline">  if (r) {</td>
    <td class="lineNumber">1433</td>
    <td class="codeline">  if (r) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeline">    // The value d is expressed by the "shift" value above since we avoided</td>
    <td class="lineNumber">1434</td>
    <td class="codeline">    // The value d is expressed by the "shift" value above since we avoided</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeline">    // multiplication by d by using a shift left. So, all we have to do is</td>
    <td class="lineNumber">1435</td>
    <td class="codeline">    // multiplication by d by using a shift left. So, all we have to do is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeline">    // shift right here.</td>
    <td class="lineNumber">1436</td>
    <td class="codeline">    // shift right here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeline">    if (shift) {</td>
    <td class="lineNumber">1437</td>
    <td class="codeline">    if (shift) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeline">      uint32_t carry = 0;</td>
    <td class="lineNumber">1438</td>
    <td class="codeline">      uint32_t carry = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeline">      DEBUG_KNUTH(dbgs() << "KnuthDiv: remainder:");</td>
    <td class="lineNumber">1439</td>
    <td class="codeline">      DEBUG_KNUTH(dbgs() << "KnuthDiv: remainder:");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeline">      for (int i = n-1; i >= 0; i--) {</td>
    <td class="lineNumber">1440</td>
    <td class="codeline">      for (int i = n-1; i >= 0; i--) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeline">        r[i] = (u[i] >> shift) | carry;</td>
    <td class="lineNumber">1441</td>
    <td class="codeline">        r[i] = (u[i] >> shift) | carry;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeline">        carry = u[i] << (32 - shift);</td>
    <td class="lineNumber">1442</td>
    <td class="codeline">        carry = u[i] << (32 - shift);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeline">        DEBUG_KNUTH(dbgs() << " " << r[i]);</td>
    <td class="lineNumber">1443</td>
    <td class="codeline">        DEBUG_KNUTH(dbgs() << " " << r[i]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1444</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">1445</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeline">      for (int i = n-1; i >= 0; i--) {</td>
    <td class="lineNumber">1446</td>
    <td class="codeline">      for (int i = n-1; i >= 0; i--) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeline">        r[i] = u[i];</td>
    <td class="lineNumber">1447</td>
    <td class="codeline">        r[i] = u[i];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeline">        DEBUG_KNUTH(dbgs() << " " << r[i]);</td>
    <td class="lineNumber">1448</td>
    <td class="codeline">        DEBUG_KNUTH(dbgs() << " " << r[i]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1449</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1450</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeline">    DEBUG_KNUTH(dbgs() << '\n');</td>
    <td class="lineNumber">1451</td>
    <td class="codeline">    DEBUG_KNUTH(dbgs() << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1452</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeline">  DEBUG_KNUTH(dbgs() << '\n');</td>
    <td class="lineNumber">1453</td>
    <td class="codeline">  DEBUG_KNUTH(dbgs() << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1454</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeline"></td>
    <td class="lineNumber">1455</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeline">void APInt::divide(const WordType *LHS, unsigned lhsWords, const WordType *RHS,</td>
    <td class="lineNumber">1456</td>
    <td class="codeline">void APInt::divide(const WordType *LHS, unsigned lhsWords, const WordType *RHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeline">                   unsigned rhsWords, WordType *Quotient, WordType *Remainder) {</td>
    <td class="lineNumber">1457</td>
    <td class="codeline">                   unsigned rhsWords, WordType *Quotient, WordType *Remainder) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeline">  assert(lhsWords >= rhsWords && "Fractional result");</td>
    <td class="lineNumber">1458</td>
    <td class="codeline">  assert(lhsWords >= rhsWords && "Fractional result");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeline"></td>
    <td class="lineNumber">1459</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeline">  // First, compose the values into an array of 32-bit words instead of</td>
    <td class="lineNumber">1460</td>
    <td class="codeline">  // First, compose the values into an array of 32-bit words instead of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeline">  // 64-bit words. This is a necessity of both the "short division" algorithm</td>
    <td class="lineNumber">1461</td>
    <td class="codeline">  // 64-bit words. This is a necessity of both the "short division" algorithm</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeline">  // and the Knuth "classical algorithm" which requires there to be native</td>
    <td class="lineNumber">1462</td>
    <td class="codeline">  // and the Knuth "classical algorithm" which requires there to be native</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeline">  // operations for +, -, and * on an m bit value with an m*2 bit result. We</td>
    <td class="lineNumber">1463</td>
    <td class="codeline">  // operations for +, -, and * on an m bit value with an m*2 bit result. We</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeline">  // can't use 64-bit operands here because we don't have native results of</td>
    <td class="lineNumber">1464</td>
    <td class="codeline">  // can't use 64-bit operands here because we don't have native results of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeline">  // 128-bits. Furthermore, casting the 64-bit values to 32-bit values won't</td>
    <td class="lineNumber">1465</td>
    <td class="codeline">  // 128-bits. Furthermore, casting the 64-bit values to 32-bit values won't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeline">  // work on large-endian machines.</td>
    <td class="lineNumber">1466</td>
    <td class="codeline">  // work on large-endian machines.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeline">  unsigned n = rhsWords * 2;</td>
    <td class="lineNumber">1467</td>
    <td class="codeline">  unsigned n = rhsWords * 2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeline">  unsigned m = (lhsWords * 2) - n;</td>
    <td class="lineNumber">1468</td>
    <td class="codeline">  unsigned m = (lhsWords * 2) - n;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeline"></td>
    <td class="lineNumber">1469</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeline">  // Allocate space for the temporary values we need either on the stack, if</td>
    <td class="lineNumber">1470</td>
    <td class="codeline">  // Allocate space for the temporary values we need either on the stack, if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeline">  // it will fit, or on the heap if it won't.</td>
    <td class="lineNumber">1471</td>
    <td class="codeline">  // it will fit, or on the heap if it won't.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeline">  uint32_t SPACE[128];</td>
    <td class="lineNumber">1472</td>
    <td class="codeline">  uint32_t SPACE[128];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeline">  uint32_t *U = nullptr;</td>
    <td class="lineNumber">1473</td>
    <td class="codeline">  uint32_t *U = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeline">  uint32_t *V = nullptr;</td>
    <td class="lineNumber">1474</td>
    <td class="codeline">  uint32_t *V = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeline">  uint32_t *Q = nullptr;</td>
    <td class="lineNumber">1475</td>
    <td class="codeline">  uint32_t *Q = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeline">  uint32_t *R = nullptr;</td>
    <td class="lineNumber">1476</td>
    <td class="codeline">  uint32_t *R = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeline">  if ((Remainder?4:3)*n+2*m+1 <= 128) {</td>
    <td class="lineNumber">1477</td>
    <td class="codeline">  if ((Remainder?4:3)*n+2*m+1 <= 128) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeline">    U = &SPACE[0];</td>
    <td class="lineNumber">1478</td>
    <td class="codeline">    U = &SPACE[0];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeline">    V = &SPACE[m+n+1];</td>
    <td class="lineNumber">1479</td>
    <td class="codeline">    V = &SPACE[m+n+1];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeline">    Q = &SPACE[(m+n+1) + n];</td>
    <td class="lineNumber">1480</td>
    <td class="codeline">    Q = &SPACE[(m+n+1) + n];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeline">    if (Remainder)</td>
    <td class="lineNumber">1481</td>
    <td class="codeline">    if (Remainder)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeline">      R = &SPACE[(m+n+1) + n + (m+n)];</td>
    <td class="lineNumber">1482</td>
    <td class="codeline">      R = &SPACE[(m+n+1) + n + (m+n)];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">1483</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeline">    U = new uint32_t[m + n + 1];</td>
    <td class="lineNumber">1484</td>
    <td class="codeline">    U = new uint32_t[m + n + 1];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeline">    V = new uint32_t[n];</td>
    <td class="lineNumber">1485</td>
    <td class="codeline">    V = new uint32_t[n];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeline">    Q = new uint32_t[m+n];</td>
    <td class="lineNumber">1486</td>
    <td class="codeline">    Q = new uint32_t[m+n];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeline">    if (Remainder)</td>
    <td class="lineNumber">1487</td>
    <td class="codeline">    if (Remainder)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeline">      R = new uint32_t[n];</td>
    <td class="lineNumber">1488</td>
    <td class="codeline">      R = new uint32_t[n];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1489</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeline"></td>
    <td class="lineNumber">1490</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeline">  // Initialize the dividend</td>
    <td class="lineNumber">1491</td>
    <td class="codeline">  // Initialize the dividend</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeline">  memset(U, 0, (m+n+1)*sizeof(uint32_t));</td>
    <td class="lineNumber">1492</td>
    <td class="codeline">  memset(U, 0, (m+n+1)*sizeof(uint32_t));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeline">  for (unsigned i = 0; i < lhsWords; ++i) {</td>
    <td class="lineNumber">1493</td>
    <td class="codeline">  for (unsigned i = 0; i < lhsWords; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeline">    uint64_t tmp = LHS[i];</td>
    <td class="lineNumber">1494</td>
    <td class="codeline">    uint64_t tmp = LHS[i];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeline">    U[i * 2] = Lo_32(tmp);</td>
    <td class="lineNumber">1495</td>
    <td class="codeline">    U[i * 2] = Lo_32(tmp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeline">    U[i * 2 + 1] = Hi_32(tmp);</td>
    <td class="lineNumber">1496</td>
    <td class="codeline">    U[i * 2 + 1] = Hi_32(tmp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1497</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeline">  U[m+n] = 0; // this extra word is for "spill" in the Knuth algorithm.</td>
    <td class="lineNumber">1498</td>
    <td class="codeline">  U[m+n] = 0; // this extra word is for "spill" in the Knuth algorithm.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeline"></td>
    <td class="lineNumber">1499</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeline">  // Initialize the divisor</td>
    <td class="lineNumber">1500</td>
    <td class="codeline">  // Initialize the divisor</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeline">  memset(V, 0, (n)*sizeof(uint32_t));</td>
    <td class="lineNumber">1501</td>
    <td class="codeline">  memset(V, 0, (n)*sizeof(uint32_t));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeline">  for (unsigned i = 0; i < rhsWords; ++i) {</td>
    <td class="lineNumber">1502</td>
    <td class="codeline">  for (unsigned i = 0; i < rhsWords; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeline">    uint64_t tmp = RHS[i];</td>
    <td class="lineNumber">1503</td>
    <td class="codeline">    uint64_t tmp = RHS[i];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeline">    V[i * 2] = Lo_32(tmp);</td>
    <td class="lineNumber">1504</td>
    <td class="codeline">    V[i * 2] = Lo_32(tmp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeline">    V[i * 2 + 1] = Hi_32(tmp);</td>
    <td class="lineNumber">1505</td>
    <td class="codeline">    V[i * 2 + 1] = Hi_32(tmp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1506</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeline"></td>
    <td class="lineNumber">1507</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeline">  // initialize the quotient and remainder</td>
    <td class="lineNumber">1508</td>
    <td class="codeline">  // initialize the quotient and remainder</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeline">  memset(Q, 0, (m+n) * sizeof(uint32_t));</td>
    <td class="lineNumber">1509</td>
    <td class="codeline">  memset(Q, 0, (m+n) * sizeof(uint32_t));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeline">  if (Remainder)</td>
    <td class="lineNumber">1510</td>
    <td class="codeline">  if (Remainder)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeline">    memset(R, 0, n * sizeof(uint32_t));</td>
    <td class="lineNumber">1511</td>
    <td class="codeline">    memset(R, 0, n * sizeof(uint32_t));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeline"></td>
    <td class="lineNumber">1512</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeline">  // Now, adjust m and n for the Knuth division. n is the number of words in</td>
    <td class="lineNumber">1513</td>
    <td class="codeline">  // Now, adjust m and n for the Knuth division. n is the number of words in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeline">  // the divisor. m is the number of words by which the dividend exceeds the</td>
    <td class="lineNumber">1514</td>
    <td class="codeline">  // the divisor. m is the number of words by which the dividend exceeds the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeline">  // divisor (i.e. m+n is the length of the dividend). These sizes must not</td>
    <td class="lineNumber">1515</td>
    <td class="codeline">  // divisor (i.e. m+n is the length of the dividend). These sizes must not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeline">  // contain any zero words or the Knuth algorithm fails.</td>
    <td class="lineNumber">1516</td>
    <td class="codeline">  // contain any zero words or the Knuth algorithm fails.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeline">  for (unsigned i = n; i > 0 && V[i-1] == 0; i--) {</td>
    <td class="lineNumber">1517</td>
    <td class="codeline">  for (unsigned i = n; i > 0 && V[i-1] == 0; i--) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeline">    n--;</td>
    <td class="lineNumber">1518</td>
    <td class="codeline">    n--;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeline">    m++;</td>
    <td class="lineNumber">1519</td>
    <td class="codeline">    m++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1520</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeline">  for (unsigned i = m+n; i > 0 && U[i-1] == 0; i--)</td>
    <td class="lineNumber">1521</td>
    <td class="codeline">  for (unsigned i = m+n; i > 0 && U[i-1] == 0; i--)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeline">    m--;</td>
    <td class="lineNumber">1522</td>
    <td class="codeline">    m--;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeline"></td>
    <td class="lineNumber">1523</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeline">  // If we're left with only a single word for the divisor, Knuth doesn't work</td>
    <td class="lineNumber">1524</td>
    <td class="codeline">  // If we're left with only a single word for the divisor, Knuth doesn't work</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeline">  // so we implement the short division algorithm here. This is much simpler</td>
    <td class="lineNumber">1525</td>
    <td class="codeline">  // so we implement the short division algorithm here. This is much simpler</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeline">  // and faster because we are certain that we can divide a 64-bit quantity</td>
    <td class="lineNumber">1526</td>
    <td class="codeline">  // and faster because we are certain that we can divide a 64-bit quantity</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeline">  // by a 32-bit quantity at hardware speed and short division is simply a</td>
    <td class="lineNumber">1527</td>
    <td class="codeline">  // by a 32-bit quantity at hardware speed and short division is simply a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeline">  // series of such operations. This is just like doing short division but we</td>
    <td class="lineNumber">1528</td>
    <td class="codeline">  // series of such operations. This is just like doing short division but we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeline">  // are using base 2^32 instead of base 10.</td>
    <td class="lineNumber">1529</td>
    <td class="codeline">  // are using base 2^32 instead of base 10.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeline">  assert(n != 0 && "Divide by zero?");</td>
    <td class="lineNumber">1530</td>
    <td class="codeline">  assert(n != 0 && "Divide by zero?");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeline">  if (n == 1) {</td>
    <td class="lineNumber">1531</td>
    <td class="codeline">  if (n == 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeline">    uint32_t divisor = V[0];</td>
    <td class="lineNumber">1532</td>
    <td class="codeline">    uint32_t divisor = V[0];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeline">    uint32_t remainder = 0;</td>
    <td class="lineNumber">1533</td>
    <td class="codeline">    uint32_t remainder = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeline">    for (int i = m; i >= 0; i--) {</td>
    <td class="lineNumber">1534</td>
    <td class="codeline">    for (int i = m; i >= 0; i--) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeline">      uint64_t partial_dividend = Make_64(remainder, U[i]);</td>
    <td class="lineNumber">1535</td>
    <td class="codeline">      uint64_t partial_dividend = Make_64(remainder, U[i]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeline">      if (partial_dividend == 0) {</td>
    <td class="lineNumber">1536</td>
    <td class="codeline">      if (partial_dividend == 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeline">        Q[i] = 0;</td>
    <td class="lineNumber">1537</td>
    <td class="codeline">        Q[i] = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeline">        remainder = 0;</td>
    <td class="lineNumber">1538</td>
    <td class="codeline">        remainder = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeline">      } else if (partial_dividend < divisor) {</td>
    <td class="lineNumber">1539</td>
    <td class="codeline">      } else if (partial_dividend < divisor) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeline">        Q[i] = 0;</td>
    <td class="lineNumber">1540</td>
    <td class="codeline">        Q[i] = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeline">        remainder = Lo_32(partial_dividend);</td>
    <td class="lineNumber">1541</td>
    <td class="codeline">        remainder = Lo_32(partial_dividend);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeline">      } else if (partial_dividend == divisor) {</td>
    <td class="lineNumber">1542</td>
    <td class="codeline">      } else if (partial_dividend == divisor) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeline">        Q[i] = 1;</td>
    <td class="lineNumber">1543</td>
    <td class="codeline">        Q[i] = 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeline">        remainder = 0;</td>
    <td class="lineNumber">1544</td>
    <td class="codeline">        remainder = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">1545</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeline">        Q[i] = Lo_32(partial_dividend / divisor);</td>
    <td class="lineNumber">1546</td>
    <td class="codeline">        Q[i] = Lo_32(partial_dividend / divisor);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeline">        remainder = Lo_32(partial_dividend - (Q[i] * divisor));</td>
    <td class="lineNumber">1547</td>
    <td class="codeline">        remainder = Lo_32(partial_dividend - (Q[i] * divisor));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1548</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1549</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeline">    if (R)</td>
    <td class="lineNumber">1550</td>
    <td class="codeline">    if (R)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeline">      R[0] = remainder;</td>
    <td class="lineNumber">1551</td>
    <td class="codeline">      R[0] = remainder;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">1552</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeline">    // Now we're ready to invoke the Knuth classical divide algorithm. In this</td>
    <td class="lineNumber">1553</td>
    <td class="codeline">    // Now we're ready to invoke the Knuth classical divide algorithm. In this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeline">    // case n > 1.</td>
    <td class="lineNumber">1554</td>
    <td class="codeline">    // case n > 1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeline">    KnuthDiv(U, V, Q, R, m, n);</td>
    <td class="lineNumber">1555</td>
    <td class="codeline">    KnuthDiv(U, V, Q, R, m, n);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1556</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeline"></td>
    <td class="lineNumber">1557</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeline">  // If the caller wants the quotient</td>
    <td class="lineNumber">1558</td>
    <td class="codeline">  // If the caller wants the quotient</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeline">  if (Quotient) {</td>
    <td class="lineNumber">1559</td>
    <td class="codeline">  if (Quotient) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeline">    for (unsigned i = 0; i < lhsWords; ++i)</td>
    <td class="lineNumber">1560</td>
    <td class="codeline">    for (unsigned i = 0; i < lhsWords; ++i)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeline">      Quotient[i] = Make_64(Q[i*2+1], Q[i*2]);</td>
    <td class="lineNumber">1561</td>
    <td class="codeline">      Quotient[i] = Make_64(Q[i*2+1], Q[i*2]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1562</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeline"></td>
    <td class="lineNumber">1563</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeline">  // If the caller wants the remainder</td>
    <td class="lineNumber">1564</td>
    <td class="codeline">  // If the caller wants the remainder</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeline">  if (Remainder) {</td>
    <td class="lineNumber">1565</td>
    <td class="codeline">  if (Remainder) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeline">    for (unsigned i = 0; i < rhsWords; ++i)</td>
    <td class="lineNumber">1566</td>
    <td class="codeline">    for (unsigned i = 0; i < rhsWords; ++i)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeline">      Remainder[i] = Make_64(R[i*2+1], R[i*2]);</td>
    <td class="lineNumber">1567</td>
    <td class="codeline">      Remainder[i] = Make_64(R[i*2+1], R[i*2]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1568</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeline"></td>
    <td class="lineNumber">1569</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeline">  // Clean up the memory we allocated.</td>
    <td class="lineNumber">1570</td>
    <td class="codeline">  // Clean up the memory we allocated.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeline">  if (U != &SPACE[0]) {</td>
    <td class="lineNumber">1571</td>
    <td class="codeline">  if (U != &SPACE[0]) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeline">    delete [] U;</td>
    <td class="lineNumber">1572</td>
    <td class="codeline">    delete [] U;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeline">    delete [] V;</td>
    <td class="lineNumber">1573</td>
    <td class="codeline">    delete [] V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeline">    delete [] Q;</td>
    <td class="lineNumber">1574</td>
    <td class="codeline">    delete [] Q;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeline">    delete [] R;</td>
    <td class="lineNumber">1575</td>
    <td class="codeline">    delete [] R;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1576</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1577</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeline"></td>
    <td class="lineNumber">1578</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeline">APInt APInt::udiv(const APInt &RHS) const {</td>
    <td class="lineNumber">1579</td>
    <td class="codeline">APInt APInt::udiv(const APInt &RHS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeline">  assert(BitWidth == RHS.BitWidth && "Bit widths must be the same");</td>
    <td class="lineNumber">1580</td>
    <td class="codeline">  assert(BitWidth == RHS.BitWidth && "Bit widths must be the same");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeline"></td>
    <td class="lineNumber">1581</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeline">  // First, deal with the easy case</td>
    <td class="lineNumber">1582</td>
    <td class="codeline">  // First, deal with the easy case</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeline">  if (isSingleWord()) {</td>
    <td class="lineNumber">1583</td>
    <td class="codeline">  if (isSingleWord()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeline">    assert(RHS.U.VAL != 0 && "Divide by zero?");</td>
    <td class="lineNumber">1584</td>
    <td class="codeline">    assert(RHS.U.VAL != 0 && "Divide by zero?");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeline">    return APInt(BitWidth, U.VAL / RHS.U.VAL);</td>
    <td class="lineNumber">1585</td>
    <td class="codeline">    return APInt(BitWidth, U.VAL / RHS.U.VAL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1586</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeline"></td>
    <td class="lineNumber">1587</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeline">  // Get some facts about the LHS and RHS number of bits and words</td>
    <td class="lineNumber">1588</td>
    <td class="codeline">  // Get some facts about the LHS and RHS number of bits and words</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeline">  unsigned lhsWords = getNumWords(getActiveBits());</td>
    <td class="lineNumber">1589</td>
    <td class="codeline">  unsigned lhsWords = getNumWords(getActiveBits());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeline">  unsigned rhsBits  = RHS.getActiveBits();</td>
    <td class="lineNumber">1590</td>
    <td class="codeline">  unsigned rhsBits  = RHS.getActiveBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeline">  unsigned rhsWords = getNumWords(rhsBits);</td>
    <td class="lineNumber">1591</td>
    <td class="codeline">  unsigned rhsWords = getNumWords(rhsBits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeline">  assert(rhsWords && "Divided by zero???");</td>
    <td class="lineNumber">1592</td>
    <td class="codeline">  assert(rhsWords && "Divided by zero???");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeline"></td>
    <td class="lineNumber">1593</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeline">  // Deal with some degenerate cases</td>
    <td class="lineNumber">1594</td>
    <td class="codeline">  // Deal with some degenerate cases</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeline">  if (!lhsWords)</td>
    <td class="lineNumber">1595</td>
    <td class="codeline">  if (!lhsWords)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeline">    // 0 / X ===> 0</td>
    <td class="lineNumber">1596</td>
    <td class="codeline">    // 0 / X ===> 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeline">    return APInt(BitWidth, 0);</td>
    <td class="lineNumber">1597</td>
    <td class="codeline">    return APInt(BitWidth, 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeline">  if (rhsBits == 1)</td>
    <td class="lineNumber">1598</td>
    <td class="codeline">  if (rhsBits == 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeline">    // X / 1 ===> X</td>
    <td class="lineNumber">1599</td>
    <td class="codeline">    // X / 1 ===> X</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeline">    return *this;</td>
    <td class="lineNumber">1600</td>
    <td class="codeline">    return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeline">  if (lhsWords < rhsWords || this->ult(RHS))</td>
    <td class="lineNumber">1601</td>
    <td class="codeline">  if (lhsWords < rhsWords || this->ult(RHS))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeline">    // X / Y ===> 0, iff X < Y</td>
    <td class="lineNumber">1602</td>
    <td class="codeline">    // X / Y ===> 0, iff X < Y</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeline">    return APInt(BitWidth, 0);</td>
    <td class="lineNumber">1603</td>
    <td class="codeline">    return APInt(BitWidth, 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeline">  if (*this == RHS)</td>
    <td class="lineNumber">1604</td>
    <td class="codeline">  if (*this == RHS)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeline">    // X / X ===> 1</td>
    <td class="lineNumber">1605</td>
    <td class="codeline">    // X / X ===> 1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeline">    return APInt(BitWidth, 1);</td>
    <td class="lineNumber">1606</td>
    <td class="codeline">    return APInt(BitWidth, 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeline">  if (lhsWords == 1) // rhsWords is 1 if lhsWords is 1.</td>
    <td class="lineNumber">1607</td>
    <td class="codeline">  if (lhsWords == 1) // rhsWords is 1 if lhsWords is 1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeline">    // All high words are zero, just use native divide</td>
    <td class="lineNumber">1608</td>
    <td class="codeline">    // All high words are zero, just use native divide</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeline">    return APInt(BitWidth, this->U.pVal[0] / RHS.U.pVal[0]);</td>
    <td class="lineNumber">1609</td>
    <td class="codeline">    return APInt(BitWidth, this->U.pVal[0] / RHS.U.pVal[0]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeline"></td>
    <td class="lineNumber">1610</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeline">  // We have to compute it the hard way. Invoke the Knuth divide algorithm.</td>
    <td class="lineNumber">1611</td>
    <td class="codeline">  // We have to compute it the hard way. Invoke the Knuth divide algorithm.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeline">  APInt Quotient(BitWidth, 0); // to hold result.</td>
    <td class="lineNumber">1612</td>
    <td class="codeline">  APInt Quotient(BitWidth, 0); // to hold result.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeline">  divide(U.pVal, lhsWords, RHS.U.pVal, rhsWords, Quotient.U.pVal, nullptr);</td>
    <td class="lineNumber">1613</td>
    <td class="codeline">  divide(U.pVal, lhsWords, RHS.U.pVal, rhsWords, Quotient.U.pVal, nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeline">  return Quotient;</td>
    <td class="lineNumber">1614</td>
    <td class="codeline">  return Quotient;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1615</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeline"></td>
    <td class="lineNumber">1616</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeline">APInt APInt::udiv(uint64_t RHS) const {</td>
    <td class="lineNumber">1617</td>
    <td class="codeline">APInt APInt::udiv(uint64_t RHS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeline">  assert(RHS != 0 && "Divide by zero?");</td>
    <td class="lineNumber">1618</td>
    <td class="codeline">  assert(RHS != 0 && "Divide by zero?");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeline"></td>
    <td class="lineNumber">1619</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeline">  // First, deal with the easy case</td>
    <td class="lineNumber">1620</td>
    <td class="codeline">  // First, deal with the easy case</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeline">  if (isSingleWord())</td>
    <td class="lineNumber">1621</td>
    <td class="codeline">  if (isSingleWord())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeline">    return APInt(BitWidth, U.VAL / RHS);</td>
    <td class="lineNumber">1622</td>
    <td class="codeline">    return APInt(BitWidth, U.VAL / RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeline"></td>
    <td class="lineNumber">1623</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeline">  // Get some facts about the LHS words.</td>
    <td class="lineNumber">1624</td>
    <td class="codeline">  // Get some facts about the LHS words.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeline">  unsigned lhsWords = getNumWords(getActiveBits());</td>
    <td class="lineNumber">1625</td>
    <td class="codeline">  unsigned lhsWords = getNumWords(getActiveBits());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeline"></td>
    <td class="lineNumber">1626</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeline">  // Deal with some degenerate cases</td>
    <td class="lineNumber">1627</td>
    <td class="codeline">  // Deal with some degenerate cases</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeline">  if (!lhsWords)</td>
    <td class="lineNumber">1628</td>
    <td class="codeline">  if (!lhsWords)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeline">    // 0 / X ===> 0</td>
    <td class="lineNumber">1629</td>
    <td class="codeline">    // 0 / X ===> 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeline">    return APInt(BitWidth, 0);</td>
    <td class="lineNumber">1630</td>
    <td class="codeline">    return APInt(BitWidth, 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeline">  if (RHS == 1)</td>
    <td class="lineNumber">1631</td>
    <td class="codeline">  if (RHS == 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeline">    // X / 1 ===> X</td>
    <td class="lineNumber">1632</td>
    <td class="codeline">    // X / 1 ===> X</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeline">    return *this;</td>
    <td class="lineNumber">1633</td>
    <td class="codeline">    return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeline">  if (this->ult(RHS))</td>
    <td class="lineNumber">1634</td>
    <td class="codeline">  if (this->ult(RHS))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeline">    // X / Y ===> 0, iff X < Y</td>
    <td class="lineNumber">1635</td>
    <td class="codeline">    // X / Y ===> 0, iff X < Y</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeline">    return APInt(BitWidth, 0);</td>
    <td class="lineNumber">1636</td>
    <td class="codeline">    return APInt(BitWidth, 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeline">  if (*this == RHS)</td>
    <td class="lineNumber">1637</td>
    <td class="codeline">  if (*this == RHS)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeline">    // X / X ===> 1</td>
    <td class="lineNumber">1638</td>
    <td class="codeline">    // X / X ===> 1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeline">    return APInt(BitWidth, 1);</td>
    <td class="lineNumber">1639</td>
    <td class="codeline">    return APInt(BitWidth, 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeline">  if (lhsWords == 1) // rhsWords is 1 if lhsWords is 1.</td>
    <td class="lineNumber">1640</td>
    <td class="codeline">  if (lhsWords == 1) // rhsWords is 1 if lhsWords is 1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeline">    // All high words are zero, just use native divide</td>
    <td class="lineNumber">1641</td>
    <td class="codeline">    // All high words are zero, just use native divide</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeline">    return APInt(BitWidth, this->U.pVal[0] / RHS);</td>
    <td class="lineNumber">1642</td>
    <td class="codeline">    return APInt(BitWidth, this->U.pVal[0] / RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeline"></td>
    <td class="lineNumber">1643</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeline">  // We have to compute it the hard way. Invoke the Knuth divide algorithm.</td>
    <td class="lineNumber">1644</td>
    <td class="codeline">  // We have to compute it the hard way. Invoke the Knuth divide algorithm.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeline">  APInt Quotient(BitWidth, 0); // to hold result.</td>
    <td class="lineNumber">1645</td>
    <td class="codeline">  APInt Quotient(BitWidth, 0); // to hold result.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeline">  divide(U.pVal, lhsWords, &RHS, 1, Quotient.U.pVal, nullptr);</td>
    <td class="lineNumber">1646</td>
    <td class="codeline">  divide(U.pVal, lhsWords, &RHS, 1, Quotient.U.pVal, nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeline">  return Quotient;</td>
    <td class="lineNumber">1647</td>
    <td class="codeline">  return Quotient;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1648</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeline"></td>
    <td class="lineNumber">1649</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeline">APInt APInt::sdiv(const APInt &RHS) const {</td>
    <td class="lineNumber">1650</td>
    <td class="codeline">APInt APInt::sdiv(const APInt &RHS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeline">  if (isNegative()) {</td>
    <td class="lineNumber">1651</td>
    <td class="codeline">  if (isNegative()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeline">    if (RHS.isNegative())</td>
    <td class="lineNumber">1652</td>
    <td class="codeline">    if (RHS.isNegative())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeline">      return (-(*this)).udiv(-RHS);</td>
    <td class="lineNumber">1653</td>
    <td class="codeline">      return (-(*this)).udiv(-RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeline">    return -((-(*this)).udiv(RHS));</td>
    <td class="lineNumber">1654</td>
    <td class="codeline">    return -((-(*this)).udiv(RHS));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1655</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeline">  if (RHS.isNegative())</td>
    <td class="lineNumber">1656</td>
    <td class="codeline">  if (RHS.isNegative())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeline">    return -(this->udiv(-RHS));</td>
    <td class="lineNumber">1657</td>
    <td class="codeline">    return -(this->udiv(-RHS));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeline">  return this->udiv(RHS);</td>
    <td class="lineNumber">1658</td>
    <td class="codeline">  return this->udiv(RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1659</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeline"></td>
    <td class="lineNumber">1660</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeline">APInt APInt::sdiv(int64_t RHS) const {</td>
    <td class="lineNumber">1661</td>
    <td class="codeline">APInt APInt::sdiv(int64_t RHS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeline">  if (isNegative()) {</td>
    <td class="lineNumber">1662</td>
    <td class="codeline">  if (isNegative()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeline">    if (RHS < 0)</td>
    <td class="lineNumber">1663</td>
    <td class="codeline">    if (RHS < 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeline">      return (-(*this)).udiv(-RHS);</td>
    <td class="lineNumber">1664</td>
    <td class="codeline">      return (-(*this)).udiv(-RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeline">    return -((-(*this)).udiv(RHS));</td>
    <td class="lineNumber">1665</td>
    <td class="codeline">    return -((-(*this)).udiv(RHS));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1666</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeline">  if (RHS < 0)</td>
    <td class="lineNumber">1667</td>
    <td class="codeline">  if (RHS < 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeline">    return -(this->udiv(-RHS));</td>
    <td class="lineNumber">1668</td>
    <td class="codeline">    return -(this->udiv(-RHS));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeline">  return this->udiv(RHS);</td>
    <td class="lineNumber">1669</td>
    <td class="codeline">  return this->udiv(RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1670</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeline"></td>
    <td class="lineNumber">1671</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeline">APInt APInt::urem(const APInt &RHS) const {</td>
    <td class="lineNumber">1672</td>
    <td class="codeline">APInt APInt::urem(const APInt &RHS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeline">  assert(BitWidth == RHS.BitWidth && "Bit widths must be the same");</td>
    <td class="lineNumber">1673</td>
    <td class="codeline">  assert(BitWidth == RHS.BitWidth && "Bit widths must be the same");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeline">  if (isSingleWord()) {</td>
    <td class="lineNumber">1674</td>
    <td class="codeline">  if (isSingleWord()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeline">    assert(RHS.U.VAL != 0 && "Remainder by zero?");</td>
    <td class="lineNumber">1675</td>
    <td class="codeline">    assert(RHS.U.VAL != 0 && "Remainder by zero?");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeline">    return APInt(BitWidth, U.VAL % RHS.U.VAL);</td>
    <td class="lineNumber">1676</td>
    <td class="codeline">    return APInt(BitWidth, U.VAL % RHS.U.VAL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1677</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeline"></td>
    <td class="lineNumber">1678</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeline">  // Get some facts about the LHS</td>
    <td class="lineNumber">1679</td>
    <td class="codeline">  // Get some facts about the LHS</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeline">  unsigned lhsWords = getNumWords(getActiveBits());</td>
    <td class="lineNumber">1680</td>
    <td class="codeline">  unsigned lhsWords = getNumWords(getActiveBits());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeline"></td>
    <td class="lineNumber">1681</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeline">  // Get some facts about the RHS</td>
    <td class="lineNumber">1682</td>
    <td class="codeline">  // Get some facts about the RHS</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeline">  unsigned rhsBits = RHS.getActiveBits();</td>
    <td class="lineNumber">1683</td>
    <td class="codeline">  unsigned rhsBits = RHS.getActiveBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeline">  unsigned rhsWords = getNumWords(rhsBits);</td>
    <td class="lineNumber">1684</td>
    <td class="codeline">  unsigned rhsWords = getNumWords(rhsBits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeline">  assert(rhsWords && "Performing remainder operation by zero ???");</td>
    <td class="lineNumber">1685</td>
    <td class="codeline">  assert(rhsWords && "Performing remainder operation by zero ???");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeline"></td>
    <td class="lineNumber">1686</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeline">  // Check the degenerate cases</td>
    <td class="lineNumber">1687</td>
    <td class="codeline">  // Check the degenerate cases</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeline">  if (lhsWords == 0)</td>
    <td class="lineNumber">1688</td>
    <td class="codeline">  if (lhsWords == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeline">    // 0 % Y ===> 0</td>
    <td class="lineNumber">1689</td>
    <td class="codeline">    // 0 % Y ===> 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeline">    return APInt(BitWidth, 0);</td>
    <td class="lineNumber">1690</td>
    <td class="codeline">    return APInt(BitWidth, 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeline">  if (rhsBits == 1)</td>
    <td class="lineNumber">1691</td>
    <td class="codeline">  if (rhsBits == 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeline">    // X % 1 ===> 0</td>
    <td class="lineNumber">1692</td>
    <td class="codeline">    // X % 1 ===> 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeline">    return APInt(BitWidth, 0);</td>
    <td class="lineNumber">1693</td>
    <td class="codeline">    return APInt(BitWidth, 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeline">  if (lhsWords < rhsWords || this->ult(RHS))</td>
    <td class="lineNumber">1694</td>
    <td class="codeline">  if (lhsWords < rhsWords || this->ult(RHS))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeline">    // X % Y ===> X, iff X < Y</td>
    <td class="lineNumber">1695</td>
    <td class="codeline">    // X % Y ===> X, iff X < Y</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeline">    return *this;</td>
    <td class="lineNumber">1696</td>
    <td class="codeline">    return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeline">  if (*this == RHS)</td>
    <td class="lineNumber">1697</td>
    <td class="codeline">  if (*this == RHS)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeline">    // X % X == 0;</td>
    <td class="lineNumber">1698</td>
    <td class="codeline">    // X % X == 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeline">    return APInt(BitWidth, 0);</td>
    <td class="lineNumber">1699</td>
    <td class="codeline">    return APInt(BitWidth, 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeline">  if (lhsWords == 1)</td>
    <td class="lineNumber">1700</td>
    <td class="codeline">  if (lhsWords == 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeline">    // All high words are zero, just use native remainder</td>
    <td class="lineNumber">1701</td>
    <td class="codeline">    // All high words are zero, just use native remainder</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeline">    return APInt(BitWidth, U.pVal[0] % RHS.U.pVal[0]);</td>
    <td class="lineNumber">1702</td>
    <td class="codeline">    return APInt(BitWidth, U.pVal[0] % RHS.U.pVal[0]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeline"></td>
    <td class="lineNumber">1703</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeline">  // We have to compute it the hard way. Invoke the Knuth divide algorithm.</td>
    <td class="lineNumber">1704</td>
    <td class="codeline">  // We have to compute it the hard way. Invoke the Knuth divide algorithm.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeline">  APInt Remainder(BitWidth, 0);</td>
    <td class="lineNumber">1705</td>
    <td class="codeline">  APInt Remainder(BitWidth, 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeline">  divide(U.pVal, lhsWords, RHS.U.pVal, rhsWords, nullptr, Remainder.U.pVal);</td>
    <td class="lineNumber">1706</td>
    <td class="codeline">  divide(U.pVal, lhsWords, RHS.U.pVal, rhsWords, nullptr, Remainder.U.pVal);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeline">  return Remainder;</td>
    <td class="lineNumber">1707</td>
    <td class="codeline">  return Remainder;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1708</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeline"></td>
    <td class="lineNumber">1709</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeline">uint64_t APInt::urem(uint64_t RHS) const {</td>
    <td class="lineNumber">1710</td>
    <td class="codeline">uint64_t APInt::urem(uint64_t RHS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeline">  assert(RHS != 0 && "Remainder by zero?");</td>
    <td class="lineNumber">1711</td>
    <td class="codeline">  assert(RHS != 0 && "Remainder by zero?");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeline"></td>
    <td class="lineNumber">1712</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeline">  if (isSingleWord())</td>
    <td class="lineNumber">1713</td>
    <td class="codeline">  if (isSingleWord())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeline">    return U.VAL % RHS;</td>
    <td class="lineNumber">1714</td>
    <td class="codeline">    return U.VAL % RHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeline"></td>
    <td class="lineNumber">1715</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeline">  // Get some facts about the LHS</td>
    <td class="lineNumber">1716</td>
    <td class="codeline">  // Get some facts about the LHS</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeline">  unsigned lhsWords = getNumWords(getActiveBits());</td>
    <td class="lineNumber">1717</td>
    <td class="codeline">  unsigned lhsWords = getNumWords(getActiveBits());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeline"></td>
    <td class="lineNumber">1718</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeline">  // Check the degenerate cases</td>
    <td class="lineNumber">1719</td>
    <td class="codeline">  // Check the degenerate cases</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeline">  if (lhsWords == 0)</td>
    <td class="lineNumber">1720</td>
    <td class="codeline">  if (lhsWords == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeline">    // 0 % Y ===> 0</td>
    <td class="lineNumber">1721</td>
    <td class="codeline">    // 0 % Y ===> 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeline">    return 0;</td>
    <td class="lineNumber">1722</td>
    <td class="codeline">    return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeline">  if (RHS == 1)</td>
    <td class="lineNumber">1723</td>
    <td class="codeline">  if (RHS == 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeline">    // X % 1 ===> 0</td>
    <td class="lineNumber">1724</td>
    <td class="codeline">    // X % 1 ===> 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeline">    return 0;</td>
    <td class="lineNumber">1725</td>
    <td class="codeline">    return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeline">  if (this->ult(RHS))</td>
    <td class="lineNumber">1726</td>
    <td class="codeline">  if (this->ult(RHS))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeline">    // X % Y ===> X, iff X < Y</td>
    <td class="lineNumber">1727</td>
    <td class="codeline">    // X % Y ===> X, iff X < Y</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeline">    return getZExtValue();</td>
    <td class="lineNumber">1728</td>
    <td class="codeline">    return getZExtValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeline">  if (*this == RHS)</td>
    <td class="lineNumber">1729</td>
    <td class="codeline">  if (*this == RHS)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeline">    // X % X == 0;</td>
    <td class="lineNumber">1730</td>
    <td class="codeline">    // X % X == 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeline">    return 0;</td>
    <td class="lineNumber">1731</td>
    <td class="codeline">    return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeline">  if (lhsWords == 1)</td>
    <td class="lineNumber">1732</td>
    <td class="codeline">  if (lhsWords == 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeline">    // All high words are zero, just use native remainder</td>
    <td class="lineNumber">1733</td>
    <td class="codeline">    // All high words are zero, just use native remainder</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeline">    return U.pVal[0] % RHS;</td>
    <td class="lineNumber">1734</td>
    <td class="codeline">    return U.pVal[0] % RHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeline"></td>
    <td class="lineNumber">1735</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeline">  // We have to compute it the hard way. Invoke the Knuth divide algorithm.</td>
    <td class="lineNumber">1736</td>
    <td class="codeline">  // We have to compute it the hard way. Invoke the Knuth divide algorithm.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeline">  uint64_t Remainder;</td>
    <td class="lineNumber">1737</td>
    <td class="codeline">  uint64_t Remainder;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeline">  divide(U.pVal, lhsWords, &RHS, 1, nullptr, &Remainder);</td>
    <td class="lineNumber">1738</td>
    <td class="codeline">  divide(U.pVal, lhsWords, &RHS, 1, nullptr, &Remainder);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeline">  return Remainder;</td>
    <td class="lineNumber">1739</td>
    <td class="codeline">  return Remainder;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1740</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeline"></td>
    <td class="lineNumber">1741</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeline">APInt APInt::srem(const APInt &RHS) const {</td>
    <td class="lineNumber">1742</td>
    <td class="codeline">APInt APInt::srem(const APInt &RHS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeline">  if (isNegative()) {</td>
    <td class="lineNumber">1743</td>
    <td class="codeline">  if (isNegative()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeline">    if (RHS.isNegative())</td>
    <td class="lineNumber">1744</td>
    <td class="codeline">    if (RHS.isNegative())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeline">      return -((-(*this)).urem(-RHS));</td>
    <td class="lineNumber">1745</td>
    <td class="codeline">      return -((-(*this)).urem(-RHS));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeline">    return -((-(*this)).urem(RHS));</td>
    <td class="lineNumber">1746</td>
    <td class="codeline">    return -((-(*this)).urem(RHS));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1747</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeline">  if (RHS.isNegative())</td>
    <td class="lineNumber">1748</td>
    <td class="codeline">  if (RHS.isNegative())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeline">    return this->urem(-RHS);</td>
    <td class="lineNumber">1749</td>
    <td class="codeline">    return this->urem(-RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeline">  return this->urem(RHS);</td>
    <td class="lineNumber">1750</td>
    <td class="codeline">  return this->urem(RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1751</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeline"></td>
    <td class="lineNumber">1752</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeline">int64_t APInt::srem(int64_t RHS) const {</td>
    <td class="lineNumber">1753</td>
    <td class="codeline">int64_t APInt::srem(int64_t RHS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeline">  if (isNegative()) {</td>
    <td class="lineNumber">1754</td>
    <td class="codeline">  if (isNegative()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeline">    if (RHS < 0)</td>
    <td class="lineNumber">1755</td>
    <td class="codeline">    if (RHS < 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeline">      return -((-(*this)).urem(-RHS));</td>
    <td class="lineNumber">1756</td>
    <td class="codeline">      return -((-(*this)).urem(-RHS));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeline">    return -((-(*this)).urem(RHS));</td>
    <td class="lineNumber">1757</td>
    <td class="codeline">    return -((-(*this)).urem(RHS));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1758</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeline">  if (RHS < 0)</td>
    <td class="lineNumber">1759</td>
    <td class="codeline">  if (RHS < 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeline">    return this->urem(-RHS);</td>
    <td class="lineNumber">1760</td>
    <td class="codeline">    return this->urem(-RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeline">  return this->urem(RHS);</td>
    <td class="lineNumber">1761</td>
    <td class="codeline">  return this->urem(RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1762</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeline"></td>
    <td class="lineNumber">1763</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeline">void APInt::udivrem(const APInt &LHS, const APInt &RHS,</td>
    <td class="lineNumber">1764</td>
    <td class="codeline">void APInt::udivrem(const APInt &LHS, const APInt &RHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeline">                    APInt &Quotient, APInt &Remainder) {</td>
    <td class="lineNumber">1765</td>
    <td class="codeline">                    APInt &Quotient, APInt &Remainder) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeline">  assert(LHS.BitWidth == RHS.BitWidth && "Bit widths must be the same");</td>
    <td class="lineNumber">1766</td>
    <td class="codeline">  assert(LHS.BitWidth == RHS.BitWidth && "Bit widths must be the same");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeline">  unsigned BitWidth = LHS.BitWidth;</td>
    <td class="lineNumber">1767</td>
    <td class="codeline">  unsigned BitWidth = LHS.BitWidth;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeline"></td>
    <td class="lineNumber">1768</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeline">  // First, deal with the easy case</td>
    <td class="lineNumber">1769</td>
    <td class="codeline">  // First, deal with the easy case</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeline">  if (LHS.isSingleWord()) {</td>
    <td class="lineNumber">1770</td>
    <td class="codeline">  if (LHS.isSingleWord()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeline">    assert(RHS.U.VAL != 0 && "Divide by zero?");</td>
    <td class="lineNumber">1771</td>
    <td class="codeline">    assert(RHS.U.VAL != 0 && "Divide by zero?");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeline">    uint64_t QuotVal = LHS.U.VAL / RHS.U.VAL;</td>
    <td class="lineNumber">1772</td>
    <td class="codeline">    uint64_t QuotVal = LHS.U.VAL / RHS.U.VAL;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeline">    uint64_t RemVal = LHS.U.VAL % RHS.U.VAL;</td>
    <td class="lineNumber">1773</td>
    <td class="codeline">    uint64_t RemVal = LHS.U.VAL % RHS.U.VAL;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeline">    Quotient = APInt(BitWidth, QuotVal);</td>
    <td class="lineNumber">1774</td>
    <td class="codeline">    Quotient = APInt(BitWidth, QuotVal);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeline">    Remainder = APInt(BitWidth, RemVal);</td>
    <td class="lineNumber">1775</td>
    <td class="codeline">    Remainder = APInt(BitWidth, RemVal);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">1776</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1777</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeline"></td>
    <td class="lineNumber">1778</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeline">  // Get some size facts about the dividend and divisor</td>
    <td class="lineNumber">1779</td>
    <td class="codeline">  // Get some size facts about the dividend and divisor</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeline">  unsigned lhsWords = getNumWords(LHS.getActiveBits());</td>
    <td class="lineNumber">1780</td>
    <td class="codeline">  unsigned lhsWords = getNumWords(LHS.getActiveBits());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeline">  unsigned rhsBits  = RHS.getActiveBits();</td>
    <td class="lineNumber">1781</td>
    <td class="codeline">  unsigned rhsBits  = RHS.getActiveBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeline">  unsigned rhsWords = getNumWords(rhsBits);</td>
    <td class="lineNumber">1782</td>
    <td class="codeline">  unsigned rhsWords = getNumWords(rhsBits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeline">  assert(rhsWords && "Performing divrem operation by zero ???");</td>
    <td class="lineNumber">1783</td>
    <td class="codeline">  assert(rhsWords && "Performing divrem operation by zero ???");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeline"></td>
    <td class="lineNumber">1784</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeline">  // Check the degenerate cases</td>
    <td class="lineNumber">1785</td>
    <td class="codeline">  // Check the degenerate cases</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeline">  if (lhsWords == 0) {</td>
    <td class="lineNumber">1786</td>
    <td class="codeline">  if (lhsWords == 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeline">    Quotient = APInt(BitWidth, 0);    // 0 / Y ===> 0</td>
    <td class="lineNumber">1787</td>
    <td class="codeline">    Quotient = APInt(BitWidth, 0);    // 0 / Y ===> 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeline">    Remainder = APInt(BitWidth, 0);   // 0 % Y ===> 0</td>
    <td class="lineNumber">1788</td>
    <td class="codeline">    Remainder = APInt(BitWidth, 0);   // 0 % Y ===> 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">1789</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1790</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeline"></td>
    <td class="lineNumber">1791</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeline">  if (rhsBits == 1) {</td>
    <td class="lineNumber">1792</td>
    <td class="codeline">  if (rhsBits == 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="codeline">    Quotient = LHS;                   // X / 1 ===> X</td>
    <td class="lineNumber">1793</td>
    <td class="codeline">    Quotient = LHS;                   // X / 1 ===> X</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="codeline">    Remainder = APInt(BitWidth, 0);   // X % 1 ===> 0</td>
    <td class="lineNumber">1794</td>
    <td class="codeline">    Remainder = APInt(BitWidth, 0);   // X % 1 ===> 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1795</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="codeline"></td>
    <td class="lineNumber">1796</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="codeline">  if (lhsWords < rhsWords || LHS.ult(RHS)) {</td>
    <td class="lineNumber">1797</td>
    <td class="codeline">  if (lhsWords < rhsWords || LHS.ult(RHS)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="codeline">    Remainder = LHS;                  // X % Y ===> X, iff X < Y</td>
    <td class="lineNumber">1798</td>
    <td class="codeline">    Remainder = LHS;                  // X % Y ===> X, iff X < Y</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="codeline">    Quotient = APInt(BitWidth, 0);    // X / Y ===> 0, iff X < Y</td>
    <td class="lineNumber">1799</td>
    <td class="codeline">    Quotient = APInt(BitWidth, 0);    // X / Y ===> 0, iff X < Y</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">1800</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1801</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="codeline"></td>
    <td class="lineNumber">1802</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="codeline">  if (LHS == RHS) {</td>
    <td class="lineNumber">1803</td>
    <td class="codeline">  if (LHS == RHS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="codeline">    Quotient  = APInt(BitWidth, 1);   // X / X ===> 1</td>
    <td class="lineNumber">1804</td>
    <td class="codeline">    Quotient  = APInt(BitWidth, 1);   // X / X ===> 1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="codeline">    Remainder = APInt(BitWidth, 0);   // X % X ===> 0;</td>
    <td class="lineNumber">1805</td>
    <td class="codeline">    Remainder = APInt(BitWidth, 0);   // X % X ===> 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">1806</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1807</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="codeline"></td>
    <td class="lineNumber">1808</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="codeline">  // Make sure there is enough space to hold the results.</td>
    <td class="lineNumber">1809</td>
    <td class="codeline">  // Make sure there is enough space to hold the results.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="codeline">  // NOTE: This assumes that reallocate won't affect any bits if it doesn't</td>
    <td class="lineNumber">1810</td>
    <td class="codeline">  // NOTE: This assumes that reallocate won't affect any bits if it doesn't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="codeline">  // change the size. This is necessary if Quotient or Remainder is aliased</td>
    <td class="lineNumber">1811</td>
    <td class="codeline">  // change the size. This is necessary if Quotient or Remainder is aliased</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="codeline">  // with LHS or RHS.</td>
    <td class="lineNumber">1812</td>
    <td class="codeline">  // with LHS or RHS.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="codeline">  Quotient.reallocate(BitWidth);</td>
    <td class="lineNumber">1813</td>
    <td class="codeline">  Quotient.reallocate(BitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="codeline">  Remainder.reallocate(BitWidth);</td>
    <td class="lineNumber">1814</td>
    <td class="codeline">  Remainder.reallocate(BitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="codeline"></td>
    <td class="lineNumber">1815</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="codeline">  if (lhsWords == 1) { // rhsWords is 1 if lhsWords is 1.</td>
    <td class="lineNumber">1816</td>
    <td class="codeline">  if (lhsWords == 1) { // rhsWords is 1 if lhsWords is 1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="codeline">    // There is only one word to consider so use the native versions.</td>
    <td class="lineNumber">1817</td>
    <td class="codeline">    // There is only one word to consider so use the native versions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="codeline">    uint64_t lhsValue = LHS.U.pVal[0];</td>
    <td class="lineNumber">1818</td>
    <td class="codeline">    uint64_t lhsValue = LHS.U.pVal[0];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="codeline">    uint64_t rhsValue = RHS.U.pVal[0];</td>
    <td class="lineNumber">1819</td>
    <td class="codeline">    uint64_t rhsValue = RHS.U.pVal[0];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="codeline">    Quotient = lhsValue / rhsValue;</td>
    <td class="lineNumber">1820</td>
    <td class="codeline">    Quotient = lhsValue / rhsValue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="codeline">    Remainder = lhsValue % rhsValue;</td>
    <td class="lineNumber">1821</td>
    <td class="codeline">    Remainder = lhsValue % rhsValue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">1822</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1823</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="codeline"></td>
    <td class="lineNumber">1824</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="codeline">  // Okay, lets do it the long way</td>
    <td class="lineNumber">1825</td>
    <td class="codeline">  // Okay, lets do it the long way</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="codeline">  divide(LHS.U.pVal, lhsWords, RHS.U.pVal, rhsWords, Quotient.U.pVal,</td>
    <td class="lineNumber">1826</td>
    <td class="codeline">  divide(LHS.U.pVal, lhsWords, RHS.U.pVal, rhsWords, Quotient.U.pVal,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="codeline">         Remainder.U.pVal);</td>
    <td class="lineNumber">1827</td>
    <td class="codeline">         Remainder.U.pVal);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="codeline">  // Clear the rest of the Quotient and Remainder.</td>
    <td class="lineNumber">1828</td>
    <td class="codeline">  // Clear the rest of the Quotient and Remainder.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="codeline">  std::memset(Quotient.U.pVal + lhsWords, 0,</td>
    <td class="lineNumber">1829</td>
    <td class="codeline">  std::memset(Quotient.U.pVal + lhsWords, 0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="codeline">              (getNumWords(BitWidth) - lhsWords) * APINT_WORD_SIZE);</td>
    <td class="lineNumber">1830</td>
    <td class="codeline">              (getNumWords(BitWidth) - lhsWords) * APINT_WORD_SIZE);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="codeline">  std::memset(Remainder.U.pVal + rhsWords, 0,</td>
    <td class="lineNumber">1831</td>
    <td class="codeline">  std::memset(Remainder.U.pVal + rhsWords, 0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="codeline">              (getNumWords(BitWidth) - rhsWords) * APINT_WORD_SIZE);</td>
    <td class="lineNumber">1832</td>
    <td class="codeline">              (getNumWords(BitWidth) - rhsWords) * APINT_WORD_SIZE);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1833</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="codeline"></td>
    <td class="lineNumber">1834</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="codeline">void APInt::udivrem(const APInt &LHS, uint64_t RHS, APInt &Quotient,</td>
    <td class="lineNumber">1835</td>
    <td class="codeline">void APInt::udivrem(const APInt &LHS, uint64_t RHS, APInt &Quotient,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="codeline">                    uint64_t &Remainder) {</td>
    <td class="lineNumber">1836</td>
    <td class="codeline">                    uint64_t &Remainder) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="codeline">  assert(RHS != 0 && "Divide by zero?");</td>
    <td class="lineNumber">1837</td>
    <td class="codeline">  assert(RHS != 0 && "Divide by zero?");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="codeline">  unsigned BitWidth = LHS.BitWidth;</td>
    <td class="lineNumber">1838</td>
    <td class="codeline">  unsigned BitWidth = LHS.BitWidth;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="codeline"></td>
    <td class="lineNumber">1839</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="codeline">  // First, deal with the easy case</td>
    <td class="lineNumber">1840</td>
    <td class="codeline">  // First, deal with the easy case</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="codeline">  if (LHS.isSingleWord()) {</td>
    <td class="lineNumber">1841</td>
    <td class="codeline">  if (LHS.isSingleWord()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="codeline">    uint64_t QuotVal = LHS.U.VAL / RHS;</td>
    <td class="lineNumber">1842</td>
    <td class="codeline">    uint64_t QuotVal = LHS.U.VAL / RHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="codeline">    Remainder = LHS.U.VAL % RHS;</td>
    <td class="lineNumber">1843</td>
    <td class="codeline">    Remainder = LHS.U.VAL % RHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="codeline">    Quotient = APInt(BitWidth, QuotVal);</td>
    <td class="lineNumber">1844</td>
    <td class="codeline">    Quotient = APInt(BitWidth, QuotVal);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">1845</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1846</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="codeline"></td>
    <td class="lineNumber">1847</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="codeline">  // Get some size facts about the dividend and divisor</td>
    <td class="lineNumber">1848</td>
    <td class="codeline">  // Get some size facts about the dividend and divisor</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="codeline">  unsigned lhsWords = getNumWords(LHS.getActiveBits());</td>
    <td class="lineNumber">1849</td>
    <td class="codeline">  unsigned lhsWords = getNumWords(LHS.getActiveBits());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="codeline"></td>
    <td class="lineNumber">1850</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="codeline">  // Check the degenerate cases</td>
    <td class="lineNumber">1851</td>
    <td class="codeline">  // Check the degenerate cases</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="codeline">  if (lhsWords == 0) {</td>
    <td class="lineNumber">1852</td>
    <td class="codeline">  if (lhsWords == 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="codeline">    Quotient = APInt(BitWidth, 0);    // 0 / Y ===> 0</td>
    <td class="lineNumber">1853</td>
    <td class="codeline">    Quotient = APInt(BitWidth, 0);    // 0 / Y ===> 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="codeline">    Remainder = 0;                    // 0 % Y ===> 0</td>
    <td class="lineNumber">1854</td>
    <td class="codeline">    Remainder = 0;                    // 0 % Y ===> 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">1855</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1856</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="codeline"></td>
    <td class="lineNumber">1857</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="codeline">  if (RHS == 1) {</td>
    <td class="lineNumber">1858</td>
    <td class="codeline">  if (RHS == 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="codeline">    Quotient = LHS;                   // X / 1 ===> X</td>
    <td class="lineNumber">1859</td>
    <td class="codeline">    Quotient = LHS;                   // X / 1 ===> X</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="codeline">    Remainder = 0;                    // X % 1 ===> 0</td>
    <td class="lineNumber">1860</td>
    <td class="codeline">    Remainder = 0;                    // X % 1 ===> 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">1861</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1862</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="codeline"></td>
    <td class="lineNumber">1863</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="codeline">  if (LHS.ult(RHS)) {</td>
    <td class="lineNumber">1864</td>
    <td class="codeline">  if (LHS.ult(RHS)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="codeline">    Remainder = LHS.getZExtValue();   // X % Y ===> X, iff X < Y</td>
    <td class="lineNumber">1865</td>
    <td class="codeline">    Remainder = LHS.getZExtValue();   // X % Y ===> X, iff X < Y</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="codeline">    Quotient = APInt(BitWidth, 0);    // X / Y ===> 0, iff X < Y</td>
    <td class="lineNumber">1866</td>
    <td class="codeline">    Quotient = APInt(BitWidth, 0);    // X / Y ===> 0, iff X < Y</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">1867</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1868</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="codeline"></td>
    <td class="lineNumber">1869</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="codeline">  if (LHS == RHS) {</td>
    <td class="lineNumber">1870</td>
    <td class="codeline">  if (LHS == RHS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="codeline">    Quotient  = APInt(BitWidth, 1);   // X / X ===> 1</td>
    <td class="lineNumber">1871</td>
    <td class="codeline">    Quotient  = APInt(BitWidth, 1);   // X / X ===> 1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="codeline">    Remainder = 0;                    // X % X ===> 0;</td>
    <td class="lineNumber">1872</td>
    <td class="codeline">    Remainder = 0;                    // X % X ===> 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">1873</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1874</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="codeline"></td>
    <td class="lineNumber">1875</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="codeline">  // Make sure there is enough space to hold the results.</td>
    <td class="lineNumber">1876</td>
    <td class="codeline">  // Make sure there is enough space to hold the results.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="codeline">  // NOTE: This assumes that reallocate won't affect any bits if it doesn't</td>
    <td class="lineNumber">1877</td>
    <td class="codeline">  // NOTE: This assumes that reallocate won't affect any bits if it doesn't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="codeline">  // change the size. This is necessary if Quotient is aliased with LHS.</td>
    <td class="lineNumber">1878</td>
    <td class="codeline">  // change the size. This is necessary if Quotient is aliased with LHS.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="codeline">  Quotient.reallocate(BitWidth);</td>
    <td class="lineNumber">1879</td>
    <td class="codeline">  Quotient.reallocate(BitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="codeline"></td>
    <td class="lineNumber">1880</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="codeline">  if (lhsWords == 1) { // rhsWords is 1 if lhsWords is 1.</td>
    <td class="lineNumber">1881</td>
    <td class="codeline">  if (lhsWords == 1) { // rhsWords is 1 if lhsWords is 1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="codeline">    // There is only one word to consider so use the native versions.</td>
    <td class="lineNumber">1882</td>
    <td class="codeline">    // There is only one word to consider so use the native versions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="codeline">    uint64_t lhsValue = LHS.U.pVal[0];</td>
    <td class="lineNumber">1883</td>
    <td class="codeline">    uint64_t lhsValue = LHS.U.pVal[0];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="codeline">    Quotient = lhsValue / RHS;</td>
    <td class="lineNumber">1884</td>
    <td class="codeline">    Quotient = lhsValue / RHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="codeline">    Remainder = lhsValue % RHS;</td>
    <td class="lineNumber">1885</td>
    <td class="codeline">    Remainder = lhsValue % RHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">1886</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1887</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="codeline"></td>
    <td class="lineNumber">1888</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="codeline">  // Okay, lets do it the long way</td>
    <td class="lineNumber">1889</td>
    <td class="codeline">  // Okay, lets do it the long way</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="codeline">  divide(LHS.U.pVal, lhsWords, &RHS, 1, Quotient.U.pVal, &Remainder);</td>
    <td class="lineNumber">1890</td>
    <td class="codeline">  divide(LHS.U.pVal, lhsWords, &RHS, 1, Quotient.U.pVal, &Remainder);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="codeline">  // Clear the rest of the Quotient.</td>
    <td class="lineNumber">1891</td>
    <td class="codeline">  // Clear the rest of the Quotient.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="codeline">  std::memset(Quotient.U.pVal + lhsWords, 0,</td>
    <td class="lineNumber">1892</td>
    <td class="codeline">  std::memset(Quotient.U.pVal + lhsWords, 0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="codeline">              (getNumWords(BitWidth) - lhsWords) * APINT_WORD_SIZE);</td>
    <td class="lineNumber">1893</td>
    <td class="codeline">              (getNumWords(BitWidth) - lhsWords) * APINT_WORD_SIZE);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1894</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="codeline"></td>
    <td class="lineNumber">1895</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="codeline">void APInt::sdivrem(const APInt &LHS, const APInt &RHS,</td>
    <td class="lineNumber">1896</td>
    <td class="codeline">void APInt::sdivrem(const APInt &LHS, const APInt &RHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="codeline">                    APInt &Quotient, APInt &Remainder) {</td>
    <td class="lineNumber">1897</td>
    <td class="codeline">                    APInt &Quotient, APInt &Remainder) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="codeline">  if (LHS.isNegative()) {</td>
    <td class="lineNumber">1898</td>
    <td class="codeline">  if (LHS.isNegative()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="codeline">    if (RHS.isNegative())</td>
    <td class="lineNumber">1899</td>
    <td class="codeline">    if (RHS.isNegative())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="codeline">      APInt::udivrem(-LHS, -RHS, Quotient, Remainder);</td>
    <td class="lineNumber">1900</td>
    <td class="codeline">      APInt::udivrem(-LHS, -RHS, Quotient, Remainder);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="codeline">    else {</td>
    <td class="lineNumber">1901</td>
    <td class="codeline">    else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="codeline">      APInt::udivrem(-LHS, RHS, Quotient, Remainder);</td>
    <td class="lineNumber">1902</td>
    <td class="codeline">      APInt::udivrem(-LHS, RHS, Quotient, Remainder);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="codeline">      Quotient.negate();</td>
    <td class="lineNumber">1903</td>
    <td class="codeline">      Quotient.negate();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1904</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="codeline">    Remainder.negate();</td>
    <td class="lineNumber">1905</td>
    <td class="codeline">    Remainder.negate();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="codeline">  } else if (RHS.isNegative()) {</td>
    <td class="lineNumber">1906</td>
    <td class="codeline">  } else if (RHS.isNegative()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="codeline">    APInt::udivrem(LHS, -RHS, Quotient, Remainder);</td>
    <td class="lineNumber">1907</td>
    <td class="codeline">    APInt::udivrem(LHS, -RHS, Quotient, Remainder);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="codeline">    Quotient.negate();</td>
    <td class="lineNumber">1908</td>
    <td class="codeline">    Quotient.negate();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">1909</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="codeline">    APInt::udivrem(LHS, RHS, Quotient, Remainder);</td>
    <td class="lineNumber">1910</td>
    <td class="codeline">    APInt::udivrem(LHS, RHS, Quotient, Remainder);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1911</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1912</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="codeline"></td>
    <td class="lineNumber">1913</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="codeline">void APInt::sdivrem(const APInt &LHS, int64_t RHS,</td>
    <td class="lineNumber">1914</td>
    <td class="codeline">void APInt::sdivrem(const APInt &LHS, int64_t RHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="codeline">                    APInt &Quotient, int64_t &Remainder) {</td>
    <td class="lineNumber">1915</td>
    <td class="codeline">                    APInt &Quotient, int64_t &Remainder) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="codeline">  uint64_t R = Remainder;</td>
    <td class="lineNumber">1916</td>
    <td class="codeline">  uint64_t R = Remainder;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="codeline">  if (LHS.isNegative()) {</td>
    <td class="lineNumber">1917</td>
    <td class="codeline">  if (LHS.isNegative()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="codeline">    if (RHS < 0)</td>
    <td class="lineNumber">1918</td>
    <td class="codeline">    if (RHS < 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="codeline">      APInt::udivrem(-LHS, -RHS, Quotient, R);</td>
    <td class="lineNumber">1919</td>
    <td class="codeline">      APInt::udivrem(-LHS, -RHS, Quotient, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="codeline">    else {</td>
    <td class="lineNumber">1920</td>
    <td class="codeline">    else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="codeline">      APInt::udivrem(-LHS, RHS, Quotient, R);</td>
    <td class="lineNumber">1921</td>
    <td class="codeline">      APInt::udivrem(-LHS, RHS, Quotient, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="codeline">      Quotient.negate();</td>
    <td class="lineNumber">1922</td>
    <td class="codeline">      Quotient.negate();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1923</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="codeline">    R = -R;</td>
    <td class="lineNumber">1924</td>
    <td class="codeline">    R = -R;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="codeline">  } else if (RHS < 0) {</td>
    <td class="lineNumber">1925</td>
    <td class="codeline">  } else if (RHS < 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="codeline">    APInt::udivrem(LHS, -RHS, Quotient, R);</td>
    <td class="lineNumber">1926</td>
    <td class="codeline">    APInt::udivrem(LHS, -RHS, Quotient, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="codeline">    Quotient.negate();</td>
    <td class="lineNumber">1927</td>
    <td class="codeline">    Quotient.negate();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">1928</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="codeline">    APInt::udivrem(LHS, RHS, Quotient, R);</td>
    <td class="lineNumber">1929</td>
    <td class="codeline">    APInt::udivrem(LHS, RHS, Quotient, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1930</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="codeline">  Remainder = R;</td>
    <td class="lineNumber">1931</td>
    <td class="codeline">  Remainder = R;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1932</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="codeline"></td>
    <td class="lineNumber">1933</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="codeline">APInt APInt::sadd_ov(const APInt &RHS, bool &Overflow) const {</td>
    <td class="lineNumber">1934</td>
    <td class="codeline">APInt APInt::sadd_ov(const APInt &RHS, bool &Overflow) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="codeline">  APInt Res = *this+RHS;</td>
    <td class="lineNumber">1935</td>
    <td class="codeline">  APInt Res = *this+RHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="codeline">  Overflow = isNonNegative() == RHS.isNonNegative() &&</td>
    <td class="lineNumber">1936</td>
    <td class="codeline">  Overflow = isNonNegative() == RHS.isNonNegative() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="codeline">             Res.isNonNegative() != isNonNegative();</td>
    <td class="lineNumber">1937</td>
    <td class="codeline">             Res.isNonNegative() != isNonNegative();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="codeline">  return Res;</td>
    <td class="lineNumber">1938</td>
    <td class="codeline">  return Res;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1939</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="codeline"></td>
    <td class="lineNumber">1940</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="codeline">APInt APInt::uadd_ov(const APInt &RHS, bool &Overflow) const {</td>
    <td class="lineNumber">1941</td>
    <td class="codeline">APInt APInt::uadd_ov(const APInt &RHS, bool &Overflow) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="codeline">  APInt Res = *this+RHS;</td>
    <td class="lineNumber">1942</td>
    <td class="codeline">  APInt Res = *this+RHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="codeline">  Overflow = Res.ult(RHS);</td>
    <td class="lineNumber">1943</td>
    <td class="codeline">  Overflow = Res.ult(RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="codeline">  return Res;</td>
    <td class="lineNumber">1944</td>
    <td class="codeline">  return Res;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1945</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="codeline"></td>
    <td class="lineNumber">1946</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="codeline">APInt APInt::ssub_ov(const APInt &RHS, bool &Overflow) const {</td>
    <td class="lineNumber">1947</td>
    <td class="codeline">APInt APInt::ssub_ov(const APInt &RHS, bool &Overflow) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="codeline">  APInt Res = *this - RHS;</td>
    <td class="lineNumber">1948</td>
    <td class="codeline">  APInt Res = *this - RHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="codeline">  Overflow = isNonNegative() != RHS.isNonNegative() &&</td>
    <td class="lineNumber">1949</td>
    <td class="codeline">  Overflow = isNonNegative() != RHS.isNonNegative() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="codeline">             Res.isNonNegative() != isNonNegative();</td>
    <td class="lineNumber">1950</td>
    <td class="codeline">             Res.isNonNegative() != isNonNegative();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="codeline">  return Res;</td>
    <td class="lineNumber">1951</td>
    <td class="codeline">  return Res;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1952</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="codeline"></td>
    <td class="lineNumber">1953</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="codeline">APInt APInt::usub_ov(const APInt &RHS, bool &Overflow) const {</td>
    <td class="lineNumber">1954</td>
    <td class="codeline">APInt APInt::usub_ov(const APInt &RHS, bool &Overflow) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="codeline">  APInt Res = *this-RHS;</td>
    <td class="lineNumber">1955</td>
    <td class="codeline">  APInt Res = *this-RHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="codeline">  Overflow = Res.ugt(*this);</td>
    <td class="lineNumber">1956</td>
    <td class="codeline">  Overflow = Res.ugt(*this);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="codeline">  return Res;</td>
    <td class="lineNumber">1957</td>
    <td class="codeline">  return Res;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1958</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="codeline"></td>
    <td class="lineNumber">1959</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="codeline">APInt APInt::sdiv_ov(const APInt &RHS, bool &Overflow) const {</td>
    <td class="lineNumber">1960</td>
    <td class="codeline">APInt APInt::sdiv_ov(const APInt &RHS, bool &Overflow) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="codeline">  // MININT/-1  -->  overflow.</td>
    <td class="lineNumber">1961</td>
    <td class="codeline">  // MININT/-1  -->  overflow.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="codeline">  Overflow = isMinSignedValue() && RHS.isAllOnes();</td>
    <td class="lineNumber">1962</td>
    <td class="codeline">  Overflow = isMinSignedValue() && RHS.isAllOnes();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="codeline">  return sdiv(RHS);</td>
    <td class="lineNumber">1963</td>
    <td class="codeline">  return sdiv(RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1964</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="codeline"></td>
    <td class="lineNumber">1965</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="codeline">APInt APInt::smul_ov(const APInt &RHS, bool &Overflow) const {</td>
    <td class="lineNumber">1966</td>
    <td class="codeline">APInt APInt::smul_ov(const APInt &RHS, bool &Overflow) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="codeline">  APInt Res = *this * RHS;</td>
    <td class="lineNumber">1967</td>
    <td class="codeline">  APInt Res = *this * RHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="codeline"></td>
    <td class="lineNumber">1968</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="codeline">  if (RHS != 0)</td>
    <td class="lineNumber">1969</td>
    <td class="codeline">  if (RHS != 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="codeline">    Overflow = Res.sdiv(RHS) != *this ||</td>
    <td class="lineNumber">1970</td>
    <td class="codeline">    Overflow = Res.sdiv(RHS) != *this ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="codeline">               (isMinSignedValue() && RHS.isAllOnes());</td>
    <td class="lineNumber">1971</td>
    <td class="codeline">               (isMinSignedValue() && RHS.isAllOnes());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">1972</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="codeline">    Overflow = false;</td>
    <td class="lineNumber">1973</td>
    <td class="codeline">    Overflow = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="codeline">  return Res;</td>
    <td class="lineNumber">1974</td>
    <td class="codeline">  return Res;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1975</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="codeline"></td>
    <td class="lineNumber">1976</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="codeline">APInt APInt::umul_ov(const APInt &RHS, bool &Overflow) const {</td>
    <td class="lineNumber">1977</td>
    <td class="codeline">APInt APInt::umul_ov(const APInt &RHS, bool &Overflow) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="codeline">  if (countl_zero() + RHS.countl_zero() + 2 <= BitWidth) {</td>
    <td class="lineNumber">1978</td>
    <td class="codeline">  if (countl_zero() + RHS.countl_zero() + 2 <= BitWidth) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="codeline">    Overflow = true;</td>
    <td class="lineNumber">1979</td>
    <td class="codeline">    Overflow = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="codeline">    return *this * RHS;</td>
    <td class="lineNumber">1980</td>
    <td class="codeline">    return *this * RHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1981</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="codeline"></td>
    <td class="lineNumber">1982</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="codeline">  APInt Res = lshr(1) * RHS;</td>
    <td class="lineNumber">1983</td>
    <td class="codeline">  APInt Res = lshr(1) * RHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="codeline">  Overflow = Res.isNegative();</td>
    <td class="lineNumber">1984</td>
    <td class="codeline">  Overflow = Res.isNegative();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="codeline">  Res <<= 1;</td>
    <td class="lineNumber">1985</td>
    <td class="codeline">  Res <<= 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="codeline">  if ((*this)[0]) {</td>
    <td class="lineNumber">1986</td>
    <td class="codeline">  if ((*this)[0]) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="codeline">    Res += RHS;</td>
    <td class="lineNumber">1987</td>
    <td class="codeline">    Res += RHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="codeline">    if (Res.ult(RHS))</td>
    <td class="lineNumber">1988</td>
    <td class="codeline">    if (Res.ult(RHS))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="codeline">      Overflow = true;</td>
    <td class="lineNumber">1989</td>
    <td class="codeline">      Overflow = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1990</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="codeline">  return Res;</td>
    <td class="lineNumber">1991</td>
    <td class="codeline">  return Res;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1992</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="codeline"></td>
    <td class="lineNumber">1993</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="codeline">APInt APInt::sshl_ov(const APInt &ShAmt, bool &Overflow) const {</td>
    <td class="lineNumber">1994</td>
    <td class="codeline">APInt APInt::sshl_ov(const APInt &ShAmt, bool &Overflow) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="codeline">  return sshl_ov(ShAmt.getLimitedValue(getBitWidth()), Overflow);</td>
    <td class="lineNumber">1995</td>
    <td class="codeline">  return sshl_ov(ShAmt.getLimitedValue(getBitWidth()), Overflow);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1996</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="codeline"></td>
    <td class="lineNumber">1997</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="codeline">APInt APInt::sshl_ov(unsigned ShAmt, bool &Overflow) const {</td>
    <td class="lineNumber">1998</td>
    <td class="codeline">APInt APInt::sshl_ov(unsigned ShAmt, bool &Overflow) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="codeline">  Overflow = ShAmt >= getBitWidth();</td>
    <td class="lineNumber">1999</td>
    <td class="codeline">  Overflow = ShAmt >= getBitWidth();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="codeline">  if (Overflow)</td>
    <td class="lineNumber">2000</td>
    <td class="codeline">  if (Overflow)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="codeline">    return APInt(BitWidth, 0);</td>
    <td class="lineNumber">2001</td>
    <td class="codeline">    return APInt(BitWidth, 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="codeline"></td>
    <td class="lineNumber">2002</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="codeline">  if (isNonNegative()) // Don't allow sign change.</td>
    <td class="lineNumber">2003</td>
    <td class="codeline">  if (isNonNegative()) // Don't allow sign change.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="codeline">    Overflow = ShAmt >= countl_zero();</td>
    <td class="lineNumber">2004</td>
    <td class="codeline">    Overflow = ShAmt >= countl_zero();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">2005</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="codeline">    Overflow = ShAmt >= countl_one();</td>
    <td class="lineNumber">2006</td>
    <td class="codeline">    Overflow = ShAmt >= countl_one();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="codeline"></td>
    <td class="lineNumber">2007</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="codeline">  return *this << ShAmt;</td>
    <td class="lineNumber">2008</td>
    <td class="codeline">  return *this << ShAmt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2009</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="codeline"></td>
    <td class="lineNumber">2010</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="codeline">APInt APInt::ushl_ov(const APInt &ShAmt, bool &Overflow) const {</td>
    <td class="lineNumber">2011</td>
    <td class="codeline">APInt APInt::ushl_ov(const APInt &ShAmt, bool &Overflow) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="codeline">  return ushl_ov(ShAmt.getLimitedValue(getBitWidth()), Overflow);</td>
    <td class="lineNumber">2012</td>
    <td class="codeline">  return ushl_ov(ShAmt.getLimitedValue(getBitWidth()), Overflow);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2013</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="codeline"></td>
    <td class="lineNumber">2014</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="codeline">APInt APInt::ushl_ov(unsigned ShAmt, bool &Overflow) const {</td>
    <td class="lineNumber">2015</td>
    <td class="codeline">APInt APInt::ushl_ov(unsigned ShAmt, bool &Overflow) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="codeline">  Overflow = ShAmt >= getBitWidth();</td>
    <td class="lineNumber">2016</td>
    <td class="codeline">  Overflow = ShAmt >= getBitWidth();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="codeline">  if (Overflow)</td>
    <td class="lineNumber">2017</td>
    <td class="codeline">  if (Overflow)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="codeline">    return APInt(BitWidth, 0);</td>
    <td class="lineNumber">2018</td>
    <td class="codeline">    return APInt(BitWidth, 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="codeline"></td>
    <td class="lineNumber">2019</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="codeline">  Overflow = ShAmt > countl_zero();</td>
    <td class="lineNumber">2020</td>
    <td class="codeline">  Overflow = ShAmt > countl_zero();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="codeline"></td>
    <td class="lineNumber">2021</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="codeline">  return *this << ShAmt;</td>
    <td class="lineNumber">2022</td>
    <td class="codeline">  return *this << ShAmt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2023</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="codeline"></td>
    <td class="lineNumber">2024</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="codeline">APInt APInt::sadd_sat(const APInt &RHS) const {</td>
    <td class="lineNumber">2025</td>
    <td class="codeline">APInt APInt::sadd_sat(const APInt &RHS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="codeline">  bool Overflow;</td>
    <td class="lineNumber">2026</td>
    <td class="codeline">  bool Overflow;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="codeline">  APInt Res = sadd_ov(RHS, Overflow);</td>
    <td class="lineNumber">2027</td>
    <td class="codeline">  APInt Res = sadd_ov(RHS, Overflow);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="codeline">  if (!Overflow)</td>
    <td class="lineNumber">2028</td>
    <td class="codeline">  if (!Overflow)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="codeline">    return Res;</td>
    <td class="lineNumber">2029</td>
    <td class="codeline">    return Res;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="codeline"></td>
    <td class="lineNumber">2030</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="codeline">  return isNegative() ? APInt::getSignedMinValue(BitWidth)</td>
    <td class="lineNumber">2031</td>
    <td class="codeline">  return isNegative() ? APInt::getSignedMinValue(BitWidth)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="codeline">                      : APInt::getSignedMaxValue(BitWidth);</td>
    <td class="lineNumber">2032</td>
    <td class="codeline">                      : APInt::getSignedMaxValue(BitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2033</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="codeline"></td>
    <td class="lineNumber">2034</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="codeline">APInt APInt::uadd_sat(const APInt &RHS) const {</td>
    <td class="lineNumber">2035</td>
    <td class="codeline">APInt APInt::uadd_sat(const APInt &RHS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="codeline">  bool Overflow;</td>
    <td class="lineNumber">2036</td>
    <td class="codeline">  bool Overflow;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="codeline">  APInt Res = uadd_ov(RHS, Overflow);</td>
    <td class="lineNumber">2037</td>
    <td class="codeline">  APInt Res = uadd_ov(RHS, Overflow);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="codeline">  if (!Overflow)</td>
    <td class="lineNumber">2038</td>
    <td class="codeline">  if (!Overflow)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="codeline">    return Res;</td>
    <td class="lineNumber">2039</td>
    <td class="codeline">    return Res;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="codeline"></td>
    <td class="lineNumber">2040</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="codeline">  return APInt::getMaxValue(BitWidth);</td>
    <td class="lineNumber">2041</td>
    <td class="codeline">  return APInt::getMaxValue(BitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2042</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="codeline"></td>
    <td class="lineNumber">2043</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="codeline">APInt APInt::ssub_sat(const APInt &RHS) const {</td>
    <td class="lineNumber">2044</td>
    <td class="codeline">APInt APInt::ssub_sat(const APInt &RHS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="codeline">  bool Overflow;</td>
    <td class="lineNumber">2045</td>
    <td class="codeline">  bool Overflow;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="codeline">  APInt Res = ssub_ov(RHS, Overflow);</td>
    <td class="lineNumber">2046</td>
    <td class="codeline">  APInt Res = ssub_ov(RHS, Overflow);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="codeline">  if (!Overflow)</td>
    <td class="lineNumber">2047</td>
    <td class="codeline">  if (!Overflow)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="codeline">    return Res;</td>
    <td class="lineNumber">2048</td>
    <td class="codeline">    return Res;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="codeline"></td>
    <td class="lineNumber">2049</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="codeline">  return isNegative() ? APInt::getSignedMinValue(BitWidth)</td>
    <td class="lineNumber">2050</td>
    <td class="codeline">  return isNegative() ? APInt::getSignedMinValue(BitWidth)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="codeline">                      : APInt::getSignedMaxValue(BitWidth);</td>
    <td class="lineNumber">2051</td>
    <td class="codeline">                      : APInt::getSignedMaxValue(BitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2052</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="codeline"></td>
    <td class="lineNumber">2053</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="codeline">APInt APInt::usub_sat(const APInt &RHS) const {</td>
    <td class="lineNumber">2054</td>
    <td class="codeline">APInt APInt::usub_sat(const APInt &RHS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="codeline">  bool Overflow;</td>
    <td class="lineNumber">2055</td>
    <td class="codeline">  bool Overflow;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="codeline">  APInt Res = usub_ov(RHS, Overflow);</td>
    <td class="lineNumber">2056</td>
    <td class="codeline">  APInt Res = usub_ov(RHS, Overflow);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="codeline">  if (!Overflow)</td>
    <td class="lineNumber">2057</td>
    <td class="codeline">  if (!Overflow)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="codeline">    return Res;</td>
    <td class="lineNumber">2058</td>
    <td class="codeline">    return Res;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="codeline"></td>
    <td class="lineNumber">2059</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="codeline">  return APInt(BitWidth, 0);</td>
    <td class="lineNumber">2060</td>
    <td class="codeline">  return APInt(BitWidth, 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2061</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="codeline"></td>
    <td class="lineNumber">2062</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="codeline">APInt APInt::smul_sat(const APInt &RHS) const {</td>
    <td class="lineNumber">2063</td>
    <td class="codeline">APInt APInt::smul_sat(const APInt &RHS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="codeline">  bool Overflow;</td>
    <td class="lineNumber">2064</td>
    <td class="codeline">  bool Overflow;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="codeline">  APInt Res = smul_ov(RHS, Overflow);</td>
    <td class="lineNumber">2065</td>
    <td class="codeline">  APInt Res = smul_ov(RHS, Overflow);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="codeline">  if (!Overflow)</td>
    <td class="lineNumber">2066</td>
    <td class="codeline">  if (!Overflow)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="codeline">    return Res;</td>
    <td class="lineNumber">2067</td>
    <td class="codeline">    return Res;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="codeline"></td>
    <td class="lineNumber">2068</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="codeline">  // The result is negative if one and only one of inputs is negative.</td>
    <td class="lineNumber">2069</td>
    <td class="codeline">  // The result is negative if one and only one of inputs is negative.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="codeline">  bool ResIsNegative = isNegative() ^ RHS.isNegative();</td>
    <td class="lineNumber">2070</td>
    <td class="codeline">  bool ResIsNegative = isNegative() ^ RHS.isNegative();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="codeline"></td>
    <td class="lineNumber">2071</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="codeline">  return ResIsNegative ? APInt::getSignedMinValue(BitWidth)</td>
    <td class="lineNumber">2072</td>
    <td class="codeline">  return ResIsNegative ? APInt::getSignedMinValue(BitWidth)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="codeline">                       : APInt::getSignedMaxValue(BitWidth);</td>
    <td class="lineNumber">2073</td>
    <td class="codeline">                       : APInt::getSignedMaxValue(BitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2074</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="codeline"></td>
    <td class="lineNumber">2075</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="codeline">APInt APInt::umul_sat(const APInt &RHS) const {</td>
    <td class="lineNumber">2076</td>
    <td class="codeline">APInt APInt::umul_sat(const APInt &RHS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="codeline">  bool Overflow;</td>
    <td class="lineNumber">2077</td>
    <td class="codeline">  bool Overflow;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="codeline">  APInt Res = umul_ov(RHS, Overflow);</td>
    <td class="lineNumber">2078</td>
    <td class="codeline">  APInt Res = umul_ov(RHS, Overflow);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="codeline">  if (!Overflow)</td>
    <td class="lineNumber">2079</td>
    <td class="codeline">  if (!Overflow)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="codeline">    return Res;</td>
    <td class="lineNumber">2080</td>
    <td class="codeline">    return Res;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="codeline"></td>
    <td class="lineNumber">2081</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="codeline">  return APInt::getMaxValue(BitWidth);</td>
    <td class="lineNumber">2082</td>
    <td class="codeline">  return APInt::getMaxValue(BitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2083</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="codeline"></td>
    <td class="lineNumber">2084</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="codeline">APInt APInt::sshl_sat(const APInt &RHS) const {</td>
    <td class="lineNumber">2085</td>
    <td class="codeline">APInt APInt::sshl_sat(const APInt &RHS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="codeline">  return sshl_sat(RHS.getLimitedValue(getBitWidth()));</td>
    <td class="lineNumber">2086</td>
    <td class="codeline">  return sshl_sat(RHS.getLimitedValue(getBitWidth()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2087</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="codeline"></td>
    <td class="lineNumber">2088</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="codeline">APInt APInt::sshl_sat(unsigned RHS) const {</td>
    <td class="lineNumber">2089</td>
    <td class="codeline">APInt APInt::sshl_sat(unsigned RHS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="codeline">  bool Overflow;</td>
    <td class="lineNumber">2090</td>
    <td class="codeline">  bool Overflow;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="codeline">  APInt Res = sshl_ov(RHS, Overflow);</td>
    <td class="lineNumber">2091</td>
    <td class="codeline">  APInt Res = sshl_ov(RHS, Overflow);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="codeline">  if (!Overflow)</td>
    <td class="lineNumber">2092</td>
    <td class="codeline">  if (!Overflow)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="codeline">    return Res;</td>
    <td class="lineNumber">2093</td>
    <td class="codeline">    return Res;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="codeline"></td>
    <td class="lineNumber">2094</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="codeline">  return isNegative() ? APInt::getSignedMinValue(BitWidth)</td>
    <td class="lineNumber">2095</td>
    <td class="codeline">  return isNegative() ? APInt::getSignedMinValue(BitWidth)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="codeline">                      : APInt::getSignedMaxValue(BitWidth);</td>
    <td class="lineNumber">2096</td>
    <td class="codeline">                      : APInt::getSignedMaxValue(BitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2097</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="codeline"></td>
    <td class="lineNumber">2098</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="codeline">APInt APInt::ushl_sat(const APInt &RHS) const {</td>
    <td class="lineNumber">2099</td>
    <td class="codeline">APInt APInt::ushl_sat(const APInt &RHS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="codeline">  return ushl_sat(RHS.getLimitedValue(getBitWidth()));</td>
    <td class="lineNumber">2100</td>
    <td class="codeline">  return ushl_sat(RHS.getLimitedValue(getBitWidth()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2101</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="codeline"></td>
    <td class="lineNumber">2102</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="codeline">APInt APInt::ushl_sat(unsigned RHS) const {</td>
    <td class="lineNumber">2103</td>
    <td class="codeline">APInt APInt::ushl_sat(unsigned RHS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="codeline">  bool Overflow;</td>
    <td class="lineNumber">2104</td>
    <td class="codeline">  bool Overflow;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="codeline">  APInt Res = ushl_ov(RHS, Overflow);</td>
    <td class="lineNumber">2105</td>
    <td class="codeline">  APInt Res = ushl_ov(RHS, Overflow);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="codeline">  if (!Overflow)</td>
    <td class="lineNumber">2106</td>
    <td class="codeline">  if (!Overflow)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="codeline">    return Res;</td>
    <td class="lineNumber">2107</td>
    <td class="codeline">    return Res;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="codeline"></td>
    <td class="lineNumber">2108</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="codeline">  return APInt::getMaxValue(BitWidth);</td>
    <td class="lineNumber">2109</td>
    <td class="codeline">  return APInt::getMaxValue(BitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2110</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="codeline"></td>
    <td class="lineNumber">2111</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="codeline">void APInt::fromString(unsigned numbits, StringRef str, uint8_t radix) {</td>
    <td class="lineNumber">2112</td>
    <td class="codeline">void APInt::fromString(unsigned numbits, StringRef str, uint8_t radix) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="codeline">  // Check our assumptions here</td>
    <td class="lineNumber">2113</td>
    <td class="codeline">  // Check our assumptions here</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="codeline">  assert(!str.empty() && "Invalid string length");</td>
    <td class="lineNumber">2114</td>
    <td class="codeline">  assert(!str.empty() && "Invalid string length");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="codeline">  assert((radix == 10 || radix == 8 || radix == 16 || radix == 2 ||</td>
    <td class="lineNumber">2115</td>
    <td class="codeline">  assert((radix == 10 || radix == 8 || radix == 16 || radix == 2 ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="codeline">          radix == 36) &&</td>
    <td class="lineNumber">2116</td>
    <td class="codeline">          radix == 36) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="codeline">         "Radix should be 2, 8, 10, 16, or 36!");</td>
    <td class="lineNumber">2117</td>
    <td class="codeline">         "Radix should be 2, 8, 10, 16, or 36!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="codeline"></td>
    <td class="lineNumber">2118</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="codeline">  StringRef::iterator p = str.begin();</td>
    <td class="lineNumber">2119</td>
    <td class="codeline">  StringRef::iterator p = str.begin();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="codeline">  size_t slen = str.size();</td>
    <td class="lineNumber">2120</td>
    <td class="codeline">  size_t slen = str.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="codeline">  bool isNeg = *p == '-';</td>
    <td class="lineNumber">2121</td>
    <td class="codeline">  bool isNeg = *p == '-';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="codeline">  if (*p == '-' || *p == '+') {</td>
    <td class="lineNumber">2122</td>
    <td class="codeline">  if (*p == '-' || *p == '+') {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="codeline">    p++;</td>
    <td class="lineNumber">2123</td>
    <td class="codeline">    p++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="codeline">    slen--;</td>
    <td class="lineNumber">2124</td>
    <td class="codeline">    slen--;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="codeline">    assert(slen && "String is only a sign, needs a value.");</td>
    <td class="lineNumber">2125</td>
    <td class="codeline">    assert(slen && "String is only a sign, needs a value.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2126</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="codeline">  assert((slen <= numbits || radix != 2) && "Insufficient bit width");</td>
    <td class="lineNumber">2127</td>
    <td class="codeline">  assert((slen <= numbits || radix != 2) && "Insufficient bit width");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="codeline">  assert(((slen-1)*3 <= numbits || radix != 8) && "Insufficient bit width");</td>
    <td class="lineNumber">2128</td>
    <td class="codeline">  assert(((slen-1)*3 <= numbits || radix != 8) && "Insufficient bit width");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="codeline">  assert(((slen-1)*4 <= numbits || radix != 16) && "Insufficient bit width");</td>
    <td class="lineNumber">2129</td>
    <td class="codeline">  assert(((slen-1)*4 <= numbits || radix != 16) && "Insufficient bit width");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="codeline">  assert((((slen-1)*64)/22 <= numbits || radix != 10) &&</td>
    <td class="lineNumber">2130</td>
    <td class="codeline">  assert((((slen-1)*64)/22 <= numbits || radix != 10) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="codeline">         "Insufficient bit width");</td>
    <td class="lineNumber">2131</td>
    <td class="codeline">         "Insufficient bit width");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="codeline"></td>
    <td class="lineNumber">2132</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="codeline">  // Allocate memory if needed</td>
    <td class="lineNumber">2133</td>
    <td class="codeline">  // Allocate memory if needed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="codeline">  if (isSingleWord())</td>
    <td class="lineNumber">2134</td>
    <td class="codeline">  if (isSingleWord())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="codeline">    U.VAL = 0;</td>
    <td class="lineNumber">2135</td>
    <td class="codeline">    U.VAL = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">2136</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="codeline">    U.pVal = getClearedMemory(getNumWords());</td>
    <td class="lineNumber">2137</td>
    <td class="codeline">    U.pVal = getClearedMemory(getNumWords());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="codeline"></td>
    <td class="lineNumber">2138</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="codeline">  // Figure out if we can shift instead of multiply</td>
    <td class="lineNumber">2139</td>
    <td class="codeline">  // Figure out if we can shift instead of multiply</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="codeline">  unsigned shift = (radix == 16 ? 4 : radix == 8 ? 3 : radix == 2 ? 1 : 0);</td>
    <td class="lineNumber">2140</td>
    <td class="codeline">  unsigned shift = (radix == 16 ? 4 : radix == 8 ? 3 : radix == 2 ? 1 : 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="codeline"></td>
    <td class="lineNumber">2141</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="codeline">  // Enter digit traversal loop</td>
    <td class="lineNumber">2142</td>
    <td class="codeline">  // Enter digit traversal loop</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="codeline">  for (StringRef::iterator e = str.end(); p != e; ++p) {</td>
    <td class="lineNumber">2143</td>
    <td class="codeline">  for (StringRef::iterator e = str.end(); p != e; ++p) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="codeline">    unsigned digit = getDigit(*p, radix);</td>
    <td class="lineNumber">2144</td>
    <td class="codeline">    unsigned digit = getDigit(*p, radix);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="codeline">    assert(digit < radix && "Invalid character in digit string");</td>
    <td class="lineNumber">2145</td>
    <td class="codeline">    assert(digit < radix && "Invalid character in digit string");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="codeline"></td>
    <td class="lineNumber">2146</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="codeline">    // Shift or multiply the value by the radix</td>
    <td class="lineNumber">2147</td>
    <td class="codeline">    // Shift or multiply the value by the radix</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="codeline">    if (slen > 1) {</td>
    <td class="lineNumber">2148</td>
    <td class="codeline">    if (slen > 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="codeLine diffFirst">      if (shift)</td>
    <td class="lineNumber">2149</td>
    <td class="codeline">      if (shift)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="codeline">        *this <<= shift;</td>
    <td class="lineNumber">2150</td>
    <td class="codeline">        *this <<= shift;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="codeline">      else</td>
    <td class="lineNumber">2151</td>
    <td class="codeline">      else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="codeLine diffFirst">        *this *= radix;</td>
    <td class="lineNumber">2152</td>
    <td class="codeline">        *this *= radix;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2153</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="codeline"></td>
    <td class="lineNumber">2154</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="codeline">    // Add in the digit we just interpreted</td>
    <td class="lineNumber">2155</td>
    <td class="codeline">    // Add in the digit we just interpreted</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="codeline">    *this += digit;</td>
    <td class="lineNumber">2156</td>
    <td class="codeline">    *this += digit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2157</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="codeline">  // If its negative, put it in two's complement form</td>
    <td class="lineNumber">2158</td>
    <td class="codeline">  // If its negative, put it in two's complement form</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="codeline">  if (isNeg)</td>
    <td class="lineNumber">2159</td>
    <td class="codeline">  if (isNeg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="codeline">    this->negate();</td>
    <td class="lineNumber">2160</td>
    <td class="codeline">    this->negate();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2161</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="codeline"></td>
    <td class="lineNumber">2162</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="codeline">void APInt::toString(SmallVectorImpl<char> &Str, unsigned Radix, bool Signed,</td>
    <td class="lineNumber">2163</td>
    <td class="codeline">void APInt::toString(SmallVectorImpl<char> &Str, unsigned Radix, bool Signed,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="codeline">                     bool formatAsCLiteral, bool UpperCase) const {</td>
    <td class="lineNumber">2164</td>
    <td class="codeline">                     bool formatAsCLiteral, bool UpperCase) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="codeline">  assert((Radix == 10 || Radix == 8 || Radix == 16 || Radix == 2 ||</td>
    <td class="lineNumber">2165</td>
    <td class="codeline">  assert((Radix == 10 || Radix == 8 || Radix == 16 || Radix == 2 ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="codeline">          Radix == 36) &&</td>
    <td class="lineNumber">2166</td>
    <td class="codeline">          Radix == 36) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="codeline">         "Radix should be 2, 8, 10, 16, or 36!");</td>
    <td class="lineNumber">2167</td>
    <td class="codeline">         "Radix should be 2, 8, 10, 16, or 36!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="codeline"></td>
    <td class="lineNumber">2168</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="codeline">  const char *Prefix = "";</td>
    <td class="lineNumber">2169</td>
    <td class="codeline">  const char *Prefix = "";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="codeline">  if (formatAsCLiteral) {</td>
    <td class="lineNumber">2170</td>
    <td class="codeline">  if (formatAsCLiteral) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="codeline">    switch (Radix) {</td>
    <td class="lineNumber">2171</td>
    <td class="codeline">    switch (Radix) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="codeline">      case 2:</td>
    <td class="lineNumber">2172</td>
    <td class="codeline">      case 2:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="codeline">        // Binary literals are a non-standard extension added in gcc 4.3:</td>
    <td class="lineNumber">2173</td>
    <td class="codeline">        // Binary literals are a non-standard extension added in gcc 4.3:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="codeline">        // http://gcc.gnu.org/onlinedocs/gcc-4.3.0/gcc/Binary-constants.html</td>
    <td class="lineNumber">2174</td>
    <td class="codeline">        // http://gcc.gnu.org/onlinedocs/gcc-4.3.0/gcc/Binary-constants.html</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="codeline">        Prefix = "0b";</td>
    <td class="lineNumber">2175</td>
    <td class="codeline">        Prefix = "0b";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">2176</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="codeline">      case 8:</td>
    <td class="lineNumber">2177</td>
    <td class="codeline">      case 8:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="codeline">        Prefix = "0";</td>
    <td class="lineNumber">2178</td>
    <td class="codeline">        Prefix = "0";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">2179</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="codeline">      case 10:</td>
    <td class="lineNumber">2180</td>
    <td class="codeline">      case 10:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="codeline">        break; // No prefix</td>
    <td class="lineNumber">2181</td>
    <td class="codeline">        break; // No prefix</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="codeline">      case 16:</td>
    <td class="lineNumber">2182</td>
    <td class="codeline">      case 16:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="codeline">        Prefix = "0x";</td>
    <td class="lineNumber">2183</td>
    <td class="codeline">        Prefix = "0x";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">2184</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="codeline">      default:</td>
    <td class="lineNumber">2185</td>
    <td class="codeline">      default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="codeline">        llvm_unreachable("Invalid radix!");</td>
    <td class="lineNumber">2186</td>
    <td class="codeline">        llvm_unreachable("Invalid radix!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2187</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2188</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="codeline"></td>
    <td class="lineNumber">2189</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="codeline">  // First, check for a zero value and just short circuit the logic below.</td>
    <td class="lineNumber">2190</td>
    <td class="codeline">  // First, check for a zero value and just short circuit the logic below.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="codeline">  if (isZero()) {</td>
    <td class="lineNumber">2191</td>
    <td class="codeline">  if (isZero()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="codeline">    while (*Prefix) {</td>
    <td class="lineNumber">2192</td>
    <td class="codeline">    while (*Prefix) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="codeline">      Str.push_back(*Prefix);</td>
    <td class="lineNumber">2193</td>
    <td class="codeline">      Str.push_back(*Prefix);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="codeline">      ++Prefix;</td>
    <td class="lineNumber">2194</td>
    <td class="codeline">      ++Prefix;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="codeline">    };</td>
    <td class="lineNumber">2195</td>
    <td class="codeline">    };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="codeline">    Str.push_back('0');</td>
    <td class="lineNumber">2196</td>
    <td class="codeline">    Str.push_back('0');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">2197</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2198</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="codeline"></td>
    <td class="lineNumber">2199</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="codeline">  static const char BothDigits[] = "0123456789abcdefghijklmnopqrstuvwxyz"</td>
    <td class="lineNumber">2200</td>
    <td class="codeline">  static const char BothDigits[] = "0123456789abcdefghijklmnopqrstuvwxyz"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="codeline">                                   "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";</td>
    <td class="lineNumber">2201</td>
    <td class="codeline">                                   "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="codeline">  const char *Digits = BothDigits + (UpperCase ? 36 : 0);</td>
    <td class="lineNumber">2202</td>
    <td class="codeline">  const char *Digits = BothDigits + (UpperCase ? 36 : 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="codeline"></td>
    <td class="lineNumber">2203</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="codeline">  if (isSingleWord()) {</td>
    <td class="lineNumber">2204</td>
    <td class="codeline">  if (isSingleWord()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="codeline">    char Buffer[65];</td>
    <td class="lineNumber">2205</td>
    <td class="codeline">    char Buffer[65];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="codeline">    char *BufPtr = std::end(Buffer);</td>
    <td class="lineNumber">2206</td>
    <td class="codeline">    char *BufPtr = std::end(Buffer);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="codeline"></td>
    <td class="lineNumber">2207</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="codeline">    uint64_t N;</td>
    <td class="lineNumber">2208</td>
    <td class="codeline">    uint64_t N;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="codeline">    if (!Signed) {</td>
    <td class="lineNumber">2209</td>
    <td class="codeline">    if (!Signed) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="codeline">      N = getZExtValue();</td>
    <td class="lineNumber">2210</td>
    <td class="codeline">      N = getZExtValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">2211</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="codeline">      int64_t I = getSExtValue();</td>
    <td class="lineNumber">2212</td>
    <td class="codeline">      int64_t I = getSExtValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="codeline">      if (I >= 0) {</td>
    <td class="lineNumber">2213</td>
    <td class="codeline">      if (I >= 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="codeline">        N = I;</td>
    <td class="lineNumber">2214</td>
    <td class="codeline">        N = I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">2215</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="codeline">        Str.push_back('-');</td>
    <td class="lineNumber">2216</td>
    <td class="codeline">        Str.push_back('-');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="codeline">        N = -(uint64_t)I;</td>
    <td class="lineNumber">2217</td>
    <td class="codeline">        N = -(uint64_t)I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2218</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2219</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="codeline"></td>
    <td class="lineNumber">2220</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="codeline">    while (*Prefix) {</td>
    <td class="lineNumber">2221</td>
    <td class="codeline">    while (*Prefix) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="codeline">      Str.push_back(*Prefix);</td>
    <td class="lineNumber">2222</td>
    <td class="codeline">      Str.push_back(*Prefix);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="codeline">      ++Prefix;</td>
    <td class="lineNumber">2223</td>
    <td class="codeline">      ++Prefix;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="codeline">    };</td>
    <td class="lineNumber">2224</td>
    <td class="codeline">    };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="codeline"></td>
    <td class="lineNumber">2225</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="codeline">    while (N) {</td>
    <td class="lineNumber">2226</td>
    <td class="codeline">    while (N) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="codeline">      *--BufPtr = Digits[N % Radix];</td>
    <td class="lineNumber">2227</td>
    <td class="codeline">      *--BufPtr = Digits[N % Radix];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="codeline">      N /= Radix;</td>
    <td class="lineNumber">2228</td>
    <td class="codeline">      N /= Radix;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2229</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="codeline">    Str.append(BufPtr, std::end(Buffer));</td>
    <td class="lineNumber">2230</td>
    <td class="codeline">    Str.append(BufPtr, std::end(Buffer));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">2231</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2232</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="codeline"></td>
    <td class="lineNumber">2233</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="codeline">  APInt Tmp(*this);</td>
    <td class="lineNumber">2234</td>
    <td class="codeline">  APInt Tmp(*this);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="codeline"></td>
    <td class="lineNumber">2235</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="codeline">  if (Signed && isNegative()) {</td>
    <td class="lineNumber">2236</td>
    <td class="codeline">  if (Signed && isNegative()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="codeline">    // They want to print the signed version and it is a negative value</td>
    <td class="lineNumber">2237</td>
    <td class="codeline">    // They want to print the signed version and it is a negative value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="codeline">    // Flip the bits and add one to turn it into the equivalent positive</td>
    <td class="lineNumber">2238</td>
    <td class="codeline">    // Flip the bits and add one to turn it into the equivalent positive</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="codeline">    // value and put a '-' in the result.</td>
    <td class="lineNumber">2239</td>
    <td class="codeline">    // value and put a '-' in the result.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="codeline">    Tmp.negate();</td>
    <td class="lineNumber">2240</td>
    <td class="codeline">    Tmp.negate();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="codeline">    Str.push_back('-');</td>
    <td class="lineNumber">2241</td>
    <td class="codeline">    Str.push_back('-');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2242</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="codeline"></td>
    <td class="lineNumber">2243</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="codeline">  while (*Prefix) {</td>
    <td class="lineNumber">2244</td>
    <td class="codeline">  while (*Prefix) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="codeline">    Str.push_back(*Prefix);</td>
    <td class="lineNumber">2245</td>
    <td class="codeline">    Str.push_back(*Prefix);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="codeline">    ++Prefix;</td>
    <td class="lineNumber">2246</td>
    <td class="codeline">    ++Prefix;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">2247</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="codeline"></td>
    <td class="lineNumber">2248</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="codeline">  // We insert the digits backward, then reverse them to get the right order.</td>
    <td class="lineNumber">2249</td>
    <td class="codeline">  // We insert the digits backward, then reverse them to get the right order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="codeline">  unsigned StartDig = Str.size();</td>
    <td class="lineNumber">2250</td>
    <td class="codeline">  unsigned StartDig = Str.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="codeline"></td>
    <td class="lineNumber">2251</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="codeline">  // For the 2, 8 and 16 bit cases, we can just shift instead of divide</td>
    <td class="lineNumber">2252</td>
    <td class="codeline">  // For the 2, 8 and 16 bit cases, we can just shift instead of divide</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="codeline">  // because the number of bits per digit (1, 3 and 4 respectively) divides</td>
    <td class="lineNumber">2253</td>
    <td class="codeline">  // because the number of bits per digit (1, 3 and 4 respectively) divides</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="codeline">  // equally.  We just shift until the value is zero.</td>
    <td class="lineNumber">2254</td>
    <td class="codeline">  // equally.  We just shift until the value is zero.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="codeline">  if (Radix == 2 || Radix == 8 || Radix == 16) {</td>
    <td class="lineNumber">2255</td>
    <td class="codeline">  if (Radix == 2 || Radix == 8 || Radix == 16) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="codeline">    // Just shift tmp right for each digit width until it becomes zero</td>
    <td class="lineNumber">2256</td>
    <td class="codeline">    // Just shift tmp right for each digit width until it becomes zero</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="codeline">    unsigned ShiftAmt = (Radix == 16 ? 4 : (Radix == 8 ? 3 : 1));</td>
    <td class="lineNumber">2257</td>
    <td class="codeline">    unsigned ShiftAmt = (Radix == 16 ? 4 : (Radix == 8 ? 3 : 1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="codeline">    unsigned MaskAmt = Radix - 1;</td>
    <td class="lineNumber">2258</td>
    <td class="codeline">    unsigned MaskAmt = Radix - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="codeline"></td>
    <td class="lineNumber">2259</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="codeline">    while (Tmp.getBoolValue()) {</td>
    <td class="lineNumber">2260</td>
    <td class="codeline">    while (Tmp.getBoolValue()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="codeline">      unsigned Digit = unsigned(Tmp.getRawData()[0]) & MaskAmt;</td>
    <td class="lineNumber">2261</td>
    <td class="codeline">      unsigned Digit = unsigned(Tmp.getRawData()[0]) & MaskAmt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="codeline">      Str.push_back(Digits[Digit]);</td>
    <td class="lineNumber">2262</td>
    <td class="codeline">      Str.push_back(Digits[Digit]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="codeline">      Tmp.lshrInPlace(ShiftAmt);</td>
    <td class="lineNumber">2263</td>
    <td class="codeline">      Tmp.lshrInPlace(ShiftAmt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2264</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">2265</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="codeline">    while (Tmp.getBoolValue()) {</td>
    <td class="lineNumber">2266</td>
    <td class="codeline">    while (Tmp.getBoolValue()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="codeline">      uint64_t Digit;</td>
    <td class="lineNumber">2267</td>
    <td class="codeline">      uint64_t Digit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="codeline">      udivrem(Tmp, Radix, Tmp, Digit);</td>
    <td class="lineNumber">2268</td>
    <td class="codeline">      udivrem(Tmp, Radix, Tmp, Digit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="codeline">      assert(Digit < Radix && "divide failed");</td>
    <td class="lineNumber">2269</td>
    <td class="codeline">      assert(Digit < Radix && "divide failed");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="codeline">      Str.push_back(Digits[Digit]);</td>
    <td class="lineNumber">2270</td>
    <td class="codeline">      Str.push_back(Digits[Digit]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2271</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2272</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="codeline"></td>
    <td class="lineNumber">2273</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="codeline">  // Reverse the digits before returning.</td>
    <td class="lineNumber">2274</td>
    <td class="codeline">  // Reverse the digits before returning.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="codeline">  std::reverse(Str.begin()+StartDig, Str.end());</td>
    <td class="lineNumber">2275</td>
    <td class="codeline">  std::reverse(Str.begin()+StartDig, Str.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2276</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="codeline"></td>
    <td class="lineNumber">2277</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="codeline">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td class="lineNumber">2278</td>
    <td class="codeline">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="codeline">LLVM_DUMP_METHOD void APInt::dump() const {</td>
    <td class="lineNumber">2279</td>
    <td class="codeline">LLVM_DUMP_METHOD void APInt::dump() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="codeline">  SmallString<40> S, U;</td>
    <td class="lineNumber">2280</td>
    <td class="codeline">  SmallString<40> S, U;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="codeline">  this->toStringUnsigned(U);</td>
    <td class="lineNumber">2281</td>
    <td class="codeline">  this->toStringUnsigned(U);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="codeline">  this->toStringSigned(S);</td>
    <td class="lineNumber">2282</td>
    <td class="codeline">  this->toStringSigned(S);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="codeline">  dbgs() << "APInt(" << BitWidth << "b, "</td>
    <td class="lineNumber">2283</td>
    <td class="codeline">  dbgs() << "APInt(" << BitWidth << "b, "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="codeline">         << U << "u " << S << "s)\n";</td>
    <td class="lineNumber">2284</td>
    <td class="codeline">         << U << "u " << S << "s)\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2285</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">2286</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="codeline"></td>
    <td class="lineNumber">2287</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="codeline">void APInt::print(raw_ostream &OS, bool isSigned) const {</td>
    <td class="lineNumber">2288</td>
    <td class="codeline">void APInt::print(raw_ostream &OS, bool isSigned) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="codeline">  SmallString<40> S;</td>
    <td class="lineNumber">2289</td>
    <td class="codeline">  SmallString<40> S;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="codeline">  this->toString(S, 10, isSigned, /* formatAsCLiteral = */false);</td>
    <td class="lineNumber">2290</td>
    <td class="codeline">  this->toString(S, 10, isSigned, /* formatAsCLiteral = */false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="codeline">  OS << S;</td>
    <td class="lineNumber">2291</td>
    <td class="codeline">  OS << S;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2292</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="codeline"></td>
    <td class="lineNumber">2293</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="codeline">// This implements a variety of operations on a representation of</td>
    <td class="lineNumber">2294</td>
    <td class="codeline">// This implements a variety of operations on a representation of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="codeline">// arbitrary precision, two's-complement, bignum integer values.</td>
    <td class="lineNumber">2295</td>
    <td class="codeline">// arbitrary precision, two's-complement, bignum integer values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="codeline"></td>
    <td class="lineNumber">2296</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="codeline">// Assumed by lowHalf, highHalf, partMSB and partLSB.  A fairly safe</td>
    <td class="lineNumber">2297</td>
    <td class="codeline">// Assumed by lowHalf, highHalf, partMSB and partLSB.  A fairly safe</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="codeline">// and unrestricting assumption.</td>
    <td class="lineNumber">2298</td>
    <td class="codeline">// and unrestricting assumption.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="codeline">static_assert(APInt::APINT_BITS_PER_WORD % 2 == 0,</td>
    <td class="lineNumber">2299</td>
    <td class="codeline">static_assert(APInt::APINT_BITS_PER_WORD % 2 == 0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="codeline">              "Part width must be divisible by 2!");</td>
    <td class="lineNumber">2300</td>
    <td class="codeline">              "Part width must be divisible by 2!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="codeline"></td>
    <td class="lineNumber">2301</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="codeline">// Returns the integer part with the least significant BITS set.</td>
    <td class="lineNumber">2302</td>
    <td class="codeline">// Returns the integer part with the least significant BITS set.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="codeline">// BITS cannot be zero.</td>
    <td class="lineNumber">2303</td>
    <td class="codeline">// BITS cannot be zero.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="codeline">static inline APInt::WordType lowBitMask(unsigned bits) {</td>
    <td class="lineNumber">2304</td>
    <td class="codeline">static inline APInt::WordType lowBitMask(unsigned bits) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="codeline">  assert(bits != 0 && bits <= APInt::APINT_BITS_PER_WORD);</td>
    <td class="lineNumber">2305</td>
    <td class="codeline">  assert(bits != 0 && bits <= APInt::APINT_BITS_PER_WORD);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="codeline">  return ~(APInt::WordType) 0 >> (APInt::APINT_BITS_PER_WORD - bits);</td>
    <td class="lineNumber">2306</td>
    <td class="codeline">  return ~(APInt::WordType) 0 >> (APInt::APINT_BITS_PER_WORD - bits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2307</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="codeline"></td>
    <td class="lineNumber">2308</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="codeline">/// Returns the value of the lower half of PART.</td>
    <td class="lineNumber">2309</td>
    <td class="codeline">/// Returns the value of the lower half of PART.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="codeline">static inline APInt::WordType lowHalf(APInt::WordType part) {</td>
    <td class="lineNumber">2310</td>
    <td class="codeline">static inline APInt::WordType lowHalf(APInt::WordType part) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="codeline">  return part & lowBitMask(APInt::APINT_BITS_PER_WORD / 2);</td>
    <td class="lineNumber">2311</td>
    <td class="codeline">  return part & lowBitMask(APInt::APINT_BITS_PER_WORD / 2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2312</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="codeline"></td>
    <td class="lineNumber">2313</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="codeline">/// Returns the value of the upper half of PART.</td>
    <td class="lineNumber">2314</td>
    <td class="codeline">/// Returns the value of the upper half of PART.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="codeline">static inline APInt::WordType highHalf(APInt::WordType part) {</td>
    <td class="lineNumber">2315</td>
    <td class="codeline">static inline APInt::WordType highHalf(APInt::WordType part) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="codeline">  return part >> (APInt::APINT_BITS_PER_WORD / 2);</td>
    <td class="lineNumber">2316</td>
    <td class="codeline">  return part >> (APInt::APINT_BITS_PER_WORD / 2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2317</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="codeline"></td>
    <td class="lineNumber">2318</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="codeline">/// Sets the least significant part of a bignum to the input value, and zeroes</td>
    <td class="lineNumber">2319</td>
    <td class="codeline">/// Sets the least significant part of a bignum to the input value, and zeroes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="codeline">/// out higher parts.</td>
    <td class="lineNumber">2320</td>
    <td class="codeline">/// out higher parts.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="codeline">void APInt::tcSet(WordType *dst, WordType part, unsigned parts) {</td>
    <td class="lineNumber">2321</td>
    <td class="codeline">void APInt::tcSet(WordType *dst, WordType part, unsigned parts) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="codeline">  assert(parts > 0);</td>
    <td class="lineNumber">2322</td>
    <td class="codeline">  assert(parts > 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="codeline">  dst[0] = part;</td>
    <td class="lineNumber">2323</td>
    <td class="codeline">  dst[0] = part;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="codeline">  for (unsigned i = 1; i < parts; i++)</td>
    <td class="lineNumber">2324</td>
    <td class="codeline">  for (unsigned i = 1; i < parts; i++)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="codeline">    dst[i] = 0;</td>
    <td class="lineNumber">2325</td>
    <td class="codeline">    dst[i] = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2326</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="codeline"></td>
    <td class="lineNumber">2327</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="codeline">/// Assign one bignum to another.</td>
    <td class="lineNumber">2328</td>
    <td class="codeline">/// Assign one bignum to another.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="codeline">void APInt::tcAssign(WordType *dst, const WordType *src, unsigned parts) {</td>
    <td class="lineNumber">2329</td>
    <td class="codeline">void APInt::tcAssign(WordType *dst, const WordType *src, unsigned parts) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="codeline">  for (unsigned i = 0; i < parts; i++)</td>
    <td class="lineNumber">2330</td>
    <td class="codeline">  for (unsigned i = 0; i < parts; i++)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="codeline">    dst[i] = src[i];</td>
    <td class="lineNumber">2331</td>
    <td class="codeline">    dst[i] = src[i];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2332</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="codeline"></td>
    <td class="lineNumber">2333</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="codeline">/// Returns true if a bignum is zero, false otherwise.</td>
    <td class="lineNumber">2334</td>
    <td class="codeline">/// Returns true if a bignum is zero, false otherwise.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="codeline">bool APInt::tcIsZero(const WordType *src, unsigned parts) {</td>
    <td class="lineNumber">2335</td>
    <td class="codeline">bool APInt::tcIsZero(const WordType *src, unsigned parts) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="codeline">  for (unsigned i = 0; i < parts; i++)</td>
    <td class="lineNumber">2336</td>
    <td class="codeline">  for (unsigned i = 0; i < parts; i++)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="codeline">    if (src[i])</td>
    <td class="lineNumber">2337</td>
    <td class="codeline">    if (src[i])</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">2338</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="codeline"></td>
    <td class="lineNumber">2339</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">2340</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2341</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="codeline"></td>
    <td class="lineNumber">2342</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="codeline">/// Extract the given bit of a bignum; returns 0 or 1.</td>
    <td class="lineNumber">2343</td>
    <td class="codeline">/// Extract the given bit of a bignum; returns 0 or 1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="codeline">int APInt::tcExtractBit(const WordType *parts, unsigned bit) {</td>
    <td class="lineNumber">2344</td>
    <td class="codeline">int APInt::tcExtractBit(const WordType *parts, unsigned bit) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="codeline">  return (parts[whichWord(bit)] & maskBit(bit)) != 0;</td>
    <td class="lineNumber">2345</td>
    <td class="codeline">  return (parts[whichWord(bit)] & maskBit(bit)) != 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2346</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="codeline"></td>
    <td class="lineNumber">2347</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="codeline">/// Set the given bit of a bignum.</td>
    <td class="lineNumber">2348</td>
    <td class="codeline">/// Set the given bit of a bignum.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="codeline">void APInt::tcSetBit(WordType *parts, unsigned bit) {</td>
    <td class="lineNumber">2349</td>
    <td class="codeline">void APInt::tcSetBit(WordType *parts, unsigned bit) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="codeline">  parts[whichWord(bit)] |= maskBit(bit);</td>
    <td class="lineNumber">2350</td>
    <td class="codeline">  parts[whichWord(bit)] |= maskBit(bit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2351</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="codeline"></td>
    <td class="lineNumber">2352</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="codeline">/// Clears the given bit of a bignum.</td>
    <td class="lineNumber">2353</td>
    <td class="codeline">/// Clears the given bit of a bignum.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="codeline">void APInt::tcClearBit(WordType *parts, unsigned bit) {</td>
    <td class="lineNumber">2354</td>
    <td class="codeline">void APInt::tcClearBit(WordType *parts, unsigned bit) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="codeline">  parts[whichWord(bit)] &= ~maskBit(bit);</td>
    <td class="lineNumber">2355</td>
    <td class="codeline">  parts[whichWord(bit)] &= ~maskBit(bit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2356</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="codeline"></td>
    <td class="lineNumber">2357</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="codeline">/// Returns the bit number of the least significant set bit of a number.  If the</td>
    <td class="lineNumber">2358</td>
    <td class="codeline">/// Returns the bit number of the least significant set bit of a number.  If the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="codeline">/// input number has no bits set UINT_MAX is returned.</td>
    <td class="lineNumber">2359</td>
    <td class="codeline">/// input number has no bits set UINT_MAX is returned.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="codeline">unsigned APInt::tcLSB(const WordType *parts, unsigned n) {</td>
    <td class="lineNumber">2360</td>
    <td class="codeline">unsigned APInt::tcLSB(const WordType *parts, unsigned n) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="codeline">  for (unsigned i = 0; i < n; i++) {</td>
    <td class="lineNumber">2361</td>
    <td class="codeline">  for (unsigned i = 0; i < n; i++) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="codeline">    if (parts[i] != 0) {</td>
    <td class="lineNumber">2362</td>
    <td class="codeline">    if (parts[i] != 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="codeline">      unsigned lsb = llvm::countr_zero(parts[i]);</td>
    <td class="lineNumber">2363</td>
    <td class="codeline">      unsigned lsb = llvm::countr_zero(parts[i]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="codeline">      return lsb + i * APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">2364</td>
    <td class="codeline">      return lsb + i * APINT_BITS_PER_WORD;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2365</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2366</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="codeline"></td>
    <td class="lineNumber">2367</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="codeline">  return UINT_MAX;</td>
    <td class="lineNumber">2368</td>
    <td class="codeline">  return UINT_MAX;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2369</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="codeline"></td>
    <td class="lineNumber">2370</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="codeline">/// Returns the bit number of the most significant set bit of a number.</td>
    <td class="lineNumber">2371</td>
    <td class="codeline">/// Returns the bit number of the most significant set bit of a number.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="codeline">/// If the input number has no bits set UINT_MAX is returned.</td>
    <td class="lineNumber">2372</td>
    <td class="codeline">/// If the input number has no bits set UINT_MAX is returned.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="codeline">unsigned APInt::tcMSB(const WordType *parts, unsigned n) {</td>
    <td class="lineNumber">2373</td>
    <td class="codeline">unsigned APInt::tcMSB(const WordType *parts, unsigned n) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="codeline">  do {</td>
    <td class="lineNumber">2374</td>
    <td class="codeline">  do {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="codeline">    --n;</td>
    <td class="lineNumber">2375</td>
    <td class="codeline">    --n;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="codeline"></td>
    <td class="lineNumber">2376</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="codeline">    if (parts[n] != 0) {</td>
    <td class="lineNumber">2377</td>
    <td class="codeline">    if (parts[n] != 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="codeline">      static_assert(sizeof(parts[n]) <= sizeof(uint64_t));</td>
    <td class="lineNumber">2378</td>
    <td class="codeline">      static_assert(sizeof(parts[n]) <= sizeof(uint64_t));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="codeline">      unsigned msb = llvm::Log2_64(parts[n]);</td>
    <td class="lineNumber">2379</td>
    <td class="codeline">      unsigned msb = llvm::Log2_64(parts[n]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="codeline"></td>
    <td class="lineNumber">2380</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="codeline">      return msb + n * APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">2381</td>
    <td class="codeline">      return msb + n * APINT_BITS_PER_WORD;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2382</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="codeline">  } while (n);</td>
    <td class="lineNumber">2383</td>
    <td class="codeline">  } while (n);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="codeline"></td>
    <td class="lineNumber">2384</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="codeline">  return UINT_MAX;</td>
    <td class="lineNumber">2385</td>
    <td class="codeline">  return UINT_MAX;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2386</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="codeline"></td>
    <td class="lineNumber">2387</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="codeline">/// Copy the bit vector of width srcBITS from SRC, starting at bit srcLSB, to</td>
    <td class="lineNumber">2388</td>
    <td class="codeline">/// Copy the bit vector of width srcBITS from SRC, starting at bit srcLSB, to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="codeline">/// DST, of dstCOUNT parts, such that the bit srcLSB becomes the least</td>
    <td class="lineNumber">2389</td>
    <td class="codeline">/// DST, of dstCOUNT parts, such that the bit srcLSB becomes the least</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="codeline">/// significant bit of DST.  All high bits above srcBITS in DST are zero-filled.</td>
    <td class="lineNumber">2390</td>
    <td class="codeline">/// significant bit of DST.  All high bits above srcBITS in DST are zero-filled.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="codeline">/// */</td>
    <td class="lineNumber">2391</td>
    <td class="codeline">/// */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="codeline">void</td>
    <td class="lineNumber">2392</td>
    <td class="codeline">void</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="codeline">APInt::tcExtract(WordType *dst, unsigned dstCount, const WordType *src,</td>
    <td class="lineNumber">2393</td>
    <td class="codeline">APInt::tcExtract(WordType *dst, unsigned dstCount, const WordType *src,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="codeline">                 unsigned srcBits, unsigned srcLSB) {</td>
    <td class="lineNumber">2394</td>
    <td class="codeline">                 unsigned srcBits, unsigned srcLSB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="codeline">  unsigned dstParts = (srcBits + APINT_BITS_PER_WORD - 1) / APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">2395</td>
    <td class="codeline">  unsigned dstParts = (srcBits + APINT_BITS_PER_WORD - 1) / APINT_BITS_PER_WORD;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="codeline">  assert(dstParts <= dstCount);</td>
    <td class="lineNumber">2396</td>
    <td class="codeline">  assert(dstParts <= dstCount);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="codeline"></td>
    <td class="lineNumber">2397</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="codeline">  unsigned firstSrcPart = srcLSB / APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">2398</td>
    <td class="codeline">  unsigned firstSrcPart = srcLSB / APINT_BITS_PER_WORD;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="codeline">  tcAssign(dst, src + firstSrcPart, dstParts);</td>
    <td class="lineNumber">2399</td>
    <td class="codeline">  tcAssign(dst, src + firstSrcPart, dstParts);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="codeline"></td>
    <td class="lineNumber">2400</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="codeline">  unsigned shift = srcLSB % APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">2401</td>
    <td class="codeline">  unsigned shift = srcLSB % APINT_BITS_PER_WORD;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="codeline">  tcShiftRight(dst, dstParts, shift);</td>
    <td class="lineNumber">2402</td>
    <td class="codeline">  tcShiftRight(dst, dstParts, shift);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="codeline"></td>
    <td class="lineNumber">2403</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="codeline">  // We now have (dstParts * APINT_BITS_PER_WORD - shift) bits from SRC</td>
    <td class="lineNumber">2404</td>
    <td class="codeline">  // We now have (dstParts * APINT_BITS_PER_WORD - shift) bits from SRC</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="codeline">  // in DST.  If this is less that srcBits, append the rest, else</td>
    <td class="lineNumber">2405</td>
    <td class="codeline">  // in DST.  If this is less that srcBits, append the rest, else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="codeline">  // clear the high bits.</td>
    <td class="lineNumber">2406</td>
    <td class="codeline">  // clear the high bits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="codeline">  unsigned n = dstParts * APINT_BITS_PER_WORD - shift;</td>
    <td class="lineNumber">2407</td>
    <td class="codeline">  unsigned n = dstParts * APINT_BITS_PER_WORD - shift;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="codeline">  if (n < srcBits) {</td>
    <td class="lineNumber">2408</td>
    <td class="codeline">  if (n < srcBits) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="codeline">    WordType mask = lowBitMask (srcBits - n);</td>
    <td class="lineNumber">2409</td>
    <td class="codeline">    WordType mask = lowBitMask (srcBits - n);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="codeline">    dst[dstParts - 1] |= ((src[firstSrcPart + dstParts] & mask)</td>
    <td class="lineNumber">2410</td>
    <td class="codeline">    dst[dstParts - 1] |= ((src[firstSrcPart + dstParts] & mask)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="codeline">                          << n % APINT_BITS_PER_WORD);</td>
    <td class="lineNumber">2411</td>
    <td class="codeline">                          << n % APINT_BITS_PER_WORD);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="codeline">  } else if (n > srcBits) {</td>
    <td class="lineNumber">2412</td>
    <td class="codeline">  } else if (n > srcBits) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="codeline">    if (srcBits % APINT_BITS_PER_WORD)</td>
    <td class="lineNumber">2413</td>
    <td class="codeline">    if (srcBits % APINT_BITS_PER_WORD)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="codeline">      dst[dstParts - 1] &= lowBitMask (srcBits % APINT_BITS_PER_WORD);</td>
    <td class="lineNumber">2414</td>
    <td class="codeline">      dst[dstParts - 1] &= lowBitMask (srcBits % APINT_BITS_PER_WORD);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2415</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="codeline"></td>
    <td class="lineNumber">2416</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="codeline">  // Clear high parts.</td>
    <td class="lineNumber">2417</td>
    <td class="codeline">  // Clear high parts.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="codeline">  while (dstParts < dstCount)</td>
    <td class="lineNumber">2418</td>
    <td class="codeline">  while (dstParts < dstCount)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="codeline">    dst[dstParts++] = 0;</td>
    <td class="lineNumber">2419</td>
    <td class="codeline">    dst[dstParts++] = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2420</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="codeline"></td>
    <td class="lineNumber">2421</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="codeline">//// DST += RHS + C where C is zero or one.  Returns the carry flag.</td>
    <td class="lineNumber">2422</td>
    <td class="codeline">//// DST += RHS + C where C is zero or one.  Returns the carry flag.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="codeline">APInt::WordType APInt::tcAdd(WordType *dst, const WordType *rhs,</td>
    <td class="lineNumber">2423</td>
    <td class="codeline">APInt::WordType APInt::tcAdd(WordType *dst, const WordType *rhs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="codeline">                             WordType c, unsigned parts) {</td>
    <td class="lineNumber">2424</td>
    <td class="codeline">                             WordType c, unsigned parts) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="codeline">  assert(c <= 1);</td>
    <td class="lineNumber">2425</td>
    <td class="codeline">  assert(c <= 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="codeline"></td>
    <td class="lineNumber">2426</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="codeline">  for (unsigned i = 0; i < parts; i++) {</td>
    <td class="lineNumber">2427</td>
    <td class="codeline">  for (unsigned i = 0; i < parts; i++) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="codeline">    WordType l = dst[i];</td>
    <td class="lineNumber">2428</td>
    <td class="codeline">    WordType l = dst[i];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="codeline">    if (c) {</td>
    <td class="lineNumber">2429</td>
    <td class="codeline">    if (c) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="codeline">      dst[i] += rhs[i] + 1;</td>
    <td class="lineNumber">2430</td>
    <td class="codeline">      dst[i] += rhs[i] + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="codeline">      c = (dst[i] <= l);</td>
    <td class="lineNumber">2431</td>
    <td class="codeline">      c = (dst[i] <= l);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">2432</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="codeline">      dst[i] += rhs[i];</td>
    <td class="lineNumber">2433</td>
    <td class="codeline">      dst[i] += rhs[i];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="codeline">      c = (dst[i] < l);</td>
    <td class="lineNumber">2434</td>
    <td class="codeline">      c = (dst[i] < l);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2435</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2436</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="codeline"></td>
    <td class="lineNumber">2437</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="codeline">  return c;</td>
    <td class="lineNumber">2438</td>
    <td class="codeline">  return c;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2439</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="codeline"></td>
    <td class="lineNumber">2440</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="codeline">/// This function adds a single "word" integer, src, to the multiple</td>
    <td class="lineNumber">2441</td>
    <td class="codeline">/// This function adds a single "word" integer, src, to the multiple</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="codeline">/// "word" integer array, dst[]. dst[] is modified to reflect the addition and</td>
    <td class="lineNumber">2442</td>
    <td class="codeline">/// "word" integer array, dst[]. dst[] is modified to reflect the addition and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="codeline">/// 1 is returned if there is a carry out, otherwise 0 is returned.</td>
    <td class="lineNumber">2443</td>
    <td class="codeline">/// 1 is returned if there is a carry out, otherwise 0 is returned.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="codeline">/// @returns the carry of the addition.</td>
    <td class="lineNumber">2444</td>
    <td class="codeline">/// @returns the carry of the addition.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="codeline">APInt::WordType APInt::tcAddPart(WordType *dst, WordType src,</td>
    <td class="lineNumber">2445</td>
    <td class="codeline">APInt::WordType APInt::tcAddPart(WordType *dst, WordType src,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="codeline">                                 unsigned parts) {</td>
    <td class="lineNumber">2446</td>
    <td class="codeline">                                 unsigned parts) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="codeline">  for (unsigned i = 0; i < parts; ++i) {</td>
    <td class="lineNumber">2447</td>
    <td class="codeline">  for (unsigned i = 0; i < parts; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="codeline">    dst[i] += src;</td>
    <td class="lineNumber">2448</td>
    <td class="codeline">    dst[i] += src;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="codeline">    if (dst[i] >= src)</td>
    <td class="lineNumber">2449</td>
    <td class="codeline">    if (dst[i] >= src)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="codeline">      return 0; // No need to carry so exit early.</td>
    <td class="lineNumber">2450</td>
    <td class="codeline">      return 0; // No need to carry so exit early.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="codeline">    src = 1; // Carry one to next digit.</td>
    <td class="lineNumber">2451</td>
    <td class="codeline">    src = 1; // Carry one to next digit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2452</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="codeline"></td>
    <td class="lineNumber">2453</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="codeline">  return 1;</td>
    <td class="lineNumber">2454</td>
    <td class="codeline">  return 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2455</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="codeline"></td>
    <td class="lineNumber">2456</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="codeline">/// DST -= RHS + C where C is zero or one.  Returns the carry flag.</td>
    <td class="lineNumber">2457</td>
    <td class="codeline">/// DST -= RHS + C where C is zero or one.  Returns the carry flag.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="codeline">APInt::WordType APInt::tcSubtract(WordType *dst, const WordType *rhs,</td>
    <td class="lineNumber">2458</td>
    <td class="codeline">APInt::WordType APInt::tcSubtract(WordType *dst, const WordType *rhs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="codeline">                                  WordType c, unsigned parts) {</td>
    <td class="lineNumber">2459</td>
    <td class="codeline">                                  WordType c, unsigned parts) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="codeline">  assert(c <= 1);</td>
    <td class="lineNumber">2460</td>
    <td class="codeline">  assert(c <= 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="codeline"></td>
    <td class="lineNumber">2461</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="codeline">  for (unsigned i = 0; i < parts; i++) {</td>
    <td class="lineNumber">2462</td>
    <td class="codeline">  for (unsigned i = 0; i < parts; i++) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="codeline">    WordType l = dst[i];</td>
    <td class="lineNumber">2463</td>
    <td class="codeline">    WordType l = dst[i];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="codeline">    if (c) {</td>
    <td class="lineNumber">2464</td>
    <td class="codeline">    if (c) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="codeline">      dst[i] -= rhs[i] + 1;</td>
    <td class="lineNumber">2465</td>
    <td class="codeline">      dst[i] -= rhs[i] + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="codeline">      c = (dst[i] >= l);</td>
    <td class="lineNumber">2466</td>
    <td class="codeline">      c = (dst[i] >= l);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">2467</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="codeline">      dst[i] -= rhs[i];</td>
    <td class="lineNumber">2468</td>
    <td class="codeline">      dst[i] -= rhs[i];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="codeline">      c = (dst[i] > l);</td>
    <td class="lineNumber">2469</td>
    <td class="codeline">      c = (dst[i] > l);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2470</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2471</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class="codeline"></td>
    <td class="lineNumber">2472</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="codeline">  return c;</td>
    <td class="lineNumber">2473</td>
    <td class="codeline">  return c;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2474</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2475</td>
    <td class="codeline"></td>
    <td class="lineNumber">2475</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2476</td>
    <td class="codeline">/// This function subtracts a single "word" (64-bit word), src, from</td>
    <td class="lineNumber">2476</td>
    <td class="codeline">/// This function subtracts a single "word" (64-bit word), src, from</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2477</td>
    <td class="codeline">/// the multi-word integer array, dst[], propagating the borrowed 1 value until</td>
    <td class="lineNumber">2477</td>
    <td class="codeline">/// the multi-word integer array, dst[], propagating the borrowed 1 value until</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2478</td>
    <td class="codeline">/// no further borrowing is needed or it runs out of "words" in dst.  The result</td>
    <td class="lineNumber">2478</td>
    <td class="codeline">/// no further borrowing is needed or it runs out of "words" in dst.  The result</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2479</td>
    <td class="codeline">/// is 1 if "borrowing" exhausted the digits in dst, or 0 if dst was not</td>
    <td class="lineNumber">2479</td>
    <td class="codeline">/// is 1 if "borrowing" exhausted the digits in dst, or 0 if dst was not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2480</td>
    <td class="codeline">/// exhausted. In other words, if src > dst then this function returns 1,</td>
    <td class="lineNumber">2480</td>
    <td class="codeline">/// exhausted. In other words, if src > dst then this function returns 1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2481</td>
    <td class="codeline">/// otherwise 0.</td>
    <td class="lineNumber">2481</td>
    <td class="codeline">/// otherwise 0.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2482</td>
    <td class="codeline">/// @returns the borrow out of the subtraction</td>
    <td class="lineNumber">2482</td>
    <td class="codeline">/// @returns the borrow out of the subtraction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2483</td>
    <td class="codeline">APInt::WordType APInt::tcSubtractPart(WordType *dst, WordType src,</td>
    <td class="lineNumber">2483</td>
    <td class="codeline">APInt::WordType APInt::tcSubtractPart(WordType *dst, WordType src,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2484</td>
    <td class="codeline">                                      unsigned parts) {</td>
    <td class="lineNumber">2484</td>
    <td class="codeline">                                      unsigned parts) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2485</td>
    <td class="codeline">  for (unsigned i = 0; i < parts; ++i) {</td>
    <td class="lineNumber">2485</td>
    <td class="codeline">  for (unsigned i = 0; i < parts; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2486</td>
    <td class="codeline">    WordType Dst = dst[i];</td>
    <td class="lineNumber">2486</td>
    <td class="codeline">    WordType Dst = dst[i];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2487</td>
    <td class="codeline">    dst[i] -= src;</td>
    <td class="lineNumber">2487</td>
    <td class="codeline">    dst[i] -= src;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2488</td>
    <td class="codeline">    if (src <= Dst)</td>
    <td class="lineNumber">2488</td>
    <td class="codeline">    if (src <= Dst)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2489</td>
    <td class="codeline">      return 0; // No need to borrow so exit early.</td>
    <td class="lineNumber">2489</td>
    <td class="codeline">      return 0; // No need to borrow so exit early.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2490</td>
    <td class="codeline">    src = 1; // We have to "borrow 1" from next "word"</td>
    <td class="lineNumber">2490</td>
    <td class="codeline">    src = 1; // We have to "borrow 1" from next "word"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2491</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2491</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2492</td>
    <td class="codeline"></td>
    <td class="lineNumber">2492</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2493</td>
    <td class="codeline">  return 1;</td>
    <td class="lineNumber">2493</td>
    <td class="codeline">  return 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2494</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2494</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2495</td>
    <td class="codeline"></td>
    <td class="lineNumber">2495</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2496</td>
    <td class="codeline">/// Negate a bignum in-place.</td>
    <td class="lineNumber">2496</td>
    <td class="codeline">/// Negate a bignum in-place.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2497</td>
    <td class="codeline">void APInt::tcNegate(WordType *dst, unsigned parts) {</td>
    <td class="lineNumber">2497</td>
    <td class="codeline">void APInt::tcNegate(WordType *dst, unsigned parts) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2498</td>
    <td class="codeline">  tcComplement(dst, parts);</td>
    <td class="lineNumber">2498</td>
    <td class="codeline">  tcComplement(dst, parts);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2499</td>
    <td class="codeline">  tcIncrement(dst, parts);</td>
    <td class="lineNumber">2499</td>
    <td class="codeline">  tcIncrement(dst, parts);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2500</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2500</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2501</td>
    <td class="codeline"></td>
    <td class="lineNumber">2501</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2502</td>
    <td class="codeline">/// DST += SRC * MULTIPLIER + CARRY   if add is true</td>
    <td class="lineNumber">2502</td>
    <td class="codeline">/// DST += SRC * MULTIPLIER + CARRY   if add is true</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2503</td>
    <td class="codeline">/// DST  = SRC * MULTIPLIER + CARRY   if add is false</td>
    <td class="lineNumber">2503</td>
    <td class="codeline">/// DST  = SRC * MULTIPLIER + CARRY   if add is false</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2504</td>
    <td class="codeline">/// Requires 0 <= DSTPARTS <= SRCPARTS + 1.  If DST overlaps SRC</td>
    <td class="lineNumber">2504</td>
    <td class="codeline">/// Requires 0 <= DSTPARTS <= SRCPARTS + 1.  If DST overlaps SRC</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2505</td>
    <td class="codeline">/// they must start at the same point, i.e. DST == SRC.</td>
    <td class="lineNumber">2505</td>
    <td class="codeline">/// they must start at the same point, i.e. DST == SRC.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2506</td>
    <td class="codeline">/// If DSTPARTS == SRCPARTS + 1 no overflow occurs and zero is</td>
    <td class="lineNumber">2506</td>
    <td class="codeline">/// If DSTPARTS == SRCPARTS + 1 no overflow occurs and zero is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2507</td>
    <td class="codeline">/// returned.  Otherwise DST is filled with the least significant</td>
    <td class="lineNumber">2507</td>
    <td class="codeline">/// returned.  Otherwise DST is filled with the least significant</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2508</td>
    <td class="codeline">/// DSTPARTS parts of the result, and if all of the omitted higher</td>
    <td class="lineNumber">2508</td>
    <td class="codeline">/// DSTPARTS parts of the result, and if all of the omitted higher</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2509</td>
    <td class="codeline">/// parts were zero return zero, otherwise overflow occurred and</td>
    <td class="lineNumber">2509</td>
    <td class="codeline">/// parts were zero return zero, otherwise overflow occurred and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2510</td>
    <td class="codeline">/// return one.</td>
    <td class="lineNumber">2510</td>
    <td class="codeline">/// return one.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2511</td>
    <td class="codeline">int APInt::tcMultiplyPart(WordType *dst, const WordType *src,</td>
    <td class="lineNumber">2511</td>
    <td class="codeline">int APInt::tcMultiplyPart(WordType *dst, const WordType *src,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2512</td>
    <td class="codeline">                          WordType multiplier, WordType carry,</td>
    <td class="lineNumber">2512</td>
    <td class="codeline">                          WordType multiplier, WordType carry,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2513</td>
    <td class="codeline">                          unsigned srcParts, unsigned dstParts,</td>
    <td class="lineNumber">2513</td>
    <td class="codeline">                          unsigned srcParts, unsigned dstParts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2514</td>
    <td class="codeline">                          bool add) {</td>
    <td class="lineNumber">2514</td>
    <td class="codeline">                          bool add) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2515</td>
    <td class="codeline">  // Otherwise our writes of DST kill our later reads of SRC.</td>
    <td class="lineNumber">2515</td>
    <td class="codeline">  // Otherwise our writes of DST kill our later reads of SRC.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2516</td>
    <td class="codeline">  assert(dst <= src || dst >= src + srcParts);</td>
    <td class="lineNumber">2516</td>
    <td class="codeline">  assert(dst <= src || dst >= src + srcParts);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2517</td>
    <td class="codeline">  assert(dstParts <= srcParts + 1);</td>
    <td class="lineNumber">2517</td>
    <td class="codeline">  assert(dstParts <= srcParts + 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2518</td>
    <td class="codeline"></td>
    <td class="lineNumber">2518</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2519</td>
    <td class="codeline">  // N loops; minimum of dstParts and srcParts.</td>
    <td class="lineNumber">2519</td>
    <td class="codeline">  // N loops; minimum of dstParts and srcParts.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2520</td>
    <td class="codeline">  unsigned n = std::min(dstParts, srcParts);</td>
    <td class="lineNumber">2520</td>
    <td class="codeline">  unsigned n = std::min(dstParts, srcParts);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2521</td>
    <td class="codeline"></td>
    <td class="lineNumber">2521</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2522</td>
    <td class="codeline">  for (unsigned i = 0; i < n; i++) {</td>
    <td class="lineNumber">2522</td>
    <td class="codeline">  for (unsigned i = 0; i < n; i++) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2523</td>
    <td class="codeline">    // [LOW, HIGH] = MULTIPLIER * SRC[i] + DST[i] + CARRY.</td>
    <td class="lineNumber">2523</td>
    <td class="codeline">    // [LOW, HIGH] = MULTIPLIER * SRC[i] + DST[i] + CARRY.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2524</td>
    <td class="codeline">    // This cannot overflow, because:</td>
    <td class="lineNumber">2524</td>
    <td class="codeline">    // This cannot overflow, because:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2525</td>
    <td class="codeline">    //   (n - 1) * (n - 1) + 2 (n - 1) = (n - 1) * (n + 1)</td>
    <td class="lineNumber">2525</td>
    <td class="codeline">    //   (n - 1) * (n - 1) + 2 (n - 1) = (n - 1) * (n + 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2526</td>
    <td class="codeline">    // which is less than n^2.</td>
    <td class="lineNumber">2526</td>
    <td class="codeline">    // which is less than n^2.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2527</td>
    <td class="codeline">    WordType srcPart = src[i];</td>
    <td class="lineNumber">2527</td>
    <td class="codeline">    WordType srcPart = src[i];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2528</td>
    <td class="codeline">    WordType low, mid, high;</td>
    <td class="lineNumber">2528</td>
    <td class="codeline">    WordType low, mid, high;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2529</td>
    <td class="codeline">    if (multiplier == 0 || srcPart == 0) {</td>
    <td class="lineNumber">2529</td>
    <td class="codeline">    if (multiplier == 0 || srcPart == 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2530</td>
    <td class="codeline">      low = carry;</td>
    <td class="lineNumber">2530</td>
    <td class="codeline">      low = carry;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2531</td>
    <td class="codeline">      high = 0;</td>
    <td class="lineNumber">2531</td>
    <td class="codeline">      high = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2532</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">2532</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2533</td>
    <td class="codeline">      low = lowHalf(srcPart) * lowHalf(multiplier);</td>
    <td class="lineNumber">2533</td>
    <td class="codeline">      low = lowHalf(srcPart) * lowHalf(multiplier);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2534</td>
    <td class="codeline">      high = highHalf(srcPart) * highHalf(multiplier);</td>
    <td class="lineNumber">2534</td>
    <td class="codeline">      high = highHalf(srcPart) * highHalf(multiplier);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2535</td>
    <td class="codeline"></td>
    <td class="lineNumber">2535</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2536</td>
    <td class="codeline">      mid = lowHalf(srcPart) * highHalf(multiplier);</td>
    <td class="lineNumber">2536</td>
    <td class="codeline">      mid = lowHalf(srcPart) * highHalf(multiplier);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2537</td>
    <td class="codeline">      high += highHalf(mid);</td>
    <td class="lineNumber">2537</td>
    <td class="codeline">      high += highHalf(mid);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2538</td>
    <td class="codeline">      mid <<= APINT_BITS_PER_WORD / 2;</td>
    <td class="lineNumber">2538</td>
    <td class="codeline">      mid <<= APINT_BITS_PER_WORD / 2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2539</td>
    <td class="codeline">      if (low + mid < low)</td>
    <td class="lineNumber">2539</td>
    <td class="codeline">      if (low + mid < low)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2540</td>
    <td class="codeline">        high++;</td>
    <td class="lineNumber">2540</td>
    <td class="codeline">        high++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2541</td>
    <td class="codeline">      low += mid;</td>
    <td class="lineNumber">2541</td>
    <td class="codeline">      low += mid;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2542</td>
    <td class="codeline"></td>
    <td class="lineNumber">2542</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2543</td>
    <td class="codeline">      mid = highHalf(srcPart) * lowHalf(multiplier);</td>
    <td class="lineNumber">2543</td>
    <td class="codeline">      mid = highHalf(srcPart) * lowHalf(multiplier);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2544</td>
    <td class="codeline">      high += highHalf(mid);</td>
    <td class="lineNumber">2544</td>
    <td class="codeline">      high += highHalf(mid);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2545</td>
    <td class="codeline">      mid <<= APINT_BITS_PER_WORD / 2;</td>
    <td class="lineNumber">2545</td>
    <td class="codeline">      mid <<= APINT_BITS_PER_WORD / 2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2546</td>
    <td class="codeline">      if (low + mid < low)</td>
    <td class="lineNumber">2546</td>
    <td class="codeline">      if (low + mid < low)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2547</td>
    <td class="codeline">        high++;</td>
    <td class="lineNumber">2547</td>
    <td class="codeline">        high++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2548</td>
    <td class="codeline">      low += mid;</td>
    <td class="lineNumber">2548</td>
    <td class="codeline">      low += mid;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2549</td>
    <td class="codeline"></td>
    <td class="lineNumber">2549</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2550</td>
    <td class="codeline">      // Now add carry.</td>
    <td class="lineNumber">2550</td>
    <td class="codeline">      // Now add carry.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2551</td>
    <td class="codeline">      if (low + carry < low)</td>
    <td class="lineNumber">2551</td>
    <td class="codeline">      if (low + carry < low)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2552</td>
    <td class="codeline">        high++;</td>
    <td class="lineNumber">2552</td>
    <td class="codeline">        high++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2553</td>
    <td class="codeline">      low += carry;</td>
    <td class="lineNumber">2553</td>
    <td class="codeline">      low += carry;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2554</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2554</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2555</td>
    <td class="codeline"></td>
    <td class="lineNumber">2555</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2556</td>
    <td class="codeline">    if (add) {</td>
    <td class="lineNumber">2556</td>
    <td class="codeline">    if (add) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2557</td>
    <td class="codeline">      // And now DST[i], and store the new low part there.</td>
    <td class="lineNumber">2557</td>
    <td class="codeline">      // And now DST[i], and store the new low part there.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2558</td>
    <td class="codeline">      if (low + dst[i] < low)</td>
    <td class="lineNumber">2558</td>
    <td class="codeline">      if (low + dst[i] < low)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2559</td>
    <td class="codeline">        high++;</td>
    <td class="lineNumber">2559</td>
    <td class="codeline">        high++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2560</td>
    <td class="codeline">      dst[i] += low;</td>
    <td class="lineNumber">2560</td>
    <td class="codeline">      dst[i] += low;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2561</td>
    <td class="codeline">    } else</td>
    <td class="lineNumber">2561</td>
    <td class="codeline">    } else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2562</td>
    <td class="codeline">      dst[i] = low;</td>
    <td class="lineNumber">2562</td>
    <td class="codeline">      dst[i] = low;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2563</td>
    <td class="codeline"></td>
    <td class="lineNumber">2563</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2564</td>
    <td class="codeline">    carry = high;</td>
    <td class="lineNumber">2564</td>
    <td class="codeline">    carry = high;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2565</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2565</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2566</td>
    <td class="codeline"></td>
    <td class="lineNumber">2566</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2567</td>
    <td class="codeline">  if (srcParts < dstParts) {</td>
    <td class="lineNumber">2567</td>
    <td class="codeline">  if (srcParts < dstParts) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2568</td>
    <td class="codeline">    // Full multiplication, there is no overflow.</td>
    <td class="lineNumber">2568</td>
    <td class="codeline">    // Full multiplication, there is no overflow.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2569</td>
    <td class="codeline">    assert(srcParts + 1 == dstParts);</td>
    <td class="lineNumber">2569</td>
    <td class="codeline">    assert(srcParts + 1 == dstParts);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2570</td>
    <td class="codeline">    dst[srcParts] = carry;</td>
    <td class="lineNumber">2570</td>
    <td class="codeline">    dst[srcParts] = carry;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2571</td>
    <td class="codeline">    return 0;</td>
    <td class="lineNumber">2571</td>
    <td class="codeline">    return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2572</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2572</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2573</td>
    <td class="codeline"></td>
    <td class="lineNumber">2573</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2574</td>
    <td class="codeline">  // We overflowed if there is carry.</td>
    <td class="lineNumber">2574</td>
    <td class="codeline">  // We overflowed if there is carry.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2575</td>
    <td class="codeline">  if (carry)</td>
    <td class="lineNumber">2575</td>
    <td class="codeline">  if (carry)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2576</td>
    <td class="codeline">    return 1;</td>
    <td class="lineNumber">2576</td>
    <td class="codeline">    return 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2577</td>
    <td class="codeline"></td>
    <td class="lineNumber">2577</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2578</td>
    <td class="codeline">  // We would overflow if any significant unwritten parts would be</td>
    <td class="lineNumber">2578</td>
    <td class="codeline">  // We would overflow if any significant unwritten parts would be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2579</td>
    <td class="codeline">  // non-zero.  This is true if any remaining src parts are non-zero</td>
    <td class="lineNumber">2579</td>
    <td class="codeline">  // non-zero.  This is true if any remaining src parts are non-zero</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2580</td>
    <td class="codeline">  // and the multiplier is non-zero.</td>
    <td class="lineNumber">2580</td>
    <td class="codeline">  // and the multiplier is non-zero.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2581</td>
    <td class="codeline">  if (multiplier)</td>
    <td class="lineNumber">2581</td>
    <td class="codeline">  if (multiplier)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2582</td>
    <td class="codeline">    for (unsigned i = dstParts; i < srcParts; i++)</td>
    <td class="lineNumber">2582</td>
    <td class="codeline">    for (unsigned i = dstParts; i < srcParts; i++)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2583</td>
    <td class="codeline">      if (src[i])</td>
    <td class="lineNumber">2583</td>
    <td class="codeline">      if (src[i])</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2584</td>
    <td class="codeline">        return 1;</td>
    <td class="lineNumber">2584</td>
    <td class="codeline">        return 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2585</td>
    <td class="codeline"></td>
    <td class="lineNumber">2585</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2586</td>
    <td class="codeline">  // We fitted in the narrow destination.</td>
    <td class="lineNumber">2586</td>
    <td class="codeline">  // We fitted in the narrow destination.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2587</td>
    <td class="codeline">  return 0;</td>
    <td class="lineNumber">2587</td>
    <td class="codeline">  return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2588</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2588</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2589</td>
    <td class="codeline"></td>
    <td class="lineNumber">2589</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2590</td>
    <td class="codeline">/// DST = LHS * RHS, where DST has the same width as the operands and</td>
    <td class="lineNumber">2590</td>
    <td class="codeline">/// DST = LHS * RHS, where DST has the same width as the operands and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2591</td>
    <td class="codeline">/// is filled with the least significant parts of the result.  Returns</td>
    <td class="lineNumber">2591</td>
    <td class="codeline">/// is filled with the least significant parts of the result.  Returns</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2592</td>
    <td class="codeline">/// one if overflow occurred, otherwise zero.  DST must be disjoint</td>
    <td class="lineNumber">2592</td>
    <td class="codeline">/// one if overflow occurred, otherwise zero.  DST must be disjoint</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2593</td>
    <td class="codeline">/// from both operands.</td>
    <td class="lineNumber">2593</td>
    <td class="codeline">/// from both operands.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2594</td>
    <td class="codeline">int APInt::tcMultiply(WordType *dst, const WordType *lhs,</td>
    <td class="lineNumber">2594</td>
    <td class="codeline">int APInt::tcMultiply(WordType *dst, const WordType *lhs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2595</td>
    <td class="codeline">                      const WordType *rhs, unsigned parts) {</td>
    <td class="lineNumber">2595</td>
    <td class="codeline">                      const WordType *rhs, unsigned parts) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2596</td>
    <td class="codeline">  assert(dst != lhs && dst != rhs);</td>
    <td class="lineNumber">2596</td>
    <td class="codeline">  assert(dst != lhs && dst != rhs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2597</td>
    <td class="codeline"></td>
    <td class="lineNumber">2597</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2598</td>
    <td class="codeline">  int overflow = 0;</td>
    <td class="lineNumber">2598</td>
    <td class="codeline">  int overflow = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2599</td>
    <td class="codeline">  tcSet(dst, 0, parts);</td>
    <td class="lineNumber">2599</td>
    <td class="codeline">  tcSet(dst, 0, parts);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2600</td>
    <td class="codeline"></td>
    <td class="lineNumber">2600</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2601</td>
    <td class="codeline">  for (unsigned i = 0; i < parts; i++)</td>
    <td class="lineNumber">2601</td>
    <td class="codeline">  for (unsigned i = 0; i < parts; i++)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2602</td>
    <td class="codeline">    overflow |= tcMultiplyPart(&dst[i], lhs, rhs[i], 0, parts,</td>
    <td class="lineNumber">2602</td>
    <td class="codeline">    overflow |= tcMultiplyPart(&dst[i], lhs, rhs[i], 0, parts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2603</td>
    <td class="codeline">                               parts - i, true);</td>
    <td class="lineNumber">2603</td>
    <td class="codeline">                               parts - i, true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2604</td>
    <td class="codeline"></td>
    <td class="lineNumber">2604</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2605</td>
    <td class="codeline">  return overflow;</td>
    <td class="lineNumber">2605</td>
    <td class="codeline">  return overflow;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2606</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2606</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2607</td>
    <td class="codeline"></td>
    <td class="lineNumber">2607</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2608</td>
    <td class="codeline">/// DST = LHS * RHS, where DST has width the sum of the widths of the</td>
    <td class="lineNumber">2608</td>
    <td class="codeline">/// DST = LHS * RHS, where DST has width the sum of the widths of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2609</td>
    <td class="codeline">/// operands. No overflow occurs. DST must be disjoint from both operands.</td>
    <td class="lineNumber">2609</td>
    <td class="codeline">/// operands. No overflow occurs. DST must be disjoint from both operands.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2610</td>
    <td class="codeline">void APInt::tcFullMultiply(WordType *dst, const WordType *lhs,</td>
    <td class="lineNumber">2610</td>
    <td class="codeline">void APInt::tcFullMultiply(WordType *dst, const WordType *lhs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2611</td>
    <td class="codeline">                           const WordType *rhs, unsigned lhsParts,</td>
    <td class="lineNumber">2611</td>
    <td class="codeline">                           const WordType *rhs, unsigned lhsParts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2612</td>
    <td class="codeline">                           unsigned rhsParts) {</td>
    <td class="lineNumber">2612</td>
    <td class="codeline">                           unsigned rhsParts) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2613</td>
    <td class="codeline">  // Put the narrower number on the LHS for less loops below.</td>
    <td class="lineNumber">2613</td>
    <td class="codeline">  // Put the narrower number on the LHS for less loops below.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2614</td>
    <td class="codeline">  if (lhsParts > rhsParts)</td>
    <td class="lineNumber">2614</td>
    <td class="codeline">  if (lhsParts > rhsParts)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2615</td>
    <td class="codeline">    return tcFullMultiply (dst, rhs, lhs, rhsParts, lhsParts);</td>
    <td class="lineNumber">2615</td>
    <td class="codeline">    return tcFullMultiply (dst, rhs, lhs, rhsParts, lhsParts);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2616</td>
    <td class="codeline"></td>
    <td class="lineNumber">2616</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2617</td>
    <td class="codeline">  assert(dst != lhs && dst != rhs);</td>
    <td class="lineNumber">2617</td>
    <td class="codeline">  assert(dst != lhs && dst != rhs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2618</td>
    <td class="codeline"></td>
    <td class="lineNumber">2618</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2619</td>
    <td class="codeline">  tcSet(dst, 0, rhsParts);</td>
    <td class="lineNumber">2619</td>
    <td class="codeline">  tcSet(dst, 0, rhsParts);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2620</td>
    <td class="codeline"></td>
    <td class="lineNumber">2620</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2621</td>
    <td class="codeline">  for (unsigned i = 0; i < lhsParts; i++)</td>
    <td class="lineNumber">2621</td>
    <td class="codeline">  for (unsigned i = 0; i < lhsParts; i++)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2622</td>
    <td class="codeline">    tcMultiplyPart(&dst[i], rhs, lhs[i], 0, rhsParts, rhsParts + 1, true);</td>
    <td class="lineNumber">2622</td>
    <td class="codeline">    tcMultiplyPart(&dst[i], rhs, lhs[i], 0, rhsParts, rhsParts + 1, true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2623</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2623</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2624</td>
    <td class="codeline"></td>
    <td class="lineNumber">2624</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2625</td>
    <td class="codeline">// If RHS is zero LHS and REMAINDER are left unchanged, return one.</td>
    <td class="lineNumber">2625</td>
    <td class="codeline">// If RHS is zero LHS and REMAINDER are left unchanged, return one.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2626</td>
    <td class="codeline">// Otherwise set LHS to LHS / RHS with the fractional part discarded,</td>
    <td class="lineNumber">2626</td>
    <td class="codeline">// Otherwise set LHS to LHS / RHS with the fractional part discarded,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2627</td>
    <td class="codeline">// set REMAINDER to the remainder, return zero.  i.e.</td>
    <td class="lineNumber">2627</td>
    <td class="codeline">// set REMAINDER to the remainder, return zero.  i.e.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2628</td>
    <td class="codeline">//</td>
    <td class="lineNumber">2628</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2629</td>
    <td class="codeline">//   OLD_LHS = RHS * LHS + REMAINDER</td>
    <td class="lineNumber">2629</td>
    <td class="codeline">//   OLD_LHS = RHS * LHS + REMAINDER</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2630</td>
    <td class="codeline">//</td>
    <td class="lineNumber">2630</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2631</td>
    <td class="codeline">// SCRATCH is a bignum of the same size as the operands and result for</td>
    <td class="lineNumber">2631</td>
    <td class="codeline">// SCRATCH is a bignum of the same size as the operands and result for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2632</td>
    <td class="codeline">// use by the routine; its contents need not be initialized and are</td>
    <td class="lineNumber">2632</td>
    <td class="codeline">// use by the routine; its contents need not be initialized and are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2633</td>
    <td class="codeline">// destroyed.  LHS, REMAINDER and SCRATCH must be distinct.</td>
    <td class="lineNumber">2633</td>
    <td class="codeline">// destroyed.  LHS, REMAINDER and SCRATCH must be distinct.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2634</td>
    <td class="codeline">int APInt::tcDivide(WordType *lhs, const WordType *rhs,</td>
    <td class="lineNumber">2634</td>
    <td class="codeline">int APInt::tcDivide(WordType *lhs, const WordType *rhs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2635</td>
    <td class="codeline">                    WordType *remainder, WordType *srhs,</td>
    <td class="lineNumber">2635</td>
    <td class="codeline">                    WordType *remainder, WordType *srhs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2636</td>
    <td class="codeline">                    unsigned parts) {</td>
    <td class="lineNumber">2636</td>
    <td class="codeline">                    unsigned parts) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2637</td>
    <td class="codeline">  assert(lhs != remainder && lhs != srhs && remainder != srhs);</td>
    <td class="lineNumber">2637</td>
    <td class="codeline">  assert(lhs != remainder && lhs != srhs && remainder != srhs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2638</td>
    <td class="codeline"></td>
    <td class="lineNumber">2638</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2639</td>
    <td class="codeline">  unsigned shiftCount = tcMSB(rhs, parts) + 1;</td>
    <td class="lineNumber">2639</td>
    <td class="codeline">  unsigned shiftCount = tcMSB(rhs, parts) + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2640</td>
    <td class="codeline">  if (shiftCount == 0)</td>
    <td class="lineNumber">2640</td>
    <td class="codeline">  if (shiftCount == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2641</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">2641</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2642</td>
    <td class="codeline"></td>
    <td class="lineNumber">2642</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2643</td>
    <td class="codeline">  shiftCount = parts * APINT_BITS_PER_WORD - shiftCount;</td>
    <td class="lineNumber">2643</td>
    <td class="codeline">  shiftCount = parts * APINT_BITS_PER_WORD - shiftCount;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2644</td>
    <td class="codeline">  unsigned n = shiftCount / APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">2644</td>
    <td class="codeline">  unsigned n = shiftCount / APINT_BITS_PER_WORD;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2645</td>
    <td class="codeline">  WordType mask = (WordType) 1 << (shiftCount % APINT_BITS_PER_WORD);</td>
    <td class="lineNumber">2645</td>
    <td class="codeline">  WordType mask = (WordType) 1 << (shiftCount % APINT_BITS_PER_WORD);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2646</td>
    <td class="codeline"></td>
    <td class="lineNumber">2646</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2647</td>
    <td class="codeline">  tcAssign(srhs, rhs, parts);</td>
    <td class="lineNumber">2647</td>
    <td class="codeline">  tcAssign(srhs, rhs, parts);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2648</td>
    <td class="codeline">  tcShiftLeft(srhs, parts, shiftCount);</td>
    <td class="lineNumber">2648</td>
    <td class="codeline">  tcShiftLeft(srhs, parts, shiftCount);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2649</td>
    <td class="codeline">  tcAssign(remainder, lhs, parts);</td>
    <td class="lineNumber">2649</td>
    <td class="codeline">  tcAssign(remainder, lhs, parts);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2650</td>
    <td class="codeline">  tcSet(lhs, 0, parts);</td>
    <td class="lineNumber">2650</td>
    <td class="codeline">  tcSet(lhs, 0, parts);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2651</td>
    <td class="codeline"></td>
    <td class="lineNumber">2651</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2652</td>
    <td class="codeline">  // Loop, subtracting SRHS if REMAINDER is greater and adding that to the</td>
    <td class="lineNumber">2652</td>
    <td class="codeline">  // Loop, subtracting SRHS if REMAINDER is greater and adding that to the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2653</td>
    <td class="codeline">  // total.</td>
    <td class="lineNumber">2653</td>
    <td class="codeline">  // total.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2654</td>
    <td class="codeline">  for (;;) {</td>
    <td class="lineNumber">2654</td>
    <td class="codeline">  for (;;) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2655</td>
    <td class="codeline">    int compare = tcCompare(remainder, srhs, parts);</td>
    <td class="lineNumber">2655</td>
    <td class="codeline">    int compare = tcCompare(remainder, srhs, parts);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2656</td>
    <td class="codeline">    if (compare >= 0) {</td>
    <td class="lineNumber">2656</td>
    <td class="codeline">    if (compare >= 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2657</td>
    <td class="codeline">      tcSubtract(remainder, srhs, 0, parts);</td>
    <td class="lineNumber">2657</td>
    <td class="codeline">      tcSubtract(remainder, srhs, 0, parts);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2658</td>
    <td class="codeline">      lhs[n] |= mask;</td>
    <td class="lineNumber">2658</td>
    <td class="codeline">      lhs[n] |= mask;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2659</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2659</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2660</td>
    <td class="codeline"></td>
    <td class="lineNumber">2660</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2661</td>
    <td class="codeline">    if (shiftCount == 0)</td>
    <td class="lineNumber">2661</td>
    <td class="codeline">    if (shiftCount == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2662</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">2662</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2663</td>
    <td class="codeline">    shiftCount--;</td>
    <td class="lineNumber">2663</td>
    <td class="codeline">    shiftCount--;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2664</td>
    <td class="codeline">    tcShiftRight(srhs, parts, 1);</td>
    <td class="lineNumber">2664</td>
    <td class="codeline">    tcShiftRight(srhs, parts, 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2665</td>
    <td class="codeline">    if ((mask >>= 1) == 0) {</td>
    <td class="lineNumber">2665</td>
    <td class="codeline">    if ((mask >>= 1) == 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2666</td>
    <td class="codeline">      mask = (WordType) 1 << (APINT_BITS_PER_WORD - 1);</td>
    <td class="lineNumber">2666</td>
    <td class="codeline">      mask = (WordType) 1 << (APINT_BITS_PER_WORD - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2667</td>
    <td class="codeline">      n--;</td>
    <td class="lineNumber">2667</td>
    <td class="codeline">      n--;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2668</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2668</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2669</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2669</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2670</td>
    <td class="codeline"></td>
    <td class="lineNumber">2670</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2671</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">2671</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2672</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2672</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2673</td>
    <td class="codeline"></td>
    <td class="lineNumber">2673</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2674</td>
    <td class="codeline">/// Shift a bignum left Cound bits in-place. Shifted in bits are zero. There are</td>
    <td class="lineNumber">2674</td>
    <td class="codeline">/// Shift a bignum left Cound bits in-place. Shifted in bits are zero. There are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2675</td>
    <td class="codeline">/// no restrictions on Count.</td>
    <td class="lineNumber">2675</td>
    <td class="codeline">/// no restrictions on Count.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2676</td>
    <td class="codeline">void APInt::tcShiftLeft(WordType *Dst, unsigned Words, unsigned Count) {</td>
    <td class="lineNumber">2676</td>
    <td class="codeline">void APInt::tcShiftLeft(WordType *Dst, unsigned Words, unsigned Count) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2677</td>
    <td class="codeline">  // Don't bother performing a no-op shift.</td>
    <td class="lineNumber">2677</td>
    <td class="codeline">  // Don't bother performing a no-op shift.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2678</td>
    <td class="codeline">  if (!Count)</td>
    <td class="lineNumber">2678</td>
    <td class="codeline">  if (!Count)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2679</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">2679</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2680</td>
    <td class="codeline"></td>
    <td class="lineNumber">2680</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2681</td>
    <td class="codeline">  // WordShift is the inter-part shift; BitShift is the intra-part shift.</td>
    <td class="lineNumber">2681</td>
    <td class="codeline">  // WordShift is the inter-part shift; BitShift is the intra-part shift.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2682</td>
    <td class="codeline">  unsigned WordShift = std::min(Count / APINT_BITS_PER_WORD, Words);</td>
    <td class="lineNumber">2682</td>
    <td class="codeline">  unsigned WordShift = std::min(Count / APINT_BITS_PER_WORD, Words);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2683</td>
    <td class="codeline">  unsigned BitShift = Count % APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">2683</td>
    <td class="codeline">  unsigned BitShift = Count % APINT_BITS_PER_WORD;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2684</td>
    <td class="codeline"></td>
    <td class="lineNumber">2684</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2685</td>
    <td class="codeline">  // Fastpath for moving by whole words.</td>
    <td class="lineNumber">2685</td>
    <td class="codeline">  // Fastpath for moving by whole words.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2686</td>
    <td class="codeline">  if (BitShift == 0) {</td>
    <td class="lineNumber">2686</td>
    <td class="codeline">  if (BitShift == 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2687</td>
    <td class="codeline">    std::memmove(Dst + WordShift, Dst, (Words - WordShift) * APINT_WORD_SIZE);</td>
    <td class="lineNumber">2687</td>
    <td class="codeline">    std::memmove(Dst + WordShift, Dst, (Words - WordShift) * APINT_WORD_SIZE);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2688</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">2688</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2689</td>
    <td class="codeline">    while (Words-- > WordShift) {</td>
    <td class="lineNumber">2689</td>
    <td class="codeline">    while (Words-- > WordShift) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2690</td>
    <td class="codeline">      Dst[Words] = Dst[Words - WordShift] << BitShift;</td>
    <td class="lineNumber">2690</td>
    <td class="codeline">      Dst[Words] = Dst[Words - WordShift] << BitShift;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2691</td>
    <td class="codeline">      if (Words > WordShift)</td>
    <td class="lineNumber">2691</td>
    <td class="codeline">      if (Words > WordShift)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2692</td>
    <td class="codeline">        Dst[Words] |=</td>
    <td class="lineNumber">2692</td>
    <td class="codeline">        Dst[Words] |=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2693</td>
    <td class="codeline">          Dst[Words - WordShift - 1] >> (APINT_BITS_PER_WORD - BitShift);</td>
    <td class="lineNumber">2693</td>
    <td class="codeline">          Dst[Words - WordShift - 1] >> (APINT_BITS_PER_WORD - BitShift);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2694</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2694</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2695</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2695</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2696</td>
    <td class="codeline"></td>
    <td class="lineNumber">2696</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2697</td>
    <td class="codeline">  // Fill in the remainder with 0s.</td>
    <td class="lineNumber">2697</td>
    <td class="codeline">  // Fill in the remainder with 0s.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2698</td>
    <td class="codeline">  std::memset(Dst, 0, WordShift * APINT_WORD_SIZE);</td>
    <td class="lineNumber">2698</td>
    <td class="codeline">  std::memset(Dst, 0, WordShift * APINT_WORD_SIZE);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2699</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2699</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2700</td>
    <td class="codeline"></td>
    <td class="lineNumber">2700</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2701</td>
    <td class="codeline">/// Shift a bignum right Count bits in-place. Shifted in bits are zero. There</td>
    <td class="lineNumber">2701</td>
    <td class="codeline">/// Shift a bignum right Count bits in-place. Shifted in bits are zero. There</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2702</td>
    <td class="codeline">/// are no restrictions on Count.</td>
    <td class="lineNumber">2702</td>
    <td class="codeline">/// are no restrictions on Count.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2703</td>
    <td class="codeline">void APInt::tcShiftRight(WordType *Dst, unsigned Words, unsigned Count) {</td>
    <td class="lineNumber">2703</td>
    <td class="codeline">void APInt::tcShiftRight(WordType *Dst, unsigned Words, unsigned Count) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2704</td>
    <td class="codeline">  // Don't bother performing a no-op shift.</td>
    <td class="lineNumber">2704</td>
    <td class="codeline">  // Don't bother performing a no-op shift.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2705</td>
    <td class="codeline">  if (!Count)</td>
    <td class="lineNumber">2705</td>
    <td class="codeline">  if (!Count)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2706</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">2706</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2707</td>
    <td class="codeline"></td>
    <td class="lineNumber">2707</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2708</td>
    <td class="codeline">  // WordShift is the inter-part shift; BitShift is the intra-part shift.</td>
    <td class="lineNumber">2708</td>
    <td class="codeline">  // WordShift is the inter-part shift; BitShift is the intra-part shift.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2709</td>
    <td class="codeline">  unsigned WordShift = std::min(Count / APINT_BITS_PER_WORD, Words);</td>
    <td class="lineNumber">2709</td>
    <td class="codeline">  unsigned WordShift = std::min(Count / APINT_BITS_PER_WORD, Words);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2710</td>
    <td class="codeline">  unsigned BitShift = Count % APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">2710</td>
    <td class="codeline">  unsigned BitShift = Count % APINT_BITS_PER_WORD;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2711</td>
    <td class="codeline"></td>
    <td class="lineNumber">2711</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2712</td>
    <td class="codeline">  unsigned WordsToMove = Words - WordShift;</td>
    <td class="lineNumber">2712</td>
    <td class="codeline">  unsigned WordsToMove = Words - WordShift;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2713</td>
    <td class="codeline">  // Fastpath for moving by whole words.</td>
    <td class="lineNumber">2713</td>
    <td class="codeline">  // Fastpath for moving by whole words.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2714</td>
    <td class="codeline">  if (BitShift == 0) {</td>
    <td class="lineNumber">2714</td>
    <td class="codeline">  if (BitShift == 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2715</td>
    <td class="codeline">    std::memmove(Dst, Dst + WordShift, WordsToMove * APINT_WORD_SIZE);</td>
    <td class="lineNumber">2715</td>
    <td class="codeline">    std::memmove(Dst, Dst + WordShift, WordsToMove * APINT_WORD_SIZE);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2716</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">2716</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2717</td>
    <td class="codeline">    for (unsigned i = 0; i != WordsToMove; ++i) {</td>
    <td class="lineNumber">2717</td>
    <td class="codeline">    for (unsigned i = 0; i != WordsToMove; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2718</td>
    <td class="codeline">      Dst[i] = Dst[i + WordShift] >> BitShift;</td>
    <td class="lineNumber">2718</td>
    <td class="codeline">      Dst[i] = Dst[i + WordShift] >> BitShift;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2719</td>
    <td class="codeline">      if (i + 1 != WordsToMove)</td>
    <td class="lineNumber">2719</td>
    <td class="codeline">      if (i + 1 != WordsToMove)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2720</td>
    <td class="codeline">        Dst[i] |= Dst[i + WordShift + 1] << (APINT_BITS_PER_WORD - BitShift);</td>
    <td class="lineNumber">2720</td>
    <td class="codeline">        Dst[i] |= Dst[i + WordShift + 1] << (APINT_BITS_PER_WORD - BitShift);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2721</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2721</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2722</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2722</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2723</td>
    <td class="codeline"></td>
    <td class="lineNumber">2723</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2724</td>
    <td class="codeline">  // Fill in the remainder with 0s.</td>
    <td class="lineNumber">2724</td>
    <td class="codeline">  // Fill in the remainder with 0s.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2725</td>
    <td class="codeline">  std::memset(Dst + WordsToMove, 0, WordShift * APINT_WORD_SIZE);</td>
    <td class="lineNumber">2725</td>
    <td class="codeline">  std::memset(Dst + WordsToMove, 0, WordShift * APINT_WORD_SIZE);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2726</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2726</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2727</td>
    <td class="codeline"></td>
    <td class="lineNumber">2727</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2728</td>
    <td class="codeline">// Comparison (unsigned) of two bignums.</td>
    <td class="lineNumber">2728</td>
    <td class="codeline">// Comparison (unsigned) of two bignums.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2729</td>
    <td class="codeline">int APInt::tcCompare(const WordType *lhs, const WordType *rhs,</td>
    <td class="lineNumber">2729</td>
    <td class="codeline">int APInt::tcCompare(const WordType *lhs, const WordType *rhs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2730</td>
    <td class="codeline">                     unsigned parts) {</td>
    <td class="lineNumber">2730</td>
    <td class="codeline">                     unsigned parts) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2731</td>
    <td class="codeline">  while (parts) {</td>
    <td class="lineNumber">2731</td>
    <td class="codeline">  while (parts) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2732</td>
    <td class="codeline">    parts--;</td>
    <td class="lineNumber">2732</td>
    <td class="codeline">    parts--;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2733</td>
    <td class="codeline">    if (lhs[parts] != rhs[parts])</td>
    <td class="lineNumber">2733</td>
    <td class="codeline">    if (lhs[parts] != rhs[parts])</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2734</td>
    <td class="codeline">      return (lhs[parts] > rhs[parts]) ? 1 : -1;</td>
    <td class="lineNumber">2734</td>
    <td class="codeline">      return (lhs[parts] > rhs[parts]) ? 1 : -1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2735</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2735</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2736</td>
    <td class="codeline"></td>
    <td class="lineNumber">2736</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2737</td>
    <td class="codeline">  return 0;</td>
    <td class="lineNumber">2737</td>
    <td class="codeline">  return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2738</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2738</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2739</td>
    <td class="codeline"></td>
    <td class="lineNumber">2739</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2740</td>
    <td class="codeline">APInt llvm::APIntOps::RoundingUDiv(const APInt &A, const APInt &B,</td>
    <td class="lineNumber">2740</td>
    <td class="codeline">APInt llvm::APIntOps::RoundingUDiv(const APInt &A, const APInt &B,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2741</td>
    <td class="codeline">                                   APInt::Rounding RM) {</td>
    <td class="lineNumber">2741</td>
    <td class="codeline">                                   APInt::Rounding RM) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2742</td>
    <td class="codeline">  // Currently udivrem always rounds down.</td>
    <td class="lineNumber">2742</td>
    <td class="codeline">  // Currently udivrem always rounds down.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2743</td>
    <td class="codeline">  switch (RM) {</td>
    <td class="lineNumber">2743</td>
    <td class="codeline">  switch (RM) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2744</td>
    <td class="codeline">  case APInt::Rounding::DOWN:</td>
    <td class="lineNumber">2744</td>
    <td class="codeline">  case APInt::Rounding::DOWN:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2745</td>
    <td class="codeline">  case APInt::Rounding::TOWARD_ZERO:</td>
    <td class="lineNumber">2745</td>
    <td class="codeline">  case APInt::Rounding::TOWARD_ZERO:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2746</td>
    <td class="codeline">    return A.udiv(B);</td>
    <td class="lineNumber">2746</td>
    <td class="codeline">    return A.udiv(B);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2747</td>
    <td class="codeline">  case APInt::Rounding::UP: {</td>
    <td class="lineNumber">2747</td>
    <td class="codeline">  case APInt::Rounding::UP: {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2748</td>
    <td class="codeline">    APInt Quo, Rem;</td>
    <td class="lineNumber">2748</td>
    <td class="codeline">    APInt Quo, Rem;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2749</td>
    <td class="codeline">    APInt::udivrem(A, B, Quo, Rem);</td>
    <td class="lineNumber">2749</td>
    <td class="codeline">    APInt::udivrem(A, B, Quo, Rem);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2750</td>
    <td class="codeline">    if (Rem.isZero())</td>
    <td class="lineNumber">2750</td>
    <td class="codeline">    if (Rem.isZero())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2751</td>
    <td class="codeline">      return Quo;</td>
    <td class="lineNumber">2751</td>
    <td class="codeline">      return Quo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2752</td>
    <td class="codeline">    return Quo + 1;</td>
    <td class="lineNumber">2752</td>
    <td class="codeline">    return Quo + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2753</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2753</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2754</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2754</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2755</td>
    <td class="codeline">  llvm_unreachable("Unknown APInt::Rounding enum");</td>
    <td class="lineNumber">2755</td>
    <td class="codeline">  llvm_unreachable("Unknown APInt::Rounding enum");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2756</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2756</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2757</td>
    <td class="codeline"></td>
    <td class="lineNumber">2757</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2758</td>
    <td class="codeline">APInt llvm::APIntOps::RoundingSDiv(const APInt &A, const APInt &B,</td>
    <td class="lineNumber">2758</td>
    <td class="codeline">APInt llvm::APIntOps::RoundingSDiv(const APInt &A, const APInt &B,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2759</td>
    <td class="codeline">                                   APInt::Rounding RM) {</td>
    <td class="lineNumber">2759</td>
    <td class="codeline">                                   APInt::Rounding RM) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2760</td>
    <td class="codeline">  switch (RM) {</td>
    <td class="lineNumber">2760</td>
    <td class="codeline">  switch (RM) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2761</td>
    <td class="codeline">  case APInt::Rounding::DOWN:</td>
    <td class="lineNumber">2761</td>
    <td class="codeline">  case APInt::Rounding::DOWN:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2762</td>
    <td class="codeline">  case APInt::Rounding::UP: {</td>
    <td class="lineNumber">2762</td>
    <td class="codeline">  case APInt::Rounding::UP: {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2763</td>
    <td class="codeline">    APInt Quo, Rem;</td>
    <td class="lineNumber">2763</td>
    <td class="codeline">    APInt Quo, Rem;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2764</td>
    <td class="codeline">    APInt::sdivrem(A, B, Quo, Rem);</td>
    <td class="lineNumber">2764</td>
    <td class="codeline">    APInt::sdivrem(A, B, Quo, Rem);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2765</td>
    <td class="codeline">    if (Rem.isZero())</td>
    <td class="lineNumber">2765</td>
    <td class="codeline">    if (Rem.isZero())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2766</td>
    <td class="codeline">      return Quo;</td>
    <td class="lineNumber">2766</td>
    <td class="codeline">      return Quo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2767</td>
    <td class="codeline">    // This algorithm deals with arbitrary rounding mode used by sdivrem.</td>
    <td class="lineNumber">2767</td>
    <td class="codeline">    // This algorithm deals with arbitrary rounding mode used by sdivrem.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2768</td>
    <td class="codeline">    // We want to check whether the non-integer part of the mathematical value</td>
    <td class="lineNumber">2768</td>
    <td class="codeline">    // We want to check whether the non-integer part of the mathematical value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2769</td>
    <td class="codeline">    // is negative or not. If the non-integer part is negative, we need to round</td>
    <td class="lineNumber">2769</td>
    <td class="codeline">    // is negative or not. If the non-integer part is negative, we need to round</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2770</td>
    <td class="codeline">    // down from Quo; otherwise, if it's positive or 0, we return Quo, as it's</td>
    <td class="lineNumber">2770</td>
    <td class="codeline">    // down from Quo; otherwise, if it's positive or 0, we return Quo, as it's</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2771</td>
    <td class="codeline">    // already rounded down.</td>
    <td class="lineNumber">2771</td>
    <td class="codeline">    // already rounded down.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2772</td>
    <td class="codeline">    if (RM == APInt::Rounding::DOWN) {</td>
    <td class="lineNumber">2772</td>
    <td class="codeline">    if (RM == APInt::Rounding::DOWN) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2773</td>
    <td class="codeline">      if (Rem.isNegative() != B.isNegative())</td>
    <td class="lineNumber">2773</td>
    <td class="codeline">      if (Rem.isNegative() != B.isNegative())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2774</td>
    <td class="codeline">        return Quo - 1;</td>
    <td class="lineNumber">2774</td>
    <td class="codeline">        return Quo - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2775</td>
    <td class="codeline">      return Quo;</td>
    <td class="lineNumber">2775</td>
    <td class="codeline">      return Quo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2776</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2776</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2777</td>
    <td class="codeline">    if (Rem.isNegative() != B.isNegative())</td>
    <td class="lineNumber">2777</td>
    <td class="codeline">    if (Rem.isNegative() != B.isNegative())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2778</td>
    <td class="codeline">      return Quo;</td>
    <td class="lineNumber">2778</td>
    <td class="codeline">      return Quo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2779</td>
    <td class="codeline">    return Quo + 1;</td>
    <td class="lineNumber">2779</td>
    <td class="codeline">    return Quo + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2780</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2780</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2781</td>
    <td class="codeline">  // Currently sdiv rounds towards zero.</td>
    <td class="lineNumber">2781</td>
    <td class="codeline">  // Currently sdiv rounds towards zero.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2782</td>
    <td class="codeline">  case APInt::Rounding::TOWARD_ZERO:</td>
    <td class="lineNumber">2782</td>
    <td class="codeline">  case APInt::Rounding::TOWARD_ZERO:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2783</td>
    <td class="codeline">    return A.sdiv(B);</td>
    <td class="lineNumber">2783</td>
    <td class="codeline">    return A.sdiv(B);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2784</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2784</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2785</td>
    <td class="codeline">  llvm_unreachable("Unknown APInt::Rounding enum");</td>
    <td class="lineNumber">2785</td>
    <td class="codeline">  llvm_unreachable("Unknown APInt::Rounding enum");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2786</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2786</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2787</td>
    <td class="codeline"></td>
    <td class="lineNumber">2787</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2788</td>
    <td class="codeline">std::optional<APInt></td>
    <td class="lineNumber">2788</td>
    <td class="codeline">std::optional<APInt></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2789</td>
    <td class="codeline">llvm::APIntOps::SolveQuadraticEquationWrap(APInt A, APInt B, APInt C,</td>
    <td class="lineNumber">2789</td>
    <td class="codeline">llvm::APIntOps::SolveQuadraticEquationWrap(APInt A, APInt B, APInt C,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2790</td>
    <td class="codeline">                                           unsigned RangeWidth) {</td>
    <td class="lineNumber">2790</td>
    <td class="codeline">                                           unsigned RangeWidth) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2791</td>
    <td class="codeline">  unsigned CoeffWidth = A.getBitWidth();</td>
    <td class="lineNumber">2791</td>
    <td class="codeline">  unsigned CoeffWidth = A.getBitWidth();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2792</td>
    <td class="codeline">  assert(CoeffWidth == B.getBitWidth() && CoeffWidth == C.getBitWidth());</td>
    <td class="lineNumber">2792</td>
    <td class="codeline">  assert(CoeffWidth == B.getBitWidth() && CoeffWidth == C.getBitWidth());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2793</td>
    <td class="codeline">  assert(RangeWidth <= CoeffWidth &&</td>
    <td class="lineNumber">2793</td>
    <td class="codeline">  assert(RangeWidth <= CoeffWidth &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2794</td>
    <td class="codeline">         "Value range width should be less than coefficient width");</td>
    <td class="lineNumber">2794</td>
    <td class="codeline">         "Value range width should be less than coefficient width");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2795</td>
    <td class="codeline">  assert(RangeWidth > 1 && "Value range bit width should be > 1");</td>
    <td class="lineNumber">2795</td>
    <td class="codeline">  assert(RangeWidth > 1 && "Value range bit width should be > 1");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2796</td>
    <td class="codeline"></td>
    <td class="lineNumber">2796</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2797</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << __func__ << ": solving " << A << "x^2 + " << B</td>
    <td class="lineNumber">2797</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << __func__ << ": solving " << A << "x^2 + " << B</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2798</td>
    <td class="codeline">                    << "x + " << C << ", rw:" << RangeWidth << '\n');</td>
    <td class="lineNumber">2798</td>
    <td class="codeline">                    << "x + " << C << ", rw:" << RangeWidth << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2799</td>
    <td class="codeline"></td>
    <td class="lineNumber">2799</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2800</td>
    <td class="codeline">  // Identify 0 as a (non)solution immediately.</td>
    <td class="lineNumber">2800</td>
    <td class="codeline">  // Identify 0 as a (non)solution immediately.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2801</td>
    <td class="codeline">  if (C.sextOrTrunc(RangeWidth).isZero()) {</td>
    <td class="lineNumber">2801</td>
    <td class="codeline">  if (C.sextOrTrunc(RangeWidth).isZero()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2802</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << __func__ << ": zero solution\n");</td>
    <td class="lineNumber">2802</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << __func__ << ": zero solution\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2803</td>
    <td class="codeline">    return APInt(CoeffWidth, 0);</td>
    <td class="lineNumber">2803</td>
    <td class="codeline">    return APInt(CoeffWidth, 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2804</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2804</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2805</td>
    <td class="codeline"></td>
    <td class="lineNumber">2805</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2806</td>
    <td class="codeline">  // The result of APInt arithmetic has the same bit width as the operands,</td>
    <td class="lineNumber">2806</td>
    <td class="codeline">  // The result of APInt arithmetic has the same bit width as the operands,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2807</td>
    <td class="codeline">  // so it can actually lose high bits. A product of two n-bit integers needs</td>
    <td class="lineNumber">2807</td>
    <td class="codeline">  // so it can actually lose high bits. A product of two n-bit integers needs</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2808</td>
    <td class="codeline">  // 2n-1 bits to represent the full value.</td>
    <td class="lineNumber">2808</td>
    <td class="codeline">  // 2n-1 bits to represent the full value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2809</td>
    <td class="codeline">  // The operation done below (on quadratic coefficients) that can produce</td>
    <td class="lineNumber">2809</td>
    <td class="codeline">  // The operation done below (on quadratic coefficients) that can produce</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2810</td>
    <td class="codeline">  // the largest value is the evaluation of the equation during bisection,</td>
    <td class="lineNumber">2810</td>
    <td class="codeline">  // the largest value is the evaluation of the equation during bisection,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2811</td>
    <td class="codeline">  // which needs 3 times the bitwidth of the coefficient, so the total number</td>
    <td class="lineNumber">2811</td>
    <td class="codeline">  // which needs 3 times the bitwidth of the coefficient, so the total number</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2812</td>
    <td class="codeline">  // of required bits is 3n.</td>
    <td class="lineNumber">2812</td>
    <td class="codeline">  // of required bits is 3n.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2813</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">2813</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2814</td>
    <td class="codeline">  // The purpose of this extension is to simulate the set Z of all integers,</td>
    <td class="lineNumber">2814</td>
    <td class="codeline">  // The purpose of this extension is to simulate the set Z of all integers,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2815</td>
    <td class="codeline">  // where n+1 > n for all n in Z. In Z it makes sense to talk about positive</td>
    <td class="lineNumber">2815</td>
    <td class="codeline">  // where n+1 > n for all n in Z. In Z it makes sense to talk about positive</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2816</td>
    <td class="codeline">  // and negative numbers (not so much in a modulo arithmetic). The method</td>
    <td class="lineNumber">2816</td>
    <td class="codeline">  // and negative numbers (not so much in a modulo arithmetic). The method</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2817</td>
    <td class="codeline">  // used to solve the equation is based on the standard formula for real</td>
    <td class="lineNumber">2817</td>
    <td class="codeline">  // used to solve the equation is based on the standard formula for real</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2818</td>
    <td class="codeline">  // numbers, and uses the concepts of "positive" and "negative" with their</td>
    <td class="lineNumber">2818</td>
    <td class="codeline">  // numbers, and uses the concepts of "positive" and "negative" with their</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2819</td>
    <td class="codeline">  // usual meanings.</td>
    <td class="lineNumber">2819</td>
    <td class="codeline">  // usual meanings.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2820</td>
    <td class="codeline">  CoeffWidth *= 3;</td>
    <td class="lineNumber">2820</td>
    <td class="codeline">  CoeffWidth *= 3;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2821</td>
    <td class="codeline">  A = A.sext(CoeffWidth);</td>
    <td class="lineNumber">2821</td>
    <td class="codeline">  A = A.sext(CoeffWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2822</td>
    <td class="codeline">  B = B.sext(CoeffWidth);</td>
    <td class="lineNumber">2822</td>
    <td class="codeline">  B = B.sext(CoeffWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2823</td>
    <td class="codeline">  C = C.sext(CoeffWidth);</td>
    <td class="lineNumber">2823</td>
    <td class="codeline">  C = C.sext(CoeffWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2824</td>
    <td class="codeline"></td>
    <td class="lineNumber">2824</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2825</td>
    <td class="codeline">  // Make A > 0 for simplicity. Negate cannot overflow at this point because</td>
    <td class="lineNumber">2825</td>
    <td class="codeline">  // Make A > 0 for simplicity. Negate cannot overflow at this point because</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2826</td>
    <td class="codeline">  // the bit width has increased.</td>
    <td class="lineNumber">2826</td>
    <td class="codeline">  // the bit width has increased.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2827</td>
    <td class="codeline">  if (A.isNegative()) {</td>
    <td class="lineNumber">2827</td>
    <td class="codeline">  if (A.isNegative()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2828</td>
    <td class="codeline">    A.negate();</td>
    <td class="lineNumber">2828</td>
    <td class="codeline">    A.negate();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2829</td>
    <td class="codeline">    B.negate();</td>
    <td class="lineNumber">2829</td>
    <td class="codeline">    B.negate();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2830</td>
    <td class="codeline">    C.negate();</td>
    <td class="lineNumber">2830</td>
    <td class="codeline">    C.negate();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2831</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2831</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2832</td>
    <td class="codeline"></td>
    <td class="lineNumber">2832</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2833</td>
    <td class="codeline">  // Solving an equation q(x) = 0 with coefficients in modular arithmetic</td>
    <td class="lineNumber">2833</td>
    <td class="codeline">  // Solving an equation q(x) = 0 with coefficients in modular arithmetic</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2834</td>
    <td class="codeline">  // is really solving a set of equations q(x) = kR for k = 0, 1, 2, ...,</td>
    <td class="lineNumber">2834</td>
    <td class="codeline">  // is really solving a set of equations q(x) = kR for k = 0, 1, 2, ...,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2835</td>
    <td class="codeline">  // and R = 2^BitWidth.</td>
    <td class="lineNumber">2835</td>
    <td class="codeline">  // and R = 2^BitWidth.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2836</td>
    <td class="codeline">  // Since we're trying not only to find exact solutions, but also values</td>
    <td class="lineNumber">2836</td>
    <td class="codeline">  // Since we're trying not only to find exact solutions, but also values</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2837</td>
    <td class="codeline">  // that "wrap around", such a set will always have a solution, i.e. an x</td>
    <td class="lineNumber">2837</td>
    <td class="codeline">  // that "wrap around", such a set will always have a solution, i.e. an x</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2838</td>
    <td class="codeline">  // that satisfies at least one of the equations, or such that |q(x)|</td>
    <td class="lineNumber">2838</td>
    <td class="codeline">  // that satisfies at least one of the equations, or such that |q(x)|</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2839</td>
    <td class="codeline">  // exceeds kR, while |q(x-1)| for the same k does not.</td>
    <td class="lineNumber">2839</td>
    <td class="codeline">  // exceeds kR, while |q(x-1)| for the same k does not.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2840</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">2840</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2841</td>
    <td class="codeline">  // We need to find a value k, such that Ax^2 + Bx + C = kR will have a</td>
    <td class="lineNumber">2841</td>
    <td class="codeline">  // We need to find a value k, such that Ax^2 + Bx + C = kR will have a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2842</td>
    <td class="codeline">  // positive solution n (in the above sense), and also such that the n</td>
    <td class="lineNumber">2842</td>
    <td class="codeline">  // positive solution n (in the above sense), and also such that the n</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2843</td>
    <td class="codeline">  // will be the least among all solutions corresponding to k = 0, 1, ...</td>
    <td class="lineNumber">2843</td>
    <td class="codeline">  // will be the least among all solutions corresponding to k = 0, 1, ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2844</td>
    <td class="codeline">  // (more precisely, the least element in the set</td>
    <td class="lineNumber">2844</td>
    <td class="codeline">  // (more precisely, the least element in the set</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2845</td>
    <td class="codeline">  //   { n(k) | k is such that a solution n(k) exists }).</td>
    <td class="lineNumber">2845</td>
    <td class="codeline">  //   { n(k) | k is such that a solution n(k) exists }).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2846</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">2846</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2847</td>
    <td class="codeline">  // Consider the parabola (over real numbers) that corresponds to the</td>
    <td class="lineNumber">2847</td>
    <td class="codeline">  // Consider the parabola (over real numbers) that corresponds to the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2848</td>
    <td class="codeline">  // quadratic equation. Since A > 0, the arms of the parabola will point</td>
    <td class="lineNumber">2848</td>
    <td class="codeline">  // quadratic equation. Since A > 0, the arms of the parabola will point</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2849</td>
    <td class="codeline">  // up. Picking different values of k will shift it up and down by R.</td>
    <td class="lineNumber">2849</td>
    <td class="codeline">  // up. Picking different values of k will shift it up and down by R.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2850</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">2850</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2851</td>
    <td class="codeline">  // We want to shift the parabola in such a way as to reduce the problem</td>
    <td class="lineNumber">2851</td>
    <td class="codeline">  // We want to shift the parabola in such a way as to reduce the problem</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2852</td>
    <td class="codeline">  // of solving q(x) = kR to solving shifted_q(x) = 0.</td>
    <td class="lineNumber">2852</td>
    <td class="codeline">  // of solving q(x) = kR to solving shifted_q(x) = 0.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2853</td>
    <td class="codeline">  // (The interesting solutions are the ceilings of the real number</td>
    <td class="lineNumber">2853</td>
    <td class="codeline">  // (The interesting solutions are the ceilings of the real number</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2854</td>
    <td class="codeline">  // solutions.)</td>
    <td class="lineNumber">2854</td>
    <td class="codeline">  // solutions.)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2855</td>
    <td class="codeline">  APInt R = APInt::getOneBitSet(CoeffWidth, RangeWidth);</td>
    <td class="lineNumber">2855</td>
    <td class="codeline">  APInt R = APInt::getOneBitSet(CoeffWidth, RangeWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2856</td>
    <td class="codeline">  APInt TwoA = 2 * A;</td>
    <td class="lineNumber">2856</td>
    <td class="codeline">  APInt TwoA = 2 * A;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2857</td>
    <td class="codeline">  APInt SqrB = B * B;</td>
    <td class="lineNumber">2857</td>
    <td class="codeline">  APInt SqrB = B * B;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2858</td>
    <td class="codeline">  bool PickLow;</td>
    <td class="lineNumber">2858</td>
    <td class="codeline">  bool PickLow;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2859</td>
    <td class="codeline"></td>
    <td class="lineNumber">2859</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2860</td>
    <td class="codeline">  auto RoundUp = [] (const APInt &V, const APInt &A) -> APInt {</td>
    <td class="lineNumber">2860</td>
    <td class="codeline">  auto RoundUp = [] (const APInt &V, const APInt &A) -> APInt {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2861</td>
    <td class="codeline">    assert(A.isStrictlyPositive());</td>
    <td class="lineNumber">2861</td>
    <td class="codeline">    assert(A.isStrictlyPositive());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2862</td>
    <td class="codeline">    APInt T = V.abs().urem(A);</td>
    <td class="lineNumber">2862</td>
    <td class="codeline">    APInt T = V.abs().urem(A);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2863</td>
    <td class="codeline">    if (T.isZero())</td>
    <td class="lineNumber">2863</td>
    <td class="codeline">    if (T.isZero())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2864</td>
    <td class="codeline">      return V;</td>
    <td class="lineNumber">2864</td>
    <td class="codeline">      return V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2865</td>
    <td class="codeline">    return V.isNegative() ? V+T : V+(A-T);</td>
    <td class="lineNumber">2865</td>
    <td class="codeline">    return V.isNegative() ? V+T : V+(A-T);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2866</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">2866</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2867</td>
    <td class="codeline"></td>
    <td class="lineNumber">2867</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2868</td>
    <td class="codeline">  // The vertex of the parabola is at -B/2A, but since A > 0, it's negative</td>
    <td class="lineNumber">2868</td>
    <td class="codeline">  // The vertex of the parabola is at -B/2A, but since A > 0, it's negative</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2869</td>
    <td class="codeline">  // iff B is positive.</td>
    <td class="lineNumber">2869</td>
    <td class="codeline">  // iff B is positive.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2870</td>
    <td class="codeline">  if (B.isNonNegative()) {</td>
    <td class="lineNumber">2870</td>
    <td class="codeline">  if (B.isNonNegative()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2871</td>
    <td class="codeline">    // If B >= 0, the vertex it at a negative location (or at 0), so in</td>
    <td class="lineNumber">2871</td>
    <td class="codeline">    // If B >= 0, the vertex it at a negative location (or at 0), so in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2872</td>
    <td class="codeline">    // order to have a non-negative solution we need to pick k that makes</td>
    <td class="lineNumber">2872</td>
    <td class="codeline">    // order to have a non-negative solution we need to pick k that makes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2873</td>
    <td class="codeline">    // C-kR negative. To satisfy all the requirements for the solution</td>
    <td class="lineNumber">2873</td>
    <td class="codeline">    // C-kR negative. To satisfy all the requirements for the solution</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2874</td>
    <td class="codeline">    // that we are looking for, it needs to be closest to 0 of all k.</td>
    <td class="lineNumber">2874</td>
    <td class="codeline">    // that we are looking for, it needs to be closest to 0 of all k.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2875</td>
    <td class="codeline">    C = C.srem(R);</td>
    <td class="lineNumber">2875</td>
    <td class="codeline">    C = C.srem(R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2876</td>
    <td class="codeline">    if (C.isStrictlyPositive())</td>
    <td class="lineNumber">2876</td>
    <td class="codeline">    if (C.isStrictlyPositive())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2877</td>
    <td class="codeline">      C -= R;</td>
    <td class="lineNumber">2877</td>
    <td class="codeline">      C -= R;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2878</td>
    <td class="codeline">    // Pick the greater solution.</td>
    <td class="lineNumber">2878</td>
    <td class="codeline">    // Pick the greater solution.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2879</td>
    <td class="codeline">    PickLow = false;</td>
    <td class="lineNumber">2879</td>
    <td class="codeline">    PickLow = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2880</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">2880</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2881</td>
    <td class="codeline">    // If B < 0, the vertex is at a positive location. For any solution</td>
    <td class="lineNumber">2881</td>
    <td class="codeline">    // If B < 0, the vertex is at a positive location. For any solution</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2882</td>
    <td class="codeline">    // to exist, the discriminant must be non-negative. This means that</td>
    <td class="lineNumber">2882</td>
    <td class="codeline">    // to exist, the discriminant must be non-negative. This means that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2883</td>
    <td class="codeline">    // C-kR <= B^2/4A is a necessary condition for k, i.e. there is a</td>
    <td class="lineNumber">2883</td>
    <td class="codeline">    // C-kR <= B^2/4A is a necessary condition for k, i.e. there is a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2884</td>
    <td class="codeline">    // lower bound on values of k: kR >= C - B^2/4A.</td>
    <td class="lineNumber">2884</td>
    <td class="codeline">    // lower bound on values of k: kR >= C - B^2/4A.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2885</td>
    <td class="codeline">    APInt LowkR = C - SqrB.udiv(2*TwoA); // udiv because all values > 0.</td>
    <td class="lineNumber">2885</td>
    <td class="codeline">    APInt LowkR = C - SqrB.udiv(2*TwoA); // udiv because all values > 0.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2886</td>
    <td class="codeline">    // Round LowkR up (towards +inf) to the nearest kR.</td>
    <td class="lineNumber">2886</td>
    <td class="codeline">    // Round LowkR up (towards +inf) to the nearest kR.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2887</td>
    <td class="codeline">    LowkR = RoundUp(LowkR, R);</td>
    <td class="lineNumber">2887</td>
    <td class="codeline">    LowkR = RoundUp(LowkR, R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2888</td>
    <td class="codeline"></td>
    <td class="lineNumber">2888</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2889</td>
    <td class="codeline">    // If there exists k meeting the condition above, and such that</td>
    <td class="lineNumber">2889</td>
    <td class="codeline">    // If there exists k meeting the condition above, and such that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2890</td>
    <td class="codeline">    // C-kR > 0, there will be two positive real number solutions of</td>
    <td class="lineNumber">2890</td>
    <td class="codeline">    // C-kR > 0, there will be two positive real number solutions of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2891</td>
    <td class="codeline">    // q(x) = kR. Out of all such values of k, pick the one that makes</td>
    <td class="lineNumber">2891</td>
    <td class="codeline">    // q(x) = kR. Out of all such values of k, pick the one that makes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2892</td>
    <td class="codeline">    // C-kR closest to 0, (i.e. pick maximum k such that C-kR > 0).</td>
    <td class="lineNumber">2892</td>
    <td class="codeline">    // C-kR closest to 0, (i.e. pick maximum k such that C-kR > 0).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2893</td>
    <td class="codeline">    // In other words, find maximum k such that LowkR <= kR < C.</td>
    <td class="lineNumber">2893</td>
    <td class="codeline">    // In other words, find maximum k such that LowkR <= kR < C.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2894</td>
    <td class="codeline">    if (C.sgt(LowkR)) {</td>
    <td class="lineNumber">2894</td>
    <td class="codeline">    if (C.sgt(LowkR)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2895</td>
    <td class="codeline">      // If LowkR < C, then such a k is guaranteed to exist because</td>
    <td class="lineNumber">2895</td>
    <td class="codeline">      // If LowkR < C, then such a k is guaranteed to exist because</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2896</td>
    <td class="codeline">      // LowkR itself is a multiple of R.</td>
    <td class="lineNumber">2896</td>
    <td class="codeline">      // LowkR itself is a multiple of R.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2897</td>
    <td class="codeline">      C -= -RoundUp(-C, R);      // C = C - RoundDown(C, R)</td>
    <td class="lineNumber">2897</td>
    <td class="codeline">      C -= -RoundUp(-C, R);      // C = C - RoundDown(C, R)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2898</td>
    <td class="codeline">      // Pick the smaller solution.</td>
    <td class="lineNumber">2898</td>
    <td class="codeline">      // Pick the smaller solution.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2899</td>
    <td class="codeline">      PickLow = true;</td>
    <td class="lineNumber">2899</td>
    <td class="codeline">      PickLow = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2900</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">2900</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2901</td>
    <td class="codeline">      // If C-kR < 0 for all potential k's, it means that one solution</td>
    <td class="lineNumber">2901</td>
    <td class="codeline">      // If C-kR < 0 for all potential k's, it means that one solution</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2902</td>
    <td class="codeline">      // will be negative, while the other will be positive. The positive</td>
    <td class="lineNumber">2902</td>
    <td class="codeline">      // will be negative, while the other will be positive. The positive</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2903</td>
    <td class="codeline">      // solution will shift towards 0 if the parabola is moved up.</td>
    <td class="lineNumber">2903</td>
    <td class="codeline">      // solution will shift towards 0 if the parabola is moved up.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2904</td>
    <td class="codeline">      // Pick the kR closest to the lower bound (i.e. make C-kR closest</td>
    <td class="lineNumber">2904</td>
    <td class="codeline">      // Pick the kR closest to the lower bound (i.e. make C-kR closest</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2905</td>
    <td class="codeline">      // to 0, or in other words, out of all parabolas that have solutions,</td>
    <td class="lineNumber">2905</td>
    <td class="codeline">      // to 0, or in other words, out of all parabolas that have solutions,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2906</td>
    <td class="codeline">      // pick the one that is the farthest "up").</td>
    <td class="lineNumber">2906</td>
    <td class="codeline">      // pick the one that is the farthest "up").</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2907</td>
    <td class="codeline">      // Since LowkR is itself a multiple of R, simply take C-LowkR.</td>
    <td class="lineNumber">2907</td>
    <td class="codeline">      // Since LowkR is itself a multiple of R, simply take C-LowkR.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2908</td>
    <td class="codeline">      C -= LowkR;</td>
    <td class="lineNumber">2908</td>
    <td class="codeline">      C -= LowkR;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2909</td>
    <td class="codeline">      // Pick the greater solution.</td>
    <td class="lineNumber">2909</td>
    <td class="codeline">      // Pick the greater solution.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2910</td>
    <td class="codeline">      PickLow = false;</td>
    <td class="lineNumber">2910</td>
    <td class="codeline">      PickLow = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2911</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2911</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2912</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2912</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2913</td>
    <td class="codeline"></td>
    <td class="lineNumber">2913</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2914</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << __func__ << ": updated coefficients " << A << "x^2 + "</td>
    <td class="lineNumber">2914</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << __func__ << ": updated coefficients " << A << "x^2 + "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2915</td>
    <td class="codeline">                    << B << "x + " << C << ", rw:" << RangeWidth << '\n');</td>
    <td class="lineNumber">2915</td>
    <td class="codeline">                    << B << "x + " << C << ", rw:" << RangeWidth << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2916</td>
    <td class="codeline"></td>
    <td class="lineNumber">2916</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2917</td>
    <td class="codeline">  APInt D = SqrB - 4*A*C;</td>
    <td class="lineNumber">2917</td>
    <td class="codeline">  APInt D = SqrB - 4*A*C;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2918</td>
    <td class="codeline">  assert(D.isNonNegative() && "Negative discriminant");</td>
    <td class="lineNumber">2918</td>
    <td class="codeline">  assert(D.isNonNegative() && "Negative discriminant");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2919</td>
    <td class="codeline">  APInt SQ = D.sqrt();</td>
    <td class="lineNumber">2919</td>
    <td class="codeline">  APInt SQ = D.sqrt();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2920</td>
    <td class="codeline"></td>
    <td class="lineNumber">2920</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2921</td>
    <td class="codeline">  APInt Q = SQ * SQ;</td>
    <td class="lineNumber">2921</td>
    <td class="codeline">  APInt Q = SQ * SQ;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2922</td>
    <td class="codeline">  bool InexactSQ = Q != D;</td>
    <td class="lineNumber">2922</td>
    <td class="codeline">  bool InexactSQ = Q != D;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2923</td>
    <td class="codeline">  // The calculated SQ may actually be greater than the exact (non-integer)</td>
    <td class="lineNumber">2923</td>
    <td class="codeline">  // The calculated SQ may actually be greater than the exact (non-integer)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2924</td>
    <td class="codeline">  // value. If that's the case, decrement SQ to get a value that is lower.</td>
    <td class="lineNumber">2924</td>
    <td class="codeline">  // value. If that's the case, decrement SQ to get a value that is lower.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2925</td>
    <td class="codeline">  if (Q.sgt(D))</td>
    <td class="lineNumber">2925</td>
    <td class="codeline">  if (Q.sgt(D))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2926</td>
    <td class="codeline">    SQ -= 1;</td>
    <td class="lineNumber">2926</td>
    <td class="codeline">    SQ -= 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2927</td>
    <td class="codeline"></td>
    <td class="lineNumber">2927</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2928</td>
    <td class="codeline">  APInt X;</td>
    <td class="lineNumber">2928</td>
    <td class="codeline">  APInt X;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2929</td>
    <td class="codeline">  APInt Rem;</td>
    <td class="lineNumber">2929</td>
    <td class="codeline">  APInt Rem;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2930</td>
    <td class="codeline"></td>
    <td class="lineNumber">2930</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2931</td>
    <td class="codeline">  // SQ is rounded down (i.e SQ * SQ <= D), so the roots may be inexact.</td>
    <td class="lineNumber">2931</td>
    <td class="codeline">  // SQ is rounded down (i.e SQ * SQ <= D), so the roots may be inexact.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2932</td>
    <td class="codeline">  // When using the quadratic formula directly, the calculated low root</td>
    <td class="lineNumber">2932</td>
    <td class="codeline">  // When using the quadratic formula directly, the calculated low root</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2933</td>
    <td class="codeline">  // may be greater than the exact one, since we would be subtracting SQ.</td>
    <td class="lineNumber">2933</td>
    <td class="codeline">  // may be greater than the exact one, since we would be subtracting SQ.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2934</td>
    <td class="codeline">  // To make sure that the calculated root is not greater than the exact</td>
    <td class="lineNumber">2934</td>
    <td class="codeline">  // To make sure that the calculated root is not greater than the exact</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2935</td>
    <td class="codeline">  // one, subtract SQ+1 when calculating the low root (for inexact value</td>
    <td class="lineNumber">2935</td>
    <td class="codeline">  // one, subtract SQ+1 when calculating the low root (for inexact value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2936</td>
    <td class="codeline">  // of SQ).</td>
    <td class="lineNumber">2936</td>
    <td class="codeline">  // of SQ).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2937</td>
    <td class="codeline">  if (PickLow)</td>
    <td class="lineNumber">2937</td>
    <td class="codeline">  if (PickLow)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2938</td>
    <td class="codeline">    APInt::sdivrem(-B - (SQ+InexactSQ), TwoA, X, Rem);</td>
    <td class="lineNumber">2938</td>
    <td class="codeline">    APInt::sdivrem(-B - (SQ+InexactSQ), TwoA, X, Rem);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2939</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">2939</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2940</td>
    <td class="codeline">    APInt::sdivrem(-B + SQ, TwoA, X, Rem);</td>
    <td class="lineNumber">2940</td>
    <td class="codeline">    APInt::sdivrem(-B + SQ, TwoA, X, Rem);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2941</td>
    <td class="codeline"></td>
    <td class="lineNumber">2941</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2942</td>
    <td class="codeline">  // The updated coefficients should be such that the (exact) solution is</td>
    <td class="lineNumber">2942</td>
    <td class="codeline">  // The updated coefficients should be such that the (exact) solution is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2943</td>
    <td class="codeline">  // positive. Since APInt division rounds towards 0, the calculated one</td>
    <td class="lineNumber">2943</td>
    <td class="codeline">  // positive. Since APInt division rounds towards 0, the calculated one</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2944</td>
    <td class="codeline">  // can be 0, but cannot be negative.</td>
    <td class="lineNumber">2944</td>
    <td class="codeline">  // can be 0, but cannot be negative.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2945</td>
    <td class="codeline">  assert(X.isNonNegative() && "Solution should be non-negative");</td>
    <td class="lineNumber">2945</td>
    <td class="codeline">  assert(X.isNonNegative() && "Solution should be non-negative");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2946</td>
    <td class="codeline"></td>
    <td class="lineNumber">2946</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2947</td>
    <td class="codeline">  if (!InexactSQ && Rem.isZero()) {</td>
    <td class="lineNumber">2947</td>
    <td class="codeline">  if (!InexactSQ && Rem.isZero()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2948</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << __func__ << ": solution (root): " << X << '\n');</td>
    <td class="lineNumber">2948</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << __func__ << ": solution (root): " << X << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2949</td>
    <td class="codeline">    return X;</td>
    <td class="lineNumber">2949</td>
    <td class="codeline">    return X;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2950</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2950</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2951</td>
    <td class="codeline"></td>
    <td class="lineNumber">2951</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2952</td>
    <td class="codeline">  assert((SQ*SQ).sle(D) && "SQ = |_sqrt(D)_|, so SQ*SQ <= D");</td>
    <td class="lineNumber">2952</td>
    <td class="codeline">  assert((SQ*SQ).sle(D) && "SQ = |_sqrt(D)_|, so SQ*SQ <= D");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2953</td>
    <td class="codeline">  // The exact value of the square root of D should be between SQ and SQ+1.</td>
    <td class="lineNumber">2953</td>
    <td class="codeline">  // The exact value of the square root of D should be between SQ and SQ+1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2954</td>
    <td class="codeline">  // This implies that the solution should be between that corresponding to</td>
    <td class="lineNumber">2954</td>
    <td class="codeline">  // This implies that the solution should be between that corresponding to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2955</td>
    <td class="codeline">  // SQ (i.e. X) and that corresponding to SQ+1.</td>
    <td class="lineNumber">2955</td>
    <td class="codeline">  // SQ (i.e. X) and that corresponding to SQ+1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2956</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">2956</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2957</td>
    <td class="codeline">  // The calculated X cannot be greater than the exact (real) solution.</td>
    <td class="lineNumber">2957</td>
    <td class="codeline">  // The calculated X cannot be greater than the exact (real) solution.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2958</td>
    <td class="codeline">  // Actually it must be strictly less than the exact solution, while</td>
    <td class="lineNumber">2958</td>
    <td class="codeline">  // Actually it must be strictly less than the exact solution, while</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2959</td>
    <td class="codeline">  // X+1 will be greater than or equal to it.</td>
    <td class="lineNumber">2959</td>
    <td class="codeline">  // X+1 will be greater than or equal to it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2960</td>
    <td class="codeline"></td>
    <td class="lineNumber">2960</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2961</td>
    <td class="codeline">  APInt VX = (A*X + B)*X + C;</td>
    <td class="lineNumber">2961</td>
    <td class="codeline">  APInt VX = (A*X + B)*X + C;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2962</td>
    <td class="codeline">  APInt VY = VX + TwoA*X + A + B;</td>
    <td class="lineNumber">2962</td>
    <td class="codeline">  APInt VY = VX + TwoA*X + A + B;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2963</td>
    <td class="codeline">  bool SignChange =</td>
    <td class="lineNumber">2963</td>
    <td class="codeline">  bool SignChange =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2964</td>
    <td class="codeline">      VX.isNegative() != VY.isNegative() || VX.isZero() != VY.isZero();</td>
    <td class="lineNumber">2964</td>
    <td class="codeline">      VX.isNegative() != VY.isNegative() || VX.isZero() != VY.isZero();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2965</td>
    <td class="codeline">  // If the sign did not change between X and X+1, X is not a valid solution.</td>
    <td class="lineNumber">2965</td>
    <td class="codeline">  // If the sign did not change between X and X+1, X is not a valid solution.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2966</td>
    <td class="codeline">  // This could happen when the actual (exact) roots don't have an integer</td>
    <td class="lineNumber">2966</td>
    <td class="codeline">  // This could happen when the actual (exact) roots don't have an integer</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2967</td>
    <td class="codeline">  // between them, so they would both be contained between X and X+1.</td>
    <td class="lineNumber">2967</td>
    <td class="codeline">  // between them, so they would both be contained between X and X+1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2968</td>
    <td class="codeline">  if (!SignChange) {</td>
    <td class="lineNumber">2968</td>
    <td class="codeline">  if (!SignChange) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2969</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << __func__ << ": no valid solution\n");</td>
    <td class="lineNumber">2969</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << __func__ << ": no valid solution\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2970</td>
    <td class="codeline">    return std::nullopt;</td>
    <td class="lineNumber">2970</td>
    <td class="codeline">    return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2971</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2971</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2972</td>
    <td class="codeline"></td>
    <td class="lineNumber">2972</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2973</td>
    <td class="codeline">  X += 1;</td>
    <td class="lineNumber">2973</td>
    <td class="codeline">  X += 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2974</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << __func__ << ": solution (wrap): " << X << '\n');</td>
    <td class="lineNumber">2974</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << __func__ << ": solution (wrap): " << X << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2975</td>
    <td class="codeline">  return X;</td>
    <td class="lineNumber">2975</td>
    <td class="codeline">  return X;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2976</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2976</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2977</td>
    <td class="codeline"></td>
    <td class="lineNumber">2977</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2978</td>
    <td class="codeline">std::optional<unsigned></td>
    <td class="lineNumber">2978</td>
    <td class="codeline">std::optional<unsigned></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2979</td>
    <td class="codeline">llvm::APIntOps::GetMostSignificantDifferentBit(const APInt &A, const APInt &B) {</td>
    <td class="lineNumber">2979</td>
    <td class="codeline">llvm::APIntOps::GetMostSignificantDifferentBit(const APInt &A, const APInt &B) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2980</td>
    <td class="codeline">  assert(A.getBitWidth() == B.getBitWidth() && "Must have the same bitwidth");</td>
    <td class="lineNumber">2980</td>
    <td class="codeline">  assert(A.getBitWidth() == B.getBitWidth() && "Must have the same bitwidth");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2981</td>
    <td class="codeline">  if (A == B)</td>
    <td class="lineNumber">2981</td>
    <td class="codeline">  if (A == B)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2982</td>
    <td class="codeline">    return std::nullopt;</td>
    <td class="lineNumber">2982</td>
    <td class="codeline">    return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2983</td>
    <td class="codeline">  return A.getBitWidth() - ((A ^ B).countl_zero() + 1);</td>
    <td class="lineNumber">2983</td>
    <td class="codeline">  return A.getBitWidth() - ((A ^ B).countl_zero() + 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2984</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2984</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2985</td>
    <td class="codeline"></td>
    <td class="lineNumber">2985</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2986</td>
    <td class="codeline">APInt llvm::APIntOps::ScaleBitMask(const APInt &A, unsigned NewBitWidth,</td>
    <td class="lineNumber">2986</td>
    <td class="codeline">APInt llvm::APIntOps::ScaleBitMask(const APInt &A, unsigned NewBitWidth,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2987</td>
    <td class="codeline">                                   bool MatchAllBits) {</td>
    <td class="lineNumber">2987</td>
    <td class="codeline">                                   bool MatchAllBits) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2988</td>
    <td class="codeline">  unsigned OldBitWidth = A.getBitWidth();</td>
    <td class="lineNumber">2988</td>
    <td class="codeline">  unsigned OldBitWidth = A.getBitWidth();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2989</td>
    <td class="codeline">  assert((((OldBitWidth % NewBitWidth) == 0) ||</td>
    <td class="lineNumber">2989</td>
    <td class="codeline">  assert((((OldBitWidth % NewBitWidth) == 0) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2990</td>
    <td class="codeline">          ((NewBitWidth % OldBitWidth) == 0)) &&</td>
    <td class="lineNumber">2990</td>
    <td class="codeline">          ((NewBitWidth % OldBitWidth) == 0)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2991</td>
    <td class="codeline">         "One size should be a multiple of the other one. "</td>
    <td class="lineNumber">2991</td>
    <td class="codeline">         "One size should be a multiple of the other one. "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2992</td>
    <td class="codeline">         "Can't do fractional scaling.");</td>
    <td class="lineNumber">2992</td>
    <td class="codeline">         "Can't do fractional scaling.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2993</td>
    <td class="codeline"></td>
    <td class="lineNumber">2993</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2994</td>
    <td class="codeline">  // Check for matching bitwidths.</td>
    <td class="lineNumber">2994</td>
    <td class="codeline">  // Check for matching bitwidths.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2995</td>
    <td class="codeline">  if (OldBitWidth == NewBitWidth)</td>
    <td class="lineNumber">2995</td>
    <td class="codeline">  if (OldBitWidth == NewBitWidth)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2996</td>
    <td class="codeline">    return A;</td>
    <td class="lineNumber">2996</td>
    <td class="codeline">    return A;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2997</td>
    <td class="codeline"></td>
    <td class="lineNumber">2997</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2998</td>
    <td class="codeline">  APInt NewA = APInt::getZero(NewBitWidth);</td>
    <td class="lineNumber">2998</td>
    <td class="codeline">  APInt NewA = APInt::getZero(NewBitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2999</td>
    <td class="codeline"></td>
    <td class="lineNumber">2999</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3000</td>
    <td class="codeline">  // Check for null input.</td>
    <td class="lineNumber">3000</td>
    <td class="codeline">  // Check for null input.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3001</td>
    <td class="codeline">  if (A.isZero())</td>
    <td class="lineNumber">3001</td>
    <td class="codeline">  if (A.isZero())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3002</td>
    <td class="codeline">    return NewA;</td>
    <td class="lineNumber">3002</td>
    <td class="codeline">    return NewA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3003</td>
    <td class="codeline"></td>
    <td class="lineNumber">3003</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3004</td>
    <td class="codeline">  if (NewBitWidth > OldBitWidth) {</td>
    <td class="lineNumber">3004</td>
    <td class="codeline">  if (NewBitWidth > OldBitWidth) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3005</td>
    <td class="codeline">    // Repeat bits.</td>
    <td class="lineNumber">3005</td>
    <td class="codeline">    // Repeat bits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3006</td>
    <td class="codeline">    unsigned Scale = NewBitWidth / OldBitWidth;</td>
    <td class="lineNumber">3006</td>
    <td class="codeline">    unsigned Scale = NewBitWidth / OldBitWidth;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3007</td>
    <td class="codeline">    for (unsigned i = 0; i != OldBitWidth; ++i)</td>
    <td class="lineNumber">3007</td>
    <td class="codeline">    for (unsigned i = 0; i != OldBitWidth; ++i)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3008</td>
    <td class="codeline">      if (A[i])</td>
    <td class="lineNumber">3008</td>
    <td class="codeline">      if (A[i])</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3009</td>
    <td class="codeline">        NewA.setBits(i * Scale, (i + 1) * Scale);</td>
    <td class="lineNumber">3009</td>
    <td class="codeline">        NewA.setBits(i * Scale, (i + 1) * Scale);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3010</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">3010</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3011</td>
    <td class="codeline">    unsigned Scale = OldBitWidth / NewBitWidth;</td>
    <td class="lineNumber">3011</td>
    <td class="codeline">    unsigned Scale = OldBitWidth / NewBitWidth;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3012</td>
    <td class="codeline">    for (unsigned i = 0; i != NewBitWidth; ++i) {</td>
    <td class="lineNumber">3012</td>
    <td class="codeline">    for (unsigned i = 0; i != NewBitWidth; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3013</td>
    <td class="codeline">      if (MatchAllBits) {</td>
    <td class="lineNumber">3013</td>
    <td class="codeline">      if (MatchAllBits) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3014</td>
    <td class="codeline">        if (A.extractBits(Scale, i * Scale).isAllOnes())</td>
    <td class="lineNumber">3014</td>
    <td class="codeline">        if (A.extractBits(Scale, i * Scale).isAllOnes())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3015</td>
    <td class="codeline">          NewA.setBit(i);</td>
    <td class="lineNumber">3015</td>
    <td class="codeline">          NewA.setBit(i);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3016</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">3016</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3017</td>
    <td class="codeline">        if (!A.extractBits(Scale, i * Scale).isZero())</td>
    <td class="lineNumber">3017</td>
    <td class="codeline">        if (!A.extractBits(Scale, i * Scale).isZero())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3018</td>
    <td class="codeline">          NewA.setBit(i);</td>
    <td class="lineNumber">3018</td>
    <td class="codeline">          NewA.setBit(i);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3019</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">3019</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3020</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3020</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3021</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3021</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3022</td>
    <td class="codeline"></td>
    <td class="lineNumber">3022</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3023</td>
    <td class="codeline">  return NewA;</td>
    <td class="lineNumber">3023</td>
    <td class="codeline">  return NewA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3024</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3024</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3025</td>
    <td class="codeline"></td>
    <td class="lineNumber">3025</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3026</td>
    <td class="codeline">/// StoreIntToMemory - Fills the StoreBytes bytes of memory starting from Dst</td>
    <td class="lineNumber">3026</td>
    <td class="codeline">/// StoreIntToMemory - Fills the StoreBytes bytes of memory starting from Dst</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3027</td>
    <td class="codeline">/// with the integer held in IntVal.</td>
    <td class="lineNumber">3027</td>
    <td class="codeline">/// with the integer held in IntVal.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3028</td>
    <td class="codeline">void llvm::StoreIntToMemory(const APInt &IntVal, uint8_t *Dst,</td>
    <td class="lineNumber">3028</td>
    <td class="codeline">void llvm::StoreIntToMemory(const APInt &IntVal, uint8_t *Dst,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3029</td>
    <td class="codeline">                            unsigned StoreBytes) {</td>
    <td class="lineNumber">3029</td>
    <td class="codeline">                            unsigned StoreBytes) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3030</td>
    <td class="codeline">  assert((IntVal.getBitWidth()+7)/8 >= StoreBytes && "Integer too small!");</td>
    <td class="lineNumber">3030</td>
    <td class="codeline">  assert((IntVal.getBitWidth()+7)/8 >= StoreBytes && "Integer too small!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3031</td>
    <td class="codeline">  const uint8_t *Src = (const uint8_t *)IntVal.getRawData();</td>
    <td class="lineNumber">3031</td>
    <td class="codeline">  const uint8_t *Src = (const uint8_t *)IntVal.getRawData();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3032</td>
    <td class="codeline"></td>
    <td class="lineNumber">3032</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3033</td>
    <td class="codeline">  if (sys::IsLittleEndianHost) {</td>
    <td class="lineNumber">3033</td>
    <td class="codeline">  if (sys::IsLittleEndianHost) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3034</td>
    <td class="codeline">    // Little-endian host - the source is ordered from LSB to MSB.  Order the</td>
    <td class="lineNumber">3034</td>
    <td class="codeline">    // Little-endian host - the source is ordered from LSB to MSB.  Order the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3035</td>
    <td class="codeline">    // destination from LSB to MSB: Do a straight copy.</td>
    <td class="lineNumber">3035</td>
    <td class="codeline">    // destination from LSB to MSB: Do a straight copy.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3036</td>
    <td class="codeline">    memcpy(Dst, Src, StoreBytes);</td>
    <td class="lineNumber">3036</td>
    <td class="codeline">    memcpy(Dst, Src, StoreBytes);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3037</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">3037</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3038</td>
    <td class="codeline">    // Big-endian host - the source is an array of 64 bit words ordered from</td>
    <td class="lineNumber">3038</td>
    <td class="codeline">    // Big-endian host - the source is an array of 64 bit words ordered from</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3039</td>
    <td class="codeline">    // LSW to MSW.  Each word is ordered from MSB to LSB.  Order the destination</td>
    <td class="lineNumber">3039</td>
    <td class="codeline">    // LSW to MSW.  Each word is ordered from MSB to LSB.  Order the destination</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3040</td>
    <td class="codeline">    // from MSB to LSB: Reverse the word order, but not the bytes in a word.</td>
    <td class="lineNumber">3040</td>
    <td class="codeline">    // from MSB to LSB: Reverse the word order, but not the bytes in a word.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3041</td>
    <td class="codeline">    while (StoreBytes > sizeof(uint64_t)) {</td>
    <td class="lineNumber">3041</td>
    <td class="codeline">    while (StoreBytes > sizeof(uint64_t)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3042</td>
    <td class="codeline">      StoreBytes -= sizeof(uint64_t);</td>
    <td class="lineNumber">3042</td>
    <td class="codeline">      StoreBytes -= sizeof(uint64_t);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3043</td>
    <td class="codeline">      // May not be aligned so use memcpy.</td>
    <td class="lineNumber">3043</td>
    <td class="codeline">      // May not be aligned so use memcpy.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3044</td>
    <td class="codeline">      memcpy(Dst + StoreBytes, Src, sizeof(uint64_t));</td>
    <td class="lineNumber">3044</td>
    <td class="codeline">      memcpy(Dst + StoreBytes, Src, sizeof(uint64_t));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3045</td>
    <td class="codeline">      Src += sizeof(uint64_t);</td>
    <td class="lineNumber">3045</td>
    <td class="codeline">      Src += sizeof(uint64_t);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3046</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3046</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3047</td>
    <td class="codeline"></td>
    <td class="lineNumber">3047</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3048</td>
    <td class="codeline">    memcpy(Dst, Src + sizeof(uint64_t) - StoreBytes, StoreBytes);</td>
    <td class="lineNumber">3048</td>
    <td class="codeline">    memcpy(Dst, Src + sizeof(uint64_t) - StoreBytes, StoreBytes);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3049</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3049</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3050</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3050</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3051</td>
    <td class="codeline"></td>
    <td class="lineNumber">3051</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3052</td>
    <td class="codeline">/// LoadIntFromMemory - Loads the integer stored in the LoadBytes bytes starting</td>
    <td class="lineNumber">3052</td>
    <td class="codeline">/// LoadIntFromMemory - Loads the integer stored in the LoadBytes bytes starting</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3053</td>
    <td class="codeline">/// from Src into IntVal, which is assumed to be wide enough and to hold zero.</td>
    <td class="lineNumber">3053</td>
    <td class="codeline">/// from Src into IntVal, which is assumed to be wide enough and to hold zero.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3054</td>
    <td class="codeline">void llvm::LoadIntFromMemory(APInt &IntVal, const uint8_t *Src,</td>
    <td class="lineNumber">3054</td>
    <td class="codeline">void llvm::LoadIntFromMemory(APInt &IntVal, const uint8_t *Src,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3055</td>
    <td class="codeline">                             unsigned LoadBytes) {</td>
    <td class="lineNumber">3055</td>
    <td class="codeline">                             unsigned LoadBytes) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3056</td>
    <td class="codeline">  assert((IntVal.getBitWidth()+7)/8 >= LoadBytes && "Integer too small!");</td>
    <td class="lineNumber">3056</td>
    <td class="codeline">  assert((IntVal.getBitWidth()+7)/8 >= LoadBytes && "Integer too small!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3057</td>
    <td class="codeline">  uint8_t *Dst = reinterpret_cast<uint8_t *>(</td>
    <td class="lineNumber">3057</td>
    <td class="codeline">  uint8_t *Dst = reinterpret_cast<uint8_t *>(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3058</td>
    <td class="codeline">                   const_cast<uint64_t *>(IntVal.getRawData()));</td>
    <td class="lineNumber">3058</td>
    <td class="codeline">                   const_cast<uint64_t *>(IntVal.getRawData()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3059</td>
    <td class="codeline"></td>
    <td class="lineNumber">3059</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3060</td>
    <td class="codeline">  if (sys::IsLittleEndianHost)</td>
    <td class="lineNumber">3060</td>
    <td class="codeline">  if (sys::IsLittleEndianHost)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3061</td>
    <td class="codeline">    // Little-endian host - the destination must be ordered from LSB to MSB.</td>
    <td class="lineNumber">3061</td>
    <td class="codeline">    // Little-endian host - the destination must be ordered from LSB to MSB.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3062</td>
    <td class="codeline">    // The source is ordered from LSB to MSB: Do a straight copy.</td>
    <td class="lineNumber">3062</td>
    <td class="codeline">    // The source is ordered from LSB to MSB: Do a straight copy.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3063</td>
    <td class="codeline">    memcpy(Dst, Src, LoadBytes);</td>
    <td class="lineNumber">3063</td>
    <td class="codeline">    memcpy(Dst, Src, LoadBytes);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3064</td>
    <td class="codeline">  else {</td>
    <td class="lineNumber">3064</td>
    <td class="codeline">  else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3065</td>
    <td class="codeline">    // Big-endian - the destination is an array of 64 bit words ordered from</td>
    <td class="lineNumber">3065</td>
    <td class="codeline">    // Big-endian - the destination is an array of 64 bit words ordered from</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3066</td>
    <td class="codeline">    // LSW to MSW.  Each word must be ordered from MSB to LSB.  The source is</td>
    <td class="lineNumber">3066</td>
    <td class="codeline">    // LSW to MSW.  Each word must be ordered from MSB to LSB.  The source is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3067</td>
    <td class="codeline">    // ordered from MSB to LSB: Reverse the word order, but not the bytes in</td>
    <td class="lineNumber">3067</td>
    <td class="codeline">    // ordered from MSB to LSB: Reverse the word order, but not the bytes in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3068</td>
    <td class="codeline">    // a word.</td>
    <td class="lineNumber">3068</td>
    <td class="codeline">    // a word.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3069</td>
    <td class="codeline">    while (LoadBytes > sizeof(uint64_t)) {</td>
    <td class="lineNumber">3069</td>
    <td class="codeline">    while (LoadBytes > sizeof(uint64_t)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3070</td>
    <td class="codeline">      LoadBytes -= sizeof(uint64_t);</td>
    <td class="lineNumber">3070</td>
    <td class="codeline">      LoadBytes -= sizeof(uint64_t);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3071</td>
    <td class="codeline">      // May not be aligned so use memcpy.</td>
    <td class="lineNumber">3071</td>
    <td class="codeline">      // May not be aligned so use memcpy.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3072</td>
    <td class="codeline">      memcpy(Dst, Src + LoadBytes, sizeof(uint64_t));</td>
    <td class="lineNumber">3072</td>
    <td class="codeline">      memcpy(Dst, Src + LoadBytes, sizeof(uint64_t));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3073</td>
    <td class="codeline">      Dst += sizeof(uint64_t);</td>
    <td class="lineNumber">3073</td>
    <td class="codeline">      Dst += sizeof(uint64_t);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3074</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3074</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3075</td>
    <td class="codeline"></td>
    <td class="lineNumber">3075</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3076</td>
    <td class="codeline">    memcpy(Dst + sizeof(uint64_t) - LoadBytes, Src, LoadBytes);</td>
    <td class="lineNumber">3076</td>
    <td class="codeline">    memcpy(Dst + sizeof(uint64_t) - LoadBytes, Src, LoadBytes);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3077</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3077</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3078</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3078</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3079</td>
    <td class="codeline"></td>
    <td class="lineNumber">3079</td>
    <td class="codeline"></td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Side By Side Comparison</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Side By Side Comparison</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeLine">//===-- APInt.cpp - Implement APInt class ---------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1</td>
    <td class="codeLine">//===-- APInt.cpp - Implement APInt class ---------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeLine">// This file implements a class to represent arbitrary precision integer</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">9</td>
    <td class="codeLine">// This file implements a class to represent arbitrary precision integer</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeLine">// constant values and provide a variety of arithmetic operations on them.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">10</td>
    <td class="codeLine">// constant values and provide a variety of arithmetic operations on them.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">11</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">12</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">13</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeLine">#include "llvm/ADT/APInt.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">14</td>
    <td class="codeLine">#include "llvm/ADT/APInt.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeLine">#include "llvm/ADT/ArrayRef.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">15</td>
    <td class="codeLine">#include "llvm/ADT/ArrayRef.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeLine">#include "llvm/ADT/FoldingSet.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">16</td>
    <td class="codeLine">#include "llvm/ADT/FoldingSet.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeLine">#include "llvm/ADT/Hashing.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">17</td>
    <td class="codeLine">#include "llvm/ADT/Hashing.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeLine">#include "llvm/ADT/SmallString.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">18</td>
    <td class="codeLine">#include "llvm/ADT/SmallString.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeLine">#include "llvm/ADT/StringRef.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">19</td>
    <td class="codeLine">#include "llvm/ADT/StringRef.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeLine">#include "llvm/ADT/bit.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">20</td>
    <td class="codeLine">#include "llvm/ADT/bit.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeLine">#include "llvm/Config/llvm-config.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">21</td>
    <td class="codeLine">#include "llvm/Config/llvm-config.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "llvm/Support/Alignment.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "llvm/Support/Alignment.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/Support/ErrorHandling.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/Support/ErrorHandling.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/Support/MathExtras.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/Support/MathExtras.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeLine">#include <cmath></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">27</td>
    <td class="codeLine">#include <cmath></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeLine">#include <optional></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">28</td>
    <td class="codeLine">#include <optional></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">29</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">30</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">31</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeLine">#define DEBUG_TYPE "apint"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">32</td>
    <td class="codeLine">#define DEBUG_TYPE "apint"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">33</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeLine">/// A utility function for allocating memory, checking for allocation failures,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">34</td>
    <td class="codeLine">/// A utility function for allocating memory, checking for allocation failures,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeLine">/// and ensuring the contents are zeroed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">35</td>
    <td class="codeLine">/// and ensuring the contents are zeroed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeLine">inline static uint64_t* getClearedMemory(unsigned numWords) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">36</td>
    <td class="codeLine">inline static uint64_t* getClearedMemory(unsigned numWords) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeLine">  uint64_t *result = new uint64_t[numWords];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">37</td>
    <td class="codeLine">  uint64_t *result = new uint64_t[numWords];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeLine">  memset(result, 0, numWords * sizeof(uint64_t));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">38</td>
    <td class="codeLine">  memset(result, 0, numWords * sizeof(uint64_t));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeLine">  return result;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">39</td>
    <td class="codeLine">  return result;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">40</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">41</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeLine">/// A utility function for allocating memory and checking for allocation</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">42</td>
    <td class="codeLine">/// A utility function for allocating memory and checking for allocation</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeLine">/// failure.  The content is not zeroed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">43</td>
    <td class="codeLine">/// failure.  The content is not zeroed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeLine">inline static uint64_t* getMemory(unsigned numWords) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">44</td>
    <td class="codeLine">inline static uint64_t* getMemory(unsigned numWords) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeLine">  return new uint64_t[numWords];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">45</td>
    <td class="codeLine">  return new uint64_t[numWords];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">46</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">47</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeLine">/// A utility function that converts a character to a digit.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">48</td>
    <td class="codeLine">/// A utility function that converts a character to a digit.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeLine coveredLine">inline static unsigned getDigit(char cdigit, uint8_t radix) {</td>
    <td class="lineNumber">215</td>
    <td class="lineNumber">49</td>
    <td class="codeLine coveredLine">inline static unsigned getDigit(char cdigit, uint8_t radix) {</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeLine">  unsigned r;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">50</td>
    <td class="codeLine">  unsigned r;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">51</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeLine coveredLine">  if (radix == 16 || radix == 36) {</td>
    <td class="lineNumber">215</td>
    <td class="lineNumber">52</td>
    <td class="codeLine coveredLine">  if (radix == 16 || radix == 36) {</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeLine">    r = cdigit - '0';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">53</td>
    <td class="codeLine">    r = cdigit - '0';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeLine">    if (r <= 9)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">54</td>
    <td class="codeLine">    if (r <= 9)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeLine">      return r;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">55</td>
    <td class="codeLine">      return r;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">56</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeLine">    r = cdigit - 'A';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">57</td>
    <td class="codeLine">    r = cdigit - 'A';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeLine">    if (r <= radix - 11U)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">58</td>
    <td class="codeLine">    if (r <= radix - 11U)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeLine">      return r + 10;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">59</td>
    <td class="codeLine">      return r + 10;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">60</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeLine">    r = cdigit - 'a';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">61</td>
    <td class="codeLine">    r = cdigit - 'a';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeLine">    if (r <= radix - 11U)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">62</td>
    <td class="codeLine">    if (r <= radix - 11U)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeLine">      return r + 10;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">63</td>
    <td class="codeLine">      return r + 10;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">64</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeLine">    radix = 10;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">65</td>
    <td class="codeLine">    radix = 10;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">66</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">67</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeLine coveredLine">  r = cdigit - '0';</td>
    <td class="lineNumber">215</td>
    <td class="lineNumber">68</td>
    <td class="codeLine coveredLine">  r = cdigit - '0';</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeLine coveredLine">  if (r < radix)</td>
    <td class="lineNumber">215</td>
    <td class="lineNumber">69</td>
    <td class="codeLine coveredLine">  if (r < radix)</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeLine coveredLine">    return r;</td>
    <td class="lineNumber">215</td>
    <td class="lineNumber">70</td>
    <td class="codeLine coveredLine">    return r;</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">71</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeLine">  return UINT_MAX;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">72</td>
    <td class="codeLine">  return UINT_MAX;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">73</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">74</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">75</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeLine">void APInt::initSlowCase(uint64_t val, bool isSigned) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">76</td>
    <td class="codeLine">void APInt::initSlowCase(uint64_t val, bool isSigned) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeLine">  U.pVal = getClearedMemory(getNumWords());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">77</td>
    <td class="codeLine">  U.pVal = getClearedMemory(getNumWords());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeLine">  U.pVal[0] = val;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">78</td>
    <td class="codeLine">  U.pVal[0] = val;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeLine">  if (isSigned && int64_t(val) < 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">79</td>
    <td class="codeLine">  if (isSigned && int64_t(val) < 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeLine">    for (unsigned i = 1; i < getNumWords(); ++i)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">80</td>
    <td class="codeLine">    for (unsigned i = 1; i < getNumWords(); ++i)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeLine">      U.pVal[i] = WORDTYPE_MAX;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">81</td>
    <td class="codeLine">      U.pVal[i] = WORDTYPE_MAX;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeLine">  clearUnusedBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">82</td>
    <td class="codeLine">  clearUnusedBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">83</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">84</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeLine">void APInt::initSlowCase(const APInt& that) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">85</td>
    <td class="codeLine">void APInt::initSlowCase(const APInt& that) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeLine">  U.pVal = getMemory(getNumWords());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">86</td>
    <td class="codeLine">  U.pVal = getMemory(getNumWords());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeLine">  memcpy(U.pVal, that.U.pVal, getNumWords() * APINT_WORD_SIZE);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">87</td>
    <td class="codeLine">  memcpy(U.pVal, that.U.pVal, getNumWords() * APINT_WORD_SIZE);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">88</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">89</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeLine">void APInt::initFromArray(ArrayRef<uint64_t> bigVal) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">90</td>
    <td class="codeLine">void APInt::initFromArray(ArrayRef<uint64_t> bigVal) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeLine">  assert(bigVal.data() && "Null pointer detected!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">91</td>
    <td class="codeLine">  assert(bigVal.data() && "Null pointer detected!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeLine">  if (isSingleWord())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">92</td>
    <td class="codeLine">  if (isSingleWord())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeLine">    U.VAL = bigVal[0];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">93</td>
    <td class="codeLine">    U.VAL = bigVal[0];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeLine">  else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">94</td>
    <td class="codeLine">  else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeLine">    // Get memory, cleared to 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">95</td>
    <td class="codeLine">    // Get memory, cleared to 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeLine">    U.pVal = getClearedMemory(getNumWords());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">96</td>
    <td class="codeLine">    U.pVal = getClearedMemory(getNumWords());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeLine">    // Calculate the number of words to copy</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">97</td>
    <td class="codeLine">    // Calculate the number of words to copy</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeLine">    unsigned words = std::min<unsigned>(bigVal.size(), getNumWords());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">98</td>
    <td class="codeLine">    unsigned words = std::min<unsigned>(bigVal.size(), getNumWords());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeLine">    // Copy the words from bigVal to pVal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">99</td>
    <td class="codeLine">    // Copy the words from bigVal to pVal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeLine">    memcpy(U.pVal, bigVal.data(), words * APINT_WORD_SIZE);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">100</td>
    <td class="codeLine">    memcpy(U.pVal, bigVal.data(), words * APINT_WORD_SIZE);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">101</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeLine">  // Make sure unused high bits are cleared</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">102</td>
    <td class="codeLine">  // Make sure unused high bits are cleared</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeLine">  clearUnusedBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">103</td>
    <td class="codeLine">  clearUnusedBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">104</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">105</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeLine">APInt::APInt(unsigned numBits, ArrayRef<uint64_t> bigVal) : BitWidth(numBits) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">106</td>
    <td class="codeLine">APInt::APInt(unsigned numBits, ArrayRef<uint64_t> bigVal) : BitWidth(numBits) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeLine">  initFromArray(bigVal);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">107</td>
    <td class="codeLine">  initFromArray(bigVal);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">108</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">109</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeLine">APInt::APInt(unsigned numBits, unsigned numWords, const uint64_t bigVal[])</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">110</td>
    <td class="codeLine">APInt::APInt(unsigned numBits, unsigned numWords, const uint64_t bigVal[])</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeLine">    : BitWidth(numBits) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">111</td>
    <td class="codeLine">    : BitWidth(numBits) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeLine">  initFromArray(ArrayRef(bigVal, numWords));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">112</td>
    <td class="codeLine">  initFromArray(ArrayRef(bigVal, numWords));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">113</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">114</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeLine coveredLine">APInt::APInt(unsigned numbits, StringRef Str, uint8_t radix)</td>
    <td class="lineNumber">149</td>
    <td class="lineNumber">115</td>
    <td class="codeLine coveredLine">APInt::APInt(unsigned numbits, StringRef Str, uint8_t radix)</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeLine coveredLine">    : BitWidth(numbits) {</td>
    <td class="lineNumber">149</td>
    <td class="lineNumber">116</td>
    <td class="codeLine coveredLine">    : BitWidth(numbits) {</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeLine coveredLine">  fromString(numbits, Str, radix);</td>
    <td class="lineNumber">149</td>
    <td class="lineNumber">117</td>
    <td class="codeLine coveredLine">  fromString(numbits, Str, radix);</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">149</td>
    <td class="lineNumber">118</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">119</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeLine">void APInt::reallocate(unsigned NewBitWidth) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">120</td>
    <td class="codeLine">void APInt::reallocate(unsigned NewBitWidth) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeLine">  // If the number of words is the same we can just change the width and stop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">121</td>
    <td class="codeLine">  // If the number of words is the same we can just change the width and stop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeLine">  if (getNumWords() == getNumWords(NewBitWidth)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">122</td>
    <td class="codeLine">  if (getNumWords() == getNumWords(NewBitWidth)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeLine">    BitWidth = NewBitWidth;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">123</td>
    <td class="codeLine">    BitWidth = NewBitWidth;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">124</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">125</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">126</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeLine">  // If we have an allocation, delete it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">127</td>
    <td class="codeLine">  // If we have an allocation, delete it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeLine">  if (!isSingleWord())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">128</td>
    <td class="codeLine">  if (!isSingleWord())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeLine">    delete [] U.pVal;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">129</td>
    <td class="codeLine">    delete [] U.pVal;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">130</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeLine">  // Update BitWidth.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">131</td>
    <td class="codeLine">  // Update BitWidth.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeLine">  BitWidth = NewBitWidth;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">132</td>
    <td class="codeLine">  BitWidth = NewBitWidth;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">133</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeLine">  // If we are supposed to have an allocation, create it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">134</td>
    <td class="codeLine">  // If we are supposed to have an allocation, create it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeLine">  if (!isSingleWord())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">135</td>
    <td class="codeLine">  if (!isSingleWord())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeLine">    U.pVal = getMemory(getNumWords());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">136</td>
    <td class="codeLine">    U.pVal = getMemory(getNumWords());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">137</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">138</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeLine">void APInt::assignSlowCase(const APInt &RHS) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">139</td>
    <td class="codeLine">void APInt::assignSlowCase(const APInt &RHS) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeLine">  // Don't do anything for X = X</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">140</td>
    <td class="codeLine">  // Don't do anything for X = X</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeLine">  if (this == &RHS)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">141</td>
    <td class="codeLine">  if (this == &RHS)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">142</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">143</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeLine">  // Adjust the bit width and handle allocations as necessary.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">144</td>
    <td class="codeLine">  // Adjust the bit width and handle allocations as necessary.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeLine">  reallocate(RHS.getBitWidth());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">145</td>
    <td class="codeLine">  reallocate(RHS.getBitWidth());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">146</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeLine">  // Copy the data.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">147</td>
    <td class="codeLine">  // Copy the data.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeLine">  if (isSingleWord())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">148</td>
    <td class="codeLine">  if (isSingleWord())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeLine">    U.VAL = RHS.U.VAL;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">149</td>
    <td class="codeLine">    U.VAL = RHS.U.VAL;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">150</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeLine">    memcpy(U.pVal, RHS.U.pVal, getNumWords() * APINT_WORD_SIZE);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">151</td>
    <td class="codeLine">    memcpy(U.pVal, RHS.U.pVal, getNumWords() * APINT_WORD_SIZE);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">152</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">153</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeLine">/// This method 'profiles' an APInt for use with FoldingSet.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">154</td>
    <td class="codeLine">/// This method 'profiles' an APInt for use with FoldingSet.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeLine">void APInt::Profile(FoldingSetNodeID& ID) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">155</td>
    <td class="codeLine">void APInt::Profile(FoldingSetNodeID& ID) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeLine">  ID.AddInteger(BitWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">156</td>
    <td class="codeLine">  ID.AddInteger(BitWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">157</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeLine">  if (isSingleWord()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">158</td>
    <td class="codeLine">  if (isSingleWord()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeLine">    ID.AddInteger(U.VAL);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">159</td>
    <td class="codeLine">    ID.AddInteger(U.VAL);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">160</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">161</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">162</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeLine">  unsigned NumWords = getNumWords();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">163</td>
    <td class="codeLine">  unsigned NumWords = getNumWords();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeLine">  for (unsigned i = 0; i < NumWords; ++i)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">164</td>
    <td class="codeLine">  for (unsigned i = 0; i < NumWords; ++i)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeLine">    ID.AddInteger(U.pVal[i]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">165</td>
    <td class="codeLine">    ID.AddInteger(U.pVal[i]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">166</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">167</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeLine coveredLine">bool APInt::isAligned(Align A) const {</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">168</td>
    <td class="codeLine coveredLine">bool APInt::isAligned(Align A) const {</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeLine coveredLine">  if (isZero())</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">169</td>
    <td class="codeLine coveredLine">  if (isZero())</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeLine coveredLine">    return true;</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">170</td>
    <td class="codeLine coveredLine">    return true;</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeLine">  const unsigned TrailingZeroes = countr_zero();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">171</td>
    <td class="codeLine">  const unsigned TrailingZeroes = countr_zero();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeLine">  const unsigned MinimumTrailingZeroes = Log2(A);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">172</td>
    <td class="codeLine">  const unsigned MinimumTrailingZeroes = Log2(A);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeLine">  return TrailingZeroes >= MinimumTrailingZeroes;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">173</td>
    <td class="codeLine">  return TrailingZeroes >= MinimumTrailingZeroes;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">174</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">175</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeLine">/// Prefix increment operator. Increments the APInt by one.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">176</td>
    <td class="codeLine">/// Prefix increment operator. Increments the APInt by one.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeLine">APInt& APInt::operator++() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">177</td>
    <td class="codeLine">APInt& APInt::operator++() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeLine">  if (isSingleWord())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">178</td>
    <td class="codeLine">  if (isSingleWord())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeLine">    ++U.VAL;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">179</td>
    <td class="codeLine">    ++U.VAL;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">180</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeLine">    tcIncrement(U.pVal, getNumWords());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">181</td>
    <td class="codeLine">    tcIncrement(U.pVal, getNumWords());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeLine">  return clearUnusedBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">182</td>
    <td class="codeLine">  return clearUnusedBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">183</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">184</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeLine">/// Prefix decrement operator. Decrements the APInt by one.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">185</td>
    <td class="codeLine">/// Prefix decrement operator. Decrements the APInt by one.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeLine">APInt& APInt::operator--() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">186</td>
    <td class="codeLine">APInt& APInt::operator--() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeLine">  if (isSingleWord())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">187</td>
    <td class="codeLine">  if (isSingleWord())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeLine">    --U.VAL;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">188</td>
    <td class="codeLine">    --U.VAL;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">189</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeLine">    tcDecrement(U.pVal, getNumWords());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">190</td>
    <td class="codeLine">    tcDecrement(U.pVal, getNumWords());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeLine">  return clearUnusedBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">191</td>
    <td class="codeLine">  return clearUnusedBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">192</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">193</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeLine">/// Adds the RHS APInt to this APInt.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">194</td>
    <td class="codeLine">/// Adds the RHS APInt to this APInt.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeLine">/// @returns this, after addition of RHS.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">195</td>
    <td class="codeLine">/// @returns this, after addition of RHS.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeLine">/// Addition assignment operator.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">196</td>
    <td class="codeLine">/// Addition assignment operator.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeLine">APInt& APInt::operator+=(const APInt& RHS) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">197</td>
    <td class="codeLine">APInt& APInt::operator+=(const APInt& RHS) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeLine">  assert(BitWidth == RHS.BitWidth && "Bit widths must be the same");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">198</td>
    <td class="codeLine">  assert(BitWidth == RHS.BitWidth && "Bit widths must be the same");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeLine">  if (isSingleWord())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">199</td>
    <td class="codeLine">  if (isSingleWord())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeLine">    U.VAL += RHS.U.VAL;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">200</td>
    <td class="codeLine">    U.VAL += RHS.U.VAL;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">201</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeLine">    tcAdd(U.pVal, RHS.U.pVal, 0, getNumWords());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">202</td>
    <td class="codeLine">    tcAdd(U.pVal, RHS.U.pVal, 0, getNumWords());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeLine">  return clearUnusedBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">203</td>
    <td class="codeLine">  return clearUnusedBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">204</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">205</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeLine coveredLine">APInt& APInt::operator+=(uint64_t RHS) {</td>
    <td class="lineNumber">215</td>
    <td class="lineNumber">206</td>
    <td class="codeLine coveredLine">APInt& APInt::operator+=(uint64_t RHS) {</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeLine coveredLine">  if (isSingleWord())</td>
    <td class="lineNumber">215</td>
    <td class="lineNumber">207</td>
    <td class="codeLine coveredLine">  if (isSingleWord())</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeLine coveredLine">    U.VAL += RHS;</td>
    <td class="lineNumber">215</td>
    <td class="lineNumber">208</td>
    <td class="codeLine coveredLine">    U.VAL += RHS;</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">209</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeLine">    tcAddPart(U.pVal, RHS, getNumWords());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">210</td>
    <td class="codeLine">    tcAddPart(U.pVal, RHS, getNumWords());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeLine coveredLine">  return clearUnusedBits();</td>
    <td class="lineNumber">215</td>
    <td class="lineNumber">211</td>
    <td class="codeLine coveredLine">  return clearUnusedBits();</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">212</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">213</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeLine">/// Subtracts the RHS APInt from this APInt</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">214</td>
    <td class="codeLine">/// Subtracts the RHS APInt from this APInt</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeLine">/// @returns this, after subtraction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">215</td>
    <td class="codeLine">/// @returns this, after subtraction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeLine">/// Subtraction assignment operator.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">216</td>
    <td class="codeLine">/// Subtraction assignment operator.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeLine">APInt& APInt::operator-=(const APInt& RHS) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">217</td>
    <td class="codeLine">APInt& APInt::operator-=(const APInt& RHS) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeLine">  assert(BitWidth == RHS.BitWidth && "Bit widths must be the same");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">218</td>
    <td class="codeLine">  assert(BitWidth == RHS.BitWidth && "Bit widths must be the same");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeLine">  if (isSingleWord())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">219</td>
    <td class="codeLine">  if (isSingleWord())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeLine">    U.VAL -= RHS.U.VAL;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">220</td>
    <td class="codeLine">    U.VAL -= RHS.U.VAL;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">221</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeLine">    tcSubtract(U.pVal, RHS.U.pVal, 0, getNumWords());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">222</td>
    <td class="codeLine">    tcSubtract(U.pVal, RHS.U.pVal, 0, getNumWords());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeLine">  return clearUnusedBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">223</td>
    <td class="codeLine">  return clearUnusedBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">224</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeLine">APInt& APInt::operator-=(uint64_t RHS) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">226</td>
    <td class="codeLine">APInt& APInt::operator-=(uint64_t RHS) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeLine">  if (isSingleWord())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">227</td>
    <td class="codeLine">  if (isSingleWord())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeLine">    U.VAL -= RHS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">228</td>
    <td class="codeLine">    U.VAL -= RHS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">229</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeLine">    tcSubtractPart(U.pVal, RHS, getNumWords());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">230</td>
    <td class="codeLine">    tcSubtractPart(U.pVal, RHS, getNumWords());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeLine">  return clearUnusedBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">231</td>
    <td class="codeLine">  return clearUnusedBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">232</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">233</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeLine">APInt APInt::operator*(const APInt& RHS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">234</td>
    <td class="codeLine">APInt APInt::operator*(const APInt& RHS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeLine">  assert(BitWidth == RHS.BitWidth && "Bit widths must be the same");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">235</td>
    <td class="codeLine">  assert(BitWidth == RHS.BitWidth && "Bit widths must be the same");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeLine">  if (isSingleWord())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">236</td>
    <td class="codeLine">  if (isSingleWord())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeLine">    return APInt(BitWidth, U.VAL * RHS.U.VAL);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">237</td>
    <td class="codeLine">    return APInt(BitWidth, U.VAL * RHS.U.VAL);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">238</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeLine">  APInt Result(getMemory(getNumWords()), getBitWidth());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">239</td>
    <td class="codeLine">  APInt Result(getMemory(getNumWords()), getBitWidth());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeLine">  tcMultiply(Result.U.pVal, U.pVal, RHS.U.pVal, getNumWords());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">240</td>
    <td class="codeLine">  tcMultiply(Result.U.pVal, U.pVal, RHS.U.pVal, getNumWords());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeLine">  Result.clearUnusedBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">241</td>
    <td class="codeLine">  Result.clearUnusedBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeLine">  return Result;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">242</td>
    <td class="codeLine">  return Result;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">243</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">244</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeLine">void APInt::andAssignSlowCase(const APInt &RHS) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">245</td>
    <td class="codeLine">void APInt::andAssignSlowCase(const APInt &RHS) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeLine">  WordType *dst = U.pVal, *rhs = RHS.U.pVal;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">246</td>
    <td class="codeLine">  WordType *dst = U.pVal, *rhs = RHS.U.pVal;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeLine">  for (size_t i = 0, e = getNumWords(); i != e; ++i)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">247</td>
    <td class="codeLine">  for (size_t i = 0, e = getNumWords(); i != e; ++i)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeLine">    dst[i] &= rhs[i];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">248</td>
    <td class="codeLine">    dst[i] &= rhs[i];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">249</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">250</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeLine">void APInt::orAssignSlowCase(const APInt &RHS) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">251</td>
    <td class="codeLine">void APInt::orAssignSlowCase(const APInt &RHS) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeLine">  WordType *dst = U.pVal, *rhs = RHS.U.pVal;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">252</td>
    <td class="codeLine">  WordType *dst = U.pVal, *rhs = RHS.U.pVal;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeLine">  for (size_t i = 0, e = getNumWords(); i != e; ++i)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">253</td>
    <td class="codeLine">  for (size_t i = 0, e = getNumWords(); i != e; ++i)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeLine">    dst[i] |= rhs[i];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">254</td>
    <td class="codeLine">    dst[i] |= rhs[i];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">255</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">256</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeLine">void APInt::xorAssignSlowCase(const APInt &RHS) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">257</td>
    <td class="codeLine">void APInt::xorAssignSlowCase(const APInt &RHS) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeLine">  WordType *dst = U.pVal, *rhs = RHS.U.pVal;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">258</td>
    <td class="codeLine">  WordType *dst = U.pVal, *rhs = RHS.U.pVal;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeLine">  for (size_t i = 0, e = getNumWords(); i != e; ++i)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">259</td>
    <td class="codeLine">  for (size_t i = 0, e = getNumWords(); i != e; ++i)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeLine">    dst[i] ^= rhs[i];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">260</td>
    <td class="codeLine">    dst[i] ^= rhs[i];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">261</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">262</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeLine">APInt &APInt::operator*=(const APInt &RHS) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">263</td>
    <td class="codeLine">APInt &APInt::operator*=(const APInt &RHS) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeLine">  *this = *this * RHS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">264</td>
    <td class="codeLine">  *this = *this * RHS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeLine">  return *this;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">265</td>
    <td class="codeLine">  return *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">266</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">267</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeLine coveredLine">APInt& APInt::operator*=(uint64_t RHS) {</td>
    <td class="lineNumber">132</td>
    <td class="lineNumber">268</td>
    <td class="codeLine">APInt& APInt::operator*=(uint64_t RHS) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeLine coveredLine">  if (isSingleWord()) {</td>
    <td class="lineNumber">132</td>
    <td class="lineNumber">269</td>
    <td class="codeLine">  if (isSingleWord()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeLine coveredLine">    U.VAL *= RHS;</td>
    <td class="lineNumber">132</td>
    <td class="lineNumber">270</td>
    <td class="codeLine">    U.VAL *= RHS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">271</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeLine">    unsigned NumWords = getNumWords();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">272</td>
    <td class="codeLine">    unsigned NumWords = getNumWords();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeLine">    tcMultiplyPart(U.pVal, U.pVal, RHS, 0, NumWords, NumWords, false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">273</td>
    <td class="codeLine">    tcMultiplyPart(U.pVal, U.pVal, RHS, 0, NumWords, NumWords, false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">274</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeLine coveredLine">  return clearUnusedBits();</td>
    <td class="lineNumber">132</td>
    <td class="lineNumber">275</td>
    <td class="codeLine">  return clearUnusedBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">276</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">277</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeLine">bool APInt::equalSlowCase(const APInt &RHS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">278</td>
    <td class="codeLine">bool APInt::equalSlowCase(const APInt &RHS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeLine">  return std::equal(U.pVal, U.pVal + getNumWords(), RHS.U.pVal);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">279</td>
    <td class="codeLine">  return std::equal(U.pVal, U.pVal + getNumWords(), RHS.U.pVal);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">280</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">281</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeLine coveredLine">int APInt::compare(const APInt& RHS) const {</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">282</td>
    <td class="codeLine coveredLine">int APInt::compare(const APInt& RHS) const {</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeLine coveredLine">  assert(BitWidth == RHS.BitWidth && "Bit widths must be same for comparison");</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">283</td>
    <td class="codeLine coveredLine">  assert(BitWidth == RHS.BitWidth && "Bit widths must be same for comparison");</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeLine coveredLine">  if (isSingleWord())</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">284</td>
    <td class="codeLine coveredLine">  if (isSingleWord())</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeLine coveredLine">    return U.VAL < RHS.U.VAL ? -1 : U.VAL > RHS.U.VAL;</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">285</td>
    <td class="codeLine coveredLine">    return U.VAL < RHS.U.VAL ? -1 : U.VAL > RHS.U.VAL;</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">286</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeLine">  return tcCompare(U.pVal, RHS.U.pVal, getNumWords());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">287</td>
    <td class="codeLine">  return tcCompare(U.pVal, RHS.U.pVal, getNumWords());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">288</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">289</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeLine">int APInt::compareSigned(const APInt& RHS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">290</td>
    <td class="codeLine">int APInt::compareSigned(const APInt& RHS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeLine">  assert(BitWidth == RHS.BitWidth && "Bit widths must be same for comparison");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">291</td>
    <td class="codeLine">  assert(BitWidth == RHS.BitWidth && "Bit widths must be same for comparison");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeLine">  if (isSingleWord()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">292</td>
    <td class="codeLine">  if (isSingleWord()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeLine">    int64_t lhsSext = SignExtend64(U.VAL, BitWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">293</td>
    <td class="codeLine">    int64_t lhsSext = SignExtend64(U.VAL, BitWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeLine">    int64_t rhsSext = SignExtend64(RHS.U.VAL, BitWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">294</td>
    <td class="codeLine">    int64_t rhsSext = SignExtend64(RHS.U.VAL, BitWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeLine">    return lhsSext < rhsSext ? -1 : lhsSext > rhsSext;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">295</td>
    <td class="codeLine">    return lhsSext < rhsSext ? -1 : lhsSext > rhsSext;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">296</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">297</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeLine">  bool lhsNeg = isNegative();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">298</td>
    <td class="codeLine">  bool lhsNeg = isNegative();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeLine">  bool rhsNeg = RHS.isNegative();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">299</td>
    <td class="codeLine">  bool rhsNeg = RHS.isNegative();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">300</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeLine">  // If the sign bits don't match, then (LHS < RHS) if LHS is negative</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">301</td>
    <td class="codeLine">  // If the sign bits don't match, then (LHS < RHS) if LHS is negative</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeLine">  if (lhsNeg != rhsNeg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">302</td>
    <td class="codeLine">  if (lhsNeg != rhsNeg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeLine">    return lhsNeg ? -1 : 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">303</td>
    <td class="codeLine">    return lhsNeg ? -1 : 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">304</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeLine">  // Otherwise we can just use an unsigned comparison, because even negative</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">305</td>
    <td class="codeLine">  // Otherwise we can just use an unsigned comparison, because even negative</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeLine">  // numbers compare correctly this way if both have the same signed-ness.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">306</td>
    <td class="codeLine">  // numbers compare correctly this way if both have the same signed-ness.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeLine">  return tcCompare(U.pVal, RHS.U.pVal, getNumWords());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">307</td>
    <td class="codeLine">  return tcCompare(U.pVal, RHS.U.pVal, getNumWords());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">308</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">309</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeLine">void APInt::setBitsSlowCase(unsigned loBit, unsigned hiBit) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">310</td>
    <td class="codeLine">void APInt::setBitsSlowCase(unsigned loBit, unsigned hiBit) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeLine">  unsigned loWord = whichWord(loBit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">311</td>
    <td class="codeLine">  unsigned loWord = whichWord(loBit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeLine">  unsigned hiWord = whichWord(hiBit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">312</td>
    <td class="codeLine">  unsigned hiWord = whichWord(hiBit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">313</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeLine">  // Create an initial mask for the low word with zeros below loBit.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">314</td>
    <td class="codeLine">  // Create an initial mask for the low word with zeros below loBit.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeLine">  uint64_t loMask = WORDTYPE_MAX << whichBit(loBit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">315</td>
    <td class="codeLine">  uint64_t loMask = WORDTYPE_MAX << whichBit(loBit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">316</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeLine">  // If hiBit is not aligned, we need a high mask.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">317</td>
    <td class="codeLine">  // If hiBit is not aligned, we need a high mask.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeLine">  unsigned hiShiftAmt = whichBit(hiBit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">318</td>
    <td class="codeLine">  unsigned hiShiftAmt = whichBit(hiBit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeLine">  if (hiShiftAmt != 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">319</td>
    <td class="codeLine">  if (hiShiftAmt != 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeLine">    // Create a high mask with zeros above hiBit.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">320</td>
    <td class="codeLine">    // Create a high mask with zeros above hiBit.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeLine">    uint64_t hiMask = WORDTYPE_MAX >> (APINT_BITS_PER_WORD - hiShiftAmt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">321</td>
    <td class="codeLine">    uint64_t hiMask = WORDTYPE_MAX >> (APINT_BITS_PER_WORD - hiShiftAmt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeLine">    // If loWord and hiWord are equal, then we combine the masks. Otherwise,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">322</td>
    <td class="codeLine">    // If loWord and hiWord are equal, then we combine the masks. Otherwise,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeLine">    // set the bits in hiWord.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">323</td>
    <td class="codeLine">    // set the bits in hiWord.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeLine">    if (hiWord == loWord)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">324</td>
    <td class="codeLine">    if (hiWord == loWord)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeLine">      loMask &= hiMask;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">325</td>
    <td class="codeLine">      loMask &= hiMask;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">326</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeLine">      U.pVal[hiWord] |= hiMask;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">327</td>
    <td class="codeLine">      U.pVal[hiWord] |= hiMask;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">328</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeLine">  // Apply the mask to the low word.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">329</td>
    <td class="codeLine">  // Apply the mask to the low word.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeLine">  U.pVal[loWord] |= loMask;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">330</td>
    <td class="codeLine">  U.pVal[loWord] |= loMask;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">331</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeLine">  // Fill any words between loWord and hiWord with all ones.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">332</td>
    <td class="codeLine">  // Fill any words between loWord and hiWord with all ones.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeLine">  for (unsigned word = loWord + 1; word < hiWord; ++word)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">333</td>
    <td class="codeLine">  for (unsigned word = loWord + 1; word < hiWord; ++word)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeLine">    U.pVal[word] = WORDTYPE_MAX;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">334</td>
    <td class="codeLine">    U.pVal[word] = WORDTYPE_MAX;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">335</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">336</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeLine">// Complement a bignum in-place.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">337</td>
    <td class="codeLine">// Complement a bignum in-place.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeLine">static void tcComplement(APInt::WordType *dst, unsigned parts) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">338</td>
    <td class="codeLine">static void tcComplement(APInt::WordType *dst, unsigned parts) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeLine">  for (unsigned i = 0; i < parts; i++)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">339</td>
    <td class="codeLine">  for (unsigned i = 0; i < parts; i++)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeLine">    dst[i] = ~dst[i];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">340</td>
    <td class="codeLine">    dst[i] = ~dst[i];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">341</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">342</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeLine">/// Toggle every bit to its opposite value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">343</td>
    <td class="codeLine">/// Toggle every bit to its opposite value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeLine">void APInt::flipAllBitsSlowCase() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">344</td>
    <td class="codeLine">void APInt::flipAllBitsSlowCase() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeLine">  tcComplement(U.pVal, getNumWords());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">345</td>
    <td class="codeLine">  tcComplement(U.pVal, getNumWords());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeLine">  clearUnusedBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">346</td>
    <td class="codeLine">  clearUnusedBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">347</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">348</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeLine">/// Concatenate the bits from "NewLSB" onto the bottom of *this.  This is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">349</td>
    <td class="codeLine">/// Concatenate the bits from "NewLSB" onto the bottom of *this.  This is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeLine">/// equivalent to:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">350</td>
    <td class="codeLine">/// equivalent to:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeLine">///   (this->zext(NewWidth) << NewLSB.getBitWidth()) | NewLSB.zext(NewWidth)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">351</td>
    <td class="codeLine">///   (this->zext(NewWidth) << NewLSB.getBitWidth()) | NewLSB.zext(NewWidth)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeLine">/// In the slow case, we know the result is large.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">352</td>
    <td class="codeLine">/// In the slow case, we know the result is large.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeLine">APInt APInt::concatSlowCase(const APInt &NewLSB) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">353</td>
    <td class="codeLine">APInt APInt::concatSlowCase(const APInt &NewLSB) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeLine">  unsigned NewWidth = getBitWidth() + NewLSB.getBitWidth();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">354</td>
    <td class="codeLine">  unsigned NewWidth = getBitWidth() + NewLSB.getBitWidth();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeLine">  APInt Result = NewLSB.zext(NewWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">355</td>
    <td class="codeLine">  APInt Result = NewLSB.zext(NewWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeLine">  Result.insertBits(*this, NewLSB.getBitWidth());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">356</td>
    <td class="codeLine">  Result.insertBits(*this, NewLSB.getBitWidth());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeLine">  return Result;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">357</td>
    <td class="codeLine">  return Result;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">358</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">359</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeLine">/// Toggle a given bit to its opposite value whose position is given</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">360</td>
    <td class="codeLine">/// Toggle a given bit to its opposite value whose position is given</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeLine">/// as "bitPosition".</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">361</td>
    <td class="codeLine">/// as "bitPosition".</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeLine">/// Toggles a given bit to its opposite value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">362</td>
    <td class="codeLine">/// Toggles a given bit to its opposite value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeLine">void APInt::flipBit(unsigned bitPosition) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">363</td>
    <td class="codeLine">void APInt::flipBit(unsigned bitPosition) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeLine">  assert(bitPosition < BitWidth && "Out of the bit-width range!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">364</td>
    <td class="codeLine">  assert(bitPosition < BitWidth && "Out of the bit-width range!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeLine">  setBitVal(bitPosition, !(*this)[bitPosition]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">365</td>
    <td class="codeLine">  setBitVal(bitPosition, !(*this)[bitPosition]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">366</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">367</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeLine">void APInt::insertBits(const APInt &subBits, unsigned bitPosition) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">368</td>
    <td class="codeLine">void APInt::insertBits(const APInt &subBits, unsigned bitPosition) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeLine">  unsigned subBitWidth = subBits.getBitWidth();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">369</td>
    <td class="codeLine">  unsigned subBitWidth = subBits.getBitWidth();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeLine">  assert((subBitWidth + bitPosition) <= BitWidth && "Illegal bit insertion");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">370</td>
    <td class="codeLine">  assert((subBitWidth + bitPosition) <= BitWidth && "Illegal bit insertion");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">371</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeLine">  // inserting no bits is a noop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">372</td>
    <td class="codeLine">  // inserting no bits is a noop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeLine">  if (subBitWidth == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">373</td>
    <td class="codeLine">  if (subBitWidth == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">374</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">375</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeLine">  // Insertion is a direct copy.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">376</td>
    <td class="codeLine">  // Insertion is a direct copy.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeLine">  if (subBitWidth == BitWidth) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">377</td>
    <td class="codeLine">  if (subBitWidth == BitWidth) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeLine">    *this = subBits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">378</td>
    <td class="codeLine">    *this = subBits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">379</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">380</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">381</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeLine">  // Single word result can be done as a direct bitmask.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">382</td>
    <td class="codeLine">  // Single word result can be done as a direct bitmask.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeLine">  if (isSingleWord()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">383</td>
    <td class="codeLine">  if (isSingleWord()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeLine">    uint64_t mask = WORDTYPE_MAX >> (APINT_BITS_PER_WORD - subBitWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">384</td>
    <td class="codeLine">    uint64_t mask = WORDTYPE_MAX >> (APINT_BITS_PER_WORD - subBitWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeLine">    U.VAL &= ~(mask << bitPosition);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">385</td>
    <td class="codeLine">    U.VAL &= ~(mask << bitPosition);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeLine">    U.VAL |= (subBits.U.VAL << bitPosition);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">386</td>
    <td class="codeLine">    U.VAL |= (subBits.U.VAL << bitPosition);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">387</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">388</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">389</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeLine">  unsigned loBit = whichBit(bitPosition);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">390</td>
    <td class="codeLine">  unsigned loBit = whichBit(bitPosition);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeLine">  unsigned loWord = whichWord(bitPosition);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">391</td>
    <td class="codeLine">  unsigned loWord = whichWord(bitPosition);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeLine">  unsigned hi1Word = whichWord(bitPosition + subBitWidth - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">392</td>
    <td class="codeLine">  unsigned hi1Word = whichWord(bitPosition + subBitWidth - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">393</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeLine">  // Insertion within a single word can be done as a direct bitmask.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">394</td>
    <td class="codeLine">  // Insertion within a single word can be done as a direct bitmask.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeLine">  if (loWord == hi1Word) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">395</td>
    <td class="codeLine">  if (loWord == hi1Word) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeLine">    uint64_t mask = WORDTYPE_MAX >> (APINT_BITS_PER_WORD - subBitWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">396</td>
    <td class="codeLine">    uint64_t mask = WORDTYPE_MAX >> (APINT_BITS_PER_WORD - subBitWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeLine">    U.pVal[loWord] &= ~(mask << loBit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">397</td>
    <td class="codeLine">    U.pVal[loWord] &= ~(mask << loBit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeLine">    U.pVal[loWord] |= (subBits.U.VAL << loBit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">398</td>
    <td class="codeLine">    U.pVal[loWord] |= (subBits.U.VAL << loBit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">399</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">400</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">401</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeLine">  // Insert on word boundaries.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">402</td>
    <td class="codeLine">  // Insert on word boundaries.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeLine">  if (loBit == 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">403</td>
    <td class="codeLine">  if (loBit == 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeLine">    // Direct copy whole words.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">404</td>
    <td class="codeLine">    // Direct copy whole words.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeLine">    unsigned numWholeSubWords = subBitWidth / APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">405</td>
    <td class="codeLine">    unsigned numWholeSubWords = subBitWidth / APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeLine">    memcpy(U.pVal + loWord, subBits.getRawData(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">406</td>
    <td class="codeLine">    memcpy(U.pVal + loWord, subBits.getRawData(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeLine">           numWholeSubWords * APINT_WORD_SIZE);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">407</td>
    <td class="codeLine">           numWholeSubWords * APINT_WORD_SIZE);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">408</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeLine">    // Mask+insert remaining bits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">409</td>
    <td class="codeLine">    // Mask+insert remaining bits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeLine">    unsigned remainingBits = subBitWidth % APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">410</td>
    <td class="codeLine">    unsigned remainingBits = subBitWidth % APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeLine">    if (remainingBits != 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">411</td>
    <td class="codeLine">    if (remainingBits != 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeLine">      uint64_t mask = WORDTYPE_MAX >> (APINT_BITS_PER_WORD - remainingBits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">412</td>
    <td class="codeLine">      uint64_t mask = WORDTYPE_MAX >> (APINT_BITS_PER_WORD - remainingBits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeLine">      U.pVal[hi1Word] &= ~mask;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">413</td>
    <td class="codeLine">      U.pVal[hi1Word] &= ~mask;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeLine">      U.pVal[hi1Word] |= subBits.getWord(subBitWidth - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">414</td>
    <td class="codeLine">      U.pVal[hi1Word] |= subBits.getWord(subBitWidth - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">415</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">416</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">417</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">418</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeLine">  // General case - set/clear individual bits in dst based on src.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">419</td>
    <td class="codeLine">  // General case - set/clear individual bits in dst based on src.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeLine">  // TODO - there is scope for optimization here, but at the moment this code</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">420</td>
    <td class="codeLine">  // TODO - there is scope for optimization here, but at the moment this code</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeLine">  // path is barely used so prefer readability over performance.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">421</td>
    <td class="codeLine">  // path is barely used so prefer readability over performance.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeLine">  for (unsigned i = 0; i != subBitWidth; ++i)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">422</td>
    <td class="codeLine">  for (unsigned i = 0; i != subBitWidth; ++i)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeLine">    setBitVal(bitPosition + i, subBits[i]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">423</td>
    <td class="codeLine">    setBitVal(bitPosition + i, subBits[i]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">424</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">425</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeLine">void APInt::insertBits(uint64_t subBits, unsigned bitPosition, unsigned numBits) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">426</td>
    <td class="codeLine">void APInt::insertBits(uint64_t subBits, unsigned bitPosition, unsigned numBits) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeLine">  uint64_t maskBits = maskTrailingOnes<uint64_t>(numBits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">427</td>
    <td class="codeLine">  uint64_t maskBits = maskTrailingOnes<uint64_t>(numBits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeLine">  subBits &= maskBits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">428</td>
    <td class="codeLine">  subBits &= maskBits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeLine">  if (isSingleWord()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">429</td>
    <td class="codeLine">  if (isSingleWord()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeLine">    U.VAL &= ~(maskBits << bitPosition);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">430</td>
    <td class="codeLine">    U.VAL &= ~(maskBits << bitPosition);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeLine">    U.VAL |= subBits << bitPosition;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">431</td>
    <td class="codeLine">    U.VAL |= subBits << bitPosition;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">432</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">433</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">434</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeLine">  unsigned loBit = whichBit(bitPosition);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">435</td>
    <td class="codeLine">  unsigned loBit = whichBit(bitPosition);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeLine">  unsigned loWord = whichWord(bitPosition);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">436</td>
    <td class="codeLine">  unsigned loWord = whichWord(bitPosition);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeLine">  unsigned hiWord = whichWord(bitPosition + numBits - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">437</td>
    <td class="codeLine">  unsigned hiWord = whichWord(bitPosition + numBits - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeLine">  if (loWord == hiWord) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">438</td>
    <td class="codeLine">  if (loWord == hiWord) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeLine">    U.pVal[loWord] &= ~(maskBits << loBit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">439</td>
    <td class="codeLine">    U.pVal[loWord] &= ~(maskBits << loBit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeLine">    U.pVal[loWord] |= subBits << loBit;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">440</td>
    <td class="codeLine">    U.pVal[loWord] |= subBits << loBit;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">441</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">442</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">443</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeLine">  static_assert(8 * sizeof(WordType) <= 64, "This code assumes only two words affected");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">444</td>
    <td class="codeLine">  static_assert(8 * sizeof(WordType) <= 64, "This code assumes only two words affected");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeLine">  unsigned wordBits = 8 * sizeof(WordType);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">445</td>
    <td class="codeLine">  unsigned wordBits = 8 * sizeof(WordType);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeLine">  U.pVal[loWord] &= ~(maskBits << loBit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">446</td>
    <td class="codeLine">  U.pVal[loWord] &= ~(maskBits << loBit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeLine">  U.pVal[loWord] |= subBits << loBit;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">447</td>
    <td class="codeLine">  U.pVal[loWord] |= subBits << loBit;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">448</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeLine">  U.pVal[hiWord] &= ~(maskBits >> (wordBits - loBit));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">449</td>
    <td class="codeLine">  U.pVal[hiWord] &= ~(maskBits >> (wordBits - loBit));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeLine">  U.pVal[hiWord] |= subBits >> (wordBits - loBit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">450</td>
    <td class="codeLine">  U.pVal[hiWord] |= subBits >> (wordBits - loBit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">451</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">452</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeLine">APInt APInt::extractBits(unsigned numBits, unsigned bitPosition) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">453</td>
    <td class="codeLine">APInt APInt::extractBits(unsigned numBits, unsigned bitPosition) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeLine">  assert(bitPosition < BitWidth && (numBits + bitPosition) <= BitWidth &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">454</td>
    <td class="codeLine">  assert(bitPosition < BitWidth && (numBits + bitPosition) <= BitWidth &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeLine">         "Illegal bit extraction");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">455</td>
    <td class="codeLine">         "Illegal bit extraction");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">456</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeLine">  if (isSingleWord())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">457</td>
    <td class="codeLine">  if (isSingleWord())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeLine">    return APInt(numBits, U.VAL >> bitPosition);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">458</td>
    <td class="codeLine">    return APInt(numBits, U.VAL >> bitPosition);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">459</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeLine">  unsigned loBit = whichBit(bitPosition);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">460</td>
    <td class="codeLine">  unsigned loBit = whichBit(bitPosition);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeLine">  unsigned loWord = whichWord(bitPosition);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">461</td>
    <td class="codeLine">  unsigned loWord = whichWord(bitPosition);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeLine">  unsigned hiWord = whichWord(bitPosition + numBits - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">462</td>
    <td class="codeLine">  unsigned hiWord = whichWord(bitPosition + numBits - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">463</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeLine">  // Single word result extracting bits from a single word source.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">464</td>
    <td class="codeLine">  // Single word result extracting bits from a single word source.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeLine">  if (loWord == hiWord)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">465</td>
    <td class="codeLine">  if (loWord == hiWord)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeLine">    return APInt(numBits, U.pVal[loWord] >> loBit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">466</td>
    <td class="codeLine">    return APInt(numBits, U.pVal[loWord] >> loBit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">467</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeLine">  // Extracting bits that start on a source word boundary can be done</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">468</td>
    <td class="codeLine">  // Extracting bits that start on a source word boundary can be done</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeLine">  // as a fast memory copy.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">469</td>
    <td class="codeLine">  // as a fast memory copy.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeLine">  if (loBit == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">470</td>
    <td class="codeLine">  if (loBit == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeLine">    return APInt(numBits, ArrayRef(U.pVal + loWord, 1 + hiWord - loWord));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">471</td>
    <td class="codeLine">    return APInt(numBits, ArrayRef(U.pVal + loWord, 1 + hiWord - loWord));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">472</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeLine">  // General case - shift + copy source words directly into place.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">473</td>
    <td class="codeLine">  // General case - shift + copy source words directly into place.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeLine">  APInt Result(numBits, 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">474</td>
    <td class="codeLine">  APInt Result(numBits, 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeLine">  unsigned NumSrcWords = getNumWords();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">475</td>
    <td class="codeLine">  unsigned NumSrcWords = getNumWords();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeLine">  unsigned NumDstWords = Result.getNumWords();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">476</td>
    <td class="codeLine">  unsigned NumDstWords = Result.getNumWords();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">477</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeLine">  uint64_t *DestPtr = Result.isSingleWord() ? &Result.U.VAL : Result.U.pVal;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">478</td>
    <td class="codeLine">  uint64_t *DestPtr = Result.isSingleWord() ? &Result.U.VAL : Result.U.pVal;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeLine">  for (unsigned word = 0; word < NumDstWords; ++word) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">479</td>
    <td class="codeLine">  for (unsigned word = 0; word < NumDstWords; ++word) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeLine">    uint64_t w0 = U.pVal[loWord + word];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">480</td>
    <td class="codeLine">    uint64_t w0 = U.pVal[loWord + word];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeLine">    uint64_t w1 =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">481</td>
    <td class="codeLine">    uint64_t w1 =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeLine">        (loWord + word + 1) < NumSrcWords ? U.pVal[loWord + word + 1] : 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">482</td>
    <td class="codeLine">        (loWord + word + 1) < NumSrcWords ? U.pVal[loWord + word + 1] : 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeLine">    DestPtr[word] = (w0 >> loBit) | (w1 << (APINT_BITS_PER_WORD - loBit));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">483</td>
    <td class="codeLine">    DestPtr[word] = (w0 >> loBit) | (w1 << (APINT_BITS_PER_WORD - loBit));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">484</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">485</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeLine">  return Result.clearUnusedBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">486</td>
    <td class="codeLine">  return Result.clearUnusedBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">487</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">488</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeLine">uint64_t APInt::extractBitsAsZExtValue(unsigned numBits,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">489</td>
    <td class="codeLine">uint64_t APInt::extractBitsAsZExtValue(unsigned numBits,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeLine">                                       unsigned bitPosition) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">490</td>
    <td class="codeLine">                                       unsigned bitPosition) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeLine">  assert(bitPosition < BitWidth && (numBits + bitPosition) <= BitWidth &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">491</td>
    <td class="codeLine">  assert(bitPosition < BitWidth && (numBits + bitPosition) <= BitWidth &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeLine">         "Illegal bit extraction");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">492</td>
    <td class="codeLine">         "Illegal bit extraction");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeLine">  assert(numBits <= 64 && "Illegal bit extraction");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">493</td>
    <td class="codeLine">  assert(numBits <= 64 && "Illegal bit extraction");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">494</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeLine">  uint64_t maskBits = maskTrailingOnes<uint64_t>(numBits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">495</td>
    <td class="codeLine">  uint64_t maskBits = maskTrailingOnes<uint64_t>(numBits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeLine">  if (isSingleWord())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">496</td>
    <td class="codeLine">  if (isSingleWord())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeLine">    return (U.VAL >> bitPosition) & maskBits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">497</td>
    <td class="codeLine">    return (U.VAL >> bitPosition) & maskBits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">498</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeLine">  unsigned loBit = whichBit(bitPosition);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">499</td>
    <td class="codeLine">  unsigned loBit = whichBit(bitPosition);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeLine">  unsigned loWord = whichWord(bitPosition);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">500</td>
    <td class="codeLine">  unsigned loWord = whichWord(bitPosition);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeLine">  unsigned hiWord = whichWord(bitPosition + numBits - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">501</td>
    <td class="codeLine">  unsigned hiWord = whichWord(bitPosition + numBits - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeLine">  if (loWord == hiWord)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">502</td>
    <td class="codeLine">  if (loWord == hiWord)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeLine">    return (U.pVal[loWord] >> loBit) & maskBits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">503</td>
    <td class="codeLine">    return (U.pVal[loWord] >> loBit) & maskBits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">504</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeLine">  static_assert(8 * sizeof(WordType) <= 64, "This code assumes only two words affected");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">505</td>
    <td class="codeLine">  static_assert(8 * sizeof(WordType) <= 64, "This code assumes only two words affected");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeLine">  unsigned wordBits = 8 * sizeof(WordType);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">506</td>
    <td class="codeLine">  unsigned wordBits = 8 * sizeof(WordType);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeLine">  uint64_t retBits = U.pVal[loWord] >> loBit;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">507</td>
    <td class="codeLine">  uint64_t retBits = U.pVal[loWord] >> loBit;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeLine">  retBits |= U.pVal[hiWord] << (wordBits - loBit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">508</td>
    <td class="codeLine">  retBits |= U.pVal[hiWord] << (wordBits - loBit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeLine">  retBits &= maskBits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">509</td>
    <td class="codeLine">  retBits &= maskBits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeLine">  return retBits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">510</td>
    <td class="codeLine">  return retBits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">511</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">512</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeLine">unsigned APInt::getSufficientBitsNeeded(StringRef Str, uint8_t Radix) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">513</td>
    <td class="codeLine">unsigned APInt::getSufficientBitsNeeded(StringRef Str, uint8_t Radix) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeLine">  assert(!Str.empty() && "Invalid string length");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">514</td>
    <td class="codeLine">  assert(!Str.empty() && "Invalid string length");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeLine">  size_t StrLen = Str.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">515</td>
    <td class="codeLine">  size_t StrLen = Str.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">516</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeLine">  // Each computation below needs to know if it's negative.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">517</td>
    <td class="codeLine">  // Each computation below needs to know if it's negative.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeLine">  unsigned IsNegative = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">518</td>
    <td class="codeLine">  unsigned IsNegative = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeLine">  if (Str[0] == '-' || Str[0] == '+') {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">519</td>
    <td class="codeLine">  if (Str[0] == '-' || Str[0] == '+') {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeLine">    IsNegative = Str[0] == '-';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">520</td>
    <td class="codeLine">    IsNegative = Str[0] == '-';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeLine">    StrLen--;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">521</td>
    <td class="codeLine">    StrLen--;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeLine">    assert(StrLen && "String is only a sign, needs a value.");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">522</td>
    <td class="codeLine">    assert(StrLen && "String is only a sign, needs a value.");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">523</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">524</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeLine">  // For radixes of power-of-two values, the bits required is accurately and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">525</td>
    <td class="codeLine">  // For radixes of power-of-two values, the bits required is accurately and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeLine">  // easily computed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">526</td>
    <td class="codeLine">  // easily computed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeLine">  if (Radix == 2)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">527</td>
    <td class="codeLine">  if (Radix == 2)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeLine">    return StrLen + IsNegative;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">528</td>
    <td class="codeLine">    return StrLen + IsNegative;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeLine">  if (Radix == 8)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">529</td>
    <td class="codeLine">  if (Radix == 8)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeLine">    return StrLen * 3 + IsNegative;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">530</td>
    <td class="codeLine">    return StrLen * 3 + IsNegative;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeLine">  if (Radix == 16)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">531</td>
    <td class="codeLine">  if (Radix == 16)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeLine">    return StrLen * 4 + IsNegative;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">532</td>
    <td class="codeLine">    return StrLen * 4 + IsNegative;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">533</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeLine">  // Compute a sufficient number of bits that is always large enough but might</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">534</td>
    <td class="codeLine">  // Compute a sufficient number of bits that is always large enough but might</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeLine">  // be too large. This avoids the assertion in the constructor. This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">535</td>
    <td class="codeLine">  // be too large. This avoids the assertion in the constructor. This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeLine">  // calculation doesn't work appropriately for the numbers 0-9, so just use 4</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">536</td>
    <td class="codeLine">  // calculation doesn't work appropriately for the numbers 0-9, so just use 4</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeLine">  // bits in that case.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">537</td>
    <td class="codeLine">  // bits in that case.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeLine">  if (Radix == 10)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">538</td>
    <td class="codeLine">  if (Radix == 10)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeLine">    return (StrLen == 1 ? 4 : StrLen * 64 / 18) + IsNegative;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">539</td>
    <td class="codeLine">    return (StrLen == 1 ? 4 : StrLen * 64 / 18) + IsNegative;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">540</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeLine">  assert(Radix == 36);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">541</td>
    <td class="codeLine">  assert(Radix == 36);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeLine">  return (StrLen == 1 ? 7 : StrLen * 16 / 3) + IsNegative;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">542</td>
    <td class="codeLine">  return (StrLen == 1 ? 7 : StrLen * 16 / 3) + IsNegative;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">543</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">544</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeLine">unsigned APInt::getBitsNeeded(StringRef str, uint8_t radix) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">545</td>
    <td class="codeLine">unsigned APInt::getBitsNeeded(StringRef str, uint8_t radix) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeLine">  // Compute a sufficient number of bits that is always large enough but might</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">546</td>
    <td class="codeLine">  // Compute a sufficient number of bits that is always large enough but might</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeLine">  // be too large.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">547</td>
    <td class="codeLine">  // be too large.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeLine">  unsigned sufficient = getSufficientBitsNeeded(str, radix);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">548</td>
    <td class="codeLine">  unsigned sufficient = getSufficientBitsNeeded(str, radix);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">549</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeLine">  // For bases 2, 8, and 16, the sufficient number of bits is exact and we can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">550</td>
    <td class="codeLine">  // For bases 2, 8, and 16, the sufficient number of bits is exact and we can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeLine">  // return the value directly. For bases 10 and 36, we need to do extra work.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">551</td>
    <td class="codeLine">  // return the value directly. For bases 10 and 36, we need to do extra work.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeLine">  if (radix == 2 || radix == 8 || radix == 16)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">552</td>
    <td class="codeLine">  if (radix == 2 || radix == 8 || radix == 16)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeLine">    return sufficient;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">553</td>
    <td class="codeLine">    return sufficient;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">554</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeLine">  // This is grossly inefficient but accurate. We could probably do something</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">555</td>
    <td class="codeLine">  // This is grossly inefficient but accurate. We could probably do something</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeLine">  // with a computation of roughly slen*64/20 and then adjust by the value of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">556</td>
    <td class="codeLine">  // with a computation of roughly slen*64/20 and then adjust by the value of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeLine">  // the first few digits. But, I'm not sure how accurate that could be.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">557</td>
    <td class="codeLine">  // the first few digits. But, I'm not sure how accurate that could be.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeLine">  size_t slen = str.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">558</td>
    <td class="codeLine">  size_t slen = str.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">559</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeLine">  // Each computation below needs to know if it's negative.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">560</td>
    <td class="codeLine">  // Each computation below needs to know if it's negative.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeLine">  StringRef::iterator p = str.begin();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">561</td>
    <td class="codeLine">  StringRef::iterator p = str.begin();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeLine">  unsigned isNegative = *p == '-';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">562</td>
    <td class="codeLine">  unsigned isNegative = *p == '-';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeLine">  if (*p == '-' || *p == '+') {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">563</td>
    <td class="codeLine">  if (*p == '-' || *p == '+') {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeLine">    p++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">564</td>
    <td class="codeLine">    p++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeLine">    slen--;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">565</td>
    <td class="codeLine">    slen--;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeLine">    assert(slen && "String is only a sign, needs a value.");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">566</td>
    <td class="codeLine">    assert(slen && "String is only a sign, needs a value.");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">567</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">568</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">569</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeLine">  // Convert to the actual binary value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">570</td>
    <td class="codeLine">  // Convert to the actual binary value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeLine">  APInt tmp(sufficient, StringRef(p, slen), radix);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">571</td>
    <td class="codeLine">  APInt tmp(sufficient, StringRef(p, slen), radix);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">572</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeLine">  // Compute how many bits are required. If the log is infinite, assume we need</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">573</td>
    <td class="codeLine">  // Compute how many bits are required. If the log is infinite, assume we need</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeLine">  // just bit. If the log is exact and value is negative, then the value is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">574</td>
    <td class="codeLine">  // just bit. If the log is exact and value is negative, then the value is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeLine">  // MinSignedValue with (log + 1) bits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">575</td>
    <td class="codeLine">  // MinSignedValue with (log + 1) bits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeLine">  unsigned log = tmp.logBase2();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">576</td>
    <td class="codeLine">  unsigned log = tmp.logBase2();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeLine">  if (log == (unsigned)-1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">577</td>
    <td class="codeLine">  if (log == (unsigned)-1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeLine">    return isNegative + 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">578</td>
    <td class="codeLine">    return isNegative + 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeLine">  } else if (isNegative && tmp.isPowerOf2()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">579</td>
    <td class="codeLine">  } else if (isNegative && tmp.isPowerOf2()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeLine">    return isNegative + log;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">580</td>
    <td class="codeLine">    return isNegative + log;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">581</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeLine">    return isNegative + log + 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">582</td>
    <td class="codeLine">    return isNegative + log + 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">583</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">584</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">585</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeLine coveredLine">hash_code llvm::hash_value(const APInt &Arg) {</td>
    <td class="lineNumber">7</td>
    <td class="lineNumber">586</td>
    <td class="codeLine coveredLine">hash_code llvm::hash_value(const APInt &Arg) {</td>
    <td class="lineNumber">3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeLine coveredLine">  if (Arg.isSingleWord())</td>
    <td class="lineNumber">7</td>
    <td class="lineNumber">587</td>
    <td class="codeLine coveredLine">  if (Arg.isSingleWord())</td>
    <td class="lineNumber">3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeLine coveredLine">    return hash_combine(Arg.BitWidth, Arg.U.VAL);</td>
    <td class="lineNumber">7</td>
    <td class="lineNumber">588</td>
    <td class="codeLine coveredLine">    return hash_combine(Arg.BitWidth, Arg.U.VAL);</td>
    <td class="lineNumber">3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">589</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeLine">  return hash_combine(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">590</td>
    <td class="codeLine">  return hash_combine(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeLine">      Arg.BitWidth,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">591</td>
    <td class="codeLine">      Arg.BitWidth,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeLine">      hash_combine_range(Arg.U.pVal, Arg.U.pVal + Arg.getNumWords()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">592</td>
    <td class="codeLine">      hash_combine_range(Arg.U.pVal, Arg.U.pVal + Arg.getNumWords()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">593</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">594</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeLine coveredLine">unsigned DenseMapInfo<APInt, void>::getHashValue(const APInt &Key) {</td>
    <td class="lineNumber">7</td>
    <td class="lineNumber">595</td>
    <td class="codeLine coveredLine">unsigned DenseMapInfo<APInt, void>::getHashValue(const APInt &Key) {</td>
    <td class="lineNumber">3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeLine coveredLine">  return static_cast<unsigned>(hash_value(Key));</td>
    <td class="lineNumber">7</td>
    <td class="lineNumber">596</td>
    <td class="codeLine coveredLine">  return static_cast<unsigned>(hash_value(Key));</td>
    <td class="lineNumber">3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">597</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">598</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeLine">bool APInt::isSplat(unsigned SplatSizeInBits) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">599</td>
    <td class="codeLine">bool APInt::isSplat(unsigned SplatSizeInBits) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeLine">  assert(getBitWidth() % SplatSizeInBits == 0 &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">600</td>
    <td class="codeLine">  assert(getBitWidth() % SplatSizeInBits == 0 &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeLine">         "SplatSizeInBits must divide width!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">601</td>
    <td class="codeLine">         "SplatSizeInBits must divide width!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeLine">  // We can check that all parts of an integer are equal by making use of a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">602</td>
    <td class="codeLine">  // We can check that all parts of an integer are equal by making use of a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeLine">  // little trick: rotate and check if it's still the same value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">603</td>
    <td class="codeLine">  // little trick: rotate and check if it's still the same value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeLine">  return *this == rotl(SplatSizeInBits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">604</td>
    <td class="codeLine">  return *this == rotl(SplatSizeInBits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">605</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">606</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeLine">/// This function returns the high "numBits" bits of this APInt.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">607</td>
    <td class="codeLine">/// This function returns the high "numBits" bits of this APInt.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeLine">APInt APInt::getHiBits(unsigned numBits) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">608</td>
    <td class="codeLine">APInt APInt::getHiBits(unsigned numBits) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeLine">  return this->lshr(BitWidth - numBits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">609</td>
    <td class="codeLine">  return this->lshr(BitWidth - numBits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">610</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">611</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeLine">/// This function returns the low "numBits" bits of this APInt.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">612</td>
    <td class="codeLine">/// This function returns the low "numBits" bits of this APInt.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeLine">APInt APInt::getLoBits(unsigned numBits) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">613</td>
    <td class="codeLine">APInt APInt::getLoBits(unsigned numBits) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeLine">  APInt Result(getLowBitsSet(BitWidth, numBits));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">614</td>
    <td class="codeLine">  APInt Result(getLowBitsSet(BitWidth, numBits));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeLine">  Result &= *this;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">615</td>
    <td class="codeLine">  Result &= *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeLine">  return Result;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">616</td>
    <td class="codeLine">  return Result;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">617</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">618</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeLine">/// Return a value containing V broadcasted over NewLen bits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">619</td>
    <td class="codeLine">/// Return a value containing V broadcasted over NewLen bits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeLine">APInt APInt::getSplat(unsigned NewLen, const APInt &V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">620</td>
    <td class="codeLine">APInt APInt::getSplat(unsigned NewLen, const APInt &V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeLine">  assert(NewLen >= V.getBitWidth() && "Can't splat to smaller bit width!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">621</td>
    <td class="codeLine">  assert(NewLen >= V.getBitWidth() && "Can't splat to smaller bit width!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">622</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeLine">  APInt Val = V.zext(NewLen);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">623</td>
    <td class="codeLine">  APInt Val = V.zext(NewLen);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeLine">  for (unsigned I = V.getBitWidth(); I < NewLen; I <<= 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">624</td>
    <td class="codeLine">  for (unsigned I = V.getBitWidth(); I < NewLen; I <<= 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeLine">    Val |= Val << I;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">625</td>
    <td class="codeLine">    Val |= Val << I;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">626</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeLine">  return Val;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">627</td>
    <td class="codeLine">  return Val;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">628</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">629</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeLine">unsigned APInt::countLeadingZerosSlowCase() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">630</td>
    <td class="codeLine">unsigned APInt::countLeadingZerosSlowCase() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeLine">  unsigned Count = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">631</td>
    <td class="codeLine">  unsigned Count = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeLine">  for (int i = getNumWords()-1; i >= 0; --i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">632</td>
    <td class="codeLine">  for (int i = getNumWords()-1; i >= 0; --i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeLine">    uint64_t V = U.pVal[i];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">633</td>
    <td class="codeLine">    uint64_t V = U.pVal[i];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeLine">    if (V == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">634</td>
    <td class="codeLine">    if (V == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeLine">      Count += APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">635</td>
    <td class="codeLine">      Count += APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeLine">    else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">636</td>
    <td class="codeLine">    else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeLine">      Count += llvm::countl_zero(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">637</td>
    <td class="codeLine">      Count += llvm::countl_zero(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">638</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">639</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">640</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeLine">  // Adjust for unused bits in the most significant word (they are zero).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">641</td>
    <td class="codeLine">  // Adjust for unused bits in the most significant word (they are zero).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeLine">  unsigned Mod = BitWidth % APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">642</td>
    <td class="codeLine">  unsigned Mod = BitWidth % APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeLine">  Count -= Mod > 0 ? APINT_BITS_PER_WORD - Mod : 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">643</td>
    <td class="codeLine">  Count -= Mod > 0 ? APINT_BITS_PER_WORD - Mod : 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeLine">  return Count;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">644</td>
    <td class="codeLine">  return Count;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">645</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">646</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeLine">unsigned APInt::countLeadingOnesSlowCase() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">647</td>
    <td class="codeLine">unsigned APInt::countLeadingOnesSlowCase() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeLine">  unsigned highWordBits = BitWidth % APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">648</td>
    <td class="codeLine">  unsigned highWordBits = BitWidth % APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeLine">  unsigned shift;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">649</td>
    <td class="codeLine">  unsigned shift;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeLine">  if (!highWordBits) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">650</td>
    <td class="codeLine">  if (!highWordBits) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeLine">    highWordBits = APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">651</td>
    <td class="codeLine">    highWordBits = APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeLine">    shift = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">652</td>
    <td class="codeLine">    shift = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">653</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeLine">    shift = APINT_BITS_PER_WORD - highWordBits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">654</td>
    <td class="codeLine">    shift = APINT_BITS_PER_WORD - highWordBits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">655</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeLine">  int i = getNumWords() - 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">656</td>
    <td class="codeLine">  int i = getNumWords() - 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeLine">  unsigned Count = llvm::countl_one(U.pVal[i] << shift);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">657</td>
    <td class="codeLine">  unsigned Count = llvm::countl_one(U.pVal[i] << shift);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeLine">  if (Count == highWordBits) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">658</td>
    <td class="codeLine">  if (Count == highWordBits) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeLine">    for (i--; i >= 0; --i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">659</td>
    <td class="codeLine">    for (i--; i >= 0; --i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeLine">      if (U.pVal[i] == WORDTYPE_MAX)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">660</td>
    <td class="codeLine">      if (U.pVal[i] == WORDTYPE_MAX)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeLine">        Count += APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">661</td>
    <td class="codeLine">        Count += APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeLine">      else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">662</td>
    <td class="codeLine">      else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeLine">        Count += llvm::countl_one(U.pVal[i]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">663</td>
    <td class="codeLine">        Count += llvm::countl_one(U.pVal[i]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">664</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">665</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">666</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">667</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeLine">  return Count;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">668</td>
    <td class="codeLine">  return Count;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">669</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">670</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeLine">unsigned APInt::countTrailingZerosSlowCase() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">671</td>
    <td class="codeLine">unsigned APInt::countTrailingZerosSlowCase() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeLine">  unsigned Count = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">672</td>
    <td class="codeLine">  unsigned Count = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeLine">  unsigned i = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">673</td>
    <td class="codeLine">  unsigned i = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeLine">  for (; i < getNumWords() && U.pVal[i] == 0; ++i)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">674</td>
    <td class="codeLine">  for (; i < getNumWords() && U.pVal[i] == 0; ++i)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeLine">    Count += APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">675</td>
    <td class="codeLine">    Count += APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeLine">  if (i < getNumWords())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">676</td>
    <td class="codeLine">  if (i < getNumWords())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeLine">    Count += llvm::countr_zero(U.pVal[i]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">677</td>
    <td class="codeLine">    Count += llvm::countr_zero(U.pVal[i]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeLine">  return std::min(Count, BitWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">678</td>
    <td class="codeLine">  return std::min(Count, BitWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">679</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">680</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeLine">unsigned APInt::countTrailingOnesSlowCase() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">681</td>
    <td class="codeLine">unsigned APInt::countTrailingOnesSlowCase() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeLine">  unsigned Count = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">682</td>
    <td class="codeLine">  unsigned Count = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeLine">  unsigned i = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">683</td>
    <td class="codeLine">  unsigned i = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeLine">  for (; i < getNumWords() && U.pVal[i] == WORDTYPE_MAX; ++i)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">684</td>
    <td class="codeLine">  for (; i < getNumWords() && U.pVal[i] == WORDTYPE_MAX; ++i)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeLine">    Count += APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">685</td>
    <td class="codeLine">    Count += APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeLine">  if (i < getNumWords())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">686</td>
    <td class="codeLine">  if (i < getNumWords())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeLine">    Count += llvm::countr_one(U.pVal[i]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">687</td>
    <td class="codeLine">    Count += llvm::countr_one(U.pVal[i]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeLine">  assert(Count <= BitWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">688</td>
    <td class="codeLine">  assert(Count <= BitWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeLine">  return Count;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">689</td>
    <td class="codeLine">  return Count;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">690</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">691</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeLine">unsigned APInt::countPopulationSlowCase() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">692</td>
    <td class="codeLine">unsigned APInt::countPopulationSlowCase() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeLine">  unsigned Count = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">693</td>
    <td class="codeLine">  unsigned Count = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeLine">  for (unsigned i = 0; i < getNumWords(); ++i)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">694</td>
    <td class="codeLine">  for (unsigned i = 0; i < getNumWords(); ++i)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeLine">    Count += llvm::popcount(U.pVal[i]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">695</td>
    <td class="codeLine">    Count += llvm::popcount(U.pVal[i]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeLine">  return Count;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">696</td>
    <td class="codeLine">  return Count;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">697</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">698</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeLine">bool APInt::intersectsSlowCase(const APInt &RHS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">699</td>
    <td class="codeLine">bool APInt::intersectsSlowCase(const APInt &RHS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeLine">  for (unsigned i = 0, e = getNumWords(); i != e; ++i)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">700</td>
    <td class="codeLine">  for (unsigned i = 0, e = getNumWords(); i != e; ++i)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeLine">    if ((U.pVal[i] & RHS.U.pVal[i]) != 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">701</td>
    <td class="codeLine">    if ((U.pVal[i] & RHS.U.pVal[i]) != 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">702</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">703</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">704</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">705</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">706</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeLine">bool APInt::isSubsetOfSlowCase(const APInt &RHS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">707</td>
    <td class="codeLine">bool APInt::isSubsetOfSlowCase(const APInt &RHS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeLine">  for (unsigned i = 0, e = getNumWords(); i != e; ++i)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">708</td>
    <td class="codeLine">  for (unsigned i = 0, e = getNumWords(); i != e; ++i)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeLine">    if ((U.pVal[i] & ~RHS.U.pVal[i]) != 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">709</td>
    <td class="codeLine">    if ((U.pVal[i] & ~RHS.U.pVal[i]) != 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">710</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">711</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">712</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">713</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">714</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeLine">APInt APInt::byteSwap() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">715</td>
    <td class="codeLine">APInt APInt::byteSwap() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeLine">  assert(BitWidth >= 16 && BitWidth % 8 == 0 && "Cannot byteswap!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">716</td>
    <td class="codeLine">  assert(BitWidth >= 16 && BitWidth % 8 == 0 && "Cannot byteswap!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeLine">  if (BitWidth == 16)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">717</td>
    <td class="codeLine">  if (BitWidth == 16)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeLine">    return APInt(BitWidth, llvm::byteswap<uint16_t>(U.VAL));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">718</td>
    <td class="codeLine">    return APInt(BitWidth, llvm::byteswap<uint16_t>(U.VAL));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeLine">  if (BitWidth == 32)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">719</td>
    <td class="codeLine">  if (BitWidth == 32)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeLine">    return APInt(BitWidth, llvm::byteswap<uint32_t>(U.VAL));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">720</td>
    <td class="codeLine">    return APInt(BitWidth, llvm::byteswap<uint32_t>(U.VAL));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeLine">  if (BitWidth <= 64) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">721</td>
    <td class="codeLine">  if (BitWidth <= 64) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeLine">    uint64_t Tmp1 = llvm::byteswap<uint64_t>(U.VAL);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">722</td>
    <td class="codeLine">    uint64_t Tmp1 = llvm::byteswap<uint64_t>(U.VAL);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeLine">    Tmp1 >>= (64 - BitWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">723</td>
    <td class="codeLine">    Tmp1 >>= (64 - BitWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeLine">    return APInt(BitWidth, Tmp1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">724</td>
    <td class="codeLine">    return APInt(BitWidth, Tmp1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">725</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">726</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeLine">  APInt Result(getNumWords() * APINT_BITS_PER_WORD, 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">727</td>
    <td class="codeLine">  APInt Result(getNumWords() * APINT_BITS_PER_WORD, 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeLine">  for (unsigned I = 0, N = getNumWords(); I != N; ++I)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">728</td>
    <td class="codeLine">  for (unsigned I = 0, N = getNumWords(); I != N; ++I)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeLine">    Result.U.pVal[I] = llvm::byteswap<uint64_t>(U.pVal[N - I - 1]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">729</td>
    <td class="codeLine">    Result.U.pVal[I] = llvm::byteswap<uint64_t>(U.pVal[N - I - 1]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeLine">  if (Result.BitWidth != BitWidth) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">730</td>
    <td class="codeLine">  if (Result.BitWidth != BitWidth) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeLine">    Result.lshrInPlace(Result.BitWidth - BitWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">731</td>
    <td class="codeLine">    Result.lshrInPlace(Result.BitWidth - BitWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeLine">    Result.BitWidth = BitWidth;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">732</td>
    <td class="codeLine">    Result.BitWidth = BitWidth;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">733</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeLine">  return Result;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">734</td>
    <td class="codeLine">  return Result;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">735</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">736</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeLine">APInt APInt::reverseBits() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">737</td>
    <td class="codeLine">APInt APInt::reverseBits() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeLine">  switch (BitWidth) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">738</td>
    <td class="codeLine">  switch (BitWidth) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeLine">  case 64:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">739</td>
    <td class="codeLine">  case 64:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeLine">    return APInt(BitWidth, llvm::reverseBits<uint64_t>(U.VAL));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">740</td>
    <td class="codeLine">    return APInt(BitWidth, llvm::reverseBits<uint64_t>(U.VAL));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeLine">  case 32:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">741</td>
    <td class="codeLine">  case 32:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeLine">    return APInt(BitWidth, llvm::reverseBits<uint32_t>(U.VAL));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">742</td>
    <td class="codeLine">    return APInt(BitWidth, llvm::reverseBits<uint32_t>(U.VAL));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeLine">  case 16:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">743</td>
    <td class="codeLine">  case 16:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeLine">    return APInt(BitWidth, llvm::reverseBits<uint16_t>(U.VAL));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">744</td>
    <td class="codeLine">    return APInt(BitWidth, llvm::reverseBits<uint16_t>(U.VAL));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeLine">  case 8:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">745</td>
    <td class="codeLine">  case 8:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeLine">    return APInt(BitWidth, llvm::reverseBits<uint8_t>(U.VAL));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">746</td>
    <td class="codeLine">    return APInt(BitWidth, llvm::reverseBits<uint8_t>(U.VAL));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeLine">  case 0:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">747</td>
    <td class="codeLine">  case 0:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeLine">    return *this;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">748</td>
    <td class="codeLine">    return *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">749</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">750</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">751</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">752</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeLine">  APInt Val(*this);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">753</td>
    <td class="codeLine">  APInt Val(*this);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeLine">  APInt Reversed(BitWidth, 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">754</td>
    <td class="codeLine">  APInt Reversed(BitWidth, 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeLine">  unsigned S = BitWidth;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">755</td>
    <td class="codeLine">  unsigned S = BitWidth;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">756</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeLine">  for (; Val != 0; Val.lshrInPlace(1)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">757</td>
    <td class="codeLine">  for (; Val != 0; Val.lshrInPlace(1)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeLine">    Reversed <<= 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">758</td>
    <td class="codeLine">    Reversed <<= 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeLine">    Reversed |= Val[0];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">759</td>
    <td class="codeLine">    Reversed |= Val[0];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeLine">    --S;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">760</td>
    <td class="codeLine">    --S;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">761</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">762</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeLine">  Reversed <<= S;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">763</td>
    <td class="codeLine">  Reversed <<= S;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeLine">  return Reversed;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">764</td>
    <td class="codeLine">  return Reversed;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">765</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">766</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeLine">APInt llvm::APIntOps::GreatestCommonDivisor(APInt A, APInt B) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">767</td>
    <td class="codeLine">APInt llvm::APIntOps::GreatestCommonDivisor(APInt A, APInt B) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeLine">  // Fast-path a common case.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">768</td>
    <td class="codeLine">  // Fast-path a common case.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeLine">  if (A == B) return A;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">769</td>
    <td class="codeLine">  if (A == B) return A;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">770</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeLine">  // Corner cases: if either operand is zero, the other is the gcd.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">771</td>
    <td class="codeLine">  // Corner cases: if either operand is zero, the other is the gcd.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeLine">  if (!A) return B;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">772</td>
    <td class="codeLine">  if (!A) return B;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeLine">  if (!B) return A;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">773</td>
    <td class="codeLine">  if (!B) return A;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">774</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeLine">  // Count common powers of 2 and remove all other powers of 2.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">775</td>
    <td class="codeLine">  // Count common powers of 2 and remove all other powers of 2.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeLine">  unsigned Pow2;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">776</td>
    <td class="codeLine">  unsigned Pow2;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeLine">  {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">777</td>
    <td class="codeLine">  {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeLine">    unsigned Pow2_A = A.countr_zero();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">778</td>
    <td class="codeLine">    unsigned Pow2_A = A.countr_zero();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeLine">    unsigned Pow2_B = B.countr_zero();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">779</td>
    <td class="codeLine">    unsigned Pow2_B = B.countr_zero();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeLine">    if (Pow2_A > Pow2_B) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">780</td>
    <td class="codeLine">    if (Pow2_A > Pow2_B) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeLine">      A.lshrInPlace(Pow2_A - Pow2_B);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">781</td>
    <td class="codeLine">      A.lshrInPlace(Pow2_A - Pow2_B);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeLine">      Pow2 = Pow2_B;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">782</td>
    <td class="codeLine">      Pow2 = Pow2_B;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeLine">    } else if (Pow2_B > Pow2_A) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">783</td>
    <td class="codeLine">    } else if (Pow2_B > Pow2_A) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeLine">      B.lshrInPlace(Pow2_B - Pow2_A);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">784</td>
    <td class="codeLine">      B.lshrInPlace(Pow2_B - Pow2_A);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeLine">      Pow2 = Pow2_A;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">785</td>
    <td class="codeLine">      Pow2 = Pow2_A;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">786</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeLine">      Pow2 = Pow2_A;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">787</td>
    <td class="codeLine">      Pow2 = Pow2_A;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">788</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">789</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">790</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeLine">  // Both operands are odd multiples of 2^Pow_2:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">791</td>
    <td class="codeLine">  // Both operands are odd multiples of 2^Pow_2:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">792</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeLine">  //   gcd(a, b) = gcd(|a - b| / 2^i, min(a, b))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">793</td>
    <td class="codeLine">  //   gcd(a, b) = gcd(|a - b| / 2^i, min(a, b))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">794</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeLine">  // This is a modified version of Stein's algorithm, taking advantage of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">795</td>
    <td class="codeLine">  // This is a modified version of Stein's algorithm, taking advantage of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeLine">  // efficient countTrailingZeros().</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">796</td>
    <td class="codeLine">  // efficient countTrailingZeros().</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeLine">  while (A != B) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">797</td>
    <td class="codeLine">  while (A != B) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeLine">    if (A.ugt(B)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">798</td>
    <td class="codeLine">    if (A.ugt(B)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeLine">      A -= B;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">799</td>
    <td class="codeLine">      A -= B;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeLine">      A.lshrInPlace(A.countr_zero() - Pow2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">800</td>
    <td class="codeLine">      A.lshrInPlace(A.countr_zero() - Pow2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">801</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeLine">      B -= A;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">802</td>
    <td class="codeLine">      B -= A;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeLine">      B.lshrInPlace(B.countr_zero() - Pow2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">803</td>
    <td class="codeLine">      B.lshrInPlace(B.countr_zero() - Pow2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">804</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">805</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">806</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeLine">  return A;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">807</td>
    <td class="codeLine">  return A;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">808</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">809</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeLine">APInt llvm::APIntOps::RoundDoubleToAPInt(double Double, unsigned width) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">810</td>
    <td class="codeLine">APInt llvm::APIntOps::RoundDoubleToAPInt(double Double, unsigned width) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeLine">  uint64_t I = bit_cast<uint64_t>(Double);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">811</td>
    <td class="codeLine">  uint64_t I = bit_cast<uint64_t>(Double);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">812</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeLine">  // Get the sign bit from the highest order bit</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">813</td>
    <td class="codeLine">  // Get the sign bit from the highest order bit</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeLine">  bool isNeg = I >> 63;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">814</td>
    <td class="codeLine">  bool isNeg = I >> 63;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">815</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeLine">  // Get the 11-bit exponent and adjust for the 1023 bit bias</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">816</td>
    <td class="codeLine">  // Get the 11-bit exponent and adjust for the 1023 bit bias</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeLine">  int64_t exp = ((I >> 52) & 0x7ff) - 1023;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">817</td>
    <td class="codeLine">  int64_t exp = ((I >> 52) & 0x7ff) - 1023;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">818</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeLine">  // If the exponent is negative, the value is < 0 so just return 0.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">819</td>
    <td class="codeLine">  // If the exponent is negative, the value is < 0 so just return 0.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeLine">  if (exp < 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">820</td>
    <td class="codeLine">  if (exp < 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeLine">    return APInt(width, 0u);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">821</td>
    <td class="codeLine">    return APInt(width, 0u);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">822</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeLine">  // Extract the mantissa by clearing the top 12 bits (sign + exponent).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">823</td>
    <td class="codeLine">  // Extract the mantissa by clearing the top 12 bits (sign + exponent).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeLine">  uint64_t mantissa = (I & (~0ULL >> 12)) | 1ULL << 52;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">824</td>
    <td class="codeLine">  uint64_t mantissa = (I & (~0ULL >> 12)) | 1ULL << 52;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">825</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeLine">  // If the exponent doesn't shift all bits out of the mantissa</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">826</td>
    <td class="codeLine">  // If the exponent doesn't shift all bits out of the mantissa</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeLine">  if (exp < 52)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">827</td>
    <td class="codeLine">  if (exp < 52)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeLine">    return isNeg ? -APInt(width, mantissa >> (52 - exp)) :</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">828</td>
    <td class="codeLine">    return isNeg ? -APInt(width, mantissa >> (52 - exp)) :</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeLine">                    APInt(width, mantissa >> (52 - exp));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">829</td>
    <td class="codeLine">                    APInt(width, mantissa >> (52 - exp));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">830</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeLine">  // If the client didn't provide enough bits for us to shift the mantissa into</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">831</td>
    <td class="codeLine">  // If the client didn't provide enough bits for us to shift the mantissa into</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeLine">  // then the result is undefined, just return 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">832</td>
    <td class="codeLine">  // then the result is undefined, just return 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeLine">  if (width <= exp - 52)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">833</td>
    <td class="codeLine">  if (width <= exp - 52)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeLine">    return APInt(width, 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">834</td>
    <td class="codeLine">    return APInt(width, 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">835</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeLine">  // Otherwise, we have to shift the mantissa bits up to the right location</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">836</td>
    <td class="codeLine">  // Otherwise, we have to shift the mantissa bits up to the right location</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeLine">  APInt Tmp(width, mantissa);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">837</td>
    <td class="codeLine">  APInt Tmp(width, mantissa);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeLine">  Tmp <<= (unsigned)exp - 52;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">838</td>
    <td class="codeLine">  Tmp <<= (unsigned)exp - 52;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeLine">  return isNeg ? -Tmp : Tmp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">839</td>
    <td class="codeLine">  return isNeg ? -Tmp : Tmp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">840</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">841</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeLine">/// This function converts this APInt to a double.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">842</td>
    <td class="codeLine">/// This function converts this APInt to a double.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeLine">/// The layout for double is as following (IEEE Standard 754):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">843</td>
    <td class="codeLine">/// The layout for double is as following (IEEE Standard 754):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeLine">///  --------------------------------------</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">844</td>
    <td class="codeLine">///  --------------------------------------</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeLine">/// |  Sign    Exponent    Fraction    Bias |</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">845</td>
    <td class="codeLine">/// |  Sign    Exponent    Fraction    Bias |</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeLine">/// |-------------------------------------- |</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">846</td>
    <td class="codeLine">/// |-------------------------------------- |</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeLine">/// |  1[63]   11[62-52]   52[51-00]   1023 |</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">847</td>
    <td class="codeLine">/// |  1[63]   11[62-52]   52[51-00]   1023 |</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeLine">///  --------------------------------------</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">848</td>
    <td class="codeLine">///  --------------------------------------</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeLine">double APInt::roundToDouble(bool isSigned) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">849</td>
    <td class="codeLine">double APInt::roundToDouble(bool isSigned) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">850</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeLine">  // Handle the simple case where the value is contained in one uint64_t.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">851</td>
    <td class="codeLine">  // Handle the simple case where the value is contained in one uint64_t.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeLine">  // It is wrong to optimize getWord(0) to VAL; there might be more than one word.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">852</td>
    <td class="codeLine">  // It is wrong to optimize getWord(0) to VAL; there might be more than one word.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeLine">  if (isSingleWord() || getActiveBits() <= APINT_BITS_PER_WORD) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">853</td>
    <td class="codeLine">  if (isSingleWord() || getActiveBits() <= APINT_BITS_PER_WORD) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeLine">    if (isSigned) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">854</td>
    <td class="codeLine">    if (isSigned) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeLine">      int64_t sext = SignExtend64(getWord(0), BitWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">855</td>
    <td class="codeLine">      int64_t sext = SignExtend64(getWord(0), BitWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeLine">      return double(sext);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">856</td>
    <td class="codeLine">      return double(sext);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeLine">    } else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">857</td>
    <td class="codeLine">    } else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeLine">      return double(getWord(0));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">858</td>
    <td class="codeLine">      return double(getWord(0));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">859</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">860</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeLine">  // Determine if the value is negative.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">861</td>
    <td class="codeLine">  // Determine if the value is negative.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeLine">  bool isNeg = isSigned ? (*this)[BitWidth-1] : false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">862</td>
    <td class="codeLine">  bool isNeg = isSigned ? (*this)[BitWidth-1] : false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">863</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeLine">  // Construct the absolute value if we're negative.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">864</td>
    <td class="codeLine">  // Construct the absolute value if we're negative.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeLine">  APInt Tmp(isNeg ? -(*this) : (*this));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">865</td>
    <td class="codeLine">  APInt Tmp(isNeg ? -(*this) : (*this));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">866</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeLine">  // Figure out how many bits we're using.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">867</td>
    <td class="codeLine">  // Figure out how many bits we're using.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeLine">  unsigned n = Tmp.getActiveBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">868</td>
    <td class="codeLine">  unsigned n = Tmp.getActiveBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">869</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeLine">  // The exponent (without bias normalization) is just the number of bits</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">870</td>
    <td class="codeLine">  // The exponent (without bias normalization) is just the number of bits</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeLine">  // we are using. Note that the sign bit is gone since we constructed the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">871</td>
    <td class="codeLine">  // we are using. Note that the sign bit is gone since we constructed the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeLine">  // absolute value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">872</td>
    <td class="codeLine">  // absolute value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeLine">  uint64_t exp = n;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">873</td>
    <td class="codeLine">  uint64_t exp = n;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">874</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeLine">  // Return infinity for exponent overflow</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">875</td>
    <td class="codeLine">  // Return infinity for exponent overflow</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeLine">  if (exp > 1023) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">876</td>
    <td class="codeLine">  if (exp > 1023) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeLine">    if (!isSigned || !isNeg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">877</td>
    <td class="codeLine">    if (!isSigned || !isNeg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeLine">      return std::numeric_limits<double>::infinity();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">878</td>
    <td class="codeLine">      return std::numeric_limits<double>::infinity();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">879</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeLine">      return -std::numeric_limits<double>::infinity();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">880</td>
    <td class="codeLine">      return -std::numeric_limits<double>::infinity();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">881</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeLine">  exp += 1023; // Increment for 1023 bias</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">882</td>
    <td class="codeLine">  exp += 1023; // Increment for 1023 bias</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">883</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeLine">  // Number of bits in mantissa is 52. To obtain the mantissa value, we must</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">884</td>
    <td class="codeLine">  // Number of bits in mantissa is 52. To obtain the mantissa value, we must</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeLine">  // extract the high 52 bits from the correct words in pVal.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">885</td>
    <td class="codeLine">  // extract the high 52 bits from the correct words in pVal.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeLine">  uint64_t mantissa;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">886</td>
    <td class="codeLine">  uint64_t mantissa;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeLine">  unsigned hiWord = whichWord(n-1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">887</td>
    <td class="codeLine">  unsigned hiWord = whichWord(n-1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeLine">  if (hiWord == 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">888</td>
    <td class="codeLine">  if (hiWord == 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeLine">    mantissa = Tmp.U.pVal[0];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">889</td>
    <td class="codeLine">    mantissa = Tmp.U.pVal[0];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeLine">    if (n > 52)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">890</td>
    <td class="codeLine">    if (n > 52)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeLine">      mantissa >>= n - 52; // shift down, we want the top 52 bits.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">891</td>
    <td class="codeLine">      mantissa >>= n - 52; // shift down, we want the top 52 bits.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">892</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeLine">    assert(hiWord > 0 && "huh?");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">893</td>
    <td class="codeLine">    assert(hiWord > 0 && "huh?");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeLine">    uint64_t hibits = Tmp.U.pVal[hiWord] << (52 - n % APINT_BITS_PER_WORD);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">894</td>
    <td class="codeLine">    uint64_t hibits = Tmp.U.pVal[hiWord] << (52 - n % APINT_BITS_PER_WORD);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeLine">    uint64_t lobits = Tmp.U.pVal[hiWord-1] >> (11 + n % APINT_BITS_PER_WORD);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">895</td>
    <td class="codeLine">    uint64_t lobits = Tmp.U.pVal[hiWord-1] >> (11 + n % APINT_BITS_PER_WORD);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeLine">    mantissa = hibits | lobits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">896</td>
    <td class="codeLine">    mantissa = hibits | lobits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">897</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">898</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeLine">  // The leading bit of mantissa is implicit, so get rid of it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">899</td>
    <td class="codeLine">  // The leading bit of mantissa is implicit, so get rid of it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeLine">  uint64_t sign = isNeg ? (1ULL << (APINT_BITS_PER_WORD - 1)) : 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">900</td>
    <td class="codeLine">  uint64_t sign = isNeg ? (1ULL << (APINT_BITS_PER_WORD - 1)) : 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeLine">  uint64_t I = sign | (exp << 52) | mantissa;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">901</td>
    <td class="codeLine">  uint64_t I = sign | (exp << 52) | mantissa;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeLine">  return bit_cast<double>(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">902</td>
    <td class="codeLine">  return bit_cast<double>(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">903</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">904</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeLine">// Truncate to new width.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">905</td>
    <td class="codeLine">// Truncate to new width.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeLine coveredLine">APInt APInt::trunc(unsigned width) const {</td>
    <td class="lineNumber">149</td>
    <td class="lineNumber">906</td>
    <td class="codeLine coveredLine">APInt APInt::trunc(unsigned width) const {</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeLine coveredLine">  assert(width <= BitWidth && "Invalid APInt Truncate request");</td>
    <td class="lineNumber">149</td>
    <td class="lineNumber">907</td>
    <td class="codeLine coveredLine">  assert(width <= BitWidth && "Invalid APInt Truncate request");</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">908</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeLine coveredLine">  if (width <= APINT_BITS_PER_WORD)</td>
    <td class="lineNumber">149</td>
    <td class="lineNumber">909</td>
    <td class="codeLine coveredLine">  if (width <= APINT_BITS_PER_WORD)</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeLine coveredLine">    return APInt(width, getRawData()[0]);</td>
    <td class="lineNumber">149</td>
    <td class="lineNumber">910</td>
    <td class="codeLine coveredLine">    return APInt(width, getRawData()[0]);</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">911</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeLine">  if (width == BitWidth)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">912</td>
    <td class="codeLine">  if (width == BitWidth)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeLine">    return *this;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">913</td>
    <td class="codeLine">    return *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">914</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeLine">  APInt Result(getMemory(getNumWords(width)), width);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">915</td>
    <td class="codeLine">  APInt Result(getMemory(getNumWords(width)), width);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">916</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeLine">  // Copy full words.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">917</td>
    <td class="codeLine">  // Copy full words.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeLine">  unsigned i;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">918</td>
    <td class="codeLine">  unsigned i;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeLine">  for (i = 0; i != width / APINT_BITS_PER_WORD; i++)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">919</td>
    <td class="codeLine">  for (i = 0; i != width / APINT_BITS_PER_WORD; i++)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeLine">    Result.U.pVal[i] = U.pVal[i];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">920</td>
    <td class="codeLine">    Result.U.pVal[i] = U.pVal[i];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">921</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeLine">  // Truncate and copy any partial word.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">922</td>
    <td class="codeLine">  // Truncate and copy any partial word.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeLine">  unsigned bits = (0 - width) % APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">923</td>
    <td class="codeLine">  unsigned bits = (0 - width) % APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeLine">  if (bits != 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">924</td>
    <td class="codeLine">  if (bits != 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeLine">    Result.U.pVal[i] = U.pVal[i] << bits >> bits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">925</td>
    <td class="codeLine">    Result.U.pVal[i] = U.pVal[i] << bits >> bits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">926</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeLine">  return Result;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">927</td>
    <td class="codeLine">  return Result;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">928</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">929</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeLine">// Truncate to new width with unsigned saturation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">930</td>
    <td class="codeLine">// Truncate to new width with unsigned saturation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeLine">APInt APInt::truncUSat(unsigned width) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">931</td>
    <td class="codeLine">APInt APInt::truncUSat(unsigned width) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeLine">  assert(width <= BitWidth && "Invalid APInt Truncate request");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">932</td>
    <td class="codeLine">  assert(width <= BitWidth && "Invalid APInt Truncate request");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">933</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeLine">  // Can we just losslessly truncate it?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">934</td>
    <td class="codeLine">  // Can we just losslessly truncate it?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeLine">  if (isIntN(width))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">935</td>
    <td class="codeLine">  if (isIntN(width))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeLine">    return trunc(width);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">936</td>
    <td class="codeLine">    return trunc(width);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeLine">  // If not, then just return the new limit.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">937</td>
    <td class="codeLine">  // If not, then just return the new limit.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeLine">  return APInt::getMaxValue(width);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">938</td>
    <td class="codeLine">  return APInt::getMaxValue(width);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">939</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">940</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeLine">// Truncate to new width with signed saturation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">941</td>
    <td class="codeLine">// Truncate to new width with signed saturation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeLine">APInt APInt::truncSSat(unsigned width) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">942</td>
    <td class="codeLine">APInt APInt::truncSSat(unsigned width) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeLine">  assert(width <= BitWidth && "Invalid APInt Truncate request");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">943</td>
    <td class="codeLine">  assert(width <= BitWidth && "Invalid APInt Truncate request");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">944</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeLine">  // Can we just losslessly truncate it?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">945</td>
    <td class="codeLine">  // Can we just losslessly truncate it?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeLine">  if (isSignedIntN(width))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">946</td>
    <td class="codeLine">  if (isSignedIntN(width))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeLine">    return trunc(width);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">947</td>
    <td class="codeLine">    return trunc(width);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeLine">  // If not, then just return the new limits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">948</td>
    <td class="codeLine">  // If not, then just return the new limits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeLine">  return isNegative() ? APInt::getSignedMinValue(width)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">949</td>
    <td class="codeLine">  return isNegative() ? APInt::getSignedMinValue(width)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeLine">                      : APInt::getSignedMaxValue(width);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">950</td>
    <td class="codeLine">                      : APInt::getSignedMaxValue(width);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">951</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">952</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeLine">// Sign extend to a new width.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">953</td>
    <td class="codeLine">// Sign extend to a new width.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeLine">APInt APInt::sext(unsigned Width) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">954</td>
    <td class="codeLine">APInt APInt::sext(unsigned Width) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeLine">  assert(Width >= BitWidth && "Invalid APInt SignExtend request");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">955</td>
    <td class="codeLine">  assert(Width >= BitWidth && "Invalid APInt SignExtend request");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">956</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeLine">  if (Width <= APINT_BITS_PER_WORD)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">957</td>
    <td class="codeLine">  if (Width <= APINT_BITS_PER_WORD)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeLine">    return APInt(Width, SignExtend64(U.VAL, BitWidth));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">958</td>
    <td class="codeLine">    return APInt(Width, SignExtend64(U.VAL, BitWidth));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">959</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeLine">  if (Width == BitWidth)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">960</td>
    <td class="codeLine">  if (Width == BitWidth)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeLine">    return *this;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">961</td>
    <td class="codeLine">    return *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">962</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeLine">  APInt Result(getMemory(getNumWords(Width)), Width);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">963</td>
    <td class="codeLine">  APInt Result(getMemory(getNumWords(Width)), Width);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">964</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeLine">  // Copy words.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">965</td>
    <td class="codeLine">  // Copy words.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeLine">  std::memcpy(Result.U.pVal, getRawData(), getNumWords() * APINT_WORD_SIZE);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">966</td>
    <td class="codeLine">  std::memcpy(Result.U.pVal, getRawData(), getNumWords() * APINT_WORD_SIZE);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">967</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeLine">  // Sign extend the last word since there may be unused bits in the input.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">968</td>
    <td class="codeLine">  // Sign extend the last word since there may be unused bits in the input.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeLine">  Result.U.pVal[getNumWords() - 1] =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">969</td>
    <td class="codeLine">  Result.U.pVal[getNumWords() - 1] =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeLine">      SignExtend64(Result.U.pVal[getNumWords() - 1],</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">970</td>
    <td class="codeLine">      SignExtend64(Result.U.pVal[getNumWords() - 1],</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeLine">                   ((BitWidth - 1) % APINT_BITS_PER_WORD) + 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">971</td>
    <td class="codeLine">                   ((BitWidth - 1) % APINT_BITS_PER_WORD) + 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">972</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeLine">  // Fill with sign bits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">973</td>
    <td class="codeLine">  // Fill with sign bits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeLine">  std::memset(Result.U.pVal + getNumWords(), isNegative() ? -1 : 0,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">974</td>
    <td class="codeLine">  std::memset(Result.U.pVal + getNumWords(), isNegative() ? -1 : 0,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeLine">              (Result.getNumWords() - getNumWords()) * APINT_WORD_SIZE);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">975</td>
    <td class="codeLine">              (Result.getNumWords() - getNumWords()) * APINT_WORD_SIZE);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeLine">  Result.clearUnusedBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">976</td>
    <td class="codeLine">  Result.clearUnusedBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeLine">  return Result;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">977</td>
    <td class="codeLine">  return Result;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">978</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">979</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeLine">//  Zero extend to a new width.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">980</td>
    <td class="codeLine">//  Zero extend to a new width.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeLine coveredLine">APInt APInt::zext(unsigned width) const {</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">981</td>
    <td class="codeLine coveredLine">APInt APInt::zext(unsigned width) const {</td>
    <td class="lineNumber">4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeLine coveredLine">  assert(width >= BitWidth && "Invalid APInt ZeroExtend request");</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">982</td>
    <td class="codeLine coveredLine">  assert(width >= BitWidth && "Invalid APInt ZeroExtend request");</td>
    <td class="lineNumber">4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">983</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeLine coveredLine">  if (width <= APINT_BITS_PER_WORD)</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">984</td>
    <td class="codeLine coveredLine">  if (width <= APINT_BITS_PER_WORD)</td>
    <td class="lineNumber">4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeLine coveredLine">    return APInt(width, U.VAL);</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">985</td>
    <td class="codeLine coveredLine">    return APInt(width, U.VAL);</td>
    <td class="lineNumber">4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">986</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeLine">  if (width == BitWidth)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">987</td>
    <td class="codeLine">  if (width == BitWidth)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeLine">    return *this;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">988</td>
    <td class="codeLine">    return *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">989</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeLine">  APInt Result(getMemory(getNumWords(width)), width);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">990</td>
    <td class="codeLine">  APInt Result(getMemory(getNumWords(width)), width);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">991</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeLine">  // Copy words.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">992</td>
    <td class="codeLine">  // Copy words.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeLine">  std::memcpy(Result.U.pVal, getRawData(), getNumWords() * APINT_WORD_SIZE);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">993</td>
    <td class="codeLine">  std::memcpy(Result.U.pVal, getRawData(), getNumWords() * APINT_WORD_SIZE);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">994</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeLine">  // Zero remaining words.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">995</td>
    <td class="codeLine">  // Zero remaining words.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeLine">  std::memset(Result.U.pVal + getNumWords(), 0,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">996</td>
    <td class="codeLine">  std::memset(Result.U.pVal + getNumWords(), 0,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeLine">              (Result.getNumWords() - getNumWords()) * APINT_WORD_SIZE);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">997</td>
    <td class="codeLine">              (Result.getNumWords() - getNumWords()) * APINT_WORD_SIZE);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">998</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeLine">  return Result;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">999</td>
    <td class="codeLine">  return Result;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1000</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1001</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeLine coveredLine">APInt APInt::zextOrTrunc(unsigned width) const {</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">1002</td>
    <td class="codeLine coveredLine">APInt APInt::zextOrTrunc(unsigned width) const {</td>
    <td class="lineNumber">4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeLine coveredLine">  if (BitWidth < width)</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">1003</td>
    <td class="codeLine coveredLine">  if (BitWidth < width)</td>
    <td class="lineNumber">4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeLine coveredLine">    return zext(width);</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">1004</td>
    <td class="codeLine coveredLine">    return zext(width);</td>
    <td class="lineNumber">4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeLine">  if (BitWidth > width)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1005</td>
    <td class="codeLine">  if (BitWidth > width)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeLine">    return trunc(width);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1006</td>
    <td class="codeLine">    return trunc(width);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeLine">  return *this;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1007</td>
    <td class="codeLine">  return *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1008</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1009</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeLine">APInt APInt::sextOrTrunc(unsigned width) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1010</td>
    <td class="codeLine">APInt APInt::sextOrTrunc(unsigned width) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeLine">  if (BitWidth < width)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1011</td>
    <td class="codeLine">  if (BitWidth < width)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeLine">    return sext(width);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1012</td>
    <td class="codeLine">    return sext(width);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeLine">  if (BitWidth > width)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1013</td>
    <td class="codeLine">  if (BitWidth > width)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeLine">    return trunc(width);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1014</td>
    <td class="codeLine">    return trunc(width);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeLine">  return *this;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1015</td>
    <td class="codeLine">  return *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1016</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1017</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeLine">/// Arithmetic right-shift this APInt by shiftAmt.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1018</td>
    <td class="codeLine">/// Arithmetic right-shift this APInt by shiftAmt.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeLine">/// Arithmetic right-shift function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1019</td>
    <td class="codeLine">/// Arithmetic right-shift function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeLine">void APInt::ashrInPlace(const APInt &shiftAmt) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1020</td>
    <td class="codeLine">void APInt::ashrInPlace(const APInt &shiftAmt) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeLine">  ashrInPlace((unsigned)shiftAmt.getLimitedValue(BitWidth));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1021</td>
    <td class="codeLine">  ashrInPlace((unsigned)shiftAmt.getLimitedValue(BitWidth));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1022</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1023</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeLine">/// Arithmetic right-shift this APInt by shiftAmt.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1024</td>
    <td class="codeLine">/// Arithmetic right-shift this APInt by shiftAmt.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeLine">/// Arithmetic right-shift function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1025</td>
    <td class="codeLine">/// Arithmetic right-shift function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeLine">void APInt::ashrSlowCase(unsigned ShiftAmt) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1026</td>
    <td class="codeLine">void APInt::ashrSlowCase(unsigned ShiftAmt) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeLine">  // Don't bother performing a no-op shift.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1027</td>
    <td class="codeLine">  // Don't bother performing a no-op shift.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeLine">  if (!ShiftAmt)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1028</td>
    <td class="codeLine">  if (!ShiftAmt)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1029</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1030</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeLine">  // Save the original sign bit for later.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1031</td>
    <td class="codeLine">  // Save the original sign bit for later.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeLine">  bool Negative = isNegative();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1032</td>
    <td class="codeLine">  bool Negative = isNegative();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1033</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeLine">  // WordShift is the inter-part shift; BitShift is intra-part shift.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1034</td>
    <td class="codeLine">  // WordShift is the inter-part shift; BitShift is intra-part shift.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeLine">  unsigned WordShift = ShiftAmt / APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1035</td>
    <td class="codeLine">  unsigned WordShift = ShiftAmt / APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeLine">  unsigned BitShift = ShiftAmt % APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1036</td>
    <td class="codeLine">  unsigned BitShift = ShiftAmt % APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1037</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeLine">  unsigned WordsToMove = getNumWords() - WordShift;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1038</td>
    <td class="codeLine">  unsigned WordsToMove = getNumWords() - WordShift;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeLine">  if (WordsToMove != 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1039</td>
    <td class="codeLine">  if (WordsToMove != 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeLine">    // Sign extend the last word to fill in the unused bits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1040</td>
    <td class="codeLine">    // Sign extend the last word to fill in the unused bits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeLine">    U.pVal[getNumWords() - 1] = SignExtend64(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1041</td>
    <td class="codeLine">    U.pVal[getNumWords() - 1] = SignExtend64(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeLine">        U.pVal[getNumWords() - 1], ((BitWidth - 1) % APINT_BITS_PER_WORD) + 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1042</td>
    <td class="codeLine">        U.pVal[getNumWords() - 1], ((BitWidth - 1) % APINT_BITS_PER_WORD) + 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1043</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeLine">    // Fastpath for moving by whole words.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1044</td>
    <td class="codeLine">    // Fastpath for moving by whole words.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeLine">    if (BitShift == 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1045</td>
    <td class="codeLine">    if (BitShift == 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeLine">      std::memmove(U.pVal, U.pVal + WordShift, WordsToMove * APINT_WORD_SIZE);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1046</td>
    <td class="codeLine">      std::memmove(U.pVal, U.pVal + WordShift, WordsToMove * APINT_WORD_SIZE);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1047</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeLine">      // Move the words containing significant bits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1048</td>
    <td class="codeLine">      // Move the words containing significant bits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeLine">      for (unsigned i = 0; i != WordsToMove - 1; ++i)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1049</td>
    <td class="codeLine">      for (unsigned i = 0; i != WordsToMove - 1; ++i)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeLine">        U.pVal[i] = (U.pVal[i + WordShift] >> BitShift) |</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1050</td>
    <td class="codeLine">        U.pVal[i] = (U.pVal[i + WordShift] >> BitShift) |</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeLine">                    (U.pVal[i + WordShift + 1] << (APINT_BITS_PER_WORD - BitShift));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1051</td>
    <td class="codeLine">                    (U.pVal[i + WordShift + 1] << (APINT_BITS_PER_WORD - BitShift));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1052</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeLine">      // Handle the last word which has no high bits to copy.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1053</td>
    <td class="codeLine">      // Handle the last word which has no high bits to copy.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeLine">      U.pVal[WordsToMove - 1] = U.pVal[WordShift + WordsToMove - 1] >> BitShift;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1054</td>
    <td class="codeLine">      U.pVal[WordsToMove - 1] = U.pVal[WordShift + WordsToMove - 1] >> BitShift;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeLine">      // Sign extend one more time.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1055</td>
    <td class="codeLine">      // Sign extend one more time.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeLine">      U.pVal[WordsToMove - 1] =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1056</td>
    <td class="codeLine">      U.pVal[WordsToMove - 1] =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeLine">          SignExtend64(U.pVal[WordsToMove - 1], APINT_BITS_PER_WORD - BitShift);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1057</td>
    <td class="codeLine">          SignExtend64(U.pVal[WordsToMove - 1], APINT_BITS_PER_WORD - BitShift);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1058</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1059</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1060</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeLine">  // Fill in the remainder based on the original sign.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1061</td>
    <td class="codeLine">  // Fill in the remainder based on the original sign.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeLine">  std::memset(U.pVal + WordsToMove, Negative ? -1 : 0,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1062</td>
    <td class="codeLine">  std::memset(U.pVal + WordsToMove, Negative ? -1 : 0,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeLine">              WordShift * APINT_WORD_SIZE);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1063</td>
    <td class="codeLine">              WordShift * APINT_WORD_SIZE);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeLine">  clearUnusedBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1064</td>
    <td class="codeLine">  clearUnusedBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1065</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1066</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeLine">/// Logical right-shift this APInt by shiftAmt.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1067</td>
    <td class="codeLine">/// Logical right-shift this APInt by shiftAmt.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeLine">/// Logical right-shift function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1068</td>
    <td class="codeLine">/// Logical right-shift function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeLine">void APInt::lshrInPlace(const APInt &shiftAmt) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1069</td>
    <td class="codeLine">void APInt::lshrInPlace(const APInt &shiftAmt) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeLine">  lshrInPlace((unsigned)shiftAmt.getLimitedValue(BitWidth));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1070</td>
    <td class="codeLine">  lshrInPlace((unsigned)shiftAmt.getLimitedValue(BitWidth));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1071</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1072</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeLine">/// Logical right-shift this APInt by shiftAmt.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1073</td>
    <td class="codeLine">/// Logical right-shift this APInt by shiftAmt.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeLine">/// Logical right-shift function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1074</td>
    <td class="codeLine">/// Logical right-shift function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeLine">void APInt::lshrSlowCase(unsigned ShiftAmt) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1075</td>
    <td class="codeLine">void APInt::lshrSlowCase(unsigned ShiftAmt) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeLine">  tcShiftRight(U.pVal, getNumWords(), ShiftAmt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1076</td>
    <td class="codeLine">  tcShiftRight(U.pVal, getNumWords(), ShiftAmt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1077</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1078</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeLine">/// Left-shift this APInt by shiftAmt.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1079</td>
    <td class="codeLine">/// Left-shift this APInt by shiftAmt.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeLine">/// Left-shift function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1080</td>
    <td class="codeLine">/// Left-shift function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeLine">APInt &APInt::operator<<=(const APInt &shiftAmt) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1081</td>
    <td class="codeLine">APInt &APInt::operator<<=(const APInt &shiftAmt) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeLine">  // It's undefined behavior in C to shift by BitWidth or greater.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1082</td>
    <td class="codeLine">  // It's undefined behavior in C to shift by BitWidth or greater.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeLine">  *this <<= (unsigned)shiftAmt.getLimitedValue(BitWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1083</td>
    <td class="codeLine">  *this <<= (unsigned)shiftAmt.getLimitedValue(BitWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeLine">  return *this;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1084</td>
    <td class="codeLine">  return *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1085</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1086</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeLine">void APInt::shlSlowCase(unsigned ShiftAmt) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1087</td>
    <td class="codeLine">void APInt::shlSlowCase(unsigned ShiftAmt) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeLine">  tcShiftLeft(U.pVal, getNumWords(), ShiftAmt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1088</td>
    <td class="codeLine">  tcShiftLeft(U.pVal, getNumWords(), ShiftAmt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeLine">  clearUnusedBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1089</td>
    <td class="codeLine">  clearUnusedBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1090</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1091</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeLine">// Calculate the rotate amount modulo the bit width.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1092</td>
    <td class="codeLine">// Calculate the rotate amount modulo the bit width.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeLine">static unsigned rotateModulo(unsigned BitWidth, const APInt &rotateAmt) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1093</td>
    <td class="codeLine">static unsigned rotateModulo(unsigned BitWidth, const APInt &rotateAmt) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeLine">  if (LLVM_UNLIKELY(BitWidth == 0))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1094</td>
    <td class="codeLine">  if (LLVM_UNLIKELY(BitWidth == 0))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1095</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeLine">  unsigned rotBitWidth = rotateAmt.getBitWidth();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1096</td>
    <td class="codeLine">  unsigned rotBitWidth = rotateAmt.getBitWidth();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeLine">  APInt rot = rotateAmt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1097</td>
    <td class="codeLine">  APInt rot = rotateAmt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeLine">  if (rotBitWidth < BitWidth) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1098</td>
    <td class="codeLine">  if (rotBitWidth < BitWidth) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeLine">    // Extend the rotate APInt, so that the urem doesn't divide by 0.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1099</td>
    <td class="codeLine">    // Extend the rotate APInt, so that the urem doesn't divide by 0.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeLine">    // e.g. APInt(1, 32) would give APInt(1, 0).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1100</td>
    <td class="codeLine">    // e.g. APInt(1, 32) would give APInt(1, 0).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeLine">    rot = rotateAmt.zext(BitWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1101</td>
    <td class="codeLine">    rot = rotateAmt.zext(BitWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1102</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeLine">  rot = rot.urem(APInt(rot.getBitWidth(), BitWidth));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1103</td>
    <td class="codeLine">  rot = rot.urem(APInt(rot.getBitWidth(), BitWidth));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeLine">  return rot.getLimitedValue(BitWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1104</td>
    <td class="codeLine">  return rot.getLimitedValue(BitWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1105</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1106</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeLine">APInt APInt::rotl(const APInt &rotateAmt) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1107</td>
    <td class="codeLine">APInt APInt::rotl(const APInt &rotateAmt) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeLine">  return rotl(rotateModulo(BitWidth, rotateAmt));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1108</td>
    <td class="codeLine">  return rotl(rotateModulo(BitWidth, rotateAmt));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1109</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1110</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeLine">APInt APInt::rotl(unsigned rotateAmt) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1111</td>
    <td class="codeLine">APInt APInt::rotl(unsigned rotateAmt) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeLine">  if (LLVM_UNLIKELY(BitWidth == 0))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1112</td>
    <td class="codeLine">  if (LLVM_UNLIKELY(BitWidth == 0))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeLine">    return *this;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1113</td>
    <td class="codeLine">    return *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeLine">  rotateAmt %= BitWidth;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1114</td>
    <td class="codeLine">  rotateAmt %= BitWidth;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeLine">  if (rotateAmt == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1115</td>
    <td class="codeLine">  if (rotateAmt == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeLine">    return *this;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1116</td>
    <td class="codeLine">    return *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeLine">  return shl(rotateAmt) | lshr(BitWidth - rotateAmt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1117</td>
    <td class="codeLine">  return shl(rotateAmt) | lshr(BitWidth - rotateAmt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1118</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1119</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeLine">APInt APInt::rotr(const APInt &rotateAmt) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1120</td>
    <td class="codeLine">APInt APInt::rotr(const APInt &rotateAmt) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeLine">  return rotr(rotateModulo(BitWidth, rotateAmt));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1121</td>
    <td class="codeLine">  return rotr(rotateModulo(BitWidth, rotateAmt));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1122</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1123</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeLine">APInt APInt::rotr(unsigned rotateAmt) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1124</td>
    <td class="codeLine">APInt APInt::rotr(unsigned rotateAmt) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeLine">  if (BitWidth == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1125</td>
    <td class="codeLine">  if (BitWidth == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeLine">    return *this;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1126</td>
    <td class="codeLine">    return *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeLine">  rotateAmt %= BitWidth;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1127</td>
    <td class="codeLine">  rotateAmt %= BitWidth;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeLine">  if (rotateAmt == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1128</td>
    <td class="codeLine">  if (rotateAmt == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeLine">    return *this;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1129</td>
    <td class="codeLine">    return *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeLine">  return lshr(rotateAmt) | shl(BitWidth - rotateAmt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1130</td>
    <td class="codeLine">  return lshr(rotateAmt) | shl(BitWidth - rotateAmt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1131</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1132</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeLine">/// \returns the nearest log base 2 of this APInt. Ties round up.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1133</td>
    <td class="codeLine">/// \returns the nearest log base 2 of this APInt. Ties round up.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1134</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeLine">/// NOTE: When we have a BitWidth of 1, we define:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1135</td>
    <td class="codeLine">/// NOTE: When we have a BitWidth of 1, we define:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1136</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeLine">///   log2(0) = UINT32_MAX</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1137</td>
    <td class="codeLine">///   log2(0) = UINT32_MAX</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeLine">///   log2(1) = 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1138</td>
    <td class="codeLine">///   log2(1) = 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1139</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeLine">/// to get around any mathematical concerns resulting from</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1140</td>
    <td class="codeLine">/// to get around any mathematical concerns resulting from</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeLine">/// referencing 2 in a space where 2 does no exist.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1141</td>
    <td class="codeLine">/// referencing 2 in a space where 2 does no exist.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeLine">unsigned APInt::nearestLogBase2() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1142</td>
    <td class="codeLine">unsigned APInt::nearestLogBase2() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeLine">  // Special case when we have a bitwidth of 1. If VAL is 1, then we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1143</td>
    <td class="codeLine">  // Special case when we have a bitwidth of 1. If VAL is 1, then we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeLine">  // get 0. If VAL is 0, we get WORDTYPE_MAX which gets truncated to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1144</td>
    <td class="codeLine">  // get 0. If VAL is 0, we get WORDTYPE_MAX which gets truncated to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeLine">  // UINT32_MAX.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1145</td>
    <td class="codeLine">  // UINT32_MAX.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeLine">  if (BitWidth == 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1146</td>
    <td class="codeLine">  if (BitWidth == 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeLine">    return U.VAL - 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1147</td>
    <td class="codeLine">    return U.VAL - 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1148</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeLine">  // Handle the zero case.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1149</td>
    <td class="codeLine">  // Handle the zero case.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeLine">  if (isZero())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1150</td>
    <td class="codeLine">  if (isZero())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeLine">    return UINT32_MAX;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1151</td>
    <td class="codeLine">    return UINT32_MAX;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1152</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeLine">  // The non-zero case is handled by computing:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1153</td>
    <td class="codeLine">  // The non-zero case is handled by computing:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1154</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeLine">  //   nearestLogBase2(x) = logBase2(x) + x[logBase2(x)-1].</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1155</td>
    <td class="codeLine">  //   nearestLogBase2(x) = logBase2(x) + x[logBase2(x)-1].</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1156</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeLine">  // where x[i] is referring to the value of the ith bit of x.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1157</td>
    <td class="codeLine">  // where x[i] is referring to the value of the ith bit of x.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeLine">  unsigned lg = logBase2();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1158</td>
    <td class="codeLine">  unsigned lg = logBase2();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeLine">  return lg + unsigned((*this)[lg - 1]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1159</td>
    <td class="codeLine">  return lg + unsigned((*this)[lg - 1]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1160</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1161</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeLine">// Square Root - this method computes and returns the square root of "this".</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1162</td>
    <td class="codeLine">// Square Root - this method computes and returns the square root of "this".</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeLine">// Three mechanisms are used for computation. For small values (<= 5 bits),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1163</td>
    <td class="codeLine">// Three mechanisms are used for computation. For small values (<= 5 bits),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeLine">// a table lookup is done. This gets some performance for common cases. For</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1164</td>
    <td class="codeLine">// a table lookup is done. This gets some performance for common cases. For</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeLine">// values using less than 52 bits, the value is converted to double and then</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1165</td>
    <td class="codeLine">// values using less than 52 bits, the value is converted to double and then</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeLine">// the libc sqrt function is called. The result is rounded and then converted</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1166</td>
    <td class="codeLine">// the libc sqrt function is called. The result is rounded and then converted</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeLine">// back to a uint64_t which is then used to construct the result. Finally,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1167</td>
    <td class="codeLine">// back to a uint64_t which is then used to construct the result. Finally,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeLine">// the Babylonian method for computing square roots is used.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1168</td>
    <td class="codeLine">// the Babylonian method for computing square roots is used.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeLine">APInt APInt::sqrt() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1169</td>
    <td class="codeLine">APInt APInt::sqrt() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1170</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeLine">  // Determine the magnitude of the value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1171</td>
    <td class="codeLine">  // Determine the magnitude of the value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeLine">  unsigned magnitude = getActiveBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1172</td>
    <td class="codeLine">  unsigned magnitude = getActiveBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1173</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeLine">  // Use a fast table for some small values. This also gets rid of some</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1174</td>
    <td class="codeLine">  // Use a fast table for some small values. This also gets rid of some</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeLine">  // rounding errors in libc sqrt for small values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1175</td>
    <td class="codeLine">  // rounding errors in libc sqrt for small values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeLine">  if (magnitude <= 5) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1176</td>
    <td class="codeLine">  if (magnitude <= 5) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeLine">    static const uint8_t results[32] = {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1177</td>
    <td class="codeLine">    static const uint8_t results[32] = {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeLine">      /*     0 */ 0,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1178</td>
    <td class="codeLine">      /*     0 */ 0,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeLine">      /*  1- 2 */ 1, 1,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1179</td>
    <td class="codeLine">      /*  1- 2 */ 1, 1,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeLine">      /*  3- 6 */ 2, 2, 2, 2,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1180</td>
    <td class="codeLine">      /*  3- 6 */ 2, 2, 2, 2,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeLine">      /*  7-12 */ 3, 3, 3, 3, 3, 3,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1181</td>
    <td class="codeLine">      /*  7-12 */ 3, 3, 3, 3, 3, 3,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeLine">      /* 13-20 */ 4, 4, 4, 4, 4, 4, 4, 4,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1182</td>
    <td class="codeLine">      /* 13-20 */ 4, 4, 4, 4, 4, 4, 4, 4,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeLine">      /* 21-30 */ 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1183</td>
    <td class="codeLine">      /* 21-30 */ 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeLine">      /*    31 */ 6</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1184</td>
    <td class="codeLine">      /*    31 */ 6</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1185</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeLine">    return APInt(BitWidth, results[ (isSingleWord() ? U.VAL : U.pVal[0]) ]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1186</td>
    <td class="codeLine">    return APInt(BitWidth, results[ (isSingleWord() ? U.VAL : U.pVal[0]) ]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1187</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1188</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeLine">  // If the magnitude of the value fits in less than 52 bits (the precision of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1189</td>
    <td class="codeLine">  // If the magnitude of the value fits in less than 52 bits (the precision of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeLine">  // an IEEE double precision floating point value), then we can use the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1190</td>
    <td class="codeLine">  // an IEEE double precision floating point value), then we can use the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeLine">  // libc sqrt function which will probably use a hardware sqrt computation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1191</td>
    <td class="codeLine">  // libc sqrt function which will probably use a hardware sqrt computation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeLine">  // This should be faster than the algorithm below.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1192</td>
    <td class="codeLine">  // This should be faster than the algorithm below.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeLine">  if (magnitude < 52) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1193</td>
    <td class="codeLine">  if (magnitude < 52) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeLine">    return APInt(BitWidth,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1194</td>
    <td class="codeLine">    return APInt(BitWidth,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeLine">                 uint64_t(::round(::sqrt(double(isSingleWord() ? U.VAL</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1195</td>
    <td class="codeLine">                 uint64_t(::round(::sqrt(double(isSingleWord() ? U.VAL</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeLine">                                                               : U.pVal[0])))));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1196</td>
    <td class="codeLine">                                                               : U.pVal[0])))));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1197</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1198</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeLine">  // Okay, all the short cuts are exhausted. We must compute it. The following</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1199</td>
    <td class="codeLine">  // Okay, all the short cuts are exhausted. We must compute it. The following</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeLine">  // is a classical Babylonian method for computing the square root. This code</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1200</td>
    <td class="codeLine">  // is a classical Babylonian method for computing the square root. This code</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeLine">  // was adapted to APInt from a wikipedia article on such computations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1201</td>
    <td class="codeLine">  // was adapted to APInt from a wikipedia article on such computations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeLine">  // See http://www.wikipedia.org/ and go to the page named</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1202</td>
    <td class="codeLine">  // See http://www.wikipedia.org/ and go to the page named</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeLine">  // Calculate_an_integer_square_root.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1203</td>
    <td class="codeLine">  // Calculate_an_integer_square_root.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeLine">  unsigned nbits = BitWidth, i = 4;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1204</td>
    <td class="codeLine">  unsigned nbits = BitWidth, i = 4;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeLine">  APInt testy(BitWidth, 16);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1205</td>
    <td class="codeLine">  APInt testy(BitWidth, 16);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeLine">  APInt x_old(BitWidth, 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1206</td>
    <td class="codeLine">  APInt x_old(BitWidth, 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeLine">  APInt x_new(BitWidth, 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1207</td>
    <td class="codeLine">  APInt x_new(BitWidth, 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeLine">  APInt two(BitWidth, 2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1208</td>
    <td class="codeLine">  APInt two(BitWidth, 2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1209</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeLine">  // Select a good starting value using binary logarithms.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1210</td>
    <td class="codeLine">  // Select a good starting value using binary logarithms.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeLine">  for (;; i += 2, testy = testy.shl(2))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1211</td>
    <td class="codeLine">  for (;; i += 2, testy = testy.shl(2))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeLine">    if (i >= nbits || this->ule(testy)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1212</td>
    <td class="codeLine">    if (i >= nbits || this->ule(testy)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeLine">      x_old = x_old.shl(i / 2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1213</td>
    <td class="codeLine">      x_old = x_old.shl(i / 2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1214</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1215</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1216</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeLine">  // Use the Babylonian method to arrive at the integer square root:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1217</td>
    <td class="codeLine">  // Use the Babylonian method to arrive at the integer square root:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeLine">  for (;;) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1218</td>
    <td class="codeLine">  for (;;) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeLine">    x_new = (this->udiv(x_old) + x_old).udiv(two);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1219</td>
    <td class="codeLine">    x_new = (this->udiv(x_old) + x_old).udiv(two);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeLine">    if (x_old.ule(x_new))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1220</td>
    <td class="codeLine">    if (x_old.ule(x_new))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1221</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeLine">    x_old = x_new;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1222</td>
    <td class="codeLine">    x_old = x_new;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1223</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1224</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeLine">  // Make sure we return the closest approximation</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1225</td>
    <td class="codeLine">  // Make sure we return the closest approximation</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeLine">  // NOTE: The rounding calculation below is correct. It will produce an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1226</td>
    <td class="codeLine">  // NOTE: The rounding calculation below is correct. It will produce an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeLine">  // off-by-one discrepancy with results from pari/gp. That discrepancy has been</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1227</td>
    <td class="codeLine">  // off-by-one discrepancy with results from pari/gp. That discrepancy has been</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeLine">  // determined to be a rounding issue with pari/gp as it begins to use a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1228</td>
    <td class="codeLine">  // determined to be a rounding issue with pari/gp as it begins to use a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeLine">  // floating point representation after 192 bits. There are no discrepancies</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1229</td>
    <td class="codeLine">  // floating point representation after 192 bits. There are no discrepancies</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeLine">  // between this algorithm and pari/gp for bit widths < 192 bits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1230</td>
    <td class="codeLine">  // between this algorithm and pari/gp for bit widths < 192 bits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeLine">  APInt square(x_old * x_old);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1231</td>
    <td class="codeLine">  APInt square(x_old * x_old);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeLine">  APInt nextSquare((x_old + 1) * (x_old +1));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1232</td>
    <td class="codeLine">  APInt nextSquare((x_old + 1) * (x_old +1));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeLine">  if (this->ult(square))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1233</td>
    <td class="codeLine">  if (this->ult(square))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeLine">    return x_old;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1234</td>
    <td class="codeLine">    return x_old;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeLine">  assert(this->ule(nextSquare) && "Error in APInt::sqrt computation");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1235</td>
    <td class="codeLine">  assert(this->ule(nextSquare) && "Error in APInt::sqrt computation");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeLine">  APInt midpoint((nextSquare - square).udiv(two));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1236</td>
    <td class="codeLine">  APInt midpoint((nextSquare - square).udiv(two));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeLine">  APInt offset(*this - square);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1237</td>
    <td class="codeLine">  APInt offset(*this - square);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeLine">  if (offset.ult(midpoint))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1238</td>
    <td class="codeLine">  if (offset.ult(midpoint))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeLine">    return x_old;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1239</td>
    <td class="codeLine">    return x_old;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeLine">  return x_old + 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1240</td>
    <td class="codeLine">  return x_old + 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1241</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1242</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeLine">/// Computes the multiplicative inverse of this APInt for a given modulo. The</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1243</td>
    <td class="codeLine">/// Computes the multiplicative inverse of this APInt for a given modulo. The</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeLine">/// iterative extended Euclidean algorithm is used to solve for this value,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1244</td>
    <td class="codeLine">/// iterative extended Euclidean algorithm is used to solve for this value,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeLine">/// however we simplify it to speed up calculating only the inverse, and take</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1245</td>
    <td class="codeLine">/// however we simplify it to speed up calculating only the inverse, and take</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeLine">/// advantage of div+rem calculations. We also use some tricks to avoid copying</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1246</td>
    <td class="codeLine">/// advantage of div+rem calculations. We also use some tricks to avoid copying</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeLine">/// (potentially large) APInts around.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1247</td>
    <td class="codeLine">/// (potentially large) APInts around.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeLine">/// WARNING: a value of '0' may be returned,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1248</td>
    <td class="codeLine">/// WARNING: a value of '0' may be returned,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeLine">///          signifying that no multiplicative inverse exists!</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1249</td>
    <td class="codeLine">///          signifying that no multiplicative inverse exists!</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeLine">APInt APInt::multiplicativeInverse(const APInt& modulo) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1250</td>
    <td class="codeLine">APInt APInt::multiplicativeInverse(const APInt& modulo) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeLine">  assert(ult(modulo) && "This APInt must be smaller than the modulo");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1251</td>
    <td class="codeLine">  assert(ult(modulo) && "This APInt must be smaller than the modulo");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1252</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeLine">  // Using the properties listed at the following web page (accessed 06/21/08):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1253</td>
    <td class="codeLine">  // Using the properties listed at the following web page (accessed 06/21/08):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeLine">  //   http://www.numbertheory.org/php/euclid.html</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1254</td>
    <td class="codeLine">  //   http://www.numbertheory.org/php/euclid.html</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeLine">  // (especially the properties numbered 3, 4 and 9) it can be proved that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1255</td>
    <td class="codeLine">  // (especially the properties numbered 3, 4 and 9) it can be proved that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeLine">  // BitWidth bits suffice for all the computations in the algorithm implemented</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1256</td>
    <td class="codeLine">  // BitWidth bits suffice for all the computations in the algorithm implemented</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeLine">  // below. More precisely, this number of bits suffice if the multiplicative</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1257</td>
    <td class="codeLine">  // below. More precisely, this number of bits suffice if the multiplicative</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeLine">  // inverse exists, but may not suffice for the general extended Euclidean</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1258</td>
    <td class="codeLine">  // inverse exists, but may not suffice for the general extended Euclidean</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeLine">  // algorithm.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1259</td>
    <td class="codeLine">  // algorithm.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1260</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeLine">  APInt r[2] = { modulo, *this };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1261</td>
    <td class="codeLine">  APInt r[2] = { modulo, *this };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeLine">  APInt t[2] = { APInt(BitWidth, 0), APInt(BitWidth, 1) };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1262</td>
    <td class="codeLine">  APInt t[2] = { APInt(BitWidth, 0), APInt(BitWidth, 1) };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeLine">  APInt q(BitWidth, 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1263</td>
    <td class="codeLine">  APInt q(BitWidth, 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1264</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeLine">  unsigned i;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1265</td>
    <td class="codeLine">  unsigned i;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeLine">  for (i = 0; r[i^1] != 0; i ^= 1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1266</td>
    <td class="codeLine">  for (i = 0; r[i^1] != 0; i ^= 1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeLine">    // An overview of the math without the confusing bit-flipping:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1267</td>
    <td class="codeLine">    // An overview of the math without the confusing bit-flipping:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeLine">    // q = r[i-2] / r[i-1]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1268</td>
    <td class="codeLine">    // q = r[i-2] / r[i-1]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeLine">    // r[i] = r[i-2] % r[i-1]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1269</td>
    <td class="codeLine">    // r[i] = r[i-2] % r[i-1]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeLine">    // t[i] = t[i-2] - t[i-1] * q</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1270</td>
    <td class="codeLine">    // t[i] = t[i-2] - t[i-1] * q</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeLine">    udivrem(r[i], r[i^1], q, r[i]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1271</td>
    <td class="codeLine">    udivrem(r[i], r[i^1], q, r[i]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeLine">    t[i] -= t[i^1] * q;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1272</td>
    <td class="codeLine">    t[i] -= t[i^1] * q;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1273</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1274</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeLine">  // If this APInt and the modulo are not coprime, there is no multiplicative</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1275</td>
    <td class="codeLine">  // If this APInt and the modulo are not coprime, there is no multiplicative</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeLine">  // inverse, so return 0. We check this by looking at the next-to-last</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1276</td>
    <td class="codeLine">  // inverse, so return 0. We check this by looking at the next-to-last</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeLine">  // remainder, which is the gcd(*this,modulo) as calculated by the Euclidean</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1277</td>
    <td class="codeLine">  // remainder, which is the gcd(*this,modulo) as calculated by the Euclidean</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeLine">  // algorithm.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1278</td>
    <td class="codeLine">  // algorithm.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeLine">  if (r[i] != 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1279</td>
    <td class="codeLine">  if (r[i] != 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeLine">    return APInt(BitWidth, 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1280</td>
    <td class="codeLine">    return APInt(BitWidth, 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1281</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeLine">  // The next-to-last t is the multiplicative inverse.  However, we are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1282</td>
    <td class="codeLine">  // The next-to-last t is the multiplicative inverse.  However, we are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeLine">  // interested in a positive inverse. Calculate a positive one from a negative</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1283</td>
    <td class="codeLine">  // interested in a positive inverse. Calculate a positive one from a negative</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeLine">  // one if necessary. A simple addition of the modulo suffices because</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1284</td>
    <td class="codeLine">  // one if necessary. A simple addition of the modulo suffices because</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeLine">  // abs(t[i]) is known to be less than *this/2 (see the link above).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1285</td>
    <td class="codeLine">  // abs(t[i]) is known to be less than *this/2 (see the link above).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeLine">  if (t[i].isNegative())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1286</td>
    <td class="codeLine">  if (t[i].isNegative())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeLine">    t[i] += modulo;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1287</td>
    <td class="codeLine">    t[i] += modulo;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1288</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeLine">  return std::move(t[i]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1289</td>
    <td class="codeLine">  return std::move(t[i]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1290</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1291</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeLine">/// Implementation of Knuth's Algorithm D (Division of nonnegative integers)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1292</td>
    <td class="codeLine">/// Implementation of Knuth's Algorithm D (Division of nonnegative integers)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeLine">/// from "Art of Computer Programming, Volume 2", section 4.3.1, p. 272. The</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1293</td>
    <td class="codeLine">/// from "Art of Computer Programming, Volume 2", section 4.3.1, p. 272. The</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeLine">/// variables here have the same names as in the algorithm. Comments explain</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1294</td>
    <td class="codeLine">/// variables here have the same names as in the algorithm. Comments explain</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeLine">/// the algorithm and any deviation from it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1295</td>
    <td class="codeLine">/// the algorithm and any deviation from it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeLine">static void KnuthDiv(uint32_t *u, uint32_t *v, uint32_t *q, uint32_t* r,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1296</td>
    <td class="codeLine">static void KnuthDiv(uint32_t *u, uint32_t *v, uint32_t *q, uint32_t* r,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeLine">                     unsigned m, unsigned n) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1297</td>
    <td class="codeLine">                     unsigned m, unsigned n) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeLine">  assert(u && "Must provide dividend");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1298</td>
    <td class="codeLine">  assert(u && "Must provide dividend");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeLine">  assert(v && "Must provide divisor");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1299</td>
    <td class="codeLine">  assert(v && "Must provide divisor");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeLine">  assert(q && "Must provide quotient");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1300</td>
    <td class="codeLine">  assert(q && "Must provide quotient");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeLine">  assert(u != v && u != q && v != q && "Must use different memory");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1301</td>
    <td class="codeLine">  assert(u != v && u != q && v != q && "Must use different memory");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeLine">  assert(n>1 && "n must be > 1");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1302</td>
    <td class="codeLine">  assert(n>1 && "n must be > 1");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1303</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeLine">  // b denotes the base of the number system. In our case b is 2^32.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1304</td>
    <td class="codeLine">  // b denotes the base of the number system. In our case b is 2^32.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeLine">  const uint64_t b = uint64_t(1) << 32;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1305</td>
    <td class="codeLine">  const uint64_t b = uint64_t(1) << 32;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1306</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeLine">// The DEBUG macros here tend to be spam in the debug output if you're not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1307</td>
    <td class="codeLine">// The DEBUG macros here tend to be spam in the debug output if you're not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeLine">// debugging this code. Disable them unless KNUTH_DEBUG is defined.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1308</td>
    <td class="codeLine">// debugging this code. Disable them unless KNUTH_DEBUG is defined.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeLine">#ifdef KNUTH_DEBUG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1309</td>
    <td class="codeLine">#ifdef KNUTH_DEBUG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeLine">#define DEBUG_KNUTH(X) LLVM_DEBUG(X)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1310</td>
    <td class="codeLine">#define DEBUG_KNUTH(X) LLVM_DEBUG(X)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeLine">#else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1311</td>
    <td class="codeLine">#else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeLine">#define DEBUG_KNUTH(X) do {} while(false)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1312</td>
    <td class="codeLine">#define DEBUG_KNUTH(X) do {} while(false)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1313</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1314</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeLine">  DEBUG_KNUTH(dbgs() << "KnuthDiv: m=" << m << " n=" << n << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1315</td>
    <td class="codeLine">  DEBUG_KNUTH(dbgs() << "KnuthDiv: m=" << m << " n=" << n << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeLine">  DEBUG_KNUTH(dbgs() << "KnuthDiv: original:");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1316</td>
    <td class="codeLine">  DEBUG_KNUTH(dbgs() << "KnuthDiv: original:");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeLine">  DEBUG_KNUTH(for (int i = m + n; i >= 0; i--) dbgs() << " " << u[i]);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1317</td>
    <td class="codeLine">  DEBUG_KNUTH(for (int i = m + n; i >= 0; i--) dbgs() << " " << u[i]);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeLine">  DEBUG_KNUTH(dbgs() << " by");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1318</td>
    <td class="codeLine">  DEBUG_KNUTH(dbgs() << " by");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeLine">  DEBUG_KNUTH(for (int i = n; i > 0; i--) dbgs() << " " << v[i - 1]);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1319</td>
    <td class="codeLine">  DEBUG_KNUTH(for (int i = n; i > 0; i--) dbgs() << " " << v[i - 1]);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeLine">  DEBUG_KNUTH(dbgs() << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1320</td>
    <td class="codeLine">  DEBUG_KNUTH(dbgs() << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeLine">  // D1. [Normalize.] Set d = b / (v[n-1] + 1) and multiply all the digits of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1321</td>
    <td class="codeLine">  // D1. [Normalize.] Set d = b / (v[n-1] + 1) and multiply all the digits of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeLine">  // u and v by d. Note that we have taken Knuth's advice here to use a power</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1322</td>
    <td class="codeLine">  // u and v by d. Note that we have taken Knuth's advice here to use a power</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeLine">  // of 2 value for d such that d * v[n-1] >= b/2 (b is the base). A power of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1323</td>
    <td class="codeLine">  // of 2 value for d such that d * v[n-1] >= b/2 (b is the base). A power of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeLine">  // 2 allows us to shift instead of multiply and it is easy to determine the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1324</td>
    <td class="codeLine">  // 2 allows us to shift instead of multiply and it is easy to determine the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeLine">  // shift amount from the leading zeros.  We are basically normalizing the u</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1325</td>
    <td class="codeLine">  // shift amount from the leading zeros.  We are basically normalizing the u</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeLine">  // and v so that its high bits are shifted to the top of v's range without</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1326</td>
    <td class="codeLine">  // and v so that its high bits are shifted to the top of v's range without</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeLine">  // overflow. Note that this can require an extra word in u so that u must</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1327</td>
    <td class="codeLine">  // overflow. Note that this can require an extra word in u so that u must</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeLine">  // be of length m+n+1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1328</td>
    <td class="codeLine">  // be of length m+n+1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeLine">  unsigned shift = llvm::countl_zero(v[n - 1]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1329</td>
    <td class="codeLine">  unsigned shift = llvm::countl_zero(v[n - 1]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeLine">  uint32_t v_carry = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1330</td>
    <td class="codeLine">  uint32_t v_carry = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeLine">  uint32_t u_carry = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1331</td>
    <td class="codeLine">  uint32_t u_carry = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeLine">  if (shift) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1332</td>
    <td class="codeLine">  if (shift) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeLine">    for (unsigned i = 0; i < m+n; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1333</td>
    <td class="codeLine">    for (unsigned i = 0; i < m+n; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeLine">      uint32_t u_tmp = u[i] >> (32 - shift);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1334</td>
    <td class="codeLine">      uint32_t u_tmp = u[i] >> (32 - shift);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeLine">      u[i] = (u[i] << shift) | u_carry;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1335</td>
    <td class="codeLine">      u[i] = (u[i] << shift) | u_carry;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeLine">      u_carry = u_tmp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1336</td>
    <td class="codeLine">      u_carry = u_tmp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1337</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeLine">    for (unsigned i = 0; i < n; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1338</td>
    <td class="codeLine">    for (unsigned i = 0; i < n; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeLine">      uint32_t v_tmp = v[i] >> (32 - shift);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1339</td>
    <td class="codeLine">      uint32_t v_tmp = v[i] >> (32 - shift);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeLine">      v[i] = (v[i] << shift) | v_carry;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1340</td>
    <td class="codeLine">      v[i] = (v[i] << shift) | v_carry;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeLine">      v_carry = v_tmp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1341</td>
    <td class="codeLine">      v_carry = v_tmp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1342</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1343</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeLine">  u[m+n] = u_carry;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1344</td>
    <td class="codeLine">  u[m+n] = u_carry;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1345</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeLine">  DEBUG_KNUTH(dbgs() << "KnuthDiv:   normal:");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1346</td>
    <td class="codeLine">  DEBUG_KNUTH(dbgs() << "KnuthDiv:   normal:");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeLine">  DEBUG_KNUTH(for (int i = m + n; i >= 0; i--) dbgs() << " " << u[i]);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1347</td>
    <td class="codeLine">  DEBUG_KNUTH(for (int i = m + n; i >= 0; i--) dbgs() << " " << u[i]);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeLine">  DEBUG_KNUTH(dbgs() << " by");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1348</td>
    <td class="codeLine">  DEBUG_KNUTH(dbgs() << " by");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeLine">  DEBUG_KNUTH(for (int i = n; i > 0; i--) dbgs() << " " << v[i - 1]);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1349</td>
    <td class="codeLine">  DEBUG_KNUTH(for (int i = n; i > 0; i--) dbgs() << " " << v[i - 1]);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeLine">  DEBUG_KNUTH(dbgs() << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1350</td>
    <td class="codeLine">  DEBUG_KNUTH(dbgs() << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1351</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeLine">  // D2. [Initialize j.]  Set j to m. This is the loop counter over the places.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1352</td>
    <td class="codeLine">  // D2. [Initialize j.]  Set j to m. This is the loop counter over the places.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeLine">  int j = m;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1353</td>
    <td class="codeLine">  int j = m;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeLine">  do {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1354</td>
    <td class="codeLine">  do {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeLine">    DEBUG_KNUTH(dbgs() << "KnuthDiv: quotient digit #" << j << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1355</td>
    <td class="codeLine">    DEBUG_KNUTH(dbgs() << "KnuthDiv: quotient digit #" << j << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeLine">    // D3. [Calculate q'.].</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1356</td>
    <td class="codeLine">    // D3. [Calculate q'.].</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeLine">    //     Set qp = (u[j+n]*b + u[j+n-1]) / v[n-1]. (qp=qprime=q')</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1357</td>
    <td class="codeLine">    //     Set qp = (u[j+n]*b + u[j+n-1]) / v[n-1]. (qp=qprime=q')</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeLine">    //     Set rp = (u[j+n]*b + u[j+n-1]) % v[n-1]. (rp=rprime=r')</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1358</td>
    <td class="codeLine">    //     Set rp = (u[j+n]*b + u[j+n-1]) % v[n-1]. (rp=rprime=r')</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeLine">    // Now test if qp == b or qp*v[n-2] > b*rp + u[j+n-2]; if so, decrease</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1359</td>
    <td class="codeLine">    // Now test if qp == b or qp*v[n-2] > b*rp + u[j+n-2]; if so, decrease</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeLine">    // qp by 1, increase rp by v[n-1], and repeat this test if rp < b. The test</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1360</td>
    <td class="codeLine">    // qp by 1, increase rp by v[n-1], and repeat this test if rp < b. The test</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeLine">    // on v[n-2] determines at high speed most of the cases in which the trial</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1361</td>
    <td class="codeLine">    // on v[n-2] determines at high speed most of the cases in which the trial</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeLine">    // value qp is one too large, and it eliminates all cases where qp is two</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1362</td>
    <td class="codeLine">    // value qp is one too large, and it eliminates all cases where qp is two</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeLine">    // too large.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1363</td>
    <td class="codeLine">    // too large.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeLine">    uint64_t dividend = Make_64(u[j+n], u[j+n-1]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1364</td>
    <td class="codeLine">    uint64_t dividend = Make_64(u[j+n], u[j+n-1]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeLine">    DEBUG_KNUTH(dbgs() << "KnuthDiv: dividend == " << dividend << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1365</td>
    <td class="codeLine">    DEBUG_KNUTH(dbgs() << "KnuthDiv: dividend == " << dividend << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeLine">    uint64_t qp = dividend / v[n-1];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1366</td>
    <td class="codeLine">    uint64_t qp = dividend / v[n-1];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeLine">    uint64_t rp = dividend % v[n-1];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1367</td>
    <td class="codeLine">    uint64_t rp = dividend % v[n-1];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeLine">    if (qp == b || qp*v[n-2] > b*rp + u[j+n-2]) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1368</td>
    <td class="codeLine">    if (qp == b || qp*v[n-2] > b*rp + u[j+n-2]) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeLine">      qp--;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1369</td>
    <td class="codeLine">      qp--;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeLine">      rp += v[n-1];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1370</td>
    <td class="codeLine">      rp += v[n-1];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeLine">      if (rp < b && (qp == b || qp*v[n-2] > b*rp + u[j+n-2]))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1371</td>
    <td class="codeLine">      if (rp < b && (qp == b || qp*v[n-2] > b*rp + u[j+n-2]))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeLine">        qp--;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1372</td>
    <td class="codeLine">        qp--;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1373</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeLine">    DEBUG_KNUTH(dbgs() << "KnuthDiv: qp == " << qp << ", rp == " << rp << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1374</td>
    <td class="codeLine">    DEBUG_KNUTH(dbgs() << "KnuthDiv: qp == " << qp << ", rp == " << rp << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1375</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeLine">    // D4. [Multiply and subtract.] Replace (u[j+n]u[j+n-1]...u[j]) with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1376</td>
    <td class="codeLine">    // D4. [Multiply and subtract.] Replace (u[j+n]u[j+n-1]...u[j]) with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeLine">    // (u[j+n]u[j+n-1]..u[j]) - qp * (v[n-1]...v[1]v[0]). This computation</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1377</td>
    <td class="codeLine">    // (u[j+n]u[j+n-1]..u[j]) - qp * (v[n-1]...v[1]v[0]). This computation</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeLine">    // consists of a simple multiplication by a one-place number, combined with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1378</td>
    <td class="codeLine">    // consists of a simple multiplication by a one-place number, combined with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeLine">    // a subtraction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1379</td>
    <td class="codeLine">    // a subtraction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeLine">    // The digits (u[j+n]...u[j]) should be kept positive; if the result of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1380</td>
    <td class="codeLine">    // The digits (u[j+n]...u[j]) should be kept positive; if the result of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeLine">    // this step is actually negative, (u[j+n]...u[j]) should be left as the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1381</td>
    <td class="codeLine">    // this step is actually negative, (u[j+n]...u[j]) should be left as the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeLine">    // true value plus b**(n+1), namely as the b's complement of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1382</td>
    <td class="codeLine">    // true value plus b**(n+1), namely as the b's complement of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeLine">    // the true value, and a "borrow" to the left should be remembered.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1383</td>
    <td class="codeLine">    // the true value, and a "borrow" to the left should be remembered.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeLine">    int64_t borrow = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1384</td>
    <td class="codeLine">    int64_t borrow = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeLine">    for (unsigned i = 0; i < n; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1385</td>
    <td class="codeLine">    for (unsigned i = 0; i < n; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeLine">      uint64_t p = uint64_t(qp) * uint64_t(v[i]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1386</td>
    <td class="codeLine">      uint64_t p = uint64_t(qp) * uint64_t(v[i]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeLine">      int64_t subres = int64_t(u[j+i]) - borrow - Lo_32(p);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1387</td>
    <td class="codeLine">      int64_t subres = int64_t(u[j+i]) - borrow - Lo_32(p);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeLine">      u[j+i] = Lo_32(subres);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1388</td>
    <td class="codeLine">      u[j+i] = Lo_32(subres);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeLine">      borrow = Hi_32(p) - Hi_32(subres);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1389</td>
    <td class="codeLine">      borrow = Hi_32(p) - Hi_32(subres);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeLine">      DEBUG_KNUTH(dbgs() << "KnuthDiv: u[j+i] = " << u[j + i]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1390</td>
    <td class="codeLine">      DEBUG_KNUTH(dbgs() << "KnuthDiv: u[j+i] = " << u[j + i]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeLine">                        << ", borrow = " << borrow << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1391</td>
    <td class="codeLine">                        << ", borrow = " << borrow << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1392</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeLine">    bool isNeg = u[j+n] < borrow;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1393</td>
    <td class="codeLine">    bool isNeg = u[j+n] < borrow;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeLine">    u[j+n] -= Lo_32(borrow);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1394</td>
    <td class="codeLine">    u[j+n] -= Lo_32(borrow);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1395</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeLine">    DEBUG_KNUTH(dbgs() << "KnuthDiv: after subtraction:");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1396</td>
    <td class="codeLine">    DEBUG_KNUTH(dbgs() << "KnuthDiv: after subtraction:");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeLine">    DEBUG_KNUTH(for (int i = m + n; i >= 0; i--) dbgs() << " " << u[i]);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1397</td>
    <td class="codeLine">    DEBUG_KNUTH(for (int i = m + n; i >= 0; i--) dbgs() << " " << u[i]);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeLine">    DEBUG_KNUTH(dbgs() << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1398</td>
    <td class="codeLine">    DEBUG_KNUTH(dbgs() << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1399</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeLine">    // D5. [Test remainder.] Set q[j] = qp. If the result of step D4 was</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1400</td>
    <td class="codeLine">    // D5. [Test remainder.] Set q[j] = qp. If the result of step D4 was</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeLine">    // negative, go to step D6; otherwise go on to step D7.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1401</td>
    <td class="codeLine">    // negative, go to step D6; otherwise go on to step D7.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeLine">    q[j] = Lo_32(qp);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1402</td>
    <td class="codeLine">    q[j] = Lo_32(qp);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeLine">    if (isNeg) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1403</td>
    <td class="codeLine">    if (isNeg) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeLine">      // D6. [Add back]. The probability that this step is necessary is very</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1404</td>
    <td class="codeLine">      // D6. [Add back]. The probability that this step is necessary is very</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeLine">      // small, on the order of only 2/b. Make sure that test data accounts for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1405</td>
    <td class="codeLine">      // small, on the order of only 2/b. Make sure that test data accounts for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeLine">      // this possibility. Decrease q[j] by 1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1406</td>
    <td class="codeLine">      // this possibility. Decrease q[j] by 1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeLine">      q[j]--;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1407</td>
    <td class="codeLine">      q[j]--;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeLine">      // and add (0v[n-1]...v[1]v[0]) to (u[j+n]u[j+n-1]...u[j+1]u[j]).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1408</td>
    <td class="codeLine">      // and add (0v[n-1]...v[1]v[0]) to (u[j+n]u[j+n-1]...u[j+1]u[j]).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeLine">      // A carry will occur to the left of u[j+n], and it should be ignored</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1409</td>
    <td class="codeLine">      // A carry will occur to the left of u[j+n], and it should be ignored</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeLine">      // since it cancels with the borrow that occurred in D4.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1410</td>
    <td class="codeLine">      // since it cancels with the borrow that occurred in D4.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeLine">      bool carry = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1411</td>
    <td class="codeLine">      bool carry = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeLine">      for (unsigned i = 0; i < n; i++) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1412</td>
    <td class="codeLine">      for (unsigned i = 0; i < n; i++) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeLine">        uint32_t limit = std::min(u[j+i],v[i]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1413</td>
    <td class="codeLine">        uint32_t limit = std::min(u[j+i],v[i]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeLine">        u[j+i] += v[i] + carry;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1414</td>
    <td class="codeLine">        u[j+i] += v[i] + carry;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeLine">        carry = u[j+i] < limit || (carry && u[j+i] == limit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1415</td>
    <td class="codeLine">        carry = u[j+i] < limit || (carry && u[j+i] == limit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1416</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeLine">      u[j+n] += carry;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1417</td>
    <td class="codeLine">      u[j+n] += carry;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1418</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeLine">    DEBUG_KNUTH(dbgs() << "KnuthDiv: after correction:");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1419</td>
    <td class="codeLine">    DEBUG_KNUTH(dbgs() << "KnuthDiv: after correction:");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeLine">    DEBUG_KNUTH(for (int i = m + n; i >= 0; i--) dbgs() << " " << u[i]);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1420</td>
    <td class="codeLine">    DEBUG_KNUTH(for (int i = m + n; i >= 0; i--) dbgs() << " " << u[i]);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeLine">    DEBUG_KNUTH(dbgs() << "\nKnuthDiv: digit result = " << q[j] << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1421</td>
    <td class="codeLine">    DEBUG_KNUTH(dbgs() << "\nKnuthDiv: digit result = " << q[j] << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1422</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeLine">    // D7. [Loop on j.]  Decrease j by one. Now if j >= 0, go back to D3.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1423</td>
    <td class="codeLine">    // D7. [Loop on j.]  Decrease j by one. Now if j >= 0, go back to D3.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeLine">  } while (--j >= 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1424</td>
    <td class="codeLine">  } while (--j >= 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1425</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeLine">  DEBUG_KNUTH(dbgs() << "KnuthDiv: quotient:");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1426</td>
    <td class="codeLine">  DEBUG_KNUTH(dbgs() << "KnuthDiv: quotient:");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeLine">  DEBUG_KNUTH(for (int i = m; i >= 0; i--) dbgs() << " " << q[i]);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1427</td>
    <td class="codeLine">  DEBUG_KNUTH(for (int i = m; i >= 0; i--) dbgs() << " " << q[i]);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeLine">  DEBUG_KNUTH(dbgs() << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1428</td>
    <td class="codeLine">  DEBUG_KNUTH(dbgs() << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1429</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeLine">  // D8. [Unnormalize]. Now q[...] is the desired quotient, and the desired</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1430</td>
    <td class="codeLine">  // D8. [Unnormalize]. Now q[...] is the desired quotient, and the desired</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeLine">  // remainder may be obtained by dividing u[...] by d. If r is non-null we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1431</td>
    <td class="codeLine">  // remainder may be obtained by dividing u[...] by d. If r is non-null we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeLine">  // compute the remainder (urem uses this).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1432</td>
    <td class="codeLine">  // compute the remainder (urem uses this).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeLine">  if (r) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1433</td>
    <td class="codeLine">  if (r) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeLine">    // The value d is expressed by the "shift" value above since we avoided</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1434</td>
    <td class="codeLine">    // The value d is expressed by the "shift" value above since we avoided</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeLine">    // multiplication by d by using a shift left. So, all we have to do is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1435</td>
    <td class="codeLine">    // multiplication by d by using a shift left. So, all we have to do is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeLine">    // shift right here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1436</td>
    <td class="codeLine">    // shift right here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeLine">    if (shift) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1437</td>
    <td class="codeLine">    if (shift) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeLine">      uint32_t carry = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1438</td>
    <td class="codeLine">      uint32_t carry = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeLine">      DEBUG_KNUTH(dbgs() << "KnuthDiv: remainder:");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1439</td>
    <td class="codeLine">      DEBUG_KNUTH(dbgs() << "KnuthDiv: remainder:");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeLine">      for (int i = n-1; i >= 0; i--) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1440</td>
    <td class="codeLine">      for (int i = n-1; i >= 0; i--) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeLine">        r[i] = (u[i] >> shift) | carry;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1441</td>
    <td class="codeLine">        r[i] = (u[i] >> shift) | carry;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeLine">        carry = u[i] << (32 - shift);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1442</td>
    <td class="codeLine">        carry = u[i] << (32 - shift);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeLine">        DEBUG_KNUTH(dbgs() << " " << r[i]);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1443</td>
    <td class="codeLine">        DEBUG_KNUTH(dbgs() << " " << r[i]);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1444</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1445</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeLine">      for (int i = n-1; i >= 0; i--) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1446</td>
    <td class="codeLine">      for (int i = n-1; i >= 0; i--) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeLine">        r[i] = u[i];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1447</td>
    <td class="codeLine">        r[i] = u[i];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeLine">        DEBUG_KNUTH(dbgs() << " " << r[i]);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1448</td>
    <td class="codeLine">        DEBUG_KNUTH(dbgs() << " " << r[i]);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1449</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1450</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeLine">    DEBUG_KNUTH(dbgs() << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1451</td>
    <td class="codeLine">    DEBUG_KNUTH(dbgs() << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1452</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeLine">  DEBUG_KNUTH(dbgs() << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1453</td>
    <td class="codeLine">  DEBUG_KNUTH(dbgs() << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1454</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1455</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeLine">void APInt::divide(const WordType *LHS, unsigned lhsWords, const WordType *RHS,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1456</td>
    <td class="codeLine">void APInt::divide(const WordType *LHS, unsigned lhsWords, const WordType *RHS,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeLine">                   unsigned rhsWords, WordType *Quotient, WordType *Remainder) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1457</td>
    <td class="codeLine">                   unsigned rhsWords, WordType *Quotient, WordType *Remainder) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeLine">  assert(lhsWords >= rhsWords && "Fractional result");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1458</td>
    <td class="codeLine">  assert(lhsWords >= rhsWords && "Fractional result");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1459</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeLine">  // First, compose the values into an array of 32-bit words instead of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1460</td>
    <td class="codeLine">  // First, compose the values into an array of 32-bit words instead of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeLine">  // 64-bit words. This is a necessity of both the "short division" algorithm</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1461</td>
    <td class="codeLine">  // 64-bit words. This is a necessity of both the "short division" algorithm</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeLine">  // and the Knuth "classical algorithm" which requires there to be native</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1462</td>
    <td class="codeLine">  // and the Knuth "classical algorithm" which requires there to be native</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeLine">  // operations for +, -, and * on an m bit value with an m*2 bit result. We</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1463</td>
    <td class="codeLine">  // operations for +, -, and * on an m bit value with an m*2 bit result. We</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeLine">  // can't use 64-bit operands here because we don't have native results of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1464</td>
    <td class="codeLine">  // can't use 64-bit operands here because we don't have native results of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeLine">  // 128-bits. Furthermore, casting the 64-bit values to 32-bit values won't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1465</td>
    <td class="codeLine">  // 128-bits. Furthermore, casting the 64-bit values to 32-bit values won't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeLine">  // work on large-endian machines.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1466</td>
    <td class="codeLine">  // work on large-endian machines.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeLine">  unsigned n = rhsWords * 2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1467</td>
    <td class="codeLine">  unsigned n = rhsWords * 2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeLine">  unsigned m = (lhsWords * 2) - n;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1468</td>
    <td class="codeLine">  unsigned m = (lhsWords * 2) - n;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1469</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeLine">  // Allocate space for the temporary values we need either on the stack, if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1470</td>
    <td class="codeLine">  // Allocate space for the temporary values we need either on the stack, if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeLine">  // it will fit, or on the heap if it won't.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1471</td>
    <td class="codeLine">  // it will fit, or on the heap if it won't.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeLine">  uint32_t SPACE[128];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1472</td>
    <td class="codeLine">  uint32_t SPACE[128];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeLine">  uint32_t *U = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1473</td>
    <td class="codeLine">  uint32_t *U = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeLine">  uint32_t *V = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1474</td>
    <td class="codeLine">  uint32_t *V = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeLine">  uint32_t *Q = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1475</td>
    <td class="codeLine">  uint32_t *Q = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeLine">  uint32_t *R = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1476</td>
    <td class="codeLine">  uint32_t *R = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeLine">  if ((Remainder?4:3)*n+2*m+1 <= 128) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1477</td>
    <td class="codeLine">  if ((Remainder?4:3)*n+2*m+1 <= 128) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeLine">    U = &SPACE[0];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1478</td>
    <td class="codeLine">    U = &SPACE[0];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeLine">    V = &SPACE[m+n+1];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1479</td>
    <td class="codeLine">    V = &SPACE[m+n+1];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeLine">    Q = &SPACE[(m+n+1) + n];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1480</td>
    <td class="codeLine">    Q = &SPACE[(m+n+1) + n];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeLine">    if (Remainder)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1481</td>
    <td class="codeLine">    if (Remainder)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeLine">      R = &SPACE[(m+n+1) + n + (m+n)];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1482</td>
    <td class="codeLine">      R = &SPACE[(m+n+1) + n + (m+n)];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1483</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeLine">    U = new uint32_t[m + n + 1];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1484</td>
    <td class="codeLine">    U = new uint32_t[m + n + 1];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeLine">    V = new uint32_t[n];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1485</td>
    <td class="codeLine">    V = new uint32_t[n];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeLine">    Q = new uint32_t[m+n];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1486</td>
    <td class="codeLine">    Q = new uint32_t[m+n];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeLine">    if (Remainder)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1487</td>
    <td class="codeLine">    if (Remainder)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeLine">      R = new uint32_t[n];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1488</td>
    <td class="codeLine">      R = new uint32_t[n];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1489</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1490</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeLine">  // Initialize the dividend</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1491</td>
    <td class="codeLine">  // Initialize the dividend</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeLine">  memset(U, 0, (m+n+1)*sizeof(uint32_t));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1492</td>
    <td class="codeLine">  memset(U, 0, (m+n+1)*sizeof(uint32_t));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeLine">  for (unsigned i = 0; i < lhsWords; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1493</td>
    <td class="codeLine">  for (unsigned i = 0; i < lhsWords; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeLine">    uint64_t tmp = LHS[i];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1494</td>
    <td class="codeLine">    uint64_t tmp = LHS[i];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeLine">    U[i * 2] = Lo_32(tmp);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1495</td>
    <td class="codeLine">    U[i * 2] = Lo_32(tmp);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeLine">    U[i * 2 + 1] = Hi_32(tmp);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1496</td>
    <td class="codeLine">    U[i * 2 + 1] = Hi_32(tmp);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1497</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeLine">  U[m+n] = 0; // this extra word is for "spill" in the Knuth algorithm.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1498</td>
    <td class="codeLine">  U[m+n] = 0; // this extra word is for "spill" in the Knuth algorithm.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1499</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeLine">  // Initialize the divisor</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1500</td>
    <td class="codeLine">  // Initialize the divisor</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeLine">  memset(V, 0, (n)*sizeof(uint32_t));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1501</td>
    <td class="codeLine">  memset(V, 0, (n)*sizeof(uint32_t));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeLine">  for (unsigned i = 0; i < rhsWords; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1502</td>
    <td class="codeLine">  for (unsigned i = 0; i < rhsWords; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeLine">    uint64_t tmp = RHS[i];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1503</td>
    <td class="codeLine">    uint64_t tmp = RHS[i];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeLine">    V[i * 2] = Lo_32(tmp);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1504</td>
    <td class="codeLine">    V[i * 2] = Lo_32(tmp);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeLine">    V[i * 2 + 1] = Hi_32(tmp);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1505</td>
    <td class="codeLine">    V[i * 2 + 1] = Hi_32(tmp);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1506</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1507</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeLine">  // initialize the quotient and remainder</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1508</td>
    <td class="codeLine">  // initialize the quotient and remainder</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeLine">  memset(Q, 0, (m+n) * sizeof(uint32_t));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1509</td>
    <td class="codeLine">  memset(Q, 0, (m+n) * sizeof(uint32_t));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeLine">  if (Remainder)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1510</td>
    <td class="codeLine">  if (Remainder)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeLine">    memset(R, 0, n * sizeof(uint32_t));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1511</td>
    <td class="codeLine">    memset(R, 0, n * sizeof(uint32_t));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1512</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeLine">  // Now, adjust m and n for the Knuth division. n is the number of words in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1513</td>
    <td class="codeLine">  // Now, adjust m and n for the Knuth division. n is the number of words in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeLine">  // the divisor. m is the number of words by which the dividend exceeds the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1514</td>
    <td class="codeLine">  // the divisor. m is the number of words by which the dividend exceeds the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeLine">  // divisor (i.e. m+n is the length of the dividend). These sizes must not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1515</td>
    <td class="codeLine">  // divisor (i.e. m+n is the length of the dividend). These sizes must not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeLine">  // contain any zero words or the Knuth algorithm fails.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1516</td>
    <td class="codeLine">  // contain any zero words or the Knuth algorithm fails.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeLine">  for (unsigned i = n; i > 0 && V[i-1] == 0; i--) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1517</td>
    <td class="codeLine">  for (unsigned i = n; i > 0 && V[i-1] == 0; i--) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeLine">    n--;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1518</td>
    <td class="codeLine">    n--;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeLine">    m++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1519</td>
    <td class="codeLine">    m++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1520</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeLine">  for (unsigned i = m+n; i > 0 && U[i-1] == 0; i--)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1521</td>
    <td class="codeLine">  for (unsigned i = m+n; i > 0 && U[i-1] == 0; i--)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeLine">    m--;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1522</td>
    <td class="codeLine">    m--;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1523</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeLine">  // If we're left with only a single word for the divisor, Knuth doesn't work</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1524</td>
    <td class="codeLine">  // If we're left with only a single word for the divisor, Knuth doesn't work</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeLine">  // so we implement the short division algorithm here. This is much simpler</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1525</td>
    <td class="codeLine">  // so we implement the short division algorithm here. This is much simpler</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeLine">  // and faster because we are certain that we can divide a 64-bit quantity</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1526</td>
    <td class="codeLine">  // and faster because we are certain that we can divide a 64-bit quantity</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeLine">  // by a 32-bit quantity at hardware speed and short division is simply a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1527</td>
    <td class="codeLine">  // by a 32-bit quantity at hardware speed and short division is simply a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeLine">  // series of such operations. This is just like doing short division but we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1528</td>
    <td class="codeLine">  // series of such operations. This is just like doing short division but we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeLine">  // are using base 2^32 instead of base 10.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1529</td>
    <td class="codeLine">  // are using base 2^32 instead of base 10.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeLine">  assert(n != 0 && "Divide by zero?");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1530</td>
    <td class="codeLine">  assert(n != 0 && "Divide by zero?");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeLine">  if (n == 1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1531</td>
    <td class="codeLine">  if (n == 1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeLine">    uint32_t divisor = V[0];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1532</td>
    <td class="codeLine">    uint32_t divisor = V[0];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeLine">    uint32_t remainder = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1533</td>
    <td class="codeLine">    uint32_t remainder = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeLine">    for (int i = m; i >= 0; i--) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1534</td>
    <td class="codeLine">    for (int i = m; i >= 0; i--) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeLine">      uint64_t partial_dividend = Make_64(remainder, U[i]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1535</td>
    <td class="codeLine">      uint64_t partial_dividend = Make_64(remainder, U[i]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeLine">      if (partial_dividend == 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1536</td>
    <td class="codeLine">      if (partial_dividend == 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeLine">        Q[i] = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1537</td>
    <td class="codeLine">        Q[i] = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeLine">        remainder = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1538</td>
    <td class="codeLine">        remainder = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeLine">      } else if (partial_dividend < divisor) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1539</td>
    <td class="codeLine">      } else if (partial_dividend < divisor) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeLine">        Q[i] = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1540</td>
    <td class="codeLine">        Q[i] = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeLine">        remainder = Lo_32(partial_dividend);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1541</td>
    <td class="codeLine">        remainder = Lo_32(partial_dividend);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeLine">      } else if (partial_dividend == divisor) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1542</td>
    <td class="codeLine">      } else if (partial_dividend == divisor) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeLine">        Q[i] = 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1543</td>
    <td class="codeLine">        Q[i] = 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeLine">        remainder = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1544</td>
    <td class="codeLine">        remainder = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1545</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeLine">        Q[i] = Lo_32(partial_dividend / divisor);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1546</td>
    <td class="codeLine">        Q[i] = Lo_32(partial_dividend / divisor);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeLine">        remainder = Lo_32(partial_dividend - (Q[i] * divisor));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1547</td>
    <td class="codeLine">        remainder = Lo_32(partial_dividend - (Q[i] * divisor));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1548</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1549</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeLine">    if (R)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1550</td>
    <td class="codeLine">    if (R)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeLine">      R[0] = remainder;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1551</td>
    <td class="codeLine">      R[0] = remainder;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1552</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeLine">    // Now we're ready to invoke the Knuth classical divide algorithm. In this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1553</td>
    <td class="codeLine">    // Now we're ready to invoke the Knuth classical divide algorithm. In this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeLine">    // case n > 1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1554</td>
    <td class="codeLine">    // case n > 1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeLine">    KnuthDiv(U, V, Q, R, m, n);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1555</td>
    <td class="codeLine">    KnuthDiv(U, V, Q, R, m, n);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1556</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1557</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeLine">  // If the caller wants the quotient</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1558</td>
    <td class="codeLine">  // If the caller wants the quotient</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeLine">  if (Quotient) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1559</td>
    <td class="codeLine">  if (Quotient) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeLine">    for (unsigned i = 0; i < lhsWords; ++i)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1560</td>
    <td class="codeLine">    for (unsigned i = 0; i < lhsWords; ++i)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeLine">      Quotient[i] = Make_64(Q[i*2+1], Q[i*2]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1561</td>
    <td class="codeLine">      Quotient[i] = Make_64(Q[i*2+1], Q[i*2]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1562</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1563</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeLine">  // If the caller wants the remainder</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1564</td>
    <td class="codeLine">  // If the caller wants the remainder</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeLine">  if (Remainder) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1565</td>
    <td class="codeLine">  if (Remainder) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeLine">    for (unsigned i = 0; i < rhsWords; ++i)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1566</td>
    <td class="codeLine">    for (unsigned i = 0; i < rhsWords; ++i)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeLine">      Remainder[i] = Make_64(R[i*2+1], R[i*2]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1567</td>
    <td class="codeLine">      Remainder[i] = Make_64(R[i*2+1], R[i*2]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1568</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1569</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeLine">  // Clean up the memory we allocated.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1570</td>
    <td class="codeLine">  // Clean up the memory we allocated.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeLine">  if (U != &SPACE[0]) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1571</td>
    <td class="codeLine">  if (U != &SPACE[0]) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeLine">    delete [] U;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1572</td>
    <td class="codeLine">    delete [] U;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeLine">    delete [] V;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1573</td>
    <td class="codeLine">    delete [] V;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeLine">    delete [] Q;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1574</td>
    <td class="codeLine">    delete [] Q;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeLine">    delete [] R;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1575</td>
    <td class="codeLine">    delete [] R;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1576</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1577</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1578</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeLine">APInt APInt::udiv(const APInt &RHS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1579</td>
    <td class="codeLine">APInt APInt::udiv(const APInt &RHS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeLine">  assert(BitWidth == RHS.BitWidth && "Bit widths must be the same");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1580</td>
    <td class="codeLine">  assert(BitWidth == RHS.BitWidth && "Bit widths must be the same");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1581</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeLine">  // First, deal with the easy case</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1582</td>
    <td class="codeLine">  // First, deal with the easy case</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeLine">  if (isSingleWord()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1583</td>
    <td class="codeLine">  if (isSingleWord()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeLine">    assert(RHS.U.VAL != 0 && "Divide by zero?");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1584</td>
    <td class="codeLine">    assert(RHS.U.VAL != 0 && "Divide by zero?");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeLine">    return APInt(BitWidth, U.VAL / RHS.U.VAL);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1585</td>
    <td class="codeLine">    return APInt(BitWidth, U.VAL / RHS.U.VAL);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1586</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1587</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeLine">  // Get some facts about the LHS and RHS number of bits and words</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1588</td>
    <td class="codeLine">  // Get some facts about the LHS and RHS number of bits and words</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeLine">  unsigned lhsWords = getNumWords(getActiveBits());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1589</td>
    <td class="codeLine">  unsigned lhsWords = getNumWords(getActiveBits());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeLine">  unsigned rhsBits  = RHS.getActiveBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1590</td>
    <td class="codeLine">  unsigned rhsBits  = RHS.getActiveBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeLine">  unsigned rhsWords = getNumWords(rhsBits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1591</td>
    <td class="codeLine">  unsigned rhsWords = getNumWords(rhsBits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeLine">  assert(rhsWords && "Divided by zero???");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1592</td>
    <td class="codeLine">  assert(rhsWords && "Divided by zero???");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1593</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeLine">  // Deal with some degenerate cases</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1594</td>
    <td class="codeLine">  // Deal with some degenerate cases</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeLine">  if (!lhsWords)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1595</td>
    <td class="codeLine">  if (!lhsWords)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeLine">    // 0 / X ===> 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1596</td>
    <td class="codeLine">    // 0 / X ===> 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeLine">    return APInt(BitWidth, 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1597</td>
    <td class="codeLine">    return APInt(BitWidth, 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeLine">  if (rhsBits == 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1598</td>
    <td class="codeLine">  if (rhsBits == 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeLine">    // X / 1 ===> X</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1599</td>
    <td class="codeLine">    // X / 1 ===> X</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeLine">    return *this;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1600</td>
    <td class="codeLine">    return *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeLine">  if (lhsWords < rhsWords || this->ult(RHS))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1601</td>
    <td class="codeLine">  if (lhsWords < rhsWords || this->ult(RHS))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeLine">    // X / Y ===> 0, iff X < Y</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1602</td>
    <td class="codeLine">    // X / Y ===> 0, iff X < Y</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeLine">    return APInt(BitWidth, 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1603</td>
    <td class="codeLine">    return APInt(BitWidth, 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeLine">  if (*this == RHS)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1604</td>
    <td class="codeLine">  if (*this == RHS)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeLine">    // X / X ===> 1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1605</td>
    <td class="codeLine">    // X / X ===> 1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeLine">    return APInt(BitWidth, 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1606</td>
    <td class="codeLine">    return APInt(BitWidth, 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeLine">  if (lhsWords == 1) // rhsWords is 1 if lhsWords is 1.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1607</td>
    <td class="codeLine">  if (lhsWords == 1) // rhsWords is 1 if lhsWords is 1.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeLine">    // All high words are zero, just use native divide</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1608</td>
    <td class="codeLine">    // All high words are zero, just use native divide</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeLine">    return APInt(BitWidth, this->U.pVal[0] / RHS.U.pVal[0]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1609</td>
    <td class="codeLine">    return APInt(BitWidth, this->U.pVal[0] / RHS.U.pVal[0]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1610</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeLine">  // We have to compute it the hard way. Invoke the Knuth divide algorithm.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1611</td>
    <td class="codeLine">  // We have to compute it the hard way. Invoke the Knuth divide algorithm.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeLine">  APInt Quotient(BitWidth, 0); // to hold result.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1612</td>
    <td class="codeLine">  APInt Quotient(BitWidth, 0); // to hold result.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeLine">  divide(U.pVal, lhsWords, RHS.U.pVal, rhsWords, Quotient.U.pVal, nullptr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1613</td>
    <td class="codeLine">  divide(U.pVal, lhsWords, RHS.U.pVal, rhsWords, Quotient.U.pVal, nullptr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeLine">  return Quotient;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1614</td>
    <td class="codeLine">  return Quotient;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1615</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1616</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeLine">APInt APInt::udiv(uint64_t RHS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1617</td>
    <td class="codeLine">APInt APInt::udiv(uint64_t RHS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeLine">  assert(RHS != 0 && "Divide by zero?");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1618</td>
    <td class="codeLine">  assert(RHS != 0 && "Divide by zero?");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1619</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeLine">  // First, deal with the easy case</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1620</td>
    <td class="codeLine">  // First, deal with the easy case</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeLine">  if (isSingleWord())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1621</td>
    <td class="codeLine">  if (isSingleWord())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeLine">    return APInt(BitWidth, U.VAL / RHS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1622</td>
    <td class="codeLine">    return APInt(BitWidth, U.VAL / RHS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1623</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeLine">  // Get some facts about the LHS words.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1624</td>
    <td class="codeLine">  // Get some facts about the LHS words.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeLine">  unsigned lhsWords = getNumWords(getActiveBits());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1625</td>
    <td class="codeLine">  unsigned lhsWords = getNumWords(getActiveBits());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1626</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeLine">  // Deal with some degenerate cases</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1627</td>
    <td class="codeLine">  // Deal with some degenerate cases</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeLine">  if (!lhsWords)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1628</td>
    <td class="codeLine">  if (!lhsWords)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeLine">    // 0 / X ===> 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1629</td>
    <td class="codeLine">    // 0 / X ===> 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeLine">    return APInt(BitWidth, 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1630</td>
    <td class="codeLine">    return APInt(BitWidth, 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeLine">  if (RHS == 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1631</td>
    <td class="codeLine">  if (RHS == 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeLine">    // X / 1 ===> X</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1632</td>
    <td class="codeLine">    // X / 1 ===> X</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeLine">    return *this;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1633</td>
    <td class="codeLine">    return *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeLine">  if (this->ult(RHS))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1634</td>
    <td class="codeLine">  if (this->ult(RHS))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeLine">    // X / Y ===> 0, iff X < Y</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1635</td>
    <td class="codeLine">    // X / Y ===> 0, iff X < Y</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeLine">    return APInt(BitWidth, 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1636</td>
    <td class="codeLine">    return APInt(BitWidth, 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeLine">  if (*this == RHS)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1637</td>
    <td class="codeLine">  if (*this == RHS)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeLine">    // X / X ===> 1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1638</td>
    <td class="codeLine">    // X / X ===> 1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeLine">    return APInt(BitWidth, 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1639</td>
    <td class="codeLine">    return APInt(BitWidth, 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeLine">  if (lhsWords == 1) // rhsWords is 1 if lhsWords is 1.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1640</td>
    <td class="codeLine">  if (lhsWords == 1) // rhsWords is 1 if lhsWords is 1.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeLine">    // All high words are zero, just use native divide</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1641</td>
    <td class="codeLine">    // All high words are zero, just use native divide</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeLine">    return APInt(BitWidth, this->U.pVal[0] / RHS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1642</td>
    <td class="codeLine">    return APInt(BitWidth, this->U.pVal[0] / RHS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1643</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeLine">  // We have to compute it the hard way. Invoke the Knuth divide algorithm.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1644</td>
    <td class="codeLine">  // We have to compute it the hard way. Invoke the Knuth divide algorithm.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeLine">  APInt Quotient(BitWidth, 0); // to hold result.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1645</td>
    <td class="codeLine">  APInt Quotient(BitWidth, 0); // to hold result.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeLine">  divide(U.pVal, lhsWords, &RHS, 1, Quotient.U.pVal, nullptr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1646</td>
    <td class="codeLine">  divide(U.pVal, lhsWords, &RHS, 1, Quotient.U.pVal, nullptr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeLine">  return Quotient;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1647</td>
    <td class="codeLine">  return Quotient;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1648</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1649</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeLine">APInt APInt::sdiv(const APInt &RHS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1650</td>
    <td class="codeLine">APInt APInt::sdiv(const APInt &RHS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeLine">  if (isNegative()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1651</td>
    <td class="codeLine">  if (isNegative()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeLine">    if (RHS.isNegative())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1652</td>
    <td class="codeLine">    if (RHS.isNegative())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeLine">      return (-(*this)).udiv(-RHS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1653</td>
    <td class="codeLine">      return (-(*this)).udiv(-RHS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeLine">    return -((-(*this)).udiv(RHS));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1654</td>
    <td class="codeLine">    return -((-(*this)).udiv(RHS));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1655</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeLine">  if (RHS.isNegative())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1656</td>
    <td class="codeLine">  if (RHS.isNegative())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeLine">    return -(this->udiv(-RHS));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1657</td>
    <td class="codeLine">    return -(this->udiv(-RHS));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeLine">  return this->udiv(RHS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1658</td>
    <td class="codeLine">  return this->udiv(RHS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1659</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1660</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeLine">APInt APInt::sdiv(int64_t RHS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1661</td>
    <td class="codeLine">APInt APInt::sdiv(int64_t RHS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeLine">  if (isNegative()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1662</td>
    <td class="codeLine">  if (isNegative()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeLine">    if (RHS < 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1663</td>
    <td class="codeLine">    if (RHS < 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeLine">      return (-(*this)).udiv(-RHS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1664</td>
    <td class="codeLine">      return (-(*this)).udiv(-RHS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeLine">    return -((-(*this)).udiv(RHS));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1665</td>
    <td class="codeLine">    return -((-(*this)).udiv(RHS));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1666</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeLine">  if (RHS < 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1667</td>
    <td class="codeLine">  if (RHS < 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeLine">    return -(this->udiv(-RHS));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1668</td>
    <td class="codeLine">    return -(this->udiv(-RHS));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeLine">  return this->udiv(RHS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1669</td>
    <td class="codeLine">  return this->udiv(RHS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1670</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1671</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeLine">APInt APInt::urem(const APInt &RHS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1672</td>
    <td class="codeLine">APInt APInt::urem(const APInt &RHS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeLine">  assert(BitWidth == RHS.BitWidth && "Bit widths must be the same");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1673</td>
    <td class="codeLine">  assert(BitWidth == RHS.BitWidth && "Bit widths must be the same");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeLine">  if (isSingleWord()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1674</td>
    <td class="codeLine">  if (isSingleWord()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeLine">    assert(RHS.U.VAL != 0 && "Remainder by zero?");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1675</td>
    <td class="codeLine">    assert(RHS.U.VAL != 0 && "Remainder by zero?");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeLine">    return APInt(BitWidth, U.VAL % RHS.U.VAL);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1676</td>
    <td class="codeLine">    return APInt(BitWidth, U.VAL % RHS.U.VAL);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1677</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1678</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeLine">  // Get some facts about the LHS</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1679</td>
    <td class="codeLine">  // Get some facts about the LHS</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeLine">  unsigned lhsWords = getNumWords(getActiveBits());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1680</td>
    <td class="codeLine">  unsigned lhsWords = getNumWords(getActiveBits());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1681</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeLine">  // Get some facts about the RHS</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1682</td>
    <td class="codeLine">  // Get some facts about the RHS</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeLine">  unsigned rhsBits = RHS.getActiveBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1683</td>
    <td class="codeLine">  unsigned rhsBits = RHS.getActiveBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeLine">  unsigned rhsWords = getNumWords(rhsBits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1684</td>
    <td class="codeLine">  unsigned rhsWords = getNumWords(rhsBits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeLine">  assert(rhsWords && "Performing remainder operation by zero ???");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1685</td>
    <td class="codeLine">  assert(rhsWords && "Performing remainder operation by zero ???");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1686</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeLine">  // Check the degenerate cases</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1687</td>
    <td class="codeLine">  // Check the degenerate cases</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeLine">  if (lhsWords == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1688</td>
    <td class="codeLine">  if (lhsWords == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeLine">    // 0 % Y ===> 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1689</td>
    <td class="codeLine">    // 0 % Y ===> 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeLine">    return APInt(BitWidth, 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1690</td>
    <td class="codeLine">    return APInt(BitWidth, 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeLine">  if (rhsBits == 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1691</td>
    <td class="codeLine">  if (rhsBits == 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeLine">    // X % 1 ===> 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1692</td>
    <td class="codeLine">    // X % 1 ===> 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeLine">    return APInt(BitWidth, 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1693</td>
    <td class="codeLine">    return APInt(BitWidth, 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeLine">  if (lhsWords < rhsWords || this->ult(RHS))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1694</td>
    <td class="codeLine">  if (lhsWords < rhsWords || this->ult(RHS))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeLine">    // X % Y ===> X, iff X < Y</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1695</td>
    <td class="codeLine">    // X % Y ===> X, iff X < Y</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeLine">    return *this;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1696</td>
    <td class="codeLine">    return *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeLine">  if (*this == RHS)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1697</td>
    <td class="codeLine">  if (*this == RHS)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeLine">    // X % X == 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1698</td>
    <td class="codeLine">    // X % X == 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeLine">    return APInt(BitWidth, 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1699</td>
    <td class="codeLine">    return APInt(BitWidth, 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeLine">  if (lhsWords == 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1700</td>
    <td class="codeLine">  if (lhsWords == 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeLine">    // All high words are zero, just use native remainder</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1701</td>
    <td class="codeLine">    // All high words are zero, just use native remainder</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeLine">    return APInt(BitWidth, U.pVal[0] % RHS.U.pVal[0]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1702</td>
    <td class="codeLine">    return APInt(BitWidth, U.pVal[0] % RHS.U.pVal[0]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1703</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeLine">  // We have to compute it the hard way. Invoke the Knuth divide algorithm.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1704</td>
    <td class="codeLine">  // We have to compute it the hard way. Invoke the Knuth divide algorithm.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeLine">  APInt Remainder(BitWidth, 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1705</td>
    <td class="codeLine">  APInt Remainder(BitWidth, 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeLine">  divide(U.pVal, lhsWords, RHS.U.pVal, rhsWords, nullptr, Remainder.U.pVal);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1706</td>
    <td class="codeLine">  divide(U.pVal, lhsWords, RHS.U.pVal, rhsWords, nullptr, Remainder.U.pVal);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeLine">  return Remainder;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1707</td>
    <td class="codeLine">  return Remainder;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1708</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1709</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeLine">uint64_t APInt::urem(uint64_t RHS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1710</td>
    <td class="codeLine">uint64_t APInt::urem(uint64_t RHS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeLine">  assert(RHS != 0 && "Remainder by zero?");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1711</td>
    <td class="codeLine">  assert(RHS != 0 && "Remainder by zero?");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1712</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeLine">  if (isSingleWord())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1713</td>
    <td class="codeLine">  if (isSingleWord())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeLine">    return U.VAL % RHS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1714</td>
    <td class="codeLine">    return U.VAL % RHS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1715</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeLine">  // Get some facts about the LHS</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1716</td>
    <td class="codeLine">  // Get some facts about the LHS</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeLine">  unsigned lhsWords = getNumWords(getActiveBits());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1717</td>
    <td class="codeLine">  unsigned lhsWords = getNumWords(getActiveBits());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1718</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeLine">  // Check the degenerate cases</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1719</td>
    <td class="codeLine">  // Check the degenerate cases</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeLine">  if (lhsWords == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1720</td>
    <td class="codeLine">  if (lhsWords == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeLine">    // 0 % Y ===> 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1721</td>
    <td class="codeLine">    // 0 % Y ===> 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1722</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeLine">  if (RHS == 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1723</td>
    <td class="codeLine">  if (RHS == 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeLine">    // X % 1 ===> 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1724</td>
    <td class="codeLine">    // X % 1 ===> 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1725</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeLine">  if (this->ult(RHS))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1726</td>
    <td class="codeLine">  if (this->ult(RHS))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeLine">    // X % Y ===> X, iff X < Y</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1727</td>
    <td class="codeLine">    // X % Y ===> X, iff X < Y</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeLine">    return getZExtValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1728</td>
    <td class="codeLine">    return getZExtValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeLine">  if (*this == RHS)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1729</td>
    <td class="codeLine">  if (*this == RHS)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeLine">    // X % X == 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1730</td>
    <td class="codeLine">    // X % X == 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1731</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeLine">  if (lhsWords == 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1732</td>
    <td class="codeLine">  if (lhsWords == 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeLine">    // All high words are zero, just use native remainder</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1733</td>
    <td class="codeLine">    // All high words are zero, just use native remainder</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeLine">    return U.pVal[0] % RHS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1734</td>
    <td class="codeLine">    return U.pVal[0] % RHS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1735</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeLine">  // We have to compute it the hard way. Invoke the Knuth divide algorithm.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1736</td>
    <td class="codeLine">  // We have to compute it the hard way. Invoke the Knuth divide algorithm.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeLine">  uint64_t Remainder;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1737</td>
    <td class="codeLine">  uint64_t Remainder;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeLine">  divide(U.pVal, lhsWords, &RHS, 1, nullptr, &Remainder);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1738</td>
    <td class="codeLine">  divide(U.pVal, lhsWords, &RHS, 1, nullptr, &Remainder);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeLine">  return Remainder;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1739</td>
    <td class="codeLine">  return Remainder;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1740</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1741</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeLine">APInt APInt::srem(const APInt &RHS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1742</td>
    <td class="codeLine">APInt APInt::srem(const APInt &RHS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeLine">  if (isNegative()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1743</td>
    <td class="codeLine">  if (isNegative()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeLine">    if (RHS.isNegative())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1744</td>
    <td class="codeLine">    if (RHS.isNegative())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeLine">      return -((-(*this)).urem(-RHS));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1745</td>
    <td class="codeLine">      return -((-(*this)).urem(-RHS));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeLine">    return -((-(*this)).urem(RHS));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1746</td>
    <td class="codeLine">    return -((-(*this)).urem(RHS));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1747</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeLine">  if (RHS.isNegative())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1748</td>
    <td class="codeLine">  if (RHS.isNegative())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeLine">    return this->urem(-RHS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1749</td>
    <td class="codeLine">    return this->urem(-RHS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeLine">  return this->urem(RHS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1750</td>
    <td class="codeLine">  return this->urem(RHS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1751</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1752</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeLine">int64_t APInt::srem(int64_t RHS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1753</td>
    <td class="codeLine">int64_t APInt::srem(int64_t RHS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeLine">  if (isNegative()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1754</td>
    <td class="codeLine">  if (isNegative()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeLine">    if (RHS < 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1755</td>
    <td class="codeLine">    if (RHS < 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeLine">      return -((-(*this)).urem(-RHS));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1756</td>
    <td class="codeLine">      return -((-(*this)).urem(-RHS));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeLine">    return -((-(*this)).urem(RHS));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1757</td>
    <td class="codeLine">    return -((-(*this)).urem(RHS));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1758</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeLine">  if (RHS < 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1759</td>
    <td class="codeLine">  if (RHS < 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeLine">    return this->urem(-RHS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1760</td>
    <td class="codeLine">    return this->urem(-RHS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeLine">  return this->urem(RHS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1761</td>
    <td class="codeLine">  return this->urem(RHS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1762</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1763</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeLine">void APInt::udivrem(const APInt &LHS, const APInt &RHS,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1764</td>
    <td class="codeLine">void APInt::udivrem(const APInt &LHS, const APInt &RHS,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeLine">                    APInt &Quotient, APInt &Remainder) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1765</td>
    <td class="codeLine">                    APInt &Quotient, APInt &Remainder) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeLine">  assert(LHS.BitWidth == RHS.BitWidth && "Bit widths must be the same");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1766</td>
    <td class="codeLine">  assert(LHS.BitWidth == RHS.BitWidth && "Bit widths must be the same");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeLine">  unsigned BitWidth = LHS.BitWidth;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1767</td>
    <td class="codeLine">  unsigned BitWidth = LHS.BitWidth;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1768</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeLine">  // First, deal with the easy case</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1769</td>
    <td class="codeLine">  // First, deal with the easy case</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeLine">  if (LHS.isSingleWord()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1770</td>
    <td class="codeLine">  if (LHS.isSingleWord()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeLine">    assert(RHS.U.VAL != 0 && "Divide by zero?");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1771</td>
    <td class="codeLine">    assert(RHS.U.VAL != 0 && "Divide by zero?");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeLine">    uint64_t QuotVal = LHS.U.VAL / RHS.U.VAL;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1772</td>
    <td class="codeLine">    uint64_t QuotVal = LHS.U.VAL / RHS.U.VAL;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeLine">    uint64_t RemVal = LHS.U.VAL % RHS.U.VAL;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1773</td>
    <td class="codeLine">    uint64_t RemVal = LHS.U.VAL % RHS.U.VAL;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeLine">    Quotient = APInt(BitWidth, QuotVal);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1774</td>
    <td class="codeLine">    Quotient = APInt(BitWidth, QuotVal);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeLine">    Remainder = APInt(BitWidth, RemVal);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1775</td>
    <td class="codeLine">    Remainder = APInt(BitWidth, RemVal);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1776</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1777</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1778</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeLine">  // Get some size facts about the dividend and divisor</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1779</td>
    <td class="codeLine">  // Get some size facts about the dividend and divisor</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeLine">  unsigned lhsWords = getNumWords(LHS.getActiveBits());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1780</td>
    <td class="codeLine">  unsigned lhsWords = getNumWords(LHS.getActiveBits());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeLine">  unsigned rhsBits  = RHS.getActiveBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1781</td>
    <td class="codeLine">  unsigned rhsBits  = RHS.getActiveBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeLine">  unsigned rhsWords = getNumWords(rhsBits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1782</td>
    <td class="codeLine">  unsigned rhsWords = getNumWords(rhsBits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeLine">  assert(rhsWords && "Performing divrem operation by zero ???");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1783</td>
    <td class="codeLine">  assert(rhsWords && "Performing divrem operation by zero ???");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1784</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeLine">  // Check the degenerate cases</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1785</td>
    <td class="codeLine">  // Check the degenerate cases</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeLine">  if (lhsWords == 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1786</td>
    <td class="codeLine">  if (lhsWords == 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeLine">    Quotient = APInt(BitWidth, 0);    // 0 / Y ===> 0</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1787</td>
    <td class="codeLine">    Quotient = APInt(BitWidth, 0);    // 0 / Y ===> 0</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeLine">    Remainder = APInt(BitWidth, 0);   // 0 % Y ===> 0</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1788</td>
    <td class="codeLine">    Remainder = APInt(BitWidth, 0);   // 0 % Y ===> 0</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1789</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1790</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1791</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeLine">  if (rhsBits == 1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1792</td>
    <td class="codeLine">  if (rhsBits == 1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="codeLine">    Quotient = LHS;                   // X / 1 ===> X</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1793</td>
    <td class="codeLine">    Quotient = LHS;                   // X / 1 ===> X</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="codeLine">    Remainder = APInt(BitWidth, 0);   // X % 1 ===> 0</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1794</td>
    <td class="codeLine">    Remainder = APInt(BitWidth, 0);   // X % 1 ===> 0</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1795</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1796</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="codeLine">  if (lhsWords < rhsWords || LHS.ult(RHS)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1797</td>
    <td class="codeLine">  if (lhsWords < rhsWords || LHS.ult(RHS)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="codeLine">    Remainder = LHS;                  // X % Y ===> X, iff X < Y</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1798</td>
    <td class="codeLine">    Remainder = LHS;                  // X % Y ===> X, iff X < Y</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="codeLine">    Quotient = APInt(BitWidth, 0);    // X / Y ===> 0, iff X < Y</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1799</td>
    <td class="codeLine">    Quotient = APInt(BitWidth, 0);    // X / Y ===> 0, iff X < Y</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1800</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1801</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1802</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="codeLine">  if (LHS == RHS) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1803</td>
    <td class="codeLine">  if (LHS == RHS) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="codeLine">    Quotient  = APInt(BitWidth, 1);   // X / X ===> 1</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1804</td>
    <td class="codeLine">    Quotient  = APInt(BitWidth, 1);   // X / X ===> 1</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="codeLine">    Remainder = APInt(BitWidth, 0);   // X % X ===> 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1805</td>
    <td class="codeLine">    Remainder = APInt(BitWidth, 0);   // X % X ===> 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1806</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1807</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1808</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="codeLine">  // Make sure there is enough space to hold the results.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1809</td>
    <td class="codeLine">  // Make sure there is enough space to hold the results.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="codeLine">  // NOTE: This assumes that reallocate won't affect any bits if it doesn't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1810</td>
    <td class="codeLine">  // NOTE: This assumes that reallocate won't affect any bits if it doesn't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="codeLine">  // change the size. This is necessary if Quotient or Remainder is aliased</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1811</td>
    <td class="codeLine">  // change the size. This is necessary if Quotient or Remainder is aliased</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="codeLine">  // with LHS or RHS.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1812</td>
    <td class="codeLine">  // with LHS or RHS.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="codeLine">  Quotient.reallocate(BitWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1813</td>
    <td class="codeLine">  Quotient.reallocate(BitWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="codeLine">  Remainder.reallocate(BitWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1814</td>
    <td class="codeLine">  Remainder.reallocate(BitWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1815</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="codeLine">  if (lhsWords == 1) { // rhsWords is 1 if lhsWords is 1.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1816</td>
    <td class="codeLine">  if (lhsWords == 1) { // rhsWords is 1 if lhsWords is 1.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="codeLine">    // There is only one word to consider so use the native versions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1817</td>
    <td class="codeLine">    // There is only one word to consider so use the native versions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="codeLine">    uint64_t lhsValue = LHS.U.pVal[0];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1818</td>
    <td class="codeLine">    uint64_t lhsValue = LHS.U.pVal[0];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="codeLine">    uint64_t rhsValue = RHS.U.pVal[0];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1819</td>
    <td class="codeLine">    uint64_t rhsValue = RHS.U.pVal[0];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="codeLine">    Quotient = lhsValue / rhsValue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1820</td>
    <td class="codeLine">    Quotient = lhsValue / rhsValue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="codeLine">    Remainder = lhsValue % rhsValue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1821</td>
    <td class="codeLine">    Remainder = lhsValue % rhsValue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1822</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1823</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1824</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="codeLine">  // Okay, lets do it the long way</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1825</td>
    <td class="codeLine">  // Okay, lets do it the long way</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="codeLine">  divide(LHS.U.pVal, lhsWords, RHS.U.pVal, rhsWords, Quotient.U.pVal,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1826</td>
    <td class="codeLine">  divide(LHS.U.pVal, lhsWords, RHS.U.pVal, rhsWords, Quotient.U.pVal,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="codeLine">         Remainder.U.pVal);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1827</td>
    <td class="codeLine">         Remainder.U.pVal);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="codeLine">  // Clear the rest of the Quotient and Remainder.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1828</td>
    <td class="codeLine">  // Clear the rest of the Quotient and Remainder.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="codeLine">  std::memset(Quotient.U.pVal + lhsWords, 0,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1829</td>
    <td class="codeLine">  std::memset(Quotient.U.pVal + lhsWords, 0,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="codeLine">              (getNumWords(BitWidth) - lhsWords) * APINT_WORD_SIZE);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1830</td>
    <td class="codeLine">              (getNumWords(BitWidth) - lhsWords) * APINT_WORD_SIZE);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="codeLine">  std::memset(Remainder.U.pVal + rhsWords, 0,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1831</td>
    <td class="codeLine">  std::memset(Remainder.U.pVal + rhsWords, 0,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="codeLine">              (getNumWords(BitWidth) - rhsWords) * APINT_WORD_SIZE);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1832</td>
    <td class="codeLine">              (getNumWords(BitWidth) - rhsWords) * APINT_WORD_SIZE);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1833</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1834</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="codeLine">void APInt::udivrem(const APInt &LHS, uint64_t RHS, APInt &Quotient,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1835</td>
    <td class="codeLine">void APInt::udivrem(const APInt &LHS, uint64_t RHS, APInt &Quotient,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="codeLine">                    uint64_t &Remainder) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1836</td>
    <td class="codeLine">                    uint64_t &Remainder) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="codeLine">  assert(RHS != 0 && "Divide by zero?");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1837</td>
    <td class="codeLine">  assert(RHS != 0 && "Divide by zero?");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="codeLine">  unsigned BitWidth = LHS.BitWidth;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1838</td>
    <td class="codeLine">  unsigned BitWidth = LHS.BitWidth;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1839</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="codeLine">  // First, deal with the easy case</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1840</td>
    <td class="codeLine">  // First, deal with the easy case</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="codeLine">  if (LHS.isSingleWord()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1841</td>
    <td class="codeLine">  if (LHS.isSingleWord()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="codeLine">    uint64_t QuotVal = LHS.U.VAL / RHS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1842</td>
    <td class="codeLine">    uint64_t QuotVal = LHS.U.VAL / RHS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="codeLine">    Remainder = LHS.U.VAL % RHS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1843</td>
    <td class="codeLine">    Remainder = LHS.U.VAL % RHS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="codeLine">    Quotient = APInt(BitWidth, QuotVal);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1844</td>
    <td class="codeLine">    Quotient = APInt(BitWidth, QuotVal);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1845</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1846</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1847</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="codeLine">  // Get some size facts about the dividend and divisor</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1848</td>
    <td class="codeLine">  // Get some size facts about the dividend and divisor</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="codeLine">  unsigned lhsWords = getNumWords(LHS.getActiveBits());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1849</td>
    <td class="codeLine">  unsigned lhsWords = getNumWords(LHS.getActiveBits());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1850</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="codeLine">  // Check the degenerate cases</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1851</td>
    <td class="codeLine">  // Check the degenerate cases</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="codeLine">  if (lhsWords == 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1852</td>
    <td class="codeLine">  if (lhsWords == 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="codeLine">    Quotient = APInt(BitWidth, 0);    // 0 / Y ===> 0</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1853</td>
    <td class="codeLine">    Quotient = APInt(BitWidth, 0);    // 0 / Y ===> 0</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="codeLine">    Remainder = 0;                    // 0 % Y ===> 0</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1854</td>
    <td class="codeLine">    Remainder = 0;                    // 0 % Y ===> 0</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1855</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1856</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1857</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="codeLine">  if (RHS == 1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1858</td>
    <td class="codeLine">  if (RHS == 1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="codeLine">    Quotient = LHS;                   // X / 1 ===> X</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1859</td>
    <td class="codeLine">    Quotient = LHS;                   // X / 1 ===> X</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="codeLine">    Remainder = 0;                    // X % 1 ===> 0</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1860</td>
    <td class="codeLine">    Remainder = 0;                    // X % 1 ===> 0</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1861</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1862</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1863</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="codeLine">  if (LHS.ult(RHS)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1864</td>
    <td class="codeLine">  if (LHS.ult(RHS)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="codeLine">    Remainder = LHS.getZExtValue();   // X % Y ===> X, iff X < Y</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1865</td>
    <td class="codeLine">    Remainder = LHS.getZExtValue();   // X % Y ===> X, iff X < Y</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="codeLine">    Quotient = APInt(BitWidth, 0);    // X / Y ===> 0, iff X < Y</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1866</td>
    <td class="codeLine">    Quotient = APInt(BitWidth, 0);    // X / Y ===> 0, iff X < Y</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1867</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1868</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1869</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="codeLine">  if (LHS == RHS) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1870</td>
    <td class="codeLine">  if (LHS == RHS) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="codeLine">    Quotient  = APInt(BitWidth, 1);   // X / X ===> 1</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1871</td>
    <td class="codeLine">    Quotient  = APInt(BitWidth, 1);   // X / X ===> 1</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="codeLine">    Remainder = 0;                    // X % X ===> 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1872</td>
    <td class="codeLine">    Remainder = 0;                    // X % X ===> 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1873</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1874</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1875</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="codeLine">  // Make sure there is enough space to hold the results.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1876</td>
    <td class="codeLine">  // Make sure there is enough space to hold the results.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="codeLine">  // NOTE: This assumes that reallocate won't affect any bits if it doesn't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1877</td>
    <td class="codeLine">  // NOTE: This assumes that reallocate won't affect any bits if it doesn't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="codeLine">  // change the size. This is necessary if Quotient is aliased with LHS.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1878</td>
    <td class="codeLine">  // change the size. This is necessary if Quotient is aliased with LHS.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="codeLine">  Quotient.reallocate(BitWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1879</td>
    <td class="codeLine">  Quotient.reallocate(BitWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1880</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="codeLine">  if (lhsWords == 1) { // rhsWords is 1 if lhsWords is 1.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1881</td>
    <td class="codeLine">  if (lhsWords == 1) { // rhsWords is 1 if lhsWords is 1.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="codeLine">    // There is only one word to consider so use the native versions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1882</td>
    <td class="codeLine">    // There is only one word to consider so use the native versions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="codeLine">    uint64_t lhsValue = LHS.U.pVal[0];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1883</td>
    <td class="codeLine">    uint64_t lhsValue = LHS.U.pVal[0];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="codeLine">    Quotient = lhsValue / RHS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1884</td>
    <td class="codeLine">    Quotient = lhsValue / RHS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="codeLine">    Remainder = lhsValue % RHS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1885</td>
    <td class="codeLine">    Remainder = lhsValue % RHS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1886</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1887</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1888</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="codeLine">  // Okay, lets do it the long way</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1889</td>
    <td class="codeLine">  // Okay, lets do it the long way</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="codeLine">  divide(LHS.U.pVal, lhsWords, &RHS, 1, Quotient.U.pVal, &Remainder);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1890</td>
    <td class="codeLine">  divide(LHS.U.pVal, lhsWords, &RHS, 1, Quotient.U.pVal, &Remainder);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="codeLine">  // Clear the rest of the Quotient.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1891</td>
    <td class="codeLine">  // Clear the rest of the Quotient.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="codeLine">  std::memset(Quotient.U.pVal + lhsWords, 0,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1892</td>
    <td class="codeLine">  std::memset(Quotient.U.pVal + lhsWords, 0,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="codeLine">              (getNumWords(BitWidth) - lhsWords) * APINT_WORD_SIZE);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1893</td>
    <td class="codeLine">              (getNumWords(BitWidth) - lhsWords) * APINT_WORD_SIZE);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1894</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1895</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="codeLine">void APInt::sdivrem(const APInt &LHS, const APInt &RHS,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1896</td>
    <td class="codeLine">void APInt::sdivrem(const APInt &LHS, const APInt &RHS,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="codeLine">                    APInt &Quotient, APInt &Remainder) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1897</td>
    <td class="codeLine">                    APInt &Quotient, APInt &Remainder) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="codeLine">  if (LHS.isNegative()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1898</td>
    <td class="codeLine">  if (LHS.isNegative()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="codeLine">    if (RHS.isNegative())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1899</td>
    <td class="codeLine">    if (RHS.isNegative())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="codeLine">      APInt::udivrem(-LHS, -RHS, Quotient, Remainder);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1900</td>
    <td class="codeLine">      APInt::udivrem(-LHS, -RHS, Quotient, Remainder);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="codeLine">    else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1901</td>
    <td class="codeLine">    else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="codeLine">      APInt::udivrem(-LHS, RHS, Quotient, Remainder);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1902</td>
    <td class="codeLine">      APInt::udivrem(-LHS, RHS, Quotient, Remainder);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="codeLine">      Quotient.negate();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1903</td>
    <td class="codeLine">      Quotient.negate();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1904</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="codeLine">    Remainder.negate();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1905</td>
    <td class="codeLine">    Remainder.negate();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="codeLine">  } else if (RHS.isNegative()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1906</td>
    <td class="codeLine">  } else if (RHS.isNegative()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="codeLine">    APInt::udivrem(LHS, -RHS, Quotient, Remainder);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1907</td>
    <td class="codeLine">    APInt::udivrem(LHS, -RHS, Quotient, Remainder);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="codeLine">    Quotient.negate();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1908</td>
    <td class="codeLine">    Quotient.negate();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1909</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="codeLine">    APInt::udivrem(LHS, RHS, Quotient, Remainder);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1910</td>
    <td class="codeLine">    APInt::udivrem(LHS, RHS, Quotient, Remainder);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1911</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1912</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1913</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="codeLine">void APInt::sdivrem(const APInt &LHS, int64_t RHS,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1914</td>
    <td class="codeLine">void APInt::sdivrem(const APInt &LHS, int64_t RHS,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="codeLine">                    APInt &Quotient, int64_t &Remainder) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1915</td>
    <td class="codeLine">                    APInt &Quotient, int64_t &Remainder) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="codeLine">  uint64_t R = Remainder;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1916</td>
    <td class="codeLine">  uint64_t R = Remainder;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="codeLine">  if (LHS.isNegative()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1917</td>
    <td class="codeLine">  if (LHS.isNegative()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="codeLine">    if (RHS < 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1918</td>
    <td class="codeLine">    if (RHS < 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="codeLine">      APInt::udivrem(-LHS, -RHS, Quotient, R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1919</td>
    <td class="codeLine">      APInt::udivrem(-LHS, -RHS, Quotient, R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="codeLine">    else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1920</td>
    <td class="codeLine">    else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="codeLine">      APInt::udivrem(-LHS, RHS, Quotient, R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1921</td>
    <td class="codeLine">      APInt::udivrem(-LHS, RHS, Quotient, R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="codeLine">      Quotient.negate();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1922</td>
    <td class="codeLine">      Quotient.negate();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1923</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="codeLine">    R = -R;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1924</td>
    <td class="codeLine">    R = -R;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="codeLine">  } else if (RHS < 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1925</td>
    <td class="codeLine">  } else if (RHS < 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="codeLine">    APInt::udivrem(LHS, -RHS, Quotient, R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1926</td>
    <td class="codeLine">    APInt::udivrem(LHS, -RHS, Quotient, R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="codeLine">    Quotient.negate();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1927</td>
    <td class="codeLine">    Quotient.negate();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1928</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="codeLine">    APInt::udivrem(LHS, RHS, Quotient, R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1929</td>
    <td class="codeLine">    APInt::udivrem(LHS, RHS, Quotient, R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1930</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="codeLine">  Remainder = R;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1931</td>
    <td class="codeLine">  Remainder = R;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1932</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1933</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="codeLine">APInt APInt::sadd_ov(const APInt &RHS, bool &Overflow) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1934</td>
    <td class="codeLine">APInt APInt::sadd_ov(const APInt &RHS, bool &Overflow) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="codeLine">  APInt Res = *this+RHS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1935</td>
    <td class="codeLine">  APInt Res = *this+RHS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="codeLine">  Overflow = isNonNegative() == RHS.isNonNegative() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1936</td>
    <td class="codeLine">  Overflow = isNonNegative() == RHS.isNonNegative() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="codeLine">             Res.isNonNegative() != isNonNegative();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1937</td>
    <td class="codeLine">             Res.isNonNegative() != isNonNegative();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="codeLine">  return Res;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1938</td>
    <td class="codeLine">  return Res;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1939</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1940</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="codeLine">APInt APInt::uadd_ov(const APInt &RHS, bool &Overflow) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1941</td>
    <td class="codeLine">APInt APInt::uadd_ov(const APInt &RHS, bool &Overflow) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="codeLine">  APInt Res = *this+RHS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1942</td>
    <td class="codeLine">  APInt Res = *this+RHS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="codeLine">  Overflow = Res.ult(RHS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1943</td>
    <td class="codeLine">  Overflow = Res.ult(RHS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="codeLine">  return Res;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1944</td>
    <td class="codeLine">  return Res;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1945</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1946</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="codeLine">APInt APInt::ssub_ov(const APInt &RHS, bool &Overflow) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1947</td>
    <td class="codeLine">APInt APInt::ssub_ov(const APInt &RHS, bool &Overflow) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="codeLine">  APInt Res = *this - RHS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1948</td>
    <td class="codeLine">  APInt Res = *this - RHS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="codeLine">  Overflow = isNonNegative() != RHS.isNonNegative() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1949</td>
    <td class="codeLine">  Overflow = isNonNegative() != RHS.isNonNegative() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="codeLine">             Res.isNonNegative() != isNonNegative();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1950</td>
    <td class="codeLine">             Res.isNonNegative() != isNonNegative();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="codeLine">  return Res;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1951</td>
    <td class="codeLine">  return Res;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1952</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1953</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="codeLine">APInt APInt::usub_ov(const APInt &RHS, bool &Overflow) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1954</td>
    <td class="codeLine">APInt APInt::usub_ov(const APInt &RHS, bool &Overflow) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="codeLine">  APInt Res = *this-RHS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1955</td>
    <td class="codeLine">  APInt Res = *this-RHS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="codeLine">  Overflow = Res.ugt(*this);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1956</td>
    <td class="codeLine">  Overflow = Res.ugt(*this);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="codeLine">  return Res;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1957</td>
    <td class="codeLine">  return Res;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1958</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1959</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="codeLine">APInt APInt::sdiv_ov(const APInt &RHS, bool &Overflow) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1960</td>
    <td class="codeLine">APInt APInt::sdiv_ov(const APInt &RHS, bool &Overflow) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="codeLine">  // MININT/-1  -->  overflow.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1961</td>
    <td class="codeLine">  // MININT/-1  -->  overflow.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="codeLine">  Overflow = isMinSignedValue() && RHS.isAllOnes();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1962</td>
    <td class="codeLine">  Overflow = isMinSignedValue() && RHS.isAllOnes();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="codeLine">  return sdiv(RHS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1963</td>
    <td class="codeLine">  return sdiv(RHS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1964</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1965</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="codeLine">APInt APInt::smul_ov(const APInt &RHS, bool &Overflow) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1966</td>
    <td class="codeLine">APInt APInt::smul_ov(const APInt &RHS, bool &Overflow) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="codeLine">  APInt Res = *this * RHS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1967</td>
    <td class="codeLine">  APInt Res = *this * RHS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1968</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="codeLine">  if (RHS != 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1969</td>
    <td class="codeLine">  if (RHS != 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="codeLine">    Overflow = Res.sdiv(RHS) != *this ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1970</td>
    <td class="codeLine">    Overflow = Res.sdiv(RHS) != *this ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="codeLine">               (isMinSignedValue() && RHS.isAllOnes());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1971</td>
    <td class="codeLine">               (isMinSignedValue() && RHS.isAllOnes());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1972</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="codeLine">    Overflow = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1973</td>
    <td class="codeLine">    Overflow = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="codeLine">  return Res;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1974</td>
    <td class="codeLine">  return Res;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1975</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1976</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="codeLine">APInt APInt::umul_ov(const APInt &RHS, bool &Overflow) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1977</td>
    <td class="codeLine">APInt APInt::umul_ov(const APInt &RHS, bool &Overflow) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="codeLine">  if (countl_zero() + RHS.countl_zero() + 2 <= BitWidth) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1978</td>
    <td class="codeLine">  if (countl_zero() + RHS.countl_zero() + 2 <= BitWidth) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="codeLine">    Overflow = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1979</td>
    <td class="codeLine">    Overflow = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="codeLine">    return *this * RHS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1980</td>
    <td class="codeLine">    return *this * RHS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1981</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1982</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="codeLine">  APInt Res = lshr(1) * RHS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1983</td>
    <td class="codeLine">  APInt Res = lshr(1) * RHS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="codeLine">  Overflow = Res.isNegative();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1984</td>
    <td class="codeLine">  Overflow = Res.isNegative();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="codeLine">  Res <<= 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1985</td>
    <td class="codeLine">  Res <<= 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="codeLine">  if ((*this)[0]) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1986</td>
    <td class="codeLine">  if ((*this)[0]) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="codeLine">    Res += RHS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1987</td>
    <td class="codeLine">    Res += RHS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="codeLine">    if (Res.ult(RHS))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1988</td>
    <td class="codeLine">    if (Res.ult(RHS))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="codeLine">      Overflow = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1989</td>
    <td class="codeLine">      Overflow = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1990</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="codeLine">  return Res;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1991</td>
    <td class="codeLine">  return Res;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1992</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1993</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="codeLine">APInt APInt::sshl_ov(const APInt &ShAmt, bool &Overflow) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1994</td>
    <td class="codeLine">APInt APInt::sshl_ov(const APInt &ShAmt, bool &Overflow) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="codeLine">  return sshl_ov(ShAmt.getLimitedValue(getBitWidth()), Overflow);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1995</td>
    <td class="codeLine">  return sshl_ov(ShAmt.getLimitedValue(getBitWidth()), Overflow);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1996</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1997</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="codeLine">APInt APInt::sshl_ov(unsigned ShAmt, bool &Overflow) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1998</td>
    <td class="codeLine">APInt APInt::sshl_ov(unsigned ShAmt, bool &Overflow) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="codeLine">  Overflow = ShAmt >= getBitWidth();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1999</td>
    <td class="codeLine">  Overflow = ShAmt >= getBitWidth();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="codeLine">  if (Overflow)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2000</td>
    <td class="codeLine">  if (Overflow)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="codeLine">    return APInt(BitWidth, 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2001</td>
    <td class="codeLine">    return APInt(BitWidth, 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2002</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="codeLine">  if (isNonNegative()) // Don't allow sign change.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2003</td>
    <td class="codeLine">  if (isNonNegative()) // Don't allow sign change.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="codeLine">    Overflow = ShAmt >= countl_zero();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2004</td>
    <td class="codeLine">    Overflow = ShAmt >= countl_zero();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2005</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="codeLine">    Overflow = ShAmt >= countl_one();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2006</td>
    <td class="codeLine">    Overflow = ShAmt >= countl_one();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2007</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="codeLine">  return *this << ShAmt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2008</td>
    <td class="codeLine">  return *this << ShAmt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2009</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2010</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="codeLine">APInt APInt::ushl_ov(const APInt &ShAmt, bool &Overflow) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2011</td>
    <td class="codeLine">APInt APInt::ushl_ov(const APInt &ShAmt, bool &Overflow) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="codeLine">  return ushl_ov(ShAmt.getLimitedValue(getBitWidth()), Overflow);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2012</td>
    <td class="codeLine">  return ushl_ov(ShAmt.getLimitedValue(getBitWidth()), Overflow);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2013</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2014</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="codeLine">APInt APInt::ushl_ov(unsigned ShAmt, bool &Overflow) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2015</td>
    <td class="codeLine">APInt APInt::ushl_ov(unsigned ShAmt, bool &Overflow) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="codeLine">  Overflow = ShAmt >= getBitWidth();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2016</td>
    <td class="codeLine">  Overflow = ShAmt >= getBitWidth();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="codeLine">  if (Overflow)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2017</td>
    <td class="codeLine">  if (Overflow)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="codeLine">    return APInt(BitWidth, 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2018</td>
    <td class="codeLine">    return APInt(BitWidth, 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2019</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="codeLine">  Overflow = ShAmt > countl_zero();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2020</td>
    <td class="codeLine">  Overflow = ShAmt > countl_zero();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2021</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="codeLine">  return *this << ShAmt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2022</td>
    <td class="codeLine">  return *this << ShAmt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2023</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2024</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="codeLine">APInt APInt::sadd_sat(const APInt &RHS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2025</td>
    <td class="codeLine">APInt APInt::sadd_sat(const APInt &RHS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="codeLine">  bool Overflow;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2026</td>
    <td class="codeLine">  bool Overflow;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="codeLine">  APInt Res = sadd_ov(RHS, Overflow);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2027</td>
    <td class="codeLine">  APInt Res = sadd_ov(RHS, Overflow);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="codeLine">  if (!Overflow)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2028</td>
    <td class="codeLine">  if (!Overflow)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="codeLine">    return Res;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2029</td>
    <td class="codeLine">    return Res;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2030</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="codeLine">  return isNegative() ? APInt::getSignedMinValue(BitWidth)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2031</td>
    <td class="codeLine">  return isNegative() ? APInt::getSignedMinValue(BitWidth)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="codeLine">                      : APInt::getSignedMaxValue(BitWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2032</td>
    <td class="codeLine">                      : APInt::getSignedMaxValue(BitWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2033</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2034</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="codeLine">APInt APInt::uadd_sat(const APInt &RHS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2035</td>
    <td class="codeLine">APInt APInt::uadd_sat(const APInt &RHS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="codeLine">  bool Overflow;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2036</td>
    <td class="codeLine">  bool Overflow;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="codeLine">  APInt Res = uadd_ov(RHS, Overflow);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2037</td>
    <td class="codeLine">  APInt Res = uadd_ov(RHS, Overflow);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="codeLine">  if (!Overflow)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2038</td>
    <td class="codeLine">  if (!Overflow)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="codeLine">    return Res;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2039</td>
    <td class="codeLine">    return Res;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2040</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="codeLine">  return APInt::getMaxValue(BitWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2041</td>
    <td class="codeLine">  return APInt::getMaxValue(BitWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2042</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2043</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="codeLine">APInt APInt::ssub_sat(const APInt &RHS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2044</td>
    <td class="codeLine">APInt APInt::ssub_sat(const APInt &RHS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="codeLine">  bool Overflow;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2045</td>
    <td class="codeLine">  bool Overflow;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="codeLine">  APInt Res = ssub_ov(RHS, Overflow);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2046</td>
    <td class="codeLine">  APInt Res = ssub_ov(RHS, Overflow);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="codeLine">  if (!Overflow)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2047</td>
    <td class="codeLine">  if (!Overflow)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="codeLine">    return Res;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2048</td>
    <td class="codeLine">    return Res;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2049</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="codeLine">  return isNegative() ? APInt::getSignedMinValue(BitWidth)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2050</td>
    <td class="codeLine">  return isNegative() ? APInt::getSignedMinValue(BitWidth)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="codeLine">                      : APInt::getSignedMaxValue(BitWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2051</td>
    <td class="codeLine">                      : APInt::getSignedMaxValue(BitWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2052</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2053</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="codeLine">APInt APInt::usub_sat(const APInt &RHS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2054</td>
    <td class="codeLine">APInt APInt::usub_sat(const APInt &RHS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="codeLine">  bool Overflow;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2055</td>
    <td class="codeLine">  bool Overflow;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="codeLine">  APInt Res = usub_ov(RHS, Overflow);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2056</td>
    <td class="codeLine">  APInt Res = usub_ov(RHS, Overflow);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="codeLine">  if (!Overflow)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2057</td>
    <td class="codeLine">  if (!Overflow)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="codeLine">    return Res;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2058</td>
    <td class="codeLine">    return Res;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2059</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="codeLine">  return APInt(BitWidth, 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2060</td>
    <td class="codeLine">  return APInt(BitWidth, 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2061</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2062</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="codeLine">APInt APInt::smul_sat(const APInt &RHS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2063</td>
    <td class="codeLine">APInt APInt::smul_sat(const APInt &RHS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="codeLine">  bool Overflow;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2064</td>
    <td class="codeLine">  bool Overflow;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="codeLine">  APInt Res = smul_ov(RHS, Overflow);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2065</td>
    <td class="codeLine">  APInt Res = smul_ov(RHS, Overflow);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="codeLine">  if (!Overflow)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2066</td>
    <td class="codeLine">  if (!Overflow)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="codeLine">    return Res;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2067</td>
    <td class="codeLine">    return Res;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2068</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="codeLine">  // The result is negative if one and only one of inputs is negative.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2069</td>
    <td class="codeLine">  // The result is negative if one and only one of inputs is negative.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="codeLine">  bool ResIsNegative = isNegative() ^ RHS.isNegative();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2070</td>
    <td class="codeLine">  bool ResIsNegative = isNegative() ^ RHS.isNegative();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2071</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="codeLine">  return ResIsNegative ? APInt::getSignedMinValue(BitWidth)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2072</td>
    <td class="codeLine">  return ResIsNegative ? APInt::getSignedMinValue(BitWidth)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="codeLine">                       : APInt::getSignedMaxValue(BitWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2073</td>
    <td class="codeLine">                       : APInt::getSignedMaxValue(BitWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2074</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2075</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="codeLine">APInt APInt::umul_sat(const APInt &RHS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2076</td>
    <td class="codeLine">APInt APInt::umul_sat(const APInt &RHS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="codeLine">  bool Overflow;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2077</td>
    <td class="codeLine">  bool Overflow;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="codeLine">  APInt Res = umul_ov(RHS, Overflow);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2078</td>
    <td class="codeLine">  APInt Res = umul_ov(RHS, Overflow);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="codeLine">  if (!Overflow)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2079</td>
    <td class="codeLine">  if (!Overflow)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="codeLine">    return Res;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2080</td>
    <td class="codeLine">    return Res;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2081</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="codeLine">  return APInt::getMaxValue(BitWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2082</td>
    <td class="codeLine">  return APInt::getMaxValue(BitWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2083</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2084</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="codeLine">APInt APInt::sshl_sat(const APInt &RHS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2085</td>
    <td class="codeLine">APInt APInt::sshl_sat(const APInt &RHS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="codeLine">  return sshl_sat(RHS.getLimitedValue(getBitWidth()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2086</td>
    <td class="codeLine">  return sshl_sat(RHS.getLimitedValue(getBitWidth()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2087</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2088</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="codeLine">APInt APInt::sshl_sat(unsigned RHS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2089</td>
    <td class="codeLine">APInt APInt::sshl_sat(unsigned RHS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="codeLine">  bool Overflow;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2090</td>
    <td class="codeLine">  bool Overflow;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="codeLine">  APInt Res = sshl_ov(RHS, Overflow);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2091</td>
    <td class="codeLine">  APInt Res = sshl_ov(RHS, Overflow);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="codeLine">  if (!Overflow)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2092</td>
    <td class="codeLine">  if (!Overflow)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="codeLine">    return Res;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2093</td>
    <td class="codeLine">    return Res;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2094</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="codeLine">  return isNegative() ? APInt::getSignedMinValue(BitWidth)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2095</td>
    <td class="codeLine">  return isNegative() ? APInt::getSignedMinValue(BitWidth)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="codeLine">                      : APInt::getSignedMaxValue(BitWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2096</td>
    <td class="codeLine">                      : APInt::getSignedMaxValue(BitWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2097</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2098</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="codeLine">APInt APInt::ushl_sat(const APInt &RHS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2099</td>
    <td class="codeLine">APInt APInt::ushl_sat(const APInt &RHS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="codeLine">  return ushl_sat(RHS.getLimitedValue(getBitWidth()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2100</td>
    <td class="codeLine">  return ushl_sat(RHS.getLimitedValue(getBitWidth()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2101</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2102</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="codeLine">APInt APInt::ushl_sat(unsigned RHS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2103</td>
    <td class="codeLine">APInt APInt::ushl_sat(unsigned RHS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="codeLine">  bool Overflow;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2104</td>
    <td class="codeLine">  bool Overflow;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="codeLine">  APInt Res = ushl_ov(RHS, Overflow);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2105</td>
    <td class="codeLine">  APInt Res = ushl_ov(RHS, Overflow);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="codeLine">  if (!Overflow)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2106</td>
    <td class="codeLine">  if (!Overflow)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="codeLine">    return Res;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2107</td>
    <td class="codeLine">    return Res;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2108</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="codeLine">  return APInt::getMaxValue(BitWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2109</td>
    <td class="codeLine">  return APInt::getMaxValue(BitWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2110</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2111</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="codeLine coveredLine">void APInt::fromString(unsigned numbits, StringRef str, uint8_t radix) {</td>
    <td class="lineNumber">149</td>
    <td class="lineNumber">2112</td>
    <td class="codeLine coveredLine">void APInt::fromString(unsigned numbits, StringRef str, uint8_t radix) {</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="codeLine">  // Check our assumptions here</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2113</td>
    <td class="codeLine">  // Check our assumptions here</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="codeLine coveredLine">  assert(!str.empty() && "Invalid string length");</td>
    <td class="lineNumber">149</td>
    <td class="lineNumber">2114</td>
    <td class="codeLine coveredLine">  assert(!str.empty() && "Invalid string length");</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="codeLine coveredLine">  assert((radix == 10 || radix == 8 || radix == 16 || radix == 2 ||</td>
    <td class="lineNumber">149</td>
    <td class="lineNumber">2115</td>
    <td class="codeLine coveredLine">  assert((radix == 10 || radix == 8 || radix == 16 || radix == 2 ||</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="codeLine">          radix == 36) &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2116</td>
    <td class="codeLine">          radix == 36) &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="codeLine">         "Radix should be 2, 8, 10, 16, or 36!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2117</td>
    <td class="codeLine">         "Radix should be 2, 8, 10, 16, or 36!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2118</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="codeLine coveredLine">  StringRef::iterator p = str.begin();</td>
    <td class="lineNumber">149</td>
    <td class="lineNumber">2119</td>
    <td class="codeLine coveredLine">  StringRef::iterator p = str.begin();</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="codeLine coveredLine">  size_t slen = str.size();</td>
    <td class="lineNumber">149</td>
    <td class="lineNumber">2120</td>
    <td class="codeLine coveredLine">  size_t slen = str.size();</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="codeLine coveredLine">  bool isNeg = *p == '-';</td>
    <td class="lineNumber">149</td>
    <td class="lineNumber">2121</td>
    <td class="codeLine coveredLine">  bool isNeg = *p == '-';</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="codeLine coveredLine">  if (*p == '-' || *p == '+') {</td>
    <td class="lineNumber">149</td>
    <td class="lineNumber">2122</td>
    <td class="codeLine coveredLine">  if (*p == '-' || *p == '+') {</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="codeLine">    p++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2123</td>
    <td class="codeLine">    p++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="codeLine">    slen--;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2124</td>
    <td class="codeLine">    slen--;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="codeLine">    assert(slen && "String is only a sign, needs a value.");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2125</td>
    <td class="codeLine">    assert(slen && "String is only a sign, needs a value.");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2126</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="codeLine coveredLine">  assert((slen <= numbits || radix != 2) && "Insufficient bit width");</td>
    <td class="lineNumber">149</td>
    <td class="lineNumber">2127</td>
    <td class="codeLine coveredLine">  assert((slen <= numbits || radix != 2) && "Insufficient bit width");</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="codeLine coveredLine">  assert(((slen-1)*3 <= numbits || radix != 8) && "Insufficient bit width");</td>
    <td class="lineNumber">149</td>
    <td class="lineNumber">2128</td>
    <td class="codeLine coveredLine">  assert(((slen-1)*3 <= numbits || radix != 8) && "Insufficient bit width");</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="codeLine coveredLine">  assert(((slen-1)*4 <= numbits || radix != 16) && "Insufficient bit width");</td>
    <td class="lineNumber">149</td>
    <td class="lineNumber">2129</td>
    <td class="codeLine coveredLine">  assert(((slen-1)*4 <= numbits || radix != 16) && "Insufficient bit width");</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="codeLine coveredLine">  assert((((slen-1)*64)/22 <= numbits || radix != 10) &&</td>
    <td class="lineNumber">149</td>
    <td class="lineNumber">2130</td>
    <td class="codeLine coveredLine">  assert((((slen-1)*64)/22 <= numbits || radix != 10) &&</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="codeLine">         "Insufficient bit width");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2131</td>
    <td class="codeLine">         "Insufficient bit width");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2132</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="codeLine">  // Allocate memory if needed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2133</td>
    <td class="codeLine">  // Allocate memory if needed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="codeLine coveredLine">  if (isSingleWord())</td>
    <td class="lineNumber">149</td>
    <td class="lineNumber">2134</td>
    <td class="codeLine coveredLine">  if (isSingleWord())</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="codeLine coveredLine">    U.VAL = 0;</td>
    <td class="lineNumber">149</td>
    <td class="lineNumber">2135</td>
    <td class="codeLine coveredLine">    U.VAL = 0;</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2136</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="codeLine">    U.pVal = getClearedMemory(getNumWords());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2137</td>
    <td class="codeLine">    U.pVal = getClearedMemory(getNumWords());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2138</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="codeLine">  // Figure out if we can shift instead of multiply</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2139</td>
    <td class="codeLine">  // Figure out if we can shift instead of multiply</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="codeLine coveredLine">  unsigned shift = (radix == 16 ? 4 : radix == 8 ? 3 : radix == 2 ? 1 : 0);</td>
    <td class="lineNumber">149</td>
    <td class="lineNumber">2140</td>
    <td class="codeLine coveredLine">  unsigned shift = (radix == 16 ? 4 : radix == 8 ? 3 : radix == 2 ? 1 : 0);</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2141</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="codeLine">  // Enter digit traversal loop</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2142</td>
    <td class="codeLine">  // Enter digit traversal loop</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="codeLine coveredLine">  for (StringRef::iterator e = str.end(); p != e; ++p) {</td>
    <td class="lineNumber">364</td>
    <td class="lineNumber">2143</td>
    <td class="codeLine coveredLine">  for (StringRef::iterator e = str.end(); p != e; ++p) {</td>
    <td class="lineNumber">44</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="codeLine coveredLine">    unsigned digit = getDigit(*p, radix);</td>
    <td class="lineNumber">215</td>
    <td class="lineNumber">2144</td>
    <td class="codeLine coveredLine">    unsigned digit = getDigit(*p, radix);</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="codeLine coveredLine">    assert(digit < radix && "Invalid character in digit string");</td>
    <td class="lineNumber">215</td>
    <td class="lineNumber">2145</td>
    <td class="codeLine coveredLine">    assert(digit < radix && "Invalid character in digit string");</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2146</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="codeLine">    // Shift or multiply the value by the radix</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2147</td>
    <td class="codeLine">    // Shift or multiply the value by the radix</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="codeLine coveredLine">    if (slen > 1) {</td>
    <td class="lineNumber">215</td>
    <td class="lineNumber">2148</td>
    <td class="codeLine coveredLine">    if (slen > 1) {</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="codeLine coveredLine">      if (shift)</td>
    <td class="lineNumber">132</td>
    <td class="lineNumber">2149</td>
    <td class="codeLine">      if (shift)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="codeLine">        *this <<= shift;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2150</td>
    <td class="codeLine">        *this <<= shift;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="codeLine">      else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2151</td>
    <td class="codeLine">      else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="codeLine coveredLine">        *this *= radix;</td>
    <td class="lineNumber">132</td>
    <td class="lineNumber">2152</td>
    <td class="codeLine">        *this *= radix;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2153</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2154</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="codeLine">    // Add in the digit we just interpreted</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2155</td>
    <td class="codeLine">    // Add in the digit we just interpreted</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="codeLine coveredLine">    *this += digit;</td>
    <td class="lineNumber">215</td>
    <td class="lineNumber">2156</td>
    <td class="codeLine coveredLine">    *this += digit;</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2157</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="codeLine">  // If its negative, put it in two's complement form</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2158</td>
    <td class="codeLine">  // If its negative, put it in two's complement form</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="codeLine coveredLine">  if (isNeg)</td>
    <td class="lineNumber">149</td>
    <td class="lineNumber">2159</td>
    <td class="codeLine coveredLine">  if (isNeg)</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="codeLine">    this->negate();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2160</td>
    <td class="codeLine">    this->negate();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">149</td>
    <td class="lineNumber">2161</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2162</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="codeLine">void APInt::toString(SmallVectorImpl<char> &Str, unsigned Radix, bool Signed,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2163</td>
    <td class="codeLine">void APInt::toString(SmallVectorImpl<char> &Str, unsigned Radix, bool Signed,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="codeLine">                     bool formatAsCLiteral, bool UpperCase) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2164</td>
    <td class="codeLine">                     bool formatAsCLiteral, bool UpperCase) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="codeLine">  assert((Radix == 10 || Radix == 8 || Radix == 16 || Radix == 2 ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2165</td>
    <td class="codeLine">  assert((Radix == 10 || Radix == 8 || Radix == 16 || Radix == 2 ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="codeLine">          Radix == 36) &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2166</td>
    <td class="codeLine">          Radix == 36) &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="codeLine">         "Radix should be 2, 8, 10, 16, or 36!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2167</td>
    <td class="codeLine">         "Radix should be 2, 8, 10, 16, or 36!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2168</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="codeLine">  const char *Prefix = "";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2169</td>
    <td class="codeLine">  const char *Prefix = "";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="codeLine">  if (formatAsCLiteral) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2170</td>
    <td class="codeLine">  if (formatAsCLiteral) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="codeLine">    switch (Radix) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2171</td>
    <td class="codeLine">    switch (Radix) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="codeLine">      case 2:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2172</td>
    <td class="codeLine">      case 2:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="codeLine">        // Binary literals are a non-standard extension added in gcc 4.3:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2173</td>
    <td class="codeLine">        // Binary literals are a non-standard extension added in gcc 4.3:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="codeLine">        // http://gcc.gnu.org/onlinedocs/gcc-4.3.0/gcc/Binary-constants.html</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2174</td>
    <td class="codeLine">        // http://gcc.gnu.org/onlinedocs/gcc-4.3.0/gcc/Binary-constants.html</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="codeLine">        Prefix = "0b";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2175</td>
    <td class="codeLine">        Prefix = "0b";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2176</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="codeLine">      case 8:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2177</td>
    <td class="codeLine">      case 8:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="codeLine">        Prefix = "0";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2178</td>
    <td class="codeLine">        Prefix = "0";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2179</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="codeLine">      case 10:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2180</td>
    <td class="codeLine">      case 10:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="codeLine">        break; // No prefix</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2181</td>
    <td class="codeLine">        break; // No prefix</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="codeLine">      case 16:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2182</td>
    <td class="codeLine">      case 16:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="codeLine">        Prefix = "0x";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2183</td>
    <td class="codeLine">        Prefix = "0x";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2184</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="codeLine">      default:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2185</td>
    <td class="codeLine">      default:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="codeLine">        llvm_unreachable("Invalid radix!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2186</td>
    <td class="codeLine">        llvm_unreachable("Invalid radix!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2187</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2188</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2189</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="codeLine">  // First, check for a zero value and just short circuit the logic below.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2190</td>
    <td class="codeLine">  // First, check for a zero value and just short circuit the logic below.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="codeLine">  if (isZero()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2191</td>
    <td class="codeLine">  if (isZero()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="codeLine">    while (*Prefix) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2192</td>
    <td class="codeLine">    while (*Prefix) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="codeLine">      Str.push_back(*Prefix);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2193</td>
    <td class="codeLine">      Str.push_back(*Prefix);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="codeLine">      ++Prefix;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2194</td>
    <td class="codeLine">      ++Prefix;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2195</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="codeLine">    Str.push_back('0');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2196</td>
    <td class="codeLine">    Str.push_back('0');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2197</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2198</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2199</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="codeLine">  static const char BothDigits[] = "0123456789abcdefghijklmnopqrstuvwxyz"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2200</td>
    <td class="codeLine">  static const char BothDigits[] = "0123456789abcdefghijklmnopqrstuvwxyz"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="codeLine">                                   "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2201</td>
    <td class="codeLine">                                   "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="codeLine">  const char *Digits = BothDigits + (UpperCase ? 36 : 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2202</td>
    <td class="codeLine">  const char *Digits = BothDigits + (UpperCase ? 36 : 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2203</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="codeLine">  if (isSingleWord()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2204</td>
    <td class="codeLine">  if (isSingleWord()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="codeLine">    char Buffer[65];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2205</td>
    <td class="codeLine">    char Buffer[65];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="codeLine">    char *BufPtr = std::end(Buffer);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2206</td>
    <td class="codeLine">    char *BufPtr = std::end(Buffer);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2207</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="codeLine">    uint64_t N;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2208</td>
    <td class="codeLine">    uint64_t N;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="codeLine">    if (!Signed) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2209</td>
    <td class="codeLine">    if (!Signed) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="codeLine">      N = getZExtValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2210</td>
    <td class="codeLine">      N = getZExtValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2211</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="codeLine">      int64_t I = getSExtValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2212</td>
    <td class="codeLine">      int64_t I = getSExtValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="codeLine">      if (I >= 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2213</td>
    <td class="codeLine">      if (I >= 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="codeLine">        N = I;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2214</td>
    <td class="codeLine">        N = I;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2215</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="codeLine">        Str.push_back('-');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2216</td>
    <td class="codeLine">        Str.push_back('-');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="codeLine">        N = -(uint64_t)I;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2217</td>
    <td class="codeLine">        N = -(uint64_t)I;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2218</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2219</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2220</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="codeLine">    while (*Prefix) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2221</td>
    <td class="codeLine">    while (*Prefix) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="codeLine">      Str.push_back(*Prefix);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2222</td>
    <td class="codeLine">      Str.push_back(*Prefix);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="codeLine">      ++Prefix;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2223</td>
    <td class="codeLine">      ++Prefix;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2224</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="codeLine">    while (N) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2226</td>
    <td class="codeLine">    while (N) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="codeLine">      *--BufPtr = Digits[N % Radix];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2227</td>
    <td class="codeLine">      *--BufPtr = Digits[N % Radix];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="codeLine">      N /= Radix;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2228</td>
    <td class="codeLine">      N /= Radix;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2229</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="codeLine">    Str.append(BufPtr, std::end(Buffer));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2230</td>
    <td class="codeLine">    Str.append(BufPtr, std::end(Buffer));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2231</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2232</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2233</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="codeLine">  APInt Tmp(*this);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2234</td>
    <td class="codeLine">  APInt Tmp(*this);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2235</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="codeLine">  if (Signed && isNegative()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2236</td>
    <td class="codeLine">  if (Signed && isNegative()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="codeLine">    // They want to print the signed version and it is a negative value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2237</td>
    <td class="codeLine">    // They want to print the signed version and it is a negative value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="codeLine">    // Flip the bits and add one to turn it into the equivalent positive</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2238</td>
    <td class="codeLine">    // Flip the bits and add one to turn it into the equivalent positive</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="codeLine">    // value and put a '-' in the result.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2239</td>
    <td class="codeLine">    // value and put a '-' in the result.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="codeLine">    Tmp.negate();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2240</td>
    <td class="codeLine">    Tmp.negate();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="codeLine">    Str.push_back('-');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2241</td>
    <td class="codeLine">    Str.push_back('-');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2242</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2243</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="codeLine">  while (*Prefix) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2244</td>
    <td class="codeLine">  while (*Prefix) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="codeLine">    Str.push_back(*Prefix);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2245</td>
    <td class="codeLine">    Str.push_back(*Prefix);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="codeLine">    ++Prefix;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2246</td>
    <td class="codeLine">    ++Prefix;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2247</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2248</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="codeLine">  // We insert the digits backward, then reverse them to get the right order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2249</td>
    <td class="codeLine">  // We insert the digits backward, then reverse them to get the right order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="codeLine">  unsigned StartDig = Str.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2250</td>
    <td class="codeLine">  unsigned StartDig = Str.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2251</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="codeLine">  // For the 2, 8 and 16 bit cases, we can just shift instead of divide</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2252</td>
    <td class="codeLine">  // For the 2, 8 and 16 bit cases, we can just shift instead of divide</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="codeLine">  // because the number of bits per digit (1, 3 and 4 respectively) divides</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2253</td>
    <td class="codeLine">  // because the number of bits per digit (1, 3 and 4 respectively) divides</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="codeLine">  // equally.  We just shift until the value is zero.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2254</td>
    <td class="codeLine">  // equally.  We just shift until the value is zero.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="codeLine">  if (Radix == 2 || Radix == 8 || Radix == 16) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2255</td>
    <td class="codeLine">  if (Radix == 2 || Radix == 8 || Radix == 16) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="codeLine">    // Just shift tmp right for each digit width until it becomes zero</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2256</td>
    <td class="codeLine">    // Just shift tmp right for each digit width until it becomes zero</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="codeLine">    unsigned ShiftAmt = (Radix == 16 ? 4 : (Radix == 8 ? 3 : 1));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2257</td>
    <td class="codeLine">    unsigned ShiftAmt = (Radix == 16 ? 4 : (Radix == 8 ? 3 : 1));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="codeLine">    unsigned MaskAmt = Radix - 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2258</td>
    <td class="codeLine">    unsigned MaskAmt = Radix - 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2259</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="codeLine">    while (Tmp.getBoolValue()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2260</td>
    <td class="codeLine">    while (Tmp.getBoolValue()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="codeLine">      unsigned Digit = unsigned(Tmp.getRawData()[0]) & MaskAmt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2261</td>
    <td class="codeLine">      unsigned Digit = unsigned(Tmp.getRawData()[0]) & MaskAmt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="codeLine">      Str.push_back(Digits[Digit]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2262</td>
    <td class="codeLine">      Str.push_back(Digits[Digit]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="codeLine">      Tmp.lshrInPlace(ShiftAmt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2263</td>
    <td class="codeLine">      Tmp.lshrInPlace(ShiftAmt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2264</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2265</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="codeLine">    while (Tmp.getBoolValue()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2266</td>
    <td class="codeLine">    while (Tmp.getBoolValue()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="codeLine">      uint64_t Digit;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2267</td>
    <td class="codeLine">      uint64_t Digit;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="codeLine">      udivrem(Tmp, Radix, Tmp, Digit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2268</td>
    <td class="codeLine">      udivrem(Tmp, Radix, Tmp, Digit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="codeLine">      assert(Digit < Radix && "divide failed");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2269</td>
    <td class="codeLine">      assert(Digit < Radix && "divide failed");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="codeLine">      Str.push_back(Digits[Digit]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2270</td>
    <td class="codeLine">      Str.push_back(Digits[Digit]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2271</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2272</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2273</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="codeLine">  // Reverse the digits before returning.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2274</td>
    <td class="codeLine">  // Reverse the digits before returning.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="codeLine">  std::reverse(Str.begin()+StartDig, Str.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2275</td>
    <td class="codeLine">  std::reverse(Str.begin()+StartDig, Str.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2276</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2277</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="codeLine">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2278</td>
    <td class="codeLine">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="codeLine">LLVM_DUMP_METHOD void APInt::dump() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2279</td>
    <td class="codeLine">LLVM_DUMP_METHOD void APInt::dump() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="codeLine">  SmallString<40> S, U;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2280</td>
    <td class="codeLine">  SmallString<40> S, U;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="codeLine">  this->toStringUnsigned(U);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2281</td>
    <td class="codeLine">  this->toStringUnsigned(U);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="codeLine">  this->toStringSigned(S);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2282</td>
    <td class="codeLine">  this->toStringSigned(S);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="codeLine">  dbgs() << "APInt(" << BitWidth << "b, "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2283</td>
    <td class="codeLine">  dbgs() << "APInt(" << BitWidth << "b, "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="codeLine">         << U << "u " << S << "s)\n";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2284</td>
    <td class="codeLine">         << U << "u " << S << "s)\n";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2285</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2286</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2287</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="codeLine">void APInt::print(raw_ostream &OS, bool isSigned) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2288</td>
    <td class="codeLine">void APInt::print(raw_ostream &OS, bool isSigned) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="codeLine">  SmallString<40> S;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2289</td>
    <td class="codeLine">  SmallString<40> S;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="codeLine">  this->toString(S, 10, isSigned, /* formatAsCLiteral = */false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2290</td>
    <td class="codeLine">  this->toString(S, 10, isSigned, /* formatAsCLiteral = */false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="codeLine">  OS << S;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2291</td>
    <td class="codeLine">  OS << S;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2292</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2293</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="codeLine">// This implements a variety of operations on a representation of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2294</td>
    <td class="codeLine">// This implements a variety of operations on a representation of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="codeLine">// arbitrary precision, two's-complement, bignum integer values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2295</td>
    <td class="codeLine">// arbitrary precision, two's-complement, bignum integer values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2296</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="codeLine">// Assumed by lowHalf, highHalf, partMSB and partLSB.  A fairly safe</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2297</td>
    <td class="codeLine">// Assumed by lowHalf, highHalf, partMSB and partLSB.  A fairly safe</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="codeLine">// and unrestricting assumption.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2298</td>
    <td class="codeLine">// and unrestricting assumption.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="codeLine">static_assert(APInt::APINT_BITS_PER_WORD % 2 == 0,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2299</td>
    <td class="codeLine">static_assert(APInt::APINT_BITS_PER_WORD % 2 == 0,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="codeLine">              "Part width must be divisible by 2!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2300</td>
    <td class="codeLine">              "Part width must be divisible by 2!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2301</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="codeLine">// Returns the integer part with the least significant BITS set.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2302</td>
    <td class="codeLine">// Returns the integer part with the least significant BITS set.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="codeLine">// BITS cannot be zero.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2303</td>
    <td class="codeLine">// BITS cannot be zero.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="codeLine">static inline APInt::WordType lowBitMask(unsigned bits) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2304</td>
    <td class="codeLine">static inline APInt::WordType lowBitMask(unsigned bits) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="codeLine">  assert(bits != 0 && bits <= APInt::APINT_BITS_PER_WORD);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2305</td>
    <td class="codeLine">  assert(bits != 0 && bits <= APInt::APINT_BITS_PER_WORD);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="codeLine">  return ~(APInt::WordType) 0 >> (APInt::APINT_BITS_PER_WORD - bits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2306</td>
    <td class="codeLine">  return ~(APInt::WordType) 0 >> (APInt::APINT_BITS_PER_WORD - bits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2307</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2308</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="codeLine">/// Returns the value of the lower half of PART.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2309</td>
    <td class="codeLine">/// Returns the value of the lower half of PART.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="codeLine">static inline APInt::WordType lowHalf(APInt::WordType part) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2310</td>
    <td class="codeLine">static inline APInt::WordType lowHalf(APInt::WordType part) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="codeLine">  return part & lowBitMask(APInt::APINT_BITS_PER_WORD / 2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2311</td>
    <td class="codeLine">  return part & lowBitMask(APInt::APINT_BITS_PER_WORD / 2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2312</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2313</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="codeLine">/// Returns the value of the upper half of PART.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2314</td>
    <td class="codeLine">/// Returns the value of the upper half of PART.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="codeLine">static inline APInt::WordType highHalf(APInt::WordType part) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2315</td>
    <td class="codeLine">static inline APInt::WordType highHalf(APInt::WordType part) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="codeLine">  return part >> (APInt::APINT_BITS_PER_WORD / 2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2316</td>
    <td class="codeLine">  return part >> (APInt::APINT_BITS_PER_WORD / 2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2317</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2318</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="codeLine">/// Sets the least significant part of a bignum to the input value, and zeroes</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2319</td>
    <td class="codeLine">/// Sets the least significant part of a bignum to the input value, and zeroes</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="codeLine">/// out higher parts.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2320</td>
    <td class="codeLine">/// out higher parts.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="codeLine coveredLine">void APInt::tcSet(WordType *dst, WordType part, unsigned parts) {</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">2321</td>
    <td class="codeLine coveredLine">void APInt::tcSet(WordType *dst, WordType part, unsigned parts) {</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="codeLine coveredLine">  assert(parts > 0);</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">2322</td>
    <td class="codeLine coveredLine">  assert(parts > 0);</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="codeLine coveredLine">  dst[0] = part;</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">2323</td>
    <td class="codeLine coveredLine">  dst[0] = part;</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="codeLine coveredLine">  for (unsigned i = 1; i < parts; i++)</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">2324</td>
    <td class="codeLine coveredLine">  for (unsigned i = 1; i < parts; i++)</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="codeLine">    dst[i] = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2325</td>
    <td class="codeLine">    dst[i] = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">2326</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2327</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="codeLine">/// Assign one bignum to another.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2328</td>
    <td class="codeLine">/// Assign one bignum to another.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="codeLine">void APInt::tcAssign(WordType *dst, const WordType *src, unsigned parts) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2329</td>
    <td class="codeLine">void APInt::tcAssign(WordType *dst, const WordType *src, unsigned parts) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="codeLine">  for (unsigned i = 0; i < parts; i++)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2330</td>
    <td class="codeLine">  for (unsigned i = 0; i < parts; i++)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="codeLine">    dst[i] = src[i];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2331</td>
    <td class="codeLine">    dst[i] = src[i];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2332</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2333</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="codeLine">/// Returns true if a bignum is zero, false otherwise.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2334</td>
    <td class="codeLine">/// Returns true if a bignum is zero, false otherwise.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="codeLine">bool APInt::tcIsZero(const WordType *src, unsigned parts) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2335</td>
    <td class="codeLine">bool APInt::tcIsZero(const WordType *src, unsigned parts) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="codeLine">  for (unsigned i = 0; i < parts; i++)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2336</td>
    <td class="codeLine">  for (unsigned i = 0; i < parts; i++)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="codeLine">    if (src[i])</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2337</td>
    <td class="codeLine">    if (src[i])</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2338</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2339</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2340</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2341</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2342</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="codeLine">/// Extract the given bit of a bignum; returns 0 or 1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2343</td>
    <td class="codeLine">/// Extract the given bit of a bignum; returns 0 or 1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="codeLine">int APInt::tcExtractBit(const WordType *parts, unsigned bit) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2344</td>
    <td class="codeLine">int APInt::tcExtractBit(const WordType *parts, unsigned bit) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="codeLine">  return (parts[whichWord(bit)] & maskBit(bit)) != 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2345</td>
    <td class="codeLine">  return (parts[whichWord(bit)] & maskBit(bit)) != 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2346</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2347</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="codeLine">/// Set the given bit of a bignum.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2348</td>
    <td class="codeLine">/// Set the given bit of a bignum.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="codeLine">void APInt::tcSetBit(WordType *parts, unsigned bit) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2349</td>
    <td class="codeLine">void APInt::tcSetBit(WordType *parts, unsigned bit) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="codeLine">  parts[whichWord(bit)] |= maskBit(bit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2350</td>
    <td class="codeLine">  parts[whichWord(bit)] |= maskBit(bit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2351</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2352</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="codeLine">/// Clears the given bit of a bignum.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2353</td>
    <td class="codeLine">/// Clears the given bit of a bignum.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="codeLine">void APInt::tcClearBit(WordType *parts, unsigned bit) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2354</td>
    <td class="codeLine">void APInt::tcClearBit(WordType *parts, unsigned bit) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="codeLine">  parts[whichWord(bit)] &= ~maskBit(bit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2355</td>
    <td class="codeLine">  parts[whichWord(bit)] &= ~maskBit(bit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2356</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2357</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="codeLine">/// Returns the bit number of the least significant set bit of a number.  If the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2358</td>
    <td class="codeLine">/// Returns the bit number of the least significant set bit of a number.  If the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="codeLine">/// input number has no bits set UINT_MAX is returned.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2359</td>
    <td class="codeLine">/// input number has no bits set UINT_MAX is returned.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="codeLine">unsigned APInt::tcLSB(const WordType *parts, unsigned n) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2360</td>
    <td class="codeLine">unsigned APInt::tcLSB(const WordType *parts, unsigned n) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="codeLine">  for (unsigned i = 0; i < n; i++) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2361</td>
    <td class="codeLine">  for (unsigned i = 0; i < n; i++) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="codeLine">    if (parts[i] != 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2362</td>
    <td class="codeLine">    if (parts[i] != 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="codeLine">      unsigned lsb = llvm::countr_zero(parts[i]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2363</td>
    <td class="codeLine">      unsigned lsb = llvm::countr_zero(parts[i]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="codeLine">      return lsb + i * APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2364</td>
    <td class="codeLine">      return lsb + i * APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2365</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2366</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2367</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="codeLine">  return UINT_MAX;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2368</td>
    <td class="codeLine">  return UINT_MAX;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2369</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2370</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="codeLine">/// Returns the bit number of the most significant set bit of a number.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2371</td>
    <td class="codeLine">/// Returns the bit number of the most significant set bit of a number.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="codeLine">/// If the input number has no bits set UINT_MAX is returned.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2372</td>
    <td class="codeLine">/// If the input number has no bits set UINT_MAX is returned.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="codeLine">unsigned APInt::tcMSB(const WordType *parts, unsigned n) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2373</td>
    <td class="codeLine">unsigned APInt::tcMSB(const WordType *parts, unsigned n) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="codeLine">  do {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2374</td>
    <td class="codeLine">  do {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="codeLine">    --n;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2375</td>
    <td class="codeLine">    --n;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2376</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="codeLine">    if (parts[n] != 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2377</td>
    <td class="codeLine">    if (parts[n] != 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="codeLine">      static_assert(sizeof(parts[n]) <= sizeof(uint64_t));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2378</td>
    <td class="codeLine">      static_assert(sizeof(parts[n]) <= sizeof(uint64_t));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="codeLine">      unsigned msb = llvm::Log2_64(parts[n]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2379</td>
    <td class="codeLine">      unsigned msb = llvm::Log2_64(parts[n]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2380</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="codeLine">      return msb + n * APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2381</td>
    <td class="codeLine">      return msb + n * APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2382</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="codeLine">  } while (n);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2383</td>
    <td class="codeLine">  } while (n);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2384</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="codeLine">  return UINT_MAX;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2385</td>
    <td class="codeLine">  return UINT_MAX;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2386</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2387</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="codeLine">/// Copy the bit vector of width srcBITS from SRC, starting at bit srcLSB, to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2388</td>
    <td class="codeLine">/// Copy the bit vector of width srcBITS from SRC, starting at bit srcLSB, to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="codeLine">/// DST, of dstCOUNT parts, such that the bit srcLSB becomes the least</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2389</td>
    <td class="codeLine">/// DST, of dstCOUNT parts, such that the bit srcLSB becomes the least</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="codeLine">/// significant bit of DST.  All high bits above srcBITS in DST are zero-filled.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2390</td>
    <td class="codeLine">/// significant bit of DST.  All high bits above srcBITS in DST are zero-filled.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="codeLine">/// */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2391</td>
    <td class="codeLine">/// */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="codeLine">void</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2392</td>
    <td class="codeLine">void</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="codeLine">APInt::tcExtract(WordType *dst, unsigned dstCount, const WordType *src,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2393</td>
    <td class="codeLine">APInt::tcExtract(WordType *dst, unsigned dstCount, const WordType *src,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="codeLine">                 unsigned srcBits, unsigned srcLSB) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2394</td>
    <td class="codeLine">                 unsigned srcBits, unsigned srcLSB) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="codeLine">  unsigned dstParts = (srcBits + APINT_BITS_PER_WORD - 1) / APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2395</td>
    <td class="codeLine">  unsigned dstParts = (srcBits + APINT_BITS_PER_WORD - 1) / APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="codeLine">  assert(dstParts <= dstCount);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2396</td>
    <td class="codeLine">  assert(dstParts <= dstCount);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2397</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="codeLine">  unsigned firstSrcPart = srcLSB / APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2398</td>
    <td class="codeLine">  unsigned firstSrcPart = srcLSB / APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="codeLine">  tcAssign(dst, src + firstSrcPart, dstParts);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2399</td>
    <td class="codeLine">  tcAssign(dst, src + firstSrcPart, dstParts);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2400</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="codeLine">  unsigned shift = srcLSB % APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2401</td>
    <td class="codeLine">  unsigned shift = srcLSB % APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="codeLine">  tcShiftRight(dst, dstParts, shift);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2402</td>
    <td class="codeLine">  tcShiftRight(dst, dstParts, shift);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2403</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="codeLine">  // We now have (dstParts * APINT_BITS_PER_WORD - shift) bits from SRC</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2404</td>
    <td class="codeLine">  // We now have (dstParts * APINT_BITS_PER_WORD - shift) bits from SRC</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="codeLine">  // in DST.  If this is less that srcBits, append the rest, else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2405</td>
    <td class="codeLine">  // in DST.  If this is less that srcBits, append the rest, else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="codeLine">  // clear the high bits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2406</td>
    <td class="codeLine">  // clear the high bits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="codeLine">  unsigned n = dstParts * APINT_BITS_PER_WORD - shift;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2407</td>
    <td class="codeLine">  unsigned n = dstParts * APINT_BITS_PER_WORD - shift;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="codeLine">  if (n < srcBits) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2408</td>
    <td class="codeLine">  if (n < srcBits) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="codeLine">    WordType mask = lowBitMask (srcBits - n);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2409</td>
    <td class="codeLine">    WordType mask = lowBitMask (srcBits - n);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="codeLine">    dst[dstParts - 1] |= ((src[firstSrcPart + dstParts] & mask)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2410</td>
    <td class="codeLine">    dst[dstParts - 1] |= ((src[firstSrcPart + dstParts] & mask)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="codeLine">                          << n % APINT_BITS_PER_WORD);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2411</td>
    <td class="codeLine">                          << n % APINT_BITS_PER_WORD);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="codeLine">  } else if (n > srcBits) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2412</td>
    <td class="codeLine">  } else if (n > srcBits) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="codeLine">    if (srcBits % APINT_BITS_PER_WORD)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2413</td>
    <td class="codeLine">    if (srcBits % APINT_BITS_PER_WORD)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="codeLine">      dst[dstParts - 1] &= lowBitMask (srcBits % APINT_BITS_PER_WORD);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2414</td>
    <td class="codeLine">      dst[dstParts - 1] &= lowBitMask (srcBits % APINT_BITS_PER_WORD);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2415</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2416</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="codeLine">  // Clear high parts.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2417</td>
    <td class="codeLine">  // Clear high parts.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="codeLine">  while (dstParts < dstCount)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2418</td>
    <td class="codeLine">  while (dstParts < dstCount)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="codeLine">    dst[dstParts++] = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2419</td>
    <td class="codeLine">    dst[dstParts++] = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2420</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2421</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="codeLine">//// DST += RHS + C where C is zero or one.  Returns the carry flag.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2422</td>
    <td class="codeLine">//// DST += RHS + C where C is zero or one.  Returns the carry flag.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="codeLine">APInt::WordType APInt::tcAdd(WordType *dst, const WordType *rhs,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2423</td>
    <td class="codeLine">APInt::WordType APInt::tcAdd(WordType *dst, const WordType *rhs,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="codeLine">                             WordType c, unsigned parts) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2424</td>
    <td class="codeLine">                             WordType c, unsigned parts) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="codeLine">  assert(c <= 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2425</td>
    <td class="codeLine">  assert(c <= 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2426</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="codeLine">  for (unsigned i = 0; i < parts; i++) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2427</td>
    <td class="codeLine">  for (unsigned i = 0; i < parts; i++) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="codeLine">    WordType l = dst[i];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2428</td>
    <td class="codeLine">    WordType l = dst[i];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="codeLine">    if (c) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2429</td>
    <td class="codeLine">    if (c) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="codeLine">      dst[i] += rhs[i] + 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2430</td>
    <td class="codeLine">      dst[i] += rhs[i] + 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="codeLine">      c = (dst[i] <= l);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2431</td>
    <td class="codeLine">      c = (dst[i] <= l);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2432</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="codeLine">      dst[i] += rhs[i];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2433</td>
    <td class="codeLine">      dst[i] += rhs[i];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="codeLine">      c = (dst[i] < l);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2434</td>
    <td class="codeLine">      c = (dst[i] < l);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2435</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2436</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2437</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="codeLine">  return c;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2438</td>
    <td class="codeLine">  return c;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2439</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2440</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="codeLine">/// This function adds a single "word" integer, src, to the multiple</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2441</td>
    <td class="codeLine">/// This function adds a single "word" integer, src, to the multiple</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="codeLine">/// "word" integer array, dst[]. dst[] is modified to reflect the addition and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2442</td>
    <td class="codeLine">/// "word" integer array, dst[]. dst[] is modified to reflect the addition and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="codeLine">/// 1 is returned if there is a carry out, otherwise 0 is returned.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2443</td>
    <td class="codeLine">/// 1 is returned if there is a carry out, otherwise 0 is returned.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="codeLine">/// @returns the carry of the addition.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2444</td>
    <td class="codeLine">/// @returns the carry of the addition.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="codeLine">APInt::WordType APInt::tcAddPart(WordType *dst, WordType src,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2445</td>
    <td class="codeLine">APInt::WordType APInt::tcAddPart(WordType *dst, WordType src,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="codeLine">                                 unsigned parts) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2446</td>
    <td class="codeLine">                                 unsigned parts) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="codeLine">  for (unsigned i = 0; i < parts; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2447</td>
    <td class="codeLine">  for (unsigned i = 0; i < parts; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="codeLine">    dst[i] += src;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2448</td>
    <td class="codeLine">    dst[i] += src;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="codeLine">    if (dst[i] >= src)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2449</td>
    <td class="codeLine">    if (dst[i] >= src)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="codeLine">      return 0; // No need to carry so exit early.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2450</td>
    <td class="codeLine">      return 0; // No need to carry so exit early.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="codeLine">    src = 1; // Carry one to next digit.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2451</td>
    <td class="codeLine">    src = 1; // Carry one to next digit.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2452</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2453</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="codeLine">  return 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2454</td>
    <td class="codeLine">  return 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2455</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2456</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="codeLine">/// DST -= RHS + C where C is zero or one.  Returns the carry flag.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2457</td>
    <td class="codeLine">/// DST -= RHS + C where C is zero or one.  Returns the carry flag.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="codeLine">APInt::WordType APInt::tcSubtract(WordType *dst, const WordType *rhs,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2458</td>
    <td class="codeLine">APInt::WordType APInt::tcSubtract(WordType *dst, const WordType *rhs,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="codeLine">                                  WordType c, unsigned parts) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2459</td>
    <td class="codeLine">                                  WordType c, unsigned parts) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="codeLine">  assert(c <= 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2460</td>
    <td class="codeLine">  assert(c <= 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2461</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="codeLine">  for (unsigned i = 0; i < parts; i++) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2462</td>
    <td class="codeLine">  for (unsigned i = 0; i < parts; i++) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="codeLine">    WordType l = dst[i];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2463</td>
    <td class="codeLine">    WordType l = dst[i];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="codeLine">    if (c) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2464</td>
    <td class="codeLine">    if (c) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="codeLine">      dst[i] -= rhs[i] + 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2465</td>
    <td class="codeLine">      dst[i] -= rhs[i] + 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="codeLine">      c = (dst[i] >= l);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2466</td>
    <td class="codeLine">      c = (dst[i] >= l);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2467</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="codeLine">      dst[i] -= rhs[i];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2468</td>
    <td class="codeLine">      dst[i] -= rhs[i];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="codeLine">      c = (dst[i] > l);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2469</td>
    <td class="codeLine">      c = (dst[i] > l);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2470</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2471</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2472</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="codeLine">  return c;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2473</td>
    <td class="codeLine">  return c;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2474</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2475</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2475</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2476</td>
    <td class="codeLine">/// This function subtracts a single "word" (64-bit word), src, from</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2476</td>
    <td class="codeLine">/// This function subtracts a single "word" (64-bit word), src, from</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2477</td>
    <td class="codeLine">/// the multi-word integer array, dst[], propagating the borrowed 1 value until</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2477</td>
    <td class="codeLine">/// the multi-word integer array, dst[], propagating the borrowed 1 value until</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2478</td>
    <td class="codeLine">/// no further borrowing is needed or it runs out of "words" in dst.  The result</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2478</td>
    <td class="codeLine">/// no further borrowing is needed or it runs out of "words" in dst.  The result</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2479</td>
    <td class="codeLine">/// is 1 if "borrowing" exhausted the digits in dst, or 0 if dst was not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2479</td>
    <td class="codeLine">/// is 1 if "borrowing" exhausted the digits in dst, or 0 if dst was not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2480</td>
    <td class="codeLine">/// exhausted. In other words, if src > dst then this function returns 1,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2480</td>
    <td class="codeLine">/// exhausted. In other words, if src > dst then this function returns 1,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2481</td>
    <td class="codeLine">/// otherwise 0.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2481</td>
    <td class="codeLine">/// otherwise 0.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2482</td>
    <td class="codeLine">/// @returns the borrow out of the subtraction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2482</td>
    <td class="codeLine">/// @returns the borrow out of the subtraction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2483</td>
    <td class="codeLine">APInt::WordType APInt::tcSubtractPart(WordType *dst, WordType src,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2483</td>
    <td class="codeLine">APInt::WordType APInt::tcSubtractPart(WordType *dst, WordType src,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2484</td>
    <td class="codeLine">                                      unsigned parts) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2484</td>
    <td class="codeLine">                                      unsigned parts) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2485</td>
    <td class="codeLine">  for (unsigned i = 0; i < parts; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2485</td>
    <td class="codeLine">  for (unsigned i = 0; i < parts; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2486</td>
    <td class="codeLine">    WordType Dst = dst[i];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2486</td>
    <td class="codeLine">    WordType Dst = dst[i];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2487</td>
    <td class="codeLine">    dst[i] -= src;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2487</td>
    <td class="codeLine">    dst[i] -= src;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2488</td>
    <td class="codeLine">    if (src <= Dst)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2488</td>
    <td class="codeLine">    if (src <= Dst)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2489</td>
    <td class="codeLine">      return 0; // No need to borrow so exit early.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2489</td>
    <td class="codeLine">      return 0; // No need to borrow so exit early.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2490</td>
    <td class="codeLine">    src = 1; // We have to "borrow 1" from next "word"</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2490</td>
    <td class="codeLine">    src = 1; // We have to "borrow 1" from next "word"</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2491</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2491</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2492</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2492</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2493</td>
    <td class="codeLine">  return 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2493</td>
    <td class="codeLine">  return 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2494</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2494</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2495</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2495</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2496</td>
    <td class="codeLine">/// Negate a bignum in-place.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2496</td>
    <td class="codeLine">/// Negate a bignum in-place.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2497</td>
    <td class="codeLine">void APInt::tcNegate(WordType *dst, unsigned parts) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2497</td>
    <td class="codeLine">void APInt::tcNegate(WordType *dst, unsigned parts) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2498</td>
    <td class="codeLine">  tcComplement(dst, parts);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2498</td>
    <td class="codeLine">  tcComplement(dst, parts);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2499</td>
    <td class="codeLine">  tcIncrement(dst, parts);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2499</td>
    <td class="codeLine">  tcIncrement(dst, parts);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2500</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2500</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2501</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2501</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2502</td>
    <td class="codeLine">/// DST += SRC * MULTIPLIER + CARRY   if add is true</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2502</td>
    <td class="codeLine">/// DST += SRC * MULTIPLIER + CARRY   if add is true</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2503</td>
    <td class="codeLine">/// DST  = SRC * MULTIPLIER + CARRY   if add is false</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2503</td>
    <td class="codeLine">/// DST  = SRC * MULTIPLIER + CARRY   if add is false</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2504</td>
    <td class="codeLine">/// Requires 0 <= DSTPARTS <= SRCPARTS + 1.  If DST overlaps SRC</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2504</td>
    <td class="codeLine">/// Requires 0 <= DSTPARTS <= SRCPARTS + 1.  If DST overlaps SRC</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2505</td>
    <td class="codeLine">/// they must start at the same point, i.e. DST == SRC.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2505</td>
    <td class="codeLine">/// they must start at the same point, i.e. DST == SRC.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2506</td>
    <td class="codeLine">/// If DSTPARTS == SRCPARTS + 1 no overflow occurs and zero is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2506</td>
    <td class="codeLine">/// If DSTPARTS == SRCPARTS + 1 no overflow occurs and zero is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2507</td>
    <td class="codeLine">/// returned.  Otherwise DST is filled with the least significant</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2507</td>
    <td class="codeLine">/// returned.  Otherwise DST is filled with the least significant</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2508</td>
    <td class="codeLine">/// DSTPARTS parts of the result, and if all of the omitted higher</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2508</td>
    <td class="codeLine">/// DSTPARTS parts of the result, and if all of the omitted higher</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2509</td>
    <td class="codeLine">/// parts were zero return zero, otherwise overflow occurred and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2509</td>
    <td class="codeLine">/// parts were zero return zero, otherwise overflow occurred and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2510</td>
    <td class="codeLine">/// return one.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2510</td>
    <td class="codeLine">/// return one.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2511</td>
    <td class="codeLine">int APInt::tcMultiplyPart(WordType *dst, const WordType *src,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2511</td>
    <td class="codeLine">int APInt::tcMultiplyPart(WordType *dst, const WordType *src,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2512</td>
    <td class="codeLine">                          WordType multiplier, WordType carry,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2512</td>
    <td class="codeLine">                          WordType multiplier, WordType carry,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2513</td>
    <td class="codeLine">                          unsigned srcParts, unsigned dstParts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2513</td>
    <td class="codeLine">                          unsigned srcParts, unsigned dstParts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2514</td>
    <td class="codeLine">                          bool add) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2514</td>
    <td class="codeLine">                          bool add) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2515</td>
    <td class="codeLine">  // Otherwise our writes of DST kill our later reads of SRC.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2515</td>
    <td class="codeLine">  // Otherwise our writes of DST kill our later reads of SRC.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2516</td>
    <td class="codeLine">  assert(dst <= src || dst >= src + srcParts);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2516</td>
    <td class="codeLine">  assert(dst <= src || dst >= src + srcParts);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2517</td>
    <td class="codeLine">  assert(dstParts <= srcParts + 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2517</td>
    <td class="codeLine">  assert(dstParts <= srcParts + 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2518</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2518</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2519</td>
    <td class="codeLine">  // N loops; minimum of dstParts and srcParts.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2519</td>
    <td class="codeLine">  // N loops; minimum of dstParts and srcParts.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2520</td>
    <td class="codeLine">  unsigned n = std::min(dstParts, srcParts);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2520</td>
    <td class="codeLine">  unsigned n = std::min(dstParts, srcParts);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2521</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2521</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2522</td>
    <td class="codeLine">  for (unsigned i = 0; i < n; i++) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2522</td>
    <td class="codeLine">  for (unsigned i = 0; i < n; i++) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2523</td>
    <td class="codeLine">    // [LOW, HIGH] = MULTIPLIER * SRC[i] + DST[i] + CARRY.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2523</td>
    <td class="codeLine">    // [LOW, HIGH] = MULTIPLIER * SRC[i] + DST[i] + CARRY.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2524</td>
    <td class="codeLine">    // This cannot overflow, because:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2524</td>
    <td class="codeLine">    // This cannot overflow, because:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2525</td>
    <td class="codeLine">    //   (n - 1) * (n - 1) + 2 (n - 1) = (n - 1) * (n + 1)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2525</td>
    <td class="codeLine">    //   (n - 1) * (n - 1) + 2 (n - 1) = (n - 1) * (n + 1)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2526</td>
    <td class="codeLine">    // which is less than n^2.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2526</td>
    <td class="codeLine">    // which is less than n^2.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2527</td>
    <td class="codeLine">    WordType srcPart = src[i];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2527</td>
    <td class="codeLine">    WordType srcPart = src[i];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2528</td>
    <td class="codeLine">    WordType low, mid, high;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2528</td>
    <td class="codeLine">    WordType low, mid, high;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2529</td>
    <td class="codeLine">    if (multiplier == 0 || srcPart == 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2529</td>
    <td class="codeLine">    if (multiplier == 0 || srcPart == 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2530</td>
    <td class="codeLine">      low = carry;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2530</td>
    <td class="codeLine">      low = carry;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2531</td>
    <td class="codeLine">      high = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2531</td>
    <td class="codeLine">      high = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2532</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2532</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2533</td>
    <td class="codeLine">      low = lowHalf(srcPart) * lowHalf(multiplier);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2533</td>
    <td class="codeLine">      low = lowHalf(srcPart) * lowHalf(multiplier);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2534</td>
    <td class="codeLine">      high = highHalf(srcPart) * highHalf(multiplier);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2534</td>
    <td class="codeLine">      high = highHalf(srcPart) * highHalf(multiplier);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2535</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2535</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2536</td>
    <td class="codeLine">      mid = lowHalf(srcPart) * highHalf(multiplier);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2536</td>
    <td class="codeLine">      mid = lowHalf(srcPart) * highHalf(multiplier);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2537</td>
    <td class="codeLine">      high += highHalf(mid);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2537</td>
    <td class="codeLine">      high += highHalf(mid);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2538</td>
    <td class="codeLine">      mid <<= APINT_BITS_PER_WORD / 2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2538</td>
    <td class="codeLine">      mid <<= APINT_BITS_PER_WORD / 2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2539</td>
    <td class="codeLine">      if (low + mid < low)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2539</td>
    <td class="codeLine">      if (low + mid < low)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2540</td>
    <td class="codeLine">        high++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2540</td>
    <td class="codeLine">        high++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2541</td>
    <td class="codeLine">      low += mid;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2541</td>
    <td class="codeLine">      low += mid;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2542</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2542</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2543</td>
    <td class="codeLine">      mid = highHalf(srcPart) * lowHalf(multiplier);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2543</td>
    <td class="codeLine">      mid = highHalf(srcPart) * lowHalf(multiplier);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2544</td>
    <td class="codeLine">      high += highHalf(mid);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2544</td>
    <td class="codeLine">      high += highHalf(mid);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2545</td>
    <td class="codeLine">      mid <<= APINT_BITS_PER_WORD / 2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2545</td>
    <td class="codeLine">      mid <<= APINT_BITS_PER_WORD / 2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2546</td>
    <td class="codeLine">      if (low + mid < low)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2546</td>
    <td class="codeLine">      if (low + mid < low)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2547</td>
    <td class="codeLine">        high++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2547</td>
    <td class="codeLine">        high++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2548</td>
    <td class="codeLine">      low += mid;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2548</td>
    <td class="codeLine">      low += mid;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2549</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2549</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2550</td>
    <td class="codeLine">      // Now add carry.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2550</td>
    <td class="codeLine">      // Now add carry.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2551</td>
    <td class="codeLine">      if (low + carry < low)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2551</td>
    <td class="codeLine">      if (low + carry < low)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2552</td>
    <td class="codeLine">        high++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2552</td>
    <td class="codeLine">        high++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2553</td>
    <td class="codeLine">      low += carry;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2553</td>
    <td class="codeLine">      low += carry;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2554</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2554</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2555</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2555</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2556</td>
    <td class="codeLine">    if (add) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2556</td>
    <td class="codeLine">    if (add) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2557</td>
    <td class="codeLine">      // And now DST[i], and store the new low part there.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2557</td>
    <td class="codeLine">      // And now DST[i], and store the new low part there.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2558</td>
    <td class="codeLine">      if (low + dst[i] < low)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2558</td>
    <td class="codeLine">      if (low + dst[i] < low)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2559</td>
    <td class="codeLine">        high++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2559</td>
    <td class="codeLine">        high++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2560</td>
    <td class="codeLine">      dst[i] += low;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2560</td>
    <td class="codeLine">      dst[i] += low;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2561</td>
    <td class="codeLine">    } else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2561</td>
    <td class="codeLine">    } else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2562</td>
    <td class="codeLine">      dst[i] = low;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2562</td>
    <td class="codeLine">      dst[i] = low;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2563</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2563</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2564</td>
    <td class="codeLine">    carry = high;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2564</td>
    <td class="codeLine">    carry = high;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2565</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2565</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2566</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2566</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2567</td>
    <td class="codeLine">  if (srcParts < dstParts) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2567</td>
    <td class="codeLine">  if (srcParts < dstParts) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2568</td>
    <td class="codeLine">    // Full multiplication, there is no overflow.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2568</td>
    <td class="codeLine">    // Full multiplication, there is no overflow.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2569</td>
    <td class="codeLine">    assert(srcParts + 1 == dstParts);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2569</td>
    <td class="codeLine">    assert(srcParts + 1 == dstParts);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2570</td>
    <td class="codeLine">    dst[srcParts] = carry;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2570</td>
    <td class="codeLine">    dst[srcParts] = carry;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2571</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2571</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2572</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2572</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2573</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2573</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2574</td>
    <td class="codeLine">  // We overflowed if there is carry.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2574</td>
    <td class="codeLine">  // We overflowed if there is carry.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2575</td>
    <td class="codeLine">  if (carry)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2575</td>
    <td class="codeLine">  if (carry)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2576</td>
    <td class="codeLine">    return 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2576</td>
    <td class="codeLine">    return 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2577</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2577</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2578</td>
    <td class="codeLine">  // We would overflow if any significant unwritten parts would be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2578</td>
    <td class="codeLine">  // We would overflow if any significant unwritten parts would be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2579</td>
    <td class="codeLine">  // non-zero.  This is true if any remaining src parts are non-zero</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2579</td>
    <td class="codeLine">  // non-zero.  This is true if any remaining src parts are non-zero</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2580</td>
    <td class="codeLine">  // and the multiplier is non-zero.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2580</td>
    <td class="codeLine">  // and the multiplier is non-zero.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2581</td>
    <td class="codeLine">  if (multiplier)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2581</td>
    <td class="codeLine">  if (multiplier)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2582</td>
    <td class="codeLine">    for (unsigned i = dstParts; i < srcParts; i++)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2582</td>
    <td class="codeLine">    for (unsigned i = dstParts; i < srcParts; i++)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2583</td>
    <td class="codeLine">      if (src[i])</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2583</td>
    <td class="codeLine">      if (src[i])</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2584</td>
    <td class="codeLine">        return 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2584</td>
    <td class="codeLine">        return 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2585</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2585</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2586</td>
    <td class="codeLine">  // We fitted in the narrow destination.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2586</td>
    <td class="codeLine">  // We fitted in the narrow destination.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2587</td>
    <td class="codeLine">  return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2587</td>
    <td class="codeLine">  return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2588</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2588</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2589</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2589</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2590</td>
    <td class="codeLine">/// DST = LHS * RHS, where DST has the same width as the operands and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2590</td>
    <td class="codeLine">/// DST = LHS * RHS, where DST has the same width as the operands and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2591</td>
    <td class="codeLine">/// is filled with the least significant parts of the result.  Returns</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2591</td>
    <td class="codeLine">/// is filled with the least significant parts of the result.  Returns</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2592</td>
    <td class="codeLine">/// one if overflow occurred, otherwise zero.  DST must be disjoint</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2592</td>
    <td class="codeLine">/// one if overflow occurred, otherwise zero.  DST must be disjoint</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2593</td>
    <td class="codeLine">/// from both operands.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2593</td>
    <td class="codeLine">/// from both operands.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2594</td>
    <td class="codeLine">int APInt::tcMultiply(WordType *dst, const WordType *lhs,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2594</td>
    <td class="codeLine">int APInt::tcMultiply(WordType *dst, const WordType *lhs,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2595</td>
    <td class="codeLine">                      const WordType *rhs, unsigned parts) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2595</td>
    <td class="codeLine">                      const WordType *rhs, unsigned parts) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2596</td>
    <td class="codeLine">  assert(dst != lhs && dst != rhs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2596</td>
    <td class="codeLine">  assert(dst != lhs && dst != rhs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2597</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2597</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2598</td>
    <td class="codeLine">  int overflow = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2598</td>
    <td class="codeLine">  int overflow = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2599</td>
    <td class="codeLine">  tcSet(dst, 0, parts);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2599</td>
    <td class="codeLine">  tcSet(dst, 0, parts);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2600</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2600</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2601</td>
    <td class="codeLine">  for (unsigned i = 0; i < parts; i++)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2601</td>
    <td class="codeLine">  for (unsigned i = 0; i < parts; i++)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2602</td>
    <td class="codeLine">    overflow |= tcMultiplyPart(&dst[i], lhs, rhs[i], 0, parts,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2602</td>
    <td class="codeLine">    overflow |= tcMultiplyPart(&dst[i], lhs, rhs[i], 0, parts,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2603</td>
    <td class="codeLine">                               parts - i, true);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2603</td>
    <td class="codeLine">                               parts - i, true);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2604</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2604</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2605</td>
    <td class="codeLine">  return overflow;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2605</td>
    <td class="codeLine">  return overflow;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2606</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2606</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2607</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2607</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2608</td>
    <td class="codeLine">/// DST = LHS * RHS, where DST has width the sum of the widths of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2608</td>
    <td class="codeLine">/// DST = LHS * RHS, where DST has width the sum of the widths of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2609</td>
    <td class="codeLine">/// operands. No overflow occurs. DST must be disjoint from both operands.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2609</td>
    <td class="codeLine">/// operands. No overflow occurs. DST must be disjoint from both operands.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2610</td>
    <td class="codeLine">void APInt::tcFullMultiply(WordType *dst, const WordType *lhs,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2610</td>
    <td class="codeLine">void APInt::tcFullMultiply(WordType *dst, const WordType *lhs,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2611</td>
    <td class="codeLine">                           const WordType *rhs, unsigned lhsParts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2611</td>
    <td class="codeLine">                           const WordType *rhs, unsigned lhsParts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2612</td>
    <td class="codeLine">                           unsigned rhsParts) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2612</td>
    <td class="codeLine">                           unsigned rhsParts) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2613</td>
    <td class="codeLine">  // Put the narrower number on the LHS for less loops below.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2613</td>
    <td class="codeLine">  // Put the narrower number on the LHS for less loops below.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2614</td>
    <td class="codeLine">  if (lhsParts > rhsParts)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2614</td>
    <td class="codeLine">  if (lhsParts > rhsParts)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2615</td>
    <td class="codeLine">    return tcFullMultiply (dst, rhs, lhs, rhsParts, lhsParts);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2615</td>
    <td class="codeLine">    return tcFullMultiply (dst, rhs, lhs, rhsParts, lhsParts);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2616</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2616</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2617</td>
    <td class="codeLine">  assert(dst != lhs && dst != rhs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2617</td>
    <td class="codeLine">  assert(dst != lhs && dst != rhs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2618</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2618</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2619</td>
    <td class="codeLine">  tcSet(dst, 0, rhsParts);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2619</td>
    <td class="codeLine">  tcSet(dst, 0, rhsParts);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2620</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2620</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2621</td>
    <td class="codeLine">  for (unsigned i = 0; i < lhsParts; i++)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2621</td>
    <td class="codeLine">  for (unsigned i = 0; i < lhsParts; i++)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2622</td>
    <td class="codeLine">    tcMultiplyPart(&dst[i], rhs, lhs[i], 0, rhsParts, rhsParts + 1, true);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2622</td>
    <td class="codeLine">    tcMultiplyPart(&dst[i], rhs, lhs[i], 0, rhsParts, rhsParts + 1, true);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2623</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2623</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2624</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2624</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2625</td>
    <td class="codeLine">// If RHS is zero LHS and REMAINDER are left unchanged, return one.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2625</td>
    <td class="codeLine">// If RHS is zero LHS and REMAINDER are left unchanged, return one.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2626</td>
    <td class="codeLine">// Otherwise set LHS to LHS / RHS with the fractional part discarded,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2626</td>
    <td class="codeLine">// Otherwise set LHS to LHS / RHS with the fractional part discarded,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2627</td>
    <td class="codeLine">// set REMAINDER to the remainder, return zero.  i.e.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2627</td>
    <td class="codeLine">// set REMAINDER to the remainder, return zero.  i.e.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2628</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2628</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2629</td>
    <td class="codeLine">//   OLD_LHS = RHS * LHS + REMAINDER</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2629</td>
    <td class="codeLine">//   OLD_LHS = RHS * LHS + REMAINDER</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2630</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2630</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2631</td>
    <td class="codeLine">// SCRATCH is a bignum of the same size as the operands and result for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2631</td>
    <td class="codeLine">// SCRATCH is a bignum of the same size as the operands and result for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2632</td>
    <td class="codeLine">// use by the routine; its contents need not be initialized and are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2632</td>
    <td class="codeLine">// use by the routine; its contents need not be initialized and are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2633</td>
    <td class="codeLine">// destroyed.  LHS, REMAINDER and SCRATCH must be distinct.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2633</td>
    <td class="codeLine">// destroyed.  LHS, REMAINDER and SCRATCH must be distinct.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2634</td>
    <td class="codeLine">int APInt::tcDivide(WordType *lhs, const WordType *rhs,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2634</td>
    <td class="codeLine">int APInt::tcDivide(WordType *lhs, const WordType *rhs,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2635</td>
    <td class="codeLine">                    WordType *remainder, WordType *srhs,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2635</td>
    <td class="codeLine">                    WordType *remainder, WordType *srhs,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2636</td>
    <td class="codeLine">                    unsigned parts) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2636</td>
    <td class="codeLine">                    unsigned parts) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2637</td>
    <td class="codeLine">  assert(lhs != remainder && lhs != srhs && remainder != srhs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2637</td>
    <td class="codeLine">  assert(lhs != remainder && lhs != srhs && remainder != srhs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2638</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2638</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2639</td>
    <td class="codeLine">  unsigned shiftCount = tcMSB(rhs, parts) + 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2639</td>
    <td class="codeLine">  unsigned shiftCount = tcMSB(rhs, parts) + 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2640</td>
    <td class="codeLine">  if (shiftCount == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2640</td>
    <td class="codeLine">  if (shiftCount == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2641</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2641</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2642</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2642</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2643</td>
    <td class="codeLine">  shiftCount = parts * APINT_BITS_PER_WORD - shiftCount;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2643</td>
    <td class="codeLine">  shiftCount = parts * APINT_BITS_PER_WORD - shiftCount;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2644</td>
    <td class="codeLine">  unsigned n = shiftCount / APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2644</td>
    <td class="codeLine">  unsigned n = shiftCount / APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2645</td>
    <td class="codeLine">  WordType mask = (WordType) 1 << (shiftCount % APINT_BITS_PER_WORD);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2645</td>
    <td class="codeLine">  WordType mask = (WordType) 1 << (shiftCount % APINT_BITS_PER_WORD);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2646</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2646</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2647</td>
    <td class="codeLine">  tcAssign(srhs, rhs, parts);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2647</td>
    <td class="codeLine">  tcAssign(srhs, rhs, parts);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2648</td>
    <td class="codeLine">  tcShiftLeft(srhs, parts, shiftCount);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2648</td>
    <td class="codeLine">  tcShiftLeft(srhs, parts, shiftCount);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2649</td>
    <td class="codeLine">  tcAssign(remainder, lhs, parts);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2649</td>
    <td class="codeLine">  tcAssign(remainder, lhs, parts);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2650</td>
    <td class="codeLine">  tcSet(lhs, 0, parts);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2650</td>
    <td class="codeLine">  tcSet(lhs, 0, parts);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2651</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2651</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2652</td>
    <td class="codeLine">  // Loop, subtracting SRHS if REMAINDER is greater and adding that to the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2652</td>
    <td class="codeLine">  // Loop, subtracting SRHS if REMAINDER is greater and adding that to the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2653</td>
    <td class="codeLine">  // total.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2653</td>
    <td class="codeLine">  // total.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2654</td>
    <td class="codeLine">  for (;;) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2654</td>
    <td class="codeLine">  for (;;) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2655</td>
    <td class="codeLine">    int compare = tcCompare(remainder, srhs, parts);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2655</td>
    <td class="codeLine">    int compare = tcCompare(remainder, srhs, parts);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2656</td>
    <td class="codeLine">    if (compare >= 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2656</td>
    <td class="codeLine">    if (compare >= 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2657</td>
    <td class="codeLine">      tcSubtract(remainder, srhs, 0, parts);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2657</td>
    <td class="codeLine">      tcSubtract(remainder, srhs, 0, parts);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2658</td>
    <td class="codeLine">      lhs[n] |= mask;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2658</td>
    <td class="codeLine">      lhs[n] |= mask;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2659</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2659</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2660</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2660</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2661</td>
    <td class="codeLine">    if (shiftCount == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2661</td>
    <td class="codeLine">    if (shiftCount == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2662</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2662</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2663</td>
    <td class="codeLine">    shiftCount--;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2663</td>
    <td class="codeLine">    shiftCount--;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2664</td>
    <td class="codeLine">    tcShiftRight(srhs, parts, 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2664</td>
    <td class="codeLine">    tcShiftRight(srhs, parts, 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2665</td>
    <td class="codeLine">    if ((mask >>= 1) == 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2665</td>
    <td class="codeLine">    if ((mask >>= 1) == 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2666</td>
    <td class="codeLine">      mask = (WordType) 1 << (APINT_BITS_PER_WORD - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2666</td>
    <td class="codeLine">      mask = (WordType) 1 << (APINT_BITS_PER_WORD - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2667</td>
    <td class="codeLine">      n--;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2667</td>
    <td class="codeLine">      n--;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2668</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2668</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2669</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2669</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2670</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2670</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2671</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2671</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2672</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2672</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2673</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2673</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2674</td>
    <td class="codeLine">/// Shift a bignum left Cound bits in-place. Shifted in bits are zero. There are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2674</td>
    <td class="codeLine">/// Shift a bignum left Cound bits in-place. Shifted in bits are zero. There are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2675</td>
    <td class="codeLine">/// no restrictions on Count.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2675</td>
    <td class="codeLine">/// no restrictions on Count.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2676</td>
    <td class="codeLine">void APInt::tcShiftLeft(WordType *Dst, unsigned Words, unsigned Count) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2676</td>
    <td class="codeLine">void APInt::tcShiftLeft(WordType *Dst, unsigned Words, unsigned Count) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2677</td>
    <td class="codeLine">  // Don't bother performing a no-op shift.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2677</td>
    <td class="codeLine">  // Don't bother performing a no-op shift.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2678</td>
    <td class="codeLine">  if (!Count)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2678</td>
    <td class="codeLine">  if (!Count)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2679</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2679</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2680</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2680</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2681</td>
    <td class="codeLine">  // WordShift is the inter-part shift; BitShift is the intra-part shift.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2681</td>
    <td class="codeLine">  // WordShift is the inter-part shift; BitShift is the intra-part shift.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2682</td>
    <td class="codeLine">  unsigned WordShift = std::min(Count / APINT_BITS_PER_WORD, Words);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2682</td>
    <td class="codeLine">  unsigned WordShift = std::min(Count / APINT_BITS_PER_WORD, Words);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2683</td>
    <td class="codeLine">  unsigned BitShift = Count % APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2683</td>
    <td class="codeLine">  unsigned BitShift = Count % APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2684</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2684</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2685</td>
    <td class="codeLine">  // Fastpath for moving by whole words.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2685</td>
    <td class="codeLine">  // Fastpath for moving by whole words.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2686</td>
    <td class="codeLine">  if (BitShift == 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2686</td>
    <td class="codeLine">  if (BitShift == 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2687</td>
    <td class="codeLine">    std::memmove(Dst + WordShift, Dst, (Words - WordShift) * APINT_WORD_SIZE);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2687</td>
    <td class="codeLine">    std::memmove(Dst + WordShift, Dst, (Words - WordShift) * APINT_WORD_SIZE);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2688</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2688</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2689</td>
    <td class="codeLine">    while (Words-- > WordShift) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2689</td>
    <td class="codeLine">    while (Words-- > WordShift) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2690</td>
    <td class="codeLine">      Dst[Words] = Dst[Words - WordShift] << BitShift;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2690</td>
    <td class="codeLine">      Dst[Words] = Dst[Words - WordShift] << BitShift;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2691</td>
    <td class="codeLine">      if (Words > WordShift)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2691</td>
    <td class="codeLine">      if (Words > WordShift)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2692</td>
    <td class="codeLine">        Dst[Words] |=</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2692</td>
    <td class="codeLine">        Dst[Words] |=</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2693</td>
    <td class="codeLine">          Dst[Words - WordShift - 1] >> (APINT_BITS_PER_WORD - BitShift);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2693</td>
    <td class="codeLine">          Dst[Words - WordShift - 1] >> (APINT_BITS_PER_WORD - BitShift);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2694</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2694</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2695</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2695</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2696</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2696</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2697</td>
    <td class="codeLine">  // Fill in the remainder with 0s.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2697</td>
    <td class="codeLine">  // Fill in the remainder with 0s.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2698</td>
    <td class="codeLine">  std::memset(Dst, 0, WordShift * APINT_WORD_SIZE);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2698</td>
    <td class="codeLine">  std::memset(Dst, 0, WordShift * APINT_WORD_SIZE);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2699</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2699</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2700</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2700</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2701</td>
    <td class="codeLine">/// Shift a bignum right Count bits in-place. Shifted in bits are zero. There</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2701</td>
    <td class="codeLine">/// Shift a bignum right Count bits in-place. Shifted in bits are zero. There</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2702</td>
    <td class="codeLine">/// are no restrictions on Count.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2702</td>
    <td class="codeLine">/// are no restrictions on Count.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2703</td>
    <td class="codeLine">void APInt::tcShiftRight(WordType *Dst, unsigned Words, unsigned Count) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2703</td>
    <td class="codeLine">void APInt::tcShiftRight(WordType *Dst, unsigned Words, unsigned Count) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2704</td>
    <td class="codeLine">  // Don't bother performing a no-op shift.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2704</td>
    <td class="codeLine">  // Don't bother performing a no-op shift.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2705</td>
    <td class="codeLine">  if (!Count)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2705</td>
    <td class="codeLine">  if (!Count)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2706</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2706</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2707</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2707</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2708</td>
    <td class="codeLine">  // WordShift is the inter-part shift; BitShift is the intra-part shift.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2708</td>
    <td class="codeLine">  // WordShift is the inter-part shift; BitShift is the intra-part shift.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2709</td>
    <td class="codeLine">  unsigned WordShift = std::min(Count / APINT_BITS_PER_WORD, Words);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2709</td>
    <td class="codeLine">  unsigned WordShift = std::min(Count / APINT_BITS_PER_WORD, Words);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2710</td>
    <td class="codeLine">  unsigned BitShift = Count % APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2710</td>
    <td class="codeLine">  unsigned BitShift = Count % APINT_BITS_PER_WORD;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2711</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2711</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2712</td>
    <td class="codeLine">  unsigned WordsToMove = Words - WordShift;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2712</td>
    <td class="codeLine">  unsigned WordsToMove = Words - WordShift;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2713</td>
    <td class="codeLine">  // Fastpath for moving by whole words.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2713</td>
    <td class="codeLine">  // Fastpath for moving by whole words.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2714</td>
    <td class="codeLine">  if (BitShift == 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2714</td>
    <td class="codeLine">  if (BitShift == 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2715</td>
    <td class="codeLine">    std::memmove(Dst, Dst + WordShift, WordsToMove * APINT_WORD_SIZE);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2715</td>
    <td class="codeLine">    std::memmove(Dst, Dst + WordShift, WordsToMove * APINT_WORD_SIZE);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2716</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2716</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2717</td>
    <td class="codeLine">    for (unsigned i = 0; i != WordsToMove; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2717</td>
    <td class="codeLine">    for (unsigned i = 0; i != WordsToMove; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2718</td>
    <td class="codeLine">      Dst[i] = Dst[i + WordShift] >> BitShift;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2718</td>
    <td class="codeLine">      Dst[i] = Dst[i + WordShift] >> BitShift;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2719</td>
    <td class="codeLine">      if (i + 1 != WordsToMove)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2719</td>
    <td class="codeLine">      if (i + 1 != WordsToMove)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2720</td>
    <td class="codeLine">        Dst[i] |= Dst[i + WordShift + 1] << (APINT_BITS_PER_WORD - BitShift);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2720</td>
    <td class="codeLine">        Dst[i] |= Dst[i + WordShift + 1] << (APINT_BITS_PER_WORD - BitShift);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2721</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2721</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2722</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2722</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2723</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2723</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2724</td>
    <td class="codeLine">  // Fill in the remainder with 0s.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2724</td>
    <td class="codeLine">  // Fill in the remainder with 0s.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2725</td>
    <td class="codeLine">  std::memset(Dst + WordsToMove, 0, WordShift * APINT_WORD_SIZE);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2725</td>
    <td class="codeLine">  std::memset(Dst + WordsToMove, 0, WordShift * APINT_WORD_SIZE);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2726</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2726</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2727</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2727</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2728</td>
    <td class="codeLine">// Comparison (unsigned) of two bignums.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2728</td>
    <td class="codeLine">// Comparison (unsigned) of two bignums.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2729</td>
    <td class="codeLine">int APInt::tcCompare(const WordType *lhs, const WordType *rhs,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2729</td>
    <td class="codeLine">int APInt::tcCompare(const WordType *lhs, const WordType *rhs,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2730</td>
    <td class="codeLine">                     unsigned parts) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2730</td>
    <td class="codeLine">                     unsigned parts) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2731</td>
    <td class="codeLine">  while (parts) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2731</td>
    <td class="codeLine">  while (parts) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2732</td>
    <td class="codeLine">    parts--;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2732</td>
    <td class="codeLine">    parts--;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2733</td>
    <td class="codeLine">    if (lhs[parts] != rhs[parts])</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2733</td>
    <td class="codeLine">    if (lhs[parts] != rhs[parts])</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2734</td>
    <td class="codeLine">      return (lhs[parts] > rhs[parts]) ? 1 : -1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2734</td>
    <td class="codeLine">      return (lhs[parts] > rhs[parts]) ? 1 : -1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2735</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2735</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2736</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2736</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2737</td>
    <td class="codeLine">  return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2737</td>
    <td class="codeLine">  return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2738</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2738</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2739</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2739</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2740</td>
    <td class="codeLine">APInt llvm::APIntOps::RoundingUDiv(const APInt &A, const APInt &B,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2740</td>
    <td class="codeLine">APInt llvm::APIntOps::RoundingUDiv(const APInt &A, const APInt &B,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2741</td>
    <td class="codeLine">                                   APInt::Rounding RM) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2741</td>
    <td class="codeLine">                                   APInt::Rounding RM) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2742</td>
    <td class="codeLine">  // Currently udivrem always rounds down.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2742</td>
    <td class="codeLine">  // Currently udivrem always rounds down.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2743</td>
    <td class="codeLine">  switch (RM) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2743</td>
    <td class="codeLine">  switch (RM) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2744</td>
    <td class="codeLine">  case APInt::Rounding::DOWN:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2744</td>
    <td class="codeLine">  case APInt::Rounding::DOWN:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2745</td>
    <td class="codeLine">  case APInt::Rounding::TOWARD_ZERO:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2745</td>
    <td class="codeLine">  case APInt::Rounding::TOWARD_ZERO:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2746</td>
    <td class="codeLine">    return A.udiv(B);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2746</td>
    <td class="codeLine">    return A.udiv(B);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2747</td>
    <td class="codeLine">  case APInt::Rounding::UP: {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2747</td>
    <td class="codeLine">  case APInt::Rounding::UP: {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2748</td>
    <td class="codeLine">    APInt Quo, Rem;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2748</td>
    <td class="codeLine">    APInt Quo, Rem;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2749</td>
    <td class="codeLine">    APInt::udivrem(A, B, Quo, Rem);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2749</td>
    <td class="codeLine">    APInt::udivrem(A, B, Quo, Rem);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2750</td>
    <td class="codeLine">    if (Rem.isZero())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2750</td>
    <td class="codeLine">    if (Rem.isZero())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2751</td>
    <td class="codeLine">      return Quo;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2751</td>
    <td class="codeLine">      return Quo;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2752</td>
    <td class="codeLine">    return Quo + 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2752</td>
    <td class="codeLine">    return Quo + 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2753</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2753</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2754</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2754</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2755</td>
    <td class="codeLine">  llvm_unreachable("Unknown APInt::Rounding enum");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2755</td>
    <td class="codeLine">  llvm_unreachable("Unknown APInt::Rounding enum");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2756</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2756</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2757</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2757</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2758</td>
    <td class="codeLine">APInt llvm::APIntOps::RoundingSDiv(const APInt &A, const APInt &B,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2758</td>
    <td class="codeLine">APInt llvm::APIntOps::RoundingSDiv(const APInt &A, const APInt &B,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2759</td>
    <td class="codeLine">                                   APInt::Rounding RM) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2759</td>
    <td class="codeLine">                                   APInt::Rounding RM) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2760</td>
    <td class="codeLine">  switch (RM) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2760</td>
    <td class="codeLine">  switch (RM) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2761</td>
    <td class="codeLine">  case APInt::Rounding::DOWN:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2761</td>
    <td class="codeLine">  case APInt::Rounding::DOWN:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2762</td>
    <td class="codeLine">  case APInt::Rounding::UP: {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2762</td>
    <td class="codeLine">  case APInt::Rounding::UP: {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2763</td>
    <td class="codeLine">    APInt Quo, Rem;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2763</td>
    <td class="codeLine">    APInt Quo, Rem;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2764</td>
    <td class="codeLine">    APInt::sdivrem(A, B, Quo, Rem);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2764</td>
    <td class="codeLine">    APInt::sdivrem(A, B, Quo, Rem);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2765</td>
    <td class="codeLine">    if (Rem.isZero())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2765</td>
    <td class="codeLine">    if (Rem.isZero())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2766</td>
    <td class="codeLine">      return Quo;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2766</td>
    <td class="codeLine">      return Quo;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2767</td>
    <td class="codeLine">    // This algorithm deals with arbitrary rounding mode used by sdivrem.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2767</td>
    <td class="codeLine">    // This algorithm deals with arbitrary rounding mode used by sdivrem.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2768</td>
    <td class="codeLine">    // We want to check whether the non-integer part of the mathematical value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2768</td>
    <td class="codeLine">    // We want to check whether the non-integer part of the mathematical value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2769</td>
    <td class="codeLine">    // is negative or not. If the non-integer part is negative, we need to round</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2769</td>
    <td class="codeLine">    // is negative or not. If the non-integer part is negative, we need to round</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2770</td>
    <td class="codeLine">    // down from Quo; otherwise, if it's positive or 0, we return Quo, as it's</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2770</td>
    <td class="codeLine">    // down from Quo; otherwise, if it's positive or 0, we return Quo, as it's</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2771</td>
    <td class="codeLine">    // already rounded down.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2771</td>
    <td class="codeLine">    // already rounded down.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2772</td>
    <td class="codeLine">    if (RM == APInt::Rounding::DOWN) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2772</td>
    <td class="codeLine">    if (RM == APInt::Rounding::DOWN) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2773</td>
    <td class="codeLine">      if (Rem.isNegative() != B.isNegative())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2773</td>
    <td class="codeLine">      if (Rem.isNegative() != B.isNegative())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2774</td>
    <td class="codeLine">        return Quo - 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2774</td>
    <td class="codeLine">        return Quo - 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2775</td>
    <td class="codeLine">      return Quo;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2775</td>
    <td class="codeLine">      return Quo;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2776</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2776</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2777</td>
    <td class="codeLine">    if (Rem.isNegative() != B.isNegative())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2777</td>
    <td class="codeLine">    if (Rem.isNegative() != B.isNegative())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2778</td>
    <td class="codeLine">      return Quo;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2778</td>
    <td class="codeLine">      return Quo;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2779</td>
    <td class="codeLine">    return Quo + 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2779</td>
    <td class="codeLine">    return Quo + 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2780</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2780</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2781</td>
    <td class="codeLine">  // Currently sdiv rounds towards zero.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2781</td>
    <td class="codeLine">  // Currently sdiv rounds towards zero.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2782</td>
    <td class="codeLine">  case APInt::Rounding::TOWARD_ZERO:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2782</td>
    <td class="codeLine">  case APInt::Rounding::TOWARD_ZERO:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2783</td>
    <td class="codeLine">    return A.sdiv(B);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2783</td>
    <td class="codeLine">    return A.sdiv(B);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2784</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2784</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2785</td>
    <td class="codeLine">  llvm_unreachable("Unknown APInt::Rounding enum");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2785</td>
    <td class="codeLine">  llvm_unreachable("Unknown APInt::Rounding enum");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2786</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2786</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2787</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2787</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2788</td>
    <td class="codeLine">std::optional<APInt></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2788</td>
    <td class="codeLine">std::optional<APInt></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2789</td>
    <td class="codeLine">llvm::APIntOps::SolveQuadraticEquationWrap(APInt A, APInt B, APInt C,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2789</td>
    <td class="codeLine">llvm::APIntOps::SolveQuadraticEquationWrap(APInt A, APInt B, APInt C,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2790</td>
    <td class="codeLine">                                           unsigned RangeWidth) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2790</td>
    <td class="codeLine">                                           unsigned RangeWidth) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2791</td>
    <td class="codeLine">  unsigned CoeffWidth = A.getBitWidth();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2791</td>
    <td class="codeLine">  unsigned CoeffWidth = A.getBitWidth();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2792</td>
    <td class="codeLine">  assert(CoeffWidth == B.getBitWidth() && CoeffWidth == C.getBitWidth());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2792</td>
    <td class="codeLine">  assert(CoeffWidth == B.getBitWidth() && CoeffWidth == C.getBitWidth());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2793</td>
    <td class="codeLine">  assert(RangeWidth <= CoeffWidth &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2793</td>
    <td class="codeLine">  assert(RangeWidth <= CoeffWidth &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2794</td>
    <td class="codeLine">         "Value range width should be less than coefficient width");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2794</td>
    <td class="codeLine">         "Value range width should be less than coefficient width");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2795</td>
    <td class="codeLine">  assert(RangeWidth > 1 && "Value range bit width should be > 1");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2795</td>
    <td class="codeLine">  assert(RangeWidth > 1 && "Value range bit width should be > 1");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2796</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2796</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2797</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << __func__ << ": solving " << A << "x^2 + " << B</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2797</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << __func__ << ": solving " << A << "x^2 + " << B</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2798</td>
    <td class="codeLine">                    << "x + " << C << ", rw:" << RangeWidth << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2798</td>
    <td class="codeLine">                    << "x + " << C << ", rw:" << RangeWidth << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2799</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2799</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2800</td>
    <td class="codeLine">  // Identify 0 as a (non)solution immediately.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2800</td>
    <td class="codeLine">  // Identify 0 as a (non)solution immediately.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2801</td>
    <td class="codeLine">  if (C.sextOrTrunc(RangeWidth).isZero()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2801</td>
    <td class="codeLine">  if (C.sextOrTrunc(RangeWidth).isZero()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2802</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << __func__ << ": zero solution\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2802</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << __func__ << ": zero solution\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2803</td>
    <td class="codeLine">    return APInt(CoeffWidth, 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2803</td>
    <td class="codeLine">    return APInt(CoeffWidth, 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2804</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2804</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2805</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2805</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2806</td>
    <td class="codeLine">  // The result of APInt arithmetic has the same bit width as the operands,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2806</td>
    <td class="codeLine">  // The result of APInt arithmetic has the same bit width as the operands,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2807</td>
    <td class="codeLine">  // so it can actually lose high bits. A product of two n-bit integers needs</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2807</td>
    <td class="codeLine">  // so it can actually lose high bits. A product of two n-bit integers needs</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2808</td>
    <td class="codeLine">  // 2n-1 bits to represent the full value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2808</td>
    <td class="codeLine">  // 2n-1 bits to represent the full value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2809</td>
    <td class="codeLine">  // The operation done below (on quadratic coefficients) that can produce</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2809</td>
    <td class="codeLine">  // The operation done below (on quadratic coefficients) that can produce</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2810</td>
    <td class="codeLine">  // the largest value is the evaluation of the equation during bisection,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2810</td>
    <td class="codeLine">  // the largest value is the evaluation of the equation during bisection,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2811</td>
    <td class="codeLine">  // which needs 3 times the bitwidth of the coefficient, so the total number</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2811</td>
    <td class="codeLine">  // which needs 3 times the bitwidth of the coefficient, so the total number</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2812</td>
    <td class="codeLine">  // of required bits is 3n.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2812</td>
    <td class="codeLine">  // of required bits is 3n.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2813</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2813</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2814</td>
    <td class="codeLine">  // The purpose of this extension is to simulate the set Z of all integers,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2814</td>
    <td class="codeLine">  // The purpose of this extension is to simulate the set Z of all integers,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2815</td>
    <td class="codeLine">  // where n+1 > n for all n in Z. In Z it makes sense to talk about positive</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2815</td>
    <td class="codeLine">  // where n+1 > n for all n in Z. In Z it makes sense to talk about positive</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2816</td>
    <td class="codeLine">  // and negative numbers (not so much in a modulo arithmetic). The method</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2816</td>
    <td class="codeLine">  // and negative numbers (not so much in a modulo arithmetic). The method</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2817</td>
    <td class="codeLine">  // used to solve the equation is based on the standard formula for real</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2817</td>
    <td class="codeLine">  // used to solve the equation is based on the standard formula for real</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2818</td>
    <td class="codeLine">  // numbers, and uses the concepts of "positive" and "negative" with their</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2818</td>
    <td class="codeLine">  // numbers, and uses the concepts of "positive" and "negative" with their</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2819</td>
    <td class="codeLine">  // usual meanings.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2819</td>
    <td class="codeLine">  // usual meanings.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2820</td>
    <td class="codeLine">  CoeffWidth *= 3;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2820</td>
    <td class="codeLine">  CoeffWidth *= 3;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2821</td>
    <td class="codeLine">  A = A.sext(CoeffWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2821</td>
    <td class="codeLine">  A = A.sext(CoeffWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2822</td>
    <td class="codeLine">  B = B.sext(CoeffWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2822</td>
    <td class="codeLine">  B = B.sext(CoeffWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2823</td>
    <td class="codeLine">  C = C.sext(CoeffWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2823</td>
    <td class="codeLine">  C = C.sext(CoeffWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2824</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2824</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2825</td>
    <td class="codeLine">  // Make A > 0 for simplicity. Negate cannot overflow at this point because</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2825</td>
    <td class="codeLine">  // Make A > 0 for simplicity. Negate cannot overflow at this point because</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2826</td>
    <td class="codeLine">  // the bit width has increased.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2826</td>
    <td class="codeLine">  // the bit width has increased.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2827</td>
    <td class="codeLine">  if (A.isNegative()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2827</td>
    <td class="codeLine">  if (A.isNegative()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2828</td>
    <td class="codeLine">    A.negate();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2828</td>
    <td class="codeLine">    A.negate();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2829</td>
    <td class="codeLine">    B.negate();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2829</td>
    <td class="codeLine">    B.negate();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2830</td>
    <td class="codeLine">    C.negate();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2830</td>
    <td class="codeLine">    C.negate();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2831</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2831</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2832</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2832</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2833</td>
    <td class="codeLine">  // Solving an equation q(x) = 0 with coefficients in modular arithmetic</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2833</td>
    <td class="codeLine">  // Solving an equation q(x) = 0 with coefficients in modular arithmetic</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2834</td>
    <td class="codeLine">  // is really solving a set of equations q(x) = kR for k = 0, 1, 2, ...,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2834</td>
    <td class="codeLine">  // is really solving a set of equations q(x) = kR for k = 0, 1, 2, ...,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2835</td>
    <td class="codeLine">  // and R = 2^BitWidth.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2835</td>
    <td class="codeLine">  // and R = 2^BitWidth.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2836</td>
    <td class="codeLine">  // Since we're trying not only to find exact solutions, but also values</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2836</td>
    <td class="codeLine">  // Since we're trying not only to find exact solutions, but also values</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2837</td>
    <td class="codeLine">  // that "wrap around", such a set will always have a solution, i.e. an x</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2837</td>
    <td class="codeLine">  // that "wrap around", such a set will always have a solution, i.e. an x</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2838</td>
    <td class="codeLine">  // that satisfies at least one of the equations, or such that |q(x)|</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2838</td>
    <td class="codeLine">  // that satisfies at least one of the equations, or such that |q(x)|</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2839</td>
    <td class="codeLine">  // exceeds kR, while |q(x-1)| for the same k does not.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2839</td>
    <td class="codeLine">  // exceeds kR, while |q(x-1)| for the same k does not.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2840</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2840</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2841</td>
    <td class="codeLine">  // We need to find a value k, such that Ax^2 + Bx + C = kR will have a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2841</td>
    <td class="codeLine">  // We need to find a value k, such that Ax^2 + Bx + C = kR will have a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2842</td>
    <td class="codeLine">  // positive solution n (in the above sense), and also such that the n</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2842</td>
    <td class="codeLine">  // positive solution n (in the above sense), and also such that the n</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2843</td>
    <td class="codeLine">  // will be the least among all solutions corresponding to k = 0, 1, ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2843</td>
    <td class="codeLine">  // will be the least among all solutions corresponding to k = 0, 1, ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2844</td>
    <td class="codeLine">  // (more precisely, the least element in the set</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2844</td>
    <td class="codeLine">  // (more precisely, the least element in the set</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2845</td>
    <td class="codeLine">  //   { n(k) | k is such that a solution n(k) exists }).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2845</td>
    <td class="codeLine">  //   { n(k) | k is such that a solution n(k) exists }).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2846</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2846</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2847</td>
    <td class="codeLine">  // Consider the parabola (over real numbers) that corresponds to the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2847</td>
    <td class="codeLine">  // Consider the parabola (over real numbers) that corresponds to the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2848</td>
    <td class="codeLine">  // quadratic equation. Since A > 0, the arms of the parabola will point</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2848</td>
    <td class="codeLine">  // quadratic equation. Since A > 0, the arms of the parabola will point</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2849</td>
    <td class="codeLine">  // up. Picking different values of k will shift it up and down by R.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2849</td>
    <td class="codeLine">  // up. Picking different values of k will shift it up and down by R.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2850</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2850</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2851</td>
    <td class="codeLine">  // We want to shift the parabola in such a way as to reduce the problem</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2851</td>
    <td class="codeLine">  // We want to shift the parabola in such a way as to reduce the problem</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2852</td>
    <td class="codeLine">  // of solving q(x) = kR to solving shifted_q(x) = 0.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2852</td>
    <td class="codeLine">  // of solving q(x) = kR to solving shifted_q(x) = 0.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2853</td>
    <td class="codeLine">  // (The interesting solutions are the ceilings of the real number</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2853</td>
    <td class="codeLine">  // (The interesting solutions are the ceilings of the real number</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2854</td>
    <td class="codeLine">  // solutions.)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2854</td>
    <td class="codeLine">  // solutions.)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2855</td>
    <td class="codeLine">  APInt R = APInt::getOneBitSet(CoeffWidth, RangeWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2855</td>
    <td class="codeLine">  APInt R = APInt::getOneBitSet(CoeffWidth, RangeWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2856</td>
    <td class="codeLine">  APInt TwoA = 2 * A;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2856</td>
    <td class="codeLine">  APInt TwoA = 2 * A;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2857</td>
    <td class="codeLine">  APInt SqrB = B * B;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2857</td>
    <td class="codeLine">  APInt SqrB = B * B;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2858</td>
    <td class="codeLine">  bool PickLow;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2858</td>
    <td class="codeLine">  bool PickLow;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2859</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2859</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2860</td>
    <td class="codeLine">  auto RoundUp = [] (const APInt &V, const APInt &A) -> APInt {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2860</td>
    <td class="codeLine">  auto RoundUp = [] (const APInt &V, const APInt &A) -> APInt {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2861</td>
    <td class="codeLine">    assert(A.isStrictlyPositive());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2861</td>
    <td class="codeLine">    assert(A.isStrictlyPositive());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2862</td>
    <td class="codeLine">    APInt T = V.abs().urem(A);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2862</td>
    <td class="codeLine">    APInt T = V.abs().urem(A);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2863</td>
    <td class="codeLine">    if (T.isZero())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2863</td>
    <td class="codeLine">    if (T.isZero())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2864</td>
    <td class="codeLine">      return V;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2864</td>
    <td class="codeLine">      return V;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2865</td>
    <td class="codeLine">    return V.isNegative() ? V+T : V+(A-T);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2865</td>
    <td class="codeLine">    return V.isNegative() ? V+T : V+(A-T);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2866</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2866</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2867</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2867</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2868</td>
    <td class="codeLine">  // The vertex of the parabola is at -B/2A, but since A > 0, it's negative</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2868</td>
    <td class="codeLine">  // The vertex of the parabola is at -B/2A, but since A > 0, it's negative</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2869</td>
    <td class="codeLine">  // iff B is positive.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2869</td>
    <td class="codeLine">  // iff B is positive.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2870</td>
    <td class="codeLine">  if (B.isNonNegative()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2870</td>
    <td class="codeLine">  if (B.isNonNegative()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2871</td>
    <td class="codeLine">    // If B >= 0, the vertex it at a negative location (or at 0), so in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2871</td>
    <td class="codeLine">    // If B >= 0, the vertex it at a negative location (or at 0), so in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2872</td>
    <td class="codeLine">    // order to have a non-negative solution we need to pick k that makes</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2872</td>
    <td class="codeLine">    // order to have a non-negative solution we need to pick k that makes</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2873</td>
    <td class="codeLine">    // C-kR negative. To satisfy all the requirements for the solution</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2873</td>
    <td class="codeLine">    // C-kR negative. To satisfy all the requirements for the solution</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2874</td>
    <td class="codeLine">    // that we are looking for, it needs to be closest to 0 of all k.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2874</td>
    <td class="codeLine">    // that we are looking for, it needs to be closest to 0 of all k.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2875</td>
    <td class="codeLine">    C = C.srem(R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2875</td>
    <td class="codeLine">    C = C.srem(R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2876</td>
    <td class="codeLine">    if (C.isStrictlyPositive())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2876</td>
    <td class="codeLine">    if (C.isStrictlyPositive())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2877</td>
    <td class="codeLine">      C -= R;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2877</td>
    <td class="codeLine">      C -= R;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2878</td>
    <td class="codeLine">    // Pick the greater solution.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2878</td>
    <td class="codeLine">    // Pick the greater solution.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2879</td>
    <td class="codeLine">    PickLow = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2879</td>
    <td class="codeLine">    PickLow = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2880</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2880</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2881</td>
    <td class="codeLine">    // If B < 0, the vertex is at a positive location. For any solution</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2881</td>
    <td class="codeLine">    // If B < 0, the vertex is at a positive location. For any solution</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2882</td>
    <td class="codeLine">    // to exist, the discriminant must be non-negative. This means that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2882</td>
    <td class="codeLine">    // to exist, the discriminant must be non-negative. This means that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2883</td>
    <td class="codeLine">    // C-kR <= B^2/4A is a necessary condition for k, i.e. there is a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2883</td>
    <td class="codeLine">    // C-kR <= B^2/4A is a necessary condition for k, i.e. there is a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2884</td>
    <td class="codeLine">    // lower bound on values of k: kR >= C - B^2/4A.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2884</td>
    <td class="codeLine">    // lower bound on values of k: kR >= C - B^2/4A.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2885</td>
    <td class="codeLine">    APInt LowkR = C - SqrB.udiv(2*TwoA); // udiv because all values > 0.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2885</td>
    <td class="codeLine">    APInt LowkR = C - SqrB.udiv(2*TwoA); // udiv because all values > 0.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2886</td>
    <td class="codeLine">    // Round LowkR up (towards +inf) to the nearest kR.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2886</td>
    <td class="codeLine">    // Round LowkR up (towards +inf) to the nearest kR.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2887</td>
    <td class="codeLine">    LowkR = RoundUp(LowkR, R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2887</td>
    <td class="codeLine">    LowkR = RoundUp(LowkR, R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2888</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2888</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2889</td>
    <td class="codeLine">    // If there exists k meeting the condition above, and such that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2889</td>
    <td class="codeLine">    // If there exists k meeting the condition above, and such that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2890</td>
    <td class="codeLine">    // C-kR > 0, there will be two positive real number solutions of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2890</td>
    <td class="codeLine">    // C-kR > 0, there will be two positive real number solutions of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2891</td>
    <td class="codeLine">    // q(x) = kR. Out of all such values of k, pick the one that makes</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2891</td>
    <td class="codeLine">    // q(x) = kR. Out of all such values of k, pick the one that makes</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2892</td>
    <td class="codeLine">    // C-kR closest to 0, (i.e. pick maximum k such that C-kR > 0).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2892</td>
    <td class="codeLine">    // C-kR closest to 0, (i.e. pick maximum k such that C-kR > 0).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2893</td>
    <td class="codeLine">    // In other words, find maximum k such that LowkR <= kR < C.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2893</td>
    <td class="codeLine">    // In other words, find maximum k such that LowkR <= kR < C.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2894</td>
    <td class="codeLine">    if (C.sgt(LowkR)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2894</td>
    <td class="codeLine">    if (C.sgt(LowkR)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2895</td>
    <td class="codeLine">      // If LowkR < C, then such a k is guaranteed to exist because</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2895</td>
    <td class="codeLine">      // If LowkR < C, then such a k is guaranteed to exist because</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2896</td>
    <td class="codeLine">      // LowkR itself is a multiple of R.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2896</td>
    <td class="codeLine">      // LowkR itself is a multiple of R.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2897</td>
    <td class="codeLine">      C -= -RoundUp(-C, R);      // C = C - RoundDown(C, R)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2897</td>
    <td class="codeLine">      C -= -RoundUp(-C, R);      // C = C - RoundDown(C, R)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2898</td>
    <td class="codeLine">      // Pick the smaller solution.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2898</td>
    <td class="codeLine">      // Pick the smaller solution.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2899</td>
    <td class="codeLine">      PickLow = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2899</td>
    <td class="codeLine">      PickLow = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2900</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2900</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2901</td>
    <td class="codeLine">      // If C-kR < 0 for all potential k's, it means that one solution</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2901</td>
    <td class="codeLine">      // If C-kR < 0 for all potential k's, it means that one solution</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2902</td>
    <td class="codeLine">      // will be negative, while the other will be positive. The positive</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2902</td>
    <td class="codeLine">      // will be negative, while the other will be positive. The positive</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2903</td>
    <td class="codeLine">      // solution will shift towards 0 if the parabola is moved up.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2903</td>
    <td class="codeLine">      // solution will shift towards 0 if the parabola is moved up.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2904</td>
    <td class="codeLine">      // Pick the kR closest to the lower bound (i.e. make C-kR closest</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2904</td>
    <td class="codeLine">      // Pick the kR closest to the lower bound (i.e. make C-kR closest</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2905</td>
    <td class="codeLine">      // to 0, or in other words, out of all parabolas that have solutions,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2905</td>
    <td class="codeLine">      // to 0, or in other words, out of all parabolas that have solutions,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2906</td>
    <td class="codeLine">      // pick the one that is the farthest "up").</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2906</td>
    <td class="codeLine">      // pick the one that is the farthest "up").</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2907</td>
    <td class="codeLine">      // Since LowkR is itself a multiple of R, simply take C-LowkR.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2907</td>
    <td class="codeLine">      // Since LowkR is itself a multiple of R, simply take C-LowkR.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2908</td>
    <td class="codeLine">      C -= LowkR;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2908</td>
    <td class="codeLine">      C -= LowkR;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2909</td>
    <td class="codeLine">      // Pick the greater solution.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2909</td>
    <td class="codeLine">      // Pick the greater solution.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2910</td>
    <td class="codeLine">      PickLow = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2910</td>
    <td class="codeLine">      PickLow = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2911</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2911</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2912</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2912</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2913</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2913</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2914</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << __func__ << ": updated coefficients " << A << "x^2 + "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2914</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << __func__ << ": updated coefficients " << A << "x^2 + "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2915</td>
    <td class="codeLine">                    << B << "x + " << C << ", rw:" << RangeWidth << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2915</td>
    <td class="codeLine">                    << B << "x + " << C << ", rw:" << RangeWidth << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2916</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2916</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2917</td>
    <td class="codeLine">  APInt D = SqrB - 4*A*C;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2917</td>
    <td class="codeLine">  APInt D = SqrB - 4*A*C;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2918</td>
    <td class="codeLine">  assert(D.isNonNegative() && "Negative discriminant");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2918</td>
    <td class="codeLine">  assert(D.isNonNegative() && "Negative discriminant");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2919</td>
    <td class="codeLine">  APInt SQ = D.sqrt();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2919</td>
    <td class="codeLine">  APInt SQ = D.sqrt();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2920</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2920</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2921</td>
    <td class="codeLine">  APInt Q = SQ * SQ;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2921</td>
    <td class="codeLine">  APInt Q = SQ * SQ;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2922</td>
    <td class="codeLine">  bool InexactSQ = Q != D;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2922</td>
    <td class="codeLine">  bool InexactSQ = Q != D;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2923</td>
    <td class="codeLine">  // The calculated SQ may actually be greater than the exact (non-integer)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2923</td>
    <td class="codeLine">  // The calculated SQ may actually be greater than the exact (non-integer)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2924</td>
    <td class="codeLine">  // value. If that's the case, decrement SQ to get a value that is lower.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2924</td>
    <td class="codeLine">  // value. If that's the case, decrement SQ to get a value that is lower.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2925</td>
    <td class="codeLine">  if (Q.sgt(D))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2925</td>
    <td class="codeLine">  if (Q.sgt(D))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2926</td>
    <td class="codeLine">    SQ -= 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2926</td>
    <td class="codeLine">    SQ -= 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2927</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2927</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2928</td>
    <td class="codeLine">  APInt X;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2928</td>
    <td class="codeLine">  APInt X;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2929</td>
    <td class="codeLine">  APInt Rem;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2929</td>
    <td class="codeLine">  APInt Rem;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2930</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2930</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2931</td>
    <td class="codeLine">  // SQ is rounded down (i.e SQ * SQ <= D), so the roots may be inexact.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2931</td>
    <td class="codeLine">  // SQ is rounded down (i.e SQ * SQ <= D), so the roots may be inexact.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2932</td>
    <td class="codeLine">  // When using the quadratic formula directly, the calculated low root</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2932</td>
    <td class="codeLine">  // When using the quadratic formula directly, the calculated low root</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2933</td>
    <td class="codeLine">  // may be greater than the exact one, since we would be subtracting SQ.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2933</td>
    <td class="codeLine">  // may be greater than the exact one, since we would be subtracting SQ.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2934</td>
    <td class="codeLine">  // To make sure that the calculated root is not greater than the exact</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2934</td>
    <td class="codeLine">  // To make sure that the calculated root is not greater than the exact</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2935</td>
    <td class="codeLine">  // one, subtract SQ+1 when calculating the low root (for inexact value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2935</td>
    <td class="codeLine">  // one, subtract SQ+1 when calculating the low root (for inexact value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2936</td>
    <td class="codeLine">  // of SQ).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2936</td>
    <td class="codeLine">  // of SQ).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2937</td>
    <td class="codeLine">  if (PickLow)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2937</td>
    <td class="codeLine">  if (PickLow)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2938</td>
    <td class="codeLine">    APInt::sdivrem(-B - (SQ+InexactSQ), TwoA, X, Rem);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2938</td>
    <td class="codeLine">    APInt::sdivrem(-B - (SQ+InexactSQ), TwoA, X, Rem);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2939</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2939</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2940</td>
    <td class="codeLine">    APInt::sdivrem(-B + SQ, TwoA, X, Rem);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2940</td>
    <td class="codeLine">    APInt::sdivrem(-B + SQ, TwoA, X, Rem);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2941</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2941</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2942</td>
    <td class="codeLine">  // The updated coefficients should be such that the (exact) solution is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2942</td>
    <td class="codeLine">  // The updated coefficients should be such that the (exact) solution is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2943</td>
    <td class="codeLine">  // positive. Since APInt division rounds towards 0, the calculated one</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2943</td>
    <td class="codeLine">  // positive. Since APInt division rounds towards 0, the calculated one</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2944</td>
    <td class="codeLine">  // can be 0, but cannot be negative.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2944</td>
    <td class="codeLine">  // can be 0, but cannot be negative.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2945</td>
    <td class="codeLine">  assert(X.isNonNegative() && "Solution should be non-negative");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2945</td>
    <td class="codeLine">  assert(X.isNonNegative() && "Solution should be non-negative");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2946</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2946</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2947</td>
    <td class="codeLine">  if (!InexactSQ && Rem.isZero()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2947</td>
    <td class="codeLine">  if (!InexactSQ && Rem.isZero()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2948</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << __func__ << ": solution (root): " << X << '\n');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2948</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << __func__ << ": solution (root): " << X << '\n');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2949</td>
    <td class="codeLine">    return X;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2949</td>
    <td class="codeLine">    return X;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2950</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2950</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2951</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2951</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2952</td>
    <td class="codeLine">  assert((SQ*SQ).sle(D) && "SQ = |_sqrt(D)_|, so SQ*SQ <= D");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2952</td>
    <td class="codeLine">  assert((SQ*SQ).sle(D) && "SQ = |_sqrt(D)_|, so SQ*SQ <= D");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2953</td>
    <td class="codeLine">  // The exact value of the square root of D should be between SQ and SQ+1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2953</td>
    <td class="codeLine">  // The exact value of the square root of D should be between SQ and SQ+1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2954</td>
    <td class="codeLine">  // This implies that the solution should be between that corresponding to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2954</td>
    <td class="codeLine">  // This implies that the solution should be between that corresponding to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2955</td>
    <td class="codeLine">  // SQ (i.e. X) and that corresponding to SQ+1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2955</td>
    <td class="codeLine">  // SQ (i.e. X) and that corresponding to SQ+1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2956</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2956</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2957</td>
    <td class="codeLine">  // The calculated X cannot be greater than the exact (real) solution.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2957</td>
    <td class="codeLine">  // The calculated X cannot be greater than the exact (real) solution.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2958</td>
    <td class="codeLine">  // Actually it must be strictly less than the exact solution, while</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2958</td>
    <td class="codeLine">  // Actually it must be strictly less than the exact solution, while</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2959</td>
    <td class="codeLine">  // X+1 will be greater than or equal to it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2959</td>
    <td class="codeLine">  // X+1 will be greater than or equal to it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2960</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2960</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2961</td>
    <td class="codeLine">  APInt VX = (A*X + B)*X + C;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2961</td>
    <td class="codeLine">  APInt VX = (A*X + B)*X + C;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2962</td>
    <td class="codeLine">  APInt VY = VX + TwoA*X + A + B;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2962</td>
    <td class="codeLine">  APInt VY = VX + TwoA*X + A + B;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2963</td>
    <td class="codeLine">  bool SignChange =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2963</td>
    <td class="codeLine">  bool SignChange =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2964</td>
    <td class="codeLine">      VX.isNegative() != VY.isNegative() || VX.isZero() != VY.isZero();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2964</td>
    <td class="codeLine">      VX.isNegative() != VY.isNegative() || VX.isZero() != VY.isZero();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2965</td>
    <td class="codeLine">  // If the sign did not change between X and X+1, X is not a valid solution.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2965</td>
    <td class="codeLine">  // If the sign did not change between X and X+1, X is not a valid solution.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2966</td>
    <td class="codeLine">  // This could happen when the actual (exact) roots don't have an integer</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2966</td>
    <td class="codeLine">  // This could happen when the actual (exact) roots don't have an integer</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2967</td>
    <td class="codeLine">  // between them, so they would both be contained between X and X+1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2967</td>
    <td class="codeLine">  // between them, so they would both be contained between X and X+1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2968</td>
    <td class="codeLine">  if (!SignChange) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2968</td>
    <td class="codeLine">  if (!SignChange) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2969</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << __func__ << ": no valid solution\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2969</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << __func__ << ": no valid solution\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2970</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2970</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2971</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2971</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2972</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2972</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2973</td>
    <td class="codeLine">  X += 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2973</td>
    <td class="codeLine">  X += 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2974</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << __func__ << ": solution (wrap): " << X << '\n');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2974</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << __func__ << ": solution (wrap): " << X << '\n');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2975</td>
    <td class="codeLine">  return X;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2975</td>
    <td class="codeLine">  return X;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2976</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2976</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2977</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2977</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2978</td>
    <td class="codeLine">std::optional<unsigned></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2978</td>
    <td class="codeLine">std::optional<unsigned></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2979</td>
    <td class="codeLine">llvm::APIntOps::GetMostSignificantDifferentBit(const APInt &A, const APInt &B) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2979</td>
    <td class="codeLine">llvm::APIntOps::GetMostSignificantDifferentBit(const APInt &A, const APInt &B) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2980</td>
    <td class="codeLine">  assert(A.getBitWidth() == B.getBitWidth() && "Must have the same bitwidth");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2980</td>
    <td class="codeLine">  assert(A.getBitWidth() == B.getBitWidth() && "Must have the same bitwidth");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2981</td>
    <td class="codeLine">  if (A == B)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2981</td>
    <td class="codeLine">  if (A == B)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2982</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2982</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2983</td>
    <td class="codeLine">  return A.getBitWidth() - ((A ^ B).countl_zero() + 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2983</td>
    <td class="codeLine">  return A.getBitWidth() - ((A ^ B).countl_zero() + 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2984</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2984</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2985</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2985</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2986</td>
    <td class="codeLine">APInt llvm::APIntOps::ScaleBitMask(const APInt &A, unsigned NewBitWidth,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2986</td>
    <td class="codeLine">APInt llvm::APIntOps::ScaleBitMask(const APInt &A, unsigned NewBitWidth,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2987</td>
    <td class="codeLine">                                   bool MatchAllBits) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2987</td>
    <td class="codeLine">                                   bool MatchAllBits) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2988</td>
    <td class="codeLine">  unsigned OldBitWidth = A.getBitWidth();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2988</td>
    <td class="codeLine">  unsigned OldBitWidth = A.getBitWidth();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2989</td>
    <td class="codeLine">  assert((((OldBitWidth % NewBitWidth) == 0) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2989</td>
    <td class="codeLine">  assert((((OldBitWidth % NewBitWidth) == 0) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2990</td>
    <td class="codeLine">          ((NewBitWidth % OldBitWidth) == 0)) &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2990</td>
    <td class="codeLine">          ((NewBitWidth % OldBitWidth) == 0)) &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2991</td>
    <td class="codeLine">         "One size should be a multiple of the other one. "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2991</td>
    <td class="codeLine">         "One size should be a multiple of the other one. "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2992</td>
    <td class="codeLine">         "Can't do fractional scaling.");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2992</td>
    <td class="codeLine">         "Can't do fractional scaling.");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2993</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2993</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2994</td>
    <td class="codeLine">  // Check for matching bitwidths.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2994</td>
    <td class="codeLine">  // Check for matching bitwidths.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2995</td>
    <td class="codeLine">  if (OldBitWidth == NewBitWidth)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2995</td>
    <td class="codeLine">  if (OldBitWidth == NewBitWidth)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2996</td>
    <td class="codeLine">    return A;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2996</td>
    <td class="codeLine">    return A;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2997</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2997</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2998</td>
    <td class="codeLine">  APInt NewA = APInt::getZero(NewBitWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2998</td>
    <td class="codeLine">  APInt NewA = APInt::getZero(NewBitWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2999</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2999</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3000</td>
    <td class="codeLine">  // Check for null input.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3000</td>
    <td class="codeLine">  // Check for null input.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3001</td>
    <td class="codeLine">  if (A.isZero())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3001</td>
    <td class="codeLine">  if (A.isZero())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3002</td>
    <td class="codeLine">    return NewA;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3002</td>
    <td class="codeLine">    return NewA;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3003</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3003</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3004</td>
    <td class="codeLine">  if (NewBitWidth > OldBitWidth) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3004</td>
    <td class="codeLine">  if (NewBitWidth > OldBitWidth) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3005</td>
    <td class="codeLine">    // Repeat bits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3005</td>
    <td class="codeLine">    // Repeat bits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3006</td>
    <td class="codeLine">    unsigned Scale = NewBitWidth / OldBitWidth;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3006</td>
    <td class="codeLine">    unsigned Scale = NewBitWidth / OldBitWidth;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3007</td>
    <td class="codeLine">    for (unsigned i = 0; i != OldBitWidth; ++i)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3007</td>
    <td class="codeLine">    for (unsigned i = 0; i != OldBitWidth; ++i)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3008</td>
    <td class="codeLine">      if (A[i])</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3008</td>
    <td class="codeLine">      if (A[i])</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3009</td>
    <td class="codeLine">        NewA.setBits(i * Scale, (i + 1) * Scale);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3009</td>
    <td class="codeLine">        NewA.setBits(i * Scale, (i + 1) * Scale);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3010</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3010</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3011</td>
    <td class="codeLine">    unsigned Scale = OldBitWidth / NewBitWidth;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3011</td>
    <td class="codeLine">    unsigned Scale = OldBitWidth / NewBitWidth;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3012</td>
    <td class="codeLine">    for (unsigned i = 0; i != NewBitWidth; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3012</td>
    <td class="codeLine">    for (unsigned i = 0; i != NewBitWidth; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3013</td>
    <td class="codeLine">      if (MatchAllBits) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3013</td>
    <td class="codeLine">      if (MatchAllBits) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3014</td>
    <td class="codeLine">        if (A.extractBits(Scale, i * Scale).isAllOnes())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3014</td>
    <td class="codeLine">        if (A.extractBits(Scale, i * Scale).isAllOnes())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3015</td>
    <td class="codeLine">          NewA.setBit(i);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3015</td>
    <td class="codeLine">          NewA.setBit(i);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3016</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3016</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3017</td>
    <td class="codeLine">        if (!A.extractBits(Scale, i * Scale).isZero())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3017</td>
    <td class="codeLine">        if (!A.extractBits(Scale, i * Scale).isZero())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3018</td>
    <td class="codeLine">          NewA.setBit(i);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3018</td>
    <td class="codeLine">          NewA.setBit(i);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3019</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3019</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3020</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3020</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3021</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3021</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3022</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3022</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3023</td>
    <td class="codeLine">  return NewA;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3023</td>
    <td class="codeLine">  return NewA;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3024</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3024</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3025</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3025</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3026</td>
    <td class="codeLine">/// StoreIntToMemory - Fills the StoreBytes bytes of memory starting from Dst</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3026</td>
    <td class="codeLine">/// StoreIntToMemory - Fills the StoreBytes bytes of memory starting from Dst</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3027</td>
    <td class="codeLine">/// with the integer held in IntVal.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3027</td>
    <td class="codeLine">/// with the integer held in IntVal.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3028</td>
    <td class="codeLine">void llvm::StoreIntToMemory(const APInt &IntVal, uint8_t *Dst,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3028</td>
    <td class="codeLine">void llvm::StoreIntToMemory(const APInt &IntVal, uint8_t *Dst,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3029</td>
    <td class="codeLine">                            unsigned StoreBytes) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3029</td>
    <td class="codeLine">                            unsigned StoreBytes) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3030</td>
    <td class="codeLine">  assert((IntVal.getBitWidth()+7)/8 >= StoreBytes && "Integer too small!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3030</td>
    <td class="codeLine">  assert((IntVal.getBitWidth()+7)/8 >= StoreBytes && "Integer too small!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3031</td>
    <td class="codeLine">  const uint8_t *Src = (const uint8_t *)IntVal.getRawData();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3031</td>
    <td class="codeLine">  const uint8_t *Src = (const uint8_t *)IntVal.getRawData();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3032</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3032</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3033</td>
    <td class="codeLine">  if (sys::IsLittleEndianHost) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3033</td>
    <td class="codeLine">  if (sys::IsLittleEndianHost) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3034</td>
    <td class="codeLine">    // Little-endian host - the source is ordered from LSB to MSB.  Order the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3034</td>
    <td class="codeLine">    // Little-endian host - the source is ordered from LSB to MSB.  Order the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3035</td>
    <td class="codeLine">    // destination from LSB to MSB: Do a straight copy.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3035</td>
    <td class="codeLine">    // destination from LSB to MSB: Do a straight copy.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3036</td>
    <td class="codeLine">    memcpy(Dst, Src, StoreBytes);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3036</td>
    <td class="codeLine">    memcpy(Dst, Src, StoreBytes);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3037</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3037</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3038</td>
    <td class="codeLine">    // Big-endian host - the source is an array of 64 bit words ordered from</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3038</td>
    <td class="codeLine">    // Big-endian host - the source is an array of 64 bit words ordered from</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3039</td>
    <td class="codeLine">    // LSW to MSW.  Each word is ordered from MSB to LSB.  Order the destination</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3039</td>
    <td class="codeLine">    // LSW to MSW.  Each word is ordered from MSB to LSB.  Order the destination</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3040</td>
    <td class="codeLine">    // from MSB to LSB: Reverse the word order, but not the bytes in a word.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3040</td>
    <td class="codeLine">    // from MSB to LSB: Reverse the word order, but not the bytes in a word.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3041</td>
    <td class="codeLine">    while (StoreBytes > sizeof(uint64_t)) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3041</td>
    <td class="codeLine">    while (StoreBytes > sizeof(uint64_t)) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3042</td>
    <td class="codeLine">      StoreBytes -= sizeof(uint64_t);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3042</td>
    <td class="codeLine">      StoreBytes -= sizeof(uint64_t);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3043</td>
    <td class="codeLine">      // May not be aligned so use memcpy.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3043</td>
    <td class="codeLine">      // May not be aligned so use memcpy.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3044</td>
    <td class="codeLine">      memcpy(Dst + StoreBytes, Src, sizeof(uint64_t));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3044</td>
    <td class="codeLine">      memcpy(Dst + StoreBytes, Src, sizeof(uint64_t));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3045</td>
    <td class="codeLine">      Src += sizeof(uint64_t);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3045</td>
    <td class="codeLine">      Src += sizeof(uint64_t);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3046</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3046</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3047</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3047</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3048</td>
    <td class="codeLine">    memcpy(Dst, Src + sizeof(uint64_t) - StoreBytes, StoreBytes);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3048</td>
    <td class="codeLine">    memcpy(Dst, Src + sizeof(uint64_t) - StoreBytes, StoreBytes);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3049</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3049</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3050</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3050</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3051</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3051</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3052</td>
    <td class="codeLine">/// LoadIntFromMemory - Loads the integer stored in the LoadBytes bytes starting</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3052</td>
    <td class="codeLine">/// LoadIntFromMemory - Loads the integer stored in the LoadBytes bytes starting</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3053</td>
    <td class="codeLine">/// from Src into IntVal, which is assumed to be wide enough and to hold zero.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3053</td>
    <td class="codeLine">/// from Src into IntVal, which is assumed to be wide enough and to hold zero.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3054</td>
    <td class="codeLine">void llvm::LoadIntFromMemory(APInt &IntVal, const uint8_t *Src,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3054</td>
    <td class="codeLine">void llvm::LoadIntFromMemory(APInt &IntVal, const uint8_t *Src,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3055</td>
    <td class="codeLine">                             unsigned LoadBytes) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3055</td>
    <td class="codeLine">                             unsigned LoadBytes) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3056</td>
    <td class="codeLine">  assert((IntVal.getBitWidth()+7)/8 >= LoadBytes && "Integer too small!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3056</td>
    <td class="codeLine">  assert((IntVal.getBitWidth()+7)/8 >= LoadBytes && "Integer too small!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3057</td>
    <td class="codeLine">  uint8_t *Dst = reinterpret_cast<uint8_t *>(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3057</td>
    <td class="codeLine">  uint8_t *Dst = reinterpret_cast<uint8_t *>(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3058</td>
    <td class="codeLine">                   const_cast<uint64_t *>(IntVal.getRawData()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3058</td>
    <td class="codeLine">                   const_cast<uint64_t *>(IntVal.getRawData()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3059</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3059</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3060</td>
    <td class="codeLine">  if (sys::IsLittleEndianHost)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3060</td>
    <td class="codeLine">  if (sys::IsLittleEndianHost)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3061</td>
    <td class="codeLine">    // Little-endian host - the destination must be ordered from LSB to MSB.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3061</td>
    <td class="codeLine">    // Little-endian host - the destination must be ordered from LSB to MSB.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3062</td>
    <td class="codeLine">    // The source is ordered from LSB to MSB: Do a straight copy.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3062</td>
    <td class="codeLine">    // The source is ordered from LSB to MSB: Do a straight copy.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3063</td>
    <td class="codeLine">    memcpy(Dst, Src, LoadBytes);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3063</td>
    <td class="codeLine">    memcpy(Dst, Src, LoadBytes);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3064</td>
    <td class="codeLine">  else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3064</td>
    <td class="codeLine">  else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3065</td>
    <td class="codeLine">    // Big-endian - the destination is an array of 64 bit words ordered from</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3065</td>
    <td class="codeLine">    // Big-endian - the destination is an array of 64 bit words ordered from</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3066</td>
    <td class="codeLine">    // LSW to MSW.  Each word must be ordered from MSB to LSB.  The source is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3066</td>
    <td class="codeLine">    // LSW to MSW.  Each word must be ordered from MSB to LSB.  The source is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3067</td>
    <td class="codeLine">    // ordered from MSB to LSB: Reverse the word order, but not the bytes in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3067</td>
    <td class="codeLine">    // ordered from MSB to LSB: Reverse the word order, but not the bytes in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3068</td>
    <td class="codeLine">    // a word.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3068</td>
    <td class="codeLine">    // a word.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3069</td>
    <td class="codeLine">    while (LoadBytes > sizeof(uint64_t)) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3069</td>
    <td class="codeLine">    while (LoadBytes > sizeof(uint64_t)) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3070</td>
    <td class="codeLine">      LoadBytes -= sizeof(uint64_t);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3070</td>
    <td class="codeLine">      LoadBytes -= sizeof(uint64_t);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3071</td>
    <td class="codeLine">      // May not be aligned so use memcpy.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3071</td>
    <td class="codeLine">      // May not be aligned so use memcpy.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3072</td>
    <td class="codeLine">      memcpy(Dst, Src + LoadBytes, sizeof(uint64_t));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3072</td>
    <td class="codeLine">      memcpy(Dst, Src + LoadBytes, sizeof(uint64_t));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3073</td>
    <td class="codeLine">      Dst += sizeof(uint64_t);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3073</td>
    <td class="codeLine">      Dst += sizeof(uint64_t);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3074</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3074</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3075</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3075</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3076</td>
    <td class="codeLine">    memcpy(Dst + sizeof(uint64_t) - LoadBytes, Src, LoadBytes);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3076</td>
    <td class="codeLine">    memcpy(Dst + sizeof(uint64_t) - LoadBytes, Src, LoadBytes);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3077</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3077</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3078</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3078</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3079</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3079</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
</table>
    </div>
    <button id="myBtn" onclick="topFunction()" title="Go to top" type="button">Top</button>
    <script src="../Javascript/drop_down.js"></script>
    <script src="../Javascript/top_button.js"></script>
  </body>
</html>