<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>ScheduleDAG.h</title>
    <link rel="stylesheet" href="../Style/style.css" />
  </head>
  <body>
    <div class="headerDiv">
      <h1>
        Code Coverage
      </h1>
      <p>
        Source file: /home/nikola/Desktop/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
      </p>
    </div>
    <button class="collapsible" type="button">Open Summary Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Summary Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line number</th>
    <th class="mainTh">Line</th>
    <th class="mainTh">Number of hits</th>
    <th class="mainTh">Tests that cover line</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="">//===- llvm/CodeGen/ScheduleDAG.h - Common Base Class -----------*- C++ -*-===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="">/// \file Implements the ScheduleDAG class, which is used as the common base</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="">/// class for instruction schedulers. This encapsulates the scheduling DAG,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="">/// which is shared between SelectionDAG and MachineInstr scheduling.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="">#ifndef LLVM_CODEGEN_SCHEDULEDAG_H</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="">#define LLVM_CODEGEN_SCHEDULEDAG_H</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="">#include "llvm/ADT/BitVector.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="">#include "llvm/ADT/PointerIntPair.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="">#include "llvm/ADT/SmallVector.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="">#include "llvm/ADT/iterator.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="">#include "llvm/CodeGen/MachineInstr.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="">#include "llvm/CodeGen/TargetLowering.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="">#include "llvm/Support/ErrorHandling.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="">#include <cassert></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="">#include <cstddef></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="">#include <iterator></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="">#include <string></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="">#include <vector></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="">namespace llvm {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="">template <class GraphType> struct GraphTraits;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="">template<class Graph> class GraphWriter;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="">class LLVMTargetMachine;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="">class MachineFunction;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="">class MachineRegisterInfo;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="">class MCInstrDesc;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="">struct MCSchedClassDesc;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="">class SDNode;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="">class SUnit;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="">class ScheduleDAG;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="">class TargetInstrInfo;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="">class TargetRegisterClass;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="">class TargetRegisterInfo;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="">  /// Scheduling dependency. This represents one direction of an edge in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="">  /// scheduling DAG.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="">  class SDep {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="">  public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="">    /// These are the different kinds of scheduling dependencies.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="">    enum Kind {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="">      Data,        ///< Regular data dependence (aka true-dependence).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="">      Anti,        ///< A register anti-dependence (aka WAR).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="">      Output,      ///< A register output-dependence (aka WAW).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="">      Order        ///< Any other ordering dependency.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="">    };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="">    // Strong dependencies must be respected by the scheduler. Artificial</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="">    // dependencies may be removed only if they are redundant with another</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="">    // strong dependence.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="">    // Weak dependencies may be violated by the scheduling strategy, but only if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="">    // the strategy can prove it is correct to do so.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="">    // Strong OrderKinds must occur before "Weak".</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="">    // Weak OrderKinds must occur after "Weak".</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="">    enum OrderKind {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="">      Barrier,      ///< An unknown scheduling barrier.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="">      MayAliasMem,  ///< Nonvolatile load/Store instructions that may alias.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="">      MustAliasMem, ///< Nonvolatile load/Store instructions that must alias.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="">      Artificial,   ///< Arbitrary strong DAG edge (no real dependence).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="">      Weak,         ///< Arbitrary weak DAG edge.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="">      Cluster       ///< Weak DAG edge linking a chain of clustered instrs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="">    };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="">  private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="">    /// A pointer to the depending/depended-on SUnit, and an enum</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="">    /// indicating the kind of the dependency.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="">    PointerIntPair<SUnit *, 2, Kind> Dep;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="">    /// A union discriminated by the dependence kind.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="">    union {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="">      /// For Data, Anti, and Output dependencies, the associated register. For</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="">      /// Data dependencies that don't currently have a register/ assigned, this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="">      /// is set to zero.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="">      unsigned Reg;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="">      /// Additional information about Order dependencies.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="">      unsigned OrdKind; // enum OrderKind</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="">    } Contents;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="">    /// The time associated with this edge. Often this is just the value of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="">    /// Latency field of the predecessor, however advanced models may provide</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="">    /// additional information about specific edges.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="">    unsigned Latency = 0u;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="">  public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="">    /// Constructs a null SDep. This is only for use by container classes which</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="">    /// require default constructors. SUnits may not/ have null SDep edges.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="uncoveredLine">    SDep() : Dep(nullptr, Data) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="">    /// Constructs an SDep with the specified values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="coveredLine">    SDep(SUnit *S, Kind kind, unsigned Reg)</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="coveredLine">      : Dep(S, kind), Contents() {</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="coveredLine">      switch (kind) {</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="uncoveredLine">      default:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="uncoveredLine">        llvm_unreachable("Reg given for non-register dependence!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="uncoveredLine">      case Anti:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="">      case Output:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="uncoveredLine">        assert(Reg != 0 &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="">               "SDep::Anti and SDep::Output must use a non-zero Reg!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="uncoveredLine">        Contents.Reg = Reg;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="uncoveredLine">        Latency = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="coveredLine">      case Data:</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="coveredLine">        Contents.Reg = Reg;</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="coveredLine">        Latency = 1;</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="coveredLine">        break;</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="coveredLine">    }</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="coveredLine">    SDep(SUnit *S, OrderKind kind)</td>
    <td>18</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="coveredLine">      : Dep(S, Order), Contents(), Latency(0) {</td>
    <td>18</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="coveredLine">      Contents.OrdKind = kind;</td>
    <td>18</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="coveredLine">    }</td>
    <td>18</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="">    /// Returns true if the specified SDep is equivalent except for latency.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="">    bool overlaps(const SDep &Other) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="uncoveredLine">    bool operator==(const SDep &Other) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="uncoveredLine">      return overlaps(Other) && Latency == Other.Latency;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="">    bool operator!=(const SDep &Other) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="">      return !operator==(Other);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="">    /// Returns the latency value for this edge, which roughly means the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="">    /// minimum number of cycles that must elapse between the predecessor and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="">    /// the successor, given that they have this edge between them.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="coveredLine">    unsigned getLatency() const {</td>
    <td>68</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="coveredLine">      return Latency;</td>
    <td>68</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="">    /// Sets the latency for this edge.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="coveredLine">    void setLatency(unsigned Lat) {</td>
    <td>34</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="coveredLine">      Latency = Lat;</td>
    <td>34</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="coveredLine">    }</td>
    <td>34</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="">    //// Returns the SUnit to which this edge points.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="">    SUnit *getSUnit() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="">    //// Assigns the SUnit to which this edge points.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="">    void setSUnit(SUnit *SU);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="">    /// Returns an enum value representing the kind of the dependence.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="">    Kind getKind() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="">    /// Shorthand for getKind() != SDep::Data.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="coveredLine">    bool isCtrl() const {</td>
    <td>72</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="coveredLine">      return getKind() != Data;</td>
    <td>72</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="">    /// Tests if this is an Order dependence between two memory accesses</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="">    /// where both sides of the dependence access memory in non-volatile and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="">    /// fully modeled ways.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="uncoveredLine">    bool isNormalMemory() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="uncoveredLine">      return getKind() == Order && (Contents.OrdKind == MayAliasMem</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="uncoveredLine">                                    || Contents.OrdKind == MustAliasMem);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="">    /// Tests if this is an Order dependence that is marked as a barrier.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="uncoveredLine">    bool isBarrier() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="uncoveredLine">      return getKind() == Order && Contents.OrdKind == Barrier;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="">    /// Tests if this is could be any kind of memory dependence.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="">    bool isNormalMemoryOrBarrier() const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="">      return (isNormalMemory() || isBarrier());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="">    /// Tests if this is an Order dependence that is marked as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="">    /// "must alias", meaning that the SUnits at either end of the edge have a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="">    /// memory dependence on a known memory location.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="">    bool isMustAlias() const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="">      return getKind() == Order && Contents.OrdKind == MustAliasMem;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="">    /// Tests if this a weak dependence. Weak dependencies are considered DAG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="">    /// edges for height computation and other heuristics, but do not force</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="">    /// ordering. Breaking a weak edge may require the scheduler to compensate,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="">    /// for example by inserting a copy.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="coveredLine">    bool isWeak() const {</td>
    <td>68</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="coveredLine">      return getKind() == Order && Contents.OrdKind >= Weak;</td>
    <td>68</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="">    /// Tests if this is an Order dependence that is marked as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="">    /// "artificial", meaning it isn't necessary for correctness.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="uncoveredLine">    bool isArtificial() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="uncoveredLine">      return getKind() == Order && Contents.OrdKind == Artificial;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="">    /// Tests if this is an Order dependence that is marked as "cluster",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="">    /// meaning it is artificial and wants to be adjacent.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="">    bool isCluster() const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="">      return getKind() == Order && Contents.OrdKind == Cluster;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="">    /// Tests if this is a Data dependence that is associated with a register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="coveredLine">    bool isAssignedRegDep() const {</td>
    <td>68</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="coveredLine">      return getKind() == Data && Contents.Reg != 0;</td>
    <td>68</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="">    /// Returns the register associated with this edge. This is only valid on</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="">    /// Data, Anti, and Output edges. On Data edges, this value may be zero,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="">    /// meaning there is no associated register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="uncoveredLine">    unsigned getReg() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="uncoveredLine">      assert((getKind() == Data || getKind() == Anti || getKind() == Output) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="">             "getReg called on non-register dependence edge!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="uncoveredLine">      return Contents.Reg;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="">    /// Assigns the associated register for this edge. This is only valid on</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="">    /// Data, Anti, and Output edges. On Anti and Output edges, this value must</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="">    /// not be zero. On Data edges, the value may be zero, which would mean that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="">    /// no specific register is associated with this edge.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="">    void setReg(unsigned Reg) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="">      assert((getKind() == Data || getKind() == Anti || getKind() == Output) &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="">             "setReg called on non-register dependence edge!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="">      assert((getKind() != Anti || Reg != 0) &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="">             "SDep::Anti edge cannot use the zero register!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="">      assert((getKind() != Output || Reg != 0) &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="">             "SDep::Output edge cannot use the zero register!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="">      Contents.Reg = Reg;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="">    void dump(const TargetRegisterInfo *TRI = nullptr) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="">  /// Scheduling unit. This is a node in the scheduling DAG.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="">  class SUnit {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="">  private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="">    enum : unsigned { BoundaryID = ~0u };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="">    SDNode *Node = nullptr;        ///< Representative node.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="">    MachineInstr *Instr = nullptr; ///< Alternatively, a MachineInstr.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="">  public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="">    SUnit *OrigNode = nullptr; ///< If not this, the node from which this node</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="">                               /// was cloned. (SD scheduling only)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="">    const MCSchedClassDesc *SchedClass =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="">        nullptr; ///< nullptr or resolved SchedClass.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="">    SmallVector<SDep, 4> Preds;  ///< All sunit predecessors.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="">    SmallVector<SDep, 4> Succs;  ///< All sunit successors.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="">    typedef SmallVectorImpl<SDep>::iterator pred_iterator;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="">    typedef SmallVectorImpl<SDep>::iterator succ_iterator;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="">    typedef SmallVectorImpl<SDep>::const_iterator const_pred_iterator;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="">    typedef SmallVectorImpl<SDep>::const_iterator const_succ_iterator;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="">    unsigned NodeNum = BoundaryID;     ///< Entry # of node in the node vector.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="">    unsigned NodeQueueId = 0;          ///< Queue id of node.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="">    unsigned NumPreds = 0;             ///< # of SDep::Data preds.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="">    unsigned NumSuccs = 0;             ///< # of SDep::Data sucss.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="">    unsigned NumPredsLeft = 0;         ///< # of preds not scheduled.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="">    unsigned NumSuccsLeft = 0;         ///< # of succs not scheduled.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="">    unsigned WeakPredsLeft = 0;        ///< # of weak preds not scheduled.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="">    unsigned WeakSuccsLeft = 0;        ///< # of weak succs not scheduled.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="">    unsigned short NumRegDefsLeft = 0; ///< # of reg defs with no scheduled use.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="">    unsigned short Latency = 0;        ///< Node latency.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="">    bool isVRegCycle      : 1;         ///< May use and def the same vreg.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="">    bool isCall           : 1;         ///< Is a function call.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="">    bool isCallOp         : 1;         ///< Is a function call operand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="">    bool isTwoAddress     : 1;         ///< Is a two-address instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="">    bool isCommutable     : 1;         ///< Is a commutable instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="">    bool hasPhysRegUses   : 1;         ///< Has physreg uses.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="">    bool hasPhysRegDefs   : 1;         ///< Has physreg defs that are being used.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="">    bool hasPhysRegClobbers : 1;       ///< Has any physreg defs, used or not.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="">    bool isPending        : 1;         ///< True once pending.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="">    bool isAvailable      : 1;         ///< True once available.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="">    bool isScheduled      : 1;         ///< True once scheduled.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="">    bool isScheduleHigh   : 1;         ///< True if preferable to schedule high.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="">    bool isScheduleLow    : 1;         ///< True if preferable to schedule low.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="">    bool isCloned         : 1;         ///< True if this node has been cloned.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="">    bool isUnbuffered     : 1;         ///< Uses an unbuffered resource.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="">    bool hasReservedResource : 1;      ///< Uses a reserved resource.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="">    Sched::Preference SchedulingPref = Sched::None; ///< Scheduling preference.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="">  private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="">    bool isDepthCurrent   : 1;         ///< True if Depth is current.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="">    bool isHeightCurrent  : 1;         ///< True if Height is current.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="">    unsigned Depth = 0;                ///< Node depth.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="">    unsigned Height = 0;               ///< Node height.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="">  public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="">    unsigned TopReadyCycle = 0; ///< Cycle relative to start when node is ready.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="">    unsigned BotReadyCycle = 0; ///< Cycle relative to end when node is ready.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="">    const TargetRegisterClass *CopyDstRC =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="">        nullptr; ///< Is a special copy node if != nullptr.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="">    const TargetRegisterClass *CopySrcRC = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="">    /// Constructs an SUnit for pre-regalloc scheduling to represent an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="">    /// SDNode and any nodes flagged to it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="coveredLine">    SUnit(SDNode *node, unsigned nodenum)</td>
    <td>34</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="coveredLine">      : Node(node), NodeNum(nodenum), isVRegCycle(false), isCall(false),</td>
    <td>68</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="coveredLine">        isCallOp(false), isTwoAddress(false), isCommutable(false),</td>
    <td>34</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="coveredLine">        hasPhysRegUses(false), hasPhysRegDefs(false), hasPhysRegClobbers(false),</td>
    <td>34</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="coveredLine">        isPending(false), isAvailable(false), isScheduled(false),</td>
    <td>34</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="coveredLine">        isScheduleHigh(false), isScheduleLow(false), isCloned(false),</td>
    <td>34</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="coveredLine">        isUnbuffered(false), hasReservedResource(false), isDepthCurrent(false),</td>
    <td>34</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="coveredLine">        isHeightCurrent(false) {}</td>
    <td>34</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="">    /// Constructs an SUnit for post-regalloc scheduling to represent a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="">    /// MachineInstr.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="uncoveredLine">    SUnit(MachineInstr *instr, unsigned nodenum)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="uncoveredLine">      : Instr(instr), NodeNum(nodenum), isVRegCycle(false), isCall(false),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="uncoveredLine">        isCallOp(false), isTwoAddress(false), isCommutable(false),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="uncoveredLine">        hasPhysRegUses(false), hasPhysRegDefs(false), hasPhysRegClobbers(false),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="uncoveredLine">        isPending(false), isAvailable(false), isScheduled(false),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="uncoveredLine">        isScheduleHigh(false), isScheduleLow(false), isCloned(false),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="uncoveredLine">        isUnbuffered(false), hasReservedResource(false), isDepthCurrent(false),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="uncoveredLine">        isHeightCurrent(false) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="">    /// Constructs a placeholder SUnit.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="coveredLine">    SUnit()</td>
    <td>32</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="coveredLine">      : isVRegCycle(false), isCall(false), isCallOp(false), isTwoAddress(false),</td>
    <td>32</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="coveredLine">        isCommutable(false), hasPhysRegUses(false), hasPhysRegDefs(false),</td>
    <td>32</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="coveredLine">        hasPhysRegClobbers(false), isPending(false), isAvailable(false),</td>
    <td>32</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="coveredLine">        isScheduled(false), isScheduleHigh(false), isScheduleLow(false),</td>
    <td>32</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="coveredLine">        isCloned(false), isUnbuffered(false), hasReservedResource(false),</td>
    <td>32</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="coveredLine">        isDepthCurrent(false), isHeightCurrent(false) {}</td>
    <td>32</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="">    /// Boundary nodes are placeholders for the boundary of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="">    /// scheduling region.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="">    ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="">    /// BoundaryNodes can have DAG edges, including Data edges, but they do not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="">    /// correspond to schedulable entities (e.g. instructions) and do not have a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="">    /// valid ID. Consequently, always check for boundary nodes before accessing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="">    /// an associative data structure keyed on node ID.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="uncoveredLine">    bool isBoundaryNode() const { return NodeNum == BoundaryID; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="">    /// Assigns the representative SDNode for this SUnit. This may be used</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="">    /// during pre-regalloc scheduling.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="coveredLine">    void setNode(SDNode *N) {</td>
    <td>34</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="coveredLine">      assert(!Instr && "Setting SDNode of SUnit with MachineInstr!");</td>
    <td>34</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="coveredLine">      Node = N;</td>
    <td>34</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="coveredLine">    }</td>
    <td>34</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="">    /// Returns the representative SDNode for this SUnit. This may be used</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="">    /// during pre-regalloc scheduling.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="coveredLine">    SDNode *getNode() const {</td>
    <td>354</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="coveredLine">      assert(!Instr && "Reading SDNode of SUnit with MachineInstr!");</td>
    <td>354</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="coveredLine">      return Node;</td>
    <td>354</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="">    /// Returns true if this SUnit refers to a machine instruction as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="">    /// opposed to an SDNode.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="uncoveredLine">    bool isInstr() const { return Instr; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="">    /// Assigns the instruction for the SUnit. This may be used during</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="">    /// post-regalloc scheduling.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="uncoveredLine">    void setInstr(MachineInstr *MI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="uncoveredLine">      assert(!Node && "Setting MachineInstr of SUnit with SDNode!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="uncoveredLine">      Instr = MI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="">    /// Returns the representative MachineInstr for this SUnit. This may be used</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="">    /// during post-regalloc scheduling.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="uncoveredLine">    MachineInstr *getInstr() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="uncoveredLine">      assert(!Node && "Reading MachineInstr of SUnit with SDNode!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="uncoveredLine">      return Instr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="">    /// Adds the specified edge as a pred of the current node if not already.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="">    /// It also adds the current node as a successor of the specified node.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="">    bool addPred(const SDep &D, bool Required = true);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="">    /// Adds a barrier edge to SU by calling addPred(), with latency 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="">    /// generally or latency 1 for a store followed by a load.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="uncoveredLine">    bool addPredBarrier(SUnit *SU) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="uncoveredLine">      SDep Dep(SU, SDep::Barrier);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="">      unsigned TrueMemOrderLatency =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="uncoveredLine">        ((SU->getInstr()->mayStore() && this->getInstr()->mayLoad()) ? 1 : 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="uncoveredLine">      Dep.setLatency(TrueMemOrderLatency);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="uncoveredLine">      return addPred(Dep);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="">    /// Removes the specified edge as a pred of the current node if it exists.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="">    /// It also removes the current node as a successor of the specified node.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="">    void removePred(const SDep &D);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="">    /// Returns the depth of this node, which is the length of the maximum path</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="">    /// up to any node which has no predecessors.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="uncoveredLine">    unsigned getDepth() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="uncoveredLine">      if (!isDepthCurrent)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="uncoveredLine">        const_cast<SUnit *>(this)->ComputeDepth();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="uncoveredLine">      return Depth;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="">    /// Returns the height of this node, which is the length of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="">    /// maximum path down to any node which has no successors.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="coveredLine">    unsigned getHeight() const {</td>
    <td>166</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="coveredLine">      if (!isHeightCurrent)</td>
    <td>166</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="coveredLine">        const_cast<SUnit *>(this)->ComputeHeight();</td>
    <td>34</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="coveredLine">      return Height;</td>
    <td>166</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="">    /// If NewDepth is greater than this node's depth value, sets it to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="">    /// be the new depth value. This also recursively marks successor nodes</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="">    /// dirty.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="">    void setDepthToAtLeast(unsigned NewDepth);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="">    /// If NewHeight is greater than this node's height value, set it to be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="">    /// the new height value. This also recursively marks predecessor nodes</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="">    /// dirty.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="">    void setHeightToAtLeast(unsigned NewHeight);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="">    /// Sets a flag in this node to indicate that its stored Depth value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="">    /// will require recomputation the next time getDepth() is called.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="">    void setDepthDirty();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="">    /// Sets a flag in this node to indicate that its stored Height value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="">    /// will require recomputation the next time getHeight() is called.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="">    void setHeightDirty();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="">    /// Tests if node N is a predecessor of this node.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="uncoveredLine">    bool isPred(const SUnit *N) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="uncoveredLine">      for (const SDep &Pred : Preds)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="uncoveredLine">        if (Pred.getSUnit() == N)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="uncoveredLine">          return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="">    /// Tests if node N is a successor of this node.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="uncoveredLine">    bool isSucc(const SUnit *N) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="uncoveredLine">      for (const SDep &Succ : Succs)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="uncoveredLine">        if (Succ.getSUnit() == N)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="uncoveredLine">          return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="uncoveredLine">    bool isTopReady() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="uncoveredLine">      return NumPredsLeft == 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="uncoveredLine">    bool isBottomReady() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="uncoveredLine">      return NumSuccsLeft == 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="">    /// Orders this node's predecessor edges such that the critical path</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="">    /// edge occurs first.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="">    void biasCriticalPath();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="">    void dumpAttributes() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="">  private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="">    void ComputeDepth();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="">    void ComputeHeight();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="">  /// Returns true if the specified SDep is equivalent except for latency.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="coveredLine">  inline bool SDep::overlaps(const SDep &Other) const {</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="coveredLine">    if (Dep != Other.Dep)</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="coveredLine">      return false;</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="uncoveredLine">    switch (Dep.getInt()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="uncoveredLine">    case Data:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="">    case Anti:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="">    case Output:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="uncoveredLine">      return Contents.Reg == Other.Contents.Reg;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="uncoveredLine">    case Order:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="uncoveredLine">      return Contents.OrdKind == Other.Contents.OrdKind;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="uncoveredLine">    llvm_unreachable("Invalid dependency kind!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="">  //// Returns the SUnit to which this edge points.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="coveredLine">  inline SUnit *SDep::getSUnit() const { return Dep.getPointer(); }</td>
    <td>148</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="">  //// Assigns the SUnit to which this edge points.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="coveredLine">  inline void SDep::setSUnit(SUnit *SU) { Dep.setPointer(SU); }</td>
    <td>34</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="">  /// Returns an enum value representing the kind of the dependence.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="coveredLine">  inline SDep::Kind SDep::getKind() const { return Dep.getInt(); }</td>
    <td>242</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="">  //===--------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="">  /// This interface is used to plug different priorities computation</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="">  /// algorithms into the list scheduler. It implements the interface of a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="">  /// standard priority queue, where nodes are inserted in arbitrary order and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="">  /// returned in priority order.  The computation of the priority and the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="">  /// representation of the queue are totally up to the implementation to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="">  /// decide.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="">  class SchedulingPriorityQueue {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="">    virtual void anchor();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="">    unsigned CurCycle = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="">    bool HasReadyFilter;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="">  public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="coveredLine">    SchedulingPriorityQueue(bool rf = false) :  HasReadyFilter(rf) {}</td>
    <td>8</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="coveredLine">    virtual ~SchedulingPriorityQueue() = default;</td>
    <td>8</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="">    virtual bool isBottomUp() const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="">    virtual void initNodes(std::vector<SUnit> &SUnits) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="">    virtual void addNode(const SUnit *SU) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="">    virtual void updateNode(const SUnit *SU) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="">    virtual void releaseState() = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="">    virtual bool empty() const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="coveredLine">    bool hasReadyFilter() const { return HasReadyFilter; }</td>
    <td>26</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="">    virtual bool tracksRegPressure() const { return false; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="uncoveredLine">    virtual bool isReady(SUnit *) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="uncoveredLine">      assert(!HasReadyFilter && "The ready filter must override isReady()");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="">    virtual void push(SUnit *U) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="uncoveredLine">    void push_all(const std::vector<SUnit *> &Nodes) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="uncoveredLine">      for (SUnit *SU : Nodes)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="uncoveredLine">        push(SU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="">    virtual SUnit *pop() = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="">    virtual void remove(SUnit *SU) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="uncoveredLine">    virtual void dump(ScheduleDAG *) const {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="">    /// As each node is scheduled, this method is invoked.  This allows the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="">    /// priority function to adjust the priority of related unscheduled nodes,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="">    /// for example.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="">    virtual void scheduledNode(SUnit *) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="">    virtual void unscheduledNode(SUnit *) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="coveredLine">    void setCurCycle(unsigned Cycle) {</td>
    <td>34</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="coveredLine">      CurCycle = Cycle;</td>
    <td>34</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="coveredLine">    }</td>
    <td>34</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="uncoveredLine">    unsigned getCurCycle() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="uncoveredLine">      return CurCycle;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="">  class ScheduleDAG {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="">  public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="">    const LLVMTargetMachine &TM;        ///< Target processor</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="">    const TargetInstrInfo *TII;         ///< Target instruction information</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="">    const TargetRegisterInfo *TRI;      ///< Target processor register info</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="">    MachineFunction &MF;                ///< Machine function</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="">    MachineRegisterInfo &MRI;           ///< Virtual/real register map</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="">    std::vector<SUnit> SUnits;          ///< The scheduling units.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="">    SUnit EntrySU;                      ///< Special node for the region entry.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="">    SUnit ExitSU;                       ///< Special node for the region exit.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="">#ifdef NDEBUG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="">    static const bool StressSched = false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="">#else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="">    bool StressSched;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="">    // This class is designed to be passed by reference only. Copy constructor</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="">    // is declared as deleted here to make the derived classes have deleted</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="">    // implicit-declared copy constructor, which suppresses the warnings from</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="">    // static analyzer when the derived classes own resources that are freed in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="">    // their destructors, but don't have user-written copy constructors (rule</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="">    // of three).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="">    ScheduleDAG(const ScheduleDAG &) = delete;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="">    ScheduleDAG &operator=(const ScheduleDAG &) = delete;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="">    explicit ScheduleDAG(MachineFunction &mf);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="">    virtual ~ScheduleDAG();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="">    /// Clears the DAG state (between regions).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="">    void clearDAG();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="">    /// Returns the MCInstrDesc of this SUnit.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="">    /// Returns NULL for SDNodes without a machine opcode.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="uncoveredLine">    const MCInstrDesc *getInstrDesc(const SUnit *SU) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="uncoveredLine">      if (SU->isInstr()) return &SU->getInstr()->getDesc();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="uncoveredLine">      return getNodeDesc(SU->getNode());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="">    /// Pops up a GraphViz/gv window with the ScheduleDAG rendered using 'dot'.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="">    virtual void viewGraph(const Twine &Name, const Twine &Title);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="">    virtual void viewGraph();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="">    virtual void dumpNode(const SUnit &SU) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="">    virtual void dump() const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="">    void dumpNodeName(const SUnit &SU) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="">    /// Returns a label for an SUnit node in a visualization of the ScheduleDAG.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="">    virtual std::string getGraphNodeLabel(const SUnit *SU) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="">    /// Returns a label for the region of code covered by the DAG.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="">    virtual std::string getDAGName() const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="">    /// Adds custom features for a visualization of the ScheduleDAG.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="uncoveredLine">    virtual void addCustomGraphFeatures(GraphWriter<ScheduleDAG*> &) const {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="">#ifndef NDEBUG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="">    /// Verifies that all SUnits were scheduled and that their state is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="">    /// consistent. Returns the number of scheduled SUnits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="">    unsigned VerifyScheduledDAG(bool isBottomUp);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="">  protected:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="">    void dumpNodeAll(const SUnit &SU) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="">  private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="">    /// Returns the MCInstrDesc of this SDNode or NULL.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="">    const MCInstrDesc *getNodeDesc(const SDNode *Node) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="">  class SUnitIterator {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="">    SUnit *Node;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="">    unsigned Operand;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="">    SUnitIterator(SUnit *N, unsigned Op) : Node(N), Operand(Op) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="">  public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="">    using iterator_category = std::forward_iterator_tag;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="">    using value_type = SUnit;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="">    using difference_type = std::ptrdiff_t;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="">    using pointer = value_type *;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="">    using reference = value_type &;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="">    bool operator==(const SUnitIterator& x) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="">      return Operand == x.Operand;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="">    bool operator!=(const SUnitIterator& x) const { return !operator==(x); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="">    pointer operator*() const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="">      return Node->Preds[Operand].getSUnit();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="">    pointer operator->() const { return operator*(); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="">    SUnitIterator& operator++() {                // Preincrement</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="">      ++Operand;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="">      return *this;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="">    SUnitIterator operator++(int) { // Postincrement</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="">      SUnitIterator tmp = *this; ++*this; return tmp;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="">    static SUnitIterator begin(SUnit *N) { return SUnitIterator(N, 0); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="">    static SUnitIterator end  (SUnit *N) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="">      return SUnitIterator(N, (unsigned)N->Preds.size());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="">    unsigned getOperand() const { return Operand; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="">    const SUnit *getNode() const { return Node; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="">    /// Tests if this is not an SDep::Data dependence.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="">    bool isCtrlDep() const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="">      return getSDep().isCtrl();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="">    bool isArtificialDep() const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="">      return getSDep().isArtificial();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="">    const SDep &getSDep() const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="">      return Node->Preds[Operand];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="">  template <> struct GraphTraits<SUnit*> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="">    typedef SUnit *NodeRef;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="">    typedef SUnitIterator ChildIteratorType;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="">    static NodeRef getEntryNode(SUnit *N) { return N; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="">    static ChildIteratorType child_begin(NodeRef N) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="">      return SUnitIterator::begin(N);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="">    static ChildIteratorType child_end(NodeRef N) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="">      return SUnitIterator::end(N);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="">  template <> struct GraphTraits<ScheduleDAG*> : public GraphTraits<SUnit*> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="">    typedef pointer_iterator<std::vector<SUnit>::iterator> nodes_iterator;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="">    static nodes_iterator nodes_begin(ScheduleDAG *G) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="">      return nodes_iterator(G->SUnits.begin());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="">    static nodes_iterator nodes_end(ScheduleDAG *G) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="">      return nodes_iterator(G->SUnits.end());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="">  /// This class can compute a topological ordering for SUnits and provides</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="">  /// methods for dynamically updating the ordering as new edges are added.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="">  /// This allows a very fast implementation of IsReachable, for example.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="">  class ScheduleDAGTopologicalSort {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="">    /// A reference to the ScheduleDAG's SUnits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="">    std::vector<SUnit> &SUnits;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="">    SUnit *ExitSU;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="">    // Have any new nodes been added?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="">    bool Dirty = false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="">    // Outstanding added edges, that have not been applied to the ordering.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="">    SmallVector<std::pair<SUnit *, SUnit *>, 16> Updates;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="">    /// Maps topological index to the node number.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="">    std::vector<int> Index2Node;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="">    /// Maps the node number to its topological index.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="">    std::vector<int> Node2Index;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="">    /// a set of nodes visited during a DFS traversal.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="">    BitVector Visited;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="">    /// Makes a DFS traversal and mark all nodes affected by the edge insertion.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="">    /// These nodes will later get new topological indexes by means of the Shift</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="">    /// method.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="">    void DFS(const SUnit *SU, int UpperBound, bool& HasLoop);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="">    /// Reassigns topological indexes for the nodes in the DAG to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="">    /// preserve the topological ordering.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="">    void Shift(BitVector& Visited, int LowerBound, int UpperBound);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="">    /// Assigns the topological index to the node n.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="">    void Allocate(int n, int index);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="">    /// Fix the ordering, by either recomputing from scratch or by applying</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="">    /// any outstanding updates. Uses a heuristic to estimate what will be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="">    /// cheaper.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="">    void FixOrder();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="">  public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="">    ScheduleDAGTopologicalSort(std::vector<SUnit> &SUnits, SUnit *ExitSU);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="">    /// Add a SUnit without predecessors to the end of the topological order. It</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="">    /// also must be the first new node added to the DAG.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="">    void AddSUnitWithoutPredecessors(const SUnit *SU);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="">    /// Creates the initial topological ordering from the DAG to be scheduled.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="">    void InitDAGTopologicalSorting();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="">    /// Returns an array of SUs that are both in the successor</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="">    /// subtree of StartSU and in the predecessor subtree of TargetSU.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="">    /// StartSU and TargetSU are not in the array.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="">    /// Success is false if TargetSU is not in the successor subtree of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="">    /// StartSU, else it is true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="">    std::vector<int> GetSubGraph(const SUnit &StartSU, const SUnit &TargetSU,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="">                                 bool &Success);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="">    /// Checks if \p SU is reachable from \p TargetSU.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="">    bool IsReachable(const SUnit *SU, const SUnit *TargetSU);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="">    /// Returns true if addPred(TargetSU, SU) creates a cycle.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="">    bool WillCreateCycle(SUnit *TargetSU, SUnit *SU);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="">    /// Updates the topological ordering to accommodate an edge to be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="">    /// added from SUnit \p X to SUnit \p Y.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="">    void AddPred(SUnit *Y, SUnit *X);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="">    /// Queues an update to the topological ordering to accommodate an edge to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="">    /// be added from SUnit \p X to SUnit \p Y.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="">    void AddPredQueued(SUnit *Y, SUnit *X);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="">    /// Updates the topological ordering to accommodate an an edge to be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="">    /// removed from the specified node \p N from the predecessors of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="">    /// current node \p M.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="">    void RemovePred(SUnit *M, SUnit *N);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="">    /// Mark the ordering as temporarily broken, after a new node has been</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="">    /// added.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="coveredLine">    void MarkDirty() { Dirty = true; }</td>
    <td>8</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="">    typedef std::vector<int>::iterator iterator;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="">    typedef std::vector<int>::const_iterator const_iterator;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="uncoveredLine">    iterator begin() { return Index2Node.begin(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="">    const_iterator begin() const { return Index2Node.begin(); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="uncoveredLine">    iterator end() { return Index2Node.end(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="">    const_iterator end() const { return Index2Node.end(); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="">    typedef std::vector<int>::reverse_iterator reverse_iterator;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="">    typedef std::vector<int>::const_reverse_iterator const_reverse_iterator;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="uncoveredLine">    reverse_iterator rbegin() { return Index2Node.rbegin(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="">    const_reverse_iterator rbegin() const { return Index2Node.rbegin(); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="uncoveredLine">    reverse_iterator rend() { return Index2Node.rend(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="">    const_reverse_iterator rend() const { return Index2Node.rend(); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="">} // end namespace llvm</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="">#endif // LLVM_CODEGEN_SCHEDULEDAG_H</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Functions Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Functions Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Function name</th>
    <th class="mainTh">Number of hits</th>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4SDepC2EPNS_5SUnitENS0_4KindEj</td>
    <td class="numberOfCalls">16</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4SDepC2EPNS_5SUnitENS0_9OrderKindE</td>
    <td class="numberOfCalls">18</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4SDep10setLatencyEj</td>
    <td class="numberOfCalls">34</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4SDep6isCtrlEv</td>
    <td class="numberOfCalls">72</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4SDep6getRegEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5SUnitC2EPNS_6SDNodeEj</td>
    <td class="numberOfCalls">34</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5SUnit7setNodeEPNS_6SDNodeE</td>
    <td class="numberOfCalls">34</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5SUnit7getNodeEv</td>
    <td class="numberOfCalls">354</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4SDep8getSUnitEv</td>
    <td class="numberOfCalls">148</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4SDep7getKindEv</td>
    <td class="numberOfCalls">242</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm11ScheduleDAG22addCustomGraphFeaturesERNS_11GraphWriterIPS0_EE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4SDep10getLatencyEv</td>
    <td class="numberOfCalls">68</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4SDep12isArtificialEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4SDep16isAssignedRegDepEv</td>
    <td class="numberOfCalls">68</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5SUnit8getDepthEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5SUnit9getHeightEv</td>
    <td class="numberOfCalls">166</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5SUnit6isSuccEPKS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4SDep8setSUnitEPNS_5SUnitE</td>
    <td class="numberOfCalls">34</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23SchedulingPriorityQueueC2Eb</td>
    <td class="numberOfCalls">8</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23SchedulingPriorityQueueD0Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23SchedulingPriorityQueueD2Ev</td>
    <td class="numberOfCalls">8</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm23SchedulingPriorityQueue14hasReadyFilterEv</td>
    <td class="numberOfCalls">26</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm23SchedulingPriorityQueue7isReadyEPNS_5SUnitE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm23SchedulingPriorityQueue4dumpEPNS_11ScheduleDAGE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23SchedulingPriorityQueue11setCurCycleEj</td>
    <td class="numberOfCalls">34</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm23SchedulingPriorityQueue11getCurCycleEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm26ScheduleDAGTopologicalSort9MarkDirtyEv</td>
    <td class="numberOfCalls">8</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4SDepC2Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5SUnitC2EPNS_12MachineInstrEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5SUnit14isBoundaryNodeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5SUnit8setInstrEPNS_12MachineInstrE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5SUnit8getInstrEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5SUnit14addPredBarrierEPS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5SUnit7isInstrEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5SUnit6isPredEPKS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm26ScheduleDAGTopologicalSort5beginEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm26ScheduleDAGTopologicalSort3endEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm26ScheduleDAGTopologicalSort6rbeginEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm26ScheduleDAGTopologicalSort4rendEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4SDep6isWeakEv</td>
    <td class="numberOfCalls">68</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23SchedulingPriorityQueue8push_allERKSt6vectorIPNS_5SUnitESaIS3_EE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4SDep14isNormalMemoryEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4SDep9isBarrierEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm11ScheduleDAG12getInstrDescEPKNS_5SUnitE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5SUnit10isTopReadyEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm5SUnit13isBottomReadyEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5SUnitC2Ev</td>
    <td class="numberOfCalls">32</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4SDepeqERKS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4SDep8overlapsERKS0_</td>
    <td class="numberOfCalls">10</td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Coverage Diff</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Coverage Diff</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeline">//===- llvm/CodeGen/ScheduleDAG.h - Common Base Class -----------*- C++ -*-===//</td>
    <td class="lineNumber">1</td>
    <td class="codeline">//===- llvm/CodeGen/ScheduleDAG.h - Common Base Class -----------*- C++ -*-===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeline">/// \file Implements the ScheduleDAG class, which is used as the common base</td>
    <td class="lineNumber">9</td>
    <td class="codeline">/// \file Implements the ScheduleDAG class, which is used as the common base</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeline">/// class for instruction schedulers. This encapsulates the scheduling DAG,</td>
    <td class="lineNumber">10</td>
    <td class="codeline">/// class for instruction schedulers. This encapsulates the scheduling DAG,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeline">/// which is shared between SelectionDAG and MachineInstr scheduling.</td>
    <td class="lineNumber">11</td>
    <td class="codeline">/// which is shared between SelectionDAG and MachineInstr scheduling.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeline">//</td>
    <td class="lineNumber">12</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">13</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeline"></td>
    <td class="lineNumber">14</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeline">#ifndef LLVM_CODEGEN_SCHEDULEDAG_H</td>
    <td class="lineNumber">15</td>
    <td class="codeline">#ifndef LLVM_CODEGEN_SCHEDULEDAG_H</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeline">#define LLVM_CODEGEN_SCHEDULEDAG_H</td>
    <td class="lineNumber">16</td>
    <td class="codeline">#define LLVM_CODEGEN_SCHEDULEDAG_H</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeline"></td>
    <td class="lineNumber">17</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeline">#include "llvm/ADT/BitVector.h"</td>
    <td class="lineNumber">18</td>
    <td class="codeline">#include "llvm/ADT/BitVector.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeline">#include "llvm/ADT/PointerIntPair.h"</td>
    <td class="lineNumber">19</td>
    <td class="codeline">#include "llvm/ADT/PointerIntPair.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeline">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">20</td>
    <td class="codeline">#include "llvm/ADT/SmallVector.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeline">#include "llvm/ADT/iterator.h"</td>
    <td class="lineNumber">21</td>
    <td class="codeline">#include "llvm/ADT/iterator.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeline">#include "llvm/CodeGen/MachineInstr.h"</td>
    <td class="lineNumber">22</td>
    <td class="codeline">#include "llvm/CodeGen/MachineInstr.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/CodeGen/TargetLowering.h"</td>
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/CodeGen/TargetLowering.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/Support/ErrorHandling.h"</td>
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/Support/ErrorHandling.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeline">#include <cassert></td>
    <td class="lineNumber">25</td>
    <td class="codeline">#include <cassert></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeline">#include <cstddef></td>
    <td class="lineNumber">26</td>
    <td class="codeline">#include <cstddef></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeline">#include <iterator></td>
    <td class="lineNumber">27</td>
    <td class="codeline">#include <iterator></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeline">#include <string></td>
    <td class="lineNumber">28</td>
    <td class="codeline">#include <string></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeline">#include <vector></td>
    <td class="lineNumber">29</td>
    <td class="codeline">#include <vector></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeline"></td>
    <td class="lineNumber">30</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeline">namespace llvm {</td>
    <td class="lineNumber">31</td>
    <td class="codeline">namespace llvm {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeline"></td>
    <td class="lineNumber">32</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeline">template <class GraphType> struct GraphTraits;</td>
    <td class="lineNumber">33</td>
    <td class="codeline">template <class GraphType> struct GraphTraits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeline">template<class Graph> class GraphWriter;</td>
    <td class="lineNumber">34</td>
    <td class="codeline">template<class Graph> class GraphWriter;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeline">class LLVMTargetMachine;</td>
    <td class="lineNumber">35</td>
    <td class="codeline">class LLVMTargetMachine;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeline">class MachineFunction;</td>
    <td class="lineNumber">36</td>
    <td class="codeline">class MachineFunction;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeline">class MachineRegisterInfo;</td>
    <td class="lineNumber">37</td>
    <td class="codeline">class MachineRegisterInfo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeline">class MCInstrDesc;</td>
    <td class="lineNumber">38</td>
    <td class="codeline">class MCInstrDesc;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeline">struct MCSchedClassDesc;</td>
    <td class="lineNumber">39</td>
    <td class="codeline">struct MCSchedClassDesc;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeline">class SDNode;</td>
    <td class="lineNumber">40</td>
    <td class="codeline">class SDNode;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeline">class SUnit;</td>
    <td class="lineNumber">41</td>
    <td class="codeline">class SUnit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeline">class ScheduleDAG;</td>
    <td class="lineNumber">42</td>
    <td class="codeline">class ScheduleDAG;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeline">class TargetInstrInfo;</td>
    <td class="lineNumber">43</td>
    <td class="codeline">class TargetInstrInfo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeline">class TargetRegisterClass;</td>
    <td class="lineNumber">44</td>
    <td class="codeline">class TargetRegisterClass;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeline">class TargetRegisterInfo;</td>
    <td class="lineNumber">45</td>
    <td class="codeline">class TargetRegisterInfo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeline"></td>
    <td class="lineNumber">46</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeline">  /// Scheduling dependency. This represents one direction of an edge in the</td>
    <td class="lineNumber">47</td>
    <td class="codeline">  /// Scheduling dependency. This represents one direction of an edge in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeline">  /// scheduling DAG.</td>
    <td class="lineNumber">48</td>
    <td class="codeline">  /// scheduling DAG.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeline">  class SDep {</td>
    <td class="lineNumber">49</td>
    <td class="codeline">  class SDep {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeline">  public:</td>
    <td class="lineNumber">50</td>
    <td class="codeline">  public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeline">    /// These are the different kinds of scheduling dependencies.</td>
    <td class="lineNumber">51</td>
    <td class="codeline">    /// These are the different kinds of scheduling dependencies.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeline">    enum Kind {</td>
    <td class="lineNumber">52</td>
    <td class="codeline">    enum Kind {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeline">      Data,        ///< Regular data dependence (aka true-dependence).</td>
    <td class="lineNumber">53</td>
    <td class="codeline">      Data,        ///< Regular data dependence (aka true-dependence).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeline">      Anti,        ///< A register anti-dependence (aka WAR).</td>
    <td class="lineNumber">54</td>
    <td class="codeline">      Anti,        ///< A register anti-dependence (aka WAR).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeline">      Output,      ///< A register output-dependence (aka WAW).</td>
    <td class="lineNumber">55</td>
    <td class="codeline">      Output,      ///< A register output-dependence (aka WAW).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeline">      Order        ///< Any other ordering dependency.</td>
    <td class="lineNumber">56</td>
    <td class="codeline">      Order        ///< Any other ordering dependency.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeline">    };</td>
    <td class="lineNumber">57</td>
    <td class="codeline">    };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeline"></td>
    <td class="lineNumber">58</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeline">    // Strong dependencies must be respected by the scheduler. Artificial</td>
    <td class="lineNumber">59</td>
    <td class="codeline">    // Strong dependencies must be respected by the scheduler. Artificial</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeline">    // dependencies may be removed only if they are redundant with another</td>
    <td class="lineNumber">60</td>
    <td class="codeline">    // dependencies may be removed only if they are redundant with another</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeline">    // strong dependence.</td>
    <td class="lineNumber">61</td>
    <td class="codeline">    // strong dependence.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">62</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeline">    // Weak dependencies may be violated by the scheduling strategy, but only if</td>
    <td class="lineNumber">63</td>
    <td class="codeline">    // Weak dependencies may be violated by the scheduling strategy, but only if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeline">    // the strategy can prove it is correct to do so.</td>
    <td class="lineNumber">64</td>
    <td class="codeline">    // the strategy can prove it is correct to do so.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">65</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeline">    // Strong OrderKinds must occur before "Weak".</td>
    <td class="lineNumber">66</td>
    <td class="codeline">    // Strong OrderKinds must occur before "Weak".</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeline">    // Weak OrderKinds must occur after "Weak".</td>
    <td class="lineNumber">67</td>
    <td class="codeline">    // Weak OrderKinds must occur after "Weak".</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeline">    enum OrderKind {</td>
    <td class="lineNumber">68</td>
    <td class="codeline">    enum OrderKind {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeline">      Barrier,      ///< An unknown scheduling barrier.</td>
    <td class="lineNumber">69</td>
    <td class="codeline">      Barrier,      ///< An unknown scheduling barrier.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeline">      MayAliasMem,  ///< Nonvolatile load/Store instructions that may alias.</td>
    <td class="lineNumber">70</td>
    <td class="codeline">      MayAliasMem,  ///< Nonvolatile load/Store instructions that may alias.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeline">      MustAliasMem, ///< Nonvolatile load/Store instructions that must alias.</td>
    <td class="lineNumber">71</td>
    <td class="codeline">      MustAliasMem, ///< Nonvolatile load/Store instructions that must alias.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeline">      Artificial,   ///< Arbitrary strong DAG edge (no real dependence).</td>
    <td class="lineNumber">72</td>
    <td class="codeline">      Artificial,   ///< Arbitrary strong DAG edge (no real dependence).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeline">      Weak,         ///< Arbitrary weak DAG edge.</td>
    <td class="lineNumber">73</td>
    <td class="codeline">      Weak,         ///< Arbitrary weak DAG edge.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeline">      Cluster       ///< Weak DAG edge linking a chain of clustered instrs.</td>
    <td class="lineNumber">74</td>
    <td class="codeline">      Cluster       ///< Weak DAG edge linking a chain of clustered instrs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeline">    };</td>
    <td class="lineNumber">75</td>
    <td class="codeline">    };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeline"></td>
    <td class="lineNumber">76</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeline">  private:</td>
    <td class="lineNumber">77</td>
    <td class="codeline">  private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeline">    /// A pointer to the depending/depended-on SUnit, and an enum</td>
    <td class="lineNumber">78</td>
    <td class="codeline">    /// A pointer to the depending/depended-on SUnit, and an enum</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeline">    /// indicating the kind of the dependency.</td>
    <td class="lineNumber">79</td>
    <td class="codeline">    /// indicating the kind of the dependency.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeline">    PointerIntPair<SUnit *, 2, Kind> Dep;</td>
    <td class="lineNumber">80</td>
    <td class="codeline">    PointerIntPair<SUnit *, 2, Kind> Dep;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeline"></td>
    <td class="lineNumber">81</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeline">    /// A union discriminated by the dependence kind.</td>
    <td class="lineNumber">82</td>
    <td class="codeline">    /// A union discriminated by the dependence kind.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeline">    union {</td>
    <td class="lineNumber">83</td>
    <td class="codeline">    union {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeline">      /// For Data, Anti, and Output dependencies, the associated register. For</td>
    <td class="lineNumber">84</td>
    <td class="codeline">      /// For Data, Anti, and Output dependencies, the associated register. For</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeline">      /// Data dependencies that don't currently have a register/ assigned, this</td>
    <td class="lineNumber">85</td>
    <td class="codeline">      /// Data dependencies that don't currently have a register/ assigned, this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeline">      /// is set to zero.</td>
    <td class="lineNumber">86</td>
    <td class="codeline">      /// is set to zero.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeline">      unsigned Reg;</td>
    <td class="lineNumber">87</td>
    <td class="codeline">      unsigned Reg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeline"></td>
    <td class="lineNumber">88</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeline">      /// Additional information about Order dependencies.</td>
    <td class="lineNumber">89</td>
    <td class="codeline">      /// Additional information about Order dependencies.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeline">      unsigned OrdKind; // enum OrderKind</td>
    <td class="lineNumber">90</td>
    <td class="codeline">      unsigned OrdKind; // enum OrderKind</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeline">    } Contents;</td>
    <td class="lineNumber">91</td>
    <td class="codeline">    } Contents;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeline"></td>
    <td class="lineNumber">92</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeline">    /// The time associated with this edge. Often this is just the value of the</td>
    <td class="lineNumber">93</td>
    <td class="codeline">    /// The time associated with this edge. Often this is just the value of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeline">    /// Latency field of the predecessor, however advanced models may provide</td>
    <td class="lineNumber">94</td>
    <td class="codeline">    /// Latency field of the predecessor, however advanced models may provide</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeline">    /// additional information about specific edges.</td>
    <td class="lineNumber">95</td>
    <td class="codeline">    /// additional information about specific edges.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeline">    unsigned Latency = 0u;</td>
    <td class="lineNumber">96</td>
    <td class="codeline">    unsigned Latency = 0u;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeline"></td>
    <td class="lineNumber">97</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeline">  public:</td>
    <td class="lineNumber">98</td>
    <td class="codeline">  public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeline">    /// Constructs a null SDep. This is only for use by container classes which</td>
    <td class="lineNumber">99</td>
    <td class="codeline">    /// Constructs a null SDep. This is only for use by container classes which</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeline">    /// require default constructors. SUnits may not/ have null SDep edges.</td>
    <td class="lineNumber">100</td>
    <td class="codeline">    /// require default constructors. SUnits may not/ have null SDep edges.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeline">    SDep() : Dep(nullptr, Data) {}</td>
    <td class="lineNumber">101</td>
    <td class="codeline">    SDep() : Dep(nullptr, Data) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeline"></td>
    <td class="lineNumber">102</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeline">    /// Constructs an SDep with the specified values.</td>
    <td class="lineNumber">103</td>
    <td class="codeline">    /// Constructs an SDep with the specified values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeline">    SDep(SUnit *S, Kind kind, unsigned Reg)</td>
    <td class="lineNumber">104</td>
    <td class="codeline">    SDep(SUnit *S, Kind kind, unsigned Reg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeline">      : Dep(S, kind), Contents() {</td>
    <td class="lineNumber">105</td>
    <td class="codeline">      : Dep(S, kind), Contents() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeline">      switch (kind) {</td>
    <td class="lineNumber">106</td>
    <td class="codeline">      switch (kind) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeline">      default:</td>
    <td class="lineNumber">107</td>
    <td class="codeline">      default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeline">        llvm_unreachable("Reg given for non-register dependence!");</td>
    <td class="lineNumber">108</td>
    <td class="codeline">        llvm_unreachable("Reg given for non-register dependence!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeline">      case Anti:</td>
    <td class="lineNumber">109</td>
    <td class="codeline">      case Anti:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeline">      case Output:</td>
    <td class="lineNumber">110</td>
    <td class="codeline">      case Output:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeline">        assert(Reg != 0 &&</td>
    <td class="lineNumber">111</td>
    <td class="codeline">        assert(Reg != 0 &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeline">               "SDep::Anti and SDep::Output must use a non-zero Reg!");</td>
    <td class="lineNumber">112</td>
    <td class="codeline">               "SDep::Anti and SDep::Output must use a non-zero Reg!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeline">        Contents.Reg = Reg;</td>
    <td class="lineNumber">113</td>
    <td class="codeline">        Contents.Reg = Reg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeline">        Latency = 0;</td>
    <td class="lineNumber">114</td>
    <td class="codeline">        Latency = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">115</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeline">      case Data:</td>
    <td class="lineNumber">116</td>
    <td class="codeline">      case Data:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeline">        Contents.Reg = Reg;</td>
    <td class="lineNumber">117</td>
    <td class="codeline">        Contents.Reg = Reg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeline">        Latency = 1;</td>
    <td class="lineNumber">118</td>
    <td class="codeline">        Latency = 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">119</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">120</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">121</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeline"></td>
    <td class="lineNumber">122</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeline">    SDep(SUnit *S, OrderKind kind)</td>
    <td class="lineNumber">123</td>
    <td class="codeline">    SDep(SUnit *S, OrderKind kind)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeline">      : Dep(S, Order), Contents(), Latency(0) {</td>
    <td class="lineNumber">124</td>
    <td class="codeline">      : Dep(S, Order), Contents(), Latency(0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeline">      Contents.OrdKind = kind;</td>
    <td class="lineNumber">125</td>
    <td class="codeline">      Contents.OrdKind = kind;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">126</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeline"></td>
    <td class="lineNumber">127</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeline">    /// Returns true if the specified SDep is equivalent except for latency.</td>
    <td class="lineNumber">128</td>
    <td class="codeline">    /// Returns true if the specified SDep is equivalent except for latency.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeline">    bool overlaps(const SDep &Other) const;</td>
    <td class="lineNumber">129</td>
    <td class="codeline">    bool overlaps(const SDep &Other) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeline"></td>
    <td class="lineNumber">130</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeline">    bool operator==(const SDep &Other) const {</td>
    <td class="lineNumber">131</td>
    <td class="codeline">    bool operator==(const SDep &Other) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeline">      return overlaps(Other) && Latency == Other.Latency;</td>
    <td class="lineNumber">132</td>
    <td class="codeline">      return overlaps(Other) && Latency == Other.Latency;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">133</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeline"></td>
    <td class="lineNumber">134</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeline">    bool operator!=(const SDep &Other) const {</td>
    <td class="lineNumber">135</td>
    <td class="codeline">    bool operator!=(const SDep &Other) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeline">      return !operator==(Other);</td>
    <td class="lineNumber">136</td>
    <td class="codeline">      return !operator==(Other);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">137</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeline"></td>
    <td class="lineNumber">138</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeline">    /// Returns the latency value for this edge, which roughly means the</td>
    <td class="lineNumber">139</td>
    <td class="codeline">    /// Returns the latency value for this edge, which roughly means the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeline">    /// minimum number of cycles that must elapse between the predecessor and</td>
    <td class="lineNumber">140</td>
    <td class="codeline">    /// minimum number of cycles that must elapse between the predecessor and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeline">    /// the successor, given that they have this edge between them.</td>
    <td class="lineNumber">141</td>
    <td class="codeline">    /// the successor, given that they have this edge between them.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeline">    unsigned getLatency() const {</td>
    <td class="lineNumber">142</td>
    <td class="codeline">    unsigned getLatency() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeline">      return Latency;</td>
    <td class="lineNumber">143</td>
    <td class="codeline">      return Latency;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">144</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeline"></td>
    <td class="lineNumber">145</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeline">    /// Sets the latency for this edge.</td>
    <td class="lineNumber">146</td>
    <td class="codeline">    /// Sets the latency for this edge.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeline">    void setLatency(unsigned Lat) {</td>
    <td class="lineNumber">147</td>
    <td class="codeline">    void setLatency(unsigned Lat) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeline">      Latency = Lat;</td>
    <td class="lineNumber">148</td>
    <td class="codeline">      Latency = Lat;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">149</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeline"></td>
    <td class="lineNumber">150</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeline">    //// Returns the SUnit to which this edge points.</td>
    <td class="lineNumber">151</td>
    <td class="codeline">    //// Returns the SUnit to which this edge points.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeline">    SUnit *getSUnit() const;</td>
    <td class="lineNumber">152</td>
    <td class="codeline">    SUnit *getSUnit() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeline"></td>
    <td class="lineNumber">153</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeline">    //// Assigns the SUnit to which this edge points.</td>
    <td class="lineNumber">154</td>
    <td class="codeline">    //// Assigns the SUnit to which this edge points.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeline">    void setSUnit(SUnit *SU);</td>
    <td class="lineNumber">155</td>
    <td class="codeline">    void setSUnit(SUnit *SU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeline"></td>
    <td class="lineNumber">156</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeline">    /// Returns an enum value representing the kind of the dependence.</td>
    <td class="lineNumber">157</td>
    <td class="codeline">    /// Returns an enum value representing the kind of the dependence.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeline">    Kind getKind() const;</td>
    <td class="lineNumber">158</td>
    <td class="codeline">    Kind getKind() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeline"></td>
    <td class="lineNumber">159</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeline">    /// Shorthand for getKind() != SDep::Data.</td>
    <td class="lineNumber">160</td>
    <td class="codeline">    /// Shorthand for getKind() != SDep::Data.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeline">    bool isCtrl() const {</td>
    <td class="lineNumber">161</td>
    <td class="codeline">    bool isCtrl() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeline">      return getKind() != Data;</td>
    <td class="lineNumber">162</td>
    <td class="codeline">      return getKind() != Data;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">163</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeline"></td>
    <td class="lineNumber">164</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeline">    /// Tests if this is an Order dependence between two memory accesses</td>
    <td class="lineNumber">165</td>
    <td class="codeline">    /// Tests if this is an Order dependence between two memory accesses</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeline">    /// where both sides of the dependence access memory in non-volatile and</td>
    <td class="lineNumber">166</td>
    <td class="codeline">    /// where both sides of the dependence access memory in non-volatile and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeline">    /// fully modeled ways.</td>
    <td class="lineNumber">167</td>
    <td class="codeline">    /// fully modeled ways.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeline">    bool isNormalMemory() const {</td>
    <td class="lineNumber">168</td>
    <td class="codeline">    bool isNormalMemory() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeline">      return getKind() == Order && (Contents.OrdKind == MayAliasMem</td>
    <td class="lineNumber">169</td>
    <td class="codeline">      return getKind() == Order && (Contents.OrdKind == MayAliasMem</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeline">                                    || Contents.OrdKind == MustAliasMem);</td>
    <td class="lineNumber">170</td>
    <td class="codeline">                                    || Contents.OrdKind == MustAliasMem);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">171</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeline"></td>
    <td class="lineNumber">172</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeline">    /// Tests if this is an Order dependence that is marked as a barrier.</td>
    <td class="lineNumber">173</td>
    <td class="codeline">    /// Tests if this is an Order dependence that is marked as a barrier.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeline">    bool isBarrier() const {</td>
    <td class="lineNumber">174</td>
    <td class="codeline">    bool isBarrier() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeline">      return getKind() == Order && Contents.OrdKind == Barrier;</td>
    <td class="lineNumber">175</td>
    <td class="codeline">      return getKind() == Order && Contents.OrdKind == Barrier;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">176</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeline"></td>
    <td class="lineNumber">177</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeline">    /// Tests if this is could be any kind of memory dependence.</td>
    <td class="lineNumber">178</td>
    <td class="codeline">    /// Tests if this is could be any kind of memory dependence.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeline">    bool isNormalMemoryOrBarrier() const {</td>
    <td class="lineNumber">179</td>
    <td class="codeline">    bool isNormalMemoryOrBarrier() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeline">      return (isNormalMemory() || isBarrier());</td>
    <td class="lineNumber">180</td>
    <td class="codeline">      return (isNormalMemory() || isBarrier());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">181</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeline"></td>
    <td class="lineNumber">182</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeline">    /// Tests if this is an Order dependence that is marked as</td>
    <td class="lineNumber">183</td>
    <td class="codeline">    /// Tests if this is an Order dependence that is marked as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeline">    /// "must alias", meaning that the SUnits at either end of the edge have a</td>
    <td class="lineNumber">184</td>
    <td class="codeline">    /// "must alias", meaning that the SUnits at either end of the edge have a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeline">    /// memory dependence on a known memory location.</td>
    <td class="lineNumber">185</td>
    <td class="codeline">    /// memory dependence on a known memory location.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeline">    bool isMustAlias() const {</td>
    <td class="lineNumber">186</td>
    <td class="codeline">    bool isMustAlias() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeline">      return getKind() == Order && Contents.OrdKind == MustAliasMem;</td>
    <td class="lineNumber">187</td>
    <td class="codeline">      return getKind() == Order && Contents.OrdKind == MustAliasMem;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">188</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeline"></td>
    <td class="lineNumber">189</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeline">    /// Tests if this a weak dependence. Weak dependencies are considered DAG</td>
    <td class="lineNumber">190</td>
    <td class="codeline">    /// Tests if this a weak dependence. Weak dependencies are considered DAG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeline">    /// edges for height computation and other heuristics, but do not force</td>
    <td class="lineNumber">191</td>
    <td class="codeline">    /// edges for height computation and other heuristics, but do not force</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeline">    /// ordering. Breaking a weak edge may require the scheduler to compensate,</td>
    <td class="lineNumber">192</td>
    <td class="codeline">    /// ordering. Breaking a weak edge may require the scheduler to compensate,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeline">    /// for example by inserting a copy.</td>
    <td class="lineNumber">193</td>
    <td class="codeline">    /// for example by inserting a copy.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeline">    bool isWeak() const {</td>
    <td class="lineNumber">194</td>
    <td class="codeline">    bool isWeak() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeline">      return getKind() == Order && Contents.OrdKind >= Weak;</td>
    <td class="lineNumber">195</td>
    <td class="codeline">      return getKind() == Order && Contents.OrdKind >= Weak;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">196</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeline"></td>
    <td class="lineNumber">197</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeline">    /// Tests if this is an Order dependence that is marked as</td>
    <td class="lineNumber">198</td>
    <td class="codeline">    /// Tests if this is an Order dependence that is marked as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeline">    /// "artificial", meaning it isn't necessary for correctness.</td>
    <td class="lineNumber">199</td>
    <td class="codeline">    /// "artificial", meaning it isn't necessary for correctness.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeline">    bool isArtificial() const {</td>
    <td class="lineNumber">200</td>
    <td class="codeline">    bool isArtificial() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeline">      return getKind() == Order && Contents.OrdKind == Artificial;</td>
    <td class="lineNumber">201</td>
    <td class="codeline">      return getKind() == Order && Contents.OrdKind == Artificial;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">202</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeline"></td>
    <td class="lineNumber">203</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeline">    /// Tests if this is an Order dependence that is marked as "cluster",</td>
    <td class="lineNumber">204</td>
    <td class="codeline">    /// Tests if this is an Order dependence that is marked as "cluster",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeline">    /// meaning it is artificial and wants to be adjacent.</td>
    <td class="lineNumber">205</td>
    <td class="codeline">    /// meaning it is artificial and wants to be adjacent.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeline">    bool isCluster() const {</td>
    <td class="lineNumber">206</td>
    <td class="codeline">    bool isCluster() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeline">      return getKind() == Order && Contents.OrdKind == Cluster;</td>
    <td class="lineNumber">207</td>
    <td class="codeline">      return getKind() == Order && Contents.OrdKind == Cluster;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">208</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeline"></td>
    <td class="lineNumber">209</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeline">    /// Tests if this is a Data dependence that is associated with a register.</td>
    <td class="lineNumber">210</td>
    <td class="codeline">    /// Tests if this is a Data dependence that is associated with a register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeline">    bool isAssignedRegDep() const {</td>
    <td class="lineNumber">211</td>
    <td class="codeline">    bool isAssignedRegDep() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeline">      return getKind() == Data && Contents.Reg != 0;</td>
    <td class="lineNumber">212</td>
    <td class="codeline">      return getKind() == Data && Contents.Reg != 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">213</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeline"></td>
    <td class="lineNumber">214</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeline">    /// Returns the register associated with this edge. This is only valid on</td>
    <td class="lineNumber">215</td>
    <td class="codeline">    /// Returns the register associated with this edge. This is only valid on</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeline">    /// Data, Anti, and Output edges. On Data edges, this value may be zero,</td>
    <td class="lineNumber">216</td>
    <td class="codeline">    /// Data, Anti, and Output edges. On Data edges, this value may be zero,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeline">    /// meaning there is no associated register.</td>
    <td class="lineNumber">217</td>
    <td class="codeline">    /// meaning there is no associated register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeline">    unsigned getReg() const {</td>
    <td class="lineNumber">218</td>
    <td class="codeline">    unsigned getReg() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeline">      assert((getKind() == Data || getKind() == Anti || getKind() == Output) &&</td>
    <td class="lineNumber">219</td>
    <td class="codeline">      assert((getKind() == Data || getKind() == Anti || getKind() == Output) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeline">             "getReg called on non-register dependence edge!");</td>
    <td class="lineNumber">220</td>
    <td class="codeline">             "getReg called on non-register dependence edge!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeline">      return Contents.Reg;</td>
    <td class="lineNumber">221</td>
    <td class="codeline">      return Contents.Reg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">222</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeline"></td>
    <td class="lineNumber">223</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeline">    /// Assigns the associated register for this edge. This is only valid on</td>
    <td class="lineNumber">224</td>
    <td class="codeline">    /// Assigns the associated register for this edge. This is only valid on</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeline">    /// Data, Anti, and Output edges. On Anti and Output edges, this value must</td>
    <td class="lineNumber">225</td>
    <td class="codeline">    /// Data, Anti, and Output edges. On Anti and Output edges, this value must</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeline">    /// not be zero. On Data edges, the value may be zero, which would mean that</td>
    <td class="lineNumber">226</td>
    <td class="codeline">    /// not be zero. On Data edges, the value may be zero, which would mean that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeline">    /// no specific register is associated with this edge.</td>
    <td class="lineNumber">227</td>
    <td class="codeline">    /// no specific register is associated with this edge.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeline">    void setReg(unsigned Reg) {</td>
    <td class="lineNumber">228</td>
    <td class="codeline">    void setReg(unsigned Reg) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeline">      assert((getKind() == Data || getKind() == Anti || getKind() == Output) &&</td>
    <td class="lineNumber">229</td>
    <td class="codeline">      assert((getKind() == Data || getKind() == Anti || getKind() == Output) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeline">             "setReg called on non-register dependence edge!");</td>
    <td class="lineNumber">230</td>
    <td class="codeline">             "setReg called on non-register dependence edge!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeline">      assert((getKind() != Anti || Reg != 0) &&</td>
    <td class="lineNumber">231</td>
    <td class="codeline">      assert((getKind() != Anti || Reg != 0) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeline">             "SDep::Anti edge cannot use the zero register!");</td>
    <td class="lineNumber">232</td>
    <td class="codeline">             "SDep::Anti edge cannot use the zero register!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeline">      assert((getKind() != Output || Reg != 0) &&</td>
    <td class="lineNumber">233</td>
    <td class="codeline">      assert((getKind() != Output || Reg != 0) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeline">             "SDep::Output edge cannot use the zero register!");</td>
    <td class="lineNumber">234</td>
    <td class="codeline">             "SDep::Output edge cannot use the zero register!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeline">      Contents.Reg = Reg;</td>
    <td class="lineNumber">235</td>
    <td class="codeline">      Contents.Reg = Reg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">236</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeline"></td>
    <td class="lineNumber">237</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeline">    void dump(const TargetRegisterInfo *TRI = nullptr) const;</td>
    <td class="lineNumber">238</td>
    <td class="codeline">    void dump(const TargetRegisterInfo *TRI = nullptr) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">239</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeline"></td>
    <td class="lineNumber">240</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeline">  /// Scheduling unit. This is a node in the scheduling DAG.</td>
    <td class="lineNumber">241</td>
    <td class="codeline">  /// Scheduling unit. This is a node in the scheduling DAG.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeline">  class SUnit {</td>
    <td class="lineNumber">242</td>
    <td class="codeline">  class SUnit {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeline">  private:</td>
    <td class="lineNumber">243</td>
    <td class="codeline">  private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeline">    enum : unsigned { BoundaryID = ~0u };</td>
    <td class="lineNumber">244</td>
    <td class="codeline">    enum : unsigned { BoundaryID = ~0u };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeline"></td>
    <td class="lineNumber">245</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeline">    SDNode *Node = nullptr;        ///< Representative node.</td>
    <td class="lineNumber">246</td>
    <td class="codeline">    SDNode *Node = nullptr;        ///< Representative node.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeline">    MachineInstr *Instr = nullptr; ///< Alternatively, a MachineInstr.</td>
    <td class="lineNumber">247</td>
    <td class="codeline">    MachineInstr *Instr = nullptr; ///< Alternatively, a MachineInstr.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeline"></td>
    <td class="lineNumber">248</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeline">  public:</td>
    <td class="lineNumber">249</td>
    <td class="codeline">  public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeline">    SUnit *OrigNode = nullptr; ///< If not this, the node from which this node</td>
    <td class="lineNumber">250</td>
    <td class="codeline">    SUnit *OrigNode = nullptr; ///< If not this, the node from which this node</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeline">                               /// was cloned. (SD scheduling only)</td>
    <td class="lineNumber">251</td>
    <td class="codeline">                               /// was cloned. (SD scheduling only)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeline"></td>
    <td class="lineNumber">252</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeline">    const MCSchedClassDesc *SchedClass =</td>
    <td class="lineNumber">253</td>
    <td class="codeline">    const MCSchedClassDesc *SchedClass =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeline">        nullptr; ///< nullptr or resolved SchedClass.</td>
    <td class="lineNumber">254</td>
    <td class="codeline">        nullptr; ///< nullptr or resolved SchedClass.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeline"></td>
    <td class="lineNumber">255</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeline">    SmallVector<SDep, 4> Preds;  ///< All sunit predecessors.</td>
    <td class="lineNumber">256</td>
    <td class="codeline">    SmallVector<SDep, 4> Preds;  ///< All sunit predecessors.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeline">    SmallVector<SDep, 4> Succs;  ///< All sunit successors.</td>
    <td class="lineNumber">257</td>
    <td class="codeline">    SmallVector<SDep, 4> Succs;  ///< All sunit successors.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeline"></td>
    <td class="lineNumber">258</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeline">    typedef SmallVectorImpl<SDep>::iterator pred_iterator;</td>
    <td class="lineNumber">259</td>
    <td class="codeline">    typedef SmallVectorImpl<SDep>::iterator pred_iterator;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeline">    typedef SmallVectorImpl<SDep>::iterator succ_iterator;</td>
    <td class="lineNumber">260</td>
    <td class="codeline">    typedef SmallVectorImpl<SDep>::iterator succ_iterator;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeline">    typedef SmallVectorImpl<SDep>::const_iterator const_pred_iterator;</td>
    <td class="lineNumber">261</td>
    <td class="codeline">    typedef SmallVectorImpl<SDep>::const_iterator const_pred_iterator;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeline">    typedef SmallVectorImpl<SDep>::const_iterator const_succ_iterator;</td>
    <td class="lineNumber">262</td>
    <td class="codeline">    typedef SmallVectorImpl<SDep>::const_iterator const_succ_iterator;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeline"></td>
    <td class="lineNumber">263</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeline">    unsigned NodeNum = BoundaryID;     ///< Entry # of node in the node vector.</td>
    <td class="lineNumber">264</td>
    <td class="codeline">    unsigned NodeNum = BoundaryID;     ///< Entry # of node in the node vector.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeline">    unsigned NodeQueueId = 0;          ///< Queue id of node.</td>
    <td class="lineNumber">265</td>
    <td class="codeline">    unsigned NodeQueueId = 0;          ///< Queue id of node.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeline">    unsigned NumPreds = 0;             ///< # of SDep::Data preds.</td>
    <td class="lineNumber">266</td>
    <td class="codeline">    unsigned NumPreds = 0;             ///< # of SDep::Data preds.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeline">    unsigned NumSuccs = 0;             ///< # of SDep::Data sucss.</td>
    <td class="lineNumber">267</td>
    <td class="codeline">    unsigned NumSuccs = 0;             ///< # of SDep::Data sucss.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeline">    unsigned NumPredsLeft = 0;         ///< # of preds not scheduled.</td>
    <td class="lineNumber">268</td>
    <td class="codeline">    unsigned NumPredsLeft = 0;         ///< # of preds not scheduled.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeline">    unsigned NumSuccsLeft = 0;         ///< # of succs not scheduled.</td>
    <td class="lineNumber">269</td>
    <td class="codeline">    unsigned NumSuccsLeft = 0;         ///< # of succs not scheduled.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeline">    unsigned WeakPredsLeft = 0;        ///< # of weak preds not scheduled.</td>
    <td class="lineNumber">270</td>
    <td class="codeline">    unsigned WeakPredsLeft = 0;        ///< # of weak preds not scheduled.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeline">    unsigned WeakSuccsLeft = 0;        ///< # of weak succs not scheduled.</td>
    <td class="lineNumber">271</td>
    <td class="codeline">    unsigned WeakSuccsLeft = 0;        ///< # of weak succs not scheduled.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeline">    unsigned short NumRegDefsLeft = 0; ///< # of reg defs with no scheduled use.</td>
    <td class="lineNumber">272</td>
    <td class="codeline">    unsigned short NumRegDefsLeft = 0; ///< # of reg defs with no scheduled use.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeline">    unsigned short Latency = 0;        ///< Node latency.</td>
    <td class="lineNumber">273</td>
    <td class="codeline">    unsigned short Latency = 0;        ///< Node latency.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeline">    bool isVRegCycle      : 1;         ///< May use and def the same vreg.</td>
    <td class="lineNumber">274</td>
    <td class="codeline">    bool isVRegCycle      : 1;         ///< May use and def the same vreg.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeline">    bool isCall           : 1;         ///< Is a function call.</td>
    <td class="lineNumber">275</td>
    <td class="codeline">    bool isCall           : 1;         ///< Is a function call.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeline">    bool isCallOp         : 1;         ///< Is a function call operand.</td>
    <td class="lineNumber">276</td>
    <td class="codeline">    bool isCallOp         : 1;         ///< Is a function call operand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeline">    bool isTwoAddress     : 1;         ///< Is a two-address instruction.</td>
    <td class="lineNumber">277</td>
    <td class="codeline">    bool isTwoAddress     : 1;         ///< Is a two-address instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeline">    bool isCommutable     : 1;         ///< Is a commutable instruction.</td>
    <td class="lineNumber">278</td>
    <td class="codeline">    bool isCommutable     : 1;         ///< Is a commutable instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeline">    bool hasPhysRegUses   : 1;         ///< Has physreg uses.</td>
    <td class="lineNumber">279</td>
    <td class="codeline">    bool hasPhysRegUses   : 1;         ///< Has physreg uses.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeline">    bool hasPhysRegDefs   : 1;         ///< Has physreg defs that are being used.</td>
    <td class="lineNumber">280</td>
    <td class="codeline">    bool hasPhysRegDefs   : 1;         ///< Has physreg defs that are being used.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeline">    bool hasPhysRegClobbers : 1;       ///< Has any physreg defs, used or not.</td>
    <td class="lineNumber">281</td>
    <td class="codeline">    bool hasPhysRegClobbers : 1;       ///< Has any physreg defs, used or not.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeline">    bool isPending        : 1;         ///< True once pending.</td>
    <td class="lineNumber">282</td>
    <td class="codeline">    bool isPending        : 1;         ///< True once pending.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeline">    bool isAvailable      : 1;         ///< True once available.</td>
    <td class="lineNumber">283</td>
    <td class="codeline">    bool isAvailable      : 1;         ///< True once available.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeline">    bool isScheduled      : 1;         ///< True once scheduled.</td>
    <td class="lineNumber">284</td>
    <td class="codeline">    bool isScheduled      : 1;         ///< True once scheduled.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeline">    bool isScheduleHigh   : 1;         ///< True if preferable to schedule high.</td>
    <td class="lineNumber">285</td>
    <td class="codeline">    bool isScheduleHigh   : 1;         ///< True if preferable to schedule high.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeline">    bool isScheduleLow    : 1;         ///< True if preferable to schedule low.</td>
    <td class="lineNumber">286</td>
    <td class="codeline">    bool isScheduleLow    : 1;         ///< True if preferable to schedule low.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeline">    bool isCloned         : 1;         ///< True if this node has been cloned.</td>
    <td class="lineNumber">287</td>
    <td class="codeline">    bool isCloned         : 1;         ///< True if this node has been cloned.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeline">    bool isUnbuffered     : 1;         ///< Uses an unbuffered resource.</td>
    <td class="lineNumber">288</td>
    <td class="codeline">    bool isUnbuffered     : 1;         ///< Uses an unbuffered resource.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeline">    bool hasReservedResource : 1;      ///< Uses a reserved resource.</td>
    <td class="lineNumber">289</td>
    <td class="codeline">    bool hasReservedResource : 1;      ///< Uses a reserved resource.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeline">    Sched::Preference SchedulingPref = Sched::None; ///< Scheduling preference.</td>
    <td class="lineNumber">290</td>
    <td class="codeline">    Sched::Preference SchedulingPref = Sched::None; ///< Scheduling preference.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeline"></td>
    <td class="lineNumber">291</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeline">  private:</td>
    <td class="lineNumber">292</td>
    <td class="codeline">  private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeline">    bool isDepthCurrent   : 1;         ///< True if Depth is current.</td>
    <td class="lineNumber">293</td>
    <td class="codeline">    bool isDepthCurrent   : 1;         ///< True if Depth is current.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeline">    bool isHeightCurrent  : 1;         ///< True if Height is current.</td>
    <td class="lineNumber">294</td>
    <td class="codeline">    bool isHeightCurrent  : 1;         ///< True if Height is current.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeline">    unsigned Depth = 0;                ///< Node depth.</td>
    <td class="lineNumber">295</td>
    <td class="codeline">    unsigned Depth = 0;                ///< Node depth.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeline">    unsigned Height = 0;               ///< Node height.</td>
    <td class="lineNumber">296</td>
    <td class="codeline">    unsigned Height = 0;               ///< Node height.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeline"></td>
    <td class="lineNumber">297</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeline">  public:</td>
    <td class="lineNumber">298</td>
    <td class="codeline">  public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeline">    unsigned TopReadyCycle = 0; ///< Cycle relative to start when node is ready.</td>
    <td class="lineNumber">299</td>
    <td class="codeline">    unsigned TopReadyCycle = 0; ///< Cycle relative to start when node is ready.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeline">    unsigned BotReadyCycle = 0; ///< Cycle relative to end when node is ready.</td>
    <td class="lineNumber">300</td>
    <td class="codeline">    unsigned BotReadyCycle = 0; ///< Cycle relative to end when node is ready.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeline"></td>
    <td class="lineNumber">301</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeline">    const TargetRegisterClass *CopyDstRC =</td>
    <td class="lineNumber">302</td>
    <td class="codeline">    const TargetRegisterClass *CopyDstRC =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeline">        nullptr; ///< Is a special copy node if != nullptr.</td>
    <td class="lineNumber">303</td>
    <td class="codeline">        nullptr; ///< Is a special copy node if != nullptr.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeline">    const TargetRegisterClass *CopySrcRC = nullptr;</td>
    <td class="lineNumber">304</td>
    <td class="codeline">    const TargetRegisterClass *CopySrcRC = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeline"></td>
    <td class="lineNumber">305</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeline">    /// Constructs an SUnit for pre-regalloc scheduling to represent an</td>
    <td class="lineNumber">306</td>
    <td class="codeline">    /// Constructs an SUnit for pre-regalloc scheduling to represent an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeline">    /// SDNode and any nodes flagged to it.</td>
    <td class="lineNumber">307</td>
    <td class="codeline">    /// SDNode and any nodes flagged to it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeline">    SUnit(SDNode *node, unsigned nodenum)</td>
    <td class="lineNumber">308</td>
    <td class="codeline">    SUnit(SDNode *node, unsigned nodenum)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeline">      : Node(node), NodeNum(nodenum), isVRegCycle(false), isCall(false),</td>
    <td class="lineNumber">309</td>
    <td class="codeline">      : Node(node), NodeNum(nodenum), isVRegCycle(false), isCall(false),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeline">        isCallOp(false), isTwoAddress(false), isCommutable(false),</td>
    <td class="lineNumber">310</td>
    <td class="codeline">        isCallOp(false), isTwoAddress(false), isCommutable(false),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeline">        hasPhysRegUses(false), hasPhysRegDefs(false), hasPhysRegClobbers(false),</td>
    <td class="lineNumber">311</td>
    <td class="codeline">        hasPhysRegUses(false), hasPhysRegDefs(false), hasPhysRegClobbers(false),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeline">        isPending(false), isAvailable(false), isScheduled(false),</td>
    <td class="lineNumber">312</td>
    <td class="codeline">        isPending(false), isAvailable(false), isScheduled(false),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeline">        isScheduleHigh(false), isScheduleLow(false), isCloned(false),</td>
    <td class="lineNumber">313</td>
    <td class="codeline">        isScheduleHigh(false), isScheduleLow(false), isCloned(false),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeline">        isUnbuffered(false), hasReservedResource(false), isDepthCurrent(false),</td>
    <td class="lineNumber">314</td>
    <td class="codeline">        isUnbuffered(false), hasReservedResource(false), isDepthCurrent(false),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeline">        isHeightCurrent(false) {}</td>
    <td class="lineNumber">315</td>
    <td class="codeline">        isHeightCurrent(false) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeline"></td>
    <td class="lineNumber">316</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeline">    /// Constructs an SUnit for post-regalloc scheduling to represent a</td>
    <td class="lineNumber">317</td>
    <td class="codeline">    /// Constructs an SUnit for post-regalloc scheduling to represent a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeline">    /// MachineInstr.</td>
    <td class="lineNumber">318</td>
    <td class="codeline">    /// MachineInstr.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeline">    SUnit(MachineInstr *instr, unsigned nodenum)</td>
    <td class="lineNumber">319</td>
    <td class="codeline">    SUnit(MachineInstr *instr, unsigned nodenum)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeline">      : Instr(instr), NodeNum(nodenum), isVRegCycle(false), isCall(false),</td>
    <td class="lineNumber">320</td>
    <td class="codeline">      : Instr(instr), NodeNum(nodenum), isVRegCycle(false), isCall(false),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeline">        isCallOp(false), isTwoAddress(false), isCommutable(false),</td>
    <td class="lineNumber">321</td>
    <td class="codeline">        isCallOp(false), isTwoAddress(false), isCommutable(false),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeline">        hasPhysRegUses(false), hasPhysRegDefs(false), hasPhysRegClobbers(false),</td>
    <td class="lineNumber">322</td>
    <td class="codeline">        hasPhysRegUses(false), hasPhysRegDefs(false), hasPhysRegClobbers(false),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeline">        isPending(false), isAvailable(false), isScheduled(false),</td>
    <td class="lineNumber">323</td>
    <td class="codeline">        isPending(false), isAvailable(false), isScheduled(false),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeline">        isScheduleHigh(false), isScheduleLow(false), isCloned(false),</td>
    <td class="lineNumber">324</td>
    <td class="codeline">        isScheduleHigh(false), isScheduleLow(false), isCloned(false),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeline">        isUnbuffered(false), hasReservedResource(false), isDepthCurrent(false),</td>
    <td class="lineNumber">325</td>
    <td class="codeline">        isUnbuffered(false), hasReservedResource(false), isDepthCurrent(false),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeline">        isHeightCurrent(false) {}</td>
    <td class="lineNumber">326</td>
    <td class="codeline">        isHeightCurrent(false) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeline"></td>
    <td class="lineNumber">327</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeline">    /// Constructs a placeholder SUnit.</td>
    <td class="lineNumber">328</td>
    <td class="codeline">    /// Constructs a placeholder SUnit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeline">    SUnit()</td>
    <td class="lineNumber">329</td>
    <td class="codeline">    SUnit()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeline">      : isVRegCycle(false), isCall(false), isCallOp(false), isTwoAddress(false),</td>
    <td class="lineNumber">330</td>
    <td class="codeline">      : isVRegCycle(false), isCall(false), isCallOp(false), isTwoAddress(false),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeline">        isCommutable(false), hasPhysRegUses(false), hasPhysRegDefs(false),</td>
    <td class="lineNumber">331</td>
    <td class="codeline">        isCommutable(false), hasPhysRegUses(false), hasPhysRegDefs(false),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeline">        hasPhysRegClobbers(false), isPending(false), isAvailable(false),</td>
    <td class="lineNumber">332</td>
    <td class="codeline">        hasPhysRegClobbers(false), isPending(false), isAvailable(false),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeline">        isScheduled(false), isScheduleHigh(false), isScheduleLow(false),</td>
    <td class="lineNumber">333</td>
    <td class="codeline">        isScheduled(false), isScheduleHigh(false), isScheduleLow(false),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeline">        isCloned(false), isUnbuffered(false), hasReservedResource(false),</td>
    <td class="lineNumber">334</td>
    <td class="codeline">        isCloned(false), isUnbuffered(false), hasReservedResource(false),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeline">        isDepthCurrent(false), isHeightCurrent(false) {}</td>
    <td class="lineNumber">335</td>
    <td class="codeline">        isDepthCurrent(false), isHeightCurrent(false) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeline"></td>
    <td class="lineNumber">336</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeline">    /// Boundary nodes are placeholders for the boundary of the</td>
    <td class="lineNumber">337</td>
    <td class="codeline">    /// Boundary nodes are placeholders for the boundary of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeline">    /// scheduling region.</td>
    <td class="lineNumber">338</td>
    <td class="codeline">    /// scheduling region.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeline">    ///</td>
    <td class="lineNumber">339</td>
    <td class="codeline">    ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeline">    /// BoundaryNodes can have DAG edges, including Data edges, but they do not</td>
    <td class="lineNumber">340</td>
    <td class="codeline">    /// BoundaryNodes can have DAG edges, including Data edges, but they do not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeline">    /// correspond to schedulable entities (e.g. instructions) and do not have a</td>
    <td class="lineNumber">341</td>
    <td class="codeline">    /// correspond to schedulable entities (e.g. instructions) and do not have a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeline">    /// valid ID. Consequently, always check for boundary nodes before accessing</td>
    <td class="lineNumber">342</td>
    <td class="codeline">    /// valid ID. Consequently, always check for boundary nodes before accessing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeline">    /// an associative data structure keyed on node ID.</td>
    <td class="lineNumber">343</td>
    <td class="codeline">    /// an associative data structure keyed on node ID.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeline">    bool isBoundaryNode() const { return NodeNum == BoundaryID; }</td>
    <td class="lineNumber">344</td>
    <td class="codeline">    bool isBoundaryNode() const { return NodeNum == BoundaryID; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeline"></td>
    <td class="lineNumber">345</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeline">    /// Assigns the representative SDNode for this SUnit. This may be used</td>
    <td class="lineNumber">346</td>
    <td class="codeline">    /// Assigns the representative SDNode for this SUnit. This may be used</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeline">    /// during pre-regalloc scheduling.</td>
    <td class="lineNumber">347</td>
    <td class="codeline">    /// during pre-regalloc scheduling.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeline">    void setNode(SDNode *N) {</td>
    <td class="lineNumber">348</td>
    <td class="codeline">    void setNode(SDNode *N) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeline">      assert(!Instr && "Setting SDNode of SUnit with MachineInstr!");</td>
    <td class="lineNumber">349</td>
    <td class="codeline">      assert(!Instr && "Setting SDNode of SUnit with MachineInstr!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeline">      Node = N;</td>
    <td class="lineNumber">350</td>
    <td class="codeline">      Node = N;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">351</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeline"></td>
    <td class="lineNumber">352</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeline">    /// Returns the representative SDNode for this SUnit. This may be used</td>
    <td class="lineNumber">353</td>
    <td class="codeline">    /// Returns the representative SDNode for this SUnit. This may be used</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeline">    /// during pre-regalloc scheduling.</td>
    <td class="lineNumber">354</td>
    <td class="codeline">    /// during pre-regalloc scheduling.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeline">    SDNode *getNode() const {</td>
    <td class="lineNumber">355</td>
    <td class="codeline">    SDNode *getNode() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeline">      assert(!Instr && "Reading SDNode of SUnit with MachineInstr!");</td>
    <td class="lineNumber">356</td>
    <td class="codeline">      assert(!Instr && "Reading SDNode of SUnit with MachineInstr!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeline">      return Node;</td>
    <td class="lineNumber">357</td>
    <td class="codeline">      return Node;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">358</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeline"></td>
    <td class="lineNumber">359</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeline">    /// Returns true if this SUnit refers to a machine instruction as</td>
    <td class="lineNumber">360</td>
    <td class="codeline">    /// Returns true if this SUnit refers to a machine instruction as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeline">    /// opposed to an SDNode.</td>
    <td class="lineNumber">361</td>
    <td class="codeline">    /// opposed to an SDNode.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeline">    bool isInstr() const { return Instr; }</td>
    <td class="lineNumber">362</td>
    <td class="codeline">    bool isInstr() const { return Instr; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeline"></td>
    <td class="lineNumber">363</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeline">    /// Assigns the instruction for the SUnit. This may be used during</td>
    <td class="lineNumber">364</td>
    <td class="codeline">    /// Assigns the instruction for the SUnit. This may be used during</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeline">    /// post-regalloc scheduling.</td>
    <td class="lineNumber">365</td>
    <td class="codeline">    /// post-regalloc scheduling.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeline">    void setInstr(MachineInstr *MI) {</td>
    <td class="lineNumber">366</td>
    <td class="codeline">    void setInstr(MachineInstr *MI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeline">      assert(!Node && "Setting MachineInstr of SUnit with SDNode!");</td>
    <td class="lineNumber">367</td>
    <td class="codeline">      assert(!Node && "Setting MachineInstr of SUnit with SDNode!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeline">      Instr = MI;</td>
    <td class="lineNumber">368</td>
    <td class="codeline">      Instr = MI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">369</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeline"></td>
    <td class="lineNumber">370</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeline">    /// Returns the representative MachineInstr for this SUnit. This may be used</td>
    <td class="lineNumber">371</td>
    <td class="codeline">    /// Returns the representative MachineInstr for this SUnit. This may be used</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeline">    /// during post-regalloc scheduling.</td>
    <td class="lineNumber">372</td>
    <td class="codeline">    /// during post-regalloc scheduling.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeline">    MachineInstr *getInstr() const {</td>
    <td class="lineNumber">373</td>
    <td class="codeline">    MachineInstr *getInstr() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeline">      assert(!Node && "Reading MachineInstr of SUnit with SDNode!");</td>
    <td class="lineNumber">374</td>
    <td class="codeline">      assert(!Node && "Reading MachineInstr of SUnit with SDNode!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeline">      return Instr;</td>
    <td class="lineNumber">375</td>
    <td class="codeline">      return Instr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">376</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeline"></td>
    <td class="lineNumber">377</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeline">    /// Adds the specified edge as a pred of the current node if not already.</td>
    <td class="lineNumber">378</td>
    <td class="codeline">    /// Adds the specified edge as a pred of the current node if not already.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeline">    /// It also adds the current node as a successor of the specified node.</td>
    <td class="lineNumber">379</td>
    <td class="codeline">    /// It also adds the current node as a successor of the specified node.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeline">    bool addPred(const SDep &D, bool Required = true);</td>
    <td class="lineNumber">380</td>
    <td class="codeline">    bool addPred(const SDep &D, bool Required = true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeline"></td>
    <td class="lineNumber">381</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeline">    /// Adds a barrier edge to SU by calling addPred(), with latency 0</td>
    <td class="lineNumber">382</td>
    <td class="codeline">    /// Adds a barrier edge to SU by calling addPred(), with latency 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeline">    /// generally or latency 1 for a store followed by a load.</td>
    <td class="lineNumber">383</td>
    <td class="codeline">    /// generally or latency 1 for a store followed by a load.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeline">    bool addPredBarrier(SUnit *SU) {</td>
    <td class="lineNumber">384</td>
    <td class="codeline">    bool addPredBarrier(SUnit *SU) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeline">      SDep Dep(SU, SDep::Barrier);</td>
    <td class="lineNumber">385</td>
    <td class="codeline">      SDep Dep(SU, SDep::Barrier);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeline">      unsigned TrueMemOrderLatency =</td>
    <td class="lineNumber">386</td>
    <td class="codeline">      unsigned TrueMemOrderLatency =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeline">        ((SU->getInstr()->mayStore() && this->getInstr()->mayLoad()) ? 1 : 0);</td>
    <td class="lineNumber">387</td>
    <td class="codeline">        ((SU->getInstr()->mayStore() && this->getInstr()->mayLoad()) ? 1 : 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeline">      Dep.setLatency(TrueMemOrderLatency);</td>
    <td class="lineNumber">388</td>
    <td class="codeline">      Dep.setLatency(TrueMemOrderLatency);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeline">      return addPred(Dep);</td>
    <td class="lineNumber">389</td>
    <td class="codeline">      return addPred(Dep);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">390</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeline"></td>
    <td class="lineNumber">391</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeline">    /// Removes the specified edge as a pred of the current node if it exists.</td>
    <td class="lineNumber">392</td>
    <td class="codeline">    /// Removes the specified edge as a pred of the current node if it exists.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeline">    /// It also removes the current node as a successor of the specified node.</td>
    <td class="lineNumber">393</td>
    <td class="codeline">    /// It also removes the current node as a successor of the specified node.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeline">    void removePred(const SDep &D);</td>
    <td class="lineNumber">394</td>
    <td class="codeline">    void removePred(const SDep &D);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeline"></td>
    <td class="lineNumber">395</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeline">    /// Returns the depth of this node, which is the length of the maximum path</td>
    <td class="lineNumber">396</td>
    <td class="codeline">    /// Returns the depth of this node, which is the length of the maximum path</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeline">    /// up to any node which has no predecessors.</td>
    <td class="lineNumber">397</td>
    <td class="codeline">    /// up to any node which has no predecessors.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeline">    unsigned getDepth() const {</td>
    <td class="lineNumber">398</td>
    <td class="codeline">    unsigned getDepth() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeline">      if (!isDepthCurrent)</td>
    <td class="lineNumber">399</td>
    <td class="codeline">      if (!isDepthCurrent)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeline">        const_cast<SUnit *>(this)->ComputeDepth();</td>
    <td class="lineNumber">400</td>
    <td class="codeline">        const_cast<SUnit *>(this)->ComputeDepth();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeline">      return Depth;</td>
    <td class="lineNumber">401</td>
    <td class="codeline">      return Depth;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">402</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeline"></td>
    <td class="lineNumber">403</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeline">    /// Returns the height of this node, which is the length of the</td>
    <td class="lineNumber">404</td>
    <td class="codeline">    /// Returns the height of this node, which is the length of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeline">    /// maximum path down to any node which has no successors.</td>
    <td class="lineNumber">405</td>
    <td class="codeline">    /// maximum path down to any node which has no successors.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeline">    unsigned getHeight() const {</td>
    <td class="lineNumber">406</td>
    <td class="codeline">    unsigned getHeight() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeline">      if (!isHeightCurrent)</td>
    <td class="lineNumber">407</td>
    <td class="codeline">      if (!isHeightCurrent)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeline">        const_cast<SUnit *>(this)->ComputeHeight();</td>
    <td class="lineNumber">408</td>
    <td class="codeline">        const_cast<SUnit *>(this)->ComputeHeight();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeline">      return Height;</td>
    <td class="lineNumber">409</td>
    <td class="codeline">      return Height;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">410</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeline"></td>
    <td class="lineNumber">411</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeline">    /// If NewDepth is greater than this node's depth value, sets it to</td>
    <td class="lineNumber">412</td>
    <td class="codeline">    /// If NewDepth is greater than this node's depth value, sets it to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeline">    /// be the new depth value. This also recursively marks successor nodes</td>
    <td class="lineNumber">413</td>
    <td class="codeline">    /// be the new depth value. This also recursively marks successor nodes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeline">    /// dirty.</td>
    <td class="lineNumber">414</td>
    <td class="codeline">    /// dirty.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeline">    void setDepthToAtLeast(unsigned NewDepth);</td>
    <td class="lineNumber">415</td>
    <td class="codeline">    void setDepthToAtLeast(unsigned NewDepth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeline"></td>
    <td class="lineNumber">416</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeline">    /// If NewHeight is greater than this node's height value, set it to be</td>
    <td class="lineNumber">417</td>
    <td class="codeline">    /// If NewHeight is greater than this node's height value, set it to be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeline">    /// the new height value. This also recursively marks predecessor nodes</td>
    <td class="lineNumber">418</td>
    <td class="codeline">    /// the new height value. This also recursively marks predecessor nodes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeline">    /// dirty.</td>
    <td class="lineNumber">419</td>
    <td class="codeline">    /// dirty.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeline">    void setHeightToAtLeast(unsigned NewHeight);</td>
    <td class="lineNumber">420</td>
    <td class="codeline">    void setHeightToAtLeast(unsigned NewHeight);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeline"></td>
    <td class="lineNumber">421</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeline">    /// Sets a flag in this node to indicate that its stored Depth value</td>
    <td class="lineNumber">422</td>
    <td class="codeline">    /// Sets a flag in this node to indicate that its stored Depth value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeline">    /// will require recomputation the next time getDepth() is called.</td>
    <td class="lineNumber">423</td>
    <td class="codeline">    /// will require recomputation the next time getDepth() is called.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeline">    void setDepthDirty();</td>
    <td class="lineNumber">424</td>
    <td class="codeline">    void setDepthDirty();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeline"></td>
    <td class="lineNumber">425</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeline">    /// Sets a flag in this node to indicate that its stored Height value</td>
    <td class="lineNumber">426</td>
    <td class="codeline">    /// Sets a flag in this node to indicate that its stored Height value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeline">    /// will require recomputation the next time getHeight() is called.</td>
    <td class="lineNumber">427</td>
    <td class="codeline">    /// will require recomputation the next time getHeight() is called.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeline">    void setHeightDirty();</td>
    <td class="lineNumber">428</td>
    <td class="codeline">    void setHeightDirty();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeline"></td>
    <td class="lineNumber">429</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeline">    /// Tests if node N is a predecessor of this node.</td>
    <td class="lineNumber">430</td>
    <td class="codeline">    /// Tests if node N is a predecessor of this node.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeline">    bool isPred(const SUnit *N) const {</td>
    <td class="lineNumber">431</td>
    <td class="codeline">    bool isPred(const SUnit *N) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeline">      for (const SDep &Pred : Preds)</td>
    <td class="lineNumber">432</td>
    <td class="codeline">      for (const SDep &Pred : Preds)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeline">        if (Pred.getSUnit() == N)</td>
    <td class="lineNumber">433</td>
    <td class="codeline">        if (Pred.getSUnit() == N)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeline">          return true;</td>
    <td class="lineNumber">434</td>
    <td class="codeline">          return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">435</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">436</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeline"></td>
    <td class="lineNumber">437</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeline">    /// Tests if node N is a successor of this node.</td>
    <td class="lineNumber">438</td>
    <td class="codeline">    /// Tests if node N is a successor of this node.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeline">    bool isSucc(const SUnit *N) const {</td>
    <td class="lineNumber">439</td>
    <td class="codeline">    bool isSucc(const SUnit *N) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeline">      for (const SDep &Succ : Succs)</td>
    <td class="lineNumber">440</td>
    <td class="codeline">      for (const SDep &Succ : Succs)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeline">        if (Succ.getSUnit() == N)</td>
    <td class="lineNumber">441</td>
    <td class="codeline">        if (Succ.getSUnit() == N)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeline">          return true;</td>
    <td class="lineNumber">442</td>
    <td class="codeline">          return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">443</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">444</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeline"></td>
    <td class="lineNumber">445</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeline">    bool isTopReady() const {</td>
    <td class="lineNumber">446</td>
    <td class="codeline">    bool isTopReady() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeline">      return NumPredsLeft == 0;</td>
    <td class="lineNumber">447</td>
    <td class="codeline">      return NumPredsLeft == 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">448</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeline">    bool isBottomReady() const {</td>
    <td class="lineNumber">449</td>
    <td class="codeline">    bool isBottomReady() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeline">      return NumSuccsLeft == 0;</td>
    <td class="lineNumber">450</td>
    <td class="codeline">      return NumSuccsLeft == 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">451</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeline"></td>
    <td class="lineNumber">452</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeline">    /// Orders this node's predecessor edges such that the critical path</td>
    <td class="lineNumber">453</td>
    <td class="codeline">    /// Orders this node's predecessor edges such that the critical path</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeline">    /// edge occurs first.</td>
    <td class="lineNumber">454</td>
    <td class="codeline">    /// edge occurs first.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeline">    void biasCriticalPath();</td>
    <td class="lineNumber">455</td>
    <td class="codeline">    void biasCriticalPath();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeline"></td>
    <td class="lineNumber">456</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeline">    void dumpAttributes() const;</td>
    <td class="lineNumber">457</td>
    <td class="codeline">    void dumpAttributes() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeline"></td>
    <td class="lineNumber">458</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeline">  private:</td>
    <td class="lineNumber">459</td>
    <td class="codeline">  private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeline">    void ComputeDepth();</td>
    <td class="lineNumber">460</td>
    <td class="codeline">    void ComputeDepth();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeline">    void ComputeHeight();</td>
    <td class="lineNumber">461</td>
    <td class="codeline">    void ComputeHeight();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">462</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeline"></td>
    <td class="lineNumber">463</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeline">  /// Returns true if the specified SDep is equivalent except for latency.</td>
    <td class="lineNumber">464</td>
    <td class="codeline">  /// Returns true if the specified SDep is equivalent except for latency.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeline">  inline bool SDep::overlaps(const SDep &Other) const {</td>
    <td class="lineNumber">465</td>
    <td class="codeline">  inline bool SDep::overlaps(const SDep &Other) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeline">    if (Dep != Other.Dep)</td>
    <td class="lineNumber">466</td>
    <td class="codeline">    if (Dep != Other.Dep)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">467</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeline">    switch (Dep.getInt()) {</td>
    <td class="lineNumber">468</td>
    <td class="codeline">    switch (Dep.getInt()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeline">    case Data:</td>
    <td class="lineNumber">469</td>
    <td class="codeline">    case Data:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeline">    case Anti:</td>
    <td class="lineNumber">470</td>
    <td class="codeline">    case Anti:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeline">    case Output:</td>
    <td class="lineNumber">471</td>
    <td class="codeline">    case Output:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeline">      return Contents.Reg == Other.Contents.Reg;</td>
    <td class="lineNumber">472</td>
    <td class="codeline">      return Contents.Reg == Other.Contents.Reg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeline">    case Order:</td>
    <td class="lineNumber">473</td>
    <td class="codeline">    case Order:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeline">      return Contents.OrdKind == Other.Contents.OrdKind;</td>
    <td class="lineNumber">474</td>
    <td class="codeline">      return Contents.OrdKind == Other.Contents.OrdKind;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">475</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeline">    llvm_unreachable("Invalid dependency kind!");</td>
    <td class="lineNumber">476</td>
    <td class="codeline">    llvm_unreachable("Invalid dependency kind!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">477</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeline"></td>
    <td class="lineNumber">478</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeline">  //// Returns the SUnit to which this edge points.</td>
    <td class="lineNumber">479</td>
    <td class="codeline">  //// Returns the SUnit to which this edge points.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeline">  inline SUnit *SDep::getSUnit() const { return Dep.getPointer(); }</td>
    <td class="lineNumber">480</td>
    <td class="codeline">  inline SUnit *SDep::getSUnit() const { return Dep.getPointer(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeline"></td>
    <td class="lineNumber">481</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeline">  //// Assigns the SUnit to which this edge points.</td>
    <td class="lineNumber">482</td>
    <td class="codeline">  //// Assigns the SUnit to which this edge points.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeline">  inline void SDep::setSUnit(SUnit *SU) { Dep.setPointer(SU); }</td>
    <td class="lineNumber">483</td>
    <td class="codeline">  inline void SDep::setSUnit(SUnit *SU) { Dep.setPointer(SU); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeline"></td>
    <td class="lineNumber">484</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeline">  /// Returns an enum value representing the kind of the dependence.</td>
    <td class="lineNumber">485</td>
    <td class="codeline">  /// Returns an enum value representing the kind of the dependence.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeline">  inline SDep::Kind SDep::getKind() const { return Dep.getInt(); }</td>
    <td class="lineNumber">486</td>
    <td class="codeline">  inline SDep::Kind SDep::getKind() const { return Dep.getInt(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeline"></td>
    <td class="lineNumber">487</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeline">  //===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">488</td>
    <td class="codeline">  //===--------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeline"></td>
    <td class="lineNumber">489</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeline">  /// This interface is used to plug different priorities computation</td>
    <td class="lineNumber">490</td>
    <td class="codeline">  /// This interface is used to plug different priorities computation</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeline">  /// algorithms into the list scheduler. It implements the interface of a</td>
    <td class="lineNumber">491</td>
    <td class="codeline">  /// algorithms into the list scheduler. It implements the interface of a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeline">  /// standard priority queue, where nodes are inserted in arbitrary order and</td>
    <td class="lineNumber">492</td>
    <td class="codeline">  /// standard priority queue, where nodes are inserted in arbitrary order and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeline">  /// returned in priority order.  The computation of the priority and the</td>
    <td class="lineNumber">493</td>
    <td class="codeline">  /// returned in priority order.  The computation of the priority and the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeline">  /// representation of the queue are totally up to the implementation to</td>
    <td class="lineNumber">494</td>
    <td class="codeline">  /// representation of the queue are totally up to the implementation to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeline">  /// decide.</td>
    <td class="lineNumber">495</td>
    <td class="codeline">  /// decide.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeline">  class SchedulingPriorityQueue {</td>
    <td class="lineNumber">496</td>
    <td class="codeline">  class SchedulingPriorityQueue {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeline">    virtual void anchor();</td>
    <td class="lineNumber">497</td>
    <td class="codeline">    virtual void anchor();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeline"></td>
    <td class="lineNumber">498</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeline">    unsigned CurCycle = 0;</td>
    <td class="lineNumber">499</td>
    <td class="codeline">    unsigned CurCycle = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeline">    bool HasReadyFilter;</td>
    <td class="lineNumber">500</td>
    <td class="codeline">    bool HasReadyFilter;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeline"></td>
    <td class="lineNumber">501</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeline">  public:</td>
    <td class="lineNumber">502</td>
    <td class="codeline">  public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeline">    SchedulingPriorityQueue(bool rf = false) :  HasReadyFilter(rf) {}</td>
    <td class="lineNumber">503</td>
    <td class="codeline">    SchedulingPriorityQueue(bool rf = false) :  HasReadyFilter(rf) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeline"></td>
    <td class="lineNumber">504</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeline">    virtual ~SchedulingPriorityQueue() = default;</td>
    <td class="lineNumber">505</td>
    <td class="codeline">    virtual ~SchedulingPriorityQueue() = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeline"></td>
    <td class="lineNumber">506</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeline">    virtual bool isBottomUp() const = 0;</td>
    <td class="lineNumber">507</td>
    <td class="codeline">    virtual bool isBottomUp() const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeline"></td>
    <td class="lineNumber">508</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeline">    virtual void initNodes(std::vector<SUnit> &SUnits) = 0;</td>
    <td class="lineNumber">509</td>
    <td class="codeline">    virtual void initNodes(std::vector<SUnit> &SUnits) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeline">    virtual void addNode(const SUnit *SU) = 0;</td>
    <td class="lineNumber">510</td>
    <td class="codeline">    virtual void addNode(const SUnit *SU) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeline">    virtual void updateNode(const SUnit *SU) = 0;</td>
    <td class="lineNumber">511</td>
    <td class="codeline">    virtual void updateNode(const SUnit *SU) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeline">    virtual void releaseState() = 0;</td>
    <td class="lineNumber">512</td>
    <td class="codeline">    virtual void releaseState() = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeline"></td>
    <td class="lineNumber">513</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeline">    virtual bool empty() const = 0;</td>
    <td class="lineNumber">514</td>
    <td class="codeline">    virtual bool empty() const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeline"></td>
    <td class="lineNumber">515</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeline">    bool hasReadyFilter() const { return HasReadyFilter; }</td>
    <td class="lineNumber">516</td>
    <td class="codeline">    bool hasReadyFilter() const { return HasReadyFilter; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeline"></td>
    <td class="lineNumber">517</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeline">    virtual bool tracksRegPressure() const { return false; }</td>
    <td class="lineNumber">518</td>
    <td class="codeline">    virtual bool tracksRegPressure() const { return false; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeline"></td>
    <td class="lineNumber">519</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeline">    virtual bool isReady(SUnit *) const {</td>
    <td class="lineNumber">520</td>
    <td class="codeline">    virtual bool isReady(SUnit *) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeline">      assert(!HasReadyFilter && "The ready filter must override isReady()");</td>
    <td class="lineNumber">521</td>
    <td class="codeline">      assert(!HasReadyFilter && "The ready filter must override isReady()");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">522</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">523</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeline"></td>
    <td class="lineNumber">524</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeline">    virtual void push(SUnit *U) = 0;</td>
    <td class="lineNumber">525</td>
    <td class="codeline">    virtual void push(SUnit *U) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeline"></td>
    <td class="lineNumber">526</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeline">    void push_all(const std::vector<SUnit *> &Nodes) {</td>
    <td class="lineNumber">527</td>
    <td class="codeline">    void push_all(const std::vector<SUnit *> &Nodes) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeline">      for (SUnit *SU : Nodes)</td>
    <td class="lineNumber">528</td>
    <td class="codeline">      for (SUnit *SU : Nodes)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeline">        push(SU);</td>
    <td class="lineNumber">529</td>
    <td class="codeline">        push(SU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">530</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeline"></td>
    <td class="lineNumber">531</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeline">    virtual SUnit *pop() = 0;</td>
    <td class="lineNumber">532</td>
    <td class="codeline">    virtual SUnit *pop() = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeline"></td>
    <td class="lineNumber">533</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeline">    virtual void remove(SUnit *SU) = 0;</td>
    <td class="lineNumber">534</td>
    <td class="codeline">    virtual void remove(SUnit *SU) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeline"></td>
    <td class="lineNumber">535</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeline">    virtual void dump(ScheduleDAG *) const {}</td>
    <td class="lineNumber">536</td>
    <td class="codeline">    virtual void dump(ScheduleDAG *) const {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeline"></td>
    <td class="lineNumber">537</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeline">    /// As each node is scheduled, this method is invoked.  This allows the</td>
    <td class="lineNumber">538</td>
    <td class="codeline">    /// As each node is scheduled, this method is invoked.  This allows the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeline">    /// priority function to adjust the priority of related unscheduled nodes,</td>
    <td class="lineNumber">539</td>
    <td class="codeline">    /// priority function to adjust the priority of related unscheduled nodes,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeline">    /// for example.</td>
    <td class="lineNumber">540</td>
    <td class="codeline">    /// for example.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeline">    virtual void scheduledNode(SUnit *) {}</td>
    <td class="lineNumber">541</td>
    <td class="codeline">    virtual void scheduledNode(SUnit *) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeline"></td>
    <td class="lineNumber">542</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeline">    virtual void unscheduledNode(SUnit *) {}</td>
    <td class="lineNumber">543</td>
    <td class="codeline">    virtual void unscheduledNode(SUnit *) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeline"></td>
    <td class="lineNumber">544</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeline">    void setCurCycle(unsigned Cycle) {</td>
    <td class="lineNumber">545</td>
    <td class="codeline">    void setCurCycle(unsigned Cycle) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeline">      CurCycle = Cycle;</td>
    <td class="lineNumber">546</td>
    <td class="codeline">      CurCycle = Cycle;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">547</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeline"></td>
    <td class="lineNumber">548</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeline">    unsigned getCurCycle() const {</td>
    <td class="lineNumber">549</td>
    <td class="codeline">    unsigned getCurCycle() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeline">      return CurCycle;</td>
    <td class="lineNumber">550</td>
    <td class="codeline">      return CurCycle;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">551</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">552</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeline"></td>
    <td class="lineNumber">553</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeline">  class ScheduleDAG {</td>
    <td class="lineNumber">554</td>
    <td class="codeline">  class ScheduleDAG {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeline">  public:</td>
    <td class="lineNumber">555</td>
    <td class="codeline">  public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeline">    const LLVMTargetMachine &TM;        ///< Target processor</td>
    <td class="lineNumber">556</td>
    <td class="codeline">    const LLVMTargetMachine &TM;        ///< Target processor</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeline">    const TargetInstrInfo *TII;         ///< Target instruction information</td>
    <td class="lineNumber">557</td>
    <td class="codeline">    const TargetInstrInfo *TII;         ///< Target instruction information</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeline">    const TargetRegisterInfo *TRI;      ///< Target processor register info</td>
    <td class="lineNumber">558</td>
    <td class="codeline">    const TargetRegisterInfo *TRI;      ///< Target processor register info</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeline">    MachineFunction &MF;                ///< Machine function</td>
    <td class="lineNumber">559</td>
    <td class="codeline">    MachineFunction &MF;                ///< Machine function</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeline">    MachineRegisterInfo &MRI;           ///< Virtual/real register map</td>
    <td class="lineNumber">560</td>
    <td class="codeline">    MachineRegisterInfo &MRI;           ///< Virtual/real register map</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeline">    std::vector<SUnit> SUnits;          ///< The scheduling units.</td>
    <td class="lineNumber">561</td>
    <td class="codeline">    std::vector<SUnit> SUnits;          ///< The scheduling units.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeline">    SUnit EntrySU;                      ///< Special node for the region entry.</td>
    <td class="lineNumber">562</td>
    <td class="codeline">    SUnit EntrySU;                      ///< Special node for the region entry.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeline">    SUnit ExitSU;                       ///< Special node for the region exit.</td>
    <td class="lineNumber">563</td>
    <td class="codeline">    SUnit ExitSU;                       ///< Special node for the region exit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeline"></td>
    <td class="lineNumber">564</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeline">#ifdef NDEBUG</td>
    <td class="lineNumber">565</td>
    <td class="codeline">#ifdef NDEBUG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeline">    static const bool StressSched = false;</td>
    <td class="lineNumber">566</td>
    <td class="codeline">    static const bool StressSched = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeline">#else</td>
    <td class="lineNumber">567</td>
    <td class="codeline">#else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeline">    bool StressSched;</td>
    <td class="lineNumber">568</td>
    <td class="codeline">    bool StressSched;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">569</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeline"></td>
    <td class="lineNumber">570</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeline">    // This class is designed to be passed by reference only. Copy constructor</td>
    <td class="lineNumber">571</td>
    <td class="codeline">    // This class is designed to be passed by reference only. Copy constructor</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeline">    // is declared as deleted here to make the derived classes have deleted</td>
    <td class="lineNumber">572</td>
    <td class="codeline">    // is declared as deleted here to make the derived classes have deleted</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeline">    // implicit-declared copy constructor, which suppresses the warnings from</td>
    <td class="lineNumber">573</td>
    <td class="codeline">    // implicit-declared copy constructor, which suppresses the warnings from</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeline">    // static analyzer when the derived classes own resources that are freed in</td>
    <td class="lineNumber">574</td>
    <td class="codeline">    // static analyzer when the derived classes own resources that are freed in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeline">    // their destructors, but don't have user-written copy constructors (rule</td>
    <td class="lineNumber">575</td>
    <td class="codeline">    // their destructors, but don't have user-written copy constructors (rule</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeline">    // of three).</td>
    <td class="lineNumber">576</td>
    <td class="codeline">    // of three).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeline">    ScheduleDAG(const ScheduleDAG &) = delete;</td>
    <td class="lineNumber">577</td>
    <td class="codeline">    ScheduleDAG(const ScheduleDAG &) = delete;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeline">    ScheduleDAG &operator=(const ScheduleDAG &) = delete;</td>
    <td class="lineNumber">578</td>
    <td class="codeline">    ScheduleDAG &operator=(const ScheduleDAG &) = delete;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeline"></td>
    <td class="lineNumber">579</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeline">    explicit ScheduleDAG(MachineFunction &mf);</td>
    <td class="lineNumber">580</td>
    <td class="codeline">    explicit ScheduleDAG(MachineFunction &mf);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeline"></td>
    <td class="lineNumber">581</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeline">    virtual ~ScheduleDAG();</td>
    <td class="lineNumber">582</td>
    <td class="codeline">    virtual ~ScheduleDAG();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeline"></td>
    <td class="lineNumber">583</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeline">    /// Clears the DAG state (between regions).</td>
    <td class="lineNumber">584</td>
    <td class="codeline">    /// Clears the DAG state (between regions).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeline">    void clearDAG();</td>
    <td class="lineNumber">585</td>
    <td class="codeline">    void clearDAG();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeline"></td>
    <td class="lineNumber">586</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeline">    /// Returns the MCInstrDesc of this SUnit.</td>
    <td class="lineNumber">587</td>
    <td class="codeline">    /// Returns the MCInstrDesc of this SUnit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeline">    /// Returns NULL for SDNodes without a machine opcode.</td>
    <td class="lineNumber">588</td>
    <td class="codeline">    /// Returns NULL for SDNodes without a machine opcode.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeline">    const MCInstrDesc *getInstrDesc(const SUnit *SU) const {</td>
    <td class="lineNumber">589</td>
    <td class="codeline">    const MCInstrDesc *getInstrDesc(const SUnit *SU) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeline">      if (SU->isInstr()) return &SU->getInstr()->getDesc();</td>
    <td class="lineNumber">590</td>
    <td class="codeline">      if (SU->isInstr()) return &SU->getInstr()->getDesc();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeline">      return getNodeDesc(SU->getNode());</td>
    <td class="lineNumber">591</td>
    <td class="codeline">      return getNodeDesc(SU->getNode());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">592</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeline"></td>
    <td class="lineNumber">593</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeline">    /// Pops up a GraphViz/gv window with the ScheduleDAG rendered using 'dot'.</td>
    <td class="lineNumber">594</td>
    <td class="codeline">    /// Pops up a GraphViz/gv window with the ScheduleDAG rendered using 'dot'.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeline">    virtual void viewGraph(const Twine &Name, const Twine &Title);</td>
    <td class="lineNumber">595</td>
    <td class="codeline">    virtual void viewGraph(const Twine &Name, const Twine &Title);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeline">    virtual void viewGraph();</td>
    <td class="lineNumber">596</td>
    <td class="codeline">    virtual void viewGraph();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeline"></td>
    <td class="lineNumber">597</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeline">    virtual void dumpNode(const SUnit &SU) const = 0;</td>
    <td class="lineNumber">598</td>
    <td class="codeline">    virtual void dumpNode(const SUnit &SU) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeline">    virtual void dump() const = 0;</td>
    <td class="lineNumber">599</td>
    <td class="codeline">    virtual void dump() const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeline">    void dumpNodeName(const SUnit &SU) const;</td>
    <td class="lineNumber">600</td>
    <td class="codeline">    void dumpNodeName(const SUnit &SU) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeline"></td>
    <td class="lineNumber">601</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeline">    /// Returns a label for an SUnit node in a visualization of the ScheduleDAG.</td>
    <td class="lineNumber">602</td>
    <td class="codeline">    /// Returns a label for an SUnit node in a visualization of the ScheduleDAG.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeline">    virtual std::string getGraphNodeLabel(const SUnit *SU) const = 0;</td>
    <td class="lineNumber">603</td>
    <td class="codeline">    virtual std::string getGraphNodeLabel(const SUnit *SU) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeline"></td>
    <td class="lineNumber">604</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeline">    /// Returns a label for the region of code covered by the DAG.</td>
    <td class="lineNumber">605</td>
    <td class="codeline">    /// Returns a label for the region of code covered by the DAG.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeline">    virtual std::string getDAGName() const = 0;</td>
    <td class="lineNumber">606</td>
    <td class="codeline">    virtual std::string getDAGName() const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeline"></td>
    <td class="lineNumber">607</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeline">    /// Adds custom features for a visualization of the ScheduleDAG.</td>
    <td class="lineNumber">608</td>
    <td class="codeline">    /// Adds custom features for a visualization of the ScheduleDAG.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeline">    virtual void addCustomGraphFeatures(GraphWriter<ScheduleDAG*> &) const {}</td>
    <td class="lineNumber">609</td>
    <td class="codeline">    virtual void addCustomGraphFeatures(GraphWriter<ScheduleDAG*> &) const {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeline"></td>
    <td class="lineNumber">610</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeline">#ifndef NDEBUG</td>
    <td class="lineNumber">611</td>
    <td class="codeline">#ifndef NDEBUG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeline">    /// Verifies that all SUnits were scheduled and that their state is</td>
    <td class="lineNumber">612</td>
    <td class="codeline">    /// Verifies that all SUnits were scheduled and that their state is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeline">    /// consistent. Returns the number of scheduled SUnits.</td>
    <td class="lineNumber">613</td>
    <td class="codeline">    /// consistent. Returns the number of scheduled SUnits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeline">    unsigned VerifyScheduledDAG(bool isBottomUp);</td>
    <td class="lineNumber">614</td>
    <td class="codeline">    unsigned VerifyScheduledDAG(bool isBottomUp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">615</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeline"></td>
    <td class="lineNumber">616</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeline">  protected:</td>
    <td class="lineNumber">617</td>
    <td class="codeline">  protected:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeline">    void dumpNodeAll(const SUnit &SU) const;</td>
    <td class="lineNumber">618</td>
    <td class="codeline">    void dumpNodeAll(const SUnit &SU) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeline"></td>
    <td class="lineNumber">619</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeline">  private:</td>
    <td class="lineNumber">620</td>
    <td class="codeline">  private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeline">    /// Returns the MCInstrDesc of this SDNode or NULL.</td>
    <td class="lineNumber">621</td>
    <td class="codeline">    /// Returns the MCInstrDesc of this SDNode or NULL.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeline">    const MCInstrDesc *getNodeDesc(const SDNode *Node) const;</td>
    <td class="lineNumber">622</td>
    <td class="codeline">    const MCInstrDesc *getNodeDesc(const SDNode *Node) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">623</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeline"></td>
    <td class="lineNumber">624</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeline">  class SUnitIterator {</td>
    <td class="lineNumber">625</td>
    <td class="codeline">  class SUnitIterator {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeline">    SUnit *Node;</td>
    <td class="lineNumber">626</td>
    <td class="codeline">    SUnit *Node;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeline">    unsigned Operand;</td>
    <td class="lineNumber">627</td>
    <td class="codeline">    unsigned Operand;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeline"></td>
    <td class="lineNumber">628</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeline">    SUnitIterator(SUnit *N, unsigned Op) : Node(N), Operand(Op) {}</td>
    <td class="lineNumber">629</td>
    <td class="codeline">    SUnitIterator(SUnit *N, unsigned Op) : Node(N), Operand(Op) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeline"></td>
    <td class="lineNumber">630</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeline">  public:</td>
    <td class="lineNumber">631</td>
    <td class="codeline">  public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeline">    using iterator_category = std::forward_iterator_tag;</td>
    <td class="lineNumber">632</td>
    <td class="codeline">    using iterator_category = std::forward_iterator_tag;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeline">    using value_type = SUnit;</td>
    <td class="lineNumber">633</td>
    <td class="codeline">    using value_type = SUnit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeline">    using difference_type = std::ptrdiff_t;</td>
    <td class="lineNumber">634</td>
    <td class="codeline">    using difference_type = std::ptrdiff_t;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeline">    using pointer = value_type *;</td>
    <td class="lineNumber">635</td>
    <td class="codeline">    using pointer = value_type *;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeline">    using reference = value_type &;</td>
    <td class="lineNumber">636</td>
    <td class="codeline">    using reference = value_type &;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeline"></td>
    <td class="lineNumber">637</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeline">    bool operator==(const SUnitIterator& x) const {</td>
    <td class="lineNumber">638</td>
    <td class="codeline">    bool operator==(const SUnitIterator& x) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeline">      return Operand == x.Operand;</td>
    <td class="lineNumber">639</td>
    <td class="codeline">      return Operand == x.Operand;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">640</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeline">    bool operator!=(const SUnitIterator& x) const { return !operator==(x); }</td>
    <td class="lineNumber">641</td>
    <td class="codeline">    bool operator!=(const SUnitIterator& x) const { return !operator==(x); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeline"></td>
    <td class="lineNumber">642</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeline">    pointer operator*() const {</td>
    <td class="lineNumber">643</td>
    <td class="codeline">    pointer operator*() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeline">      return Node->Preds[Operand].getSUnit();</td>
    <td class="lineNumber">644</td>
    <td class="codeline">      return Node->Preds[Operand].getSUnit();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">645</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeline">    pointer operator->() const { return operator*(); }</td>
    <td class="lineNumber">646</td>
    <td class="codeline">    pointer operator->() const { return operator*(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeline"></td>
    <td class="lineNumber">647</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeline">    SUnitIterator& operator++() {                // Preincrement</td>
    <td class="lineNumber">648</td>
    <td class="codeline">    SUnitIterator& operator++() {                // Preincrement</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeline">      ++Operand;</td>
    <td class="lineNumber">649</td>
    <td class="codeline">      ++Operand;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeline">      return *this;</td>
    <td class="lineNumber">650</td>
    <td class="codeline">      return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">651</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeline">    SUnitIterator operator++(int) { // Postincrement</td>
    <td class="lineNumber">652</td>
    <td class="codeline">    SUnitIterator operator++(int) { // Postincrement</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeline">      SUnitIterator tmp = *this; ++*this; return tmp;</td>
    <td class="lineNumber">653</td>
    <td class="codeline">      SUnitIterator tmp = *this; ++*this; return tmp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">654</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeline"></td>
    <td class="lineNumber">655</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeline">    static SUnitIterator begin(SUnit *N) { return SUnitIterator(N, 0); }</td>
    <td class="lineNumber">656</td>
    <td class="codeline">    static SUnitIterator begin(SUnit *N) { return SUnitIterator(N, 0); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeline">    static SUnitIterator end  (SUnit *N) {</td>
    <td class="lineNumber">657</td>
    <td class="codeline">    static SUnitIterator end  (SUnit *N) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeline">      return SUnitIterator(N, (unsigned)N->Preds.size());</td>
    <td class="lineNumber">658</td>
    <td class="codeline">      return SUnitIterator(N, (unsigned)N->Preds.size());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">659</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeline"></td>
    <td class="lineNumber">660</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeline">    unsigned getOperand() const { return Operand; }</td>
    <td class="lineNumber">661</td>
    <td class="codeline">    unsigned getOperand() const { return Operand; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeline">    const SUnit *getNode() const { return Node; }</td>
    <td class="lineNumber">662</td>
    <td class="codeline">    const SUnit *getNode() const { return Node; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeline"></td>
    <td class="lineNumber">663</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeline">    /// Tests if this is not an SDep::Data dependence.</td>
    <td class="lineNumber">664</td>
    <td class="codeline">    /// Tests if this is not an SDep::Data dependence.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeline">    bool isCtrlDep() const {</td>
    <td class="lineNumber">665</td>
    <td class="codeline">    bool isCtrlDep() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeline">      return getSDep().isCtrl();</td>
    <td class="lineNumber">666</td>
    <td class="codeline">      return getSDep().isCtrl();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">667</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeline">    bool isArtificialDep() const {</td>
    <td class="lineNumber">668</td>
    <td class="codeline">    bool isArtificialDep() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeline">      return getSDep().isArtificial();</td>
    <td class="lineNumber">669</td>
    <td class="codeline">      return getSDep().isArtificial();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">670</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeline">    const SDep &getSDep() const {</td>
    <td class="lineNumber">671</td>
    <td class="codeline">    const SDep &getSDep() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeline">      return Node->Preds[Operand];</td>
    <td class="lineNumber">672</td>
    <td class="codeline">      return Node->Preds[Operand];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">673</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">674</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeline"></td>
    <td class="lineNumber">675</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeline">  template <> struct GraphTraits<SUnit*> {</td>
    <td class="lineNumber">676</td>
    <td class="codeline">  template <> struct GraphTraits<SUnit*> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeline">    typedef SUnit *NodeRef;</td>
    <td class="lineNumber">677</td>
    <td class="codeline">    typedef SUnit *NodeRef;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeline">    typedef SUnitIterator ChildIteratorType;</td>
    <td class="lineNumber">678</td>
    <td class="codeline">    typedef SUnitIterator ChildIteratorType;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeline">    static NodeRef getEntryNode(SUnit *N) { return N; }</td>
    <td class="lineNumber">679</td>
    <td class="codeline">    static NodeRef getEntryNode(SUnit *N) { return N; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeline">    static ChildIteratorType child_begin(NodeRef N) {</td>
    <td class="lineNumber">680</td>
    <td class="codeline">    static ChildIteratorType child_begin(NodeRef N) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeline">      return SUnitIterator::begin(N);</td>
    <td class="lineNumber">681</td>
    <td class="codeline">      return SUnitIterator::begin(N);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">682</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeline">    static ChildIteratorType child_end(NodeRef N) {</td>
    <td class="lineNumber">683</td>
    <td class="codeline">    static ChildIteratorType child_end(NodeRef N) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeline">      return SUnitIterator::end(N);</td>
    <td class="lineNumber">684</td>
    <td class="codeline">      return SUnitIterator::end(N);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">685</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">686</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeline"></td>
    <td class="lineNumber">687</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeline">  template <> struct GraphTraits<ScheduleDAG*> : public GraphTraits<SUnit*> {</td>
    <td class="lineNumber">688</td>
    <td class="codeline">  template <> struct GraphTraits<ScheduleDAG*> : public GraphTraits<SUnit*> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeline">    typedef pointer_iterator<std::vector<SUnit>::iterator> nodes_iterator;</td>
    <td class="lineNumber">689</td>
    <td class="codeline">    typedef pointer_iterator<std::vector<SUnit>::iterator> nodes_iterator;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeline">    static nodes_iterator nodes_begin(ScheduleDAG *G) {</td>
    <td class="lineNumber">690</td>
    <td class="codeline">    static nodes_iterator nodes_begin(ScheduleDAG *G) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeline">      return nodes_iterator(G->SUnits.begin());</td>
    <td class="lineNumber">691</td>
    <td class="codeline">      return nodes_iterator(G->SUnits.begin());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">692</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeline">    static nodes_iterator nodes_end(ScheduleDAG *G) {</td>
    <td class="lineNumber">693</td>
    <td class="codeline">    static nodes_iterator nodes_end(ScheduleDAG *G) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeline">      return nodes_iterator(G->SUnits.end());</td>
    <td class="lineNumber">694</td>
    <td class="codeline">      return nodes_iterator(G->SUnits.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">695</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">696</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeline"></td>
    <td class="lineNumber">697</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeline">  /// This class can compute a topological ordering for SUnits and provides</td>
    <td class="lineNumber">698</td>
    <td class="codeline">  /// This class can compute a topological ordering for SUnits and provides</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeline">  /// methods for dynamically updating the ordering as new edges are added.</td>
    <td class="lineNumber">699</td>
    <td class="codeline">  /// methods for dynamically updating the ordering as new edges are added.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">700</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeline">  /// This allows a very fast implementation of IsReachable, for example.</td>
    <td class="lineNumber">701</td>
    <td class="codeline">  /// This allows a very fast implementation of IsReachable, for example.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeline">  class ScheduleDAGTopologicalSort {</td>
    <td class="lineNumber">702</td>
    <td class="codeline">  class ScheduleDAGTopologicalSort {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeline">    /// A reference to the ScheduleDAG's SUnits.</td>
    <td class="lineNumber">703</td>
    <td class="codeline">    /// A reference to the ScheduleDAG's SUnits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeline">    std::vector<SUnit> &SUnits;</td>
    <td class="lineNumber">704</td>
    <td class="codeline">    std::vector<SUnit> &SUnits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeline">    SUnit *ExitSU;</td>
    <td class="lineNumber">705</td>
    <td class="codeline">    SUnit *ExitSU;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeline"></td>
    <td class="lineNumber">706</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeline">    // Have any new nodes been added?</td>
    <td class="lineNumber">707</td>
    <td class="codeline">    // Have any new nodes been added?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeline">    bool Dirty = false;</td>
    <td class="lineNumber">708</td>
    <td class="codeline">    bool Dirty = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeline"></td>
    <td class="lineNumber">709</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeline">    // Outstanding added edges, that have not been applied to the ordering.</td>
    <td class="lineNumber">710</td>
    <td class="codeline">    // Outstanding added edges, that have not been applied to the ordering.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeline">    SmallVector<std::pair<SUnit *, SUnit *>, 16> Updates;</td>
    <td class="lineNumber">711</td>
    <td class="codeline">    SmallVector<std::pair<SUnit *, SUnit *>, 16> Updates;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeline"></td>
    <td class="lineNumber">712</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeline">    /// Maps topological index to the node number.</td>
    <td class="lineNumber">713</td>
    <td class="codeline">    /// Maps topological index to the node number.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeline">    std::vector<int> Index2Node;</td>
    <td class="lineNumber">714</td>
    <td class="codeline">    std::vector<int> Index2Node;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeline">    /// Maps the node number to its topological index.</td>
    <td class="lineNumber">715</td>
    <td class="codeline">    /// Maps the node number to its topological index.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeline">    std::vector<int> Node2Index;</td>
    <td class="lineNumber">716</td>
    <td class="codeline">    std::vector<int> Node2Index;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeline">    /// a set of nodes visited during a DFS traversal.</td>
    <td class="lineNumber">717</td>
    <td class="codeline">    /// a set of nodes visited during a DFS traversal.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeline">    BitVector Visited;</td>
    <td class="lineNumber">718</td>
    <td class="codeline">    BitVector Visited;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeline"></td>
    <td class="lineNumber">719</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeline">    /// Makes a DFS traversal and mark all nodes affected by the edge insertion.</td>
    <td class="lineNumber">720</td>
    <td class="codeline">    /// Makes a DFS traversal and mark all nodes affected by the edge insertion.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeline">    /// These nodes will later get new topological indexes by means of the Shift</td>
    <td class="lineNumber">721</td>
    <td class="codeline">    /// These nodes will later get new topological indexes by means of the Shift</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeline">    /// method.</td>
    <td class="lineNumber">722</td>
    <td class="codeline">    /// method.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeline">    void DFS(const SUnit *SU, int UpperBound, bool& HasLoop);</td>
    <td class="lineNumber">723</td>
    <td class="codeline">    void DFS(const SUnit *SU, int UpperBound, bool& HasLoop);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeline"></td>
    <td class="lineNumber">724</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeline">    /// Reassigns topological indexes for the nodes in the DAG to</td>
    <td class="lineNumber">725</td>
    <td class="codeline">    /// Reassigns topological indexes for the nodes in the DAG to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeline">    /// preserve the topological ordering.</td>
    <td class="lineNumber">726</td>
    <td class="codeline">    /// preserve the topological ordering.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeline">    void Shift(BitVector& Visited, int LowerBound, int UpperBound);</td>
    <td class="lineNumber">727</td>
    <td class="codeline">    void Shift(BitVector& Visited, int LowerBound, int UpperBound);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeline"></td>
    <td class="lineNumber">728</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeline">    /// Assigns the topological index to the node n.</td>
    <td class="lineNumber">729</td>
    <td class="codeline">    /// Assigns the topological index to the node n.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeline">    void Allocate(int n, int index);</td>
    <td class="lineNumber">730</td>
    <td class="codeline">    void Allocate(int n, int index);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeline"></td>
    <td class="lineNumber">731</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeline">    /// Fix the ordering, by either recomputing from scratch or by applying</td>
    <td class="lineNumber">732</td>
    <td class="codeline">    /// Fix the ordering, by either recomputing from scratch or by applying</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeline">    /// any outstanding updates. Uses a heuristic to estimate what will be</td>
    <td class="lineNumber">733</td>
    <td class="codeline">    /// any outstanding updates. Uses a heuristic to estimate what will be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeline">    /// cheaper.</td>
    <td class="lineNumber">734</td>
    <td class="codeline">    /// cheaper.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeline">    void FixOrder();</td>
    <td class="lineNumber">735</td>
    <td class="codeline">    void FixOrder();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeline"></td>
    <td class="lineNumber">736</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeline">  public:</td>
    <td class="lineNumber">737</td>
    <td class="codeline">  public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeline">    ScheduleDAGTopologicalSort(std::vector<SUnit> &SUnits, SUnit *ExitSU);</td>
    <td class="lineNumber">738</td>
    <td class="codeline">    ScheduleDAGTopologicalSort(std::vector<SUnit> &SUnits, SUnit *ExitSU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeline"></td>
    <td class="lineNumber">739</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeline">    /// Add a SUnit without predecessors to the end of the topological order. It</td>
    <td class="lineNumber">740</td>
    <td class="codeline">    /// Add a SUnit without predecessors to the end of the topological order. It</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeline">    /// also must be the first new node added to the DAG.</td>
    <td class="lineNumber">741</td>
    <td class="codeline">    /// also must be the first new node added to the DAG.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeline">    void AddSUnitWithoutPredecessors(const SUnit *SU);</td>
    <td class="lineNumber">742</td>
    <td class="codeline">    void AddSUnitWithoutPredecessors(const SUnit *SU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeline"></td>
    <td class="lineNumber">743</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeline">    /// Creates the initial topological ordering from the DAG to be scheduled.</td>
    <td class="lineNumber">744</td>
    <td class="codeline">    /// Creates the initial topological ordering from the DAG to be scheduled.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeline">    void InitDAGTopologicalSorting();</td>
    <td class="lineNumber">745</td>
    <td class="codeline">    void InitDAGTopologicalSorting();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeline"></td>
    <td class="lineNumber">746</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeline">    /// Returns an array of SUs that are both in the successor</td>
    <td class="lineNumber">747</td>
    <td class="codeline">    /// Returns an array of SUs that are both in the successor</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeline">    /// subtree of StartSU and in the predecessor subtree of TargetSU.</td>
    <td class="lineNumber">748</td>
    <td class="codeline">    /// subtree of StartSU and in the predecessor subtree of TargetSU.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeline">    /// StartSU and TargetSU are not in the array.</td>
    <td class="lineNumber">749</td>
    <td class="codeline">    /// StartSU and TargetSU are not in the array.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeline">    /// Success is false if TargetSU is not in the successor subtree of</td>
    <td class="lineNumber">750</td>
    <td class="codeline">    /// Success is false if TargetSU is not in the successor subtree of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeline">    /// StartSU, else it is true.</td>
    <td class="lineNumber">751</td>
    <td class="codeline">    /// StartSU, else it is true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeline">    std::vector<int> GetSubGraph(const SUnit &StartSU, const SUnit &TargetSU,</td>
    <td class="lineNumber">752</td>
    <td class="codeline">    std::vector<int> GetSubGraph(const SUnit &StartSU, const SUnit &TargetSU,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeline">                                 bool &Success);</td>
    <td class="lineNumber">753</td>
    <td class="codeline">                                 bool &Success);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeline"></td>
    <td class="lineNumber">754</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeline">    /// Checks if \p SU is reachable from \p TargetSU.</td>
    <td class="lineNumber">755</td>
    <td class="codeline">    /// Checks if \p SU is reachable from \p TargetSU.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeline">    bool IsReachable(const SUnit *SU, const SUnit *TargetSU);</td>
    <td class="lineNumber">756</td>
    <td class="codeline">    bool IsReachable(const SUnit *SU, const SUnit *TargetSU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeline"></td>
    <td class="lineNumber">757</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeline">    /// Returns true if addPred(TargetSU, SU) creates a cycle.</td>
    <td class="lineNumber">758</td>
    <td class="codeline">    /// Returns true if addPred(TargetSU, SU) creates a cycle.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeline">    bool WillCreateCycle(SUnit *TargetSU, SUnit *SU);</td>
    <td class="lineNumber">759</td>
    <td class="codeline">    bool WillCreateCycle(SUnit *TargetSU, SUnit *SU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeline"></td>
    <td class="lineNumber">760</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeline">    /// Updates the topological ordering to accommodate an edge to be</td>
    <td class="lineNumber">761</td>
    <td class="codeline">    /// Updates the topological ordering to accommodate an edge to be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeline">    /// added from SUnit \p X to SUnit \p Y.</td>
    <td class="lineNumber">762</td>
    <td class="codeline">    /// added from SUnit \p X to SUnit \p Y.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeline">    void AddPred(SUnit *Y, SUnit *X);</td>
    <td class="lineNumber">763</td>
    <td class="codeline">    void AddPred(SUnit *Y, SUnit *X);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeline"></td>
    <td class="lineNumber">764</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeline">    /// Queues an update to the topological ordering to accommodate an edge to</td>
    <td class="lineNumber">765</td>
    <td class="codeline">    /// Queues an update to the topological ordering to accommodate an edge to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeline">    /// be added from SUnit \p X to SUnit \p Y.</td>
    <td class="lineNumber">766</td>
    <td class="codeline">    /// be added from SUnit \p X to SUnit \p Y.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeline">    void AddPredQueued(SUnit *Y, SUnit *X);</td>
    <td class="lineNumber">767</td>
    <td class="codeline">    void AddPredQueued(SUnit *Y, SUnit *X);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeline"></td>
    <td class="lineNumber">768</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeline">    /// Updates the topological ordering to accommodate an an edge to be</td>
    <td class="lineNumber">769</td>
    <td class="codeline">    /// Updates the topological ordering to accommodate an an edge to be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeline">    /// removed from the specified node \p N from the predecessors of the</td>
    <td class="lineNumber">770</td>
    <td class="codeline">    /// removed from the specified node \p N from the predecessors of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeline">    /// current node \p M.</td>
    <td class="lineNumber">771</td>
    <td class="codeline">    /// current node \p M.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeline">    void RemovePred(SUnit *M, SUnit *N);</td>
    <td class="lineNumber">772</td>
    <td class="codeline">    void RemovePred(SUnit *M, SUnit *N);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeline"></td>
    <td class="lineNumber">773</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeline">    /// Mark the ordering as temporarily broken, after a new node has been</td>
    <td class="lineNumber">774</td>
    <td class="codeline">    /// Mark the ordering as temporarily broken, after a new node has been</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeline">    /// added.</td>
    <td class="lineNumber">775</td>
    <td class="codeline">    /// added.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeline">    void MarkDirty() { Dirty = true; }</td>
    <td class="lineNumber">776</td>
    <td class="codeline">    void MarkDirty() { Dirty = true; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeline"></td>
    <td class="lineNumber">777</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeline">    typedef std::vector<int>::iterator iterator;</td>
    <td class="lineNumber">778</td>
    <td class="codeline">    typedef std::vector<int>::iterator iterator;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeline">    typedef std::vector<int>::const_iterator const_iterator;</td>
    <td class="lineNumber">779</td>
    <td class="codeline">    typedef std::vector<int>::const_iterator const_iterator;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeline">    iterator begin() { return Index2Node.begin(); }</td>
    <td class="lineNumber">780</td>
    <td class="codeline">    iterator begin() { return Index2Node.begin(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeline">    const_iterator begin() const { return Index2Node.begin(); }</td>
    <td class="lineNumber">781</td>
    <td class="codeline">    const_iterator begin() const { return Index2Node.begin(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeline">    iterator end() { return Index2Node.end(); }</td>
    <td class="lineNumber">782</td>
    <td class="codeline">    iterator end() { return Index2Node.end(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeline">    const_iterator end() const { return Index2Node.end(); }</td>
    <td class="lineNumber">783</td>
    <td class="codeline">    const_iterator end() const { return Index2Node.end(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeline"></td>
    <td class="lineNumber">784</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeline">    typedef std::vector<int>::reverse_iterator reverse_iterator;</td>
    <td class="lineNumber">785</td>
    <td class="codeline">    typedef std::vector<int>::reverse_iterator reverse_iterator;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeline">    typedef std::vector<int>::const_reverse_iterator const_reverse_iterator;</td>
    <td class="lineNumber">786</td>
    <td class="codeline">    typedef std::vector<int>::const_reverse_iterator const_reverse_iterator;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeline">    reverse_iterator rbegin() { return Index2Node.rbegin(); }</td>
    <td class="lineNumber">787</td>
    <td class="codeline">    reverse_iterator rbegin() { return Index2Node.rbegin(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeline">    const_reverse_iterator rbegin() const { return Index2Node.rbegin(); }</td>
    <td class="lineNumber">788</td>
    <td class="codeline">    const_reverse_iterator rbegin() const { return Index2Node.rbegin(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeline">    reverse_iterator rend() { return Index2Node.rend(); }</td>
    <td class="lineNumber">789</td>
    <td class="codeline">    reverse_iterator rend() { return Index2Node.rend(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeline">    const_reverse_iterator rend() const { return Index2Node.rend(); }</td>
    <td class="lineNumber">790</td>
    <td class="codeline">    const_reverse_iterator rend() const { return Index2Node.rend(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">791</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeline"></td>
    <td class="lineNumber">792</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeline">} // end namespace llvm</td>
    <td class="lineNumber">793</td>
    <td class="codeline">} // end namespace llvm</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeline"></td>
    <td class="lineNumber">794</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeline">#endif // LLVM_CODEGEN_SCHEDULEDAG_H</td>
    <td class="lineNumber">795</td>
    <td class="codeline">#endif // LLVM_CODEGEN_SCHEDULEDAG_H</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeline"></td>
    <td class="lineNumber">796</td>
    <td class="codeline"></td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Side By Side Comparison</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Side By Side Comparison</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- llvm/CodeGen/ScheduleDAG.h - Common Base Class -----------*- C++ -*-===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- llvm/CodeGen/ScheduleDAG.h - Common Base Class -----------*- C++ -*-===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeLine">/// \file Implements the ScheduleDAG class, which is used as the common base</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">9</td>
    <td class="codeLine">/// \file Implements the ScheduleDAG class, which is used as the common base</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeLine">/// class for instruction schedulers. This encapsulates the scheduling DAG,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">10</td>
    <td class="codeLine">/// class for instruction schedulers. This encapsulates the scheduling DAG,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeLine">/// which is shared between SelectionDAG and MachineInstr scheduling.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">11</td>
    <td class="codeLine">/// which is shared between SelectionDAG and MachineInstr scheduling.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">12</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">13</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">14</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeLine">#ifndef LLVM_CODEGEN_SCHEDULEDAG_H</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">15</td>
    <td class="codeLine">#ifndef LLVM_CODEGEN_SCHEDULEDAG_H</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeLine">#define LLVM_CODEGEN_SCHEDULEDAG_H</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">16</td>
    <td class="codeLine">#define LLVM_CODEGEN_SCHEDULEDAG_H</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">17</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeLine">#include "llvm/ADT/BitVector.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">18</td>
    <td class="codeLine">#include "llvm/ADT/BitVector.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeLine">#include "llvm/ADT/PointerIntPair.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">19</td>
    <td class="codeLine">#include "llvm/ADT/PointerIntPair.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeLine">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">20</td>
    <td class="codeLine">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeLine">#include "llvm/ADT/iterator.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">21</td>
    <td class="codeLine">#include "llvm/ADT/iterator.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineInstr.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineInstr.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetLowering.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetLowering.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/Support/ErrorHandling.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/Support/ErrorHandling.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">25</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeLine">#include <cstddef></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">26</td>
    <td class="codeLine">#include <cstddef></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeLine">#include <iterator></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">27</td>
    <td class="codeLine">#include <iterator></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeLine">#include <string></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">28</td>
    <td class="codeLine">#include <string></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeLine">#include <vector></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">29</td>
    <td class="codeLine">#include <vector></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">30</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">31</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">32</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeLine">template <class GraphType> struct GraphTraits;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">33</td>
    <td class="codeLine">template <class GraphType> struct GraphTraits;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeLine">template<class Graph> class GraphWriter;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">34</td>
    <td class="codeLine">template<class Graph> class GraphWriter;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeLine">class LLVMTargetMachine;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">35</td>
    <td class="codeLine">class LLVMTargetMachine;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeLine">class MachineFunction;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">36</td>
    <td class="codeLine">class MachineFunction;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeLine">class MachineRegisterInfo;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">37</td>
    <td class="codeLine">class MachineRegisterInfo;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeLine">class MCInstrDesc;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">38</td>
    <td class="codeLine">class MCInstrDesc;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeLine">struct MCSchedClassDesc;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">39</td>
    <td class="codeLine">struct MCSchedClassDesc;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeLine">class SDNode;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">40</td>
    <td class="codeLine">class SDNode;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeLine">class SUnit;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">41</td>
    <td class="codeLine">class SUnit;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeLine">class ScheduleDAG;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">42</td>
    <td class="codeLine">class ScheduleDAG;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeLine">class TargetInstrInfo;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">43</td>
    <td class="codeLine">class TargetInstrInfo;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeLine">class TargetRegisterClass;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">44</td>
    <td class="codeLine">class TargetRegisterClass;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeLine">class TargetRegisterInfo;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">45</td>
    <td class="codeLine">class TargetRegisterInfo;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">46</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeLine">  /// Scheduling dependency. This represents one direction of an edge in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">47</td>
    <td class="codeLine">  /// Scheduling dependency. This represents one direction of an edge in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeLine">  /// scheduling DAG.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">48</td>
    <td class="codeLine">  /// scheduling DAG.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeLine">  class SDep {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">49</td>
    <td class="codeLine">  class SDep {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">50</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeLine">    /// These are the different kinds of scheduling dependencies.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">51</td>
    <td class="codeLine">    /// These are the different kinds of scheduling dependencies.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeLine">    enum Kind {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">52</td>
    <td class="codeLine">    enum Kind {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeLine">      Data,        ///< Regular data dependence (aka true-dependence).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">53</td>
    <td class="codeLine">      Data,        ///< Regular data dependence (aka true-dependence).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeLine">      Anti,        ///< A register anti-dependence (aka WAR).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">54</td>
    <td class="codeLine">      Anti,        ///< A register anti-dependence (aka WAR).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeLine">      Output,      ///< A register output-dependence (aka WAW).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">55</td>
    <td class="codeLine">      Output,      ///< A register output-dependence (aka WAW).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeLine">      Order        ///< Any other ordering dependency.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">56</td>
    <td class="codeLine">      Order        ///< Any other ordering dependency.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">57</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">58</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeLine">    // Strong dependencies must be respected by the scheduler. Artificial</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">59</td>
    <td class="codeLine">    // Strong dependencies must be respected by the scheduler. Artificial</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeLine">    // dependencies may be removed only if they are redundant with another</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">60</td>
    <td class="codeLine">    // dependencies may be removed only if they are redundant with another</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeLine">    // strong dependence.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">61</td>
    <td class="codeLine">    // strong dependence.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">62</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeLine">    // Weak dependencies may be violated by the scheduling strategy, but only if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">63</td>
    <td class="codeLine">    // Weak dependencies may be violated by the scheduling strategy, but only if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeLine">    // the strategy can prove it is correct to do so.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">64</td>
    <td class="codeLine">    // the strategy can prove it is correct to do so.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">65</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeLine">    // Strong OrderKinds must occur before "Weak".</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">66</td>
    <td class="codeLine">    // Strong OrderKinds must occur before "Weak".</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeLine">    // Weak OrderKinds must occur after "Weak".</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">67</td>
    <td class="codeLine">    // Weak OrderKinds must occur after "Weak".</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeLine">    enum OrderKind {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">68</td>
    <td class="codeLine">    enum OrderKind {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeLine">      Barrier,      ///< An unknown scheduling barrier.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">69</td>
    <td class="codeLine">      Barrier,      ///< An unknown scheduling barrier.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeLine">      MayAliasMem,  ///< Nonvolatile load/Store instructions that may alias.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">70</td>
    <td class="codeLine">      MayAliasMem,  ///< Nonvolatile load/Store instructions that may alias.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeLine">      MustAliasMem, ///< Nonvolatile load/Store instructions that must alias.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">71</td>
    <td class="codeLine">      MustAliasMem, ///< Nonvolatile load/Store instructions that must alias.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeLine">      Artificial,   ///< Arbitrary strong DAG edge (no real dependence).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">72</td>
    <td class="codeLine">      Artificial,   ///< Arbitrary strong DAG edge (no real dependence).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeLine">      Weak,         ///< Arbitrary weak DAG edge.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">73</td>
    <td class="codeLine">      Weak,         ///< Arbitrary weak DAG edge.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeLine">      Cluster       ///< Weak DAG edge linking a chain of clustered instrs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">74</td>
    <td class="codeLine">      Cluster       ///< Weak DAG edge linking a chain of clustered instrs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">75</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">76</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeLine">  private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">77</td>
    <td class="codeLine">  private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeLine">    /// A pointer to the depending/depended-on SUnit, and an enum</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">78</td>
    <td class="codeLine">    /// A pointer to the depending/depended-on SUnit, and an enum</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeLine">    /// indicating the kind of the dependency.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">79</td>
    <td class="codeLine">    /// indicating the kind of the dependency.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeLine">    PointerIntPair<SUnit *, 2, Kind> Dep;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">80</td>
    <td class="codeLine">    PointerIntPair<SUnit *, 2, Kind> Dep;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">81</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeLine">    /// A union discriminated by the dependence kind.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">82</td>
    <td class="codeLine">    /// A union discriminated by the dependence kind.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeLine">    union {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">83</td>
    <td class="codeLine">    union {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeLine">      /// For Data, Anti, and Output dependencies, the associated register. For</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">84</td>
    <td class="codeLine">      /// For Data, Anti, and Output dependencies, the associated register. For</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeLine">      /// Data dependencies that don't currently have a register/ assigned, this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">85</td>
    <td class="codeLine">      /// Data dependencies that don't currently have a register/ assigned, this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeLine">      /// is set to zero.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">86</td>
    <td class="codeLine">      /// is set to zero.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeLine">      unsigned Reg;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">87</td>
    <td class="codeLine">      unsigned Reg;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">88</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeLine">      /// Additional information about Order dependencies.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">89</td>
    <td class="codeLine">      /// Additional information about Order dependencies.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeLine">      unsigned OrdKind; // enum OrderKind</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">90</td>
    <td class="codeLine">      unsigned OrdKind; // enum OrderKind</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeLine">    } Contents;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">91</td>
    <td class="codeLine">    } Contents;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">92</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeLine">    /// The time associated with this edge. Often this is just the value of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">93</td>
    <td class="codeLine">    /// The time associated with this edge. Often this is just the value of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeLine">    /// Latency field of the predecessor, however advanced models may provide</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">94</td>
    <td class="codeLine">    /// Latency field of the predecessor, however advanced models may provide</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeLine">    /// additional information about specific edges.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">95</td>
    <td class="codeLine">    /// additional information about specific edges.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeLine">    unsigned Latency = 0u;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">96</td>
    <td class="codeLine">    unsigned Latency = 0u;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">97</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">98</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeLine">    /// Constructs a null SDep. This is only for use by container classes which</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">99</td>
    <td class="codeLine">    /// Constructs a null SDep. This is only for use by container classes which</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeLine">    /// require default constructors. SUnits may not/ have null SDep edges.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">100</td>
    <td class="codeLine">    /// require default constructors. SUnits may not/ have null SDep edges.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeLine">    SDep() : Dep(nullptr, Data) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">101</td>
    <td class="codeLine">    SDep() : Dep(nullptr, Data) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">102</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeLine">    /// Constructs an SDep with the specified values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">103</td>
    <td class="codeLine">    /// Constructs an SDep with the specified values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeLine coveredLine">    SDep(SUnit *S, Kind kind, unsigned Reg)</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">104</td>
    <td class="codeLine coveredLine">    SDep(SUnit *S, Kind kind, unsigned Reg)</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeLine coveredLine">      : Dep(S, kind), Contents() {</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">105</td>
    <td class="codeLine coveredLine">      : Dep(S, kind), Contents() {</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeLine coveredLine">      switch (kind) {</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">106</td>
    <td class="codeLine coveredLine">      switch (kind) {</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeLine">      default:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">107</td>
    <td class="codeLine">      default:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeLine">        llvm_unreachable("Reg given for non-register dependence!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">108</td>
    <td class="codeLine">        llvm_unreachable("Reg given for non-register dependence!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeLine">      case Anti:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">109</td>
    <td class="codeLine">      case Anti:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeLine">      case Output:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">110</td>
    <td class="codeLine">      case Output:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeLine">        assert(Reg != 0 &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">111</td>
    <td class="codeLine">        assert(Reg != 0 &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeLine">               "SDep::Anti and SDep::Output must use a non-zero Reg!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">112</td>
    <td class="codeLine">               "SDep::Anti and SDep::Output must use a non-zero Reg!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeLine">        Contents.Reg = Reg;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">113</td>
    <td class="codeLine">        Contents.Reg = Reg;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeLine">        Latency = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">114</td>
    <td class="codeLine">        Latency = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">115</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeLine coveredLine">      case Data:</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">116</td>
    <td class="codeLine coveredLine">      case Data:</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeLine coveredLine">        Contents.Reg = Reg;</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">117</td>
    <td class="codeLine coveredLine">        Contents.Reg = Reg;</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeLine coveredLine">        Latency = 1;</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">118</td>
    <td class="codeLine coveredLine">        Latency = 1;</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeLine coveredLine">        break;</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">119</td>
    <td class="codeLine coveredLine">        break;</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">120</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeLine coveredLine">    }</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">121</td>
    <td class="codeLine coveredLine">    }</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">122</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeLine coveredLine">    SDep(SUnit *S, OrderKind kind)</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">123</td>
    <td class="codeLine coveredLine">    SDep(SUnit *S, OrderKind kind)</td>
    <td class="lineNumber">9</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeLine coveredLine">      : Dep(S, Order), Contents(), Latency(0) {</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">124</td>
    <td class="codeLine coveredLine">      : Dep(S, Order), Contents(), Latency(0) {</td>
    <td class="lineNumber">9</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeLine coveredLine">      Contents.OrdKind = kind;</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">125</td>
    <td class="codeLine coveredLine">      Contents.OrdKind = kind;</td>
    <td class="lineNumber">9</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeLine coveredLine">    }</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">126</td>
    <td class="codeLine coveredLine">    }</td>
    <td class="lineNumber">9</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">127</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeLine">    /// Returns true if the specified SDep is equivalent except for latency.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">128</td>
    <td class="codeLine">    /// Returns true if the specified SDep is equivalent except for latency.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeLine">    bool overlaps(const SDep &Other) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">129</td>
    <td class="codeLine">    bool overlaps(const SDep &Other) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">130</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeLine">    bool operator==(const SDep &Other) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">131</td>
    <td class="codeLine">    bool operator==(const SDep &Other) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeLine">      return overlaps(Other) && Latency == Other.Latency;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">132</td>
    <td class="codeLine">      return overlaps(Other) && Latency == Other.Latency;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">133</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">134</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeLine">    bool operator!=(const SDep &Other) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">135</td>
    <td class="codeLine">    bool operator!=(const SDep &Other) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeLine">      return !operator==(Other);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">136</td>
    <td class="codeLine">      return !operator==(Other);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">137</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">138</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeLine">    /// Returns the latency value for this edge, which roughly means the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">139</td>
    <td class="codeLine">    /// Returns the latency value for this edge, which roughly means the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeLine">    /// minimum number of cycles that must elapse between the predecessor and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">140</td>
    <td class="codeLine">    /// minimum number of cycles that must elapse between the predecessor and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeLine">    /// the successor, given that they have this edge between them.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">141</td>
    <td class="codeLine">    /// the successor, given that they have this edge between them.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeLine coveredLine">    unsigned getLatency() const {</td>
    <td class="lineNumber">34</td>
    <td class="lineNumber">142</td>
    <td class="codeLine coveredLine">    unsigned getLatency() const {</td>
    <td class="lineNumber">34</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeLine coveredLine">      return Latency;</td>
    <td class="lineNumber">34</td>
    <td class="lineNumber">143</td>
    <td class="codeLine coveredLine">      return Latency;</td>
    <td class="lineNumber">34</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">144</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">145</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeLine">    /// Sets the latency for this edge.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">146</td>
    <td class="codeLine">    /// Sets the latency for this edge.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeLine coveredLine">    void setLatency(unsigned Lat) {</td>
    <td class="lineNumber">17</td>
    <td class="lineNumber">147</td>
    <td class="codeLine coveredLine">    void setLatency(unsigned Lat) {</td>
    <td class="lineNumber">17</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeLine coveredLine">      Latency = Lat;</td>
    <td class="lineNumber">17</td>
    <td class="lineNumber">148</td>
    <td class="codeLine coveredLine">      Latency = Lat;</td>
    <td class="lineNumber">17</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeLine coveredLine">    }</td>
    <td class="lineNumber">17</td>
    <td class="lineNumber">149</td>
    <td class="codeLine coveredLine">    }</td>
    <td class="lineNumber">17</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">150</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeLine">    //// Returns the SUnit to which this edge points.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">151</td>
    <td class="codeLine">    //// Returns the SUnit to which this edge points.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeLine">    SUnit *getSUnit() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">152</td>
    <td class="codeLine">    SUnit *getSUnit() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">153</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeLine">    //// Assigns the SUnit to which this edge points.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">154</td>
    <td class="codeLine">    //// Assigns the SUnit to which this edge points.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeLine">    void setSUnit(SUnit *SU);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">155</td>
    <td class="codeLine">    void setSUnit(SUnit *SU);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">156</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeLine">    /// Returns an enum value representing the kind of the dependence.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">157</td>
    <td class="codeLine">    /// Returns an enum value representing the kind of the dependence.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeLine">    Kind getKind() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">158</td>
    <td class="codeLine">    Kind getKind() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">159</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeLine">    /// Shorthand for getKind() != SDep::Data.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">160</td>
    <td class="codeLine">    /// Shorthand for getKind() != SDep::Data.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeLine coveredLine">    bool isCtrl() const {</td>
    <td class="lineNumber">36</td>
    <td class="lineNumber">161</td>
    <td class="codeLine coveredLine">    bool isCtrl() const {</td>
    <td class="lineNumber">36</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeLine coveredLine">      return getKind() != Data;</td>
    <td class="lineNumber">36</td>
    <td class="lineNumber">162</td>
    <td class="codeLine coveredLine">      return getKind() != Data;</td>
    <td class="lineNumber">36</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">163</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">164</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeLine">    /// Tests if this is an Order dependence between two memory accesses</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">165</td>
    <td class="codeLine">    /// Tests if this is an Order dependence between two memory accesses</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeLine">    /// where both sides of the dependence access memory in non-volatile and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">166</td>
    <td class="codeLine">    /// where both sides of the dependence access memory in non-volatile and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeLine">    /// fully modeled ways.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">167</td>
    <td class="codeLine">    /// fully modeled ways.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeLine">    bool isNormalMemory() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">168</td>
    <td class="codeLine">    bool isNormalMemory() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeLine">      return getKind() == Order && (Contents.OrdKind == MayAliasMem</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">169</td>
    <td class="codeLine">      return getKind() == Order && (Contents.OrdKind == MayAliasMem</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeLine">                                    || Contents.OrdKind == MustAliasMem);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">170</td>
    <td class="codeLine">                                    || Contents.OrdKind == MustAliasMem);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">171</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">172</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeLine">    /// Tests if this is an Order dependence that is marked as a barrier.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">173</td>
    <td class="codeLine">    /// Tests if this is an Order dependence that is marked as a barrier.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeLine">    bool isBarrier() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">174</td>
    <td class="codeLine">    bool isBarrier() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeLine">      return getKind() == Order && Contents.OrdKind == Barrier;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">175</td>
    <td class="codeLine">      return getKind() == Order && Contents.OrdKind == Barrier;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">176</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">177</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeLine">    /// Tests if this is could be any kind of memory dependence.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">178</td>
    <td class="codeLine">    /// Tests if this is could be any kind of memory dependence.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeLine">    bool isNormalMemoryOrBarrier() const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">179</td>
    <td class="codeLine">    bool isNormalMemoryOrBarrier() const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeLine">      return (isNormalMemory() || isBarrier());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">180</td>
    <td class="codeLine">      return (isNormalMemory() || isBarrier());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">181</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">182</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeLine">    /// Tests if this is an Order dependence that is marked as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">183</td>
    <td class="codeLine">    /// Tests if this is an Order dependence that is marked as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeLine">    /// "must alias", meaning that the SUnits at either end of the edge have a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">184</td>
    <td class="codeLine">    /// "must alias", meaning that the SUnits at either end of the edge have a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeLine">    /// memory dependence on a known memory location.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">185</td>
    <td class="codeLine">    /// memory dependence on a known memory location.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeLine">    bool isMustAlias() const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">186</td>
    <td class="codeLine">    bool isMustAlias() const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeLine">      return getKind() == Order && Contents.OrdKind == MustAliasMem;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">187</td>
    <td class="codeLine">      return getKind() == Order && Contents.OrdKind == MustAliasMem;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">188</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">189</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeLine">    /// Tests if this a weak dependence. Weak dependencies are considered DAG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">190</td>
    <td class="codeLine">    /// Tests if this a weak dependence. Weak dependencies are considered DAG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeLine">    /// edges for height computation and other heuristics, but do not force</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">191</td>
    <td class="codeLine">    /// edges for height computation and other heuristics, but do not force</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeLine">    /// ordering. Breaking a weak edge may require the scheduler to compensate,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">192</td>
    <td class="codeLine">    /// ordering. Breaking a weak edge may require the scheduler to compensate,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeLine">    /// for example by inserting a copy.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">193</td>
    <td class="codeLine">    /// for example by inserting a copy.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeLine coveredLine">    bool isWeak() const {</td>
    <td class="lineNumber">34</td>
    <td class="lineNumber">194</td>
    <td class="codeLine coveredLine">    bool isWeak() const {</td>
    <td class="lineNumber">34</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeLine coveredLine">      return getKind() == Order && Contents.OrdKind >= Weak;</td>
    <td class="lineNumber">34</td>
    <td class="lineNumber">195</td>
    <td class="codeLine coveredLine">      return getKind() == Order && Contents.OrdKind >= Weak;</td>
    <td class="lineNumber">34</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">196</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">197</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeLine">    /// Tests if this is an Order dependence that is marked as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">198</td>
    <td class="codeLine">    /// Tests if this is an Order dependence that is marked as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeLine">    /// "artificial", meaning it isn't necessary for correctness.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">199</td>
    <td class="codeLine">    /// "artificial", meaning it isn't necessary for correctness.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeLine">    bool isArtificial() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">200</td>
    <td class="codeLine">    bool isArtificial() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeLine">      return getKind() == Order && Contents.OrdKind == Artificial;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">201</td>
    <td class="codeLine">      return getKind() == Order && Contents.OrdKind == Artificial;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">202</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">203</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeLine">    /// Tests if this is an Order dependence that is marked as "cluster",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">204</td>
    <td class="codeLine">    /// Tests if this is an Order dependence that is marked as "cluster",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeLine">    /// meaning it is artificial and wants to be adjacent.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">205</td>
    <td class="codeLine">    /// meaning it is artificial and wants to be adjacent.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeLine">    bool isCluster() const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">206</td>
    <td class="codeLine">    bool isCluster() const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeLine">      return getKind() == Order && Contents.OrdKind == Cluster;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">207</td>
    <td class="codeLine">      return getKind() == Order && Contents.OrdKind == Cluster;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">208</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">209</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeLine">    /// Tests if this is a Data dependence that is associated with a register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">210</td>
    <td class="codeLine">    /// Tests if this is a Data dependence that is associated with a register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeLine coveredLine">    bool isAssignedRegDep() const {</td>
    <td class="lineNumber">34</td>
    <td class="lineNumber">211</td>
    <td class="codeLine coveredLine">    bool isAssignedRegDep() const {</td>
    <td class="lineNumber">34</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeLine coveredLine">      return getKind() == Data && Contents.Reg != 0;</td>
    <td class="lineNumber">34</td>
    <td class="lineNumber">212</td>
    <td class="codeLine coveredLine">      return getKind() == Data && Contents.Reg != 0;</td>
    <td class="lineNumber">34</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">213</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">214</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeLine">    /// Returns the register associated with this edge. This is only valid on</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">215</td>
    <td class="codeLine">    /// Returns the register associated with this edge. This is only valid on</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeLine">    /// Data, Anti, and Output edges. On Data edges, this value may be zero,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">216</td>
    <td class="codeLine">    /// Data, Anti, and Output edges. On Data edges, this value may be zero,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeLine">    /// meaning there is no associated register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">217</td>
    <td class="codeLine">    /// meaning there is no associated register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeLine">    unsigned getReg() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">218</td>
    <td class="codeLine">    unsigned getReg() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeLine">      assert((getKind() == Data || getKind() == Anti || getKind() == Output) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">219</td>
    <td class="codeLine">      assert((getKind() == Data || getKind() == Anti || getKind() == Output) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeLine">             "getReg called on non-register dependence edge!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">220</td>
    <td class="codeLine">             "getReg called on non-register dependence edge!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeLine">      return Contents.Reg;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">221</td>
    <td class="codeLine">      return Contents.Reg;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">222</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">223</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeLine">    /// Assigns the associated register for this edge. This is only valid on</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">224</td>
    <td class="codeLine">    /// Assigns the associated register for this edge. This is only valid on</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeLine">    /// Data, Anti, and Output edges. On Anti and Output edges, this value must</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">225</td>
    <td class="codeLine">    /// Data, Anti, and Output edges. On Anti and Output edges, this value must</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeLine">    /// not be zero. On Data edges, the value may be zero, which would mean that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">226</td>
    <td class="codeLine">    /// not be zero. On Data edges, the value may be zero, which would mean that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeLine">    /// no specific register is associated with this edge.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">227</td>
    <td class="codeLine">    /// no specific register is associated with this edge.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeLine">    void setReg(unsigned Reg) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">228</td>
    <td class="codeLine">    void setReg(unsigned Reg) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeLine">      assert((getKind() == Data || getKind() == Anti || getKind() == Output) &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">229</td>
    <td class="codeLine">      assert((getKind() == Data || getKind() == Anti || getKind() == Output) &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeLine">             "setReg called on non-register dependence edge!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">230</td>
    <td class="codeLine">             "setReg called on non-register dependence edge!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeLine">      assert((getKind() != Anti || Reg != 0) &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">231</td>
    <td class="codeLine">      assert((getKind() != Anti || Reg != 0) &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeLine">             "SDep::Anti edge cannot use the zero register!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">232</td>
    <td class="codeLine">             "SDep::Anti edge cannot use the zero register!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeLine">      assert((getKind() != Output || Reg != 0) &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">233</td>
    <td class="codeLine">      assert((getKind() != Output || Reg != 0) &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeLine">             "SDep::Output edge cannot use the zero register!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">234</td>
    <td class="codeLine">             "SDep::Output edge cannot use the zero register!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeLine">      Contents.Reg = Reg;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">235</td>
    <td class="codeLine">      Contents.Reg = Reg;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">236</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">237</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeLine">    void dump(const TargetRegisterInfo *TRI = nullptr) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">238</td>
    <td class="codeLine">    void dump(const TargetRegisterInfo *TRI = nullptr) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">239</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">240</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeLine">  /// Scheduling unit. This is a node in the scheduling DAG.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">241</td>
    <td class="codeLine">  /// Scheduling unit. This is a node in the scheduling DAG.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeLine">  class SUnit {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">242</td>
    <td class="codeLine">  class SUnit {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeLine">  private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">243</td>
    <td class="codeLine">  private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeLine">    enum : unsigned { BoundaryID = ~0u };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">244</td>
    <td class="codeLine">    enum : unsigned { BoundaryID = ~0u };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">245</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeLine">    SDNode *Node = nullptr;        ///< Representative node.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">246</td>
    <td class="codeLine">    SDNode *Node = nullptr;        ///< Representative node.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeLine">    MachineInstr *Instr = nullptr; ///< Alternatively, a MachineInstr.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">247</td>
    <td class="codeLine">    MachineInstr *Instr = nullptr; ///< Alternatively, a MachineInstr.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">248</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">249</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeLine">    SUnit *OrigNode = nullptr; ///< If not this, the node from which this node</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">250</td>
    <td class="codeLine">    SUnit *OrigNode = nullptr; ///< If not this, the node from which this node</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeLine">                               /// was cloned. (SD scheduling only)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">251</td>
    <td class="codeLine">                               /// was cloned. (SD scheduling only)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">252</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeLine">    const MCSchedClassDesc *SchedClass =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">253</td>
    <td class="codeLine">    const MCSchedClassDesc *SchedClass =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeLine">        nullptr; ///< nullptr or resolved SchedClass.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">254</td>
    <td class="codeLine">        nullptr; ///< nullptr or resolved SchedClass.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">255</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeLine">    SmallVector<SDep, 4> Preds;  ///< All sunit predecessors.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">256</td>
    <td class="codeLine">    SmallVector<SDep, 4> Preds;  ///< All sunit predecessors.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeLine">    SmallVector<SDep, 4> Succs;  ///< All sunit successors.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">257</td>
    <td class="codeLine">    SmallVector<SDep, 4> Succs;  ///< All sunit successors.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">258</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeLine">    typedef SmallVectorImpl<SDep>::iterator pred_iterator;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">259</td>
    <td class="codeLine">    typedef SmallVectorImpl<SDep>::iterator pred_iterator;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeLine">    typedef SmallVectorImpl<SDep>::iterator succ_iterator;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">260</td>
    <td class="codeLine">    typedef SmallVectorImpl<SDep>::iterator succ_iterator;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeLine">    typedef SmallVectorImpl<SDep>::const_iterator const_pred_iterator;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">261</td>
    <td class="codeLine">    typedef SmallVectorImpl<SDep>::const_iterator const_pred_iterator;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeLine">    typedef SmallVectorImpl<SDep>::const_iterator const_succ_iterator;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">262</td>
    <td class="codeLine">    typedef SmallVectorImpl<SDep>::const_iterator const_succ_iterator;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">263</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeLine">    unsigned NodeNum = BoundaryID;     ///< Entry # of node in the node vector.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">264</td>
    <td class="codeLine">    unsigned NodeNum = BoundaryID;     ///< Entry # of node in the node vector.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeLine">    unsigned NodeQueueId = 0;          ///< Queue id of node.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">265</td>
    <td class="codeLine">    unsigned NodeQueueId = 0;          ///< Queue id of node.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeLine">    unsigned NumPreds = 0;             ///< # of SDep::Data preds.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">266</td>
    <td class="codeLine">    unsigned NumPreds = 0;             ///< # of SDep::Data preds.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeLine">    unsigned NumSuccs = 0;             ///< # of SDep::Data sucss.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">267</td>
    <td class="codeLine">    unsigned NumSuccs = 0;             ///< # of SDep::Data sucss.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeLine">    unsigned NumPredsLeft = 0;         ///< # of preds not scheduled.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">268</td>
    <td class="codeLine">    unsigned NumPredsLeft = 0;         ///< # of preds not scheduled.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeLine">    unsigned NumSuccsLeft = 0;         ///< # of succs not scheduled.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">269</td>
    <td class="codeLine">    unsigned NumSuccsLeft = 0;         ///< # of succs not scheduled.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeLine">    unsigned WeakPredsLeft = 0;        ///< # of weak preds not scheduled.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">270</td>
    <td class="codeLine">    unsigned WeakPredsLeft = 0;        ///< # of weak preds not scheduled.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeLine">    unsigned WeakSuccsLeft = 0;        ///< # of weak succs not scheduled.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">271</td>
    <td class="codeLine">    unsigned WeakSuccsLeft = 0;        ///< # of weak succs not scheduled.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeLine">    unsigned short NumRegDefsLeft = 0; ///< # of reg defs with no scheduled use.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">272</td>
    <td class="codeLine">    unsigned short NumRegDefsLeft = 0; ///< # of reg defs with no scheduled use.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeLine">    unsigned short Latency = 0;        ///< Node latency.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">273</td>
    <td class="codeLine">    unsigned short Latency = 0;        ///< Node latency.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeLine">    bool isVRegCycle      : 1;         ///< May use and def the same vreg.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">274</td>
    <td class="codeLine">    bool isVRegCycle      : 1;         ///< May use and def the same vreg.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeLine">    bool isCall           : 1;         ///< Is a function call.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">275</td>
    <td class="codeLine">    bool isCall           : 1;         ///< Is a function call.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeLine">    bool isCallOp         : 1;         ///< Is a function call operand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">276</td>
    <td class="codeLine">    bool isCallOp         : 1;         ///< Is a function call operand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeLine">    bool isTwoAddress     : 1;         ///< Is a two-address instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">277</td>
    <td class="codeLine">    bool isTwoAddress     : 1;         ///< Is a two-address instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeLine">    bool isCommutable     : 1;         ///< Is a commutable instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">278</td>
    <td class="codeLine">    bool isCommutable     : 1;         ///< Is a commutable instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeLine">    bool hasPhysRegUses   : 1;         ///< Has physreg uses.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">279</td>
    <td class="codeLine">    bool hasPhysRegUses   : 1;         ///< Has physreg uses.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeLine">    bool hasPhysRegDefs   : 1;         ///< Has physreg defs that are being used.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">280</td>
    <td class="codeLine">    bool hasPhysRegDefs   : 1;         ///< Has physreg defs that are being used.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeLine">    bool hasPhysRegClobbers : 1;       ///< Has any physreg defs, used or not.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">281</td>
    <td class="codeLine">    bool hasPhysRegClobbers : 1;       ///< Has any physreg defs, used or not.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeLine">    bool isPending        : 1;         ///< True once pending.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">282</td>
    <td class="codeLine">    bool isPending        : 1;         ///< True once pending.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeLine">    bool isAvailable      : 1;         ///< True once available.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">283</td>
    <td class="codeLine">    bool isAvailable      : 1;         ///< True once available.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeLine">    bool isScheduled      : 1;         ///< True once scheduled.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">284</td>
    <td class="codeLine">    bool isScheduled      : 1;         ///< True once scheduled.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeLine">    bool isScheduleHigh   : 1;         ///< True if preferable to schedule high.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">285</td>
    <td class="codeLine">    bool isScheduleHigh   : 1;         ///< True if preferable to schedule high.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeLine">    bool isScheduleLow    : 1;         ///< True if preferable to schedule low.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">286</td>
    <td class="codeLine">    bool isScheduleLow    : 1;         ///< True if preferable to schedule low.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeLine">    bool isCloned         : 1;         ///< True if this node has been cloned.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">287</td>
    <td class="codeLine">    bool isCloned         : 1;         ///< True if this node has been cloned.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeLine">    bool isUnbuffered     : 1;         ///< Uses an unbuffered resource.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">288</td>
    <td class="codeLine">    bool isUnbuffered     : 1;         ///< Uses an unbuffered resource.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeLine">    bool hasReservedResource : 1;      ///< Uses a reserved resource.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">289</td>
    <td class="codeLine">    bool hasReservedResource : 1;      ///< Uses a reserved resource.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeLine">    Sched::Preference SchedulingPref = Sched::None; ///< Scheduling preference.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">290</td>
    <td class="codeLine">    Sched::Preference SchedulingPref = Sched::None; ///< Scheduling preference.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">291</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeLine">  private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">292</td>
    <td class="codeLine">  private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeLine">    bool isDepthCurrent   : 1;         ///< True if Depth is current.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">293</td>
    <td class="codeLine">    bool isDepthCurrent   : 1;         ///< True if Depth is current.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeLine">    bool isHeightCurrent  : 1;         ///< True if Height is current.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">294</td>
    <td class="codeLine">    bool isHeightCurrent  : 1;         ///< True if Height is current.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeLine">    unsigned Depth = 0;                ///< Node depth.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">295</td>
    <td class="codeLine">    unsigned Depth = 0;                ///< Node depth.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeLine">    unsigned Height = 0;               ///< Node height.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">296</td>
    <td class="codeLine">    unsigned Height = 0;               ///< Node height.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">297</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">298</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeLine">    unsigned TopReadyCycle = 0; ///< Cycle relative to start when node is ready.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">299</td>
    <td class="codeLine">    unsigned TopReadyCycle = 0; ///< Cycle relative to start when node is ready.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeLine">    unsigned BotReadyCycle = 0; ///< Cycle relative to end when node is ready.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">300</td>
    <td class="codeLine">    unsigned BotReadyCycle = 0; ///< Cycle relative to end when node is ready.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">301</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeLine">    const TargetRegisterClass *CopyDstRC =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">302</td>
    <td class="codeLine">    const TargetRegisterClass *CopyDstRC =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeLine">        nullptr; ///< Is a special copy node if != nullptr.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">303</td>
    <td class="codeLine">        nullptr; ///< Is a special copy node if != nullptr.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeLine">    const TargetRegisterClass *CopySrcRC = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">304</td>
    <td class="codeLine">    const TargetRegisterClass *CopySrcRC = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">305</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeLine">    /// Constructs an SUnit for pre-regalloc scheduling to represent an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">306</td>
    <td class="codeLine">    /// Constructs an SUnit for pre-regalloc scheduling to represent an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeLine">    /// SDNode and any nodes flagged to it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">307</td>
    <td class="codeLine">    /// SDNode and any nodes flagged to it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeLine coveredLine">    SUnit(SDNode *node, unsigned nodenum)</td>
    <td class="lineNumber">17</td>
    <td class="lineNumber">308</td>
    <td class="codeLine coveredLine">    SUnit(SDNode *node, unsigned nodenum)</td>
    <td class="lineNumber">17</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeLine coveredLine">      : Node(node), NodeNum(nodenum), isVRegCycle(false), isCall(false),</td>
    <td class="lineNumber">34</td>
    <td class="lineNumber">309</td>
    <td class="codeLine coveredLine">      : Node(node), NodeNum(nodenum), isVRegCycle(false), isCall(false),</td>
    <td class="lineNumber">34</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeLine coveredLine">        isCallOp(false), isTwoAddress(false), isCommutable(false),</td>
    <td class="lineNumber">17</td>
    <td class="lineNumber">310</td>
    <td class="codeLine coveredLine">        isCallOp(false), isTwoAddress(false), isCommutable(false),</td>
    <td class="lineNumber">17</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeLine coveredLine">        hasPhysRegUses(false), hasPhysRegDefs(false), hasPhysRegClobbers(false),</td>
    <td class="lineNumber">17</td>
    <td class="lineNumber">311</td>
    <td class="codeLine coveredLine">        hasPhysRegUses(false), hasPhysRegDefs(false), hasPhysRegClobbers(false),</td>
    <td class="lineNumber">17</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeLine coveredLine">        isPending(false), isAvailable(false), isScheduled(false),</td>
    <td class="lineNumber">17</td>
    <td class="lineNumber">312</td>
    <td class="codeLine coveredLine">        isPending(false), isAvailable(false), isScheduled(false),</td>
    <td class="lineNumber">17</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeLine coveredLine">        isScheduleHigh(false), isScheduleLow(false), isCloned(false),</td>
    <td class="lineNumber">17</td>
    <td class="lineNumber">313</td>
    <td class="codeLine coveredLine">        isScheduleHigh(false), isScheduleLow(false), isCloned(false),</td>
    <td class="lineNumber">17</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeLine coveredLine">        isUnbuffered(false), hasReservedResource(false), isDepthCurrent(false),</td>
    <td class="lineNumber">17</td>
    <td class="lineNumber">314</td>
    <td class="codeLine coveredLine">        isUnbuffered(false), hasReservedResource(false), isDepthCurrent(false),</td>
    <td class="lineNumber">17</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeLine coveredLine">        isHeightCurrent(false) {}</td>
    <td class="lineNumber">17</td>
    <td class="lineNumber">315</td>
    <td class="codeLine coveredLine">        isHeightCurrent(false) {}</td>
    <td class="lineNumber">17</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">316</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeLine">    /// Constructs an SUnit for post-regalloc scheduling to represent a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">317</td>
    <td class="codeLine">    /// Constructs an SUnit for post-regalloc scheduling to represent a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeLine">    /// MachineInstr.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">318</td>
    <td class="codeLine">    /// MachineInstr.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeLine">    SUnit(MachineInstr *instr, unsigned nodenum)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">319</td>
    <td class="codeLine">    SUnit(MachineInstr *instr, unsigned nodenum)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeLine">      : Instr(instr), NodeNum(nodenum), isVRegCycle(false), isCall(false),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">320</td>
    <td class="codeLine">      : Instr(instr), NodeNum(nodenum), isVRegCycle(false), isCall(false),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeLine">        isCallOp(false), isTwoAddress(false), isCommutable(false),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">321</td>
    <td class="codeLine">        isCallOp(false), isTwoAddress(false), isCommutable(false),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeLine">        hasPhysRegUses(false), hasPhysRegDefs(false), hasPhysRegClobbers(false),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">322</td>
    <td class="codeLine">        hasPhysRegUses(false), hasPhysRegDefs(false), hasPhysRegClobbers(false),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeLine">        isPending(false), isAvailable(false), isScheduled(false),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">323</td>
    <td class="codeLine">        isPending(false), isAvailable(false), isScheduled(false),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeLine">        isScheduleHigh(false), isScheduleLow(false), isCloned(false),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">324</td>
    <td class="codeLine">        isScheduleHigh(false), isScheduleLow(false), isCloned(false),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeLine">        isUnbuffered(false), hasReservedResource(false), isDepthCurrent(false),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">325</td>
    <td class="codeLine">        isUnbuffered(false), hasReservedResource(false), isDepthCurrent(false),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeLine">        isHeightCurrent(false) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">326</td>
    <td class="codeLine">        isHeightCurrent(false) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">327</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeLine">    /// Constructs a placeholder SUnit.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">328</td>
    <td class="codeLine">    /// Constructs a placeholder SUnit.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeLine coveredLine">    SUnit()</td>
    <td class="lineNumber">16</td>
    <td class="lineNumber">329</td>
    <td class="codeLine coveredLine">    SUnit()</td>
    <td class="lineNumber">16</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeLine coveredLine">      : isVRegCycle(false), isCall(false), isCallOp(false), isTwoAddress(false),</td>
    <td class="lineNumber">16</td>
    <td class="lineNumber">330</td>
    <td class="codeLine coveredLine">      : isVRegCycle(false), isCall(false), isCallOp(false), isTwoAddress(false),</td>
    <td class="lineNumber">16</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeLine coveredLine">        isCommutable(false), hasPhysRegUses(false), hasPhysRegDefs(false),</td>
    <td class="lineNumber">16</td>
    <td class="lineNumber">331</td>
    <td class="codeLine coveredLine">        isCommutable(false), hasPhysRegUses(false), hasPhysRegDefs(false),</td>
    <td class="lineNumber">16</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeLine coveredLine">        hasPhysRegClobbers(false), isPending(false), isAvailable(false),</td>
    <td class="lineNumber">16</td>
    <td class="lineNumber">332</td>
    <td class="codeLine coveredLine">        hasPhysRegClobbers(false), isPending(false), isAvailable(false),</td>
    <td class="lineNumber">16</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeLine coveredLine">        isScheduled(false), isScheduleHigh(false), isScheduleLow(false),</td>
    <td class="lineNumber">16</td>
    <td class="lineNumber">333</td>
    <td class="codeLine coveredLine">        isScheduled(false), isScheduleHigh(false), isScheduleLow(false),</td>
    <td class="lineNumber">16</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeLine coveredLine">        isCloned(false), isUnbuffered(false), hasReservedResource(false),</td>
    <td class="lineNumber">16</td>
    <td class="lineNumber">334</td>
    <td class="codeLine coveredLine">        isCloned(false), isUnbuffered(false), hasReservedResource(false),</td>
    <td class="lineNumber">16</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeLine coveredLine">        isDepthCurrent(false), isHeightCurrent(false) {}</td>
    <td class="lineNumber">16</td>
    <td class="lineNumber">335</td>
    <td class="codeLine coveredLine">        isDepthCurrent(false), isHeightCurrent(false) {}</td>
    <td class="lineNumber">16</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">336</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeLine">    /// Boundary nodes are placeholders for the boundary of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">337</td>
    <td class="codeLine">    /// Boundary nodes are placeholders for the boundary of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeLine">    /// scheduling region.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">338</td>
    <td class="codeLine">    /// scheduling region.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeLine">    ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">339</td>
    <td class="codeLine">    ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeLine">    /// BoundaryNodes can have DAG edges, including Data edges, but they do not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">340</td>
    <td class="codeLine">    /// BoundaryNodes can have DAG edges, including Data edges, but they do not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeLine">    /// correspond to schedulable entities (e.g. instructions) and do not have a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">341</td>
    <td class="codeLine">    /// correspond to schedulable entities (e.g. instructions) and do not have a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeLine">    /// valid ID. Consequently, always check for boundary nodes before accessing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">342</td>
    <td class="codeLine">    /// valid ID. Consequently, always check for boundary nodes before accessing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeLine">    /// an associative data structure keyed on node ID.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">343</td>
    <td class="codeLine">    /// an associative data structure keyed on node ID.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeLine">    bool isBoundaryNode() const { return NodeNum == BoundaryID; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">344</td>
    <td class="codeLine">    bool isBoundaryNode() const { return NodeNum == BoundaryID; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">345</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeLine">    /// Assigns the representative SDNode for this SUnit. This may be used</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">346</td>
    <td class="codeLine">    /// Assigns the representative SDNode for this SUnit. This may be used</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeLine">    /// during pre-regalloc scheduling.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">347</td>
    <td class="codeLine">    /// during pre-regalloc scheduling.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeLine coveredLine">    void setNode(SDNode *N) {</td>
    <td class="lineNumber">17</td>
    <td class="lineNumber">348</td>
    <td class="codeLine coveredLine">    void setNode(SDNode *N) {</td>
    <td class="lineNumber">17</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeLine coveredLine">      assert(!Instr && "Setting SDNode of SUnit with MachineInstr!");</td>
    <td class="lineNumber">17</td>
    <td class="lineNumber">349</td>
    <td class="codeLine coveredLine">      assert(!Instr && "Setting SDNode of SUnit with MachineInstr!");</td>
    <td class="lineNumber">17</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeLine coveredLine">      Node = N;</td>
    <td class="lineNumber">17</td>
    <td class="lineNumber">350</td>
    <td class="codeLine coveredLine">      Node = N;</td>
    <td class="lineNumber">17</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeLine coveredLine">    }</td>
    <td class="lineNumber">17</td>
    <td class="lineNumber">351</td>
    <td class="codeLine coveredLine">    }</td>
    <td class="lineNumber">17</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">352</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeLine">    /// Returns the representative SDNode for this SUnit. This may be used</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">353</td>
    <td class="codeLine">    /// Returns the representative SDNode for this SUnit. This may be used</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeLine">    /// during pre-regalloc scheduling.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">354</td>
    <td class="codeLine">    /// during pre-regalloc scheduling.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeLine coveredLine">    SDNode *getNode() const {</td>
    <td class="lineNumber">177</td>
    <td class="lineNumber">355</td>
    <td class="codeLine coveredLine">    SDNode *getNode() const {</td>
    <td class="lineNumber">177</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeLine coveredLine">      assert(!Instr && "Reading SDNode of SUnit with MachineInstr!");</td>
    <td class="lineNumber">177</td>
    <td class="lineNumber">356</td>
    <td class="codeLine coveredLine">      assert(!Instr && "Reading SDNode of SUnit with MachineInstr!");</td>
    <td class="lineNumber">177</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeLine coveredLine">      return Node;</td>
    <td class="lineNumber">177</td>
    <td class="lineNumber">357</td>
    <td class="codeLine coveredLine">      return Node;</td>
    <td class="lineNumber">177</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">358</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">359</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeLine">    /// Returns true if this SUnit refers to a machine instruction as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">360</td>
    <td class="codeLine">    /// Returns true if this SUnit refers to a machine instruction as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeLine">    /// opposed to an SDNode.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">361</td>
    <td class="codeLine">    /// opposed to an SDNode.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeLine">    bool isInstr() const { return Instr; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">362</td>
    <td class="codeLine">    bool isInstr() const { return Instr; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">363</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeLine">    /// Assigns the instruction for the SUnit. This may be used during</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">364</td>
    <td class="codeLine">    /// Assigns the instruction for the SUnit. This may be used during</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeLine">    /// post-regalloc scheduling.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">365</td>
    <td class="codeLine">    /// post-regalloc scheduling.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeLine">    void setInstr(MachineInstr *MI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">366</td>
    <td class="codeLine">    void setInstr(MachineInstr *MI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeLine">      assert(!Node && "Setting MachineInstr of SUnit with SDNode!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">367</td>
    <td class="codeLine">      assert(!Node && "Setting MachineInstr of SUnit with SDNode!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeLine">      Instr = MI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">368</td>
    <td class="codeLine">      Instr = MI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">369</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">370</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeLine">    /// Returns the representative MachineInstr for this SUnit. This may be used</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">371</td>
    <td class="codeLine">    /// Returns the representative MachineInstr for this SUnit. This may be used</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeLine">    /// during post-regalloc scheduling.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">372</td>
    <td class="codeLine">    /// during post-regalloc scheduling.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeLine">    MachineInstr *getInstr() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">373</td>
    <td class="codeLine">    MachineInstr *getInstr() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeLine">      assert(!Node && "Reading MachineInstr of SUnit with SDNode!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">374</td>
    <td class="codeLine">      assert(!Node && "Reading MachineInstr of SUnit with SDNode!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeLine">      return Instr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">375</td>
    <td class="codeLine">      return Instr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">376</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">377</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeLine">    /// Adds the specified edge as a pred of the current node if not already.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">378</td>
    <td class="codeLine">    /// Adds the specified edge as a pred of the current node if not already.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeLine">    /// It also adds the current node as a successor of the specified node.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">379</td>
    <td class="codeLine">    /// It also adds the current node as a successor of the specified node.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeLine">    bool addPred(const SDep &D, bool Required = true);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">380</td>
    <td class="codeLine">    bool addPred(const SDep &D, bool Required = true);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">381</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeLine">    /// Adds a barrier edge to SU by calling addPred(), with latency 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">382</td>
    <td class="codeLine">    /// Adds a barrier edge to SU by calling addPred(), with latency 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeLine">    /// generally or latency 1 for a store followed by a load.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">383</td>
    <td class="codeLine">    /// generally or latency 1 for a store followed by a load.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeLine">    bool addPredBarrier(SUnit *SU) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">384</td>
    <td class="codeLine">    bool addPredBarrier(SUnit *SU) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeLine">      SDep Dep(SU, SDep::Barrier);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">385</td>
    <td class="codeLine">      SDep Dep(SU, SDep::Barrier);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeLine">      unsigned TrueMemOrderLatency =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">386</td>
    <td class="codeLine">      unsigned TrueMemOrderLatency =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeLine">        ((SU->getInstr()->mayStore() && this->getInstr()->mayLoad()) ? 1 : 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">387</td>
    <td class="codeLine">        ((SU->getInstr()->mayStore() && this->getInstr()->mayLoad()) ? 1 : 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeLine">      Dep.setLatency(TrueMemOrderLatency);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">388</td>
    <td class="codeLine">      Dep.setLatency(TrueMemOrderLatency);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeLine">      return addPred(Dep);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">389</td>
    <td class="codeLine">      return addPred(Dep);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">390</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">391</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeLine">    /// Removes the specified edge as a pred of the current node if it exists.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">392</td>
    <td class="codeLine">    /// Removes the specified edge as a pred of the current node if it exists.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeLine">    /// It also removes the current node as a successor of the specified node.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">393</td>
    <td class="codeLine">    /// It also removes the current node as a successor of the specified node.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeLine">    void removePred(const SDep &D);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">394</td>
    <td class="codeLine">    void removePred(const SDep &D);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">395</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeLine">    /// Returns the depth of this node, which is the length of the maximum path</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">396</td>
    <td class="codeLine">    /// Returns the depth of this node, which is the length of the maximum path</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeLine">    /// up to any node which has no predecessors.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">397</td>
    <td class="codeLine">    /// up to any node which has no predecessors.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeLine">    unsigned getDepth() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">398</td>
    <td class="codeLine">    unsigned getDepth() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeLine">      if (!isDepthCurrent)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">399</td>
    <td class="codeLine">      if (!isDepthCurrent)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeLine">        const_cast<SUnit *>(this)->ComputeDepth();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">400</td>
    <td class="codeLine">        const_cast<SUnit *>(this)->ComputeDepth();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeLine">      return Depth;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">401</td>
    <td class="codeLine">      return Depth;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">402</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">403</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeLine">    /// Returns the height of this node, which is the length of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">404</td>
    <td class="codeLine">    /// Returns the height of this node, which is the length of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeLine">    /// maximum path down to any node which has no successors.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">405</td>
    <td class="codeLine">    /// maximum path down to any node which has no successors.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeLine coveredLine">    unsigned getHeight() const {</td>
    <td class="lineNumber">83</td>
    <td class="lineNumber">406</td>
    <td class="codeLine coveredLine">    unsigned getHeight() const {</td>
    <td class="lineNumber">83</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeLine coveredLine">      if (!isHeightCurrent)</td>
    <td class="lineNumber">83</td>
    <td class="lineNumber">407</td>
    <td class="codeLine coveredLine">      if (!isHeightCurrent)</td>
    <td class="lineNumber">83</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeLine coveredLine">        const_cast<SUnit *>(this)->ComputeHeight();</td>
    <td class="lineNumber">17</td>
    <td class="lineNumber">408</td>
    <td class="codeLine coveredLine">        const_cast<SUnit *>(this)->ComputeHeight();</td>
    <td class="lineNumber">17</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeLine coveredLine">      return Height;</td>
    <td class="lineNumber">83</td>
    <td class="lineNumber">409</td>
    <td class="codeLine coveredLine">      return Height;</td>
    <td class="lineNumber">83</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">410</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">411</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeLine">    /// If NewDepth is greater than this node's depth value, sets it to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">412</td>
    <td class="codeLine">    /// If NewDepth is greater than this node's depth value, sets it to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeLine">    /// be the new depth value. This also recursively marks successor nodes</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">413</td>
    <td class="codeLine">    /// be the new depth value. This also recursively marks successor nodes</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeLine">    /// dirty.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">414</td>
    <td class="codeLine">    /// dirty.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeLine">    void setDepthToAtLeast(unsigned NewDepth);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">415</td>
    <td class="codeLine">    void setDepthToAtLeast(unsigned NewDepth);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">416</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeLine">    /// If NewHeight is greater than this node's height value, set it to be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">417</td>
    <td class="codeLine">    /// If NewHeight is greater than this node's height value, set it to be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeLine">    /// the new height value. This also recursively marks predecessor nodes</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">418</td>
    <td class="codeLine">    /// the new height value. This also recursively marks predecessor nodes</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeLine">    /// dirty.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">419</td>
    <td class="codeLine">    /// dirty.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeLine">    void setHeightToAtLeast(unsigned NewHeight);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">420</td>
    <td class="codeLine">    void setHeightToAtLeast(unsigned NewHeight);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">421</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeLine">    /// Sets a flag in this node to indicate that its stored Depth value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">422</td>
    <td class="codeLine">    /// Sets a flag in this node to indicate that its stored Depth value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeLine">    /// will require recomputation the next time getDepth() is called.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">423</td>
    <td class="codeLine">    /// will require recomputation the next time getDepth() is called.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeLine">    void setDepthDirty();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">424</td>
    <td class="codeLine">    void setDepthDirty();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">425</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeLine">    /// Sets a flag in this node to indicate that its stored Height value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">426</td>
    <td class="codeLine">    /// Sets a flag in this node to indicate that its stored Height value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeLine">    /// will require recomputation the next time getHeight() is called.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">427</td>
    <td class="codeLine">    /// will require recomputation the next time getHeight() is called.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeLine">    void setHeightDirty();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">428</td>
    <td class="codeLine">    void setHeightDirty();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">429</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeLine">    /// Tests if node N is a predecessor of this node.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">430</td>
    <td class="codeLine">    /// Tests if node N is a predecessor of this node.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeLine">    bool isPred(const SUnit *N) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">431</td>
    <td class="codeLine">    bool isPred(const SUnit *N) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeLine">      for (const SDep &Pred : Preds)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">432</td>
    <td class="codeLine">      for (const SDep &Pred : Preds)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeLine">        if (Pred.getSUnit() == N)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">433</td>
    <td class="codeLine">        if (Pred.getSUnit() == N)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeLine">          return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">434</td>
    <td class="codeLine">          return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">435</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">436</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">437</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeLine">    /// Tests if node N is a successor of this node.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">438</td>
    <td class="codeLine">    /// Tests if node N is a successor of this node.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeLine">    bool isSucc(const SUnit *N) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">439</td>
    <td class="codeLine">    bool isSucc(const SUnit *N) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeLine">      for (const SDep &Succ : Succs)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">440</td>
    <td class="codeLine">      for (const SDep &Succ : Succs)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeLine">        if (Succ.getSUnit() == N)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">441</td>
    <td class="codeLine">        if (Succ.getSUnit() == N)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeLine">          return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">442</td>
    <td class="codeLine">          return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">443</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">444</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">445</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeLine">    bool isTopReady() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">446</td>
    <td class="codeLine">    bool isTopReady() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeLine">      return NumPredsLeft == 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">447</td>
    <td class="codeLine">      return NumPredsLeft == 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">448</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeLine">    bool isBottomReady() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">449</td>
    <td class="codeLine">    bool isBottomReady() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeLine">      return NumSuccsLeft == 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">450</td>
    <td class="codeLine">      return NumSuccsLeft == 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">451</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">452</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeLine">    /// Orders this node's predecessor edges such that the critical path</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">453</td>
    <td class="codeLine">    /// Orders this node's predecessor edges such that the critical path</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeLine">    /// edge occurs first.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">454</td>
    <td class="codeLine">    /// edge occurs first.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeLine">    void biasCriticalPath();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">455</td>
    <td class="codeLine">    void biasCriticalPath();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">456</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeLine">    void dumpAttributes() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">457</td>
    <td class="codeLine">    void dumpAttributes() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">458</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeLine">  private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">459</td>
    <td class="codeLine">  private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeLine">    void ComputeDepth();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">460</td>
    <td class="codeLine">    void ComputeDepth();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeLine">    void ComputeHeight();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">461</td>
    <td class="codeLine">    void ComputeHeight();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">462</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">463</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeLine">  /// Returns true if the specified SDep is equivalent except for latency.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">464</td>
    <td class="codeLine">  /// Returns true if the specified SDep is equivalent except for latency.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeLine coveredLine">  inline bool SDep::overlaps(const SDep &Other) const {</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">465</td>
    <td class="codeLine coveredLine">  inline bool SDep::overlaps(const SDep &Other) const {</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeLine coveredLine">    if (Dep != Other.Dep)</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">466</td>
    <td class="codeLine coveredLine">    if (Dep != Other.Dep)</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeLine coveredLine">      return false;</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">467</td>
    <td class="codeLine coveredLine">      return false;</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeLine">    switch (Dep.getInt()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">468</td>
    <td class="codeLine">    switch (Dep.getInt()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeLine">    case Data:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">469</td>
    <td class="codeLine">    case Data:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeLine">    case Anti:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">470</td>
    <td class="codeLine">    case Anti:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeLine">    case Output:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">471</td>
    <td class="codeLine">    case Output:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeLine">      return Contents.Reg == Other.Contents.Reg;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">472</td>
    <td class="codeLine">      return Contents.Reg == Other.Contents.Reg;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeLine">    case Order:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">473</td>
    <td class="codeLine">    case Order:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeLine">      return Contents.OrdKind == Other.Contents.OrdKind;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">474</td>
    <td class="codeLine">      return Contents.OrdKind == Other.Contents.OrdKind;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">475</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeLine">    llvm_unreachable("Invalid dependency kind!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">476</td>
    <td class="codeLine">    llvm_unreachable("Invalid dependency kind!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">477</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">478</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeLine">  //// Returns the SUnit to which this edge points.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">479</td>
    <td class="codeLine">  //// Returns the SUnit to which this edge points.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeLine coveredLine">  inline SUnit *SDep::getSUnit() const { return Dep.getPointer(); }</td>
    <td class="lineNumber">74</td>
    <td class="lineNumber">480</td>
    <td class="codeLine coveredLine">  inline SUnit *SDep::getSUnit() const { return Dep.getPointer(); }</td>
    <td class="lineNumber">74</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">481</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeLine">  //// Assigns the SUnit to which this edge points.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">482</td>
    <td class="codeLine">  //// Assigns the SUnit to which this edge points.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeLine coveredLine">  inline void SDep::setSUnit(SUnit *SU) { Dep.setPointer(SU); }</td>
    <td class="lineNumber">17</td>
    <td class="lineNumber">483</td>
    <td class="codeLine coveredLine">  inline void SDep::setSUnit(SUnit *SU) { Dep.setPointer(SU); }</td>
    <td class="lineNumber">17</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">484</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeLine">  /// Returns an enum value representing the kind of the dependence.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">485</td>
    <td class="codeLine">  /// Returns an enum value representing the kind of the dependence.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeLine coveredLine">  inline SDep::Kind SDep::getKind() const { return Dep.getInt(); }</td>
    <td class="lineNumber">121</td>
    <td class="lineNumber">486</td>
    <td class="codeLine coveredLine">  inline SDep::Kind SDep::getKind() const { return Dep.getInt(); }</td>
    <td class="lineNumber">121</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">487</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeLine">  //===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">488</td>
    <td class="codeLine">  //===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">489</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeLine">  /// This interface is used to plug different priorities computation</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">490</td>
    <td class="codeLine">  /// This interface is used to plug different priorities computation</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeLine">  /// algorithms into the list scheduler. It implements the interface of a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">491</td>
    <td class="codeLine">  /// algorithms into the list scheduler. It implements the interface of a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeLine">  /// standard priority queue, where nodes are inserted in arbitrary order and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">492</td>
    <td class="codeLine">  /// standard priority queue, where nodes are inserted in arbitrary order and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeLine">  /// returned in priority order.  The computation of the priority and the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">493</td>
    <td class="codeLine">  /// returned in priority order.  The computation of the priority and the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeLine">  /// representation of the queue are totally up to the implementation to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">494</td>
    <td class="codeLine">  /// representation of the queue are totally up to the implementation to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeLine">  /// decide.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">495</td>
    <td class="codeLine">  /// decide.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeLine">  class SchedulingPriorityQueue {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">496</td>
    <td class="codeLine">  class SchedulingPriorityQueue {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeLine">    virtual void anchor();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">497</td>
    <td class="codeLine">    virtual void anchor();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">498</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeLine">    unsigned CurCycle = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">499</td>
    <td class="codeLine">    unsigned CurCycle = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeLine">    bool HasReadyFilter;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">500</td>
    <td class="codeLine">    bool HasReadyFilter;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">501</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">502</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeLine coveredLine">    SchedulingPriorityQueue(bool rf = false) :  HasReadyFilter(rf) {}</td>
    <td class="lineNumber">4</td>
    <td class="lineNumber">503</td>
    <td class="codeLine coveredLine">    SchedulingPriorityQueue(bool rf = false) :  HasReadyFilter(rf) {}</td>
    <td class="lineNumber">4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">504</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeLine coveredLine">    virtual ~SchedulingPriorityQueue() = default;</td>
    <td class="lineNumber">4</td>
    <td class="lineNumber">505</td>
    <td class="codeLine coveredLine">    virtual ~SchedulingPriorityQueue() = default;</td>
    <td class="lineNumber">4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">506</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeLine">    virtual bool isBottomUp() const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">507</td>
    <td class="codeLine">    virtual bool isBottomUp() const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">508</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeLine">    virtual void initNodes(std::vector<SUnit> &SUnits) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">509</td>
    <td class="codeLine">    virtual void initNodes(std::vector<SUnit> &SUnits) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeLine">    virtual void addNode(const SUnit *SU) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">510</td>
    <td class="codeLine">    virtual void addNode(const SUnit *SU) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeLine">    virtual void updateNode(const SUnit *SU) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">511</td>
    <td class="codeLine">    virtual void updateNode(const SUnit *SU) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeLine">    virtual void releaseState() = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">512</td>
    <td class="codeLine">    virtual void releaseState() = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">513</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeLine">    virtual bool empty() const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">514</td>
    <td class="codeLine">    virtual bool empty() const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">515</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeLine coveredLine">    bool hasReadyFilter() const { return HasReadyFilter; }</td>
    <td class="lineNumber">13</td>
    <td class="lineNumber">516</td>
    <td class="codeLine coveredLine">    bool hasReadyFilter() const { return HasReadyFilter; }</td>
    <td class="lineNumber">13</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">517</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeLine">    virtual bool tracksRegPressure() const { return false; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">518</td>
    <td class="codeLine">    virtual bool tracksRegPressure() const { return false; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">519</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeLine">    virtual bool isReady(SUnit *) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">520</td>
    <td class="codeLine">    virtual bool isReady(SUnit *) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeLine">      assert(!HasReadyFilter && "The ready filter must override isReady()");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">521</td>
    <td class="codeLine">      assert(!HasReadyFilter && "The ready filter must override isReady()");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">522</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">523</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">524</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeLine">    virtual void push(SUnit *U) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">525</td>
    <td class="codeLine">    virtual void push(SUnit *U) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">526</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeLine">    void push_all(const std::vector<SUnit *> &Nodes) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">527</td>
    <td class="codeLine">    void push_all(const std::vector<SUnit *> &Nodes) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeLine">      for (SUnit *SU : Nodes)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">528</td>
    <td class="codeLine">      for (SUnit *SU : Nodes)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeLine">        push(SU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">529</td>
    <td class="codeLine">        push(SU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">530</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">531</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeLine">    virtual SUnit *pop() = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">532</td>
    <td class="codeLine">    virtual SUnit *pop() = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">533</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeLine">    virtual void remove(SUnit *SU) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">534</td>
    <td class="codeLine">    virtual void remove(SUnit *SU) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">535</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeLine">    virtual void dump(ScheduleDAG *) const {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">536</td>
    <td class="codeLine">    virtual void dump(ScheduleDAG *) const {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">537</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeLine">    /// As each node is scheduled, this method is invoked.  This allows the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">538</td>
    <td class="codeLine">    /// As each node is scheduled, this method is invoked.  This allows the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeLine">    /// priority function to adjust the priority of related unscheduled nodes,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">539</td>
    <td class="codeLine">    /// priority function to adjust the priority of related unscheduled nodes,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeLine">    /// for example.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">540</td>
    <td class="codeLine">    /// for example.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeLine">    virtual void scheduledNode(SUnit *) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">541</td>
    <td class="codeLine">    virtual void scheduledNode(SUnit *) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">542</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeLine">    virtual void unscheduledNode(SUnit *) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">543</td>
    <td class="codeLine">    virtual void unscheduledNode(SUnit *) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">544</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeLine coveredLine">    void setCurCycle(unsigned Cycle) {</td>
    <td class="lineNumber">17</td>
    <td class="lineNumber">545</td>
    <td class="codeLine coveredLine">    void setCurCycle(unsigned Cycle) {</td>
    <td class="lineNumber">17</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeLine coveredLine">      CurCycle = Cycle;</td>
    <td class="lineNumber">17</td>
    <td class="lineNumber">546</td>
    <td class="codeLine coveredLine">      CurCycle = Cycle;</td>
    <td class="lineNumber">17</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeLine coveredLine">    }</td>
    <td class="lineNumber">17</td>
    <td class="lineNumber">547</td>
    <td class="codeLine coveredLine">    }</td>
    <td class="lineNumber">17</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">548</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeLine">    unsigned getCurCycle() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">549</td>
    <td class="codeLine">    unsigned getCurCycle() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeLine">      return CurCycle;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">550</td>
    <td class="codeLine">      return CurCycle;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">551</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">552</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">553</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeLine">  class ScheduleDAG {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">554</td>
    <td class="codeLine">  class ScheduleDAG {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">555</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeLine">    const LLVMTargetMachine &TM;        ///< Target processor</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">556</td>
    <td class="codeLine">    const LLVMTargetMachine &TM;        ///< Target processor</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeLine">    const TargetInstrInfo *TII;         ///< Target instruction information</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">557</td>
    <td class="codeLine">    const TargetInstrInfo *TII;         ///< Target instruction information</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeLine">    const TargetRegisterInfo *TRI;      ///< Target processor register info</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">558</td>
    <td class="codeLine">    const TargetRegisterInfo *TRI;      ///< Target processor register info</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeLine">    MachineFunction &MF;                ///< Machine function</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">559</td>
    <td class="codeLine">    MachineFunction &MF;                ///< Machine function</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeLine">    MachineRegisterInfo &MRI;           ///< Virtual/real register map</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">560</td>
    <td class="codeLine">    MachineRegisterInfo &MRI;           ///< Virtual/real register map</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeLine">    std::vector<SUnit> SUnits;          ///< The scheduling units.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">561</td>
    <td class="codeLine">    std::vector<SUnit> SUnits;          ///< The scheduling units.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeLine">    SUnit EntrySU;                      ///< Special node for the region entry.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">562</td>
    <td class="codeLine">    SUnit EntrySU;                      ///< Special node for the region entry.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeLine">    SUnit ExitSU;                       ///< Special node for the region exit.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">563</td>
    <td class="codeLine">    SUnit ExitSU;                       ///< Special node for the region exit.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">564</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeLine">#ifdef NDEBUG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">565</td>
    <td class="codeLine">#ifdef NDEBUG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeLine">    static const bool StressSched = false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">566</td>
    <td class="codeLine">    static const bool StressSched = false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeLine">#else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">567</td>
    <td class="codeLine">#else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeLine">    bool StressSched;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">568</td>
    <td class="codeLine">    bool StressSched;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">569</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">570</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeLine">    // This class is designed to be passed by reference only. Copy constructor</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">571</td>
    <td class="codeLine">    // This class is designed to be passed by reference only. Copy constructor</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeLine">    // is declared as deleted here to make the derived classes have deleted</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">572</td>
    <td class="codeLine">    // is declared as deleted here to make the derived classes have deleted</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeLine">    // implicit-declared copy constructor, which suppresses the warnings from</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">573</td>
    <td class="codeLine">    // implicit-declared copy constructor, which suppresses the warnings from</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeLine">    // static analyzer when the derived classes own resources that are freed in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">574</td>
    <td class="codeLine">    // static analyzer when the derived classes own resources that are freed in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeLine">    // their destructors, but don't have user-written copy constructors (rule</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">575</td>
    <td class="codeLine">    // their destructors, but don't have user-written copy constructors (rule</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeLine">    // of three).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">576</td>
    <td class="codeLine">    // of three).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeLine">    ScheduleDAG(const ScheduleDAG &) = delete;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">577</td>
    <td class="codeLine">    ScheduleDAG(const ScheduleDAG &) = delete;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeLine">    ScheduleDAG &operator=(const ScheduleDAG &) = delete;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">578</td>
    <td class="codeLine">    ScheduleDAG &operator=(const ScheduleDAG &) = delete;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">579</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeLine">    explicit ScheduleDAG(MachineFunction &mf);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">580</td>
    <td class="codeLine">    explicit ScheduleDAG(MachineFunction &mf);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">581</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeLine">    virtual ~ScheduleDAG();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">582</td>
    <td class="codeLine">    virtual ~ScheduleDAG();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">583</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeLine">    /// Clears the DAG state (between regions).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">584</td>
    <td class="codeLine">    /// Clears the DAG state (between regions).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeLine">    void clearDAG();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">585</td>
    <td class="codeLine">    void clearDAG();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">586</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeLine">    /// Returns the MCInstrDesc of this SUnit.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">587</td>
    <td class="codeLine">    /// Returns the MCInstrDesc of this SUnit.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeLine">    /// Returns NULL for SDNodes without a machine opcode.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">588</td>
    <td class="codeLine">    /// Returns NULL for SDNodes without a machine opcode.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeLine">    const MCInstrDesc *getInstrDesc(const SUnit *SU) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">589</td>
    <td class="codeLine">    const MCInstrDesc *getInstrDesc(const SUnit *SU) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeLine">      if (SU->isInstr()) return &SU->getInstr()->getDesc();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">590</td>
    <td class="codeLine">      if (SU->isInstr()) return &SU->getInstr()->getDesc();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeLine">      return getNodeDesc(SU->getNode());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">591</td>
    <td class="codeLine">      return getNodeDesc(SU->getNode());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">592</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">593</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeLine">    /// Pops up a GraphViz/gv window with the ScheduleDAG rendered using 'dot'.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">594</td>
    <td class="codeLine">    /// Pops up a GraphViz/gv window with the ScheduleDAG rendered using 'dot'.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeLine">    virtual void viewGraph(const Twine &Name, const Twine &Title);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">595</td>
    <td class="codeLine">    virtual void viewGraph(const Twine &Name, const Twine &Title);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeLine">    virtual void viewGraph();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">596</td>
    <td class="codeLine">    virtual void viewGraph();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">597</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeLine">    virtual void dumpNode(const SUnit &SU) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">598</td>
    <td class="codeLine">    virtual void dumpNode(const SUnit &SU) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeLine">    virtual void dump() const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">599</td>
    <td class="codeLine">    virtual void dump() const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeLine">    void dumpNodeName(const SUnit &SU) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">600</td>
    <td class="codeLine">    void dumpNodeName(const SUnit &SU) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">601</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeLine">    /// Returns a label for an SUnit node in a visualization of the ScheduleDAG.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">602</td>
    <td class="codeLine">    /// Returns a label for an SUnit node in a visualization of the ScheduleDAG.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeLine">    virtual std::string getGraphNodeLabel(const SUnit *SU) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">603</td>
    <td class="codeLine">    virtual std::string getGraphNodeLabel(const SUnit *SU) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">604</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeLine">    /// Returns a label for the region of code covered by the DAG.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">605</td>
    <td class="codeLine">    /// Returns a label for the region of code covered by the DAG.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeLine">    virtual std::string getDAGName() const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">606</td>
    <td class="codeLine">    virtual std::string getDAGName() const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">607</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeLine">    /// Adds custom features for a visualization of the ScheduleDAG.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">608</td>
    <td class="codeLine">    /// Adds custom features for a visualization of the ScheduleDAG.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeLine">    virtual void addCustomGraphFeatures(GraphWriter<ScheduleDAG*> &) const {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">609</td>
    <td class="codeLine">    virtual void addCustomGraphFeatures(GraphWriter<ScheduleDAG*> &) const {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">610</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">611</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeLine">    /// Verifies that all SUnits were scheduled and that their state is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">612</td>
    <td class="codeLine">    /// Verifies that all SUnits were scheduled and that their state is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeLine">    /// consistent. Returns the number of scheduled SUnits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">613</td>
    <td class="codeLine">    /// consistent. Returns the number of scheduled SUnits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeLine">    unsigned VerifyScheduledDAG(bool isBottomUp);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">614</td>
    <td class="codeLine">    unsigned VerifyScheduledDAG(bool isBottomUp);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">615</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">616</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeLine">  protected:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">617</td>
    <td class="codeLine">  protected:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeLine">    void dumpNodeAll(const SUnit &SU) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">618</td>
    <td class="codeLine">    void dumpNodeAll(const SUnit &SU) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">619</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeLine">  private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">620</td>
    <td class="codeLine">  private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeLine">    /// Returns the MCInstrDesc of this SDNode or NULL.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">621</td>
    <td class="codeLine">    /// Returns the MCInstrDesc of this SDNode or NULL.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeLine">    const MCInstrDesc *getNodeDesc(const SDNode *Node) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">622</td>
    <td class="codeLine">    const MCInstrDesc *getNodeDesc(const SDNode *Node) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">623</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">624</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeLine">  class SUnitIterator {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">625</td>
    <td class="codeLine">  class SUnitIterator {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeLine">    SUnit *Node;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">626</td>
    <td class="codeLine">    SUnit *Node;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeLine">    unsigned Operand;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">627</td>
    <td class="codeLine">    unsigned Operand;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">628</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeLine">    SUnitIterator(SUnit *N, unsigned Op) : Node(N), Operand(Op) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">629</td>
    <td class="codeLine">    SUnitIterator(SUnit *N, unsigned Op) : Node(N), Operand(Op) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">630</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">631</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeLine">    using iterator_category = std::forward_iterator_tag;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">632</td>
    <td class="codeLine">    using iterator_category = std::forward_iterator_tag;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeLine">    using value_type = SUnit;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">633</td>
    <td class="codeLine">    using value_type = SUnit;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeLine">    using difference_type = std::ptrdiff_t;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">634</td>
    <td class="codeLine">    using difference_type = std::ptrdiff_t;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeLine">    using pointer = value_type *;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">635</td>
    <td class="codeLine">    using pointer = value_type *;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeLine">    using reference = value_type &;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">636</td>
    <td class="codeLine">    using reference = value_type &;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">637</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeLine">    bool operator==(const SUnitIterator& x) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">638</td>
    <td class="codeLine">    bool operator==(const SUnitIterator& x) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeLine">      return Operand == x.Operand;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">639</td>
    <td class="codeLine">      return Operand == x.Operand;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">640</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeLine">    bool operator!=(const SUnitIterator& x) const { return !operator==(x); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">641</td>
    <td class="codeLine">    bool operator!=(const SUnitIterator& x) const { return !operator==(x); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">642</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeLine">    pointer operator*() const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">643</td>
    <td class="codeLine">    pointer operator*() const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeLine">      return Node->Preds[Operand].getSUnit();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">644</td>
    <td class="codeLine">      return Node->Preds[Operand].getSUnit();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">645</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeLine">    pointer operator->() const { return operator*(); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">646</td>
    <td class="codeLine">    pointer operator->() const { return operator*(); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">647</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeLine">    SUnitIterator& operator++() {                // Preincrement</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">648</td>
    <td class="codeLine">    SUnitIterator& operator++() {                // Preincrement</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeLine">      ++Operand;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">649</td>
    <td class="codeLine">      ++Operand;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">650</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">651</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeLine">    SUnitIterator operator++(int) { // Postincrement</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">652</td>
    <td class="codeLine">    SUnitIterator operator++(int) { // Postincrement</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeLine">      SUnitIterator tmp = *this; ++*this; return tmp;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">653</td>
    <td class="codeLine">      SUnitIterator tmp = *this; ++*this; return tmp;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">654</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">655</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeLine">    static SUnitIterator begin(SUnit *N) { return SUnitIterator(N, 0); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">656</td>
    <td class="codeLine">    static SUnitIterator begin(SUnit *N) { return SUnitIterator(N, 0); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeLine">    static SUnitIterator end  (SUnit *N) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">657</td>
    <td class="codeLine">    static SUnitIterator end  (SUnit *N) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeLine">      return SUnitIterator(N, (unsigned)N->Preds.size());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">658</td>
    <td class="codeLine">      return SUnitIterator(N, (unsigned)N->Preds.size());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">659</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">660</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeLine">    unsigned getOperand() const { return Operand; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">661</td>
    <td class="codeLine">    unsigned getOperand() const { return Operand; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeLine">    const SUnit *getNode() const { return Node; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">662</td>
    <td class="codeLine">    const SUnit *getNode() const { return Node; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">663</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeLine">    /// Tests if this is not an SDep::Data dependence.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">664</td>
    <td class="codeLine">    /// Tests if this is not an SDep::Data dependence.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeLine">    bool isCtrlDep() const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">665</td>
    <td class="codeLine">    bool isCtrlDep() const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeLine">      return getSDep().isCtrl();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">666</td>
    <td class="codeLine">      return getSDep().isCtrl();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">667</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeLine">    bool isArtificialDep() const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">668</td>
    <td class="codeLine">    bool isArtificialDep() const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeLine">      return getSDep().isArtificial();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">669</td>
    <td class="codeLine">      return getSDep().isArtificial();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">670</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeLine">    const SDep &getSDep() const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">671</td>
    <td class="codeLine">    const SDep &getSDep() const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeLine">      return Node->Preds[Operand];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">672</td>
    <td class="codeLine">      return Node->Preds[Operand];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">673</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">674</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">675</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeLine">  template <> struct GraphTraits<SUnit*> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">676</td>
    <td class="codeLine">  template <> struct GraphTraits<SUnit*> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeLine">    typedef SUnit *NodeRef;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">677</td>
    <td class="codeLine">    typedef SUnit *NodeRef;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeLine">    typedef SUnitIterator ChildIteratorType;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">678</td>
    <td class="codeLine">    typedef SUnitIterator ChildIteratorType;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeLine">    static NodeRef getEntryNode(SUnit *N) { return N; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">679</td>
    <td class="codeLine">    static NodeRef getEntryNode(SUnit *N) { return N; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeLine">    static ChildIteratorType child_begin(NodeRef N) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">680</td>
    <td class="codeLine">    static ChildIteratorType child_begin(NodeRef N) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeLine">      return SUnitIterator::begin(N);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">681</td>
    <td class="codeLine">      return SUnitIterator::begin(N);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">682</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeLine">    static ChildIteratorType child_end(NodeRef N) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">683</td>
    <td class="codeLine">    static ChildIteratorType child_end(NodeRef N) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeLine">      return SUnitIterator::end(N);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">684</td>
    <td class="codeLine">      return SUnitIterator::end(N);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">685</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">686</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">687</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeLine">  template <> struct GraphTraits<ScheduleDAG*> : public GraphTraits<SUnit*> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">688</td>
    <td class="codeLine">  template <> struct GraphTraits<ScheduleDAG*> : public GraphTraits<SUnit*> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeLine">    typedef pointer_iterator<std::vector<SUnit>::iterator> nodes_iterator;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">689</td>
    <td class="codeLine">    typedef pointer_iterator<std::vector<SUnit>::iterator> nodes_iterator;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeLine">    static nodes_iterator nodes_begin(ScheduleDAG *G) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">690</td>
    <td class="codeLine">    static nodes_iterator nodes_begin(ScheduleDAG *G) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeLine">      return nodes_iterator(G->SUnits.begin());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">691</td>
    <td class="codeLine">      return nodes_iterator(G->SUnits.begin());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">692</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeLine">    static nodes_iterator nodes_end(ScheduleDAG *G) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">693</td>
    <td class="codeLine">    static nodes_iterator nodes_end(ScheduleDAG *G) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeLine">      return nodes_iterator(G->SUnits.end());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">694</td>
    <td class="codeLine">      return nodes_iterator(G->SUnits.end());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">695</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">696</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">697</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeLine">  /// This class can compute a topological ordering for SUnits and provides</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">698</td>
    <td class="codeLine">  /// This class can compute a topological ordering for SUnits and provides</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeLine">  /// methods for dynamically updating the ordering as new edges are added.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">699</td>
    <td class="codeLine">  /// methods for dynamically updating the ordering as new edges are added.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">700</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeLine">  /// This allows a very fast implementation of IsReachable, for example.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">701</td>
    <td class="codeLine">  /// This allows a very fast implementation of IsReachable, for example.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeLine">  class ScheduleDAGTopologicalSort {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">702</td>
    <td class="codeLine">  class ScheduleDAGTopologicalSort {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeLine">    /// A reference to the ScheduleDAG's SUnits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">703</td>
    <td class="codeLine">    /// A reference to the ScheduleDAG's SUnits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeLine">    std::vector<SUnit> &SUnits;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">704</td>
    <td class="codeLine">    std::vector<SUnit> &SUnits;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeLine">    SUnit *ExitSU;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">705</td>
    <td class="codeLine">    SUnit *ExitSU;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">706</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeLine">    // Have any new nodes been added?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">707</td>
    <td class="codeLine">    // Have any new nodes been added?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeLine">    bool Dirty = false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">708</td>
    <td class="codeLine">    bool Dirty = false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">709</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeLine">    // Outstanding added edges, that have not been applied to the ordering.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">710</td>
    <td class="codeLine">    // Outstanding added edges, that have not been applied to the ordering.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeLine">    SmallVector<std::pair<SUnit *, SUnit *>, 16> Updates;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">711</td>
    <td class="codeLine">    SmallVector<std::pair<SUnit *, SUnit *>, 16> Updates;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">712</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeLine">    /// Maps topological index to the node number.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">713</td>
    <td class="codeLine">    /// Maps topological index to the node number.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeLine">    std::vector<int> Index2Node;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">714</td>
    <td class="codeLine">    std::vector<int> Index2Node;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeLine">    /// Maps the node number to its topological index.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">715</td>
    <td class="codeLine">    /// Maps the node number to its topological index.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeLine">    std::vector<int> Node2Index;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">716</td>
    <td class="codeLine">    std::vector<int> Node2Index;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeLine">    /// a set of nodes visited during a DFS traversal.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">717</td>
    <td class="codeLine">    /// a set of nodes visited during a DFS traversal.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeLine">    BitVector Visited;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">718</td>
    <td class="codeLine">    BitVector Visited;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">719</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeLine">    /// Makes a DFS traversal and mark all nodes affected by the edge insertion.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">720</td>
    <td class="codeLine">    /// Makes a DFS traversal and mark all nodes affected by the edge insertion.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeLine">    /// These nodes will later get new topological indexes by means of the Shift</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">721</td>
    <td class="codeLine">    /// These nodes will later get new topological indexes by means of the Shift</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeLine">    /// method.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">722</td>
    <td class="codeLine">    /// method.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeLine">    void DFS(const SUnit *SU, int UpperBound, bool& HasLoop);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">723</td>
    <td class="codeLine">    void DFS(const SUnit *SU, int UpperBound, bool& HasLoop);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">724</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeLine">    /// Reassigns topological indexes for the nodes in the DAG to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">725</td>
    <td class="codeLine">    /// Reassigns topological indexes for the nodes in the DAG to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeLine">    /// preserve the topological ordering.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">726</td>
    <td class="codeLine">    /// preserve the topological ordering.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeLine">    void Shift(BitVector& Visited, int LowerBound, int UpperBound);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">727</td>
    <td class="codeLine">    void Shift(BitVector& Visited, int LowerBound, int UpperBound);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">728</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeLine">    /// Assigns the topological index to the node n.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">729</td>
    <td class="codeLine">    /// Assigns the topological index to the node n.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeLine">    void Allocate(int n, int index);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">730</td>
    <td class="codeLine">    void Allocate(int n, int index);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">731</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeLine">    /// Fix the ordering, by either recomputing from scratch or by applying</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">732</td>
    <td class="codeLine">    /// Fix the ordering, by either recomputing from scratch or by applying</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeLine">    /// any outstanding updates. Uses a heuristic to estimate what will be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">733</td>
    <td class="codeLine">    /// any outstanding updates. Uses a heuristic to estimate what will be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeLine">    /// cheaper.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">734</td>
    <td class="codeLine">    /// cheaper.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeLine">    void FixOrder();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">735</td>
    <td class="codeLine">    void FixOrder();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">736</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">737</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeLine">    ScheduleDAGTopologicalSort(std::vector<SUnit> &SUnits, SUnit *ExitSU);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">738</td>
    <td class="codeLine">    ScheduleDAGTopologicalSort(std::vector<SUnit> &SUnits, SUnit *ExitSU);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">739</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeLine">    /// Add a SUnit without predecessors to the end of the topological order. It</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">740</td>
    <td class="codeLine">    /// Add a SUnit without predecessors to the end of the topological order. It</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeLine">    /// also must be the first new node added to the DAG.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">741</td>
    <td class="codeLine">    /// also must be the first new node added to the DAG.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeLine">    void AddSUnitWithoutPredecessors(const SUnit *SU);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">742</td>
    <td class="codeLine">    void AddSUnitWithoutPredecessors(const SUnit *SU);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">743</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeLine">    /// Creates the initial topological ordering from the DAG to be scheduled.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">744</td>
    <td class="codeLine">    /// Creates the initial topological ordering from the DAG to be scheduled.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeLine">    void InitDAGTopologicalSorting();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">745</td>
    <td class="codeLine">    void InitDAGTopologicalSorting();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">746</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeLine">    /// Returns an array of SUs that are both in the successor</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">747</td>
    <td class="codeLine">    /// Returns an array of SUs that are both in the successor</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeLine">    /// subtree of StartSU and in the predecessor subtree of TargetSU.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">748</td>
    <td class="codeLine">    /// subtree of StartSU and in the predecessor subtree of TargetSU.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeLine">    /// StartSU and TargetSU are not in the array.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">749</td>
    <td class="codeLine">    /// StartSU and TargetSU are not in the array.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeLine">    /// Success is false if TargetSU is not in the successor subtree of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">750</td>
    <td class="codeLine">    /// Success is false if TargetSU is not in the successor subtree of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeLine">    /// StartSU, else it is true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">751</td>
    <td class="codeLine">    /// StartSU, else it is true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeLine">    std::vector<int> GetSubGraph(const SUnit &StartSU, const SUnit &TargetSU,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">752</td>
    <td class="codeLine">    std::vector<int> GetSubGraph(const SUnit &StartSU, const SUnit &TargetSU,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeLine">                                 bool &Success);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">753</td>
    <td class="codeLine">                                 bool &Success);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">754</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeLine">    /// Checks if \p SU is reachable from \p TargetSU.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">755</td>
    <td class="codeLine">    /// Checks if \p SU is reachable from \p TargetSU.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeLine">    bool IsReachable(const SUnit *SU, const SUnit *TargetSU);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">756</td>
    <td class="codeLine">    bool IsReachable(const SUnit *SU, const SUnit *TargetSU);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">757</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeLine">    /// Returns true if addPred(TargetSU, SU) creates a cycle.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">758</td>
    <td class="codeLine">    /// Returns true if addPred(TargetSU, SU) creates a cycle.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeLine">    bool WillCreateCycle(SUnit *TargetSU, SUnit *SU);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">759</td>
    <td class="codeLine">    bool WillCreateCycle(SUnit *TargetSU, SUnit *SU);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">760</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeLine">    /// Updates the topological ordering to accommodate an edge to be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">761</td>
    <td class="codeLine">    /// Updates the topological ordering to accommodate an edge to be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeLine">    /// added from SUnit \p X to SUnit \p Y.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">762</td>
    <td class="codeLine">    /// added from SUnit \p X to SUnit \p Y.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeLine">    void AddPred(SUnit *Y, SUnit *X);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">763</td>
    <td class="codeLine">    void AddPred(SUnit *Y, SUnit *X);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">764</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeLine">    /// Queues an update to the topological ordering to accommodate an edge to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">765</td>
    <td class="codeLine">    /// Queues an update to the topological ordering to accommodate an edge to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeLine">    /// be added from SUnit \p X to SUnit \p Y.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">766</td>
    <td class="codeLine">    /// be added from SUnit \p X to SUnit \p Y.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeLine">    void AddPredQueued(SUnit *Y, SUnit *X);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">767</td>
    <td class="codeLine">    void AddPredQueued(SUnit *Y, SUnit *X);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">768</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeLine">    /// Updates the topological ordering to accommodate an an edge to be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">769</td>
    <td class="codeLine">    /// Updates the topological ordering to accommodate an an edge to be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeLine">    /// removed from the specified node \p N from the predecessors of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">770</td>
    <td class="codeLine">    /// removed from the specified node \p N from the predecessors of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeLine">    /// current node \p M.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">771</td>
    <td class="codeLine">    /// current node \p M.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeLine">    void RemovePred(SUnit *M, SUnit *N);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">772</td>
    <td class="codeLine">    void RemovePred(SUnit *M, SUnit *N);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">773</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeLine">    /// Mark the ordering as temporarily broken, after a new node has been</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">774</td>
    <td class="codeLine">    /// Mark the ordering as temporarily broken, after a new node has been</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeLine">    /// added.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">775</td>
    <td class="codeLine">    /// added.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeLine coveredLine">    void MarkDirty() { Dirty = true; }</td>
    <td class="lineNumber">4</td>
    <td class="lineNumber">776</td>
    <td class="codeLine coveredLine">    void MarkDirty() { Dirty = true; }</td>
    <td class="lineNumber">4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">777</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeLine">    typedef std::vector<int>::iterator iterator;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">778</td>
    <td class="codeLine">    typedef std::vector<int>::iterator iterator;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeLine">    typedef std::vector<int>::const_iterator const_iterator;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">779</td>
    <td class="codeLine">    typedef std::vector<int>::const_iterator const_iterator;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeLine">    iterator begin() { return Index2Node.begin(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">780</td>
    <td class="codeLine">    iterator begin() { return Index2Node.begin(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeLine">    const_iterator begin() const { return Index2Node.begin(); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">781</td>
    <td class="codeLine">    const_iterator begin() const { return Index2Node.begin(); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeLine">    iterator end() { return Index2Node.end(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">782</td>
    <td class="codeLine">    iterator end() { return Index2Node.end(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeLine">    const_iterator end() const { return Index2Node.end(); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">783</td>
    <td class="codeLine">    const_iterator end() const { return Index2Node.end(); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">784</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeLine">    typedef std::vector<int>::reverse_iterator reverse_iterator;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">785</td>
    <td class="codeLine">    typedef std::vector<int>::reverse_iterator reverse_iterator;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeLine">    typedef std::vector<int>::const_reverse_iterator const_reverse_iterator;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">786</td>
    <td class="codeLine">    typedef std::vector<int>::const_reverse_iterator const_reverse_iterator;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeLine">    reverse_iterator rbegin() { return Index2Node.rbegin(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">787</td>
    <td class="codeLine">    reverse_iterator rbegin() { return Index2Node.rbegin(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeLine">    const_reverse_iterator rbegin() const { return Index2Node.rbegin(); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">788</td>
    <td class="codeLine">    const_reverse_iterator rbegin() const { return Index2Node.rbegin(); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeLine">    reverse_iterator rend() { return Index2Node.rend(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">789</td>
    <td class="codeLine">    reverse_iterator rend() { return Index2Node.rend(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeLine">    const_reverse_iterator rend() const { return Index2Node.rend(); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">790</td>
    <td class="codeLine">    const_reverse_iterator rend() const { return Index2Node.rend(); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">791</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">792</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeLine">} // end namespace llvm</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">793</td>
    <td class="codeLine">} // end namespace llvm</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">794</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeLine">#endif // LLVM_CODEGEN_SCHEDULEDAG_H</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">795</td>
    <td class="codeLine">#endif // LLVM_CODEGEN_SCHEDULEDAG_H</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">796</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
</table>
    </div>
    <button id="myBtn" onclick="topFunction()" title="Go to top" type="button">Top</button>
    <script src="../Javascript/drop_down.js"></script>
    <script src="../Javascript/top_button.js"></script>
  </body>
</html>