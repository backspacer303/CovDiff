<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>AMDGPUCodeGenPrepare.cpp</title>
    <link rel="stylesheet" href="../Style/style.css" />
  </head>
  <body>
    <div class="headerDiv">
      <h1>
        Code Coverage
      </h1>
      <p>
        Source file: /home/nikola/Desktop/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp
      </p>
    </div>
    <button class="collapsible" type="button">Open Summary Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Summary Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line number</th>
    <th class="mainTh">Line</th>
    <th class="mainTh">Number of hits</th>
    <th class="mainTh">Tests that cover line</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="">//===-- AMDGPUCodeGenPrepare.cpp ------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="">/// \file</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="">/// This pass does misc. AMDGPU optimizations on IR before instruction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="">/// selection.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="">#include "AMDGPU.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="">#include "AMDGPUTargetMachine.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="">#include "SIModeRegisterDefaults.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="">#include "llvm/Analysis/AssumptionCache.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="">#include "llvm/Analysis/ConstantFolding.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="">#include "llvm/Analysis/TargetLibraryInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="">#include "llvm/Analysis/UniformityAnalysis.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="">#include "llvm/Analysis/ValueTracking.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="">#include "llvm/CodeGen/TargetPassConfig.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="">#include "llvm/IR/Dominators.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="">#include "llvm/IR/IRBuilder.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="">#include "llvm/IR/InstVisitor.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="">#include "llvm/IR/IntrinsicsAMDGPU.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="">#include "llvm/IR/PatternMatch.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="">#include "llvm/InitializePasses.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="">#include "llvm/Pass.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="">#include "llvm/Support/KnownBits.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="">#include "llvm/Transforms/Utils/IntegerDivision.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="">#include "llvm/Transforms/Utils/Local.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="">#define DEBUG_TYPE "amdgpu-codegenprepare"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="">using namespace llvm;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="">using namespace llvm::PatternMatch;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="">namespace {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="">static cl::opt<bool> WidenLoads(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="">  "amdgpu-codegenprepare-widen-constant-loads",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="">  cl::desc("Widen sub-dword constant address space loads in AMDGPUCodeGenPrepare"),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="">  cl::ReallyHidden,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="">  cl::init(false));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="">static cl::opt<bool> Widen16BitOps(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="">  "amdgpu-codegenprepare-widen-16-bit-ops",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="">  cl::desc("Widen uniform 16-bit instructions to 32-bit in AMDGPUCodeGenPrepare"),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="">  cl::ReallyHidden,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="">  cl::init(true));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="">static cl::opt<bool></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="">    ScalarizeLargePHIs("amdgpu-codegenprepare-break-large-phis",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="">                       cl::desc("Break large PHI nodes for DAGISel"),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="">                       cl::ReallyHidden, cl::init(true));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="">static cl::opt<bool></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="">    ForceScalarizeLargePHIs("amdgpu-codegenprepare-force-break-large-phis",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="">                            cl::desc("For testing purposes, always break large "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="">                                     "PHIs even if it isn't profitable."),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="">                            cl::ReallyHidden, cl::init(false));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="">static cl::opt<unsigned> ScalarizeLargePHIsThreshold(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="">    "amdgpu-codegenprepare-break-large-phis-threshold",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="">    cl::desc("Minimum type size in bits for breaking large PHI nodes"),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="">    cl::ReallyHidden, cl::init(32));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="">static cl::opt<bool> UseMul24Intrin(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="">  "amdgpu-codegenprepare-mul24",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="">  cl::desc("Introduce mul24 intrinsics in AMDGPUCodeGenPrepare"),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="">  cl::ReallyHidden,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="">  cl::init(true));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="">// Legalize 64-bit division by using the generic IR expansion.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="">static cl::opt<bool> ExpandDiv64InIR(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="">  "amdgpu-codegenprepare-expand-div64",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="">  cl::desc("Expand 64-bit division in AMDGPUCodeGenPrepare"),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="">  cl::ReallyHidden,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="">  cl::init(false));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="">// Leave all division operations as they are. This supersedes ExpandDiv64InIR</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="">// and is used for testing the legalizer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="">static cl::opt<bool> DisableIDivExpand(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="">  "amdgpu-codegenprepare-disable-idiv-expansion",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="">  cl::desc("Prevent expanding integer division in AMDGPUCodeGenPrepare"),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="">  cl::ReallyHidden,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="">  cl::init(false));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="">// Disable processing of fdiv so we can better test the backend implementations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="">static cl::opt<bool> DisableFDivExpand(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="">  "amdgpu-codegenprepare-disable-fdiv-expansion",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="">  cl::desc("Prevent expanding floating point division in AMDGPUCodeGenPrepare"),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="">  cl::ReallyHidden,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="">  cl::init(false));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="">class AMDGPUCodeGenPrepareImpl</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="">    : public InstVisitor<AMDGPUCodeGenPrepareImpl, bool> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="">  const GCNSubtarget *ST = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="">  const TargetLibraryInfo *TLInfo = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="">  AssumptionCache *AC = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="">  DominatorTree *DT = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="">  UniformityInfo *UA = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="">  Module *Mod = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="">  const DataLayout *DL = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="">  bool HasUnsafeFPMath = false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="">  bool HasFP32DenormalFlush = false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="">  bool FlowChanged = false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="">  DenseMap<const PHINode *, bool> BreakPhiNodesCache;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="">  bool canBreakPHINode(const PHINode &I);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="">  /// Copies exact/nsw/nuw flags (if any) from binary operation \p I to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="">  /// binary operation \p V.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="">  /// \returns Binary operation \p V.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="">  /// \returns \p T's base element bit width.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="">  unsigned getBaseElementBitWidth(const Type *T) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="">  /// \returns Equivalent 32 bit integer type for given type \p T. For example,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="">  /// if \p T is i7, then i32 is returned; if \p T is <3 x i12>, then <3 x i32></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="">  /// is returned.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="">  Type *getI32Ty(IRBuilder<> &B, const Type *T) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="">  /// \returns True if binary operation \p I is a signed binary operation, false</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="">  /// otherwise.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="">  bool isSigned(const BinaryOperator &I) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="">  /// \returns True if the condition of 'select' operation \p I comes from a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="">  /// signed 'icmp' operation, false otherwise.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="">  bool isSigned(const SelectInst &I) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="">  /// \returns True if type \p T needs to be promoted to 32 bit integer type,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="">  /// false otherwise.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="">  bool needsPromotionToI32(const Type *T) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="">  /// Return true if \p T is a legal scalar floating point type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="">  bool isLegalFloatingTy(const Type *T) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="">  /// Wrapper to pass all the arguments to computeKnownFPClass</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="uncoveredLine">  KnownFPClass computeKnownFPClass(const Value *V, FPClassTest Interested,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="">                                   const Instruction *CtxI) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="uncoveredLine">    return llvm::computeKnownFPClass(V, *DL, Interested, 0, TLInfo, AC, CtxI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="uncoveredLine">                                     DT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="uncoveredLine">  bool canIgnoreDenormalInput(const Value *V, const Instruction *CtxI) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="uncoveredLine">    return HasFP32DenormalFlush ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="uncoveredLine">           computeKnownFPClass(V, fcSubnormal, CtxI).isKnownNeverSubnormal();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="">  /// Promotes uniform binary operation \p I to equivalent 32 bit binary</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="">  /// operation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="">  /// \details \p I's base element bit width must be greater than 1 and less</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="">  /// than or equal 16. Promotion is done by sign or zero extending operands to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="">  /// 32 bits, replacing \p I with equivalent 32 bit binary operation, and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="">  /// truncating the result of 32 bit binary operation back to \p I's original</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="">  /// type. Division operation is not promoted.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="">  /// \returns True if \p I is promoted to equivalent 32 bit binary operation,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="">  /// false otherwise.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="">  bool promoteUniformOpToI32(BinaryOperator &I) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="">  /// Promotes uniform 'icmp' operation \p I to 32 bit 'icmp' operation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="">  /// \details \p I's base element bit width must be greater than 1 and less</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="">  /// than or equal 16. Promotion is done by sign or zero extending operands to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="">  /// 32 bits, and replacing \p I with 32 bit 'icmp' operation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="">  /// \returns True.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="">  bool promoteUniformOpToI32(ICmpInst &I) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="">  /// Promotes uniform 'select' operation \p I to 32 bit 'select'</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="">  /// operation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="">  /// \details \p I's base element bit width must be greater than 1 and less</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="">  /// than or equal 16. Promotion is done by sign or zero extending operands to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="">  /// 32 bits, replacing \p I with 32 bit 'select' operation, and truncating the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="">  /// result of 32 bit 'select' operation back to \p I's original type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="">  /// \returns True.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="">  bool promoteUniformOpToI32(SelectInst &I) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="">  /// Promotes uniform 'bitreverse' intrinsic \p I to 32 bit 'bitreverse'</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="">  /// intrinsic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="">  /// \details \p I's base element bit width must be greater than 1 and less</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="">  /// than or equal 16. Promotion is done by zero extending the operand to 32</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="">  /// bits, replacing \p I with 32 bit 'bitreverse' intrinsic, shifting the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="">  /// result of 32 bit 'bitreverse' intrinsic to the right with zero fill (the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="">  /// shift amount is 32 minus \p I's base element bit width), and truncating</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="">  /// the result of the shift operation back to \p I's original type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="">  /// \returns True.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="">  bool promoteUniformBitreverseToI32(IntrinsicInst &I) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="">  /// \returns The minimum number of bits needed to store the value of \Op as an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="">  /// unsigned integer. Truncating to this size and then zero-extending to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="">  /// the original will not change the value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="">  unsigned numBitsUnsigned(Value *Op) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="">  /// \returns The minimum number of bits needed to store the value of \Op as a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="">  /// signed integer. Truncating to this size and then sign-extending to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="">  /// the original size will not change the value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="">  unsigned numBitsSigned(Value *Op) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="">  /// Replace mul instructions with llvm.amdgcn.mul.u24 or llvm.amdgcn.mul.s24.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="">  /// SelectionDAG has an issue where an and asserting the bits are known</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="">  bool replaceMulWithMul24(BinaryOperator &I) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="">  /// Perform same function as equivalently named function in DAGCombiner. Since</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="">  /// we expand some divisions here, we need to perform this before obscuring.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="">  bool foldBinOpIntoSelect(BinaryOperator &I) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="">  bool divHasSpecialOptimization(BinaryOperator &I,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="">                                 Value *Num, Value *Den) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="">  int getDivNumBits(BinaryOperator &I,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="">                    Value *Num, Value *Den,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="">                    unsigned AtLeast, bool Signed) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="">  /// Expands 24 bit div or rem.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="">  Value* expandDivRem24(IRBuilder<> &Builder, BinaryOperator &I,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="">                        Value *Num, Value *Den,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="">                        bool IsDiv, bool IsSigned) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="">  Value *expandDivRem24Impl(IRBuilder<> &Builder, BinaryOperator &I,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="">                            Value *Num, Value *Den, unsigned NumBits,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="">                            bool IsDiv, bool IsSigned) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="">  /// Expands 32 bit div or rem.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="">  Value* expandDivRem32(IRBuilder<> &Builder, BinaryOperator &I,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="">                        Value *Num, Value *Den) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="">  Value *shrinkDivRem64(IRBuilder<> &Builder, BinaryOperator &I,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="">                        Value *Num, Value *Den) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="">  void expandDivRem64(BinaryOperator &I) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="">  /// Widen a scalar load.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="">  /// \details \p Widen scalar load for uniform, small type loads from constant</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="">  //  memory / to a full 32-bits and then truncate the input to allow a scalar</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="">  //  load instead of a vector load.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="">  /// \returns True.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="">  bool canWidenScalarExtLoad(LoadInst &I) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="">  Value *matchFractPat(IntrinsicInst &I);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="">  Value *applyFractPat(IRBuilder<> &Builder, Value *FractArg);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="">  bool canOptimizeWithRsq(const FPMathOperator *SqrtOp, FastMathFlags DivFMF,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="">                          FastMathFlags SqrtFMF) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="">  Value *optimizeWithRsq(IRBuilder<> &Builder, Value *Num, Value *Den,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="">                         FastMathFlags DivFMF, FastMathFlags SqrtFMF,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="">                         const Instruction *CtxI) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="">  Value *optimizeWithRcp(IRBuilder<> &Builder, Value *Num, Value *Den,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="">                         FastMathFlags FMF, const Instruction *CtxI) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="">  Value *optimizeWithFDivFast(IRBuilder<> &Builder, Value *Num, Value *Den,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="">                              float ReqdAccuracy) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="">  Value *visitFDivElement(IRBuilder<> &Builder, Value *Num, Value *Den,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="">                          FastMathFlags DivFMF, FastMathFlags SqrtFMF,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="">                          Value *RsqOp, const Instruction *FDiv,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="">                          float ReqdAccuracy) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="">  std::pair<Value *, Value *> getFrexpResults(IRBuilder<> &Builder,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="">                                              Value *Src) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="">  Value *emitRcpIEEE1ULP(IRBuilder<> &Builder, Value *Src,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="">                         bool IsNegative) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="">  Value *emitFrexpDiv(IRBuilder<> &Builder, Value *LHS, Value *RHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="">                      FastMathFlags FMF) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="">  bool visitFDiv(BinaryOperator &I);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="uncoveredLine">  bool visitInstruction(Instruction &I) { return false; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="">  bool visitBinaryOperator(BinaryOperator &I);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="">  bool visitLoadInst(LoadInst &I);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="">  bool visitICmpInst(ICmpInst &I);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="">  bool visitSelectInst(SelectInst &I);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="">  bool visitPHINode(PHINode &I);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="">  bool visitIntrinsicInst(IntrinsicInst &I);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="">  bool visitBitreverseIntrinsicInst(IntrinsicInst &I);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="">  bool visitMinNum(IntrinsicInst &I);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="">  bool run(Function &F);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="">class AMDGPUCodeGenPrepare : public FunctionPass {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="">  AMDGPUCodeGenPrepareImpl Impl;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="">  static char ID;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="uncoveredLine">  AMDGPUCodeGenPrepare() : FunctionPass(ID) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="uncoveredLine">    initializeAMDGPUCodeGenPreparePass(*PassRegistry::getPassRegistry());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="uncoveredLine">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="uncoveredLine">    AU.addRequired<AssumptionCacheTracker>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="uncoveredLine">    AU.addRequired<UniformityInfoWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="uncoveredLine">    AU.addRequired<TargetLibraryInfoWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="">    // FIXME: Division expansion needs to preserve the dominator tree.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="uncoveredLine">    if (!ExpandDiv64InIR)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="uncoveredLine">      AU.setPreservesAll();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="">  bool runOnFunction(Function &F) override;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="">  bool doInitialization(Module &M) override;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="uncoveredLine">  StringRef getPassName() const override { return "AMDGPU IR optimizations"; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="">} // end anonymous namespace</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="uncoveredLine">bool AMDGPUCodeGenPrepareImpl::run(Function &F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="uncoveredLine">  bool MadeChange = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="uncoveredLine">  Function::iterator NextBB;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="uncoveredLine">  for (Function::iterator FI = F.begin(), FE = F.end(); FI != FE; FI = NextBB) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="uncoveredLine">    BasicBlock *BB = &*FI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="uncoveredLine">    NextBB = std::next(FI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="uncoveredLine">    BasicBlock::iterator Next;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="uncoveredLine">    for (BasicBlock::iterator I = BB->begin(), E = BB->end(); I != E;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="uncoveredLine">         I = Next) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="uncoveredLine">      Next = std::next(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="uncoveredLine">      MadeChange |= visit(*I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="uncoveredLine">      if (Next != E) { // Control flow changed</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="uncoveredLine">        BasicBlock *NextInstBB = Next->getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="uncoveredLine">        if (NextInstBB != BB) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="uncoveredLine">          BB = NextInstBB;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="uncoveredLine">          E = BB->end();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="uncoveredLine">          FE = F.end();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="uncoveredLine">  return MadeChange;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="uncoveredLine">unsigned AMDGPUCodeGenPrepareImpl::getBaseElementBitWidth(const Type *T) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="uncoveredLine">  assert(needsPromotionToI32(T) && "T does not need promotion to i32");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="uncoveredLine">  if (T->isIntegerTy())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="uncoveredLine">    return T->getIntegerBitWidth();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="uncoveredLine">  return cast<VectorType>(T)->getElementType()->getIntegerBitWidth();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="uncoveredLine">Type *AMDGPUCodeGenPrepareImpl::getI32Ty(IRBuilder<> &B, const Type *T) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="uncoveredLine">  assert(needsPromotionToI32(T) && "T does not need promotion to i32");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="uncoveredLine">  if (T->isIntegerTy())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="uncoveredLine">    return B.getInt32Ty();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="uncoveredLine">  return FixedVectorType::get(B.getInt32Ty(), cast<FixedVectorType>(T));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="uncoveredLine">bool AMDGPUCodeGenPrepareImpl::isSigned(const BinaryOperator &I) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="uncoveredLine">  return I.getOpcode() == Instruction::AShr ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="uncoveredLine">      I.getOpcode() == Instruction::SDiv || I.getOpcode() == Instruction::SRem;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="uncoveredLine">bool AMDGPUCodeGenPrepareImpl::isSigned(const SelectInst &I) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="uncoveredLine">  return isa<ICmpInst>(I.getOperand(0)) ?</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="uncoveredLine">      cast<ICmpInst>(I.getOperand(0))->isSigned() : false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="uncoveredLine">bool AMDGPUCodeGenPrepareImpl::needsPromotionToI32(const Type *T) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="uncoveredLine">  if (!Widen16BitOps)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="uncoveredLine">  const IntegerType *IntTy = dyn_cast<IntegerType>(T);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="uncoveredLine">  if (IntTy && IntTy->getBitWidth() > 1 && IntTy->getBitWidth() <= 16)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="uncoveredLine">  if (const VectorType *VT = dyn_cast<VectorType>(T)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="">    // TODO: The set of packed operations is more limited, so may want to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="">    // promote some anyway.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="uncoveredLine">    if (ST->hasVOP3PInsts())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="uncoveredLine">    return needsPromotionToI32(VT->getElementType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="uncoveredLine">bool AMDGPUCodeGenPrepareImpl::isLegalFloatingTy(const Type *Ty) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="uncoveredLine">  return Ty->isFloatTy() || Ty->isDoubleTy() ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="uncoveredLine">         (Ty->isHalfTy() && ST->has16BitInsts());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="">// Return true if the op promoted to i32 should have nsw set.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="uncoveredLine">static bool promotedOpIsNSW(const Instruction &I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="uncoveredLine">  switch (I.getOpcode()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="uncoveredLine">  case Instruction::Shl:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="">  case Instruction::Add:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="">  case Instruction::Sub:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="uncoveredLine">  case Instruction::Mul:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="uncoveredLine">    return I.hasNoUnsignedWrap();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="uncoveredLine">  default:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="">// Return true if the op promoted to i32 should have nuw set.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="uncoveredLine">static bool promotedOpIsNUW(const Instruction &I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="uncoveredLine">  switch (I.getOpcode()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="uncoveredLine">  case Instruction::Shl:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="">  case Instruction::Add:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="">  case Instruction::Mul:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="uncoveredLine">  case Instruction::Sub:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="uncoveredLine">    return I.hasNoUnsignedWrap();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="uncoveredLine">  default:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="uncoveredLine">bool AMDGPUCodeGenPrepareImpl::canWidenScalarExtLoad(LoadInst &I) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="uncoveredLine">  Type *Ty = I.getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="uncoveredLine">  const DataLayout &DL = Mod->getDataLayout();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="uncoveredLine">  int TySize = DL.getTypeSizeInBits(Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="uncoveredLine">  Align Alignment = DL.getValueOrABITypeAlignment(I.getAlign(), Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="uncoveredLine">  return I.isSimple() && TySize < 32 && Alignment >= 4 && UA->isUniform(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="uncoveredLine">bool AMDGPUCodeGenPrepareImpl::promoteUniformOpToI32(BinaryOperator &I) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="uncoveredLine">  assert(needsPromotionToI32(I.getType()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="">         "I does not need promotion to i32");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="uncoveredLine">  if (I.getOpcode() == Instruction::SDiv ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="uncoveredLine">      I.getOpcode() == Instruction::UDiv ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="uncoveredLine">      I.getOpcode() == Instruction::SRem ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="uncoveredLine">      I.getOpcode() == Instruction::URem)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="uncoveredLine">  IRBuilder<> Builder(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="uncoveredLine">  Builder.SetCurrentDebugLocation(I.getDebugLoc());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="uncoveredLine">  Type *I32Ty = getI32Ty(Builder, I.getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="uncoveredLine">  Value *ExtOp0 = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="uncoveredLine">  Value *ExtOp1 = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="uncoveredLine">  Value *ExtRes = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="uncoveredLine">  Value *TruncRes = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="uncoveredLine">  if (isSigned(I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="uncoveredLine">    ExtOp0 = Builder.CreateSExt(I.getOperand(0), I32Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="uncoveredLine">    ExtOp1 = Builder.CreateSExt(I.getOperand(1), I32Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="uncoveredLine">    ExtOp0 = Builder.CreateZExt(I.getOperand(0), I32Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="uncoveredLine">    ExtOp1 = Builder.CreateZExt(I.getOperand(1), I32Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="uncoveredLine">  ExtRes = Builder.CreateBinOp(I.getOpcode(), ExtOp0, ExtOp1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="uncoveredLine">  if (Instruction *Inst = dyn_cast<Instruction>(ExtRes)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="uncoveredLine">    if (promotedOpIsNSW(cast<Instruction>(I)))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="uncoveredLine">      Inst->setHasNoSignedWrap();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="uncoveredLine">    if (promotedOpIsNUW(cast<Instruction>(I)))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="uncoveredLine">      Inst->setHasNoUnsignedWrap();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="uncoveredLine">    if (const auto *ExactOp = dyn_cast<PossiblyExactOperator>(&I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="uncoveredLine">      Inst->setIsExact(ExactOp->isExact());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="uncoveredLine">  TruncRes = Builder.CreateTrunc(ExtRes, I.getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="uncoveredLine">  I.replaceAllUsesWith(TruncRes);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="uncoveredLine">  I.eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="uncoveredLine">bool AMDGPUCodeGenPrepareImpl::promoteUniformOpToI32(ICmpInst &I) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="uncoveredLine">  assert(needsPromotionToI32(I.getOperand(0)->getType()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="">         "I does not need promotion to i32");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="uncoveredLine">  IRBuilder<> Builder(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="uncoveredLine">  Builder.SetCurrentDebugLocation(I.getDebugLoc());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="uncoveredLine">  Type *I32Ty = getI32Ty(Builder, I.getOperand(0)->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="uncoveredLine">  Value *ExtOp0 = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="uncoveredLine">  Value *ExtOp1 = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="uncoveredLine">  Value *NewICmp  = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="uncoveredLine">  if (I.isSigned()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="uncoveredLine">    ExtOp0 = Builder.CreateSExt(I.getOperand(0), I32Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="uncoveredLine">    ExtOp1 = Builder.CreateSExt(I.getOperand(1), I32Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="uncoveredLine">    ExtOp0 = Builder.CreateZExt(I.getOperand(0), I32Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="uncoveredLine">    ExtOp1 = Builder.CreateZExt(I.getOperand(1), I32Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="uncoveredLine">  NewICmp = Builder.CreateICmp(I.getPredicate(), ExtOp0, ExtOp1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="uncoveredLine">  I.replaceAllUsesWith(NewICmp);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="uncoveredLine">  I.eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="uncoveredLine">bool AMDGPUCodeGenPrepareImpl::promoteUniformOpToI32(SelectInst &I) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="uncoveredLine">  assert(needsPromotionToI32(I.getType()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="">         "I does not need promotion to i32");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="uncoveredLine">  IRBuilder<> Builder(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="uncoveredLine">  Builder.SetCurrentDebugLocation(I.getDebugLoc());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="uncoveredLine">  Type *I32Ty = getI32Ty(Builder, I.getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="uncoveredLine">  Value *ExtOp1 = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="uncoveredLine">  Value *ExtOp2 = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="uncoveredLine">  Value *ExtRes = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="uncoveredLine">  Value *TruncRes = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="uncoveredLine">  if (isSigned(I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="uncoveredLine">    ExtOp1 = Builder.CreateSExt(I.getOperand(1), I32Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="uncoveredLine">    ExtOp2 = Builder.CreateSExt(I.getOperand(2), I32Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="uncoveredLine">    ExtOp1 = Builder.CreateZExt(I.getOperand(1), I32Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="uncoveredLine">    ExtOp2 = Builder.CreateZExt(I.getOperand(2), I32Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="uncoveredLine">  ExtRes = Builder.CreateSelect(I.getOperand(0), ExtOp1, ExtOp2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="uncoveredLine">  TruncRes = Builder.CreateTrunc(ExtRes, I.getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="uncoveredLine">  I.replaceAllUsesWith(TruncRes);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="uncoveredLine">  I.eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="uncoveredLine">bool AMDGPUCodeGenPrepareImpl::promoteUniformBitreverseToI32(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="">    IntrinsicInst &I) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="uncoveredLine">  assert(I.getIntrinsicID() == Intrinsic::bitreverse &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="">         "I must be bitreverse intrinsic");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="uncoveredLine">  assert(needsPromotionToI32(I.getType()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="">         "I does not need promotion to i32");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="uncoveredLine">  IRBuilder<> Builder(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="uncoveredLine">  Builder.SetCurrentDebugLocation(I.getDebugLoc());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="uncoveredLine">  Type *I32Ty = getI32Ty(Builder, I.getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="">  Function *I32 =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="uncoveredLine">      Intrinsic::getDeclaration(Mod, Intrinsic::bitreverse, { I32Ty });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="uncoveredLine">  Value *ExtOp = Builder.CreateZExt(I.getOperand(0), I32Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="uncoveredLine">  Value *ExtRes = Builder.CreateCall(I32, { ExtOp });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="">  Value *LShrOp =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="uncoveredLine">      Builder.CreateLShr(ExtRes, 32 - getBaseElementBitWidth(I.getType()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="">  Value *TruncRes =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="uncoveredLine">      Builder.CreateTrunc(LShrOp, I.getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="uncoveredLine">  I.replaceAllUsesWith(TruncRes);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="uncoveredLine">  I.eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="uncoveredLine">unsigned AMDGPUCodeGenPrepareImpl::numBitsUnsigned(Value *Op) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="uncoveredLine">  return computeKnownBits(Op, *DL, 0, AC).countMaxActiveBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="uncoveredLine">unsigned AMDGPUCodeGenPrepareImpl::numBitsSigned(Value *Op) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="uncoveredLine">  return ComputeMaxSignificantBits(Op, *DL, 0, AC);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="uncoveredLine">static void extractValues(IRBuilder<> &Builder,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="">                          SmallVectorImpl<Value *> &Values, Value *V) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="uncoveredLine">  auto *VT = dyn_cast<FixedVectorType>(V->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="uncoveredLine">  if (!VT) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="uncoveredLine">    Values.push_back(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="uncoveredLine">  for (int I = 0, E = VT->getNumElements(); I != E; ++I)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="uncoveredLine">    Values.push_back(Builder.CreateExtractElement(V, I));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="uncoveredLine">static Value *insertValues(IRBuilder<> &Builder,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="">                           Type *Ty,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="">                           SmallVectorImpl<Value *> &Values) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="uncoveredLine">  if (!Ty->isVectorTy()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="uncoveredLine">    assert(Values.size() == 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="uncoveredLine">    return Values[0];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="uncoveredLine">  Value *NewVal = PoisonValue::get(Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="uncoveredLine">  for (int I = 0, E = Values.size(); I != E; ++I)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="uncoveredLine">    NewVal = Builder.CreateInsertElement(NewVal, Values[I], I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="uncoveredLine">  return NewVal;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="">// Returns 24-bit or 48-bit (as per `NumBits` and `Size`) mul of `LHS` and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="">// `RHS`. `NumBits` is the number of KnownBits of the result and `Size` is the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="">// width of the original destination.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="uncoveredLine">static Value *getMul24(IRBuilder<> &Builder, Value *LHS, Value *RHS,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="">                       unsigned Size, unsigned NumBits, bool IsSigned) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="uncoveredLine">  if (Size <= 32 || NumBits <= 32) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="uncoveredLine">    Intrinsic::ID ID =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="uncoveredLine">        IsSigned ? Intrinsic::amdgcn_mul_i24 : Intrinsic::amdgcn_mul_u24;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="uncoveredLine">    return Builder.CreateIntrinsic(ID, {}, {LHS, RHS});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="uncoveredLine">  assert(NumBits <= 48);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="uncoveredLine">  Intrinsic::ID LoID =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="uncoveredLine">      IsSigned ? Intrinsic::amdgcn_mul_i24 : Intrinsic::amdgcn_mul_u24;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="uncoveredLine">  Intrinsic::ID HiID =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="uncoveredLine">      IsSigned ? Intrinsic::amdgcn_mulhi_i24 : Intrinsic::amdgcn_mulhi_u24;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="uncoveredLine">  Value *Lo = Builder.CreateIntrinsic(LoID, {}, {LHS, RHS});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="uncoveredLine">  Value *Hi = Builder.CreateIntrinsic(HiID, {}, {LHS, RHS});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="uncoveredLine">  IntegerType *I64Ty = Builder.getInt64Ty();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="uncoveredLine">  Lo = Builder.CreateZExtOrTrunc(Lo, I64Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="uncoveredLine">  Hi = Builder.CreateZExtOrTrunc(Hi, I64Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="uncoveredLine">  return Builder.CreateOr(Lo, Builder.CreateShl(Hi, 32));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="uncoveredLine">bool AMDGPUCodeGenPrepareImpl::replaceMulWithMul24(BinaryOperator &I) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="uncoveredLine">  if (I.getOpcode() != Instruction::Mul)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="uncoveredLine">  Type *Ty = I.getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="uncoveredLine">  unsigned Size = Ty->getScalarSizeInBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="uncoveredLine">  if (Size <= 16 && ST->has16BitInsts())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="">  // Prefer scalar if this could be s_mul_i32</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="uncoveredLine">  if (UA->isUniform(&I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="uncoveredLine">  Value *LHS = I.getOperand(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="uncoveredLine">  Value *RHS = I.getOperand(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="uncoveredLine">  IRBuilder<> Builder(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="uncoveredLine">  Builder.SetCurrentDebugLocation(I.getDebugLoc());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="uncoveredLine">  unsigned LHSBits = 0, RHSBits = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="uncoveredLine">  bool IsSigned = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="uncoveredLine">  if (ST->hasMulU24() && (LHSBits = numBitsUnsigned(LHS)) <= 24 &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="uncoveredLine">      (RHSBits = numBitsUnsigned(RHS)) <= 24) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="uncoveredLine">    IsSigned = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="uncoveredLine">  } else if (ST->hasMulI24() && (LHSBits = numBitsSigned(LHS)) <= 24 &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="uncoveredLine">             (RHSBits = numBitsSigned(RHS)) <= 24) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="uncoveredLine">    IsSigned = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="">  } else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="uncoveredLine">  SmallVector<Value *, 4> LHSVals;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="uncoveredLine">  SmallVector<Value *, 4> RHSVals;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="uncoveredLine">  SmallVector<Value *, 4> ResultVals;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="uncoveredLine">  extractValues(Builder, LHSVals, LHS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="uncoveredLine">  extractValues(Builder, RHSVals, RHS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="uncoveredLine">  IntegerType *I32Ty = Builder.getInt32Ty();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="uncoveredLine">  for (int I = 0, E = LHSVals.size(); I != E; ++I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="">    Value *LHS, *RHS;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="uncoveredLine">    if (IsSigned) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="uncoveredLine">      LHS = Builder.CreateSExtOrTrunc(LHSVals[I], I32Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="uncoveredLine">      RHS = Builder.CreateSExtOrTrunc(RHSVals[I], I32Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="uncoveredLine">      LHS = Builder.CreateZExtOrTrunc(LHSVals[I], I32Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="uncoveredLine">      RHS = Builder.CreateZExtOrTrunc(RHSVals[I], I32Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="">    Value *Result =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="uncoveredLine">        getMul24(Builder, LHS, RHS, Size, LHSBits + RHSBits, IsSigned);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="uncoveredLine">    if (IsSigned) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="uncoveredLine">      ResultVals.push_back(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="uncoveredLine">          Builder.CreateSExtOrTrunc(Result, LHSVals[I]->getType()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="uncoveredLine">      ResultVals.push_back(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="uncoveredLine">          Builder.CreateZExtOrTrunc(Result, LHSVals[I]->getType()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="uncoveredLine">  Value *NewVal = insertValues(Builder, Ty, ResultVals);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="uncoveredLine">  NewVal->takeName(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="uncoveredLine">  I.replaceAllUsesWith(NewVal);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="uncoveredLine">  I.eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="">// Find a select instruction, which may have been casted. This is mostly to deal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="">// with cases where i16 selects were promoted here to i32.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="uncoveredLine">static SelectInst *findSelectThroughCast(Value *V, CastInst *&Cast) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="uncoveredLine">  Cast = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="uncoveredLine">  if (SelectInst *Sel = dyn_cast<SelectInst>(V))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="uncoveredLine">    return Sel;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="uncoveredLine">  if ((Cast = dyn_cast<CastInst>(V))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="uncoveredLine">    if (SelectInst *Sel = dyn_cast<SelectInst>(Cast->getOperand(0)))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="uncoveredLine">      return Sel;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="uncoveredLine">  return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="uncoveredLine">bool AMDGPUCodeGenPrepareImpl::foldBinOpIntoSelect(BinaryOperator &BO) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="">  // Don't do this unless the old select is going away. We want to eliminate the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="">  // binary operator, not replace a binop with a select.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="uncoveredLine">  int SelOpNo = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="">  CastInst *CastOp;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="">  // TODO: Should probably try to handle some cases with multiple</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="">  // users. Duplicating the select may be profitable for division.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="uncoveredLine">  SelectInst *Sel = findSelectThroughCast(BO.getOperand(0), CastOp);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="uncoveredLine">  if (!Sel || !Sel->hasOneUse()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="uncoveredLine">    SelOpNo = 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="uncoveredLine">    Sel = findSelectThroughCast(BO.getOperand(1), CastOp);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="uncoveredLine">  if (!Sel || !Sel->hasOneUse())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="uncoveredLine">  Constant *CT = dyn_cast<Constant>(Sel->getTrueValue());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="uncoveredLine">  Constant *CF = dyn_cast<Constant>(Sel->getFalseValue());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="uncoveredLine">  Constant *CBO = dyn_cast<Constant>(BO.getOperand(SelOpNo ^ 1));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="uncoveredLine">  if (!CBO || !CT || !CF)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="uncoveredLine">  if (CastOp) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="uncoveredLine">    if (!CastOp->hasOneUse())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="uncoveredLine">    CT = ConstantFoldCastOperand(CastOp->getOpcode(), CT, BO.getType(), *DL);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="uncoveredLine">    CF = ConstantFoldCastOperand(CastOp->getOpcode(), CF, BO.getType(), *DL);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="">  // TODO: Handle special 0/-1 cases DAG combine does, although we only really</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="">  // need to handle divisions here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="uncoveredLine">  Constant *FoldedT = SelOpNo ?</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="uncoveredLine">    ConstantFoldBinaryOpOperands(BO.getOpcode(), CBO, CT, *DL) :</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="uncoveredLine">    ConstantFoldBinaryOpOperands(BO.getOpcode(), CT, CBO, *DL);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="uncoveredLine">  if (!FoldedT || isa<ConstantExpr>(FoldedT))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="uncoveredLine">  Constant *FoldedF = SelOpNo ?</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="uncoveredLine">    ConstantFoldBinaryOpOperands(BO.getOpcode(), CBO, CF, *DL) :</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="uncoveredLine">    ConstantFoldBinaryOpOperands(BO.getOpcode(), CF, CBO, *DL);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="uncoveredLine">  if (!FoldedF || isa<ConstantExpr>(FoldedF))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="uncoveredLine">  IRBuilder<> Builder(&BO);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="uncoveredLine">  Builder.SetCurrentDebugLocation(BO.getDebugLoc());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="uncoveredLine">  if (const FPMathOperator *FPOp = dyn_cast<const FPMathOperator>(&BO))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="uncoveredLine">    Builder.setFastMathFlags(FPOp->getFastMathFlags());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="uncoveredLine">  Value *NewSelect = Builder.CreateSelect(Sel->getCondition(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="">                                          FoldedT, FoldedF);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="uncoveredLine">  NewSelect->takeName(&BO);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="uncoveredLine">  BO.replaceAllUsesWith(NewSelect);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="uncoveredLine">  BO.eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="uncoveredLine">  if (CastOp)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="uncoveredLine">    CastOp->eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="uncoveredLine">  Sel->eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="">std::pair<Value *, Value *></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="uncoveredLine">AMDGPUCodeGenPrepareImpl::getFrexpResults(IRBuilder<> &Builder,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="">                                          Value *Src) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="uncoveredLine">  Type *Ty = Src->getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="uncoveredLine">  Value *Frexp = Builder.CreateIntrinsic(Intrinsic::frexp,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="uncoveredLine">                                         {Ty, Builder.getInt32Ty()}, Src);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="uncoveredLine">  Value *FrexpMant = Builder.CreateExtractValue(Frexp, {0});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="">  // Bypass the bug workaround for the exponent result since it doesn't matter.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="">  // TODO: Does the bug workaround even really need to consider the exponent</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="">  // result? It's unspecified by the spec.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="">  Value *FrexpExp =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="uncoveredLine">      ST->hasFractBug()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="uncoveredLine">          ? Builder.CreateIntrinsic(Intrinsic::amdgcn_frexp_exp,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="uncoveredLine">                                    {Builder.getInt32Ty(), Ty}, Src)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="uncoveredLine">          : Builder.CreateExtractValue(Frexp, {1});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="uncoveredLine">  return {FrexpMant, FrexpExp};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="">/// Emit an expansion of 1.0 / Src good for 1ulp that supports denormals.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="uncoveredLine">Value *AMDGPUCodeGenPrepareImpl::emitRcpIEEE1ULP(IRBuilder<> &Builder,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="">                                                 Value *Src,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="">                                                 bool IsNegative) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="">  // Same as for 1.0, but expand the sign out of the constant.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="">  // -1.0 / x -> rcp (fneg x)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="uncoveredLine">  if (IsNegative)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="uncoveredLine">    Src = Builder.CreateFNeg(Src);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="">  // The rcp instruction doesn't support denormals, so scale the input</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="">  // out of the denormal range and convert at the end.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="">  // Expand as 2^-n * (1.0 / (x * 2^n))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="">  // TODO: Skip scaling if input is known never denormal and the input</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="">  // range won't underflow to denormal. The hard part is knowing the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="">  // result. We need a range check, the result could be denormal for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="">  // 0x1p+126 < den <= 0x1p+127.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="uncoveredLine">  Type *Ty = Src->getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="uncoveredLine">  auto [FrexpMant, FrexpExp] = getFrexpResults(Builder, Src);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="uncoveredLine">  Value *ScaleFactor = Builder.CreateNeg(FrexpExp);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="uncoveredLine">  Value *Rcp = Builder.CreateUnaryIntrinsic(Intrinsic::amdgcn_rcp, FrexpMant);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="uncoveredLine">  return Builder.CreateIntrinsic(Intrinsic::ldexp, {Ty, Builder.getInt32Ty()},</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="uncoveredLine">                                 {Rcp, ScaleFactor});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="">/// Emit a 2ulp expansion for fdiv by using frexp for input scaling.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="uncoveredLine">Value *AMDGPUCodeGenPrepareImpl::emitFrexpDiv(IRBuilder<> &Builder, Value *LHS,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="">                                              Value *RHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="">                                              FastMathFlags FMF) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="">  // If we have have to work around the fract/frexp bug, we're worse off than</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="">  // using the fdiv.fast expansion. The full safe expansion is faster if we have</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="">  // fast FMA.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="uncoveredLine">  if (HasFP32DenormalFlush && ST->hasFractBug() && !ST->hasFastFMAF32() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="uncoveredLine">      (!FMF.noNaNs() || !FMF.noInfs()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="">  // We're scaling the LHS to avoid a denormal input, and scale the denominator</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="">  // to avoid large values underflowing the result.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="uncoveredLine">  Type *Ty = LHS->getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="uncoveredLine">  auto [FrexpMantRHS, FrexpExpRHS] = getFrexpResults(Builder, RHS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="">  Value *Rcp =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="uncoveredLine">      Builder.CreateUnaryIntrinsic(Intrinsic::amdgcn_rcp, FrexpMantRHS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="uncoveredLine">  auto [FrexpMantLHS, FrexpExpLHS] = getFrexpResults(Builder, LHS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="uncoveredLine">  Value *Mul = Builder.CreateFMul(FrexpMantLHS, Rcp);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="">  // We multiplied by 2^N/2^M, so we need to multiply by 2^(N-M) to scale the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="">  // result.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="uncoveredLine">  Value *ExpDiff = Builder.CreateSub(FrexpExpLHS, FrexpExpRHS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="uncoveredLine">  return Builder.CreateIntrinsic(Intrinsic::ldexp, {Ty, Builder.getInt32Ty()},</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="uncoveredLine">                                 {Mul, ExpDiff});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="">/// Emit an expansion of 1.0 / sqrt(Src) good for 1ulp that supports denormals.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="uncoveredLine">static Value *emitRsqIEEE1ULP(IRBuilder<> &Builder, Value *Src,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="">                              bool IsNegative) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="">  // bool need_scale = x < 0x1p-126f;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="">  // float input_scale = need_scale ? 0x1.0p+24f : 1.0f;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="">  // float output_scale = need_scale ? 0x1.0p+12f : 1.0f;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="">  // rsq(x * input_scale) * output_scale;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="uncoveredLine">  Type *Ty = Src->getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="">  APFloat SmallestNormal =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="uncoveredLine">      APFloat::getSmallestNormalized(Ty->getFltSemantics());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="">  Value *NeedScale =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="uncoveredLine">      Builder.CreateFCmpOLT(Src, ConstantFP::get(Ty, SmallestNormal));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="uncoveredLine">  Constant *One = ConstantFP::get(Ty, 1.0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="uncoveredLine">  Constant *InputScale = ConstantFP::get(Ty, 0x1.0p+24);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="">  Constant *OutputScale =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="uncoveredLine">      ConstantFP::get(Ty, IsNegative ? -0x1.0p+12 : 0x1.0p+12);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="uncoveredLine">  Value *InputScaleFactor = Builder.CreateSelect(NeedScale, InputScale, One);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="uncoveredLine">  Value *ScaledInput = Builder.CreateFMul(Src, InputScaleFactor);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="uncoveredLine">  Value *Rsq = Builder.CreateUnaryIntrinsic(Intrinsic::amdgcn_rsq, ScaledInput);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="uncoveredLine">  Value *OutputScaleFactor = Builder.CreateSelect(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="uncoveredLine">      NeedScale, OutputScale, IsNegative ? ConstantFP::get(Ty, -1.0) : One);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="uncoveredLine">  return Builder.CreateFMul(Rsq, OutputScaleFactor);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="uncoveredLine">bool AMDGPUCodeGenPrepareImpl::canOptimizeWithRsq(const FPMathOperator *SqrtOp,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="">                                                  FastMathFlags DivFMF,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="">                                                  FastMathFlags SqrtFMF) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="">  // The rsqrt contraction increases accuracy from ~2ulp to ~1ulp.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="uncoveredLine">  if (!DivFMF.allowContract() || !SqrtFMF.allowContract())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="">  // v_rsq_f32 gives 1ulp</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="uncoveredLine">  return SqrtFMF.approxFunc() || HasUnsafeFPMath ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="uncoveredLine">         SqrtOp->getFPAccuracy() >= 1.0f;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="uncoveredLine">Value *AMDGPUCodeGenPrepareImpl::optimizeWithRsq(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="">    IRBuilder<> &Builder, Value *Num, Value *Den, FastMathFlags DivFMF,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="">    FastMathFlags SqrtFMF, const Instruction *CtxI) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="">  // The rsqrt contraction increases accuracy from ~2ulp to ~1ulp.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="uncoveredLine">  assert(DivFMF.allowContract() && SqrtFMF.allowContract());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="">  // rsq_f16 is accurate to 0.51 ulp.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="">  // rsq_f32 is accurate for !fpmath >= 1.0ulp and denormals are flushed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="">  // rsq_f64 is never accurate.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="uncoveredLine">  const ConstantFP *CLHS = dyn_cast<ConstantFP>(Num);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="uncoveredLine">  if (!CLHS)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="uncoveredLine">  assert(Den->getType()->isFloatTy());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="uncoveredLine">  bool IsNegative = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="">  // TODO: Handle other numerator values with arcp.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="uncoveredLine">  if (CLHS->isExactlyValue(1.0) || (IsNegative = CLHS->isExactlyValue(-1.0))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="">    // Add in the sqrt flags.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="uncoveredLine">    IRBuilder<>::FastMathFlagGuard Guard(Builder);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="uncoveredLine">    DivFMF |= SqrtFMF;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="uncoveredLine">    Builder.setFastMathFlags(DivFMF);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="uncoveredLine">    if ((DivFMF.approxFunc() && SqrtFMF.approxFunc()) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="uncoveredLine">        canIgnoreDenormalInput(Den, CtxI)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="uncoveredLine">      Value *Result = Builder.CreateUnaryIntrinsic(Intrinsic::amdgcn_rsq, Den);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="">      // -1.0 / sqrt(x) -> fneg(rsq(x))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="uncoveredLine">      return IsNegative ? Builder.CreateFNeg(Result) : Result;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="uncoveredLine">    return emitRsqIEEE1ULP(Builder, Den, IsNegative);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="uncoveredLine">  return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="">// Optimize fdiv with rcp:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="">// 1/x -> rcp(x) when rcp is sufficiently accurate or inaccurate rcp is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="">//               allowed with unsafe-fp-math or afn.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="">// a/b -> a*rcp(b) when arcp is allowed, and we only need provide ULP 1.0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="">Value *</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="uncoveredLine">AMDGPUCodeGenPrepareImpl::optimizeWithRcp(IRBuilder<> &Builder, Value *Num,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="">                                          Value *Den, FastMathFlags FMF,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="">                                          const Instruction *CtxI) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="">  // rcp_f16 is accurate to 0.51 ulp.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="">  // rcp_f32 is accurate for !fpmath >= 1.0ulp and denormals are flushed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="">  // rcp_f64 is never accurate.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="uncoveredLine">  assert(Den->getType()->isFloatTy());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="uncoveredLine">  if (const ConstantFP *CLHS = dyn_cast<ConstantFP>(Num)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="uncoveredLine">    bool IsNegative = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="uncoveredLine">    if (CLHS->isExactlyValue(1.0) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="uncoveredLine">        (IsNegative = CLHS->isExactlyValue(-1.0))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="uncoveredLine">      Value *Src = Den;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="uncoveredLine">      if (HasFP32DenormalFlush || FMF.approxFunc()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="">        // -1.0 / x -> 1.0 / fneg(x)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="uncoveredLine">        if (IsNegative)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="uncoveredLine">          Src = Builder.CreateFNeg(Src);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="">        // v_rcp_f32 and v_rsq_f32 do not support denormals, and according to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="">        // the CI documentation has a worst case error of 1 ulp.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="">        // OpenCL requires <= 2.5 ulp for 1.0 / x, so it should always be OK</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="">        // to use it as long as we aren't trying to use denormals.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="">        //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="">        // v_rcp_f16 and v_rsq_f16 DO support denormals.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="">        // NOTE: v_sqrt and v_rcp will be combined to v_rsq later. So we don't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="">        //       insert rsq intrinsic here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="">        // 1.0 / x -> rcp(x)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="uncoveredLine">        return Builder.CreateUnaryIntrinsic(Intrinsic::amdgcn_rcp, Src);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="">      // TODO: If the input isn't denormal, and we know the input exponent isn't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="">      // big enough to introduce a denormal we can avoid the scaling.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="uncoveredLine">      return emitRcpIEEE1ULP(Builder, Src, IsNegative);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="uncoveredLine">  if (FMF.allowReciprocal()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="">    // x / y -> x * (1.0 / y)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="">    // TODO: Could avoid denormal scaling and use raw rcp if we knew the output</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="">    // will never underflow.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="uncoveredLine">    if (HasFP32DenormalFlush || FMF.approxFunc()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="uncoveredLine">      Value *Recip = Builder.CreateUnaryIntrinsic(Intrinsic::amdgcn_rcp, Den);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="uncoveredLine">      return Builder.CreateFMul(Num, Recip);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="uncoveredLine">    Value *Recip = emitRcpIEEE1ULP(Builder, Den, false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="uncoveredLine">    return Builder.CreateFMul(Num, Recip);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="uncoveredLine">  return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="">// optimize with fdiv.fast:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="">// a/b -> fdiv.fast(a, b) when !fpmath >= 2.5ulp with denormals flushed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="">// 1/x -> fdiv.fast(1,x)  when !fpmath >= 2.5ulp.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="">// NOTE: optimizeWithRcp should be tried first because rcp is the preference.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="uncoveredLine">Value *AMDGPUCodeGenPrepareImpl::optimizeWithFDivFast(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="">    IRBuilder<> &Builder, Value *Num, Value *Den, float ReqdAccuracy) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="">  // fdiv.fast can achieve 2.5 ULP accuracy.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="uncoveredLine">  if (ReqdAccuracy < 2.5f)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="">  // Only have fdiv.fast for f32.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="uncoveredLine">  assert(Den->getType()->isFloatTy());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="uncoveredLine">  bool NumIsOne = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="uncoveredLine">  if (const ConstantFP *CNum = dyn_cast<ConstantFP>(Num)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="uncoveredLine">    if (CNum->isExactlyValue(+1.0) || CNum->isExactlyValue(-1.0))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="uncoveredLine">      NumIsOne = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="">  // fdiv does not support denormals. But 1.0/x is always fine to use it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="">  // TODO: This works for any value with a specific known exponent range, don't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="">  // just limit to constant 1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="uncoveredLine">  if (!HasFP32DenormalFlush && !NumIsOne)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="uncoveredLine">  return Builder.CreateIntrinsic(Intrinsic::amdgcn_fdiv_fast, {}, {Num, Den});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="uncoveredLine">Value *AMDGPUCodeGenPrepareImpl::visitFDivElement(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="">    IRBuilder<> &Builder, Value *Num, Value *Den, FastMathFlags DivFMF,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="">    FastMathFlags SqrtFMF, Value *RsqOp, const Instruction *FDivInst,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="">    float ReqdDivAccuracy) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="uncoveredLine">  if (RsqOp) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="">    Value *Rsq =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="uncoveredLine">        optimizeWithRsq(Builder, Num, RsqOp, DivFMF, SqrtFMF, FDivInst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="uncoveredLine">    if (Rsq)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="uncoveredLine">      return Rsq;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="uncoveredLine">  Value *Rcp = optimizeWithRcp(Builder, Num, Den, DivFMF, FDivInst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="uncoveredLine">  if (Rcp)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="uncoveredLine">    return Rcp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="">  // In the basic case fdiv_fast has the same instruction count as the frexp div</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="">  // expansion. Slightly prefer fdiv_fast since it ends in an fmul that can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="">  // potentially be fused into a user. Also, materialization of the constants</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="">  // can be reused for multiple instances.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="uncoveredLine">  Value *FDivFast = optimizeWithFDivFast(Builder, Num, Den, ReqdDivAccuracy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="uncoveredLine">  if (FDivFast)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="uncoveredLine">    return FDivFast;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="uncoveredLine">  return emitFrexpDiv(Builder, Num, Den, DivFMF);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="">// Optimizations is performed based on fpmath, fast math flags as well as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="">// denormals to optimize fdiv with either rcp or fdiv.fast.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="">// With rcp:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="">//   1/x -> rcp(x) when rcp is sufficiently accurate or inaccurate rcp is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="">//                 allowed with unsafe-fp-math or afn.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="">//   a/b -> a*rcp(b) when inaccurate rcp is allowed with unsafe-fp-math or afn.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="">// With fdiv.fast:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="">//   a/b -> fdiv.fast(a, b) when !fpmath >= 2.5ulp with denormals flushed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="">//   1/x -> fdiv.fast(1,x)  when !fpmath >= 2.5ulp.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="">// NOTE: rcp is the preference in cases that both are legal.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="uncoveredLine">bool AMDGPUCodeGenPrepareImpl::visitFDiv(BinaryOperator &FDiv) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="uncoveredLine">  if (DisableFDivExpand)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="uncoveredLine">  Type *Ty = FDiv.getType()->getScalarType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="uncoveredLine">  if (!Ty->isFloatTy())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="">  // The f64 rcp/rsq approximations are pretty inaccurate. We can do an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="">  // expansion around them in codegen. f16 is good enough to always use.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="uncoveredLine">  const FPMathOperator *FPOp = cast<const FPMathOperator>(&FDiv);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="uncoveredLine">  const FastMathFlags DivFMF = FPOp->getFastMathFlags();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="uncoveredLine">  const float ReqdAccuracy = FPOp->getFPAccuracy();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="">  // Inaccurate rcp is allowed with unsafe-fp-math or afn.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="">  // Defer to codegen to handle this.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="">  // TODO: Decide on an interpretation for interactions between afn + arcp +</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="">  // !fpmath, and make it consistent between here and codegen. For now, defer</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="">  // expansion of afn to codegen. The current interpretation is so aggressive we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="">  // don't need any pre-consideration here when we have better information. A</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="">  // more conservative interpretation could use handling here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="uncoveredLine">  const bool AllowInaccurateRcp = HasUnsafeFPMath || DivFMF.approxFunc();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="uncoveredLine">  if (AllowInaccurateRcp)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="">  // Defer the correct implementations to codegen.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="uncoveredLine">  if (ReqdAccuracy < 1.0f)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="uncoveredLine">  FastMathFlags SqrtFMF;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="uncoveredLine">  Value *Num = FDiv.getOperand(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="uncoveredLine">  Value *Den = FDiv.getOperand(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="uncoveredLine">  Value *RsqOp = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="uncoveredLine">  auto *DenII = dyn_cast<IntrinsicInst>(Den);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="uncoveredLine">  if (DenII && DenII->getIntrinsicID() == Intrinsic::sqrt &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="uncoveredLine">      DenII->hasOneUse()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="uncoveredLine">    const auto *SqrtOp = cast<FPMathOperator>(DenII);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="uncoveredLine">    SqrtFMF = SqrtOp->getFastMathFlags();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="uncoveredLine">    if (canOptimizeWithRsq(SqrtOp, DivFMF, SqrtFMF))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="uncoveredLine">      RsqOp = SqrtOp->getOperand(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="uncoveredLine">  IRBuilder<> Builder(FDiv.getParent(), std::next(FDiv.getIterator()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="uncoveredLine">  Builder.setFastMathFlags(DivFMF);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="uncoveredLine">  Builder.SetCurrentDebugLocation(FDiv.getDebugLoc());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="uncoveredLine">  SmallVector<Value *, 4> NumVals;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="uncoveredLine">  SmallVector<Value *, 4> DenVals;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="uncoveredLine">  SmallVector<Value *, 4> RsqDenVals;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="uncoveredLine">  extractValues(Builder, NumVals, Num);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="uncoveredLine">  extractValues(Builder, DenVals, Den);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="uncoveredLine">  if (RsqOp)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="uncoveredLine">    extractValues(Builder, RsqDenVals, RsqOp);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="uncoveredLine">  SmallVector<Value *, 4> ResultVals(NumVals.size());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="uncoveredLine">  for (int I = 0, E = NumVals.size(); I != E; ++I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="uncoveredLine">    Value *NumElt = NumVals[I];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="uncoveredLine">    Value *DenElt = DenVals[I];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="uncoveredLine">    Value *RsqDenElt = RsqOp ? RsqDenVals[I] : nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="">    Value *NewElt =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="uncoveredLine">        visitFDivElement(Builder, NumElt, DenElt, DivFMF, SqrtFMF, RsqDenElt,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="">                         cast<Instruction>(FPOp), ReqdAccuracy);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="uncoveredLine">    if (!NewElt) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="">      // Keep the original, but scalarized.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="">      // This has the unfortunate side effect of sometimes scalarizing when</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="">      // we're not going to do anything.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="uncoveredLine">      NewElt = Builder.CreateFDiv(NumElt, DenElt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="uncoveredLine">      if (auto *NewEltInst = dyn_cast<Instruction>(NewElt))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="uncoveredLine">        NewEltInst->copyMetadata(FDiv);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="uncoveredLine">    ResultVals[I] = NewElt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="uncoveredLine">  Value *NewVal = insertValues(Builder, FDiv.getType(), ResultVals);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="uncoveredLine">  if (NewVal) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="uncoveredLine">    FDiv.replaceAllUsesWith(NewVal);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="uncoveredLine">    NewVal->takeName(&FDiv);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="uncoveredLine">    RecursivelyDeleteTriviallyDeadInstructions(&FDiv, TLInfo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="uncoveredLine">static bool hasUnsafeFPMath(const Function &F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="uncoveredLine">  Attribute Attr = F.getFnAttribute("unsafe-fp-math");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="uncoveredLine">  return Attr.getValueAsBool();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="uncoveredLine">static std::pair<Value*, Value*> getMul64(IRBuilder<> &Builder,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="">                                          Value *LHS, Value *RHS) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="uncoveredLine">  Type *I32Ty = Builder.getInt32Ty();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="uncoveredLine">  Type *I64Ty = Builder.getInt64Ty();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="uncoveredLine">  Value *LHS_EXT64 = Builder.CreateZExt(LHS, I64Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="uncoveredLine">  Value *RHS_EXT64 = Builder.CreateZExt(RHS, I64Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="uncoveredLine">  Value *MUL64 = Builder.CreateMul(LHS_EXT64, RHS_EXT64);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="uncoveredLine">  Value *Lo = Builder.CreateTrunc(MUL64, I32Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="uncoveredLine">  Value *Hi = Builder.CreateLShr(MUL64, Builder.getInt64(32));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="uncoveredLine">  Hi = Builder.CreateTrunc(Hi, I32Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="uncoveredLine">  return std::pair(Lo, Hi);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="uncoveredLine">static Value* getMulHu(IRBuilder<> &Builder, Value *LHS, Value *RHS) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="uncoveredLine">  return getMul64(Builder, LHS, RHS).second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="">/// Figure out how many bits are really needed for this division. \p AtLeast is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="">/// an optimization hint to bypass the second ComputeNumSignBits call if we the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="">/// first one is insufficient. Returns -1 on failure.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="uncoveredLine">int AMDGPUCodeGenPrepareImpl::getDivNumBits(BinaryOperator &I, Value *Num,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="">                                            Value *Den, unsigned AtLeast,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="">                                            bool IsSigned) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="uncoveredLine">  const DataLayout &DL = Mod->getDataLayout();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="uncoveredLine">  unsigned LHSSignBits = ComputeNumSignBits(Num, DL, 0, AC, &I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="uncoveredLine">  if (LHSSignBits < AtLeast)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="uncoveredLine">    return -1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="uncoveredLine">  unsigned RHSSignBits = ComputeNumSignBits(Den, DL, 0, AC, &I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="uncoveredLine">  if (RHSSignBits < AtLeast)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="uncoveredLine">    return -1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="uncoveredLine">  unsigned SignBits = std::min(LHSSignBits, RHSSignBits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="uncoveredLine">  unsigned DivBits = Num->getType()->getScalarSizeInBits() - SignBits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="uncoveredLine">  if (IsSigned)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="uncoveredLine">    ++DivBits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="uncoveredLine">  return DivBits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="">// The fractional part of a float is enough to accurately represent up to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="">// a 24-bit signed integer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="uncoveredLine">Value *AMDGPUCodeGenPrepareImpl::expandDivRem24(IRBuilder<> &Builder,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="">                                                BinaryOperator &I, Value *Num,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="">                                                Value *Den, bool IsDiv,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="">                                                bool IsSigned) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="uncoveredLine">  int DivBits = getDivNumBits(I, Num, Den, 9, IsSigned);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="uncoveredLine">  if (DivBits == -1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="uncoveredLine">  return expandDivRem24Impl(Builder, I, Num, Den, DivBits, IsDiv, IsSigned);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="uncoveredLine">Value *AMDGPUCodeGenPrepareImpl::expandDivRem24Impl(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="">    IRBuilder<> &Builder, BinaryOperator &I, Value *Num, Value *Den,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="">    unsigned DivBits, bool IsDiv, bool IsSigned) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="uncoveredLine">  Type *I32Ty = Builder.getInt32Ty();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="uncoveredLine">  Num = Builder.CreateTrunc(Num, I32Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="uncoveredLine">  Den = Builder.CreateTrunc(Den, I32Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="uncoveredLine">  Type *F32Ty = Builder.getFloatTy();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="uncoveredLine">  ConstantInt *One = Builder.getInt32(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="uncoveredLine">  Value *JQ = One;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="uncoveredLine">  if (IsSigned) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="">    // char|short jq = ia ^ ib;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="uncoveredLine">    JQ = Builder.CreateXor(Num, Den);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="">    // jq = jq >> (bitsize - 2)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="uncoveredLine">    JQ = Builder.CreateAShr(JQ, Builder.getInt32(30));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="">    // jq = jq | 0x1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="uncoveredLine">    JQ = Builder.CreateOr(JQ, One);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="">  // int ia = (int)LHS;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="uncoveredLine">  Value *IA = Num;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="">  // int ib, (int)RHS;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="uncoveredLine">  Value *IB = Den;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="">  // float fa = (float)ia;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="uncoveredLine">  Value *FA = IsSigned ? Builder.CreateSIToFP(IA, F32Ty)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="uncoveredLine">                       : Builder.CreateUIToFP(IA, F32Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="">  // float fb = (float)ib;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="uncoveredLine">  Value *FB = IsSigned ? Builder.CreateSIToFP(IB,F32Ty)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="uncoveredLine">                       : Builder.CreateUIToFP(IB,F32Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="uncoveredLine">  Function *RcpDecl = Intrinsic::getDeclaration(Mod, Intrinsic::amdgcn_rcp,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="uncoveredLine">                                                Builder.getFloatTy());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="uncoveredLine">  Value *RCP = Builder.CreateCall(RcpDecl, { FB });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="uncoveredLine">  Value *FQM = Builder.CreateFMul(FA, RCP);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="">  // fq = trunc(fqm);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="uncoveredLine">  CallInst *FQ = Builder.CreateUnaryIntrinsic(Intrinsic::trunc, FQM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="uncoveredLine">  FQ->copyFastMathFlags(Builder.getFastMathFlags());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="">  // float fqneg = -fq;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="uncoveredLine">  Value *FQNeg = Builder.CreateFNeg(FQ);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="">  // float fr = mad(fqneg, fb, fa);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="uncoveredLine">  auto FMAD = !ST->hasMadMacF32Insts()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="uncoveredLine">                  ? Intrinsic::fma</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="uncoveredLine">                  : (Intrinsic::ID)Intrinsic::amdgcn_fmad_ftz;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="uncoveredLine">  Value *FR = Builder.CreateIntrinsic(FMAD,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="uncoveredLine">                                      {FQNeg->getType()}, {FQNeg, FB, FA}, FQ);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="">  // int iq = (int)fq;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="uncoveredLine">  Value *IQ = IsSigned ? Builder.CreateFPToSI(FQ, I32Ty)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="uncoveredLine">                       : Builder.CreateFPToUI(FQ, I32Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="">  // fr = fabs(fr);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="uncoveredLine">  FR = Builder.CreateUnaryIntrinsic(Intrinsic::fabs, FR, FQ);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="">  // fb = fabs(fb);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="uncoveredLine">  FB = Builder.CreateUnaryIntrinsic(Intrinsic::fabs, FB, FQ);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="">  // int cv = fr >= fb;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="uncoveredLine">  Value *CV = Builder.CreateFCmpOGE(FR, FB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="">  // jq = (cv ? jq : 0);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="uncoveredLine">  JQ = Builder.CreateSelect(CV, JQ, Builder.getInt32(0));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="">  // dst = iq + jq;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="uncoveredLine">  Value *Div = Builder.CreateAdd(IQ, JQ);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="uncoveredLine">  Value *Res = Div;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="uncoveredLine">  if (!IsDiv) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="">    // Rem needs compensation, it's easier to recompute it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="uncoveredLine">    Value *Rem = Builder.CreateMul(Div, Den);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="uncoveredLine">    Res = Builder.CreateSub(Num, Rem);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="uncoveredLine">  if (DivBits != 0 && DivBits < 32) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="">    // Extend in register from the number of bits this divide really is.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="uncoveredLine">    if (IsSigned) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="uncoveredLine">      int InRegBits = 32 - DivBits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="uncoveredLine">      Res = Builder.CreateShl(Res, InRegBits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="uncoveredLine">      Res = Builder.CreateAShr(Res, InRegBits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="">      ConstantInt *TruncMask</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="uncoveredLine">        = Builder.getInt32((UINT64_C(1) << DivBits) - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="uncoveredLine">      Res = Builder.CreateAnd(Res, TruncMask);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="uncoveredLine">  return Res;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="">// Try to recognize special cases the DAG will emit special, better expansions</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="">// than the general expansion we do here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="">// TODO: It would be better to just directly handle those optimizations here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="uncoveredLine">bool AMDGPUCodeGenPrepareImpl::divHasSpecialOptimization(BinaryOperator &I,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="">                                                         Value *Num,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="">                                                         Value *Den) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="uncoveredLine">  if (Constant *C = dyn_cast<Constant>(Den)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="">    // Arbitrary constants get a better expansion as long as a wider mulhi is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="">    // legal.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="uncoveredLine">    if (C->getType()->getScalarSizeInBits() <= 32)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="">    // TODO: Sdiv check for not exact for some reason.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="">    // If there's no wider mulhi, there's only a better expansion for powers of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="">    // two.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="">    // TODO: Should really know for each vector element.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="uncoveredLine">    if (isKnownToBeAPowerOfTwo(C, *DL, true, 0, AC, &I, DT))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="uncoveredLine">  if (BinaryOperator *BinOpDen = dyn_cast<BinaryOperator>(Den)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="">    // fold (udiv x, (shl c, y)) -> x >>u (log2(c)+y) iff c is power of 2</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="uncoveredLine">    if (BinOpDen->getOpcode() == Instruction::Shl &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="uncoveredLine">        isa<Constant>(BinOpDen->getOperand(0)) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="uncoveredLine">        isKnownToBeAPowerOfTwo(BinOpDen->getOperand(0), *DL, true,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="uncoveredLine">                               0, AC, &I, DT)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="uncoveredLine">static Value *getSign32(Value *V, IRBuilder<> &Builder, const DataLayout *DL) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="">  // Check whether the sign can be determined statically.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="uncoveredLine">  KnownBits Known = computeKnownBits(V, *DL);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="uncoveredLine">  if (Known.isNegative())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="uncoveredLine">    return Constant::getAllOnesValue(V->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="uncoveredLine">  if (Known.isNonNegative())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="uncoveredLine">    return Constant::getNullValue(V->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="uncoveredLine">  return Builder.CreateAShr(V, Builder.getInt32(31));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="uncoveredLine">Value *AMDGPUCodeGenPrepareImpl::expandDivRem32(IRBuilder<> &Builder,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="">                                                BinaryOperator &I, Value *X,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="">                                                Value *Y) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="uncoveredLine">  Instruction::BinaryOps Opc = I.getOpcode();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="uncoveredLine">  assert(Opc == Instruction::URem || Opc == Instruction::UDiv ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="">         Opc == Instruction::SRem || Opc == Instruction::SDiv);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="uncoveredLine">  FastMathFlags FMF;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="uncoveredLine">  FMF.setFast();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="uncoveredLine">  Builder.setFastMathFlags(FMF);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="uncoveredLine">  if (divHasSpecialOptimization(I, X, Y))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="uncoveredLine">    return nullptr;  // Keep it for later optimization.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="uncoveredLine">  bool IsDiv = Opc == Instruction::UDiv || Opc == Instruction::SDiv;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="uncoveredLine">  bool IsSigned = Opc == Instruction::SRem || Opc == Instruction::SDiv;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="uncoveredLine">  Type *Ty = X->getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="uncoveredLine">  Type *I32Ty = Builder.getInt32Ty();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="uncoveredLine">  Type *F32Ty = Builder.getFloatTy();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="uncoveredLine">  if (Ty->getScalarSizeInBits() < 32) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="uncoveredLine">    if (IsSigned) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="uncoveredLine">      X = Builder.CreateSExt(X, I32Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="uncoveredLine">      Y = Builder.CreateSExt(Y, I32Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="uncoveredLine">      X = Builder.CreateZExt(X, I32Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="uncoveredLine">      Y = Builder.CreateZExt(Y, I32Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="uncoveredLine">  if (Value *Res = expandDivRem24(Builder, I, X, Y, IsDiv, IsSigned)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="uncoveredLine">    return IsSigned ? Builder.CreateSExtOrTrunc(Res, Ty) :</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="uncoveredLine">                      Builder.CreateZExtOrTrunc(Res, Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="uncoveredLine">  ConstantInt *Zero = Builder.getInt32(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="uncoveredLine">  ConstantInt *One = Builder.getInt32(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="uncoveredLine">  Value *Sign = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="uncoveredLine">  if (IsSigned) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="uncoveredLine">    Value *SignX = getSign32(X, Builder, DL);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="uncoveredLine">    Value *SignY = getSign32(Y, Builder, DL);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="">    // Remainder sign is the same as LHS</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="uncoveredLine">    Sign = IsDiv ? Builder.CreateXor(SignX, SignY) : SignX;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="uncoveredLine">    X = Builder.CreateAdd(X, SignX);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="uncoveredLine">    Y = Builder.CreateAdd(Y, SignY);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="uncoveredLine">    X = Builder.CreateXor(X, SignX);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="uncoveredLine">    Y = Builder.CreateXor(Y, SignY);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="">  // The algorithm here is based on ideas from "Software Integer Division", Tom</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="">  // Rodeheffer, August 2008.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="">  // unsigned udiv(unsigned x, unsigned y) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="">  //   // Initial estimate of inv(y). The constant is less than 2^32 to ensure</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="">  //   // that this is a lower bound on inv(y), even if some of the calculations</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="">  //   // round up.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="">  //   unsigned z = (unsigned)((4294967296.0 - 512.0) * v_rcp_f32((float)y));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="">  //   // One round of UNR (Unsigned integer Newton-Raphson) to improve z.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="">  //   // Empirically this is guaranteed to give a "two-y" lower bound on</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="">  //   // inv(y).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="">  //   z += umulh(z, -y * z);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="">  //   // Quotient/remainder estimate.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="">  //   unsigned q = umulh(x, z);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="">  //   unsigned r = x - q * y;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="">  //   // Two rounds of quotient/remainder refinement.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="">  //   if (r >= y) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="">  //     ++q;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="">  //     r -= y;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="">  //   }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="">  //   if (r >= y) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="">  //     ++q;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="">  //     r -= y;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="">  //   }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="">  //   return q;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="">  // }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="">  // Initial estimate of inv(y).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="uncoveredLine">  Value *FloatY = Builder.CreateUIToFP(Y, F32Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="uncoveredLine">  Function *Rcp = Intrinsic::getDeclaration(Mod, Intrinsic::amdgcn_rcp, F32Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="uncoveredLine">  Value *RcpY = Builder.CreateCall(Rcp, {FloatY});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="uncoveredLine">  Constant *Scale = ConstantFP::get(F32Ty, llvm::bit_cast<float>(0x4F7FFFFE));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="uncoveredLine">  Value *ScaledY = Builder.CreateFMul(RcpY, Scale);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="uncoveredLine">  Value *Z = Builder.CreateFPToUI(ScaledY, I32Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="">  // One round of UNR.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="uncoveredLine">  Value *NegY = Builder.CreateSub(Zero, Y);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="uncoveredLine">  Value *NegYZ = Builder.CreateMul(NegY, Z);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="uncoveredLine">  Z = Builder.CreateAdd(Z, getMulHu(Builder, Z, NegYZ));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="">  // Quotient/remainder estimate.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="uncoveredLine">  Value *Q = getMulHu(Builder, X, Z);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="uncoveredLine">  Value *R = Builder.CreateSub(X, Builder.CreateMul(Q, Y));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="">  // First quotient/remainder refinement.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="uncoveredLine">  Value *Cond = Builder.CreateICmpUGE(R, Y);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="uncoveredLine">  if (IsDiv)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="uncoveredLine">    Q = Builder.CreateSelect(Cond, Builder.CreateAdd(Q, One), Q);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="uncoveredLine">  R = Builder.CreateSelect(Cond, Builder.CreateSub(R, Y), R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="">  // Second quotient/remainder refinement.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="uncoveredLine">  Cond = Builder.CreateICmpUGE(R, Y);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="">  Value *Res;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="uncoveredLine">  if (IsDiv)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="uncoveredLine">    Res = Builder.CreateSelect(Cond, Builder.CreateAdd(Q, One), Q);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="uncoveredLine">    Res = Builder.CreateSelect(Cond, Builder.CreateSub(R, Y), R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="uncoveredLine">  if (IsSigned) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="uncoveredLine">    Res = Builder.CreateXor(Res, Sign);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="uncoveredLine">    Res = Builder.CreateSub(Res, Sign);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="uncoveredLine">  Res = Builder.CreateTrunc(Res, Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="uncoveredLine">  return Res;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="uncoveredLine">Value *AMDGPUCodeGenPrepareImpl::shrinkDivRem64(IRBuilder<> &Builder,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="">                                                BinaryOperator &I, Value *Num,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="">                                                Value *Den) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="uncoveredLine">  if (!ExpandDiv64InIR && divHasSpecialOptimization(I, Num, Den))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="uncoveredLine">    return nullptr;  // Keep it for later optimization.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="uncoveredLine">  Instruction::BinaryOps Opc = I.getOpcode();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="uncoveredLine">  bool IsDiv = Opc == Instruction::SDiv || Opc == Instruction::UDiv;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="uncoveredLine">  bool IsSigned = Opc == Instruction::SDiv || Opc == Instruction::SRem;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="uncoveredLine">  int NumDivBits = getDivNumBits(I, Num, Den, 32, IsSigned);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="uncoveredLine">  if (NumDivBits == -1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="uncoveredLine">  Value *Narrowed = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="uncoveredLine">  if (NumDivBits <= 24) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="uncoveredLine">    Narrowed = expandDivRem24Impl(Builder, I, Num, Den, NumDivBits,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="">                                  IsDiv, IsSigned);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="uncoveredLine">  } else if (NumDivBits <= 32) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="uncoveredLine">    Narrowed = expandDivRem32(Builder, I, Num, Den);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="uncoveredLine">  if (Narrowed) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="uncoveredLine">    return IsSigned ? Builder.CreateSExt(Narrowed, Num->getType()) :</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="uncoveredLine">                      Builder.CreateZExt(Narrowed, Num->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="uncoveredLine">  return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="uncoveredLine">void AMDGPUCodeGenPrepareImpl::expandDivRem64(BinaryOperator &I) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="uncoveredLine">  Instruction::BinaryOps Opc = I.getOpcode();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="">  // Do the general expansion.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="uncoveredLine">  if (Opc == Instruction::UDiv || Opc == Instruction::SDiv) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="uncoveredLine">    expandDivisionUpTo64Bits(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="uncoveredLine">  if (Opc == Instruction::URem || Opc == Instruction::SRem) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="uncoveredLine">    expandRemainderUpTo64Bits(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="uncoveredLine">  llvm_unreachable("not a division");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="uncoveredLine">bool AMDGPUCodeGenPrepareImpl::visitBinaryOperator(BinaryOperator &I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="uncoveredLine">  if (foldBinOpIntoSelect(I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="uncoveredLine">  if (ST->has16BitInsts() && needsPromotionToI32(I.getType()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="uncoveredLine">      UA->isUniform(&I) && promoteUniformOpToI32(I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="uncoveredLine">  if (UseMul24Intrin && replaceMulWithMul24(I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="uncoveredLine">  bool Changed = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="uncoveredLine">  Instruction::BinaryOps Opc = I.getOpcode();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="uncoveredLine">  Type *Ty = I.getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="uncoveredLine">  Value *NewDiv = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="uncoveredLine">  unsigned ScalarSize = Ty->getScalarSizeInBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="uncoveredLine">  SmallVector<BinaryOperator *, 8> Div64ToExpand;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="uncoveredLine">  if ((Opc == Instruction::URem || Opc == Instruction::UDiv ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="uncoveredLine">       Opc == Instruction::SRem || Opc == Instruction::SDiv) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="uncoveredLine">      ScalarSize <= 64 &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="uncoveredLine">      !DisableIDivExpand) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="uncoveredLine">    Value *Num = I.getOperand(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="uncoveredLine">    Value *Den = I.getOperand(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="uncoveredLine">    IRBuilder<> Builder(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="uncoveredLine">    Builder.SetCurrentDebugLocation(I.getDebugLoc());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="uncoveredLine">    if (auto *VT = dyn_cast<FixedVectorType>(Ty)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="uncoveredLine">      NewDiv = PoisonValue::get(VT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="uncoveredLine">      for (unsigned N = 0, E = VT->getNumElements(); N != E; ++N) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="uncoveredLine">        Value *NumEltN = Builder.CreateExtractElement(Num, N);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="uncoveredLine">        Value *DenEltN = Builder.CreateExtractElement(Den, N);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="">        Value *NewElt;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="uncoveredLine">        if (ScalarSize <= 32) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="uncoveredLine">          NewElt = expandDivRem32(Builder, I, NumEltN, DenEltN);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="uncoveredLine">          if (!NewElt)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="uncoveredLine">            NewElt = Builder.CreateBinOp(Opc, NumEltN, DenEltN);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="">        } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="">          // See if this 64-bit division can be shrunk to 32/24-bits before</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="">          // producing the general expansion.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="uncoveredLine">          NewElt = shrinkDivRem64(Builder, I, NumEltN, DenEltN);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="uncoveredLine">          if (!NewElt) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="">            // The general 64-bit expansion introduces control flow and doesn't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="">            // return the new value. Just insert a scalar copy and defer</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="">            // expanding it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="uncoveredLine">            NewElt = Builder.CreateBinOp(Opc, NumEltN, DenEltN);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="uncoveredLine">            Div64ToExpand.push_back(cast<BinaryOperator>(NewElt));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="uncoveredLine">        NewDiv = Builder.CreateInsertElement(NewDiv, NewElt, N);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="uncoveredLine">      if (ScalarSize <= 32)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="uncoveredLine">        NewDiv = expandDivRem32(Builder, I, Num, Den);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="">      else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="uncoveredLine">        NewDiv = shrinkDivRem64(Builder, I, Num, Den);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="uncoveredLine">        if (!NewDiv)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="uncoveredLine">          Div64ToExpand.push_back(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="uncoveredLine">    if (NewDiv) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="uncoveredLine">      I.replaceAllUsesWith(NewDiv);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="uncoveredLine">      I.eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="uncoveredLine">      Changed = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="uncoveredLine">  if (ExpandDiv64InIR) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="">    // TODO: We get much worse code in specially handled constant cases.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="uncoveredLine">    for (BinaryOperator *Div : Div64ToExpand) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="uncoveredLine">      expandDivRem64(*Div);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="uncoveredLine">      FlowChanged = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="uncoveredLine">      Changed = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="uncoveredLine">  return Changed;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="uncoveredLine">bool AMDGPUCodeGenPrepareImpl::visitLoadInst(LoadInst &I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="uncoveredLine">  if (!WidenLoads)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="uncoveredLine">  if ((I.getPointerAddressSpace() == AMDGPUAS::CONSTANT_ADDRESS ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="uncoveredLine">       I.getPointerAddressSpace() == AMDGPUAS::CONSTANT_ADDRESS_32BIT) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="uncoveredLine">      canWidenScalarExtLoad(I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="uncoveredLine">    IRBuilder<> Builder(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="uncoveredLine">    Builder.SetCurrentDebugLocation(I.getDebugLoc());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="uncoveredLine">    Type *I32Ty = Builder.getInt32Ty();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="uncoveredLine">    LoadInst *WidenLoad = Builder.CreateLoad(I32Ty, I.getPointerOperand());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="uncoveredLine">    WidenLoad->copyMetadata(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="">    // If we have range metadata, we need to convert the type, and not make</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="">    // assumptions about the high bits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="uncoveredLine">    if (auto *Range = WidenLoad->getMetadata(LLVMContext::MD_range)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="">      ConstantInt *Lower =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="uncoveredLine">        mdconst::extract<ConstantInt>(Range->getOperand(0));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="uncoveredLine">      if (Lower->isNullValue()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="uncoveredLine">        WidenLoad->setMetadata(LLVMContext::MD_range, nullptr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="">        Metadata *LowAndHigh[] = {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="uncoveredLine">          ConstantAsMetadata::get(ConstantInt::get(I32Ty, Lower->getValue().zext(32))),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="">          // Don't make assumptions about the high bits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="uncoveredLine">          ConstantAsMetadata::get(ConstantInt::get(I32Ty, 0))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="uncoveredLine">        };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="uncoveredLine">        WidenLoad->setMetadata(LLVMContext::MD_range,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="uncoveredLine">                               MDNode::get(Mod->getContext(), LowAndHigh));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="uncoveredLine">    int TySize = Mod->getDataLayout().getTypeSizeInBits(I.getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="uncoveredLine">    Type *IntNTy = Builder.getIntNTy(TySize);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="uncoveredLine">    Value *ValTrunc = Builder.CreateTrunc(WidenLoad, IntNTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="uncoveredLine">    Value *ValOrig = Builder.CreateBitCast(ValTrunc, I.getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="uncoveredLine">    I.replaceAllUsesWith(ValOrig);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="uncoveredLine">    I.eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="uncoveredLine">bool AMDGPUCodeGenPrepareImpl::visitICmpInst(ICmpInst &I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="uncoveredLine">  bool Changed = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="uncoveredLine">  if (ST->has16BitInsts() && needsPromotionToI32(I.getOperand(0)->getType()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="uncoveredLine">      UA->isUniform(&I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="uncoveredLine">    Changed |= promoteUniformOpToI32(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="uncoveredLine">  return Changed;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="uncoveredLine">bool AMDGPUCodeGenPrepareImpl::visitSelectInst(SelectInst &I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="uncoveredLine">  Value *Cond = I.getCondition();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="uncoveredLine">  Value *TrueVal = I.getTrueValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="uncoveredLine">  Value *FalseVal = I.getFalseValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="">  Value *CmpVal;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="">  FCmpInst::Predicate Pred;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="uncoveredLine">  if (ST->has16BitInsts() && needsPromotionToI32(I.getType())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="uncoveredLine">    if (UA->isUniform(&I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="uncoveredLine">      return promoteUniformOpToI32(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="">  // Match fract pattern with nan check.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="uncoveredLine">  if (!match(Cond, m_FCmp(Pred, m_Value(CmpVal), m_NonNaN())))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="uncoveredLine">  FPMathOperator *FPOp = dyn_cast<FPMathOperator>(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="uncoveredLine">  if (!FPOp)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="uncoveredLine">  IRBuilder<> Builder(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="uncoveredLine">  Builder.setFastMathFlags(FPOp->getFastMathFlags());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="uncoveredLine">  auto *IITrue = dyn_cast<IntrinsicInst>(TrueVal);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="uncoveredLine">  auto *IIFalse = dyn_cast<IntrinsicInst>(FalseVal);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="uncoveredLine">  Value *Fract = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="uncoveredLine">  if (Pred == FCmpInst::FCMP_UNO && TrueVal == CmpVal && IIFalse &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="uncoveredLine">      CmpVal == matchFractPat(*IIFalse)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="">    // isnan(x) ? x : fract(x)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="uncoveredLine">    Fract = applyFractPat(Builder, CmpVal);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="uncoveredLine">  } else if (Pred == FCmpInst::FCMP_ORD && FalseVal == CmpVal && IITrue &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="uncoveredLine">             CmpVal == matchFractPat(*IITrue)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="">    // !isnan(x) ? fract(x) : x</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="uncoveredLine">    Fract = applyFractPat(Builder, CmpVal);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="">  } else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="uncoveredLine">  Fract->takeName(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="uncoveredLine">  I.replaceAllUsesWith(Fract);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="uncoveredLine">  RecursivelyDeleteTriviallyDeadInstructions(&I, TLInfo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="uncoveredLine">static bool areInSameBB(const Value *A, const Value *B) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="uncoveredLine">  const auto *IA = dyn_cast<Instruction>(A);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="uncoveredLine">  const auto *IB = dyn_cast<Instruction>(B);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="uncoveredLine">  return IA && IB && IA->getParent() == IB->getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="">// Helper for breaking large PHIs that returns true when an extractelement on V</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="">// is likely to be folded away by the DAG combiner.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="uncoveredLine">static bool isInterestingPHIIncomingValue(const Value *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="uncoveredLine">  const auto *FVT = dyn_cast<FixedVectorType>(V->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="uncoveredLine">  if (!FVT)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="uncoveredLine">  const Value *CurVal = V;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="">  // Check for insertelements, keeping track of the elements covered.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="uncoveredLine">  BitVector EltsCovered(FVT->getNumElements());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="uncoveredLine">  while (const auto *IE = dyn_cast<InsertElementInst>(CurVal)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="uncoveredLine">    const auto *Idx = dyn_cast<ConstantInt>(IE->getOperand(2));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="">    // Non constant index/out of bounds index -> folding is unlikely.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="">    // The latter is more of a sanity check because canonical IR should just</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="">    // have replaced those with poison.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="uncoveredLine">    if (!Idx || Idx->getSExtValue() >= FVT->getNumElements())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="uncoveredLine">    const auto *VecSrc = IE->getOperand(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="">    // If the vector source is another instruction, it must be in the same basic</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="">    // block. Otherwise, the DAGCombiner won't see the whole thing and is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="">    // unlikely to be able to do anything interesting here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="uncoveredLine">    if (isa<Instruction>(VecSrc) && !areInSameBB(VecSrc, IE))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="uncoveredLine">    CurVal = VecSrc;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="uncoveredLine">    EltsCovered.set(Idx->getSExtValue());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="">    // All elements covered.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="uncoveredLine">    if (EltsCovered.all())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="">  // We either didn't find a single insertelement, or the insertelement chain</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="">  // ended before all elements were covered. Check for other interesting values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="">  // Constants are always interesting because we can just constant fold the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="">  // extractelements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="uncoveredLine">  if (isa<Constant>(CurVal))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="">  // shufflevector is likely to be profitable if either operand is a constant,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="">  // or if either source is in the same block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="">  // This is because shufflevector is most often lowered as a series of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="">  // insert/extract elements anyway.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="uncoveredLine">  if (const auto *SV = dyn_cast<ShuffleVectorInst>(CurVal)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="uncoveredLine">    return isa<Constant>(SV->getOperand(1)) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="uncoveredLine">           areInSameBB(SV, SV->getOperand(0)) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="uncoveredLine">           areInSameBB(SV, SV->getOperand(1));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="uncoveredLine">bool AMDGPUCodeGenPrepareImpl::canBreakPHINode(const PHINode &I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="">  // Check in the cache, or add an entry for this node.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="">  // We init with false because we consider all PHI nodes unbreakable until we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="">  // reach a conclusion. Doing the opposite - assuming they're break-able until</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="">  // proven otherwise - can be harmful in some pathological cases so we're</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="">  // conservative for now.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="uncoveredLine">  const auto [It, DidInsert] = BreakPhiNodesCache.insert({&I, false});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="uncoveredLine">  if (!DidInsert)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="uncoveredLine">    return It->second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="">  // This function may recurse, so to guard against infinite looping, this PHI</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="">  // is conservatively considered unbreakable until we reach a conclusion.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="">  // Don't break PHIs that have no interesting incoming values. That is, where</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="">  // there is no clear opportunity to fold the "extractelement" instructions we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="">  // would add.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="">  // Note: IC does not run after this pass, so we're only interested in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="">  // foldings that the DAG combiner can do.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="uncoveredLine">  if (none_of(I.incoming_values(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="uncoveredLine">              [&](Value *V) { return isInterestingPHIIncomingValue(V); }))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="">  // Now, check users for unbreakable PHI nodes. If we have an unbreakable PHI</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="">  // node as user, we don't want to break this PHI either because it's unlikely</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="">  // to be beneficial. We would just explode the vector and reassemble it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="">  // directly, wasting instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="">  // In the case where multiple users are PHI nodes, we want at least half of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="">  // them to be breakable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="uncoveredLine">  int Score = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="uncoveredLine">  for (const Value *U : I.users()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="uncoveredLine">    if (const auto *PU = dyn_cast<PHINode>(U))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="uncoveredLine">      Score += canBreakPHINode(*PU) ? 1 : -1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="uncoveredLine">  if (Score < 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="uncoveredLine">  return BreakPhiNodesCache[&I] = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="">/// Helper class for "break large PHIs" (visitPHINode).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="">/// This represents a slice of a PHI's incoming value, which is made up of:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="">///   - The type of the slice (Ty)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="">///   - The index in the incoming value's vector where the slice starts (Idx)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="">///   - The number of elements in the slice (NumElts).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="">/// It also keeps track of the NewPHI node inserted for this particular slice.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="">/// Slice examples:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="">///   <4 x i64> -> Split into four i64 slices.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="">///     -> [i64, 0, 1], [i64, 1, 1], [i64, 2, 1], [i64, 3, 1]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="">///   <5 x i16> -> Split into 2 <2 x i16> slices + a i16 tail.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="">///     -> [<2 x i16>, 0, 2], [<2 x i16>, 2, 2], [i16, 4, 1]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="">class VectorSlice {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="uncoveredLine">  VectorSlice(Type *Ty, unsigned Idx, unsigned NumElts)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="uncoveredLine">      : Ty(Ty), Idx(Idx), NumElts(NumElts) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="">  Type *Ty = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="">  unsigned Idx = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="">  unsigned NumElts = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="">  PHINode *NewPHI = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="">  /// Slice \p Inc according to the information contained within this slice.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="">  /// This is cached, so if called multiple times for the same \p BB & \p Inc</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="">  /// pair, it returns the same Sliced value as well.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="">  /// Note this *intentionally* does not return the same value for, say,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="">  /// [%bb.0, %0] & [%bb.1, %0] as:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="">  ///   - It could cause issues with dominance (e.g. if bb.1 is seen first, then</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="">  ///   the value in bb.1 may not be reachable from bb.0 if it's its</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="">  ///   predecessor.)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="">  ///   - We also want to make our extract instructions as local as possible so</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="">  ///   the DAG has better chances of folding them out. Duplicating them like</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="">  ///   that is beneficial in that regard.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="">  /// This is both a minor optimization to avoid creating duplicate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="">  /// instructions, but also a requirement for correctness. It is not forbidden</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="">  /// for a PHI node to have the same [BB, Val] pair multiple times. If we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="">  /// returned a new value each time, those previously identical pairs would all</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="">  /// have different incoming values (from the same block) and it'd cause a "PHI</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="">  /// node has multiple entries for the same basic block with different incoming</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="">  /// values!" verifier error.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="uncoveredLine">  Value *getSlicedVal(BasicBlock *BB, Value *Inc, StringRef NewValName) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="uncoveredLine">    Value *&Res = SlicedVals[{BB, Inc}];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="uncoveredLine">    if (Res)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="uncoveredLine">      return Res;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="uncoveredLine">    IRBuilder<> B(BB->getTerminator());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="uncoveredLine">    if (Instruction *IncInst = dyn_cast<Instruction>(Inc))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="uncoveredLine">      B.SetCurrentDebugLocation(IncInst->getDebugLoc());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="uncoveredLine">    if (NumElts > 1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="uncoveredLine">      SmallVector<int, 4> Mask;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="uncoveredLine">      for (unsigned K = Idx; K < (Idx + NumElts); ++K)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="uncoveredLine">        Mask.push_back(K);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="uncoveredLine">      Res = B.CreateShuffleVector(Inc, Mask, NewValName);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="uncoveredLine">    } else</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="uncoveredLine">      Res = B.CreateExtractElement(Inc, Idx, NewValName);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="uncoveredLine">    return Res;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="">  SmallDenseMap<std::pair<BasicBlock *, Value *>, Value *> SlicedVals;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="uncoveredLine">bool AMDGPUCodeGenPrepareImpl::visitPHINode(PHINode &I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="">  // Break-up fixed-vector PHIs into smaller pieces.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="">  // Default threshold is 32, so it breaks up any vector that's >32 bits into</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="">  // its elements, or into 32-bit pieces (for 8/16 bit elts).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="">  // This is only helpful for DAGISel because it doesn't handle large PHIs as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="">  // well as GlobalISel. DAGISel lowers PHIs by using CopyToReg/CopyFromReg.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="">  // With large, odd-sized PHIs we may end up needing many `build_vector`</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="">  // operations with most elements being "undef". This inhibits a lot of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="">  // optimization opportunities and can result in unreasonably high register</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="">  // pressure and the inevitable stack spilling.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="uncoveredLine">  if (!ScalarizeLargePHIs || getCGPassBuilderOption().EnableGlobalISelOption)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="uncoveredLine">  FixedVectorType *FVT = dyn_cast<FixedVectorType>(I.getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="uncoveredLine">  if (!FVT || DL->getTypeSizeInBits(FVT) <= ScalarizeLargePHIsThreshold)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="uncoveredLine">  if (!ForceScalarizeLargePHIs && !canBreakPHINode(I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="uncoveredLine">  std::vector<VectorSlice> Slices;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="uncoveredLine">  Type *EltTy = FVT->getElementType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="">  {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="uncoveredLine">    unsigned Idx = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="">    // For 8/16 bits type, don't scalarize fully but break it up into as many</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="">    // 32-bit slices as we can, and scalarize the tail.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="uncoveredLine">    const unsigned EltSize = DL->getTypeSizeInBits(EltTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="uncoveredLine">    const unsigned NumElts = FVT->getNumElements();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="uncoveredLine">    if (EltSize == 8 || EltSize == 16) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="uncoveredLine">      const unsigned SubVecSize = (32 / EltSize);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="uncoveredLine">      Type *SubVecTy = FixedVectorType::get(EltTy, SubVecSize);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="uncoveredLine">      for (unsigned End = alignDown(NumElts, SubVecSize); Idx < End;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="uncoveredLine">           Idx += SubVecSize)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="uncoveredLine">        Slices.emplace_back(SubVecTy, Idx, SubVecSize);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="">    // Scalarize all remaining elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="uncoveredLine">    for (; Idx < NumElts; ++Idx)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="uncoveredLine">      Slices.emplace_back(EltTy, Idx, 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="uncoveredLine">  if (Slices.size() == 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="">  // Create one PHI per vector piece. The "VectorSlice" class takes care of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="">  // creating the necessary instruction to extract the relevant slices of each</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="">  // incoming value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="uncoveredLine">  IRBuilder<> B(I.getParent());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="uncoveredLine">  B.SetCurrentDebugLocation(I.getDebugLoc());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="uncoveredLine">  unsigned IncNameSuffix = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="uncoveredLine">  for (VectorSlice &S : Slices) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="">    // We need to reset the build on each iteration, because getSlicedVal may</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="">    // have inserted something into I's BB.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="uncoveredLine">    B.SetInsertPoint(I.getParent()->getFirstNonPHI());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="uncoveredLine">    S.NewPHI = B.CreatePHI(S.Ty, I.getNumIncomingValues());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="uncoveredLine">    for (const auto &[Idx, BB] : enumerate(I.blocks())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="uncoveredLine">      S.NewPHI->addIncoming(S.getSlicedVal(BB, I.getIncomingValue(Idx),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="uncoveredLine">                                           "largephi.extractslice" +</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="uncoveredLine">                                               std::to_string(IncNameSuffix++)),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="">                            BB);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="">  // And replace this PHI with a vector of all the previous PHI values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="uncoveredLine">  Value *Vec = PoisonValue::get(FVT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="uncoveredLine">  unsigned NameSuffix = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="uncoveredLine">  for (VectorSlice &S : Slices) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="uncoveredLine">    const auto ValName = "largephi.insertslice" + std::to_string(NameSuffix++);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="uncoveredLine">    if (S.NumElts > 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="">      Vec =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="uncoveredLine">          B.CreateInsertVector(FVT, Vec, S.NewPHI, B.getInt64(S.Idx), ValName);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="uncoveredLine">      Vec = B.CreateInsertElement(Vec, S.NewPHI, S.Idx, ValName);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="uncoveredLine">  I.replaceAllUsesWith(Vec);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="uncoveredLine">  I.eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="uncoveredLine">bool AMDGPUCodeGenPrepareImpl::visitIntrinsicInst(IntrinsicInst &I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="uncoveredLine">  switch (I.getIntrinsicID()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="uncoveredLine">  case Intrinsic::bitreverse:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="uncoveredLine">    return visitBitreverseIntrinsicInst(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="uncoveredLine">  case Intrinsic::minnum:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="uncoveredLine">    return visitMinNum(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="uncoveredLine">  default:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="uncoveredLine">bool AMDGPUCodeGenPrepareImpl::visitBitreverseIntrinsicInst(IntrinsicInst &I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="uncoveredLine">  bool Changed = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="uncoveredLine">  if (ST->has16BitInsts() && needsPromotionToI32(I.getType()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="uncoveredLine">      UA->isUniform(&I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="uncoveredLine">    Changed |= promoteUniformBitreverseToI32(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="uncoveredLine">  return Changed;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="">/// Match non-nan fract pattern.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="">///   minnum(fsub(x, floor(x)), nextafter(1.0, -1.0)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="">/// If fract is a useful instruction for the subtarget. Does not account for the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="">/// nan handling; the instruction has a nan check on the input value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="uncoveredLine">Value *AMDGPUCodeGenPrepareImpl::matchFractPat(IntrinsicInst &I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="uncoveredLine">  if (ST->hasFractBug())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="uncoveredLine">  if (I.getIntrinsicID() != Intrinsic::minnum)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="uncoveredLine">  Type *Ty = I.getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="uncoveredLine">  if (!isLegalFloatingTy(Ty->getScalarType()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="uncoveredLine">  Value *Arg0 = I.getArgOperand(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="uncoveredLine">  Value *Arg1 = I.getArgOperand(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="">  const APFloat *C;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="uncoveredLine">  if (!match(Arg1, m_APFloat(C)))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="uncoveredLine">  APFloat One(1.0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="">  bool LosesInfo;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="uncoveredLine">  One.convert(C->getSemantics(), APFloat::rmNearestTiesToEven, &LosesInfo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="">  // Match nextafter(1.0, -1)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="uncoveredLine">  One.next(true);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="uncoveredLine">  if (One != *C)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="">  Value *FloorSrc;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="uncoveredLine">  if (match(Arg0, m_FSub(m_Value(FloorSrc),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="uncoveredLine">                         m_Intrinsic<Intrinsic::floor>(m_Deferred(FloorSrc)))))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="uncoveredLine">    return FloorSrc;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="uncoveredLine">  return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="uncoveredLine">Value *AMDGPUCodeGenPrepareImpl::applyFractPat(IRBuilder<> &Builder,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="">                                               Value *FractArg) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="uncoveredLine">  SmallVector<Value *, 4> FractVals;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="uncoveredLine">  extractValues(Builder, FractVals, FractArg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="uncoveredLine">  SmallVector<Value *, 4> ResultVals(FractVals.size());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="uncoveredLine">  Type *Ty = FractArg->getType()->getScalarType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="uncoveredLine">  for (unsigned I = 0, E = FractVals.size(); I != E; ++I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="uncoveredLine">    ResultVals[I] =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="uncoveredLine">        Builder.CreateIntrinsic(Intrinsic::amdgcn_fract, {Ty}, {FractVals[I]});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="uncoveredLine">  return insertValues(Builder, FractArg->getType(), ResultVals);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="uncoveredLine">bool AMDGPUCodeGenPrepareImpl::visitMinNum(IntrinsicInst &I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="uncoveredLine">  Value *FractArg = matchFractPat(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="uncoveredLine">  if (!FractArg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="">  // Match pattern for fract intrinsic in contexts where the nan check has been</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="">  // optimized out (and hope the knowledge the source can't be nan wasn't lost).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="uncoveredLine">  if (!I.hasNoNaNs() && !isKnownNeverNaN(FractArg, *DL, TLInfo))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="uncoveredLine">  IRBuilder<> Builder(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="uncoveredLine">  FastMathFlags FMF = I.getFastMathFlags();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="uncoveredLine">  FMF.setNoNaNs();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="uncoveredLine">  Builder.setFastMathFlags(FMF);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="uncoveredLine">  Value *Fract = applyFractPat(Builder, FractArg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="uncoveredLine">  Fract->takeName(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="uncoveredLine">  I.replaceAllUsesWith(Fract);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="uncoveredLine">  RecursivelyDeleteTriviallyDeadInstructions(&I, TLInfo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="uncoveredLine">bool AMDGPUCodeGenPrepare::doInitialization(Module &M) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="uncoveredLine">  Impl.Mod = &M;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="uncoveredLine">  Impl.DL = &Impl.Mod->getDataLayout();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="uncoveredLine">bool AMDGPUCodeGenPrepare::runOnFunction(Function &F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="uncoveredLine">  if (skipFunction(F))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="uncoveredLine">  auto *TPC = getAnalysisIfAvailable<TargetPassConfig>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="uncoveredLine">  if (!TPC)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="uncoveredLine">  const AMDGPUTargetMachine &TM = TPC->getTM<AMDGPUTargetMachine>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="uncoveredLine">  Impl.TLInfo = &getAnalysis<TargetLibraryInfoWrapperPass>().getTLI(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="uncoveredLine">  Impl.ST = &TM.getSubtarget<GCNSubtarget>(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="uncoveredLine">  Impl.AC = &getAnalysis<AssumptionCacheTracker>().getAssumptionCache(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="uncoveredLine">  Impl.UA = &getAnalysis<UniformityInfoWrapperPass>().getUniformityInfo();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="uncoveredLine">  auto *DTWP = getAnalysisIfAvailable<DominatorTreeWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="uncoveredLine">  Impl.DT = DTWP ? &DTWP->getDomTree() : nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="uncoveredLine">  Impl.HasUnsafeFPMath = hasUnsafeFPMath(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="uncoveredLine">  SIModeRegisterDefaults Mode(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="uncoveredLine">  Impl.HasFP32DenormalFlush =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="uncoveredLine">      Mode.FP32Denormals == DenormalMode::getPreserveSign();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="uncoveredLine">  return Impl.run(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="uncoveredLine">PreservedAnalyses AMDGPUCodeGenPreparePass::run(Function &F,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="">                                                FunctionAnalysisManager &FAM) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="uncoveredLine">  AMDGPUCodeGenPrepareImpl Impl;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="uncoveredLine">  Impl.Mod = F.getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="uncoveredLine">  Impl.DL = &Impl.Mod->getDataLayout();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="uncoveredLine">  Impl.TLInfo = &FAM.getResult<TargetLibraryAnalysis>(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="uncoveredLine">  Impl.ST = &TM.getSubtarget<GCNSubtarget>(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="uncoveredLine">  Impl.AC = &FAM.getResult<AssumptionAnalysis>(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="uncoveredLine">  Impl.UA = &FAM.getResult<UniformityInfoAnalysis>(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="uncoveredLine">  Impl.DT = FAM.getCachedResult<DominatorTreeAnalysis>(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="uncoveredLine">  Impl.HasUnsafeFPMath = hasUnsafeFPMath(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="uncoveredLine">  SIModeRegisterDefaults Mode(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="uncoveredLine">  Impl.HasFP32DenormalFlush =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="uncoveredLine">      Mode.FP32Denormals == DenormalMode::getPreserveSign();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="uncoveredLine">  PreservedAnalyses PA = PreservedAnalyses::none();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="uncoveredLine">  if (!Impl.FlowChanged)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="uncoveredLine">    PA.preserveSet<CFGAnalyses>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="uncoveredLine">  return Impl.run(F) ? PA : PreservedAnalyses::all();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="coveredLine">INITIALIZE_PASS_BEGIN(AMDGPUCodeGenPrepare, DEBUG_TYPE,</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="">                      "AMDGPU IR optimizations", false, false)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(AssumptionCacheTracker)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(TargetLibraryInfoWrapperPass)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(UniformityInfoWrapperPass)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="coveredLine">INITIALIZE_PASS_END(AMDGPUCodeGenPrepare, DEBUG_TYPE, "AMDGPU IR optimizations",</td>
    <td>4</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="">                    false, false)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="">char AMDGPUCodeGenPrepare::ID = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="uncoveredLine">FunctionPass *llvm::createAMDGPUCodeGenPreparePass() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="uncoveredLine">  return new AMDGPUCodeGenPrepare();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Functions Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Functions Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Function name</th>
    <th class="mainTh">Number of hits</th>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl19computeKnownFPClassEPKN4llvm5ValueENS1_11FPClassTestEPKNS1_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl22canIgnoreDenormalInputEPKN4llvm5ValueEPKNS1_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl16visitInstructionERN4llvm11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AMDGPUCodeGenPrepareC2Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120AMDGPUCodeGenPrepare16getAnalysisUsageERN4llvm13AnalysisUsageE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_120AMDGPUCodeGenPrepare11getPassNameEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl3runERN4llvm8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl22getBaseElementBitWidthEPKN4llvm4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl8getI32TyERN4llvm9IRBuilderINS1_14ConstantFolderENS1_24IRBuilderDefaultInserterEEEPKNS1_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl8isSignedERKN4llvm14BinaryOperatorE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl8isSignedERKN4llvm10SelectInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl19needsPromotionToI32EPKN4llvm4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl17isLegalFloatingTyEPKN4llvm4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL15promotedOpIsNSWRKN4llvm11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL15promotedOpIsNUWRKN4llvm11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl21canWidenScalarExtLoadERN4llvm8LoadInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl21promoteUniformOpToI32ERN4llvm14BinaryOperatorE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl21promoteUniformOpToI32ERN4llvm8ICmpInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl21promoteUniformOpToI32ERN4llvm10SelectInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl29promoteUniformBitreverseToI32ERN4llvm13IntrinsicInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl15numBitsUnsignedEPN4llvm5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl13numBitsSignedEPN4llvm5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL13extractValuesRN4llvm9IRBuilderINS_14ConstantFolderENS_24IRBuilderDefaultInserterEEERNS_15SmallVectorImplIPNS_5ValueEEES7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL12insertValuesRN4llvm9IRBuilderINS_14ConstantFolderENS_24IRBuilderDefaultInserterEEEPNS_4TypeERNS_15SmallVectorImplIPNS_5ValueEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL8getMul24RN4llvm9IRBuilderINS_14ConstantFolderENS_24IRBuilderDefaultInserterEEEPNS_5ValueES6_jjb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl19replaceMulWithMul24ERN4llvm14BinaryOperatorE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL21findSelectThroughCastPN4llvm5ValueERPNS_8CastInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl19foldBinOpIntoSelectERN4llvm14BinaryOperatorE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl15getFrexpResultsERN4llvm9IRBuilderINS1_14ConstantFolderENS1_24IRBuilderDefaultInserterEEEPNS1_5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl15emitRcpIEEE1ULPERN4llvm9IRBuilderINS1_14ConstantFolderENS1_24IRBuilderDefaultInserterEEEPNS1_5ValueEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl12emitFrexpDivERN4llvm9IRBuilderINS1_14ConstantFolderENS1_24IRBuilderDefaultInserterEEEPNS1_5ValueES8_NS1_13FastMathFlagsE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL15emitRsqIEEE1ULPRN4llvm9IRBuilderINS_14ConstantFolderENS_24IRBuilderDefaultInserterEEEPNS_5ValueEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl18canOptimizeWithRsqEPKN4llvm14FPMathOperatorENS1_13FastMathFlagsES5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl15optimizeWithRsqERN4llvm9IRBuilderINS1_14ConstantFolderENS1_24IRBuilderDefaultInserterEEEPNS1_5ValueES8_NS1_13FastMathFlagsES9_PKNS1_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl15optimizeWithRcpERN4llvm9IRBuilderINS1_14ConstantFolderENS1_24IRBuilderDefaultInserterEEEPNS1_5ValueES8_NS1_13FastMathFlagsEPKNS1_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl20optimizeWithFDivFastERN4llvm9IRBuilderINS1_14ConstantFolderENS1_24IRBuilderDefaultInserterEEEPNS1_5ValueES8_f</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl16visitFDivElementERN4llvm9IRBuilderINS1_14ConstantFolderENS1_24IRBuilderDefaultInserterEEEPNS1_5ValueES8_NS1_13FastMathFlagsES9_S8_PKNS1_11InstructionEf</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl9visitFDivERN4llvm14BinaryOperatorE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL15hasUnsafeFPMathRKN4llvm8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL8getMul64RN4llvm9IRBuilderINS_14ConstantFolderENS_24IRBuilderDefaultInserterEEEPNS_5ValueES6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL8getMulHuRN4llvm9IRBuilderINS_14ConstantFolderENS_24IRBuilderDefaultInserterEEEPNS_5ValueES6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl13getDivNumBitsERN4llvm14BinaryOperatorEPNS1_5ValueES5_jb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl14expandDivRem24ERN4llvm9IRBuilderINS1_14ConstantFolderENS1_24IRBuilderDefaultInserterEEERNS1_14BinaryOperatorEPNS1_5ValueESA_bb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl18expandDivRem24ImplERN4llvm9IRBuilderINS1_14ConstantFolderENS1_24IRBuilderDefaultInserterEEERNS1_14BinaryOperatorEPNS1_5ValueESA_jbb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl25divHasSpecialOptimizationERN4llvm14BinaryOperatorEPNS1_5ValueES5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL9getSign32PN4llvm5ValueERNS_9IRBuilderINS_14ConstantFolderENS_24IRBuilderDefaultInserterEEEPKNS_10DataLayoutE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl14expandDivRem32ERN4llvm9IRBuilderINS1_14ConstantFolderENS1_24IRBuilderDefaultInserterEEERNS1_14BinaryOperatorEPNS1_5ValueESA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl14shrinkDivRem64ERN4llvm9IRBuilderINS1_14ConstantFolderENS1_24IRBuilderDefaultInserterEEERNS1_14BinaryOperatorEPNS1_5ValueESA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl14expandDivRem64ERN4llvm14BinaryOperatorE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl19visitBinaryOperatorERN4llvm14BinaryOperatorE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl13visitLoadInstERN4llvm8LoadInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl13visitICmpInstERN4llvm8ICmpInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl15visitSelectInstERN4llvm10SelectInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL11areInSameBBPKN4llvm5ValueES2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL29isInterestingPHIIncomingValuePKN4llvm5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl15canBreakPHINodeERKN4llvm7PHINodeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl15canBreakPHINodeERKN4llvm7PHINodeEENKUlPNS1_5ValueEE_clES6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN11VectorSliceC2EPN4llvm4TypeEjj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN11VectorSlice12getSlicedValEPN4llvm10BasicBlockEPNS0_5ValueENS0_9StringRefE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl12visitPHINodeERN4llvm7PHINodeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl18visitIntrinsicInstERN4llvm13IntrinsicInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl28visitBitreverseIntrinsicInstERN4llvm13IntrinsicInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl13matchFractPatERN4llvm13IntrinsicInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl13applyFractPatERN4llvm9IRBuilderINS1_14ConstantFolderENS1_24IRBuilderDefaultInserterEEEPNS1_5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_124AMDGPUCodeGenPrepareImpl11visitMinNumERN4llvm13IntrinsicInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AMDGPUCodeGenPrepare16doInitializationERN4llvm6ModuleE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AMDGPUCodeGenPrepare13runOnFunctionERN4llvm8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm24AMDGPUCodeGenPreparePass3runERNS_8FunctionERNS_15AnalysisManagerIS1_JEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL38initializeAMDGPUCodeGenPreparePassOnceRN4llvm12PassRegistryE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm34initializeAMDGPUCodeGenPreparePassERNS_12PassRegistryE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm30createAMDGPUCodeGenPreparePassEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Coverage Diff</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Coverage Diff</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeline">//===-- AMDGPUCodeGenPrepare.cpp ------------------------------------------===//</td>
    <td class="lineNumber">1</td>
    <td class="codeline">//===-- AMDGPUCodeGenPrepare.cpp ------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeline">/// \file</td>
    <td class="lineNumber">9</td>
    <td class="codeline">/// \file</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeline">/// This pass does misc. AMDGPU optimizations on IR before instruction</td>
    <td class="lineNumber">10</td>
    <td class="codeline">/// This pass does misc. AMDGPU optimizations on IR before instruction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeline">/// selection.</td>
    <td class="lineNumber">11</td>
    <td class="codeline">/// selection.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeline">//</td>
    <td class="lineNumber">12</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">13</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeline"></td>
    <td class="lineNumber">14</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeline">#include "AMDGPU.h"</td>
    <td class="lineNumber">15</td>
    <td class="codeline">#include "AMDGPU.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeline">#include "AMDGPUTargetMachine.h"</td>
    <td class="lineNumber">16</td>
    <td class="codeline">#include "AMDGPUTargetMachine.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeline">#include "SIModeRegisterDefaults.h"</td>
    <td class="lineNumber">17</td>
    <td class="codeline">#include "SIModeRegisterDefaults.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeline">#include "llvm/Analysis/AssumptionCache.h"</td>
    <td class="lineNumber">18</td>
    <td class="codeline">#include "llvm/Analysis/AssumptionCache.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeline">#include "llvm/Analysis/ConstantFolding.h"</td>
    <td class="lineNumber">19</td>
    <td class="codeline">#include "llvm/Analysis/ConstantFolding.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeline">#include "llvm/Analysis/TargetLibraryInfo.h"</td>
    <td class="lineNumber">20</td>
    <td class="codeline">#include "llvm/Analysis/TargetLibraryInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeline">#include "llvm/Analysis/UniformityAnalysis.h"</td>
    <td class="lineNumber">21</td>
    <td class="codeline">#include "llvm/Analysis/UniformityAnalysis.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeline">#include "llvm/Analysis/ValueTracking.h"</td>
    <td class="lineNumber">22</td>
    <td class="codeline">#include "llvm/Analysis/ValueTracking.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/CodeGen/TargetPassConfig.h"</td>
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/CodeGen/TargetPassConfig.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/IR/Dominators.h"</td>
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/IR/Dominators.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/IR/IRBuilder.h"</td>
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/IR/IRBuilder.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/IR/InstVisitor.h"</td>
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/IR/InstVisitor.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeline">#include "llvm/IR/IntrinsicsAMDGPU.h"</td>
    <td class="lineNumber">27</td>
    <td class="codeline">#include "llvm/IR/IntrinsicsAMDGPU.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeline">#include "llvm/IR/PatternMatch.h"</td>
    <td class="lineNumber">28</td>
    <td class="codeline">#include "llvm/IR/PatternMatch.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeline">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">29</td>
    <td class="codeline">#include "llvm/InitializePasses.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeline">#include "llvm/Pass.h"</td>
    <td class="lineNumber">30</td>
    <td class="codeline">#include "llvm/Pass.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeline">#include "llvm/Support/KnownBits.h"</td>
    <td class="lineNumber">31</td>
    <td class="codeline">#include "llvm/Support/KnownBits.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeline">#include "llvm/Transforms/Utils/IntegerDivision.h"</td>
    <td class="lineNumber">32</td>
    <td class="codeline">#include "llvm/Transforms/Utils/IntegerDivision.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeline">#include "llvm/Transforms/Utils/Local.h"</td>
    <td class="lineNumber">33</td>
    <td class="codeline">#include "llvm/Transforms/Utils/Local.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeline"></td>
    <td class="lineNumber">34</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeline">#define DEBUG_TYPE "amdgpu-codegenprepare"</td>
    <td class="lineNumber">35</td>
    <td class="codeline">#define DEBUG_TYPE "amdgpu-codegenprepare"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeline"></td>
    <td class="lineNumber">36</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeline">using namespace llvm;</td>
    <td class="lineNumber">37</td>
    <td class="codeline">using namespace llvm;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeline">using namespace llvm::PatternMatch;</td>
    <td class="lineNumber">38</td>
    <td class="codeline">using namespace llvm::PatternMatch;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeline"></td>
    <td class="lineNumber">39</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeline">namespace {</td>
    <td class="lineNumber">40</td>
    <td class="codeline">namespace {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeline"></td>
    <td class="lineNumber">41</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeline">static cl::opt<bool> WidenLoads(</td>
    <td class="lineNumber">42</td>
    <td class="codeline">static cl::opt<bool> WidenLoads(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeline">  "amdgpu-codegenprepare-widen-constant-loads",</td>
    <td class="lineNumber">43</td>
    <td class="codeline">  "amdgpu-codegenprepare-widen-constant-loads",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeline">  cl::desc("Widen sub-dword constant address space loads in AMDGPUCodeGenPrepare"),</td>
    <td class="lineNumber">44</td>
    <td class="codeline">  cl::desc("Widen sub-dword constant address space loads in AMDGPUCodeGenPrepare"),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeline">  cl::ReallyHidden,</td>
    <td class="lineNumber">45</td>
    <td class="codeline">  cl::ReallyHidden,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeline">  cl::init(false));</td>
    <td class="lineNumber">46</td>
    <td class="codeline">  cl::init(false));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeline"></td>
    <td class="lineNumber">47</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeline">static cl::opt<bool> Widen16BitOps(</td>
    <td class="lineNumber">48</td>
    <td class="codeline">static cl::opt<bool> Widen16BitOps(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeline">  "amdgpu-codegenprepare-widen-16-bit-ops",</td>
    <td class="lineNumber">49</td>
    <td class="codeline">  "amdgpu-codegenprepare-widen-16-bit-ops",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeline">  cl::desc("Widen uniform 16-bit instructions to 32-bit in AMDGPUCodeGenPrepare"),</td>
    <td class="lineNumber">50</td>
    <td class="codeline">  cl::desc("Widen uniform 16-bit instructions to 32-bit in AMDGPUCodeGenPrepare"),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeline">  cl::ReallyHidden,</td>
    <td class="lineNumber">51</td>
    <td class="codeline">  cl::ReallyHidden,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeline">  cl::init(true));</td>
    <td class="lineNumber">52</td>
    <td class="codeline">  cl::init(true));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeline"></td>
    <td class="lineNumber">53</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeline">static cl::opt<bool></td>
    <td class="lineNumber">54</td>
    <td class="codeline">static cl::opt<bool></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeline">    ScalarizeLargePHIs("amdgpu-codegenprepare-break-large-phis",</td>
    <td class="lineNumber">55</td>
    <td class="codeline">    ScalarizeLargePHIs("amdgpu-codegenprepare-break-large-phis",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeline">                       cl::desc("Break large PHI nodes for DAGISel"),</td>
    <td class="lineNumber">56</td>
    <td class="codeline">                       cl::desc("Break large PHI nodes for DAGISel"),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeline">                       cl::ReallyHidden, cl::init(true));</td>
    <td class="lineNumber">57</td>
    <td class="codeline">                       cl::ReallyHidden, cl::init(true));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeline"></td>
    <td class="lineNumber">58</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeline">static cl::opt<bool></td>
    <td class="lineNumber">59</td>
    <td class="codeline">static cl::opt<bool></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeline">    ForceScalarizeLargePHIs("amdgpu-codegenprepare-force-break-large-phis",</td>
    <td class="lineNumber">60</td>
    <td class="codeline">    ForceScalarizeLargePHIs("amdgpu-codegenprepare-force-break-large-phis",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeline">                            cl::desc("For testing purposes, always break large "</td>
    <td class="lineNumber">61</td>
    <td class="codeline">                            cl::desc("For testing purposes, always break large "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeline">                                     "PHIs even if it isn't profitable."),</td>
    <td class="lineNumber">62</td>
    <td class="codeline">                                     "PHIs even if it isn't profitable."),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeline">                            cl::ReallyHidden, cl::init(false));</td>
    <td class="lineNumber">63</td>
    <td class="codeline">                            cl::ReallyHidden, cl::init(false));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeline"></td>
    <td class="lineNumber">64</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeline">static cl::opt<unsigned> ScalarizeLargePHIsThreshold(</td>
    <td class="lineNumber">65</td>
    <td class="codeline">static cl::opt<unsigned> ScalarizeLargePHIsThreshold(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeline">    "amdgpu-codegenprepare-break-large-phis-threshold",</td>
    <td class="lineNumber">66</td>
    <td class="codeline">    "amdgpu-codegenprepare-break-large-phis-threshold",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeline">    cl::desc("Minimum type size in bits for breaking large PHI nodes"),</td>
    <td class="lineNumber">67</td>
    <td class="codeline">    cl::desc("Minimum type size in bits for breaking large PHI nodes"),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeline">    cl::ReallyHidden, cl::init(32));</td>
    <td class="lineNumber">68</td>
    <td class="codeline">    cl::ReallyHidden, cl::init(32));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeline"></td>
    <td class="lineNumber">69</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeline">static cl::opt<bool> UseMul24Intrin(</td>
    <td class="lineNumber">70</td>
    <td class="codeline">static cl::opt<bool> UseMul24Intrin(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeline">  "amdgpu-codegenprepare-mul24",</td>
    <td class="lineNumber">71</td>
    <td class="codeline">  "amdgpu-codegenprepare-mul24",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeline">  cl::desc("Introduce mul24 intrinsics in AMDGPUCodeGenPrepare"),</td>
    <td class="lineNumber">72</td>
    <td class="codeline">  cl::desc("Introduce mul24 intrinsics in AMDGPUCodeGenPrepare"),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeline">  cl::ReallyHidden,</td>
    <td class="lineNumber">73</td>
    <td class="codeline">  cl::ReallyHidden,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeline">  cl::init(true));</td>
    <td class="lineNumber">74</td>
    <td class="codeline">  cl::init(true));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeline"></td>
    <td class="lineNumber">75</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeline">// Legalize 64-bit division by using the generic IR expansion.</td>
    <td class="lineNumber">76</td>
    <td class="codeline">// Legalize 64-bit division by using the generic IR expansion.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeline">static cl::opt<bool> ExpandDiv64InIR(</td>
    <td class="lineNumber">77</td>
    <td class="codeline">static cl::opt<bool> ExpandDiv64InIR(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeline">  "amdgpu-codegenprepare-expand-div64",</td>
    <td class="lineNumber">78</td>
    <td class="codeline">  "amdgpu-codegenprepare-expand-div64",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeline">  cl::desc("Expand 64-bit division in AMDGPUCodeGenPrepare"),</td>
    <td class="lineNumber">79</td>
    <td class="codeline">  cl::desc("Expand 64-bit division in AMDGPUCodeGenPrepare"),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeline">  cl::ReallyHidden,</td>
    <td class="lineNumber">80</td>
    <td class="codeline">  cl::ReallyHidden,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeline">  cl::init(false));</td>
    <td class="lineNumber">81</td>
    <td class="codeline">  cl::init(false));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeline"></td>
    <td class="lineNumber">82</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeline">// Leave all division operations as they are. This supersedes ExpandDiv64InIR</td>
    <td class="lineNumber">83</td>
    <td class="codeline">// Leave all division operations as they are. This supersedes ExpandDiv64InIR</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeline">// and is used for testing the legalizer.</td>
    <td class="lineNumber">84</td>
    <td class="codeline">// and is used for testing the legalizer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeline">static cl::opt<bool> DisableIDivExpand(</td>
    <td class="lineNumber">85</td>
    <td class="codeline">static cl::opt<bool> DisableIDivExpand(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeline">  "amdgpu-codegenprepare-disable-idiv-expansion",</td>
    <td class="lineNumber">86</td>
    <td class="codeline">  "amdgpu-codegenprepare-disable-idiv-expansion",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeline">  cl::desc("Prevent expanding integer division in AMDGPUCodeGenPrepare"),</td>
    <td class="lineNumber">87</td>
    <td class="codeline">  cl::desc("Prevent expanding integer division in AMDGPUCodeGenPrepare"),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeline">  cl::ReallyHidden,</td>
    <td class="lineNumber">88</td>
    <td class="codeline">  cl::ReallyHidden,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeline">  cl::init(false));</td>
    <td class="lineNumber">89</td>
    <td class="codeline">  cl::init(false));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeline"></td>
    <td class="lineNumber">90</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeline">// Disable processing of fdiv so we can better test the backend implementations.</td>
    <td class="lineNumber">91</td>
    <td class="codeline">// Disable processing of fdiv so we can better test the backend implementations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeline">static cl::opt<bool> DisableFDivExpand(</td>
    <td class="lineNumber">92</td>
    <td class="codeline">static cl::opt<bool> DisableFDivExpand(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeline">  "amdgpu-codegenprepare-disable-fdiv-expansion",</td>
    <td class="lineNumber">93</td>
    <td class="codeline">  "amdgpu-codegenprepare-disable-fdiv-expansion",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeline">  cl::desc("Prevent expanding floating point division in AMDGPUCodeGenPrepare"),</td>
    <td class="lineNumber">94</td>
    <td class="codeline">  cl::desc("Prevent expanding floating point division in AMDGPUCodeGenPrepare"),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeline">  cl::ReallyHidden,</td>
    <td class="lineNumber">95</td>
    <td class="codeline">  cl::ReallyHidden,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeline">  cl::init(false));</td>
    <td class="lineNumber">96</td>
    <td class="codeline">  cl::init(false));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeline"></td>
    <td class="lineNumber">97</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeline">class AMDGPUCodeGenPrepareImpl</td>
    <td class="lineNumber">98</td>
    <td class="codeline">class AMDGPUCodeGenPrepareImpl</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeline">    : public InstVisitor<AMDGPUCodeGenPrepareImpl, bool> {</td>
    <td class="lineNumber">99</td>
    <td class="codeline">    : public InstVisitor<AMDGPUCodeGenPrepareImpl, bool> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">100</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeline">  const GCNSubtarget *ST = nullptr;</td>
    <td class="lineNumber">101</td>
    <td class="codeline">  const GCNSubtarget *ST = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeline">  const TargetLibraryInfo *TLInfo = nullptr;</td>
    <td class="lineNumber">102</td>
    <td class="codeline">  const TargetLibraryInfo *TLInfo = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeline">  AssumptionCache *AC = nullptr;</td>
    <td class="lineNumber">103</td>
    <td class="codeline">  AssumptionCache *AC = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeline">  DominatorTree *DT = nullptr;</td>
    <td class="lineNumber">104</td>
    <td class="codeline">  DominatorTree *DT = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeline">  UniformityInfo *UA = nullptr;</td>
    <td class="lineNumber">105</td>
    <td class="codeline">  UniformityInfo *UA = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeline">  Module *Mod = nullptr;</td>
    <td class="lineNumber">106</td>
    <td class="codeline">  Module *Mod = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeline">  const DataLayout *DL = nullptr;</td>
    <td class="lineNumber">107</td>
    <td class="codeline">  const DataLayout *DL = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeline">  bool HasUnsafeFPMath = false;</td>
    <td class="lineNumber">108</td>
    <td class="codeline">  bool HasUnsafeFPMath = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeline">  bool HasFP32DenormalFlush = false;</td>
    <td class="lineNumber">109</td>
    <td class="codeline">  bool HasFP32DenormalFlush = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeline">  bool FlowChanged = false;</td>
    <td class="lineNumber">110</td>
    <td class="codeline">  bool FlowChanged = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeline"></td>
    <td class="lineNumber">111</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeline">  DenseMap<const PHINode *, bool> BreakPhiNodesCache;</td>
    <td class="lineNumber">112</td>
    <td class="codeline">  DenseMap<const PHINode *, bool> BreakPhiNodesCache;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeline"></td>
    <td class="lineNumber">113</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeline">  bool canBreakPHINode(const PHINode &I);</td>
    <td class="lineNumber">114</td>
    <td class="codeline">  bool canBreakPHINode(const PHINode &I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeline"></td>
    <td class="lineNumber">115</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeline">  /// Copies exact/nsw/nuw flags (if any) from binary operation \p I to</td>
    <td class="lineNumber">116</td>
    <td class="codeline">  /// Copies exact/nsw/nuw flags (if any) from binary operation \p I to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeline">  /// binary operation \p V.</td>
    <td class="lineNumber">117</td>
    <td class="codeline">  /// binary operation \p V.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">118</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeline">  /// \returns Binary operation \p V.</td>
    <td class="lineNumber">119</td>
    <td class="codeline">  /// \returns Binary operation \p V.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeline">  /// \returns \p T's base element bit width.</td>
    <td class="lineNumber">120</td>
    <td class="codeline">  /// \returns \p T's base element bit width.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeline">  unsigned getBaseElementBitWidth(const Type *T) const;</td>
    <td class="lineNumber">121</td>
    <td class="codeline">  unsigned getBaseElementBitWidth(const Type *T) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeline"></td>
    <td class="lineNumber">122</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeline">  /// \returns Equivalent 32 bit integer type for given type \p T. For example,</td>
    <td class="lineNumber">123</td>
    <td class="codeline">  /// \returns Equivalent 32 bit integer type for given type \p T. For example,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeline">  /// if \p T is i7, then i32 is returned; if \p T is <3 x i12>, then <3 x i32></td>
    <td class="lineNumber">124</td>
    <td class="codeline">  /// if \p T is i7, then i32 is returned; if \p T is <3 x i12>, then <3 x i32></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeline">  /// is returned.</td>
    <td class="lineNumber">125</td>
    <td class="codeline">  /// is returned.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeline">  Type *getI32Ty(IRBuilder<> &B, const Type *T) const;</td>
    <td class="lineNumber">126</td>
    <td class="codeline">  Type *getI32Ty(IRBuilder<> &B, const Type *T) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeline"></td>
    <td class="lineNumber">127</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeline">  /// \returns True if binary operation \p I is a signed binary operation, false</td>
    <td class="lineNumber">128</td>
    <td class="codeline">  /// \returns True if binary operation \p I is a signed binary operation, false</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeline">  /// otherwise.</td>
    <td class="lineNumber">129</td>
    <td class="codeline">  /// otherwise.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeline">  bool isSigned(const BinaryOperator &I) const;</td>
    <td class="lineNumber">130</td>
    <td class="codeline">  bool isSigned(const BinaryOperator &I) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeline"></td>
    <td class="lineNumber">131</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeline">  /// \returns True if the condition of 'select' operation \p I comes from a</td>
    <td class="lineNumber">132</td>
    <td class="codeline">  /// \returns True if the condition of 'select' operation \p I comes from a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeline">  /// signed 'icmp' operation, false otherwise.</td>
    <td class="lineNumber">133</td>
    <td class="codeline">  /// signed 'icmp' operation, false otherwise.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeline">  bool isSigned(const SelectInst &I) const;</td>
    <td class="lineNumber">134</td>
    <td class="codeline">  bool isSigned(const SelectInst &I) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeline"></td>
    <td class="lineNumber">135</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeline">  /// \returns True if type \p T needs to be promoted to 32 bit integer type,</td>
    <td class="lineNumber">136</td>
    <td class="codeline">  /// \returns True if type \p T needs to be promoted to 32 bit integer type,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeline">  /// false otherwise.</td>
    <td class="lineNumber">137</td>
    <td class="codeline">  /// false otherwise.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeline">  bool needsPromotionToI32(const Type *T) const;</td>
    <td class="lineNumber">138</td>
    <td class="codeline">  bool needsPromotionToI32(const Type *T) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeline"></td>
    <td class="lineNumber">139</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeline">  /// Return true if \p T is a legal scalar floating point type.</td>
    <td class="lineNumber">140</td>
    <td class="codeline">  /// Return true if \p T is a legal scalar floating point type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeline">  bool isLegalFloatingTy(const Type *T) const;</td>
    <td class="lineNumber">141</td>
    <td class="codeline">  bool isLegalFloatingTy(const Type *T) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeline"></td>
    <td class="lineNumber">142</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeline">  /// Wrapper to pass all the arguments to computeKnownFPClass</td>
    <td class="lineNumber">143</td>
    <td class="codeline">  /// Wrapper to pass all the arguments to computeKnownFPClass</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeline">  KnownFPClass computeKnownFPClass(const Value *V, FPClassTest Interested,</td>
    <td class="lineNumber">144</td>
    <td class="codeline">  KnownFPClass computeKnownFPClass(const Value *V, FPClassTest Interested,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeline">                                   const Instruction *CtxI) const {</td>
    <td class="lineNumber">145</td>
    <td class="codeline">                                   const Instruction *CtxI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeline">    return llvm::computeKnownFPClass(V, *DL, Interested, 0, TLInfo, AC, CtxI,</td>
    <td class="lineNumber">146</td>
    <td class="codeline">    return llvm::computeKnownFPClass(V, *DL, Interested, 0, TLInfo, AC, CtxI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeline">                                     DT);</td>
    <td class="lineNumber">147</td>
    <td class="codeline">                                     DT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">148</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeline"></td>
    <td class="lineNumber">149</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeline">  bool canIgnoreDenormalInput(const Value *V, const Instruction *CtxI) const {</td>
    <td class="lineNumber">150</td>
    <td class="codeline">  bool canIgnoreDenormalInput(const Value *V, const Instruction *CtxI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeline">    return HasFP32DenormalFlush ||</td>
    <td class="lineNumber">151</td>
    <td class="codeline">    return HasFP32DenormalFlush ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeline">           computeKnownFPClass(V, fcSubnormal, CtxI).isKnownNeverSubnormal();</td>
    <td class="lineNumber">152</td>
    <td class="codeline">           computeKnownFPClass(V, fcSubnormal, CtxI).isKnownNeverSubnormal();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">153</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeline"></td>
    <td class="lineNumber">154</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeline">  /// Promotes uniform binary operation \p I to equivalent 32 bit binary</td>
    <td class="lineNumber">155</td>
    <td class="codeline">  /// Promotes uniform binary operation \p I to equivalent 32 bit binary</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeline">  /// operation.</td>
    <td class="lineNumber">156</td>
    <td class="codeline">  /// operation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">157</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeline">  /// \details \p I's base element bit width must be greater than 1 and less</td>
    <td class="lineNumber">158</td>
    <td class="codeline">  /// \details \p I's base element bit width must be greater than 1 and less</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeline">  /// than or equal 16. Promotion is done by sign or zero extending operands to</td>
    <td class="lineNumber">159</td>
    <td class="codeline">  /// than or equal 16. Promotion is done by sign or zero extending operands to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeline">  /// 32 bits, replacing \p I with equivalent 32 bit binary operation, and</td>
    <td class="lineNumber">160</td>
    <td class="codeline">  /// 32 bits, replacing \p I with equivalent 32 bit binary operation, and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeline">  /// truncating the result of 32 bit binary operation back to \p I's original</td>
    <td class="lineNumber">161</td>
    <td class="codeline">  /// truncating the result of 32 bit binary operation back to \p I's original</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeline">  /// type. Division operation is not promoted.</td>
    <td class="lineNumber">162</td>
    <td class="codeline">  /// type. Division operation is not promoted.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">163</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeline">  /// \returns True if \p I is promoted to equivalent 32 bit binary operation,</td>
    <td class="lineNumber">164</td>
    <td class="codeline">  /// \returns True if \p I is promoted to equivalent 32 bit binary operation,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeline">  /// false otherwise.</td>
    <td class="lineNumber">165</td>
    <td class="codeline">  /// false otherwise.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeline">  bool promoteUniformOpToI32(BinaryOperator &I) const;</td>
    <td class="lineNumber">166</td>
    <td class="codeline">  bool promoteUniformOpToI32(BinaryOperator &I) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeline"></td>
    <td class="lineNumber">167</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeline">  /// Promotes uniform 'icmp' operation \p I to 32 bit 'icmp' operation.</td>
    <td class="lineNumber">168</td>
    <td class="codeline">  /// Promotes uniform 'icmp' operation \p I to 32 bit 'icmp' operation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">169</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeline">  /// \details \p I's base element bit width must be greater than 1 and less</td>
    <td class="lineNumber">170</td>
    <td class="codeline">  /// \details \p I's base element bit width must be greater than 1 and less</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeline">  /// than or equal 16. Promotion is done by sign or zero extending operands to</td>
    <td class="lineNumber">171</td>
    <td class="codeline">  /// than or equal 16. Promotion is done by sign or zero extending operands to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeline">  /// 32 bits, and replacing \p I with 32 bit 'icmp' operation.</td>
    <td class="lineNumber">172</td>
    <td class="codeline">  /// 32 bits, and replacing \p I with 32 bit 'icmp' operation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">173</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeline">  /// \returns True.</td>
    <td class="lineNumber">174</td>
    <td class="codeline">  /// \returns True.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeline">  bool promoteUniformOpToI32(ICmpInst &I) const;</td>
    <td class="lineNumber">175</td>
    <td class="codeline">  bool promoteUniformOpToI32(ICmpInst &I) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeline"></td>
    <td class="lineNumber">176</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeline">  /// Promotes uniform 'select' operation \p I to 32 bit 'select'</td>
    <td class="lineNumber">177</td>
    <td class="codeline">  /// Promotes uniform 'select' operation \p I to 32 bit 'select'</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeline">  /// operation.</td>
    <td class="lineNumber">178</td>
    <td class="codeline">  /// operation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">179</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeline">  /// \details \p I's base element bit width must be greater than 1 and less</td>
    <td class="lineNumber">180</td>
    <td class="codeline">  /// \details \p I's base element bit width must be greater than 1 and less</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeline">  /// than or equal 16. Promotion is done by sign or zero extending operands to</td>
    <td class="lineNumber">181</td>
    <td class="codeline">  /// than or equal 16. Promotion is done by sign or zero extending operands to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeline">  /// 32 bits, replacing \p I with 32 bit 'select' operation, and truncating the</td>
    <td class="lineNumber">182</td>
    <td class="codeline">  /// 32 bits, replacing \p I with 32 bit 'select' operation, and truncating the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeline">  /// result of 32 bit 'select' operation back to \p I's original type.</td>
    <td class="lineNumber">183</td>
    <td class="codeline">  /// result of 32 bit 'select' operation back to \p I's original type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">184</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeline">  /// \returns True.</td>
    <td class="lineNumber">185</td>
    <td class="codeline">  /// \returns True.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeline">  bool promoteUniformOpToI32(SelectInst &I) const;</td>
    <td class="lineNumber">186</td>
    <td class="codeline">  bool promoteUniformOpToI32(SelectInst &I) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeline"></td>
    <td class="lineNumber">187</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeline">  /// Promotes uniform 'bitreverse' intrinsic \p I to 32 bit 'bitreverse'</td>
    <td class="lineNumber">188</td>
    <td class="codeline">  /// Promotes uniform 'bitreverse' intrinsic \p I to 32 bit 'bitreverse'</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeline">  /// intrinsic.</td>
    <td class="lineNumber">189</td>
    <td class="codeline">  /// intrinsic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">190</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeline">  /// \details \p I's base element bit width must be greater than 1 and less</td>
    <td class="lineNumber">191</td>
    <td class="codeline">  /// \details \p I's base element bit width must be greater than 1 and less</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeline">  /// than or equal 16. Promotion is done by zero extending the operand to 32</td>
    <td class="lineNumber">192</td>
    <td class="codeline">  /// than or equal 16. Promotion is done by zero extending the operand to 32</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeline">  /// bits, replacing \p I with 32 bit 'bitreverse' intrinsic, shifting the</td>
    <td class="lineNumber">193</td>
    <td class="codeline">  /// bits, replacing \p I with 32 bit 'bitreverse' intrinsic, shifting the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeline">  /// result of 32 bit 'bitreverse' intrinsic to the right with zero fill (the</td>
    <td class="lineNumber">194</td>
    <td class="codeline">  /// result of 32 bit 'bitreverse' intrinsic to the right with zero fill (the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeline">  /// shift amount is 32 minus \p I's base element bit width), and truncating</td>
    <td class="lineNumber">195</td>
    <td class="codeline">  /// shift amount is 32 minus \p I's base element bit width), and truncating</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeline">  /// the result of the shift operation back to \p I's original type.</td>
    <td class="lineNumber">196</td>
    <td class="codeline">  /// the result of the shift operation back to \p I's original type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">197</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeline">  /// \returns True.</td>
    <td class="lineNumber">198</td>
    <td class="codeline">  /// \returns True.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeline">  bool promoteUniformBitreverseToI32(IntrinsicInst &I) const;</td>
    <td class="lineNumber">199</td>
    <td class="codeline">  bool promoteUniformBitreverseToI32(IntrinsicInst &I) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeline"></td>
    <td class="lineNumber">200</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeline">  /// \returns The minimum number of bits needed to store the value of \Op as an</td>
    <td class="lineNumber">201</td>
    <td class="codeline">  /// \returns The minimum number of bits needed to store the value of \Op as an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeline">  /// unsigned integer. Truncating to this size and then zero-extending to</td>
    <td class="lineNumber">202</td>
    <td class="codeline">  /// unsigned integer. Truncating to this size and then zero-extending to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeline">  /// the original will not change the value.</td>
    <td class="lineNumber">203</td>
    <td class="codeline">  /// the original will not change the value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeline">  unsigned numBitsUnsigned(Value *Op) const;</td>
    <td class="lineNumber">204</td>
    <td class="codeline">  unsigned numBitsUnsigned(Value *Op) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeline"></td>
    <td class="lineNumber">205</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeline">  /// \returns The minimum number of bits needed to store the value of \Op as a</td>
    <td class="lineNumber">206</td>
    <td class="codeline">  /// \returns The minimum number of bits needed to store the value of \Op as a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeline">  /// signed integer. Truncating to this size and then sign-extending to</td>
    <td class="lineNumber">207</td>
    <td class="codeline">  /// signed integer. Truncating to this size and then sign-extending to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeline">  /// the original size will not change the value.</td>
    <td class="lineNumber">208</td>
    <td class="codeline">  /// the original size will not change the value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeline">  unsigned numBitsSigned(Value *Op) const;</td>
    <td class="lineNumber">209</td>
    <td class="codeline">  unsigned numBitsSigned(Value *Op) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeline"></td>
    <td class="lineNumber">210</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeline">  /// Replace mul instructions with llvm.amdgcn.mul.u24 or llvm.amdgcn.mul.s24.</td>
    <td class="lineNumber">211</td>
    <td class="codeline">  /// Replace mul instructions with llvm.amdgcn.mul.u24 or llvm.amdgcn.mul.s24.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeline">  /// SelectionDAG has an issue where an and asserting the bits are known</td>
    <td class="lineNumber">212</td>
    <td class="codeline">  /// SelectionDAG has an issue where an and asserting the bits are known</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeline">  bool replaceMulWithMul24(BinaryOperator &I) const;</td>
    <td class="lineNumber">213</td>
    <td class="codeline">  bool replaceMulWithMul24(BinaryOperator &I) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeline"></td>
    <td class="lineNumber">214</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeline">  /// Perform same function as equivalently named function in DAGCombiner. Since</td>
    <td class="lineNumber">215</td>
    <td class="codeline">  /// Perform same function as equivalently named function in DAGCombiner. Since</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeline">  /// we expand some divisions here, we need to perform this before obscuring.</td>
    <td class="lineNumber">216</td>
    <td class="codeline">  /// we expand some divisions here, we need to perform this before obscuring.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeline">  bool foldBinOpIntoSelect(BinaryOperator &I) const;</td>
    <td class="lineNumber">217</td>
    <td class="codeline">  bool foldBinOpIntoSelect(BinaryOperator &I) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeline"></td>
    <td class="lineNumber">218</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeline">  bool divHasSpecialOptimization(BinaryOperator &I,</td>
    <td class="lineNumber">219</td>
    <td class="codeline">  bool divHasSpecialOptimization(BinaryOperator &I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeline">                                 Value *Num, Value *Den) const;</td>
    <td class="lineNumber">220</td>
    <td class="codeline">                                 Value *Num, Value *Den) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeline">  int getDivNumBits(BinaryOperator &I,</td>
    <td class="lineNumber">221</td>
    <td class="codeline">  int getDivNumBits(BinaryOperator &I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeline">                    Value *Num, Value *Den,</td>
    <td class="lineNumber">222</td>
    <td class="codeline">                    Value *Num, Value *Den,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeline">                    unsigned AtLeast, bool Signed) const;</td>
    <td class="lineNumber">223</td>
    <td class="codeline">                    unsigned AtLeast, bool Signed) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeline"></td>
    <td class="lineNumber">224</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeline">  /// Expands 24 bit div or rem.</td>
    <td class="lineNumber">225</td>
    <td class="codeline">  /// Expands 24 bit div or rem.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeline">  Value* expandDivRem24(IRBuilder<> &Builder, BinaryOperator &I,</td>
    <td class="lineNumber">226</td>
    <td class="codeline">  Value* expandDivRem24(IRBuilder<> &Builder, BinaryOperator &I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeline">                        Value *Num, Value *Den,</td>
    <td class="lineNumber">227</td>
    <td class="codeline">                        Value *Num, Value *Den,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeline">                        bool IsDiv, bool IsSigned) const;</td>
    <td class="lineNumber">228</td>
    <td class="codeline">                        bool IsDiv, bool IsSigned) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeline"></td>
    <td class="lineNumber">229</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeline">  Value *expandDivRem24Impl(IRBuilder<> &Builder, BinaryOperator &I,</td>
    <td class="lineNumber">230</td>
    <td class="codeline">  Value *expandDivRem24Impl(IRBuilder<> &Builder, BinaryOperator &I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeline">                            Value *Num, Value *Den, unsigned NumBits,</td>
    <td class="lineNumber">231</td>
    <td class="codeline">                            Value *Num, Value *Den, unsigned NumBits,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeline">                            bool IsDiv, bool IsSigned) const;</td>
    <td class="lineNumber">232</td>
    <td class="codeline">                            bool IsDiv, bool IsSigned) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeline"></td>
    <td class="lineNumber">233</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeline">  /// Expands 32 bit div or rem.</td>
    <td class="lineNumber">234</td>
    <td class="codeline">  /// Expands 32 bit div or rem.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeline">  Value* expandDivRem32(IRBuilder<> &Builder, BinaryOperator &I,</td>
    <td class="lineNumber">235</td>
    <td class="codeline">  Value* expandDivRem32(IRBuilder<> &Builder, BinaryOperator &I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeline">                        Value *Num, Value *Den) const;</td>
    <td class="lineNumber">236</td>
    <td class="codeline">                        Value *Num, Value *Den) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeline"></td>
    <td class="lineNumber">237</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeline">  Value *shrinkDivRem64(IRBuilder<> &Builder, BinaryOperator &I,</td>
    <td class="lineNumber">238</td>
    <td class="codeline">  Value *shrinkDivRem64(IRBuilder<> &Builder, BinaryOperator &I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeline">                        Value *Num, Value *Den) const;</td>
    <td class="lineNumber">239</td>
    <td class="codeline">                        Value *Num, Value *Den) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeline">  void expandDivRem64(BinaryOperator &I) const;</td>
    <td class="lineNumber">240</td>
    <td class="codeline">  void expandDivRem64(BinaryOperator &I) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeline"></td>
    <td class="lineNumber">241</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeline">  /// Widen a scalar load.</td>
    <td class="lineNumber">242</td>
    <td class="codeline">  /// Widen a scalar load.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">243</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeline">  /// \details \p Widen scalar load for uniform, small type loads from constant</td>
    <td class="lineNumber">244</td>
    <td class="codeline">  /// \details \p Widen scalar load for uniform, small type loads from constant</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeline">  //  memory / to a full 32-bits and then truncate the input to allow a scalar</td>
    <td class="lineNumber">245</td>
    <td class="codeline">  //  memory / to a full 32-bits and then truncate the input to allow a scalar</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeline">  //  load instead of a vector load.</td>
    <td class="lineNumber">246</td>
    <td class="codeline">  //  load instead of a vector load.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">247</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeline">  /// \returns True.</td>
    <td class="lineNumber">248</td>
    <td class="codeline">  /// \returns True.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeline"></td>
    <td class="lineNumber">249</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeline">  bool canWidenScalarExtLoad(LoadInst &I) const;</td>
    <td class="lineNumber">250</td>
    <td class="codeline">  bool canWidenScalarExtLoad(LoadInst &I) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeline"></td>
    <td class="lineNumber">251</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeline">  Value *matchFractPat(IntrinsicInst &I);</td>
    <td class="lineNumber">252</td>
    <td class="codeline">  Value *matchFractPat(IntrinsicInst &I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeline">  Value *applyFractPat(IRBuilder<> &Builder, Value *FractArg);</td>
    <td class="lineNumber">253</td>
    <td class="codeline">  Value *applyFractPat(IRBuilder<> &Builder, Value *FractArg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeline"></td>
    <td class="lineNumber">254</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeline">  bool canOptimizeWithRsq(const FPMathOperator *SqrtOp, FastMathFlags DivFMF,</td>
    <td class="lineNumber">255</td>
    <td class="codeline">  bool canOptimizeWithRsq(const FPMathOperator *SqrtOp, FastMathFlags DivFMF,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeline">                          FastMathFlags SqrtFMF) const;</td>
    <td class="lineNumber">256</td>
    <td class="codeline">                          FastMathFlags SqrtFMF) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeline"></td>
    <td class="lineNumber">257</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeline">  Value *optimizeWithRsq(IRBuilder<> &Builder, Value *Num, Value *Den,</td>
    <td class="lineNumber">258</td>
    <td class="codeline">  Value *optimizeWithRsq(IRBuilder<> &Builder, Value *Num, Value *Den,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeline">                         FastMathFlags DivFMF, FastMathFlags SqrtFMF,</td>
    <td class="lineNumber">259</td>
    <td class="codeline">                         FastMathFlags DivFMF, FastMathFlags SqrtFMF,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeline">                         const Instruction *CtxI) const;</td>
    <td class="lineNumber">260</td>
    <td class="codeline">                         const Instruction *CtxI) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeline"></td>
    <td class="lineNumber">261</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeline">  Value *optimizeWithRcp(IRBuilder<> &Builder, Value *Num, Value *Den,</td>
    <td class="lineNumber">262</td>
    <td class="codeline">  Value *optimizeWithRcp(IRBuilder<> &Builder, Value *Num, Value *Den,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeline">                         FastMathFlags FMF, const Instruction *CtxI) const;</td>
    <td class="lineNumber">263</td>
    <td class="codeline">                         FastMathFlags FMF, const Instruction *CtxI) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeline">  Value *optimizeWithFDivFast(IRBuilder<> &Builder, Value *Num, Value *Den,</td>
    <td class="lineNumber">264</td>
    <td class="codeline">  Value *optimizeWithFDivFast(IRBuilder<> &Builder, Value *Num, Value *Den,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeline">                              float ReqdAccuracy) const;</td>
    <td class="lineNumber">265</td>
    <td class="codeline">                              float ReqdAccuracy) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeline"></td>
    <td class="lineNumber">266</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeline">  Value *visitFDivElement(IRBuilder<> &Builder, Value *Num, Value *Den,</td>
    <td class="lineNumber">267</td>
    <td class="codeline">  Value *visitFDivElement(IRBuilder<> &Builder, Value *Num, Value *Den,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeline">                          FastMathFlags DivFMF, FastMathFlags SqrtFMF,</td>
    <td class="lineNumber">268</td>
    <td class="codeline">                          FastMathFlags DivFMF, FastMathFlags SqrtFMF,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeline">                          Value *RsqOp, const Instruction *FDiv,</td>
    <td class="lineNumber">269</td>
    <td class="codeline">                          Value *RsqOp, const Instruction *FDiv,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeline">                          float ReqdAccuracy) const;</td>
    <td class="lineNumber">270</td>
    <td class="codeline">                          float ReqdAccuracy) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeline"></td>
    <td class="lineNumber">271</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeline">  std::pair<Value *, Value *> getFrexpResults(IRBuilder<> &Builder,</td>
    <td class="lineNumber">272</td>
    <td class="codeline">  std::pair<Value *, Value *> getFrexpResults(IRBuilder<> &Builder,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeline">                                              Value *Src) const;</td>
    <td class="lineNumber">273</td>
    <td class="codeline">                                              Value *Src) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeline"></td>
    <td class="lineNumber">274</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeline">  Value *emitRcpIEEE1ULP(IRBuilder<> &Builder, Value *Src,</td>
    <td class="lineNumber">275</td>
    <td class="codeline">  Value *emitRcpIEEE1ULP(IRBuilder<> &Builder, Value *Src,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeline">                         bool IsNegative) const;</td>
    <td class="lineNumber">276</td>
    <td class="codeline">                         bool IsNegative) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeline">  Value *emitFrexpDiv(IRBuilder<> &Builder, Value *LHS, Value *RHS,</td>
    <td class="lineNumber">277</td>
    <td class="codeline">  Value *emitFrexpDiv(IRBuilder<> &Builder, Value *LHS, Value *RHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeline">                      FastMathFlags FMF) const;</td>
    <td class="lineNumber">278</td>
    <td class="codeline">                      FastMathFlags FMF) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeline"></td>
    <td class="lineNumber">279</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">280</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeline">  bool visitFDiv(BinaryOperator &I);</td>
    <td class="lineNumber">281</td>
    <td class="codeline">  bool visitFDiv(BinaryOperator &I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeline"></td>
    <td class="lineNumber">282</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeline">  bool visitInstruction(Instruction &I) { return false; }</td>
    <td class="lineNumber">283</td>
    <td class="codeline">  bool visitInstruction(Instruction &I) { return false; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeline">  bool visitBinaryOperator(BinaryOperator &I);</td>
    <td class="lineNumber">284</td>
    <td class="codeline">  bool visitBinaryOperator(BinaryOperator &I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeline">  bool visitLoadInst(LoadInst &I);</td>
    <td class="lineNumber">285</td>
    <td class="codeline">  bool visitLoadInst(LoadInst &I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeline">  bool visitICmpInst(ICmpInst &I);</td>
    <td class="lineNumber">286</td>
    <td class="codeline">  bool visitICmpInst(ICmpInst &I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeline">  bool visitSelectInst(SelectInst &I);</td>
    <td class="lineNumber">287</td>
    <td class="codeline">  bool visitSelectInst(SelectInst &I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeline">  bool visitPHINode(PHINode &I);</td>
    <td class="lineNumber">288</td>
    <td class="codeline">  bool visitPHINode(PHINode &I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeline"></td>
    <td class="lineNumber">289</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeline">  bool visitIntrinsicInst(IntrinsicInst &I);</td>
    <td class="lineNumber">290</td>
    <td class="codeline">  bool visitIntrinsicInst(IntrinsicInst &I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeline">  bool visitBitreverseIntrinsicInst(IntrinsicInst &I);</td>
    <td class="lineNumber">291</td>
    <td class="codeline">  bool visitBitreverseIntrinsicInst(IntrinsicInst &I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeline">  bool visitMinNum(IntrinsicInst &I);</td>
    <td class="lineNumber">292</td>
    <td class="codeline">  bool visitMinNum(IntrinsicInst &I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeline">  bool run(Function &F);</td>
    <td class="lineNumber">293</td>
    <td class="codeline">  bool run(Function &F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeline">};</td>
    <td class="lineNumber">294</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeline"></td>
    <td class="lineNumber">295</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeline">class AMDGPUCodeGenPrepare : public FunctionPass {</td>
    <td class="lineNumber">296</td>
    <td class="codeline">class AMDGPUCodeGenPrepare : public FunctionPass {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">297</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeline">  AMDGPUCodeGenPrepareImpl Impl;</td>
    <td class="lineNumber">298</td>
    <td class="codeline">  AMDGPUCodeGenPrepareImpl Impl;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeline"></td>
    <td class="lineNumber">299</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">300</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeline">  static char ID;</td>
    <td class="lineNumber">301</td>
    <td class="codeline">  static char ID;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeline">  AMDGPUCodeGenPrepare() : FunctionPass(ID) {</td>
    <td class="lineNumber">302</td>
    <td class="codeline">  AMDGPUCodeGenPrepare() : FunctionPass(ID) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeline">    initializeAMDGPUCodeGenPreparePass(*PassRegistry::getPassRegistry());</td>
    <td class="lineNumber">303</td>
    <td class="codeline">    initializeAMDGPUCodeGenPreparePass(*PassRegistry::getPassRegistry());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">304</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeline">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td class="lineNumber">305</td>
    <td class="codeline">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeline">    AU.addRequired<AssumptionCacheTracker>();</td>
    <td class="lineNumber">306</td>
    <td class="codeline">    AU.addRequired<AssumptionCacheTracker>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeline">    AU.addRequired<UniformityInfoWrapperPass>();</td>
    <td class="lineNumber">307</td>
    <td class="codeline">    AU.addRequired<UniformityInfoWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeline">    AU.addRequired<TargetLibraryInfoWrapperPass>();</td>
    <td class="lineNumber">308</td>
    <td class="codeline">    AU.addRequired<TargetLibraryInfoWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeline"></td>
    <td class="lineNumber">309</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeline">    // FIXME: Division expansion needs to preserve the dominator tree.</td>
    <td class="lineNumber">310</td>
    <td class="codeline">    // FIXME: Division expansion needs to preserve the dominator tree.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeline">    if (!ExpandDiv64InIR)</td>
    <td class="lineNumber">311</td>
    <td class="codeline">    if (!ExpandDiv64InIR)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeline">      AU.setPreservesAll();</td>
    <td class="lineNumber">312</td>
    <td class="codeline">      AU.setPreservesAll();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">313</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeline">  bool runOnFunction(Function &F) override;</td>
    <td class="lineNumber">314</td>
    <td class="codeline">  bool runOnFunction(Function &F) override;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeline">  bool doInitialization(Module &M) override;</td>
    <td class="lineNumber">315</td>
    <td class="codeline">  bool doInitialization(Module &M) override;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeline">  StringRef getPassName() const override { return "AMDGPU IR optimizations"; }</td>
    <td class="lineNumber">316</td>
    <td class="codeline">  StringRef getPassName() const override { return "AMDGPU IR optimizations"; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeline">};</td>
    <td class="lineNumber">317</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeline"></td>
    <td class="lineNumber">318</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeline">} // end anonymous namespace</td>
    <td class="lineNumber">319</td>
    <td class="codeline">} // end anonymous namespace</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeline"></td>
    <td class="lineNumber">320</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::run(Function &F) {</td>
    <td class="lineNumber">321</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::run(Function &F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeline">  bool MadeChange = false;</td>
    <td class="lineNumber">322</td>
    <td class="codeline">  bool MadeChange = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeline"></td>
    <td class="lineNumber">323</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeline">  Function::iterator NextBB;</td>
    <td class="lineNumber">324</td>
    <td class="codeline">  Function::iterator NextBB;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeline">  for (Function::iterator FI = F.begin(), FE = F.end(); FI != FE; FI = NextBB) {</td>
    <td class="lineNumber">325</td>
    <td class="codeline">  for (Function::iterator FI = F.begin(), FE = F.end(); FI != FE; FI = NextBB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeline">    BasicBlock *BB = &*FI;</td>
    <td class="lineNumber">326</td>
    <td class="codeline">    BasicBlock *BB = &*FI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeline">    NextBB = std::next(FI);</td>
    <td class="lineNumber">327</td>
    <td class="codeline">    NextBB = std::next(FI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeline"></td>
    <td class="lineNumber">328</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeline">    BasicBlock::iterator Next;</td>
    <td class="lineNumber">329</td>
    <td class="codeline">    BasicBlock::iterator Next;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeline">    for (BasicBlock::iterator I = BB->begin(), E = BB->end(); I != E;</td>
    <td class="lineNumber">330</td>
    <td class="codeline">    for (BasicBlock::iterator I = BB->begin(), E = BB->end(); I != E;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeline">         I = Next) {</td>
    <td class="lineNumber">331</td>
    <td class="codeline">         I = Next) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeline">      Next = std::next(I);</td>
    <td class="lineNumber">332</td>
    <td class="codeline">      Next = std::next(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeline"></td>
    <td class="lineNumber">333</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeline">      MadeChange |= visit(*I);</td>
    <td class="lineNumber">334</td>
    <td class="codeline">      MadeChange |= visit(*I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeline"></td>
    <td class="lineNumber">335</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeline">      if (Next != E) { // Control flow changed</td>
    <td class="lineNumber">336</td>
    <td class="codeline">      if (Next != E) { // Control flow changed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeline">        BasicBlock *NextInstBB = Next->getParent();</td>
    <td class="lineNumber">337</td>
    <td class="codeline">        BasicBlock *NextInstBB = Next->getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeline">        if (NextInstBB != BB) {</td>
    <td class="lineNumber">338</td>
    <td class="codeline">        if (NextInstBB != BB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeline">          BB = NextInstBB;</td>
    <td class="lineNumber">339</td>
    <td class="codeline">          BB = NextInstBB;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeline">          E = BB->end();</td>
    <td class="lineNumber">340</td>
    <td class="codeline">          E = BB->end();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeline">          FE = F.end();</td>
    <td class="lineNumber">341</td>
    <td class="codeline">          FE = F.end();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">342</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">343</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">344</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">345</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeline">  return MadeChange;</td>
    <td class="lineNumber">346</td>
    <td class="codeline">  return MadeChange;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeline">}</td>
    <td class="lineNumber">347</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeline"></td>
    <td class="lineNumber">348</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeline">unsigned AMDGPUCodeGenPrepareImpl::getBaseElementBitWidth(const Type *T) const {</td>
    <td class="lineNumber">349</td>
    <td class="codeline">unsigned AMDGPUCodeGenPrepareImpl::getBaseElementBitWidth(const Type *T) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeline">  assert(needsPromotionToI32(T) && "T does not need promotion to i32");</td>
    <td class="lineNumber">350</td>
    <td class="codeline">  assert(needsPromotionToI32(T) && "T does not need promotion to i32");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeline"></td>
    <td class="lineNumber">351</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeline">  if (T->isIntegerTy())</td>
    <td class="lineNumber">352</td>
    <td class="codeline">  if (T->isIntegerTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeline">    return T->getIntegerBitWidth();</td>
    <td class="lineNumber">353</td>
    <td class="codeline">    return T->getIntegerBitWidth();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeline">  return cast<VectorType>(T)->getElementType()->getIntegerBitWidth();</td>
    <td class="lineNumber">354</td>
    <td class="codeline">  return cast<VectorType>(T)->getElementType()->getIntegerBitWidth();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeline">}</td>
    <td class="lineNumber">355</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeline"></td>
    <td class="lineNumber">356</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeline">Type *AMDGPUCodeGenPrepareImpl::getI32Ty(IRBuilder<> &B, const Type *T) const {</td>
    <td class="lineNumber">357</td>
    <td class="codeline">Type *AMDGPUCodeGenPrepareImpl::getI32Ty(IRBuilder<> &B, const Type *T) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeline">  assert(needsPromotionToI32(T) && "T does not need promotion to i32");</td>
    <td class="lineNumber">358</td>
    <td class="codeline">  assert(needsPromotionToI32(T) && "T does not need promotion to i32");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeline"></td>
    <td class="lineNumber">359</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeline">  if (T->isIntegerTy())</td>
    <td class="lineNumber">360</td>
    <td class="codeline">  if (T->isIntegerTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeline">    return B.getInt32Ty();</td>
    <td class="lineNumber">361</td>
    <td class="codeline">    return B.getInt32Ty();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeline">  return FixedVectorType::get(B.getInt32Ty(), cast<FixedVectorType>(T));</td>
    <td class="lineNumber">362</td>
    <td class="codeline">  return FixedVectorType::get(B.getInt32Ty(), cast<FixedVectorType>(T));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeline">}</td>
    <td class="lineNumber">363</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeline"></td>
    <td class="lineNumber">364</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::isSigned(const BinaryOperator &I) const {</td>
    <td class="lineNumber">365</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::isSigned(const BinaryOperator &I) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeline">  return I.getOpcode() == Instruction::AShr ||</td>
    <td class="lineNumber">366</td>
    <td class="codeline">  return I.getOpcode() == Instruction::AShr ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeline">      I.getOpcode() == Instruction::SDiv || I.getOpcode() == Instruction::SRem;</td>
    <td class="lineNumber">367</td>
    <td class="codeline">      I.getOpcode() == Instruction::SDiv || I.getOpcode() == Instruction::SRem;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeline">}</td>
    <td class="lineNumber">368</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeline"></td>
    <td class="lineNumber">369</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::isSigned(const SelectInst &I) const {</td>
    <td class="lineNumber">370</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::isSigned(const SelectInst &I) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeline">  return isa<ICmpInst>(I.getOperand(0)) ?</td>
    <td class="lineNumber">371</td>
    <td class="codeline">  return isa<ICmpInst>(I.getOperand(0)) ?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeline">      cast<ICmpInst>(I.getOperand(0))->isSigned() : false;</td>
    <td class="lineNumber">372</td>
    <td class="codeline">      cast<ICmpInst>(I.getOperand(0))->isSigned() : false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeline">}</td>
    <td class="lineNumber">373</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeline"></td>
    <td class="lineNumber">374</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::needsPromotionToI32(const Type *T) const {</td>
    <td class="lineNumber">375</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::needsPromotionToI32(const Type *T) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeline">  if (!Widen16BitOps)</td>
    <td class="lineNumber">376</td>
    <td class="codeline">  if (!Widen16BitOps)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">377</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeline"></td>
    <td class="lineNumber">378</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeline">  const IntegerType *IntTy = dyn_cast<IntegerType>(T);</td>
    <td class="lineNumber">379</td>
    <td class="codeline">  const IntegerType *IntTy = dyn_cast<IntegerType>(T);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeline">  if (IntTy && IntTy->getBitWidth() > 1 && IntTy->getBitWidth() <= 16)</td>
    <td class="lineNumber">380</td>
    <td class="codeline">  if (IntTy && IntTy->getBitWidth() > 1 && IntTy->getBitWidth() <= 16)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">381</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeline"></td>
    <td class="lineNumber">382</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeline">  if (const VectorType *VT = dyn_cast<VectorType>(T)) {</td>
    <td class="lineNumber">383</td>
    <td class="codeline">  if (const VectorType *VT = dyn_cast<VectorType>(T)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeline">    // TODO: The set of packed operations is more limited, so may want to</td>
    <td class="lineNumber">384</td>
    <td class="codeline">    // TODO: The set of packed operations is more limited, so may want to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeline">    // promote some anyway.</td>
    <td class="lineNumber">385</td>
    <td class="codeline">    // promote some anyway.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeline">    if (ST->hasVOP3PInsts())</td>
    <td class="lineNumber">386</td>
    <td class="codeline">    if (ST->hasVOP3PInsts())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">387</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeline"></td>
    <td class="lineNumber">388</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeline">    return needsPromotionToI32(VT->getElementType());</td>
    <td class="lineNumber">389</td>
    <td class="codeline">    return needsPromotionToI32(VT->getElementType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">390</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeline"></td>
    <td class="lineNumber">391</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">392</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeline">}</td>
    <td class="lineNumber">393</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeline"></td>
    <td class="lineNumber">394</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::isLegalFloatingTy(const Type *Ty) const {</td>
    <td class="lineNumber">395</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::isLegalFloatingTy(const Type *Ty) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeline">  return Ty->isFloatTy() || Ty->isDoubleTy() ||</td>
    <td class="lineNumber">396</td>
    <td class="codeline">  return Ty->isFloatTy() || Ty->isDoubleTy() ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeline">         (Ty->isHalfTy() && ST->has16BitInsts());</td>
    <td class="lineNumber">397</td>
    <td class="codeline">         (Ty->isHalfTy() && ST->has16BitInsts());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeline">}</td>
    <td class="lineNumber">398</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeline"></td>
    <td class="lineNumber">399</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeline">// Return true if the op promoted to i32 should have nsw set.</td>
    <td class="lineNumber">400</td>
    <td class="codeline">// Return true if the op promoted to i32 should have nsw set.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeline">static bool promotedOpIsNSW(const Instruction &I) {</td>
    <td class="lineNumber">401</td>
    <td class="codeline">static bool promotedOpIsNSW(const Instruction &I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeline">  switch (I.getOpcode()) {</td>
    <td class="lineNumber">402</td>
    <td class="codeline">  switch (I.getOpcode()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeline">  case Instruction::Shl:</td>
    <td class="lineNumber">403</td>
    <td class="codeline">  case Instruction::Shl:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeline">  case Instruction::Add:</td>
    <td class="lineNumber">404</td>
    <td class="codeline">  case Instruction::Add:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeline">  case Instruction::Sub:</td>
    <td class="lineNumber">405</td>
    <td class="codeline">  case Instruction::Sub:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">406</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeline">  case Instruction::Mul:</td>
    <td class="lineNumber">407</td>
    <td class="codeline">  case Instruction::Mul:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeline">    return I.hasNoUnsignedWrap();</td>
    <td class="lineNumber">408</td>
    <td class="codeline">    return I.hasNoUnsignedWrap();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeline">  default:</td>
    <td class="lineNumber">409</td>
    <td class="codeline">  default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">410</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">411</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeline">}</td>
    <td class="lineNumber">412</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeline"></td>
    <td class="lineNumber">413</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeline">// Return true if the op promoted to i32 should have nuw set.</td>
    <td class="lineNumber">414</td>
    <td class="codeline">// Return true if the op promoted to i32 should have nuw set.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeline">static bool promotedOpIsNUW(const Instruction &I) {</td>
    <td class="lineNumber">415</td>
    <td class="codeline">static bool promotedOpIsNUW(const Instruction &I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeline">  switch (I.getOpcode()) {</td>
    <td class="lineNumber">416</td>
    <td class="codeline">  switch (I.getOpcode()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeline">  case Instruction::Shl:</td>
    <td class="lineNumber">417</td>
    <td class="codeline">  case Instruction::Shl:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeline">  case Instruction::Add:</td>
    <td class="lineNumber">418</td>
    <td class="codeline">  case Instruction::Add:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeline">  case Instruction::Mul:</td>
    <td class="lineNumber">419</td>
    <td class="codeline">  case Instruction::Mul:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">420</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeline">  case Instruction::Sub:</td>
    <td class="lineNumber">421</td>
    <td class="codeline">  case Instruction::Sub:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeline">    return I.hasNoUnsignedWrap();</td>
    <td class="lineNumber">422</td>
    <td class="codeline">    return I.hasNoUnsignedWrap();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeline">  default:</td>
    <td class="lineNumber">423</td>
    <td class="codeline">  default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">424</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">425</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeline">}</td>
    <td class="lineNumber">426</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeline"></td>
    <td class="lineNumber">427</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::canWidenScalarExtLoad(LoadInst &I) const {</td>
    <td class="lineNumber">428</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::canWidenScalarExtLoad(LoadInst &I) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeline">  Type *Ty = I.getType();</td>
    <td class="lineNumber">429</td>
    <td class="codeline">  Type *Ty = I.getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeline">  const DataLayout &DL = Mod->getDataLayout();</td>
    <td class="lineNumber">430</td>
    <td class="codeline">  const DataLayout &DL = Mod->getDataLayout();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeline">  int TySize = DL.getTypeSizeInBits(Ty);</td>
    <td class="lineNumber">431</td>
    <td class="codeline">  int TySize = DL.getTypeSizeInBits(Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeline">  Align Alignment = DL.getValueOrABITypeAlignment(I.getAlign(), Ty);</td>
    <td class="lineNumber">432</td>
    <td class="codeline">  Align Alignment = DL.getValueOrABITypeAlignment(I.getAlign(), Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeline"></td>
    <td class="lineNumber">433</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeline">  return I.isSimple() && TySize < 32 && Alignment >= 4 && UA->isUniform(&I);</td>
    <td class="lineNumber">434</td>
    <td class="codeline">  return I.isSimple() && TySize < 32 && Alignment >= 4 && UA->isUniform(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeline">}</td>
    <td class="lineNumber">435</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeline"></td>
    <td class="lineNumber">436</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::promoteUniformOpToI32(BinaryOperator &I) const {</td>
    <td class="lineNumber">437</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::promoteUniformOpToI32(BinaryOperator &I) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeline">  assert(needsPromotionToI32(I.getType()) &&</td>
    <td class="lineNumber">438</td>
    <td class="codeline">  assert(needsPromotionToI32(I.getType()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeline">         "I does not need promotion to i32");</td>
    <td class="lineNumber">439</td>
    <td class="codeline">         "I does not need promotion to i32");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeline"></td>
    <td class="lineNumber">440</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeline">  if (I.getOpcode() == Instruction::SDiv ||</td>
    <td class="lineNumber">441</td>
    <td class="codeline">  if (I.getOpcode() == Instruction::SDiv ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeline">      I.getOpcode() == Instruction::UDiv ||</td>
    <td class="lineNumber">442</td>
    <td class="codeline">      I.getOpcode() == Instruction::UDiv ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeline">      I.getOpcode() == Instruction::SRem ||</td>
    <td class="lineNumber">443</td>
    <td class="codeline">      I.getOpcode() == Instruction::SRem ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeline">      I.getOpcode() == Instruction::URem)</td>
    <td class="lineNumber">444</td>
    <td class="codeline">      I.getOpcode() == Instruction::URem)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">445</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeline"></td>
    <td class="lineNumber">446</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeline">  IRBuilder<> Builder(&I);</td>
    <td class="lineNumber">447</td>
    <td class="codeline">  IRBuilder<> Builder(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeline">  Builder.SetCurrentDebugLocation(I.getDebugLoc());</td>
    <td class="lineNumber">448</td>
    <td class="codeline">  Builder.SetCurrentDebugLocation(I.getDebugLoc());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeline"></td>
    <td class="lineNumber">449</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeline">  Type *I32Ty = getI32Ty(Builder, I.getType());</td>
    <td class="lineNumber">450</td>
    <td class="codeline">  Type *I32Ty = getI32Ty(Builder, I.getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeline">  Value *ExtOp0 = nullptr;</td>
    <td class="lineNumber">451</td>
    <td class="codeline">  Value *ExtOp0 = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeline">  Value *ExtOp1 = nullptr;</td>
    <td class="lineNumber">452</td>
    <td class="codeline">  Value *ExtOp1 = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeline">  Value *ExtRes = nullptr;</td>
    <td class="lineNumber">453</td>
    <td class="codeline">  Value *ExtRes = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeline">  Value *TruncRes = nullptr;</td>
    <td class="lineNumber">454</td>
    <td class="codeline">  Value *TruncRes = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeline"></td>
    <td class="lineNumber">455</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeline">  if (isSigned(I)) {</td>
    <td class="lineNumber">456</td>
    <td class="codeline">  if (isSigned(I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeline">    ExtOp0 = Builder.CreateSExt(I.getOperand(0), I32Ty);</td>
    <td class="lineNumber">457</td>
    <td class="codeline">    ExtOp0 = Builder.CreateSExt(I.getOperand(0), I32Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeline">    ExtOp1 = Builder.CreateSExt(I.getOperand(1), I32Ty);</td>
    <td class="lineNumber">458</td>
    <td class="codeline">    ExtOp1 = Builder.CreateSExt(I.getOperand(1), I32Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">459</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeline">    ExtOp0 = Builder.CreateZExt(I.getOperand(0), I32Ty);</td>
    <td class="lineNumber">460</td>
    <td class="codeline">    ExtOp0 = Builder.CreateZExt(I.getOperand(0), I32Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeline">    ExtOp1 = Builder.CreateZExt(I.getOperand(1), I32Ty);</td>
    <td class="lineNumber">461</td>
    <td class="codeline">    ExtOp1 = Builder.CreateZExt(I.getOperand(1), I32Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">462</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeline"></td>
    <td class="lineNumber">463</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeline">  ExtRes = Builder.CreateBinOp(I.getOpcode(), ExtOp0, ExtOp1);</td>
    <td class="lineNumber">464</td>
    <td class="codeline">  ExtRes = Builder.CreateBinOp(I.getOpcode(), ExtOp0, ExtOp1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeline">  if (Instruction *Inst = dyn_cast<Instruction>(ExtRes)) {</td>
    <td class="lineNumber">465</td>
    <td class="codeline">  if (Instruction *Inst = dyn_cast<Instruction>(ExtRes)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeline">    if (promotedOpIsNSW(cast<Instruction>(I)))</td>
    <td class="lineNumber">466</td>
    <td class="codeline">    if (promotedOpIsNSW(cast<Instruction>(I)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeline">      Inst->setHasNoSignedWrap();</td>
    <td class="lineNumber">467</td>
    <td class="codeline">      Inst->setHasNoSignedWrap();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeline"></td>
    <td class="lineNumber">468</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeline">    if (promotedOpIsNUW(cast<Instruction>(I)))</td>
    <td class="lineNumber">469</td>
    <td class="codeline">    if (promotedOpIsNUW(cast<Instruction>(I)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeline">      Inst->setHasNoUnsignedWrap();</td>
    <td class="lineNumber">470</td>
    <td class="codeline">      Inst->setHasNoUnsignedWrap();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeline"></td>
    <td class="lineNumber">471</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeline">    if (const auto *ExactOp = dyn_cast<PossiblyExactOperator>(&I))</td>
    <td class="lineNumber">472</td>
    <td class="codeline">    if (const auto *ExactOp = dyn_cast<PossiblyExactOperator>(&I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeline">      Inst->setIsExact(ExactOp->isExact());</td>
    <td class="lineNumber">473</td>
    <td class="codeline">      Inst->setIsExact(ExactOp->isExact());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">474</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeline"></td>
    <td class="lineNumber">475</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeline">  TruncRes = Builder.CreateTrunc(ExtRes, I.getType());</td>
    <td class="lineNumber">476</td>
    <td class="codeline">  TruncRes = Builder.CreateTrunc(ExtRes, I.getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeline"></td>
    <td class="lineNumber">477</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeline">  I.replaceAllUsesWith(TruncRes);</td>
    <td class="lineNumber">478</td>
    <td class="codeline">  I.replaceAllUsesWith(TruncRes);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeline">  I.eraseFromParent();</td>
    <td class="lineNumber">479</td>
    <td class="codeline">  I.eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeline"></td>
    <td class="lineNumber">480</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">481</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeline">}</td>
    <td class="lineNumber">482</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeline"></td>
    <td class="lineNumber">483</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::promoteUniformOpToI32(ICmpInst &I) const {</td>
    <td class="lineNumber">484</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::promoteUniformOpToI32(ICmpInst &I) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeline">  assert(needsPromotionToI32(I.getOperand(0)->getType()) &&</td>
    <td class="lineNumber">485</td>
    <td class="codeline">  assert(needsPromotionToI32(I.getOperand(0)->getType()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeline">         "I does not need promotion to i32");</td>
    <td class="lineNumber">486</td>
    <td class="codeline">         "I does not need promotion to i32");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeline"></td>
    <td class="lineNumber">487</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeline">  IRBuilder<> Builder(&I);</td>
    <td class="lineNumber">488</td>
    <td class="codeline">  IRBuilder<> Builder(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeline">  Builder.SetCurrentDebugLocation(I.getDebugLoc());</td>
    <td class="lineNumber">489</td>
    <td class="codeline">  Builder.SetCurrentDebugLocation(I.getDebugLoc());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeline"></td>
    <td class="lineNumber">490</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeline">  Type *I32Ty = getI32Ty(Builder, I.getOperand(0)->getType());</td>
    <td class="lineNumber">491</td>
    <td class="codeline">  Type *I32Ty = getI32Ty(Builder, I.getOperand(0)->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeline">  Value *ExtOp0 = nullptr;</td>
    <td class="lineNumber">492</td>
    <td class="codeline">  Value *ExtOp0 = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeline">  Value *ExtOp1 = nullptr;</td>
    <td class="lineNumber">493</td>
    <td class="codeline">  Value *ExtOp1 = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeline">  Value *NewICmp  = nullptr;</td>
    <td class="lineNumber">494</td>
    <td class="codeline">  Value *NewICmp  = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeline"></td>
    <td class="lineNumber">495</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeline">  if (I.isSigned()) {</td>
    <td class="lineNumber">496</td>
    <td class="codeline">  if (I.isSigned()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeline">    ExtOp0 = Builder.CreateSExt(I.getOperand(0), I32Ty);</td>
    <td class="lineNumber">497</td>
    <td class="codeline">    ExtOp0 = Builder.CreateSExt(I.getOperand(0), I32Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeline">    ExtOp1 = Builder.CreateSExt(I.getOperand(1), I32Ty);</td>
    <td class="lineNumber">498</td>
    <td class="codeline">    ExtOp1 = Builder.CreateSExt(I.getOperand(1), I32Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">499</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeline">    ExtOp0 = Builder.CreateZExt(I.getOperand(0), I32Ty);</td>
    <td class="lineNumber">500</td>
    <td class="codeline">    ExtOp0 = Builder.CreateZExt(I.getOperand(0), I32Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeline">    ExtOp1 = Builder.CreateZExt(I.getOperand(1), I32Ty);</td>
    <td class="lineNumber">501</td>
    <td class="codeline">    ExtOp1 = Builder.CreateZExt(I.getOperand(1), I32Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">502</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeline">  NewICmp = Builder.CreateICmp(I.getPredicate(), ExtOp0, ExtOp1);</td>
    <td class="lineNumber">503</td>
    <td class="codeline">  NewICmp = Builder.CreateICmp(I.getPredicate(), ExtOp0, ExtOp1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeline"></td>
    <td class="lineNumber">504</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeline">  I.replaceAllUsesWith(NewICmp);</td>
    <td class="lineNumber">505</td>
    <td class="codeline">  I.replaceAllUsesWith(NewICmp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeline">  I.eraseFromParent();</td>
    <td class="lineNumber">506</td>
    <td class="codeline">  I.eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeline"></td>
    <td class="lineNumber">507</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">508</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeline">}</td>
    <td class="lineNumber">509</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeline"></td>
    <td class="lineNumber">510</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::promoteUniformOpToI32(SelectInst &I) const {</td>
    <td class="lineNumber">511</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::promoteUniformOpToI32(SelectInst &I) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeline">  assert(needsPromotionToI32(I.getType()) &&</td>
    <td class="lineNumber">512</td>
    <td class="codeline">  assert(needsPromotionToI32(I.getType()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeline">         "I does not need promotion to i32");</td>
    <td class="lineNumber">513</td>
    <td class="codeline">         "I does not need promotion to i32");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeline"></td>
    <td class="lineNumber">514</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeline">  IRBuilder<> Builder(&I);</td>
    <td class="lineNumber">515</td>
    <td class="codeline">  IRBuilder<> Builder(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeline">  Builder.SetCurrentDebugLocation(I.getDebugLoc());</td>
    <td class="lineNumber">516</td>
    <td class="codeline">  Builder.SetCurrentDebugLocation(I.getDebugLoc());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeline"></td>
    <td class="lineNumber">517</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeline">  Type *I32Ty = getI32Ty(Builder, I.getType());</td>
    <td class="lineNumber">518</td>
    <td class="codeline">  Type *I32Ty = getI32Ty(Builder, I.getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeline">  Value *ExtOp1 = nullptr;</td>
    <td class="lineNumber">519</td>
    <td class="codeline">  Value *ExtOp1 = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeline">  Value *ExtOp2 = nullptr;</td>
    <td class="lineNumber">520</td>
    <td class="codeline">  Value *ExtOp2 = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeline">  Value *ExtRes = nullptr;</td>
    <td class="lineNumber">521</td>
    <td class="codeline">  Value *ExtRes = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeline">  Value *TruncRes = nullptr;</td>
    <td class="lineNumber">522</td>
    <td class="codeline">  Value *TruncRes = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeline"></td>
    <td class="lineNumber">523</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeline">  if (isSigned(I)) {</td>
    <td class="lineNumber">524</td>
    <td class="codeline">  if (isSigned(I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeline">    ExtOp1 = Builder.CreateSExt(I.getOperand(1), I32Ty);</td>
    <td class="lineNumber">525</td>
    <td class="codeline">    ExtOp1 = Builder.CreateSExt(I.getOperand(1), I32Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeline">    ExtOp2 = Builder.CreateSExt(I.getOperand(2), I32Ty);</td>
    <td class="lineNumber">526</td>
    <td class="codeline">    ExtOp2 = Builder.CreateSExt(I.getOperand(2), I32Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">527</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeline">    ExtOp1 = Builder.CreateZExt(I.getOperand(1), I32Ty);</td>
    <td class="lineNumber">528</td>
    <td class="codeline">    ExtOp1 = Builder.CreateZExt(I.getOperand(1), I32Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeline">    ExtOp2 = Builder.CreateZExt(I.getOperand(2), I32Ty);</td>
    <td class="lineNumber">529</td>
    <td class="codeline">    ExtOp2 = Builder.CreateZExt(I.getOperand(2), I32Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">530</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeline">  ExtRes = Builder.CreateSelect(I.getOperand(0), ExtOp1, ExtOp2);</td>
    <td class="lineNumber">531</td>
    <td class="codeline">  ExtRes = Builder.CreateSelect(I.getOperand(0), ExtOp1, ExtOp2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeline">  TruncRes = Builder.CreateTrunc(ExtRes, I.getType());</td>
    <td class="lineNumber">532</td>
    <td class="codeline">  TruncRes = Builder.CreateTrunc(ExtRes, I.getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeline"></td>
    <td class="lineNumber">533</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeline">  I.replaceAllUsesWith(TruncRes);</td>
    <td class="lineNumber">534</td>
    <td class="codeline">  I.replaceAllUsesWith(TruncRes);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeline">  I.eraseFromParent();</td>
    <td class="lineNumber">535</td>
    <td class="codeline">  I.eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeline"></td>
    <td class="lineNumber">536</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">537</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeline">}</td>
    <td class="lineNumber">538</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeline"></td>
    <td class="lineNumber">539</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::promoteUniformBitreverseToI32(</td>
    <td class="lineNumber">540</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::promoteUniformBitreverseToI32(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeline">    IntrinsicInst &I) const {</td>
    <td class="lineNumber">541</td>
    <td class="codeline">    IntrinsicInst &I) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeline">  assert(I.getIntrinsicID() == Intrinsic::bitreverse &&</td>
    <td class="lineNumber">542</td>
    <td class="codeline">  assert(I.getIntrinsicID() == Intrinsic::bitreverse &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeline">         "I must be bitreverse intrinsic");</td>
    <td class="lineNumber">543</td>
    <td class="codeline">         "I must be bitreverse intrinsic");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeline">  assert(needsPromotionToI32(I.getType()) &&</td>
    <td class="lineNumber">544</td>
    <td class="codeline">  assert(needsPromotionToI32(I.getType()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeline">         "I does not need promotion to i32");</td>
    <td class="lineNumber">545</td>
    <td class="codeline">         "I does not need promotion to i32");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeline"></td>
    <td class="lineNumber">546</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeline">  IRBuilder<> Builder(&I);</td>
    <td class="lineNumber">547</td>
    <td class="codeline">  IRBuilder<> Builder(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeline">  Builder.SetCurrentDebugLocation(I.getDebugLoc());</td>
    <td class="lineNumber">548</td>
    <td class="codeline">  Builder.SetCurrentDebugLocation(I.getDebugLoc());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeline"></td>
    <td class="lineNumber">549</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeline">  Type *I32Ty = getI32Ty(Builder, I.getType());</td>
    <td class="lineNumber">550</td>
    <td class="codeline">  Type *I32Ty = getI32Ty(Builder, I.getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeline">  Function *I32 =</td>
    <td class="lineNumber">551</td>
    <td class="codeline">  Function *I32 =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeline">      Intrinsic::getDeclaration(Mod, Intrinsic::bitreverse, { I32Ty });</td>
    <td class="lineNumber">552</td>
    <td class="codeline">      Intrinsic::getDeclaration(Mod, Intrinsic::bitreverse, { I32Ty });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeline">  Value *ExtOp = Builder.CreateZExt(I.getOperand(0), I32Ty);</td>
    <td class="lineNumber">553</td>
    <td class="codeline">  Value *ExtOp = Builder.CreateZExt(I.getOperand(0), I32Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeline">  Value *ExtRes = Builder.CreateCall(I32, { ExtOp });</td>
    <td class="lineNumber">554</td>
    <td class="codeline">  Value *ExtRes = Builder.CreateCall(I32, { ExtOp });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeline">  Value *LShrOp =</td>
    <td class="lineNumber">555</td>
    <td class="codeline">  Value *LShrOp =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeline">      Builder.CreateLShr(ExtRes, 32 - getBaseElementBitWidth(I.getType()));</td>
    <td class="lineNumber">556</td>
    <td class="codeline">      Builder.CreateLShr(ExtRes, 32 - getBaseElementBitWidth(I.getType()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeline">  Value *TruncRes =</td>
    <td class="lineNumber">557</td>
    <td class="codeline">  Value *TruncRes =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeline">      Builder.CreateTrunc(LShrOp, I.getType());</td>
    <td class="lineNumber">558</td>
    <td class="codeline">      Builder.CreateTrunc(LShrOp, I.getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeline"></td>
    <td class="lineNumber">559</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeline">  I.replaceAllUsesWith(TruncRes);</td>
    <td class="lineNumber">560</td>
    <td class="codeline">  I.replaceAllUsesWith(TruncRes);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeline">  I.eraseFromParent();</td>
    <td class="lineNumber">561</td>
    <td class="codeline">  I.eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeline"></td>
    <td class="lineNumber">562</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">563</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeline">}</td>
    <td class="lineNumber">564</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeline"></td>
    <td class="lineNumber">565</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeline">unsigned AMDGPUCodeGenPrepareImpl::numBitsUnsigned(Value *Op) const {</td>
    <td class="lineNumber">566</td>
    <td class="codeline">unsigned AMDGPUCodeGenPrepareImpl::numBitsUnsigned(Value *Op) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeline">  return computeKnownBits(Op, *DL, 0, AC).countMaxActiveBits();</td>
    <td class="lineNumber">567</td>
    <td class="codeline">  return computeKnownBits(Op, *DL, 0, AC).countMaxActiveBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeline">}</td>
    <td class="lineNumber">568</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeline"></td>
    <td class="lineNumber">569</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeline">unsigned AMDGPUCodeGenPrepareImpl::numBitsSigned(Value *Op) const {</td>
    <td class="lineNumber">570</td>
    <td class="codeline">unsigned AMDGPUCodeGenPrepareImpl::numBitsSigned(Value *Op) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeline">  return ComputeMaxSignificantBits(Op, *DL, 0, AC);</td>
    <td class="lineNumber">571</td>
    <td class="codeline">  return ComputeMaxSignificantBits(Op, *DL, 0, AC);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeline">}</td>
    <td class="lineNumber">572</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeline"></td>
    <td class="lineNumber">573</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeline">static void extractValues(IRBuilder<> &Builder,</td>
    <td class="lineNumber">574</td>
    <td class="codeline">static void extractValues(IRBuilder<> &Builder,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeline">                          SmallVectorImpl<Value *> &Values, Value *V) {</td>
    <td class="lineNumber">575</td>
    <td class="codeline">                          SmallVectorImpl<Value *> &Values, Value *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeline">  auto *VT = dyn_cast<FixedVectorType>(V->getType());</td>
    <td class="lineNumber">576</td>
    <td class="codeline">  auto *VT = dyn_cast<FixedVectorType>(V->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeline">  if (!VT) {</td>
    <td class="lineNumber">577</td>
    <td class="codeline">  if (!VT) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeline">    Values.push_back(V);</td>
    <td class="lineNumber">578</td>
    <td class="codeline">    Values.push_back(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">579</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">580</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeline"></td>
    <td class="lineNumber">581</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeline">  for (int I = 0, E = VT->getNumElements(); I != E; ++I)</td>
    <td class="lineNumber">582</td>
    <td class="codeline">  for (int I = 0, E = VT->getNumElements(); I != E; ++I)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeline">    Values.push_back(Builder.CreateExtractElement(V, I));</td>
    <td class="lineNumber">583</td>
    <td class="codeline">    Values.push_back(Builder.CreateExtractElement(V, I));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeline">}</td>
    <td class="lineNumber">584</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeline"></td>
    <td class="lineNumber">585</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeline">static Value *insertValues(IRBuilder<> &Builder,</td>
    <td class="lineNumber">586</td>
    <td class="codeline">static Value *insertValues(IRBuilder<> &Builder,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeline">                           Type *Ty,</td>
    <td class="lineNumber">587</td>
    <td class="codeline">                           Type *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeline">                           SmallVectorImpl<Value *> &Values) {</td>
    <td class="lineNumber">588</td>
    <td class="codeline">                           SmallVectorImpl<Value *> &Values) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeline">  if (!Ty->isVectorTy()) {</td>
    <td class="lineNumber">589</td>
    <td class="codeline">  if (!Ty->isVectorTy()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeline">    assert(Values.size() == 1);</td>
    <td class="lineNumber">590</td>
    <td class="codeline">    assert(Values.size() == 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeline">    return Values[0];</td>
    <td class="lineNumber">591</td>
    <td class="codeline">    return Values[0];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">592</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeline"></td>
    <td class="lineNumber">593</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeline">  Value *NewVal = PoisonValue::get(Ty);</td>
    <td class="lineNumber">594</td>
    <td class="codeline">  Value *NewVal = PoisonValue::get(Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeline">  for (int I = 0, E = Values.size(); I != E; ++I)</td>
    <td class="lineNumber">595</td>
    <td class="codeline">  for (int I = 0, E = Values.size(); I != E; ++I)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeline">    NewVal = Builder.CreateInsertElement(NewVal, Values[I], I);</td>
    <td class="lineNumber">596</td>
    <td class="codeline">    NewVal = Builder.CreateInsertElement(NewVal, Values[I], I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeline"></td>
    <td class="lineNumber">597</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeline">  return NewVal;</td>
    <td class="lineNumber">598</td>
    <td class="codeline">  return NewVal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeline">}</td>
    <td class="lineNumber">599</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeline"></td>
    <td class="lineNumber">600</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeline">// Returns 24-bit or 48-bit (as per `NumBits` and `Size`) mul of `LHS` and</td>
    <td class="lineNumber">601</td>
    <td class="codeline">// Returns 24-bit or 48-bit (as per `NumBits` and `Size`) mul of `LHS` and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeline">// `RHS`. `NumBits` is the number of KnownBits of the result and `Size` is the</td>
    <td class="lineNumber">602</td>
    <td class="codeline">// `RHS`. `NumBits` is the number of KnownBits of the result and `Size` is the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeline">// width of the original destination.</td>
    <td class="lineNumber">603</td>
    <td class="codeline">// width of the original destination.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeline">static Value *getMul24(IRBuilder<> &Builder, Value *LHS, Value *RHS,</td>
    <td class="lineNumber">604</td>
    <td class="codeline">static Value *getMul24(IRBuilder<> &Builder, Value *LHS, Value *RHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeline">                       unsigned Size, unsigned NumBits, bool IsSigned) {</td>
    <td class="lineNumber">605</td>
    <td class="codeline">                       unsigned Size, unsigned NumBits, bool IsSigned) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeline">  if (Size <= 32 || NumBits <= 32) {</td>
    <td class="lineNumber">606</td>
    <td class="codeline">  if (Size <= 32 || NumBits <= 32) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeline">    Intrinsic::ID ID =</td>
    <td class="lineNumber">607</td>
    <td class="codeline">    Intrinsic::ID ID =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeline">        IsSigned ? Intrinsic::amdgcn_mul_i24 : Intrinsic::amdgcn_mul_u24;</td>
    <td class="lineNumber">608</td>
    <td class="codeline">        IsSigned ? Intrinsic::amdgcn_mul_i24 : Intrinsic::amdgcn_mul_u24;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeline">    return Builder.CreateIntrinsic(ID, {}, {LHS, RHS});</td>
    <td class="lineNumber">609</td>
    <td class="codeline">    return Builder.CreateIntrinsic(ID, {}, {LHS, RHS});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">610</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeline"></td>
    <td class="lineNumber">611</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeline">  assert(NumBits <= 48);</td>
    <td class="lineNumber">612</td>
    <td class="codeline">  assert(NumBits <= 48);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeline"></td>
    <td class="lineNumber">613</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeline">  Intrinsic::ID LoID =</td>
    <td class="lineNumber">614</td>
    <td class="codeline">  Intrinsic::ID LoID =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeline">      IsSigned ? Intrinsic::amdgcn_mul_i24 : Intrinsic::amdgcn_mul_u24;</td>
    <td class="lineNumber">615</td>
    <td class="codeline">      IsSigned ? Intrinsic::amdgcn_mul_i24 : Intrinsic::amdgcn_mul_u24;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeline">  Intrinsic::ID HiID =</td>
    <td class="lineNumber">616</td>
    <td class="codeline">  Intrinsic::ID HiID =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeline">      IsSigned ? Intrinsic::amdgcn_mulhi_i24 : Intrinsic::amdgcn_mulhi_u24;</td>
    <td class="lineNumber">617</td>
    <td class="codeline">      IsSigned ? Intrinsic::amdgcn_mulhi_i24 : Intrinsic::amdgcn_mulhi_u24;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeline"></td>
    <td class="lineNumber">618</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeline">  Value *Lo = Builder.CreateIntrinsic(LoID, {}, {LHS, RHS});</td>
    <td class="lineNumber">619</td>
    <td class="codeline">  Value *Lo = Builder.CreateIntrinsic(LoID, {}, {LHS, RHS});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeline">  Value *Hi = Builder.CreateIntrinsic(HiID, {}, {LHS, RHS});</td>
    <td class="lineNumber">620</td>
    <td class="codeline">  Value *Hi = Builder.CreateIntrinsic(HiID, {}, {LHS, RHS});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeline"></td>
    <td class="lineNumber">621</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeline">  IntegerType *I64Ty = Builder.getInt64Ty();</td>
    <td class="lineNumber">622</td>
    <td class="codeline">  IntegerType *I64Ty = Builder.getInt64Ty();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeline">  Lo = Builder.CreateZExtOrTrunc(Lo, I64Ty);</td>
    <td class="lineNumber">623</td>
    <td class="codeline">  Lo = Builder.CreateZExtOrTrunc(Lo, I64Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeline">  Hi = Builder.CreateZExtOrTrunc(Hi, I64Ty);</td>
    <td class="lineNumber">624</td>
    <td class="codeline">  Hi = Builder.CreateZExtOrTrunc(Hi, I64Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeline"></td>
    <td class="lineNumber">625</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeline">  return Builder.CreateOr(Lo, Builder.CreateShl(Hi, 32));</td>
    <td class="lineNumber">626</td>
    <td class="codeline">  return Builder.CreateOr(Lo, Builder.CreateShl(Hi, 32));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeline">}</td>
    <td class="lineNumber">627</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeline"></td>
    <td class="lineNumber">628</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::replaceMulWithMul24(BinaryOperator &I) const {</td>
    <td class="lineNumber">629</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::replaceMulWithMul24(BinaryOperator &I) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeline">  if (I.getOpcode() != Instruction::Mul)</td>
    <td class="lineNumber">630</td>
    <td class="codeline">  if (I.getOpcode() != Instruction::Mul)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">631</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeline"></td>
    <td class="lineNumber">632</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeline">  Type *Ty = I.getType();</td>
    <td class="lineNumber">633</td>
    <td class="codeline">  Type *Ty = I.getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeline">  unsigned Size = Ty->getScalarSizeInBits();</td>
    <td class="lineNumber">634</td>
    <td class="codeline">  unsigned Size = Ty->getScalarSizeInBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeline">  if (Size <= 16 && ST->has16BitInsts())</td>
    <td class="lineNumber">635</td>
    <td class="codeline">  if (Size <= 16 && ST->has16BitInsts())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">636</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeline"></td>
    <td class="lineNumber">637</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeline">  // Prefer scalar if this could be s_mul_i32</td>
    <td class="lineNumber">638</td>
    <td class="codeline">  // Prefer scalar if this could be s_mul_i32</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeline">  if (UA->isUniform(&I))</td>
    <td class="lineNumber">639</td>
    <td class="codeline">  if (UA->isUniform(&I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">640</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeline"></td>
    <td class="lineNumber">641</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeline">  Value *LHS = I.getOperand(0);</td>
    <td class="lineNumber">642</td>
    <td class="codeline">  Value *LHS = I.getOperand(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeline">  Value *RHS = I.getOperand(1);</td>
    <td class="lineNumber">643</td>
    <td class="codeline">  Value *RHS = I.getOperand(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeline">  IRBuilder<> Builder(&I);</td>
    <td class="lineNumber">644</td>
    <td class="codeline">  IRBuilder<> Builder(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeline">  Builder.SetCurrentDebugLocation(I.getDebugLoc());</td>
    <td class="lineNumber">645</td>
    <td class="codeline">  Builder.SetCurrentDebugLocation(I.getDebugLoc());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeline"></td>
    <td class="lineNumber">646</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeline">  unsigned LHSBits = 0, RHSBits = 0;</td>
    <td class="lineNumber">647</td>
    <td class="codeline">  unsigned LHSBits = 0, RHSBits = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeline">  bool IsSigned = false;</td>
    <td class="lineNumber">648</td>
    <td class="codeline">  bool IsSigned = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeline"></td>
    <td class="lineNumber">649</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeline">  if (ST->hasMulU24() && (LHSBits = numBitsUnsigned(LHS)) <= 24 &&</td>
    <td class="lineNumber">650</td>
    <td class="codeline">  if (ST->hasMulU24() && (LHSBits = numBitsUnsigned(LHS)) <= 24 &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeline">      (RHSBits = numBitsUnsigned(RHS)) <= 24) {</td>
    <td class="lineNumber">651</td>
    <td class="codeline">      (RHSBits = numBitsUnsigned(RHS)) <= 24) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeline">    IsSigned = false;</td>
    <td class="lineNumber">652</td>
    <td class="codeline">    IsSigned = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeline"></td>
    <td class="lineNumber">653</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeline">  } else if (ST->hasMulI24() && (LHSBits = numBitsSigned(LHS)) <= 24 &&</td>
    <td class="lineNumber">654</td>
    <td class="codeline">  } else if (ST->hasMulI24() && (LHSBits = numBitsSigned(LHS)) <= 24 &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeline">             (RHSBits = numBitsSigned(RHS)) <= 24) {</td>
    <td class="lineNumber">655</td>
    <td class="codeline">             (RHSBits = numBitsSigned(RHS)) <= 24) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeline">    IsSigned = true;</td>
    <td class="lineNumber">656</td>
    <td class="codeline">    IsSigned = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeline"></td>
    <td class="lineNumber">657</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeline">  } else</td>
    <td class="lineNumber">658</td>
    <td class="codeline">  } else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">659</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeline"></td>
    <td class="lineNumber">660</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeline">  SmallVector<Value *, 4> LHSVals;</td>
    <td class="lineNumber">661</td>
    <td class="codeline">  SmallVector<Value *, 4> LHSVals;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeline">  SmallVector<Value *, 4> RHSVals;</td>
    <td class="lineNumber">662</td>
    <td class="codeline">  SmallVector<Value *, 4> RHSVals;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeline">  SmallVector<Value *, 4> ResultVals;</td>
    <td class="lineNumber">663</td>
    <td class="codeline">  SmallVector<Value *, 4> ResultVals;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeline">  extractValues(Builder, LHSVals, LHS);</td>
    <td class="lineNumber">664</td>
    <td class="codeline">  extractValues(Builder, LHSVals, LHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeline">  extractValues(Builder, RHSVals, RHS);</td>
    <td class="lineNumber">665</td>
    <td class="codeline">  extractValues(Builder, RHSVals, RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeline"></td>
    <td class="lineNumber">666</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeline">  IntegerType *I32Ty = Builder.getInt32Ty();</td>
    <td class="lineNumber">667</td>
    <td class="codeline">  IntegerType *I32Ty = Builder.getInt32Ty();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeline">  for (int I = 0, E = LHSVals.size(); I != E; ++I) {</td>
    <td class="lineNumber">668</td>
    <td class="codeline">  for (int I = 0, E = LHSVals.size(); I != E; ++I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeline">    Value *LHS, *RHS;</td>
    <td class="lineNumber">669</td>
    <td class="codeline">    Value *LHS, *RHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeline">    if (IsSigned) {</td>
    <td class="lineNumber">670</td>
    <td class="codeline">    if (IsSigned) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeline">      LHS = Builder.CreateSExtOrTrunc(LHSVals[I], I32Ty);</td>
    <td class="lineNumber">671</td>
    <td class="codeline">      LHS = Builder.CreateSExtOrTrunc(LHSVals[I], I32Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeline">      RHS = Builder.CreateSExtOrTrunc(RHSVals[I], I32Ty);</td>
    <td class="lineNumber">672</td>
    <td class="codeline">      RHS = Builder.CreateSExtOrTrunc(RHSVals[I], I32Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">673</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeline">      LHS = Builder.CreateZExtOrTrunc(LHSVals[I], I32Ty);</td>
    <td class="lineNumber">674</td>
    <td class="codeline">      LHS = Builder.CreateZExtOrTrunc(LHSVals[I], I32Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeline">      RHS = Builder.CreateZExtOrTrunc(RHSVals[I], I32Ty);</td>
    <td class="lineNumber">675</td>
    <td class="codeline">      RHS = Builder.CreateZExtOrTrunc(RHSVals[I], I32Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">676</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeline"></td>
    <td class="lineNumber">677</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeline">    Value *Result =</td>
    <td class="lineNumber">678</td>
    <td class="codeline">    Value *Result =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeline">        getMul24(Builder, LHS, RHS, Size, LHSBits + RHSBits, IsSigned);</td>
    <td class="lineNumber">679</td>
    <td class="codeline">        getMul24(Builder, LHS, RHS, Size, LHSBits + RHSBits, IsSigned);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeline"></td>
    <td class="lineNumber">680</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeline">    if (IsSigned) {</td>
    <td class="lineNumber">681</td>
    <td class="codeline">    if (IsSigned) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeline">      ResultVals.push_back(</td>
    <td class="lineNumber">682</td>
    <td class="codeline">      ResultVals.push_back(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeline">          Builder.CreateSExtOrTrunc(Result, LHSVals[I]->getType()));</td>
    <td class="lineNumber">683</td>
    <td class="codeline">          Builder.CreateSExtOrTrunc(Result, LHSVals[I]->getType()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">684</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeline">      ResultVals.push_back(</td>
    <td class="lineNumber">685</td>
    <td class="codeline">      ResultVals.push_back(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeline">          Builder.CreateZExtOrTrunc(Result, LHSVals[I]->getType()));</td>
    <td class="lineNumber">686</td>
    <td class="codeline">          Builder.CreateZExtOrTrunc(Result, LHSVals[I]->getType()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">687</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">688</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeline"></td>
    <td class="lineNumber">689</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeline">  Value *NewVal = insertValues(Builder, Ty, ResultVals);</td>
    <td class="lineNumber">690</td>
    <td class="codeline">  Value *NewVal = insertValues(Builder, Ty, ResultVals);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeline">  NewVal->takeName(&I);</td>
    <td class="lineNumber">691</td>
    <td class="codeline">  NewVal->takeName(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeline">  I.replaceAllUsesWith(NewVal);</td>
    <td class="lineNumber">692</td>
    <td class="codeline">  I.replaceAllUsesWith(NewVal);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeline">  I.eraseFromParent();</td>
    <td class="lineNumber">693</td>
    <td class="codeline">  I.eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeline"></td>
    <td class="lineNumber">694</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">695</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeline">}</td>
    <td class="lineNumber">696</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeline"></td>
    <td class="lineNumber">697</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeline">// Find a select instruction, which may have been casted. This is mostly to deal</td>
    <td class="lineNumber">698</td>
    <td class="codeline">// Find a select instruction, which may have been casted. This is mostly to deal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeline">// with cases where i16 selects were promoted here to i32.</td>
    <td class="lineNumber">699</td>
    <td class="codeline">// with cases where i16 selects were promoted here to i32.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeline">static SelectInst *findSelectThroughCast(Value *V, CastInst *&Cast) {</td>
    <td class="lineNumber">700</td>
    <td class="codeline">static SelectInst *findSelectThroughCast(Value *V, CastInst *&Cast) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeline">  Cast = nullptr;</td>
    <td class="lineNumber">701</td>
    <td class="codeline">  Cast = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeline">  if (SelectInst *Sel = dyn_cast<SelectInst>(V))</td>
    <td class="lineNumber">702</td>
    <td class="codeline">  if (SelectInst *Sel = dyn_cast<SelectInst>(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeline">    return Sel;</td>
    <td class="lineNumber">703</td>
    <td class="codeline">    return Sel;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeline"></td>
    <td class="lineNumber">704</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeline">  if ((Cast = dyn_cast<CastInst>(V))) {</td>
    <td class="lineNumber">705</td>
    <td class="codeline">  if ((Cast = dyn_cast<CastInst>(V))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeline">    if (SelectInst *Sel = dyn_cast<SelectInst>(Cast->getOperand(0)))</td>
    <td class="lineNumber">706</td>
    <td class="codeline">    if (SelectInst *Sel = dyn_cast<SelectInst>(Cast->getOperand(0)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeline">      return Sel;</td>
    <td class="lineNumber">707</td>
    <td class="codeline">      return Sel;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">708</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeline"></td>
    <td class="lineNumber">709</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeline">  return nullptr;</td>
    <td class="lineNumber">710</td>
    <td class="codeline">  return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeline">}</td>
    <td class="lineNumber">711</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeline"></td>
    <td class="lineNumber">712</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::foldBinOpIntoSelect(BinaryOperator &BO) const {</td>
    <td class="lineNumber">713</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::foldBinOpIntoSelect(BinaryOperator &BO) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeline">  // Don't do this unless the old select is going away. We want to eliminate the</td>
    <td class="lineNumber">714</td>
    <td class="codeline">  // Don't do this unless the old select is going away. We want to eliminate the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeline">  // binary operator, not replace a binop with a select.</td>
    <td class="lineNumber">715</td>
    <td class="codeline">  // binary operator, not replace a binop with a select.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeline">  int SelOpNo = 0;</td>
    <td class="lineNumber">716</td>
    <td class="codeline">  int SelOpNo = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeline"></td>
    <td class="lineNumber">717</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeline">  CastInst *CastOp;</td>
    <td class="lineNumber">718</td>
    <td class="codeline">  CastInst *CastOp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeline"></td>
    <td class="lineNumber">719</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeline">  // TODO: Should probably try to handle some cases with multiple</td>
    <td class="lineNumber">720</td>
    <td class="codeline">  // TODO: Should probably try to handle some cases with multiple</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeline">  // users. Duplicating the select may be profitable for division.</td>
    <td class="lineNumber">721</td>
    <td class="codeline">  // users. Duplicating the select may be profitable for division.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeline">  SelectInst *Sel = findSelectThroughCast(BO.getOperand(0), CastOp);</td>
    <td class="lineNumber">722</td>
    <td class="codeline">  SelectInst *Sel = findSelectThroughCast(BO.getOperand(0), CastOp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeline">  if (!Sel || !Sel->hasOneUse()) {</td>
    <td class="lineNumber">723</td>
    <td class="codeline">  if (!Sel || !Sel->hasOneUse()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeline">    SelOpNo = 1;</td>
    <td class="lineNumber">724</td>
    <td class="codeline">    SelOpNo = 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeline">    Sel = findSelectThroughCast(BO.getOperand(1), CastOp);</td>
    <td class="lineNumber">725</td>
    <td class="codeline">    Sel = findSelectThroughCast(BO.getOperand(1), CastOp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">726</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeline"></td>
    <td class="lineNumber">727</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeline">  if (!Sel || !Sel->hasOneUse())</td>
    <td class="lineNumber">728</td>
    <td class="codeline">  if (!Sel || !Sel->hasOneUse())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">729</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeline"></td>
    <td class="lineNumber">730</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeline">  Constant *CT = dyn_cast<Constant>(Sel->getTrueValue());</td>
    <td class="lineNumber">731</td>
    <td class="codeline">  Constant *CT = dyn_cast<Constant>(Sel->getTrueValue());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeline">  Constant *CF = dyn_cast<Constant>(Sel->getFalseValue());</td>
    <td class="lineNumber">732</td>
    <td class="codeline">  Constant *CF = dyn_cast<Constant>(Sel->getFalseValue());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeline">  Constant *CBO = dyn_cast<Constant>(BO.getOperand(SelOpNo ^ 1));</td>
    <td class="lineNumber">733</td>
    <td class="codeline">  Constant *CBO = dyn_cast<Constant>(BO.getOperand(SelOpNo ^ 1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeline">  if (!CBO || !CT || !CF)</td>
    <td class="lineNumber">734</td>
    <td class="codeline">  if (!CBO || !CT || !CF)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">735</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeline"></td>
    <td class="lineNumber">736</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeline">  if (CastOp) {</td>
    <td class="lineNumber">737</td>
    <td class="codeline">  if (CastOp) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeline">    if (!CastOp->hasOneUse())</td>
    <td class="lineNumber">738</td>
    <td class="codeline">    if (!CastOp->hasOneUse())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">739</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeline">    CT = ConstantFoldCastOperand(CastOp->getOpcode(), CT, BO.getType(), *DL);</td>
    <td class="lineNumber">740</td>
    <td class="codeline">    CT = ConstantFoldCastOperand(CastOp->getOpcode(), CT, BO.getType(), *DL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeline">    CF = ConstantFoldCastOperand(CastOp->getOpcode(), CF, BO.getType(), *DL);</td>
    <td class="lineNumber">741</td>
    <td class="codeline">    CF = ConstantFoldCastOperand(CastOp->getOpcode(), CF, BO.getType(), *DL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">742</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeline"></td>
    <td class="lineNumber">743</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeline">  // TODO: Handle special 0/-1 cases DAG combine does, although we only really</td>
    <td class="lineNumber">744</td>
    <td class="codeline">  // TODO: Handle special 0/-1 cases DAG combine does, although we only really</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeline">  // need to handle divisions here.</td>
    <td class="lineNumber">745</td>
    <td class="codeline">  // need to handle divisions here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeline">  Constant *FoldedT = SelOpNo ?</td>
    <td class="lineNumber">746</td>
    <td class="codeline">  Constant *FoldedT = SelOpNo ?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeline">    ConstantFoldBinaryOpOperands(BO.getOpcode(), CBO, CT, *DL) :</td>
    <td class="lineNumber">747</td>
    <td class="codeline">    ConstantFoldBinaryOpOperands(BO.getOpcode(), CBO, CT, *DL) :</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeline">    ConstantFoldBinaryOpOperands(BO.getOpcode(), CT, CBO, *DL);</td>
    <td class="lineNumber">748</td>
    <td class="codeline">    ConstantFoldBinaryOpOperands(BO.getOpcode(), CT, CBO, *DL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeline">  if (!FoldedT || isa<ConstantExpr>(FoldedT))</td>
    <td class="lineNumber">749</td>
    <td class="codeline">  if (!FoldedT || isa<ConstantExpr>(FoldedT))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">750</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeline"></td>
    <td class="lineNumber">751</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeline">  Constant *FoldedF = SelOpNo ?</td>
    <td class="lineNumber">752</td>
    <td class="codeline">  Constant *FoldedF = SelOpNo ?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeline">    ConstantFoldBinaryOpOperands(BO.getOpcode(), CBO, CF, *DL) :</td>
    <td class="lineNumber">753</td>
    <td class="codeline">    ConstantFoldBinaryOpOperands(BO.getOpcode(), CBO, CF, *DL) :</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeline">    ConstantFoldBinaryOpOperands(BO.getOpcode(), CF, CBO, *DL);</td>
    <td class="lineNumber">754</td>
    <td class="codeline">    ConstantFoldBinaryOpOperands(BO.getOpcode(), CF, CBO, *DL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeline">  if (!FoldedF || isa<ConstantExpr>(FoldedF))</td>
    <td class="lineNumber">755</td>
    <td class="codeline">  if (!FoldedF || isa<ConstantExpr>(FoldedF))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">756</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeline"></td>
    <td class="lineNumber">757</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeline">  IRBuilder<> Builder(&BO);</td>
    <td class="lineNumber">758</td>
    <td class="codeline">  IRBuilder<> Builder(&BO);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeline">  Builder.SetCurrentDebugLocation(BO.getDebugLoc());</td>
    <td class="lineNumber">759</td>
    <td class="codeline">  Builder.SetCurrentDebugLocation(BO.getDebugLoc());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeline">  if (const FPMathOperator *FPOp = dyn_cast<const FPMathOperator>(&BO))</td>
    <td class="lineNumber">760</td>
    <td class="codeline">  if (const FPMathOperator *FPOp = dyn_cast<const FPMathOperator>(&BO))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeline">    Builder.setFastMathFlags(FPOp->getFastMathFlags());</td>
    <td class="lineNumber">761</td>
    <td class="codeline">    Builder.setFastMathFlags(FPOp->getFastMathFlags());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeline"></td>
    <td class="lineNumber">762</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeline">  Value *NewSelect = Builder.CreateSelect(Sel->getCondition(),</td>
    <td class="lineNumber">763</td>
    <td class="codeline">  Value *NewSelect = Builder.CreateSelect(Sel->getCondition(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeline">                                          FoldedT, FoldedF);</td>
    <td class="lineNumber">764</td>
    <td class="codeline">                                          FoldedT, FoldedF);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeline">  NewSelect->takeName(&BO);</td>
    <td class="lineNumber">765</td>
    <td class="codeline">  NewSelect->takeName(&BO);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeline">  BO.replaceAllUsesWith(NewSelect);</td>
    <td class="lineNumber">766</td>
    <td class="codeline">  BO.replaceAllUsesWith(NewSelect);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeline">  BO.eraseFromParent();</td>
    <td class="lineNumber">767</td>
    <td class="codeline">  BO.eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeline">  if (CastOp)</td>
    <td class="lineNumber">768</td>
    <td class="codeline">  if (CastOp)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeline">    CastOp->eraseFromParent();</td>
    <td class="lineNumber">769</td>
    <td class="codeline">    CastOp->eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeline">  Sel->eraseFromParent();</td>
    <td class="lineNumber">770</td>
    <td class="codeline">  Sel->eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">771</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeline">}</td>
    <td class="lineNumber">772</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeline"></td>
    <td class="lineNumber">773</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeline">std::pair<Value *, Value *></td>
    <td class="lineNumber">774</td>
    <td class="codeline">std::pair<Value *, Value *></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeline">AMDGPUCodeGenPrepareImpl::getFrexpResults(IRBuilder<> &Builder,</td>
    <td class="lineNumber">775</td>
    <td class="codeline">AMDGPUCodeGenPrepareImpl::getFrexpResults(IRBuilder<> &Builder,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeline">                                          Value *Src) const {</td>
    <td class="lineNumber">776</td>
    <td class="codeline">                                          Value *Src) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeline">  Type *Ty = Src->getType();</td>
    <td class="lineNumber">777</td>
    <td class="codeline">  Type *Ty = Src->getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeline">  Value *Frexp = Builder.CreateIntrinsic(Intrinsic::frexp,</td>
    <td class="lineNumber">778</td>
    <td class="codeline">  Value *Frexp = Builder.CreateIntrinsic(Intrinsic::frexp,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeline">                                         {Ty, Builder.getInt32Ty()}, Src);</td>
    <td class="lineNumber">779</td>
    <td class="codeline">                                         {Ty, Builder.getInt32Ty()}, Src);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeline">  Value *FrexpMant = Builder.CreateExtractValue(Frexp, {0});</td>
    <td class="lineNumber">780</td>
    <td class="codeline">  Value *FrexpMant = Builder.CreateExtractValue(Frexp, {0});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeline"></td>
    <td class="lineNumber">781</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeline">  // Bypass the bug workaround for the exponent result since it doesn't matter.</td>
    <td class="lineNumber">782</td>
    <td class="codeline">  // Bypass the bug workaround for the exponent result since it doesn't matter.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeline">  // TODO: Does the bug workaround even really need to consider the exponent</td>
    <td class="lineNumber">783</td>
    <td class="codeline">  // TODO: Does the bug workaround even really need to consider the exponent</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeline">  // result? It's unspecified by the spec.</td>
    <td class="lineNumber">784</td>
    <td class="codeline">  // result? It's unspecified by the spec.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeline"></td>
    <td class="lineNumber">785</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeline">  Value *FrexpExp =</td>
    <td class="lineNumber">786</td>
    <td class="codeline">  Value *FrexpExp =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeline">      ST->hasFractBug()</td>
    <td class="lineNumber">787</td>
    <td class="codeline">      ST->hasFractBug()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeline">          ? Builder.CreateIntrinsic(Intrinsic::amdgcn_frexp_exp,</td>
    <td class="lineNumber">788</td>
    <td class="codeline">          ? Builder.CreateIntrinsic(Intrinsic::amdgcn_frexp_exp,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeline">                                    {Builder.getInt32Ty(), Ty}, Src)</td>
    <td class="lineNumber">789</td>
    <td class="codeline">                                    {Builder.getInt32Ty(), Ty}, Src)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeline">          : Builder.CreateExtractValue(Frexp, {1});</td>
    <td class="lineNumber">790</td>
    <td class="codeline">          : Builder.CreateExtractValue(Frexp, {1});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeline">  return {FrexpMant, FrexpExp};</td>
    <td class="lineNumber">791</td>
    <td class="codeline">  return {FrexpMant, FrexpExp};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeline">}</td>
    <td class="lineNumber">792</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeline"></td>
    <td class="lineNumber">793</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeline">/// Emit an expansion of 1.0 / Src good for 1ulp that supports denormals.</td>
    <td class="lineNumber">794</td>
    <td class="codeline">/// Emit an expansion of 1.0 / Src good for 1ulp that supports denormals.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeline">Value *AMDGPUCodeGenPrepareImpl::emitRcpIEEE1ULP(IRBuilder<> &Builder,</td>
    <td class="lineNumber">795</td>
    <td class="codeline">Value *AMDGPUCodeGenPrepareImpl::emitRcpIEEE1ULP(IRBuilder<> &Builder,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeline">                                                 Value *Src,</td>
    <td class="lineNumber">796</td>
    <td class="codeline">                                                 Value *Src,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeline">                                                 bool IsNegative) const {</td>
    <td class="lineNumber">797</td>
    <td class="codeline">                                                 bool IsNegative) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeline">  // Same as for 1.0, but expand the sign out of the constant.</td>
    <td class="lineNumber">798</td>
    <td class="codeline">  // Same as for 1.0, but expand the sign out of the constant.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeline">  // -1.0 / x -> rcp (fneg x)</td>
    <td class="lineNumber">799</td>
    <td class="codeline">  // -1.0 / x -> rcp (fneg x)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeline">  if (IsNegative)</td>
    <td class="lineNumber">800</td>
    <td class="codeline">  if (IsNegative)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeline">    Src = Builder.CreateFNeg(Src);</td>
    <td class="lineNumber">801</td>
    <td class="codeline">    Src = Builder.CreateFNeg(Src);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeline"></td>
    <td class="lineNumber">802</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeline">  // The rcp instruction doesn't support denormals, so scale the input</td>
    <td class="lineNumber">803</td>
    <td class="codeline">  // The rcp instruction doesn't support denormals, so scale the input</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeline">  // out of the denormal range and convert at the end.</td>
    <td class="lineNumber">804</td>
    <td class="codeline">  // out of the denormal range and convert at the end.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">805</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeline">  // Expand as 2^-n * (1.0 / (x * 2^n))</td>
    <td class="lineNumber">806</td>
    <td class="codeline">  // Expand as 2^-n * (1.0 / (x * 2^n))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeline"></td>
    <td class="lineNumber">807</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeline">  // TODO: Skip scaling if input is known never denormal and the input</td>
    <td class="lineNumber">808</td>
    <td class="codeline">  // TODO: Skip scaling if input is known never denormal and the input</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeline">  // range won't underflow to denormal. The hard part is knowing the</td>
    <td class="lineNumber">809</td>
    <td class="codeline">  // range won't underflow to denormal. The hard part is knowing the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeline">  // result. We need a range check, the result could be denormal for</td>
    <td class="lineNumber">810</td>
    <td class="codeline">  // result. We need a range check, the result could be denormal for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeline">  // 0x1p+126 < den <= 0x1p+127.</td>
    <td class="lineNumber">811</td>
    <td class="codeline">  // 0x1p+126 < den <= 0x1p+127.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeline"></td>
    <td class="lineNumber">812</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeline">  Type *Ty = Src->getType();</td>
    <td class="lineNumber">813</td>
    <td class="codeline">  Type *Ty = Src->getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeline"></td>
    <td class="lineNumber">814</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeline">  auto [FrexpMant, FrexpExp] = getFrexpResults(Builder, Src);</td>
    <td class="lineNumber">815</td>
    <td class="codeline">  auto [FrexpMant, FrexpExp] = getFrexpResults(Builder, Src);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeline">  Value *ScaleFactor = Builder.CreateNeg(FrexpExp);</td>
    <td class="lineNumber">816</td>
    <td class="codeline">  Value *ScaleFactor = Builder.CreateNeg(FrexpExp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeline">  Value *Rcp = Builder.CreateUnaryIntrinsic(Intrinsic::amdgcn_rcp, FrexpMant);</td>
    <td class="lineNumber">817</td>
    <td class="codeline">  Value *Rcp = Builder.CreateUnaryIntrinsic(Intrinsic::amdgcn_rcp, FrexpMant);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeline">  return Builder.CreateIntrinsic(Intrinsic::ldexp, {Ty, Builder.getInt32Ty()},</td>
    <td class="lineNumber">818</td>
    <td class="codeline">  return Builder.CreateIntrinsic(Intrinsic::ldexp, {Ty, Builder.getInt32Ty()},</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeline">                                 {Rcp, ScaleFactor});</td>
    <td class="lineNumber">819</td>
    <td class="codeline">                                 {Rcp, ScaleFactor});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeline">}</td>
    <td class="lineNumber">820</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeline"></td>
    <td class="lineNumber">821</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeline">/// Emit a 2ulp expansion for fdiv by using frexp for input scaling.</td>
    <td class="lineNumber">822</td>
    <td class="codeline">/// Emit a 2ulp expansion for fdiv by using frexp for input scaling.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeline">Value *AMDGPUCodeGenPrepareImpl::emitFrexpDiv(IRBuilder<> &Builder, Value *LHS,</td>
    <td class="lineNumber">823</td>
    <td class="codeline">Value *AMDGPUCodeGenPrepareImpl::emitFrexpDiv(IRBuilder<> &Builder, Value *LHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeline">                                              Value *RHS,</td>
    <td class="lineNumber">824</td>
    <td class="codeline">                                              Value *RHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeline">                                              FastMathFlags FMF) const {</td>
    <td class="lineNumber">825</td>
    <td class="codeline">                                              FastMathFlags FMF) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeline">  // If we have have to work around the fract/frexp bug, we're worse off than</td>
    <td class="lineNumber">826</td>
    <td class="codeline">  // If we have have to work around the fract/frexp bug, we're worse off than</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeline">  // using the fdiv.fast expansion. The full safe expansion is faster if we have</td>
    <td class="lineNumber">827</td>
    <td class="codeline">  // using the fdiv.fast expansion. The full safe expansion is faster if we have</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeline">  // fast FMA.</td>
    <td class="lineNumber">828</td>
    <td class="codeline">  // fast FMA.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeline">  if (HasFP32DenormalFlush && ST->hasFractBug() && !ST->hasFastFMAF32() &&</td>
    <td class="lineNumber">829</td>
    <td class="codeline">  if (HasFP32DenormalFlush && ST->hasFractBug() && !ST->hasFastFMAF32() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeline">      (!FMF.noNaNs() || !FMF.noInfs()))</td>
    <td class="lineNumber">830</td>
    <td class="codeline">      (!FMF.noNaNs() || !FMF.noInfs()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">831</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeline"></td>
    <td class="lineNumber">832</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeline">  // We're scaling the LHS to avoid a denormal input, and scale the denominator</td>
    <td class="lineNumber">833</td>
    <td class="codeline">  // We're scaling the LHS to avoid a denormal input, and scale the denominator</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeline">  // to avoid large values underflowing the result.</td>
    <td class="lineNumber">834</td>
    <td class="codeline">  // to avoid large values underflowing the result.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeline">  Type *Ty = LHS->getType();</td>
    <td class="lineNumber">835</td>
    <td class="codeline">  Type *Ty = LHS->getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeline"></td>
    <td class="lineNumber">836</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeline">  auto [FrexpMantRHS, FrexpExpRHS] = getFrexpResults(Builder, RHS);</td>
    <td class="lineNumber">837</td>
    <td class="codeline">  auto [FrexpMantRHS, FrexpExpRHS] = getFrexpResults(Builder, RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeline"></td>
    <td class="lineNumber">838</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeline">  Value *Rcp =</td>
    <td class="lineNumber">839</td>
    <td class="codeline">  Value *Rcp =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeline">      Builder.CreateUnaryIntrinsic(Intrinsic::amdgcn_rcp, FrexpMantRHS);</td>
    <td class="lineNumber">840</td>
    <td class="codeline">      Builder.CreateUnaryIntrinsic(Intrinsic::amdgcn_rcp, FrexpMantRHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeline"></td>
    <td class="lineNumber">841</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeline">  auto [FrexpMantLHS, FrexpExpLHS] = getFrexpResults(Builder, LHS);</td>
    <td class="lineNumber">842</td>
    <td class="codeline">  auto [FrexpMantLHS, FrexpExpLHS] = getFrexpResults(Builder, LHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeline">  Value *Mul = Builder.CreateFMul(FrexpMantLHS, Rcp);</td>
    <td class="lineNumber">843</td>
    <td class="codeline">  Value *Mul = Builder.CreateFMul(FrexpMantLHS, Rcp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeline"></td>
    <td class="lineNumber">844</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeline">  // We multiplied by 2^N/2^M, so we need to multiply by 2^(N-M) to scale the</td>
    <td class="lineNumber">845</td>
    <td class="codeline">  // We multiplied by 2^N/2^M, so we need to multiply by 2^(N-M) to scale the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeline">  // result.</td>
    <td class="lineNumber">846</td>
    <td class="codeline">  // result.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeline">  Value *ExpDiff = Builder.CreateSub(FrexpExpLHS, FrexpExpRHS);</td>
    <td class="lineNumber">847</td>
    <td class="codeline">  Value *ExpDiff = Builder.CreateSub(FrexpExpLHS, FrexpExpRHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeline">  return Builder.CreateIntrinsic(Intrinsic::ldexp, {Ty, Builder.getInt32Ty()},</td>
    <td class="lineNumber">848</td>
    <td class="codeline">  return Builder.CreateIntrinsic(Intrinsic::ldexp, {Ty, Builder.getInt32Ty()},</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeline">                                 {Mul, ExpDiff});</td>
    <td class="lineNumber">849</td>
    <td class="codeline">                                 {Mul, ExpDiff});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeline">}</td>
    <td class="lineNumber">850</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeline"></td>
    <td class="lineNumber">851</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeline">/// Emit an expansion of 1.0 / sqrt(Src) good for 1ulp that supports denormals.</td>
    <td class="lineNumber">852</td>
    <td class="codeline">/// Emit an expansion of 1.0 / sqrt(Src) good for 1ulp that supports denormals.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeline">static Value *emitRsqIEEE1ULP(IRBuilder<> &Builder, Value *Src,</td>
    <td class="lineNumber">853</td>
    <td class="codeline">static Value *emitRsqIEEE1ULP(IRBuilder<> &Builder, Value *Src,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeline">                              bool IsNegative) {</td>
    <td class="lineNumber">854</td>
    <td class="codeline">                              bool IsNegative) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeline">  // bool need_scale = x < 0x1p-126f;</td>
    <td class="lineNumber">855</td>
    <td class="codeline">  // bool need_scale = x < 0x1p-126f;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeline">  // float input_scale = need_scale ? 0x1.0p+24f : 1.0f;</td>
    <td class="lineNumber">856</td>
    <td class="codeline">  // float input_scale = need_scale ? 0x1.0p+24f : 1.0f;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeline">  // float output_scale = need_scale ? 0x1.0p+12f : 1.0f;</td>
    <td class="lineNumber">857</td>
    <td class="codeline">  // float output_scale = need_scale ? 0x1.0p+12f : 1.0f;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeline">  // rsq(x * input_scale) * output_scale;</td>
    <td class="lineNumber">858</td>
    <td class="codeline">  // rsq(x * input_scale) * output_scale;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeline"></td>
    <td class="lineNumber">859</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeline">  Type *Ty = Src->getType();</td>
    <td class="lineNumber">860</td>
    <td class="codeline">  Type *Ty = Src->getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeline">  APFloat SmallestNormal =</td>
    <td class="lineNumber">861</td>
    <td class="codeline">  APFloat SmallestNormal =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeline">      APFloat::getSmallestNormalized(Ty->getFltSemantics());</td>
    <td class="lineNumber">862</td>
    <td class="codeline">      APFloat::getSmallestNormalized(Ty->getFltSemantics());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeline">  Value *NeedScale =</td>
    <td class="lineNumber">863</td>
    <td class="codeline">  Value *NeedScale =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeline">      Builder.CreateFCmpOLT(Src, ConstantFP::get(Ty, SmallestNormal));</td>
    <td class="lineNumber">864</td>
    <td class="codeline">      Builder.CreateFCmpOLT(Src, ConstantFP::get(Ty, SmallestNormal));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeline">  Constant *One = ConstantFP::get(Ty, 1.0);</td>
    <td class="lineNumber">865</td>
    <td class="codeline">  Constant *One = ConstantFP::get(Ty, 1.0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeline">  Constant *InputScale = ConstantFP::get(Ty, 0x1.0p+24);</td>
    <td class="lineNumber">866</td>
    <td class="codeline">  Constant *InputScale = ConstantFP::get(Ty, 0x1.0p+24);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeline">  Constant *OutputScale =</td>
    <td class="lineNumber">867</td>
    <td class="codeline">  Constant *OutputScale =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeline">      ConstantFP::get(Ty, IsNegative ? -0x1.0p+12 : 0x1.0p+12);</td>
    <td class="lineNumber">868</td>
    <td class="codeline">      ConstantFP::get(Ty, IsNegative ? -0x1.0p+12 : 0x1.0p+12);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeline"></td>
    <td class="lineNumber">869</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeline">  Value *InputScaleFactor = Builder.CreateSelect(NeedScale, InputScale, One);</td>
    <td class="lineNumber">870</td>
    <td class="codeline">  Value *InputScaleFactor = Builder.CreateSelect(NeedScale, InputScale, One);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeline"></td>
    <td class="lineNumber">871</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeline">  Value *ScaledInput = Builder.CreateFMul(Src, InputScaleFactor);</td>
    <td class="lineNumber">872</td>
    <td class="codeline">  Value *ScaledInput = Builder.CreateFMul(Src, InputScaleFactor);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeline">  Value *Rsq = Builder.CreateUnaryIntrinsic(Intrinsic::amdgcn_rsq, ScaledInput);</td>
    <td class="lineNumber">873</td>
    <td class="codeline">  Value *Rsq = Builder.CreateUnaryIntrinsic(Intrinsic::amdgcn_rsq, ScaledInput);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeline">  Value *OutputScaleFactor = Builder.CreateSelect(</td>
    <td class="lineNumber">874</td>
    <td class="codeline">  Value *OutputScaleFactor = Builder.CreateSelect(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeline">      NeedScale, OutputScale, IsNegative ? ConstantFP::get(Ty, -1.0) : One);</td>
    <td class="lineNumber">875</td>
    <td class="codeline">      NeedScale, OutputScale, IsNegative ? ConstantFP::get(Ty, -1.0) : One);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeline"></td>
    <td class="lineNumber">876</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeline">  return Builder.CreateFMul(Rsq, OutputScaleFactor);</td>
    <td class="lineNumber">877</td>
    <td class="codeline">  return Builder.CreateFMul(Rsq, OutputScaleFactor);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeline">}</td>
    <td class="lineNumber">878</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeline"></td>
    <td class="lineNumber">879</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::canOptimizeWithRsq(const FPMathOperator *SqrtOp,</td>
    <td class="lineNumber">880</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::canOptimizeWithRsq(const FPMathOperator *SqrtOp,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeline">                                                  FastMathFlags DivFMF,</td>
    <td class="lineNumber">881</td>
    <td class="codeline">                                                  FastMathFlags DivFMF,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeline">                                                  FastMathFlags SqrtFMF) const {</td>
    <td class="lineNumber">882</td>
    <td class="codeline">                                                  FastMathFlags SqrtFMF) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeline">  // The rsqrt contraction increases accuracy from ~2ulp to ~1ulp.</td>
    <td class="lineNumber">883</td>
    <td class="codeline">  // The rsqrt contraction increases accuracy from ~2ulp to ~1ulp.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeline">  if (!DivFMF.allowContract() || !SqrtFMF.allowContract())</td>
    <td class="lineNumber">884</td>
    <td class="codeline">  if (!DivFMF.allowContract() || !SqrtFMF.allowContract())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">885</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeline"></td>
    <td class="lineNumber">886</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeline">  // v_rsq_f32 gives 1ulp</td>
    <td class="lineNumber">887</td>
    <td class="codeline">  // v_rsq_f32 gives 1ulp</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeline">  return SqrtFMF.approxFunc() || HasUnsafeFPMath ||</td>
    <td class="lineNumber">888</td>
    <td class="codeline">  return SqrtFMF.approxFunc() || HasUnsafeFPMath ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeline">         SqrtOp->getFPAccuracy() >= 1.0f;</td>
    <td class="lineNumber">889</td>
    <td class="codeline">         SqrtOp->getFPAccuracy() >= 1.0f;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeline">}</td>
    <td class="lineNumber">890</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeline"></td>
    <td class="lineNumber">891</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeline">Value *AMDGPUCodeGenPrepareImpl::optimizeWithRsq(</td>
    <td class="lineNumber">892</td>
    <td class="codeline">Value *AMDGPUCodeGenPrepareImpl::optimizeWithRsq(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeline">    IRBuilder<> &Builder, Value *Num, Value *Den, FastMathFlags DivFMF,</td>
    <td class="lineNumber">893</td>
    <td class="codeline">    IRBuilder<> &Builder, Value *Num, Value *Den, FastMathFlags DivFMF,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeline">    FastMathFlags SqrtFMF, const Instruction *CtxI) const {</td>
    <td class="lineNumber">894</td>
    <td class="codeline">    FastMathFlags SqrtFMF, const Instruction *CtxI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeline">  // The rsqrt contraction increases accuracy from ~2ulp to ~1ulp.</td>
    <td class="lineNumber">895</td>
    <td class="codeline">  // The rsqrt contraction increases accuracy from ~2ulp to ~1ulp.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeline">  assert(DivFMF.allowContract() && SqrtFMF.allowContract());</td>
    <td class="lineNumber">896</td>
    <td class="codeline">  assert(DivFMF.allowContract() && SqrtFMF.allowContract());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeline"></td>
    <td class="lineNumber">897</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeline">  // rsq_f16 is accurate to 0.51 ulp.</td>
    <td class="lineNumber">898</td>
    <td class="codeline">  // rsq_f16 is accurate to 0.51 ulp.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeline">  // rsq_f32 is accurate for !fpmath >= 1.0ulp and denormals are flushed.</td>
    <td class="lineNumber">899</td>
    <td class="codeline">  // rsq_f32 is accurate for !fpmath >= 1.0ulp and denormals are flushed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeline">  // rsq_f64 is never accurate.</td>
    <td class="lineNumber">900</td>
    <td class="codeline">  // rsq_f64 is never accurate.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeline">  const ConstantFP *CLHS = dyn_cast<ConstantFP>(Num);</td>
    <td class="lineNumber">901</td>
    <td class="codeline">  const ConstantFP *CLHS = dyn_cast<ConstantFP>(Num);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeline">  if (!CLHS)</td>
    <td class="lineNumber">902</td>
    <td class="codeline">  if (!CLHS)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">903</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeline"></td>
    <td class="lineNumber">904</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeline">  assert(Den->getType()->isFloatTy());</td>
    <td class="lineNumber">905</td>
    <td class="codeline">  assert(Den->getType()->isFloatTy());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeline"></td>
    <td class="lineNumber">906</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeline">  bool IsNegative = false;</td>
    <td class="lineNumber">907</td>
    <td class="codeline">  bool IsNegative = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeline"></td>
    <td class="lineNumber">908</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeline">  // TODO: Handle other numerator values with arcp.</td>
    <td class="lineNumber">909</td>
    <td class="codeline">  // TODO: Handle other numerator values with arcp.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeline">  if (CLHS->isExactlyValue(1.0) || (IsNegative = CLHS->isExactlyValue(-1.0))) {</td>
    <td class="lineNumber">910</td>
    <td class="codeline">  if (CLHS->isExactlyValue(1.0) || (IsNegative = CLHS->isExactlyValue(-1.0))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeline">    // Add in the sqrt flags.</td>
    <td class="lineNumber">911</td>
    <td class="codeline">    // Add in the sqrt flags.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeline">    IRBuilder<>::FastMathFlagGuard Guard(Builder);</td>
    <td class="lineNumber">912</td>
    <td class="codeline">    IRBuilder<>::FastMathFlagGuard Guard(Builder);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeline">    DivFMF |= SqrtFMF;</td>
    <td class="lineNumber">913</td>
    <td class="codeline">    DivFMF |= SqrtFMF;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeline">    Builder.setFastMathFlags(DivFMF);</td>
    <td class="lineNumber">914</td>
    <td class="codeline">    Builder.setFastMathFlags(DivFMF);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeline"></td>
    <td class="lineNumber">915</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeline">    if ((DivFMF.approxFunc() && SqrtFMF.approxFunc()) ||</td>
    <td class="lineNumber">916</td>
    <td class="codeline">    if ((DivFMF.approxFunc() && SqrtFMF.approxFunc()) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeline">        canIgnoreDenormalInput(Den, CtxI)) {</td>
    <td class="lineNumber">917</td>
    <td class="codeline">        canIgnoreDenormalInput(Den, CtxI)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeline">      Value *Result = Builder.CreateUnaryIntrinsic(Intrinsic::amdgcn_rsq, Den);</td>
    <td class="lineNumber">918</td>
    <td class="codeline">      Value *Result = Builder.CreateUnaryIntrinsic(Intrinsic::amdgcn_rsq, Den);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeline">      // -1.0 / sqrt(x) -> fneg(rsq(x))</td>
    <td class="lineNumber">919</td>
    <td class="codeline">      // -1.0 / sqrt(x) -> fneg(rsq(x))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeline">      return IsNegative ? Builder.CreateFNeg(Result) : Result;</td>
    <td class="lineNumber">920</td>
    <td class="codeline">      return IsNegative ? Builder.CreateFNeg(Result) : Result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">921</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeline"></td>
    <td class="lineNumber">922</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeline">    return emitRsqIEEE1ULP(Builder, Den, IsNegative);</td>
    <td class="lineNumber">923</td>
    <td class="codeline">    return emitRsqIEEE1ULP(Builder, Den, IsNegative);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">924</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeline"></td>
    <td class="lineNumber">925</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeline">  return nullptr;</td>
    <td class="lineNumber">926</td>
    <td class="codeline">  return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeline">}</td>
    <td class="lineNumber">927</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeline"></td>
    <td class="lineNumber">928</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeline">// Optimize fdiv with rcp:</td>
    <td class="lineNumber">929</td>
    <td class="codeline">// Optimize fdiv with rcp:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeline">//</td>
    <td class="lineNumber">930</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeline">// 1/x -> rcp(x) when rcp is sufficiently accurate or inaccurate rcp is</td>
    <td class="lineNumber">931</td>
    <td class="codeline">// 1/x -> rcp(x) when rcp is sufficiently accurate or inaccurate rcp is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeline">//               allowed with unsafe-fp-math or afn.</td>
    <td class="lineNumber">932</td>
    <td class="codeline">//               allowed with unsafe-fp-math or afn.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeline">//</td>
    <td class="lineNumber">933</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeline">// a/b -> a*rcp(b) when arcp is allowed, and we only need provide ULP 1.0</td>
    <td class="lineNumber">934</td>
    <td class="codeline">// a/b -> a*rcp(b) when arcp is allowed, and we only need provide ULP 1.0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeline">Value *</td>
    <td class="lineNumber">935</td>
    <td class="codeline">Value *</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeline">AMDGPUCodeGenPrepareImpl::optimizeWithRcp(IRBuilder<> &Builder, Value *Num,</td>
    <td class="lineNumber">936</td>
    <td class="codeline">AMDGPUCodeGenPrepareImpl::optimizeWithRcp(IRBuilder<> &Builder, Value *Num,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeline">                                          Value *Den, FastMathFlags FMF,</td>
    <td class="lineNumber">937</td>
    <td class="codeline">                                          Value *Den, FastMathFlags FMF,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeline">                                          const Instruction *CtxI) const {</td>
    <td class="lineNumber">938</td>
    <td class="codeline">                                          const Instruction *CtxI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeline">  // rcp_f16 is accurate to 0.51 ulp.</td>
    <td class="lineNumber">939</td>
    <td class="codeline">  // rcp_f16 is accurate to 0.51 ulp.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeline">  // rcp_f32 is accurate for !fpmath >= 1.0ulp and denormals are flushed.</td>
    <td class="lineNumber">940</td>
    <td class="codeline">  // rcp_f32 is accurate for !fpmath >= 1.0ulp and denormals are flushed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeline">  // rcp_f64 is never accurate.</td>
    <td class="lineNumber">941</td>
    <td class="codeline">  // rcp_f64 is never accurate.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeline">  assert(Den->getType()->isFloatTy());</td>
    <td class="lineNumber">942</td>
    <td class="codeline">  assert(Den->getType()->isFloatTy());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeline"></td>
    <td class="lineNumber">943</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeline">  if (const ConstantFP *CLHS = dyn_cast<ConstantFP>(Num)) {</td>
    <td class="lineNumber">944</td>
    <td class="codeline">  if (const ConstantFP *CLHS = dyn_cast<ConstantFP>(Num)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeline">    bool IsNegative = false;</td>
    <td class="lineNumber">945</td>
    <td class="codeline">    bool IsNegative = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeline">    if (CLHS->isExactlyValue(1.0) ||</td>
    <td class="lineNumber">946</td>
    <td class="codeline">    if (CLHS->isExactlyValue(1.0) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeline">        (IsNegative = CLHS->isExactlyValue(-1.0))) {</td>
    <td class="lineNumber">947</td>
    <td class="codeline">        (IsNegative = CLHS->isExactlyValue(-1.0))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeline">      Value *Src = Den;</td>
    <td class="lineNumber">948</td>
    <td class="codeline">      Value *Src = Den;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeline"></td>
    <td class="lineNumber">949</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeline">      if (HasFP32DenormalFlush || FMF.approxFunc()) {</td>
    <td class="lineNumber">950</td>
    <td class="codeline">      if (HasFP32DenormalFlush || FMF.approxFunc()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeline">        // -1.0 / x -> 1.0 / fneg(x)</td>
    <td class="lineNumber">951</td>
    <td class="codeline">        // -1.0 / x -> 1.0 / fneg(x)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeline">        if (IsNegative)</td>
    <td class="lineNumber">952</td>
    <td class="codeline">        if (IsNegative)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeline">          Src = Builder.CreateFNeg(Src);</td>
    <td class="lineNumber">953</td>
    <td class="codeline">          Src = Builder.CreateFNeg(Src);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeline"></td>
    <td class="lineNumber">954</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeline">        // v_rcp_f32 and v_rsq_f32 do not support denormals, and according to</td>
    <td class="lineNumber">955</td>
    <td class="codeline">        // v_rcp_f32 and v_rsq_f32 do not support denormals, and according to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeline">        // the CI documentation has a worst case error of 1 ulp.</td>
    <td class="lineNumber">956</td>
    <td class="codeline">        // the CI documentation has a worst case error of 1 ulp.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeline">        // OpenCL requires <= 2.5 ulp for 1.0 / x, so it should always be OK</td>
    <td class="lineNumber">957</td>
    <td class="codeline">        // OpenCL requires <= 2.5 ulp for 1.0 / x, so it should always be OK</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeline">        // to use it as long as we aren't trying to use denormals.</td>
    <td class="lineNumber">958</td>
    <td class="codeline">        // to use it as long as we aren't trying to use denormals.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeline">        //</td>
    <td class="lineNumber">959</td>
    <td class="codeline">        //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeline">        // v_rcp_f16 and v_rsq_f16 DO support denormals.</td>
    <td class="lineNumber">960</td>
    <td class="codeline">        // v_rcp_f16 and v_rsq_f16 DO support denormals.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeline"></td>
    <td class="lineNumber">961</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeline">        // NOTE: v_sqrt and v_rcp will be combined to v_rsq later. So we don't</td>
    <td class="lineNumber">962</td>
    <td class="codeline">        // NOTE: v_sqrt and v_rcp will be combined to v_rsq later. So we don't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeline">        //       insert rsq intrinsic here.</td>
    <td class="lineNumber">963</td>
    <td class="codeline">        //       insert rsq intrinsic here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeline"></td>
    <td class="lineNumber">964</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeline">        // 1.0 / x -> rcp(x)</td>
    <td class="lineNumber">965</td>
    <td class="codeline">        // 1.0 / x -> rcp(x)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeline">        return Builder.CreateUnaryIntrinsic(Intrinsic::amdgcn_rcp, Src);</td>
    <td class="lineNumber">966</td>
    <td class="codeline">        return Builder.CreateUnaryIntrinsic(Intrinsic::amdgcn_rcp, Src);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">967</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeline"></td>
    <td class="lineNumber">968</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeline">      // TODO: If the input isn't denormal, and we know the input exponent isn't</td>
    <td class="lineNumber">969</td>
    <td class="codeline">      // TODO: If the input isn't denormal, and we know the input exponent isn't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeline">      // big enough to introduce a denormal we can avoid the scaling.</td>
    <td class="lineNumber">970</td>
    <td class="codeline">      // big enough to introduce a denormal we can avoid the scaling.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeline">      return emitRcpIEEE1ULP(Builder, Src, IsNegative);</td>
    <td class="lineNumber">971</td>
    <td class="codeline">      return emitRcpIEEE1ULP(Builder, Src, IsNegative);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">972</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">973</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeline"></td>
    <td class="lineNumber">974</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeline">  if (FMF.allowReciprocal()) {</td>
    <td class="lineNumber">975</td>
    <td class="codeline">  if (FMF.allowReciprocal()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeline">    // x / y -> x * (1.0 / y)</td>
    <td class="lineNumber">976</td>
    <td class="codeline">    // x / y -> x * (1.0 / y)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeline"></td>
    <td class="lineNumber">977</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeline">    // TODO: Could avoid denormal scaling and use raw rcp if we knew the output</td>
    <td class="lineNumber">978</td>
    <td class="codeline">    // TODO: Could avoid denormal scaling and use raw rcp if we knew the output</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeline">    // will never underflow.</td>
    <td class="lineNumber">979</td>
    <td class="codeline">    // will never underflow.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeline">    if (HasFP32DenormalFlush || FMF.approxFunc()) {</td>
    <td class="lineNumber">980</td>
    <td class="codeline">    if (HasFP32DenormalFlush || FMF.approxFunc()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeline">      Value *Recip = Builder.CreateUnaryIntrinsic(Intrinsic::amdgcn_rcp, Den);</td>
    <td class="lineNumber">981</td>
    <td class="codeline">      Value *Recip = Builder.CreateUnaryIntrinsic(Intrinsic::amdgcn_rcp, Den);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeline">      return Builder.CreateFMul(Num, Recip);</td>
    <td class="lineNumber">982</td>
    <td class="codeline">      return Builder.CreateFMul(Num, Recip);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">983</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeline"></td>
    <td class="lineNumber">984</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeline">    Value *Recip = emitRcpIEEE1ULP(Builder, Den, false);</td>
    <td class="lineNumber">985</td>
    <td class="codeline">    Value *Recip = emitRcpIEEE1ULP(Builder, Den, false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeline">    return Builder.CreateFMul(Num, Recip);</td>
    <td class="lineNumber">986</td>
    <td class="codeline">    return Builder.CreateFMul(Num, Recip);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">987</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeline"></td>
    <td class="lineNumber">988</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeline">  return nullptr;</td>
    <td class="lineNumber">989</td>
    <td class="codeline">  return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeline">}</td>
    <td class="lineNumber">990</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeline"></td>
    <td class="lineNumber">991</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeline">// optimize with fdiv.fast:</td>
    <td class="lineNumber">992</td>
    <td class="codeline">// optimize with fdiv.fast:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeline">//</td>
    <td class="lineNumber">993</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeline">// a/b -> fdiv.fast(a, b) when !fpmath >= 2.5ulp with denormals flushed.</td>
    <td class="lineNumber">994</td>
    <td class="codeline">// a/b -> fdiv.fast(a, b) when !fpmath >= 2.5ulp with denormals flushed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeline">//</td>
    <td class="lineNumber">995</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeline">// 1/x -> fdiv.fast(1,x)  when !fpmath >= 2.5ulp.</td>
    <td class="lineNumber">996</td>
    <td class="codeline">// 1/x -> fdiv.fast(1,x)  when !fpmath >= 2.5ulp.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeline">//</td>
    <td class="lineNumber">997</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeline">// NOTE: optimizeWithRcp should be tried first because rcp is the preference.</td>
    <td class="lineNumber">998</td>
    <td class="codeline">// NOTE: optimizeWithRcp should be tried first because rcp is the preference.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeline">Value *AMDGPUCodeGenPrepareImpl::optimizeWithFDivFast(</td>
    <td class="lineNumber">999</td>
    <td class="codeline">Value *AMDGPUCodeGenPrepareImpl::optimizeWithFDivFast(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeline">    IRBuilder<> &Builder, Value *Num, Value *Den, float ReqdAccuracy) const {</td>
    <td class="lineNumber">1000</td>
    <td class="codeline">    IRBuilder<> &Builder, Value *Num, Value *Den, float ReqdAccuracy) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeline">  // fdiv.fast can achieve 2.5 ULP accuracy.</td>
    <td class="lineNumber">1001</td>
    <td class="codeline">  // fdiv.fast can achieve 2.5 ULP accuracy.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeline">  if (ReqdAccuracy < 2.5f)</td>
    <td class="lineNumber">1002</td>
    <td class="codeline">  if (ReqdAccuracy < 2.5f)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">1003</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeline"></td>
    <td class="lineNumber">1004</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeline">  // Only have fdiv.fast for f32.</td>
    <td class="lineNumber">1005</td>
    <td class="codeline">  // Only have fdiv.fast for f32.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeline">  assert(Den->getType()->isFloatTy());</td>
    <td class="lineNumber">1006</td>
    <td class="codeline">  assert(Den->getType()->isFloatTy());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeline"></td>
    <td class="lineNumber">1007</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeline">  bool NumIsOne = false;</td>
    <td class="lineNumber">1008</td>
    <td class="codeline">  bool NumIsOne = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeline">  if (const ConstantFP *CNum = dyn_cast<ConstantFP>(Num)) {</td>
    <td class="lineNumber">1009</td>
    <td class="codeline">  if (const ConstantFP *CNum = dyn_cast<ConstantFP>(Num)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeline">    if (CNum->isExactlyValue(+1.0) || CNum->isExactlyValue(-1.0))</td>
    <td class="lineNumber">1010</td>
    <td class="codeline">    if (CNum->isExactlyValue(+1.0) || CNum->isExactlyValue(-1.0))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeline">      NumIsOne = true;</td>
    <td class="lineNumber">1011</td>
    <td class="codeline">      NumIsOne = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1012</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeline"></td>
    <td class="lineNumber">1013</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeline">  // fdiv does not support denormals. But 1.0/x is always fine to use it.</td>
    <td class="lineNumber">1014</td>
    <td class="codeline">  // fdiv does not support denormals. But 1.0/x is always fine to use it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1015</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeline">  // TODO: This works for any value with a specific known exponent range, don't</td>
    <td class="lineNumber">1016</td>
    <td class="codeline">  // TODO: This works for any value with a specific known exponent range, don't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeline">  // just limit to constant 1.</td>
    <td class="lineNumber">1017</td>
    <td class="codeline">  // just limit to constant 1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeline">  if (!HasFP32DenormalFlush && !NumIsOne)</td>
    <td class="lineNumber">1018</td>
    <td class="codeline">  if (!HasFP32DenormalFlush && !NumIsOne)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">1019</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeline"></td>
    <td class="lineNumber">1020</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeline">  return Builder.CreateIntrinsic(Intrinsic::amdgcn_fdiv_fast, {}, {Num, Den});</td>
    <td class="lineNumber">1021</td>
    <td class="codeline">  return Builder.CreateIntrinsic(Intrinsic::amdgcn_fdiv_fast, {}, {Num, Den});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1022</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeline"></td>
    <td class="lineNumber">1023</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeline">Value *AMDGPUCodeGenPrepareImpl::visitFDivElement(</td>
    <td class="lineNumber">1024</td>
    <td class="codeline">Value *AMDGPUCodeGenPrepareImpl::visitFDivElement(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeline">    IRBuilder<> &Builder, Value *Num, Value *Den, FastMathFlags DivFMF,</td>
    <td class="lineNumber">1025</td>
    <td class="codeline">    IRBuilder<> &Builder, Value *Num, Value *Den, FastMathFlags DivFMF,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeline">    FastMathFlags SqrtFMF, Value *RsqOp, const Instruction *FDivInst,</td>
    <td class="lineNumber">1026</td>
    <td class="codeline">    FastMathFlags SqrtFMF, Value *RsqOp, const Instruction *FDivInst,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeline">    float ReqdDivAccuracy) const {</td>
    <td class="lineNumber">1027</td>
    <td class="codeline">    float ReqdDivAccuracy) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeline">  if (RsqOp) {</td>
    <td class="lineNumber">1028</td>
    <td class="codeline">  if (RsqOp) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeline">    Value *Rsq =</td>
    <td class="lineNumber">1029</td>
    <td class="codeline">    Value *Rsq =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeline">        optimizeWithRsq(Builder, Num, RsqOp, DivFMF, SqrtFMF, FDivInst);</td>
    <td class="lineNumber">1030</td>
    <td class="codeline">        optimizeWithRsq(Builder, Num, RsqOp, DivFMF, SqrtFMF, FDivInst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeline">    if (Rsq)</td>
    <td class="lineNumber">1031</td>
    <td class="codeline">    if (Rsq)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeline">      return Rsq;</td>
    <td class="lineNumber">1032</td>
    <td class="codeline">      return Rsq;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1033</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeline"></td>
    <td class="lineNumber">1034</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeline">  Value *Rcp = optimizeWithRcp(Builder, Num, Den, DivFMF, FDivInst);</td>
    <td class="lineNumber">1035</td>
    <td class="codeline">  Value *Rcp = optimizeWithRcp(Builder, Num, Den, DivFMF, FDivInst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeline">  if (Rcp)</td>
    <td class="lineNumber">1036</td>
    <td class="codeline">  if (Rcp)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeline">    return Rcp;</td>
    <td class="lineNumber">1037</td>
    <td class="codeline">    return Rcp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeline"></td>
    <td class="lineNumber">1038</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeline">  // In the basic case fdiv_fast has the same instruction count as the frexp div</td>
    <td class="lineNumber">1039</td>
    <td class="codeline">  // In the basic case fdiv_fast has the same instruction count as the frexp div</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeline">  // expansion. Slightly prefer fdiv_fast since it ends in an fmul that can</td>
    <td class="lineNumber">1040</td>
    <td class="codeline">  // expansion. Slightly prefer fdiv_fast since it ends in an fmul that can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeline">  // potentially be fused into a user. Also, materialization of the constants</td>
    <td class="lineNumber">1041</td>
    <td class="codeline">  // potentially be fused into a user. Also, materialization of the constants</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeline">  // can be reused for multiple instances.</td>
    <td class="lineNumber">1042</td>
    <td class="codeline">  // can be reused for multiple instances.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeline">  Value *FDivFast = optimizeWithFDivFast(Builder, Num, Den, ReqdDivAccuracy);</td>
    <td class="lineNumber">1043</td>
    <td class="codeline">  Value *FDivFast = optimizeWithFDivFast(Builder, Num, Den, ReqdDivAccuracy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeline">  if (FDivFast)</td>
    <td class="lineNumber">1044</td>
    <td class="codeline">  if (FDivFast)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeline">    return FDivFast;</td>
    <td class="lineNumber">1045</td>
    <td class="codeline">    return FDivFast;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeline"></td>
    <td class="lineNumber">1046</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeline">  return emitFrexpDiv(Builder, Num, Den, DivFMF);</td>
    <td class="lineNumber">1047</td>
    <td class="codeline">  return emitFrexpDiv(Builder, Num, Den, DivFMF);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1048</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeline"></td>
    <td class="lineNumber">1049</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeline">// Optimizations is performed based on fpmath, fast math flags as well as</td>
    <td class="lineNumber">1050</td>
    <td class="codeline">// Optimizations is performed based on fpmath, fast math flags as well as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeline">// denormals to optimize fdiv with either rcp or fdiv.fast.</td>
    <td class="lineNumber">1051</td>
    <td class="codeline">// denormals to optimize fdiv with either rcp or fdiv.fast.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeline">//</td>
    <td class="lineNumber">1052</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeline">// With rcp:</td>
    <td class="lineNumber">1053</td>
    <td class="codeline">// With rcp:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeline">//   1/x -> rcp(x) when rcp is sufficiently accurate or inaccurate rcp is</td>
    <td class="lineNumber">1054</td>
    <td class="codeline">//   1/x -> rcp(x) when rcp is sufficiently accurate or inaccurate rcp is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeline">//                 allowed with unsafe-fp-math or afn.</td>
    <td class="lineNumber">1055</td>
    <td class="codeline">//                 allowed with unsafe-fp-math or afn.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeline">//</td>
    <td class="lineNumber">1056</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeline">//   a/b -> a*rcp(b) when inaccurate rcp is allowed with unsafe-fp-math or afn.</td>
    <td class="lineNumber">1057</td>
    <td class="codeline">//   a/b -> a*rcp(b) when inaccurate rcp is allowed with unsafe-fp-math or afn.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeline">//</td>
    <td class="lineNumber">1058</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeline">// With fdiv.fast:</td>
    <td class="lineNumber">1059</td>
    <td class="codeline">// With fdiv.fast:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeline">//   a/b -> fdiv.fast(a, b) when !fpmath >= 2.5ulp with denormals flushed.</td>
    <td class="lineNumber">1060</td>
    <td class="codeline">//   a/b -> fdiv.fast(a, b) when !fpmath >= 2.5ulp with denormals flushed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeline">//</td>
    <td class="lineNumber">1061</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeline">//   1/x -> fdiv.fast(1,x)  when !fpmath >= 2.5ulp.</td>
    <td class="lineNumber">1062</td>
    <td class="codeline">//   1/x -> fdiv.fast(1,x)  when !fpmath >= 2.5ulp.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeline">//</td>
    <td class="lineNumber">1063</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeline">// NOTE: rcp is the preference in cases that both are legal.</td>
    <td class="lineNumber">1064</td>
    <td class="codeline">// NOTE: rcp is the preference in cases that both are legal.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::visitFDiv(BinaryOperator &FDiv) {</td>
    <td class="lineNumber">1065</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::visitFDiv(BinaryOperator &FDiv) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeline">  if (DisableFDivExpand)</td>
    <td class="lineNumber">1066</td>
    <td class="codeline">  if (DisableFDivExpand)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1067</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeline"></td>
    <td class="lineNumber">1068</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeline">  Type *Ty = FDiv.getType()->getScalarType();</td>
    <td class="lineNumber">1069</td>
    <td class="codeline">  Type *Ty = FDiv.getType()->getScalarType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeline">  if (!Ty->isFloatTy())</td>
    <td class="lineNumber">1070</td>
    <td class="codeline">  if (!Ty->isFloatTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1071</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeline"></td>
    <td class="lineNumber">1072</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeline">  // The f64 rcp/rsq approximations are pretty inaccurate. We can do an</td>
    <td class="lineNumber">1073</td>
    <td class="codeline">  // The f64 rcp/rsq approximations are pretty inaccurate. We can do an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeline">  // expansion around them in codegen. f16 is good enough to always use.</td>
    <td class="lineNumber">1074</td>
    <td class="codeline">  // expansion around them in codegen. f16 is good enough to always use.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeline"></td>
    <td class="lineNumber">1075</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeline">  const FPMathOperator *FPOp = cast<const FPMathOperator>(&FDiv);</td>
    <td class="lineNumber">1076</td>
    <td class="codeline">  const FPMathOperator *FPOp = cast<const FPMathOperator>(&FDiv);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeline">  const FastMathFlags DivFMF = FPOp->getFastMathFlags();</td>
    <td class="lineNumber">1077</td>
    <td class="codeline">  const FastMathFlags DivFMF = FPOp->getFastMathFlags();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeline">  const float ReqdAccuracy = FPOp->getFPAccuracy();</td>
    <td class="lineNumber">1078</td>
    <td class="codeline">  const float ReqdAccuracy = FPOp->getFPAccuracy();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeline"></td>
    <td class="lineNumber">1079</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeline">  // Inaccurate rcp is allowed with unsafe-fp-math or afn.</td>
    <td class="lineNumber">1080</td>
    <td class="codeline">  // Inaccurate rcp is allowed with unsafe-fp-math or afn.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1081</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeline">  // Defer to codegen to handle this.</td>
    <td class="lineNumber">1082</td>
    <td class="codeline">  // Defer to codegen to handle this.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1083</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeline">  // TODO: Decide on an interpretation for interactions between afn + arcp +</td>
    <td class="lineNumber">1084</td>
    <td class="codeline">  // TODO: Decide on an interpretation for interactions between afn + arcp +</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeline">  // !fpmath, and make it consistent between here and codegen. For now, defer</td>
    <td class="lineNumber">1085</td>
    <td class="codeline">  // !fpmath, and make it consistent between here and codegen. For now, defer</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeline">  // expansion of afn to codegen. The current interpretation is so aggressive we</td>
    <td class="lineNumber">1086</td>
    <td class="codeline">  // expansion of afn to codegen. The current interpretation is so aggressive we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeline">  // don't need any pre-consideration here when we have better information. A</td>
    <td class="lineNumber">1087</td>
    <td class="codeline">  // don't need any pre-consideration here when we have better information. A</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeline">  // more conservative interpretation could use handling here.</td>
    <td class="lineNumber">1088</td>
    <td class="codeline">  // more conservative interpretation could use handling here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeline">  const bool AllowInaccurateRcp = HasUnsafeFPMath || DivFMF.approxFunc();</td>
    <td class="lineNumber">1089</td>
    <td class="codeline">  const bool AllowInaccurateRcp = HasUnsafeFPMath || DivFMF.approxFunc();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeline">  if (AllowInaccurateRcp)</td>
    <td class="lineNumber">1090</td>
    <td class="codeline">  if (AllowInaccurateRcp)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1091</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeline"></td>
    <td class="lineNumber">1092</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeline">  // Defer the correct implementations to codegen.</td>
    <td class="lineNumber">1093</td>
    <td class="codeline">  // Defer the correct implementations to codegen.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeline">  if (ReqdAccuracy < 1.0f)</td>
    <td class="lineNumber">1094</td>
    <td class="codeline">  if (ReqdAccuracy < 1.0f)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1095</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeline"></td>
    <td class="lineNumber">1096</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeline">  FastMathFlags SqrtFMF;</td>
    <td class="lineNumber">1097</td>
    <td class="codeline">  FastMathFlags SqrtFMF;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeline"></td>
    <td class="lineNumber">1098</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeline">  Value *Num = FDiv.getOperand(0);</td>
    <td class="lineNumber">1099</td>
    <td class="codeline">  Value *Num = FDiv.getOperand(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeline">  Value *Den = FDiv.getOperand(1);</td>
    <td class="lineNumber">1100</td>
    <td class="codeline">  Value *Den = FDiv.getOperand(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeline"></td>
    <td class="lineNumber">1101</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeline">  Value *RsqOp = nullptr;</td>
    <td class="lineNumber">1102</td>
    <td class="codeline">  Value *RsqOp = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeline">  auto *DenII = dyn_cast<IntrinsicInst>(Den);</td>
    <td class="lineNumber">1103</td>
    <td class="codeline">  auto *DenII = dyn_cast<IntrinsicInst>(Den);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeline">  if (DenII && DenII->getIntrinsicID() == Intrinsic::sqrt &&</td>
    <td class="lineNumber">1104</td>
    <td class="codeline">  if (DenII && DenII->getIntrinsicID() == Intrinsic::sqrt &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeline">      DenII->hasOneUse()) {</td>
    <td class="lineNumber">1105</td>
    <td class="codeline">      DenII->hasOneUse()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeline">    const auto *SqrtOp = cast<FPMathOperator>(DenII);</td>
    <td class="lineNumber">1106</td>
    <td class="codeline">    const auto *SqrtOp = cast<FPMathOperator>(DenII);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeline">    SqrtFMF = SqrtOp->getFastMathFlags();</td>
    <td class="lineNumber">1107</td>
    <td class="codeline">    SqrtFMF = SqrtOp->getFastMathFlags();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeline">    if (canOptimizeWithRsq(SqrtOp, DivFMF, SqrtFMF))</td>
    <td class="lineNumber">1108</td>
    <td class="codeline">    if (canOptimizeWithRsq(SqrtOp, DivFMF, SqrtFMF))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeline">      RsqOp = SqrtOp->getOperand(0);</td>
    <td class="lineNumber">1109</td>
    <td class="codeline">      RsqOp = SqrtOp->getOperand(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1110</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeline"></td>
    <td class="lineNumber">1111</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeline">  IRBuilder<> Builder(FDiv.getParent(), std::next(FDiv.getIterator()));</td>
    <td class="lineNumber">1112</td>
    <td class="codeline">  IRBuilder<> Builder(FDiv.getParent(), std::next(FDiv.getIterator()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeline">  Builder.setFastMathFlags(DivFMF);</td>
    <td class="lineNumber">1113</td>
    <td class="codeline">  Builder.setFastMathFlags(DivFMF);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeline">  Builder.SetCurrentDebugLocation(FDiv.getDebugLoc());</td>
    <td class="lineNumber">1114</td>
    <td class="codeline">  Builder.SetCurrentDebugLocation(FDiv.getDebugLoc());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeline"></td>
    <td class="lineNumber">1115</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeline">  SmallVector<Value *, 4> NumVals;</td>
    <td class="lineNumber">1116</td>
    <td class="codeline">  SmallVector<Value *, 4> NumVals;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeline">  SmallVector<Value *, 4> DenVals;</td>
    <td class="lineNumber">1117</td>
    <td class="codeline">  SmallVector<Value *, 4> DenVals;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeline">  SmallVector<Value *, 4> RsqDenVals;</td>
    <td class="lineNumber">1118</td>
    <td class="codeline">  SmallVector<Value *, 4> RsqDenVals;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeline">  extractValues(Builder, NumVals, Num);</td>
    <td class="lineNumber">1119</td>
    <td class="codeline">  extractValues(Builder, NumVals, Num);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeline">  extractValues(Builder, DenVals, Den);</td>
    <td class="lineNumber">1120</td>
    <td class="codeline">  extractValues(Builder, DenVals, Den);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeline"></td>
    <td class="lineNumber">1121</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeline">  if (RsqOp)</td>
    <td class="lineNumber">1122</td>
    <td class="codeline">  if (RsqOp)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeline">    extractValues(Builder, RsqDenVals, RsqOp);</td>
    <td class="lineNumber">1123</td>
    <td class="codeline">    extractValues(Builder, RsqDenVals, RsqOp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeline"></td>
    <td class="lineNumber">1124</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeline">  SmallVector<Value *, 4> ResultVals(NumVals.size());</td>
    <td class="lineNumber">1125</td>
    <td class="codeline">  SmallVector<Value *, 4> ResultVals(NumVals.size());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeline">  for (int I = 0, E = NumVals.size(); I != E; ++I) {</td>
    <td class="lineNumber">1126</td>
    <td class="codeline">  for (int I = 0, E = NumVals.size(); I != E; ++I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeline">    Value *NumElt = NumVals[I];</td>
    <td class="lineNumber">1127</td>
    <td class="codeline">    Value *NumElt = NumVals[I];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeline">    Value *DenElt = DenVals[I];</td>
    <td class="lineNumber">1128</td>
    <td class="codeline">    Value *DenElt = DenVals[I];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeline">    Value *RsqDenElt = RsqOp ? RsqDenVals[I] : nullptr;</td>
    <td class="lineNumber">1129</td>
    <td class="codeline">    Value *RsqDenElt = RsqOp ? RsqDenVals[I] : nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeline"></td>
    <td class="lineNumber">1130</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeline">    Value *NewElt =</td>
    <td class="lineNumber">1131</td>
    <td class="codeline">    Value *NewElt =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeline">        visitFDivElement(Builder, NumElt, DenElt, DivFMF, SqrtFMF, RsqDenElt,</td>
    <td class="lineNumber">1132</td>
    <td class="codeline">        visitFDivElement(Builder, NumElt, DenElt, DivFMF, SqrtFMF, RsqDenElt,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeline">                         cast<Instruction>(FPOp), ReqdAccuracy);</td>
    <td class="lineNumber">1133</td>
    <td class="codeline">                         cast<Instruction>(FPOp), ReqdAccuracy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeline">    if (!NewElt) {</td>
    <td class="lineNumber">1134</td>
    <td class="codeline">    if (!NewElt) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeline">      // Keep the original, but scalarized.</td>
    <td class="lineNumber">1135</td>
    <td class="codeline">      // Keep the original, but scalarized.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeline"></td>
    <td class="lineNumber">1136</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeline">      // This has the unfortunate side effect of sometimes scalarizing when</td>
    <td class="lineNumber">1137</td>
    <td class="codeline">      // This has the unfortunate side effect of sometimes scalarizing when</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeline">      // we're not going to do anything.</td>
    <td class="lineNumber">1138</td>
    <td class="codeline">      // we're not going to do anything.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeline">      NewElt = Builder.CreateFDiv(NumElt, DenElt);</td>
    <td class="lineNumber">1139</td>
    <td class="codeline">      NewElt = Builder.CreateFDiv(NumElt, DenElt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeline">      if (auto *NewEltInst = dyn_cast<Instruction>(NewElt))</td>
    <td class="lineNumber">1140</td>
    <td class="codeline">      if (auto *NewEltInst = dyn_cast<Instruction>(NewElt))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeline">        NewEltInst->copyMetadata(FDiv);</td>
    <td class="lineNumber">1141</td>
    <td class="codeline">        NewEltInst->copyMetadata(FDiv);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1142</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeline"></td>
    <td class="lineNumber">1143</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeline">    ResultVals[I] = NewElt;</td>
    <td class="lineNumber">1144</td>
    <td class="codeline">    ResultVals[I] = NewElt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1145</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeline"></td>
    <td class="lineNumber">1146</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeline">  Value *NewVal = insertValues(Builder, FDiv.getType(), ResultVals);</td>
    <td class="lineNumber">1147</td>
    <td class="codeline">  Value *NewVal = insertValues(Builder, FDiv.getType(), ResultVals);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeline"></td>
    <td class="lineNumber">1148</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeline">  if (NewVal) {</td>
    <td class="lineNumber">1149</td>
    <td class="codeline">  if (NewVal) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeline">    FDiv.replaceAllUsesWith(NewVal);</td>
    <td class="lineNumber">1150</td>
    <td class="codeline">    FDiv.replaceAllUsesWith(NewVal);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeline">    NewVal->takeName(&FDiv);</td>
    <td class="lineNumber">1151</td>
    <td class="codeline">    NewVal->takeName(&FDiv);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeline">    RecursivelyDeleteTriviallyDeadInstructions(&FDiv, TLInfo);</td>
    <td class="lineNumber">1152</td>
    <td class="codeline">    RecursivelyDeleteTriviallyDeadInstructions(&FDiv, TLInfo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1153</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeline"></td>
    <td class="lineNumber">1154</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">1155</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1156</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeline"></td>
    <td class="lineNumber">1157</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeline">static bool hasUnsafeFPMath(const Function &F) {</td>
    <td class="lineNumber">1158</td>
    <td class="codeline">static bool hasUnsafeFPMath(const Function &F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeline">  Attribute Attr = F.getFnAttribute("unsafe-fp-math");</td>
    <td class="lineNumber">1159</td>
    <td class="codeline">  Attribute Attr = F.getFnAttribute("unsafe-fp-math");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeline">  return Attr.getValueAsBool();</td>
    <td class="lineNumber">1160</td>
    <td class="codeline">  return Attr.getValueAsBool();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1161</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeline"></td>
    <td class="lineNumber">1162</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeline">static std::pair<Value*, Value*> getMul64(IRBuilder<> &Builder,</td>
    <td class="lineNumber">1163</td>
    <td class="codeline">static std::pair<Value*, Value*> getMul64(IRBuilder<> &Builder,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeline">                                          Value *LHS, Value *RHS) {</td>
    <td class="lineNumber">1164</td>
    <td class="codeline">                                          Value *LHS, Value *RHS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeline">  Type *I32Ty = Builder.getInt32Ty();</td>
    <td class="lineNumber">1165</td>
    <td class="codeline">  Type *I32Ty = Builder.getInt32Ty();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeline">  Type *I64Ty = Builder.getInt64Ty();</td>
    <td class="lineNumber">1166</td>
    <td class="codeline">  Type *I64Ty = Builder.getInt64Ty();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeline"></td>
    <td class="lineNumber">1167</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeline">  Value *LHS_EXT64 = Builder.CreateZExt(LHS, I64Ty);</td>
    <td class="lineNumber">1168</td>
    <td class="codeline">  Value *LHS_EXT64 = Builder.CreateZExt(LHS, I64Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeline">  Value *RHS_EXT64 = Builder.CreateZExt(RHS, I64Ty);</td>
    <td class="lineNumber">1169</td>
    <td class="codeline">  Value *RHS_EXT64 = Builder.CreateZExt(RHS, I64Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeline">  Value *MUL64 = Builder.CreateMul(LHS_EXT64, RHS_EXT64);</td>
    <td class="lineNumber">1170</td>
    <td class="codeline">  Value *MUL64 = Builder.CreateMul(LHS_EXT64, RHS_EXT64);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeline">  Value *Lo = Builder.CreateTrunc(MUL64, I32Ty);</td>
    <td class="lineNumber">1171</td>
    <td class="codeline">  Value *Lo = Builder.CreateTrunc(MUL64, I32Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeline">  Value *Hi = Builder.CreateLShr(MUL64, Builder.getInt64(32));</td>
    <td class="lineNumber">1172</td>
    <td class="codeline">  Value *Hi = Builder.CreateLShr(MUL64, Builder.getInt64(32));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeline">  Hi = Builder.CreateTrunc(Hi, I32Ty);</td>
    <td class="lineNumber">1173</td>
    <td class="codeline">  Hi = Builder.CreateTrunc(Hi, I32Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeline">  return std::pair(Lo, Hi);</td>
    <td class="lineNumber">1174</td>
    <td class="codeline">  return std::pair(Lo, Hi);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1175</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeline"></td>
    <td class="lineNumber">1176</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeline">static Value* getMulHu(IRBuilder<> &Builder, Value *LHS, Value *RHS) {</td>
    <td class="lineNumber">1177</td>
    <td class="codeline">static Value* getMulHu(IRBuilder<> &Builder, Value *LHS, Value *RHS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeline">  return getMul64(Builder, LHS, RHS).second;</td>
    <td class="lineNumber">1178</td>
    <td class="codeline">  return getMul64(Builder, LHS, RHS).second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1179</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeline"></td>
    <td class="lineNumber">1180</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeline">/// Figure out how many bits are really needed for this division. \p AtLeast is</td>
    <td class="lineNumber">1181</td>
    <td class="codeline">/// Figure out how many bits are really needed for this division. \p AtLeast is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeline">/// an optimization hint to bypass the second ComputeNumSignBits call if we the</td>
    <td class="lineNumber">1182</td>
    <td class="codeline">/// an optimization hint to bypass the second ComputeNumSignBits call if we the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeline">/// first one is insufficient. Returns -1 on failure.</td>
    <td class="lineNumber">1183</td>
    <td class="codeline">/// first one is insufficient. Returns -1 on failure.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeline">int AMDGPUCodeGenPrepareImpl::getDivNumBits(BinaryOperator &I, Value *Num,</td>
    <td class="lineNumber">1184</td>
    <td class="codeline">int AMDGPUCodeGenPrepareImpl::getDivNumBits(BinaryOperator &I, Value *Num,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeline">                                            Value *Den, unsigned AtLeast,</td>
    <td class="lineNumber">1185</td>
    <td class="codeline">                                            Value *Den, unsigned AtLeast,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeline">                                            bool IsSigned) const {</td>
    <td class="lineNumber">1186</td>
    <td class="codeline">                                            bool IsSigned) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeline">  const DataLayout &DL = Mod->getDataLayout();</td>
    <td class="lineNumber">1187</td>
    <td class="codeline">  const DataLayout &DL = Mod->getDataLayout();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeline">  unsigned LHSSignBits = ComputeNumSignBits(Num, DL, 0, AC, &I);</td>
    <td class="lineNumber">1188</td>
    <td class="codeline">  unsigned LHSSignBits = ComputeNumSignBits(Num, DL, 0, AC, &I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeline">  if (LHSSignBits < AtLeast)</td>
    <td class="lineNumber">1189</td>
    <td class="codeline">  if (LHSSignBits < AtLeast)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeline">    return -1;</td>
    <td class="lineNumber">1190</td>
    <td class="codeline">    return -1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeline"></td>
    <td class="lineNumber">1191</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeline">  unsigned RHSSignBits = ComputeNumSignBits(Den, DL, 0, AC, &I);</td>
    <td class="lineNumber">1192</td>
    <td class="codeline">  unsigned RHSSignBits = ComputeNumSignBits(Den, DL, 0, AC, &I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeline">  if (RHSSignBits < AtLeast)</td>
    <td class="lineNumber">1193</td>
    <td class="codeline">  if (RHSSignBits < AtLeast)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeline">    return -1;</td>
    <td class="lineNumber">1194</td>
    <td class="codeline">    return -1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeline"></td>
    <td class="lineNumber">1195</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeline">  unsigned SignBits = std::min(LHSSignBits, RHSSignBits);</td>
    <td class="lineNumber">1196</td>
    <td class="codeline">  unsigned SignBits = std::min(LHSSignBits, RHSSignBits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeline">  unsigned DivBits = Num->getType()->getScalarSizeInBits() - SignBits;</td>
    <td class="lineNumber">1197</td>
    <td class="codeline">  unsigned DivBits = Num->getType()->getScalarSizeInBits() - SignBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeline">  if (IsSigned)</td>
    <td class="lineNumber">1198</td>
    <td class="codeline">  if (IsSigned)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeline">    ++DivBits;</td>
    <td class="lineNumber">1199</td>
    <td class="codeline">    ++DivBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeline">  return DivBits;</td>
    <td class="lineNumber">1200</td>
    <td class="codeline">  return DivBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1201</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeline"></td>
    <td class="lineNumber">1202</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeline">// The fractional part of a float is enough to accurately represent up to</td>
    <td class="lineNumber">1203</td>
    <td class="codeline">// The fractional part of a float is enough to accurately represent up to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeline">// a 24-bit signed integer.</td>
    <td class="lineNumber">1204</td>
    <td class="codeline">// a 24-bit signed integer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeline">Value *AMDGPUCodeGenPrepareImpl::expandDivRem24(IRBuilder<> &Builder,</td>
    <td class="lineNumber">1205</td>
    <td class="codeline">Value *AMDGPUCodeGenPrepareImpl::expandDivRem24(IRBuilder<> &Builder,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeline">                                                BinaryOperator &I, Value *Num,</td>
    <td class="lineNumber">1206</td>
    <td class="codeline">                                                BinaryOperator &I, Value *Num,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeline">                                                Value *Den, bool IsDiv,</td>
    <td class="lineNumber">1207</td>
    <td class="codeline">                                                Value *Den, bool IsDiv,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeline">                                                bool IsSigned) const {</td>
    <td class="lineNumber">1208</td>
    <td class="codeline">                                                bool IsSigned) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeline">  int DivBits = getDivNumBits(I, Num, Den, 9, IsSigned);</td>
    <td class="lineNumber">1209</td>
    <td class="codeline">  int DivBits = getDivNumBits(I, Num, Den, 9, IsSigned);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeline">  if (DivBits == -1)</td>
    <td class="lineNumber">1210</td>
    <td class="codeline">  if (DivBits == -1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">1211</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeline">  return expandDivRem24Impl(Builder, I, Num, Den, DivBits, IsDiv, IsSigned);</td>
    <td class="lineNumber">1212</td>
    <td class="codeline">  return expandDivRem24Impl(Builder, I, Num, Den, DivBits, IsDiv, IsSigned);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1213</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeline"></td>
    <td class="lineNumber">1214</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeline">Value *AMDGPUCodeGenPrepareImpl::expandDivRem24Impl(</td>
    <td class="lineNumber">1215</td>
    <td class="codeline">Value *AMDGPUCodeGenPrepareImpl::expandDivRem24Impl(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeline">    IRBuilder<> &Builder, BinaryOperator &I, Value *Num, Value *Den,</td>
    <td class="lineNumber">1216</td>
    <td class="codeline">    IRBuilder<> &Builder, BinaryOperator &I, Value *Num, Value *Den,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeline">    unsigned DivBits, bool IsDiv, bool IsSigned) const {</td>
    <td class="lineNumber">1217</td>
    <td class="codeline">    unsigned DivBits, bool IsDiv, bool IsSigned) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeline">  Type *I32Ty = Builder.getInt32Ty();</td>
    <td class="lineNumber">1218</td>
    <td class="codeline">  Type *I32Ty = Builder.getInt32Ty();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeline">  Num = Builder.CreateTrunc(Num, I32Ty);</td>
    <td class="lineNumber">1219</td>
    <td class="codeline">  Num = Builder.CreateTrunc(Num, I32Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeline">  Den = Builder.CreateTrunc(Den, I32Ty);</td>
    <td class="lineNumber">1220</td>
    <td class="codeline">  Den = Builder.CreateTrunc(Den, I32Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeline"></td>
    <td class="lineNumber">1221</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeline">  Type *F32Ty = Builder.getFloatTy();</td>
    <td class="lineNumber">1222</td>
    <td class="codeline">  Type *F32Ty = Builder.getFloatTy();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeline">  ConstantInt *One = Builder.getInt32(1);</td>
    <td class="lineNumber">1223</td>
    <td class="codeline">  ConstantInt *One = Builder.getInt32(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeline">  Value *JQ = One;</td>
    <td class="lineNumber">1224</td>
    <td class="codeline">  Value *JQ = One;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeline"></td>
    <td class="lineNumber">1225</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeline">  if (IsSigned) {</td>
    <td class="lineNumber">1226</td>
    <td class="codeline">  if (IsSigned) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeline">    // char|short jq = ia ^ ib;</td>
    <td class="lineNumber">1227</td>
    <td class="codeline">    // char|short jq = ia ^ ib;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeline">    JQ = Builder.CreateXor(Num, Den);</td>
    <td class="lineNumber">1228</td>
    <td class="codeline">    JQ = Builder.CreateXor(Num, Den);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeline"></td>
    <td class="lineNumber">1229</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeline">    // jq = jq >> (bitsize - 2)</td>
    <td class="lineNumber">1230</td>
    <td class="codeline">    // jq = jq >> (bitsize - 2)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeline">    JQ = Builder.CreateAShr(JQ, Builder.getInt32(30));</td>
    <td class="lineNumber">1231</td>
    <td class="codeline">    JQ = Builder.CreateAShr(JQ, Builder.getInt32(30));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeline"></td>
    <td class="lineNumber">1232</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeline">    // jq = jq | 0x1</td>
    <td class="lineNumber">1233</td>
    <td class="codeline">    // jq = jq | 0x1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeline">    JQ = Builder.CreateOr(JQ, One);</td>
    <td class="lineNumber">1234</td>
    <td class="codeline">    JQ = Builder.CreateOr(JQ, One);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1235</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeline"></td>
    <td class="lineNumber">1236</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeline">  // int ia = (int)LHS;</td>
    <td class="lineNumber">1237</td>
    <td class="codeline">  // int ia = (int)LHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeline">  Value *IA = Num;</td>
    <td class="lineNumber">1238</td>
    <td class="codeline">  Value *IA = Num;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeline"></td>
    <td class="lineNumber">1239</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeline">  // int ib, (int)RHS;</td>
    <td class="lineNumber">1240</td>
    <td class="codeline">  // int ib, (int)RHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeline">  Value *IB = Den;</td>
    <td class="lineNumber">1241</td>
    <td class="codeline">  Value *IB = Den;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeline"></td>
    <td class="lineNumber">1242</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeline">  // float fa = (float)ia;</td>
    <td class="lineNumber">1243</td>
    <td class="codeline">  // float fa = (float)ia;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeline">  Value *FA = IsSigned ? Builder.CreateSIToFP(IA, F32Ty)</td>
    <td class="lineNumber">1244</td>
    <td class="codeline">  Value *FA = IsSigned ? Builder.CreateSIToFP(IA, F32Ty)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeline">                       : Builder.CreateUIToFP(IA, F32Ty);</td>
    <td class="lineNumber">1245</td>
    <td class="codeline">                       : Builder.CreateUIToFP(IA, F32Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeline"></td>
    <td class="lineNumber">1246</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeline">  // float fb = (float)ib;</td>
    <td class="lineNumber">1247</td>
    <td class="codeline">  // float fb = (float)ib;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeline">  Value *FB = IsSigned ? Builder.CreateSIToFP(IB,F32Ty)</td>
    <td class="lineNumber">1248</td>
    <td class="codeline">  Value *FB = IsSigned ? Builder.CreateSIToFP(IB,F32Ty)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeline">                       : Builder.CreateUIToFP(IB,F32Ty);</td>
    <td class="lineNumber">1249</td>
    <td class="codeline">                       : Builder.CreateUIToFP(IB,F32Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeline"></td>
    <td class="lineNumber">1250</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeline">  Function *RcpDecl = Intrinsic::getDeclaration(Mod, Intrinsic::amdgcn_rcp,</td>
    <td class="lineNumber">1251</td>
    <td class="codeline">  Function *RcpDecl = Intrinsic::getDeclaration(Mod, Intrinsic::amdgcn_rcp,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeline">                                                Builder.getFloatTy());</td>
    <td class="lineNumber">1252</td>
    <td class="codeline">                                                Builder.getFloatTy());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeline">  Value *RCP = Builder.CreateCall(RcpDecl, { FB });</td>
    <td class="lineNumber">1253</td>
    <td class="codeline">  Value *RCP = Builder.CreateCall(RcpDecl, { FB });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeline">  Value *FQM = Builder.CreateFMul(FA, RCP);</td>
    <td class="lineNumber">1254</td>
    <td class="codeline">  Value *FQM = Builder.CreateFMul(FA, RCP);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeline"></td>
    <td class="lineNumber">1255</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeline">  // fq = trunc(fqm);</td>
    <td class="lineNumber">1256</td>
    <td class="codeline">  // fq = trunc(fqm);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeline">  CallInst *FQ = Builder.CreateUnaryIntrinsic(Intrinsic::trunc, FQM);</td>
    <td class="lineNumber">1257</td>
    <td class="codeline">  CallInst *FQ = Builder.CreateUnaryIntrinsic(Intrinsic::trunc, FQM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeline">  FQ->copyFastMathFlags(Builder.getFastMathFlags());</td>
    <td class="lineNumber">1258</td>
    <td class="codeline">  FQ->copyFastMathFlags(Builder.getFastMathFlags());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeline"></td>
    <td class="lineNumber">1259</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeline">  // float fqneg = -fq;</td>
    <td class="lineNumber">1260</td>
    <td class="codeline">  // float fqneg = -fq;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeline">  Value *FQNeg = Builder.CreateFNeg(FQ);</td>
    <td class="lineNumber">1261</td>
    <td class="codeline">  Value *FQNeg = Builder.CreateFNeg(FQ);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeline"></td>
    <td class="lineNumber">1262</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeline">  // float fr = mad(fqneg, fb, fa);</td>
    <td class="lineNumber">1263</td>
    <td class="codeline">  // float fr = mad(fqneg, fb, fa);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeline">  auto FMAD = !ST->hasMadMacF32Insts()</td>
    <td class="lineNumber">1264</td>
    <td class="codeline">  auto FMAD = !ST->hasMadMacF32Insts()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeline">                  ? Intrinsic::fma</td>
    <td class="lineNumber">1265</td>
    <td class="codeline">                  ? Intrinsic::fma</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeline">                  : (Intrinsic::ID)Intrinsic::amdgcn_fmad_ftz;</td>
    <td class="lineNumber">1266</td>
    <td class="codeline">                  : (Intrinsic::ID)Intrinsic::amdgcn_fmad_ftz;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeline">  Value *FR = Builder.CreateIntrinsic(FMAD,</td>
    <td class="lineNumber">1267</td>
    <td class="codeline">  Value *FR = Builder.CreateIntrinsic(FMAD,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeline">                                      {FQNeg->getType()}, {FQNeg, FB, FA}, FQ);</td>
    <td class="lineNumber">1268</td>
    <td class="codeline">                                      {FQNeg->getType()}, {FQNeg, FB, FA}, FQ);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeline"></td>
    <td class="lineNumber">1269</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeline">  // int iq = (int)fq;</td>
    <td class="lineNumber">1270</td>
    <td class="codeline">  // int iq = (int)fq;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeline">  Value *IQ = IsSigned ? Builder.CreateFPToSI(FQ, I32Ty)</td>
    <td class="lineNumber">1271</td>
    <td class="codeline">  Value *IQ = IsSigned ? Builder.CreateFPToSI(FQ, I32Ty)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeline">                       : Builder.CreateFPToUI(FQ, I32Ty);</td>
    <td class="lineNumber">1272</td>
    <td class="codeline">                       : Builder.CreateFPToUI(FQ, I32Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeline"></td>
    <td class="lineNumber">1273</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeline">  // fr = fabs(fr);</td>
    <td class="lineNumber">1274</td>
    <td class="codeline">  // fr = fabs(fr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeline">  FR = Builder.CreateUnaryIntrinsic(Intrinsic::fabs, FR, FQ);</td>
    <td class="lineNumber">1275</td>
    <td class="codeline">  FR = Builder.CreateUnaryIntrinsic(Intrinsic::fabs, FR, FQ);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeline"></td>
    <td class="lineNumber">1276</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeline">  // fb = fabs(fb);</td>
    <td class="lineNumber">1277</td>
    <td class="codeline">  // fb = fabs(fb);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeline">  FB = Builder.CreateUnaryIntrinsic(Intrinsic::fabs, FB, FQ);</td>
    <td class="lineNumber">1278</td>
    <td class="codeline">  FB = Builder.CreateUnaryIntrinsic(Intrinsic::fabs, FB, FQ);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeline"></td>
    <td class="lineNumber">1279</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeline">  // int cv = fr >= fb;</td>
    <td class="lineNumber">1280</td>
    <td class="codeline">  // int cv = fr >= fb;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeline">  Value *CV = Builder.CreateFCmpOGE(FR, FB);</td>
    <td class="lineNumber">1281</td>
    <td class="codeline">  Value *CV = Builder.CreateFCmpOGE(FR, FB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeline"></td>
    <td class="lineNumber">1282</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeline">  // jq = (cv ? jq : 0);</td>
    <td class="lineNumber">1283</td>
    <td class="codeline">  // jq = (cv ? jq : 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeline">  JQ = Builder.CreateSelect(CV, JQ, Builder.getInt32(0));</td>
    <td class="lineNumber">1284</td>
    <td class="codeline">  JQ = Builder.CreateSelect(CV, JQ, Builder.getInt32(0));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeline"></td>
    <td class="lineNumber">1285</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeline">  // dst = iq + jq;</td>
    <td class="lineNumber">1286</td>
    <td class="codeline">  // dst = iq + jq;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeline">  Value *Div = Builder.CreateAdd(IQ, JQ);</td>
    <td class="lineNumber">1287</td>
    <td class="codeline">  Value *Div = Builder.CreateAdd(IQ, JQ);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeline"></td>
    <td class="lineNumber">1288</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeline">  Value *Res = Div;</td>
    <td class="lineNumber">1289</td>
    <td class="codeline">  Value *Res = Div;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeline">  if (!IsDiv) {</td>
    <td class="lineNumber">1290</td>
    <td class="codeline">  if (!IsDiv) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeline">    // Rem needs compensation, it's easier to recompute it</td>
    <td class="lineNumber">1291</td>
    <td class="codeline">    // Rem needs compensation, it's easier to recompute it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeline">    Value *Rem = Builder.CreateMul(Div, Den);</td>
    <td class="lineNumber">1292</td>
    <td class="codeline">    Value *Rem = Builder.CreateMul(Div, Den);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeline">    Res = Builder.CreateSub(Num, Rem);</td>
    <td class="lineNumber">1293</td>
    <td class="codeline">    Res = Builder.CreateSub(Num, Rem);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1294</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeline"></td>
    <td class="lineNumber">1295</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeline">  if (DivBits != 0 && DivBits < 32) {</td>
    <td class="lineNumber">1296</td>
    <td class="codeline">  if (DivBits != 0 && DivBits < 32) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeline">    // Extend in register from the number of bits this divide really is.</td>
    <td class="lineNumber">1297</td>
    <td class="codeline">    // Extend in register from the number of bits this divide really is.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeline">    if (IsSigned) {</td>
    <td class="lineNumber">1298</td>
    <td class="codeline">    if (IsSigned) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeline">      int InRegBits = 32 - DivBits;</td>
    <td class="lineNumber">1299</td>
    <td class="codeline">      int InRegBits = 32 - DivBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeline"></td>
    <td class="lineNumber">1300</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeline">      Res = Builder.CreateShl(Res, InRegBits);</td>
    <td class="lineNumber">1301</td>
    <td class="codeline">      Res = Builder.CreateShl(Res, InRegBits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeline">      Res = Builder.CreateAShr(Res, InRegBits);</td>
    <td class="lineNumber">1302</td>
    <td class="codeline">      Res = Builder.CreateAShr(Res, InRegBits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">1303</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeline">      ConstantInt *TruncMask</td>
    <td class="lineNumber">1304</td>
    <td class="codeline">      ConstantInt *TruncMask</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeline">        = Builder.getInt32((UINT64_C(1) << DivBits) - 1);</td>
    <td class="lineNumber">1305</td>
    <td class="codeline">        = Builder.getInt32((UINT64_C(1) << DivBits) - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeline">      Res = Builder.CreateAnd(Res, TruncMask);</td>
    <td class="lineNumber">1306</td>
    <td class="codeline">      Res = Builder.CreateAnd(Res, TruncMask);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1307</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1308</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeline"></td>
    <td class="lineNumber">1309</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeline">  return Res;</td>
    <td class="lineNumber">1310</td>
    <td class="codeline">  return Res;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1311</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeline"></td>
    <td class="lineNumber">1312</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeline">// Try to recognize special cases the DAG will emit special, better expansions</td>
    <td class="lineNumber">1313</td>
    <td class="codeline">// Try to recognize special cases the DAG will emit special, better expansions</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeline">// than the general expansion we do here.</td>
    <td class="lineNumber">1314</td>
    <td class="codeline">// than the general expansion we do here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeline"></td>
    <td class="lineNumber">1315</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeline">// TODO: It would be better to just directly handle those optimizations here.</td>
    <td class="lineNumber">1316</td>
    <td class="codeline">// TODO: It would be better to just directly handle those optimizations here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::divHasSpecialOptimization(BinaryOperator &I,</td>
    <td class="lineNumber">1317</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::divHasSpecialOptimization(BinaryOperator &I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeline">                                                         Value *Num,</td>
    <td class="lineNumber">1318</td>
    <td class="codeline">                                                         Value *Num,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeline">                                                         Value *Den) const {</td>
    <td class="lineNumber">1319</td>
    <td class="codeline">                                                         Value *Den) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeline">  if (Constant *C = dyn_cast<Constant>(Den)) {</td>
    <td class="lineNumber">1320</td>
    <td class="codeline">  if (Constant *C = dyn_cast<Constant>(Den)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeline">    // Arbitrary constants get a better expansion as long as a wider mulhi is</td>
    <td class="lineNumber">1321</td>
    <td class="codeline">    // Arbitrary constants get a better expansion as long as a wider mulhi is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeline">    // legal.</td>
    <td class="lineNumber">1322</td>
    <td class="codeline">    // legal.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeline">    if (C->getType()->getScalarSizeInBits() <= 32)</td>
    <td class="lineNumber">1323</td>
    <td class="codeline">    if (C->getType()->getScalarSizeInBits() <= 32)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">1324</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeline"></td>
    <td class="lineNumber">1325</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeline">    // TODO: Sdiv check for not exact for some reason.</td>
    <td class="lineNumber">1326</td>
    <td class="codeline">    // TODO: Sdiv check for not exact for some reason.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeline"></td>
    <td class="lineNumber">1327</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeline">    // If there's no wider mulhi, there's only a better expansion for powers of</td>
    <td class="lineNumber">1328</td>
    <td class="codeline">    // If there's no wider mulhi, there's only a better expansion for powers of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeline">    // two.</td>
    <td class="lineNumber">1329</td>
    <td class="codeline">    // two.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeline">    // TODO: Should really know for each vector element.</td>
    <td class="lineNumber">1330</td>
    <td class="codeline">    // TODO: Should really know for each vector element.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeline">    if (isKnownToBeAPowerOfTwo(C, *DL, true, 0, AC, &I, DT))</td>
    <td class="lineNumber">1331</td>
    <td class="codeline">    if (isKnownToBeAPowerOfTwo(C, *DL, true, 0, AC, &I, DT))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">1332</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeline"></td>
    <td class="lineNumber">1333</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1334</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1335</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeline"></td>
    <td class="lineNumber">1336</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeline">  if (BinaryOperator *BinOpDen = dyn_cast<BinaryOperator>(Den)) {</td>
    <td class="lineNumber">1337</td>
    <td class="codeline">  if (BinaryOperator *BinOpDen = dyn_cast<BinaryOperator>(Den)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeline">    // fold (udiv x, (shl c, y)) -> x >>u (log2(c)+y) iff c is power of 2</td>
    <td class="lineNumber">1338</td>
    <td class="codeline">    // fold (udiv x, (shl c, y)) -> x >>u (log2(c)+y) iff c is power of 2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeline">    if (BinOpDen->getOpcode() == Instruction::Shl &&</td>
    <td class="lineNumber">1339</td>
    <td class="codeline">    if (BinOpDen->getOpcode() == Instruction::Shl &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeline">        isa<Constant>(BinOpDen->getOperand(0)) &&</td>
    <td class="lineNumber">1340</td>
    <td class="codeline">        isa<Constant>(BinOpDen->getOperand(0)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeline">        isKnownToBeAPowerOfTwo(BinOpDen->getOperand(0), *DL, true,</td>
    <td class="lineNumber">1341</td>
    <td class="codeline">        isKnownToBeAPowerOfTwo(BinOpDen->getOperand(0), *DL, true,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeline">                               0, AC, &I, DT)) {</td>
    <td class="lineNumber">1342</td>
    <td class="codeline">                               0, AC, &I, DT)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">1343</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1344</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1345</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeline"></td>
    <td class="lineNumber">1346</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">1347</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1348</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeline"></td>
    <td class="lineNumber">1349</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeline">static Value *getSign32(Value *V, IRBuilder<> &Builder, const DataLayout *DL) {</td>
    <td class="lineNumber">1350</td>
    <td class="codeline">static Value *getSign32(Value *V, IRBuilder<> &Builder, const DataLayout *DL) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeline">  // Check whether the sign can be determined statically.</td>
    <td class="lineNumber">1351</td>
    <td class="codeline">  // Check whether the sign can be determined statically.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeline">  KnownBits Known = computeKnownBits(V, *DL);</td>
    <td class="lineNumber">1352</td>
    <td class="codeline">  KnownBits Known = computeKnownBits(V, *DL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeline">  if (Known.isNegative())</td>
    <td class="lineNumber">1353</td>
    <td class="codeline">  if (Known.isNegative())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeline">    return Constant::getAllOnesValue(V->getType());</td>
    <td class="lineNumber">1354</td>
    <td class="codeline">    return Constant::getAllOnesValue(V->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeline">  if (Known.isNonNegative())</td>
    <td class="lineNumber">1355</td>
    <td class="codeline">  if (Known.isNonNegative())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeline">    return Constant::getNullValue(V->getType());</td>
    <td class="lineNumber">1356</td>
    <td class="codeline">    return Constant::getNullValue(V->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeline">  return Builder.CreateAShr(V, Builder.getInt32(31));</td>
    <td class="lineNumber">1357</td>
    <td class="codeline">  return Builder.CreateAShr(V, Builder.getInt32(31));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1358</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeline"></td>
    <td class="lineNumber">1359</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeline">Value *AMDGPUCodeGenPrepareImpl::expandDivRem32(IRBuilder<> &Builder,</td>
    <td class="lineNumber">1360</td>
    <td class="codeline">Value *AMDGPUCodeGenPrepareImpl::expandDivRem32(IRBuilder<> &Builder,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeline">                                                BinaryOperator &I, Value *X,</td>
    <td class="lineNumber">1361</td>
    <td class="codeline">                                                BinaryOperator &I, Value *X,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeline">                                                Value *Y) const {</td>
    <td class="lineNumber">1362</td>
    <td class="codeline">                                                Value *Y) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeline">  Instruction::BinaryOps Opc = I.getOpcode();</td>
    <td class="lineNumber">1363</td>
    <td class="codeline">  Instruction::BinaryOps Opc = I.getOpcode();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeline">  assert(Opc == Instruction::URem || Opc == Instruction::UDiv ||</td>
    <td class="lineNumber">1364</td>
    <td class="codeline">  assert(Opc == Instruction::URem || Opc == Instruction::UDiv ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeline">         Opc == Instruction::SRem || Opc == Instruction::SDiv);</td>
    <td class="lineNumber">1365</td>
    <td class="codeline">         Opc == Instruction::SRem || Opc == Instruction::SDiv);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeline"></td>
    <td class="lineNumber">1366</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeline">  FastMathFlags FMF;</td>
    <td class="lineNumber">1367</td>
    <td class="codeline">  FastMathFlags FMF;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeline">  FMF.setFast();</td>
    <td class="lineNumber">1368</td>
    <td class="codeline">  FMF.setFast();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeline">  Builder.setFastMathFlags(FMF);</td>
    <td class="lineNumber">1369</td>
    <td class="codeline">  Builder.setFastMathFlags(FMF);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeline"></td>
    <td class="lineNumber">1370</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeline">  if (divHasSpecialOptimization(I, X, Y))</td>
    <td class="lineNumber">1371</td>
    <td class="codeline">  if (divHasSpecialOptimization(I, X, Y))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeline">    return nullptr;  // Keep it for later optimization.</td>
    <td class="lineNumber">1372</td>
    <td class="codeline">    return nullptr;  // Keep it for later optimization.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeline"></td>
    <td class="lineNumber">1373</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeline">  bool IsDiv = Opc == Instruction::UDiv || Opc == Instruction::SDiv;</td>
    <td class="lineNumber">1374</td>
    <td class="codeline">  bool IsDiv = Opc == Instruction::UDiv || Opc == Instruction::SDiv;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeline">  bool IsSigned = Opc == Instruction::SRem || Opc == Instruction::SDiv;</td>
    <td class="lineNumber">1375</td>
    <td class="codeline">  bool IsSigned = Opc == Instruction::SRem || Opc == Instruction::SDiv;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeline"></td>
    <td class="lineNumber">1376</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeline">  Type *Ty = X->getType();</td>
    <td class="lineNumber">1377</td>
    <td class="codeline">  Type *Ty = X->getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeline">  Type *I32Ty = Builder.getInt32Ty();</td>
    <td class="lineNumber">1378</td>
    <td class="codeline">  Type *I32Ty = Builder.getInt32Ty();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeline">  Type *F32Ty = Builder.getFloatTy();</td>
    <td class="lineNumber">1379</td>
    <td class="codeline">  Type *F32Ty = Builder.getFloatTy();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeline"></td>
    <td class="lineNumber">1380</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeline">  if (Ty->getScalarSizeInBits() < 32) {</td>
    <td class="lineNumber">1381</td>
    <td class="codeline">  if (Ty->getScalarSizeInBits() < 32) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeline">    if (IsSigned) {</td>
    <td class="lineNumber">1382</td>
    <td class="codeline">    if (IsSigned) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeline">      X = Builder.CreateSExt(X, I32Ty);</td>
    <td class="lineNumber">1383</td>
    <td class="codeline">      X = Builder.CreateSExt(X, I32Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeline">      Y = Builder.CreateSExt(Y, I32Ty);</td>
    <td class="lineNumber">1384</td>
    <td class="codeline">      Y = Builder.CreateSExt(Y, I32Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">1385</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeline">      X = Builder.CreateZExt(X, I32Ty);</td>
    <td class="lineNumber">1386</td>
    <td class="codeline">      X = Builder.CreateZExt(X, I32Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeline">      Y = Builder.CreateZExt(Y, I32Ty);</td>
    <td class="lineNumber">1387</td>
    <td class="codeline">      Y = Builder.CreateZExt(Y, I32Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1388</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1389</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeline"></td>
    <td class="lineNumber">1390</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeline">  if (Value *Res = expandDivRem24(Builder, I, X, Y, IsDiv, IsSigned)) {</td>
    <td class="lineNumber">1391</td>
    <td class="codeline">  if (Value *Res = expandDivRem24(Builder, I, X, Y, IsDiv, IsSigned)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeline">    return IsSigned ? Builder.CreateSExtOrTrunc(Res, Ty) :</td>
    <td class="lineNumber">1392</td>
    <td class="codeline">    return IsSigned ? Builder.CreateSExtOrTrunc(Res, Ty) :</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeline">                      Builder.CreateZExtOrTrunc(Res, Ty);</td>
    <td class="lineNumber">1393</td>
    <td class="codeline">                      Builder.CreateZExtOrTrunc(Res, Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1394</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeline"></td>
    <td class="lineNumber">1395</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeline">  ConstantInt *Zero = Builder.getInt32(0);</td>
    <td class="lineNumber">1396</td>
    <td class="codeline">  ConstantInt *Zero = Builder.getInt32(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeline">  ConstantInt *One = Builder.getInt32(1);</td>
    <td class="lineNumber">1397</td>
    <td class="codeline">  ConstantInt *One = Builder.getInt32(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeline"></td>
    <td class="lineNumber">1398</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeline">  Value *Sign = nullptr;</td>
    <td class="lineNumber">1399</td>
    <td class="codeline">  Value *Sign = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeline">  if (IsSigned) {</td>
    <td class="lineNumber">1400</td>
    <td class="codeline">  if (IsSigned) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeline">    Value *SignX = getSign32(X, Builder, DL);</td>
    <td class="lineNumber">1401</td>
    <td class="codeline">    Value *SignX = getSign32(X, Builder, DL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeline">    Value *SignY = getSign32(Y, Builder, DL);</td>
    <td class="lineNumber">1402</td>
    <td class="codeline">    Value *SignY = getSign32(Y, Builder, DL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeline">    // Remainder sign is the same as LHS</td>
    <td class="lineNumber">1403</td>
    <td class="codeline">    // Remainder sign is the same as LHS</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeline">    Sign = IsDiv ? Builder.CreateXor(SignX, SignY) : SignX;</td>
    <td class="lineNumber">1404</td>
    <td class="codeline">    Sign = IsDiv ? Builder.CreateXor(SignX, SignY) : SignX;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeline"></td>
    <td class="lineNumber">1405</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeline">    X = Builder.CreateAdd(X, SignX);</td>
    <td class="lineNumber">1406</td>
    <td class="codeline">    X = Builder.CreateAdd(X, SignX);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeline">    Y = Builder.CreateAdd(Y, SignY);</td>
    <td class="lineNumber">1407</td>
    <td class="codeline">    Y = Builder.CreateAdd(Y, SignY);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeline"></td>
    <td class="lineNumber">1408</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeline">    X = Builder.CreateXor(X, SignX);</td>
    <td class="lineNumber">1409</td>
    <td class="codeline">    X = Builder.CreateXor(X, SignX);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeline">    Y = Builder.CreateXor(Y, SignY);</td>
    <td class="lineNumber">1410</td>
    <td class="codeline">    Y = Builder.CreateXor(Y, SignY);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1411</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeline"></td>
    <td class="lineNumber">1412</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeline">  // The algorithm here is based on ideas from "Software Integer Division", Tom</td>
    <td class="lineNumber">1413</td>
    <td class="codeline">  // The algorithm here is based on ideas from "Software Integer Division", Tom</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeline">  // Rodeheffer, August 2008.</td>
    <td class="lineNumber">1414</td>
    <td class="codeline">  // Rodeheffer, August 2008.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1415</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeline">  // unsigned udiv(unsigned x, unsigned y) {</td>
    <td class="lineNumber">1416</td>
    <td class="codeline">  // unsigned udiv(unsigned x, unsigned y) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeline">  //   // Initial estimate of inv(y). The constant is less than 2^32 to ensure</td>
    <td class="lineNumber">1417</td>
    <td class="codeline">  //   // Initial estimate of inv(y). The constant is less than 2^32 to ensure</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeline">  //   // that this is a lower bound on inv(y), even if some of the calculations</td>
    <td class="lineNumber">1418</td>
    <td class="codeline">  //   // that this is a lower bound on inv(y), even if some of the calculations</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeline">  //   // round up.</td>
    <td class="lineNumber">1419</td>
    <td class="codeline">  //   // round up.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeline">  //   unsigned z = (unsigned)((4294967296.0 - 512.0) * v_rcp_f32((float)y));</td>
    <td class="lineNumber">1420</td>
    <td class="codeline">  //   unsigned z = (unsigned)((4294967296.0 - 512.0) * v_rcp_f32((float)y));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1421</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeline">  //   // One round of UNR (Unsigned integer Newton-Raphson) to improve z.</td>
    <td class="lineNumber">1422</td>
    <td class="codeline">  //   // One round of UNR (Unsigned integer Newton-Raphson) to improve z.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeline">  //   // Empirically this is guaranteed to give a "two-y" lower bound on</td>
    <td class="lineNumber">1423</td>
    <td class="codeline">  //   // Empirically this is guaranteed to give a "two-y" lower bound on</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeline">  //   // inv(y).</td>
    <td class="lineNumber">1424</td>
    <td class="codeline">  //   // inv(y).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeline">  //   z += umulh(z, -y * z);</td>
    <td class="lineNumber">1425</td>
    <td class="codeline">  //   z += umulh(z, -y * z);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1426</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeline">  //   // Quotient/remainder estimate.</td>
    <td class="lineNumber">1427</td>
    <td class="codeline">  //   // Quotient/remainder estimate.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeline">  //   unsigned q = umulh(x, z);</td>
    <td class="lineNumber">1428</td>
    <td class="codeline">  //   unsigned q = umulh(x, z);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeline">  //   unsigned r = x - q * y;</td>
    <td class="lineNumber">1429</td>
    <td class="codeline">  //   unsigned r = x - q * y;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1430</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeline">  //   // Two rounds of quotient/remainder refinement.</td>
    <td class="lineNumber">1431</td>
    <td class="codeline">  //   // Two rounds of quotient/remainder refinement.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeline">  //   if (r >= y) {</td>
    <td class="lineNumber">1432</td>
    <td class="codeline">  //   if (r >= y) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeline">  //     ++q;</td>
    <td class="lineNumber">1433</td>
    <td class="codeline">  //     ++q;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeline">  //     r -= y;</td>
    <td class="lineNumber">1434</td>
    <td class="codeline">  //     r -= y;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeline">  //   }</td>
    <td class="lineNumber">1435</td>
    <td class="codeline">  //   }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeline">  //   if (r >= y) {</td>
    <td class="lineNumber">1436</td>
    <td class="codeline">  //   if (r >= y) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeline">  //     ++q;</td>
    <td class="lineNumber">1437</td>
    <td class="codeline">  //     ++q;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeline">  //     r -= y;</td>
    <td class="lineNumber">1438</td>
    <td class="codeline">  //     r -= y;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeline">  //   }</td>
    <td class="lineNumber">1439</td>
    <td class="codeline">  //   }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1440</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeline">  //   return q;</td>
    <td class="lineNumber">1441</td>
    <td class="codeline">  //   return q;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeline">  // }</td>
    <td class="lineNumber">1442</td>
    <td class="codeline">  // }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeline"></td>
    <td class="lineNumber">1443</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeline">  // Initial estimate of inv(y).</td>
    <td class="lineNumber">1444</td>
    <td class="codeline">  // Initial estimate of inv(y).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeline">  Value *FloatY = Builder.CreateUIToFP(Y, F32Ty);</td>
    <td class="lineNumber">1445</td>
    <td class="codeline">  Value *FloatY = Builder.CreateUIToFP(Y, F32Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeline">  Function *Rcp = Intrinsic::getDeclaration(Mod, Intrinsic::amdgcn_rcp, F32Ty);</td>
    <td class="lineNumber">1446</td>
    <td class="codeline">  Function *Rcp = Intrinsic::getDeclaration(Mod, Intrinsic::amdgcn_rcp, F32Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeline">  Value *RcpY = Builder.CreateCall(Rcp, {FloatY});</td>
    <td class="lineNumber">1447</td>
    <td class="codeline">  Value *RcpY = Builder.CreateCall(Rcp, {FloatY});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeline">  Constant *Scale = ConstantFP::get(F32Ty, llvm::bit_cast<float>(0x4F7FFFFE));</td>
    <td class="lineNumber">1448</td>
    <td class="codeline">  Constant *Scale = ConstantFP::get(F32Ty, llvm::bit_cast<float>(0x4F7FFFFE));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeline">  Value *ScaledY = Builder.CreateFMul(RcpY, Scale);</td>
    <td class="lineNumber">1449</td>
    <td class="codeline">  Value *ScaledY = Builder.CreateFMul(RcpY, Scale);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeline">  Value *Z = Builder.CreateFPToUI(ScaledY, I32Ty);</td>
    <td class="lineNumber">1450</td>
    <td class="codeline">  Value *Z = Builder.CreateFPToUI(ScaledY, I32Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeline"></td>
    <td class="lineNumber">1451</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeline">  // One round of UNR.</td>
    <td class="lineNumber">1452</td>
    <td class="codeline">  // One round of UNR.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeline">  Value *NegY = Builder.CreateSub(Zero, Y);</td>
    <td class="lineNumber">1453</td>
    <td class="codeline">  Value *NegY = Builder.CreateSub(Zero, Y);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeline">  Value *NegYZ = Builder.CreateMul(NegY, Z);</td>
    <td class="lineNumber">1454</td>
    <td class="codeline">  Value *NegYZ = Builder.CreateMul(NegY, Z);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeline">  Z = Builder.CreateAdd(Z, getMulHu(Builder, Z, NegYZ));</td>
    <td class="lineNumber">1455</td>
    <td class="codeline">  Z = Builder.CreateAdd(Z, getMulHu(Builder, Z, NegYZ));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeline"></td>
    <td class="lineNumber">1456</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeline">  // Quotient/remainder estimate.</td>
    <td class="lineNumber">1457</td>
    <td class="codeline">  // Quotient/remainder estimate.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeline">  Value *Q = getMulHu(Builder, X, Z);</td>
    <td class="lineNumber">1458</td>
    <td class="codeline">  Value *Q = getMulHu(Builder, X, Z);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeline">  Value *R = Builder.CreateSub(X, Builder.CreateMul(Q, Y));</td>
    <td class="lineNumber">1459</td>
    <td class="codeline">  Value *R = Builder.CreateSub(X, Builder.CreateMul(Q, Y));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeline"></td>
    <td class="lineNumber">1460</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeline">  // First quotient/remainder refinement.</td>
    <td class="lineNumber">1461</td>
    <td class="codeline">  // First quotient/remainder refinement.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeline">  Value *Cond = Builder.CreateICmpUGE(R, Y);</td>
    <td class="lineNumber">1462</td>
    <td class="codeline">  Value *Cond = Builder.CreateICmpUGE(R, Y);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeline">  if (IsDiv)</td>
    <td class="lineNumber">1463</td>
    <td class="codeline">  if (IsDiv)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeline">    Q = Builder.CreateSelect(Cond, Builder.CreateAdd(Q, One), Q);</td>
    <td class="lineNumber">1464</td>
    <td class="codeline">    Q = Builder.CreateSelect(Cond, Builder.CreateAdd(Q, One), Q);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeline">  R = Builder.CreateSelect(Cond, Builder.CreateSub(R, Y), R);</td>
    <td class="lineNumber">1465</td>
    <td class="codeline">  R = Builder.CreateSelect(Cond, Builder.CreateSub(R, Y), R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeline"></td>
    <td class="lineNumber">1466</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeline">  // Second quotient/remainder refinement.</td>
    <td class="lineNumber">1467</td>
    <td class="codeline">  // Second quotient/remainder refinement.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeline">  Cond = Builder.CreateICmpUGE(R, Y);</td>
    <td class="lineNumber">1468</td>
    <td class="codeline">  Cond = Builder.CreateICmpUGE(R, Y);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeline">  Value *Res;</td>
    <td class="lineNumber">1469</td>
    <td class="codeline">  Value *Res;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeline">  if (IsDiv)</td>
    <td class="lineNumber">1470</td>
    <td class="codeline">  if (IsDiv)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeline">    Res = Builder.CreateSelect(Cond, Builder.CreateAdd(Q, One), Q);</td>
    <td class="lineNumber">1471</td>
    <td class="codeline">    Res = Builder.CreateSelect(Cond, Builder.CreateAdd(Q, One), Q);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">1472</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeline">    Res = Builder.CreateSelect(Cond, Builder.CreateSub(R, Y), R);</td>
    <td class="lineNumber">1473</td>
    <td class="codeline">    Res = Builder.CreateSelect(Cond, Builder.CreateSub(R, Y), R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeline"></td>
    <td class="lineNumber">1474</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeline">  if (IsSigned) {</td>
    <td class="lineNumber">1475</td>
    <td class="codeline">  if (IsSigned) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeline">    Res = Builder.CreateXor(Res, Sign);</td>
    <td class="lineNumber">1476</td>
    <td class="codeline">    Res = Builder.CreateXor(Res, Sign);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeline">    Res = Builder.CreateSub(Res, Sign);</td>
    <td class="lineNumber">1477</td>
    <td class="codeline">    Res = Builder.CreateSub(Res, Sign);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1478</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeline"></td>
    <td class="lineNumber">1479</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeline">  Res = Builder.CreateTrunc(Res, Ty);</td>
    <td class="lineNumber">1480</td>
    <td class="codeline">  Res = Builder.CreateTrunc(Res, Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeline"></td>
    <td class="lineNumber">1481</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeline">  return Res;</td>
    <td class="lineNumber">1482</td>
    <td class="codeline">  return Res;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1483</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeline"></td>
    <td class="lineNumber">1484</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeline">Value *AMDGPUCodeGenPrepareImpl::shrinkDivRem64(IRBuilder<> &Builder,</td>
    <td class="lineNumber">1485</td>
    <td class="codeline">Value *AMDGPUCodeGenPrepareImpl::shrinkDivRem64(IRBuilder<> &Builder,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeline">                                                BinaryOperator &I, Value *Num,</td>
    <td class="lineNumber">1486</td>
    <td class="codeline">                                                BinaryOperator &I, Value *Num,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeline">                                                Value *Den) const {</td>
    <td class="lineNumber">1487</td>
    <td class="codeline">                                                Value *Den) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeline">  if (!ExpandDiv64InIR && divHasSpecialOptimization(I, Num, Den))</td>
    <td class="lineNumber">1488</td>
    <td class="codeline">  if (!ExpandDiv64InIR && divHasSpecialOptimization(I, Num, Den))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeline">    return nullptr;  // Keep it for later optimization.</td>
    <td class="lineNumber">1489</td>
    <td class="codeline">    return nullptr;  // Keep it for later optimization.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeline"></td>
    <td class="lineNumber">1490</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeline">  Instruction::BinaryOps Opc = I.getOpcode();</td>
    <td class="lineNumber">1491</td>
    <td class="codeline">  Instruction::BinaryOps Opc = I.getOpcode();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeline"></td>
    <td class="lineNumber">1492</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeline">  bool IsDiv = Opc == Instruction::SDiv || Opc == Instruction::UDiv;</td>
    <td class="lineNumber">1493</td>
    <td class="codeline">  bool IsDiv = Opc == Instruction::SDiv || Opc == Instruction::UDiv;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeline">  bool IsSigned = Opc == Instruction::SDiv || Opc == Instruction::SRem;</td>
    <td class="lineNumber">1494</td>
    <td class="codeline">  bool IsSigned = Opc == Instruction::SDiv || Opc == Instruction::SRem;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeline"></td>
    <td class="lineNumber">1495</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeline">  int NumDivBits = getDivNumBits(I, Num, Den, 32, IsSigned);</td>
    <td class="lineNumber">1496</td>
    <td class="codeline">  int NumDivBits = getDivNumBits(I, Num, Den, 32, IsSigned);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeline">  if (NumDivBits == -1)</td>
    <td class="lineNumber">1497</td>
    <td class="codeline">  if (NumDivBits == -1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">1498</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeline"></td>
    <td class="lineNumber">1499</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeline">  Value *Narrowed = nullptr;</td>
    <td class="lineNumber">1500</td>
    <td class="codeline">  Value *Narrowed = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeline">  if (NumDivBits <= 24) {</td>
    <td class="lineNumber">1501</td>
    <td class="codeline">  if (NumDivBits <= 24) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeline">    Narrowed = expandDivRem24Impl(Builder, I, Num, Den, NumDivBits,</td>
    <td class="lineNumber">1502</td>
    <td class="codeline">    Narrowed = expandDivRem24Impl(Builder, I, Num, Den, NumDivBits,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeline">                                  IsDiv, IsSigned);</td>
    <td class="lineNumber">1503</td>
    <td class="codeline">                                  IsDiv, IsSigned);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeline">  } else if (NumDivBits <= 32) {</td>
    <td class="lineNumber">1504</td>
    <td class="codeline">  } else if (NumDivBits <= 32) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeline">    Narrowed = expandDivRem32(Builder, I, Num, Den);</td>
    <td class="lineNumber">1505</td>
    <td class="codeline">    Narrowed = expandDivRem32(Builder, I, Num, Den);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1506</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeline"></td>
    <td class="lineNumber">1507</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeline">  if (Narrowed) {</td>
    <td class="lineNumber">1508</td>
    <td class="codeline">  if (Narrowed) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeline">    return IsSigned ? Builder.CreateSExt(Narrowed, Num->getType()) :</td>
    <td class="lineNumber">1509</td>
    <td class="codeline">    return IsSigned ? Builder.CreateSExt(Narrowed, Num->getType()) :</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeline">                      Builder.CreateZExt(Narrowed, Num->getType());</td>
    <td class="lineNumber">1510</td>
    <td class="codeline">                      Builder.CreateZExt(Narrowed, Num->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1511</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeline"></td>
    <td class="lineNumber">1512</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeline">  return nullptr;</td>
    <td class="lineNumber">1513</td>
    <td class="codeline">  return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1514</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeline"></td>
    <td class="lineNumber">1515</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeline">void AMDGPUCodeGenPrepareImpl::expandDivRem64(BinaryOperator &I) const {</td>
    <td class="lineNumber">1516</td>
    <td class="codeline">void AMDGPUCodeGenPrepareImpl::expandDivRem64(BinaryOperator &I) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeline">  Instruction::BinaryOps Opc = I.getOpcode();</td>
    <td class="lineNumber">1517</td>
    <td class="codeline">  Instruction::BinaryOps Opc = I.getOpcode();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeline">  // Do the general expansion.</td>
    <td class="lineNumber">1518</td>
    <td class="codeline">  // Do the general expansion.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeline">  if (Opc == Instruction::UDiv || Opc == Instruction::SDiv) {</td>
    <td class="lineNumber">1519</td>
    <td class="codeline">  if (Opc == Instruction::UDiv || Opc == Instruction::SDiv) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeline">    expandDivisionUpTo64Bits(&I);</td>
    <td class="lineNumber">1520</td>
    <td class="codeline">    expandDivisionUpTo64Bits(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">1521</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1522</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeline"></td>
    <td class="lineNumber">1523</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeline">  if (Opc == Instruction::URem || Opc == Instruction::SRem) {</td>
    <td class="lineNumber">1524</td>
    <td class="codeline">  if (Opc == Instruction::URem || Opc == Instruction::SRem) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeline">    expandRemainderUpTo64Bits(&I);</td>
    <td class="lineNumber">1525</td>
    <td class="codeline">    expandRemainderUpTo64Bits(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">1526</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1527</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeline"></td>
    <td class="lineNumber">1528</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeline">  llvm_unreachable("not a division");</td>
    <td class="lineNumber">1529</td>
    <td class="codeline">  llvm_unreachable("not a division");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1530</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeline"></td>
    <td class="lineNumber">1531</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::visitBinaryOperator(BinaryOperator &I) {</td>
    <td class="lineNumber">1532</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::visitBinaryOperator(BinaryOperator &I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeline">  if (foldBinOpIntoSelect(I))</td>
    <td class="lineNumber">1533</td>
    <td class="codeline">  if (foldBinOpIntoSelect(I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">1534</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeline"></td>
    <td class="lineNumber">1535</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeline">  if (ST->has16BitInsts() && needsPromotionToI32(I.getType()) &&</td>
    <td class="lineNumber">1536</td>
    <td class="codeline">  if (ST->has16BitInsts() && needsPromotionToI32(I.getType()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeline">      UA->isUniform(&I) && promoteUniformOpToI32(I))</td>
    <td class="lineNumber">1537</td>
    <td class="codeline">      UA->isUniform(&I) && promoteUniformOpToI32(I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">1538</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeline"></td>
    <td class="lineNumber">1539</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeline">  if (UseMul24Intrin && replaceMulWithMul24(I))</td>
    <td class="lineNumber">1540</td>
    <td class="codeline">  if (UseMul24Intrin && replaceMulWithMul24(I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">1541</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeline"></td>
    <td class="lineNumber">1542</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeline">  bool Changed = false;</td>
    <td class="lineNumber">1543</td>
    <td class="codeline">  bool Changed = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeline">  Instruction::BinaryOps Opc = I.getOpcode();</td>
    <td class="lineNumber">1544</td>
    <td class="codeline">  Instruction::BinaryOps Opc = I.getOpcode();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeline">  Type *Ty = I.getType();</td>
    <td class="lineNumber">1545</td>
    <td class="codeline">  Type *Ty = I.getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeline">  Value *NewDiv = nullptr;</td>
    <td class="lineNumber">1546</td>
    <td class="codeline">  Value *NewDiv = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeline">  unsigned ScalarSize = Ty->getScalarSizeInBits();</td>
    <td class="lineNumber">1547</td>
    <td class="codeline">  unsigned ScalarSize = Ty->getScalarSizeInBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeline"></td>
    <td class="lineNumber">1548</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeline">  SmallVector<BinaryOperator *, 8> Div64ToExpand;</td>
    <td class="lineNumber">1549</td>
    <td class="codeline">  SmallVector<BinaryOperator *, 8> Div64ToExpand;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeline"></td>
    <td class="lineNumber">1550</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeline">  if ((Opc == Instruction::URem || Opc == Instruction::UDiv ||</td>
    <td class="lineNumber">1551</td>
    <td class="codeline">  if ((Opc == Instruction::URem || Opc == Instruction::UDiv ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeline">       Opc == Instruction::SRem || Opc == Instruction::SDiv) &&</td>
    <td class="lineNumber">1552</td>
    <td class="codeline">       Opc == Instruction::SRem || Opc == Instruction::SDiv) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeline">      ScalarSize <= 64 &&</td>
    <td class="lineNumber">1553</td>
    <td class="codeline">      ScalarSize <= 64 &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeline">      !DisableIDivExpand) {</td>
    <td class="lineNumber">1554</td>
    <td class="codeline">      !DisableIDivExpand) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeline">    Value *Num = I.getOperand(0);</td>
    <td class="lineNumber">1555</td>
    <td class="codeline">    Value *Num = I.getOperand(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeline">    Value *Den = I.getOperand(1);</td>
    <td class="lineNumber">1556</td>
    <td class="codeline">    Value *Den = I.getOperand(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeline">    IRBuilder<> Builder(&I);</td>
    <td class="lineNumber">1557</td>
    <td class="codeline">    IRBuilder<> Builder(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeline">    Builder.SetCurrentDebugLocation(I.getDebugLoc());</td>
    <td class="lineNumber">1558</td>
    <td class="codeline">    Builder.SetCurrentDebugLocation(I.getDebugLoc());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeline"></td>
    <td class="lineNumber">1559</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeline">    if (auto *VT = dyn_cast<FixedVectorType>(Ty)) {</td>
    <td class="lineNumber">1560</td>
    <td class="codeline">    if (auto *VT = dyn_cast<FixedVectorType>(Ty)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeline">      NewDiv = PoisonValue::get(VT);</td>
    <td class="lineNumber">1561</td>
    <td class="codeline">      NewDiv = PoisonValue::get(VT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeline"></td>
    <td class="lineNumber">1562</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeline">      for (unsigned N = 0, E = VT->getNumElements(); N != E; ++N) {</td>
    <td class="lineNumber">1563</td>
    <td class="codeline">      for (unsigned N = 0, E = VT->getNumElements(); N != E; ++N) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeline">        Value *NumEltN = Builder.CreateExtractElement(Num, N);</td>
    <td class="lineNumber">1564</td>
    <td class="codeline">        Value *NumEltN = Builder.CreateExtractElement(Num, N);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeline">        Value *DenEltN = Builder.CreateExtractElement(Den, N);</td>
    <td class="lineNumber">1565</td>
    <td class="codeline">        Value *DenEltN = Builder.CreateExtractElement(Den, N);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeline"></td>
    <td class="lineNumber">1566</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeline">        Value *NewElt;</td>
    <td class="lineNumber">1567</td>
    <td class="codeline">        Value *NewElt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeline">        if (ScalarSize <= 32) {</td>
    <td class="lineNumber">1568</td>
    <td class="codeline">        if (ScalarSize <= 32) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeline">          NewElt = expandDivRem32(Builder, I, NumEltN, DenEltN);</td>
    <td class="lineNumber">1569</td>
    <td class="codeline">          NewElt = expandDivRem32(Builder, I, NumEltN, DenEltN);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeline">          if (!NewElt)</td>
    <td class="lineNumber">1570</td>
    <td class="codeline">          if (!NewElt)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeline">            NewElt = Builder.CreateBinOp(Opc, NumEltN, DenEltN);</td>
    <td class="lineNumber">1571</td>
    <td class="codeline">            NewElt = Builder.CreateBinOp(Opc, NumEltN, DenEltN);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeline">        } else {</td>
    <td class="lineNumber">1572</td>
    <td class="codeline">        } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeline">          // See if this 64-bit division can be shrunk to 32/24-bits before</td>
    <td class="lineNumber">1573</td>
    <td class="codeline">          // See if this 64-bit division can be shrunk to 32/24-bits before</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeline">          // producing the general expansion.</td>
    <td class="lineNumber">1574</td>
    <td class="codeline">          // producing the general expansion.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeline">          NewElt = shrinkDivRem64(Builder, I, NumEltN, DenEltN);</td>
    <td class="lineNumber">1575</td>
    <td class="codeline">          NewElt = shrinkDivRem64(Builder, I, NumEltN, DenEltN);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeline">          if (!NewElt) {</td>
    <td class="lineNumber">1576</td>
    <td class="codeline">          if (!NewElt) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeline">            // The general 64-bit expansion introduces control flow and doesn't</td>
    <td class="lineNumber">1577</td>
    <td class="codeline">            // The general 64-bit expansion introduces control flow and doesn't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeline">            // return the new value. Just insert a scalar copy and defer</td>
    <td class="lineNumber">1578</td>
    <td class="codeline">            // return the new value. Just insert a scalar copy and defer</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeline">            // expanding it.</td>
    <td class="lineNumber">1579</td>
    <td class="codeline">            // expanding it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeline">            NewElt = Builder.CreateBinOp(Opc, NumEltN, DenEltN);</td>
    <td class="lineNumber">1580</td>
    <td class="codeline">            NewElt = Builder.CreateBinOp(Opc, NumEltN, DenEltN);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeline">            Div64ToExpand.push_back(cast<BinaryOperator>(NewElt));</td>
    <td class="lineNumber">1581</td>
    <td class="codeline">            Div64ToExpand.push_back(cast<BinaryOperator>(NewElt));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">1582</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1583</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeline"></td>
    <td class="lineNumber">1584</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeline">        NewDiv = Builder.CreateInsertElement(NewDiv, NewElt, N);</td>
    <td class="lineNumber">1585</td>
    <td class="codeline">        NewDiv = Builder.CreateInsertElement(NewDiv, NewElt, N);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1586</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">1587</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeline">      if (ScalarSize <= 32)</td>
    <td class="lineNumber">1588</td>
    <td class="codeline">      if (ScalarSize <= 32)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeline">        NewDiv = expandDivRem32(Builder, I, Num, Den);</td>
    <td class="lineNumber">1589</td>
    <td class="codeline">        NewDiv = expandDivRem32(Builder, I, Num, Den);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeline">      else {</td>
    <td class="lineNumber">1590</td>
    <td class="codeline">      else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeline">        NewDiv = shrinkDivRem64(Builder, I, Num, Den);</td>
    <td class="lineNumber">1591</td>
    <td class="codeline">        NewDiv = shrinkDivRem64(Builder, I, Num, Den);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeline">        if (!NewDiv)</td>
    <td class="lineNumber">1592</td>
    <td class="codeline">        if (!NewDiv)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeline">          Div64ToExpand.push_back(&I);</td>
    <td class="lineNumber">1593</td>
    <td class="codeline">          Div64ToExpand.push_back(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1594</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1595</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeline"></td>
    <td class="lineNumber">1596</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeline">    if (NewDiv) {</td>
    <td class="lineNumber">1597</td>
    <td class="codeline">    if (NewDiv) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeline">      I.replaceAllUsesWith(NewDiv);</td>
    <td class="lineNumber">1598</td>
    <td class="codeline">      I.replaceAllUsesWith(NewDiv);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeline">      I.eraseFromParent();</td>
    <td class="lineNumber">1599</td>
    <td class="codeline">      I.eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeline">      Changed = true;</td>
    <td class="lineNumber">1600</td>
    <td class="codeline">      Changed = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1601</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1602</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeline"></td>
    <td class="lineNumber">1603</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeline">  if (ExpandDiv64InIR) {</td>
    <td class="lineNumber">1604</td>
    <td class="codeline">  if (ExpandDiv64InIR) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeline">    // TODO: We get much worse code in specially handled constant cases.</td>
    <td class="lineNumber">1605</td>
    <td class="codeline">    // TODO: We get much worse code in specially handled constant cases.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeline">    for (BinaryOperator *Div : Div64ToExpand) {</td>
    <td class="lineNumber">1606</td>
    <td class="codeline">    for (BinaryOperator *Div : Div64ToExpand) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeline">      expandDivRem64(*Div);</td>
    <td class="lineNumber">1607</td>
    <td class="codeline">      expandDivRem64(*Div);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeline">      FlowChanged = true;</td>
    <td class="lineNumber">1608</td>
    <td class="codeline">      FlowChanged = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeline">      Changed = true;</td>
    <td class="lineNumber">1609</td>
    <td class="codeline">      Changed = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1610</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1611</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeline"></td>
    <td class="lineNumber">1612</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeline">  return Changed;</td>
    <td class="lineNumber">1613</td>
    <td class="codeline">  return Changed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1614</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeline"></td>
    <td class="lineNumber">1615</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::visitLoadInst(LoadInst &I) {</td>
    <td class="lineNumber">1616</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::visitLoadInst(LoadInst &I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeline">  if (!WidenLoads)</td>
    <td class="lineNumber">1617</td>
    <td class="codeline">  if (!WidenLoads)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1618</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeline"></td>
    <td class="lineNumber">1619</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeline">  if ((I.getPointerAddressSpace() == AMDGPUAS::CONSTANT_ADDRESS ||</td>
    <td class="lineNumber">1620</td>
    <td class="codeline">  if ((I.getPointerAddressSpace() == AMDGPUAS::CONSTANT_ADDRESS ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeline">       I.getPointerAddressSpace() == AMDGPUAS::CONSTANT_ADDRESS_32BIT) &&</td>
    <td class="lineNumber">1621</td>
    <td class="codeline">       I.getPointerAddressSpace() == AMDGPUAS::CONSTANT_ADDRESS_32BIT) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeline">      canWidenScalarExtLoad(I)) {</td>
    <td class="lineNumber">1622</td>
    <td class="codeline">      canWidenScalarExtLoad(I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeline">    IRBuilder<> Builder(&I);</td>
    <td class="lineNumber">1623</td>
    <td class="codeline">    IRBuilder<> Builder(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeline">    Builder.SetCurrentDebugLocation(I.getDebugLoc());</td>
    <td class="lineNumber">1624</td>
    <td class="codeline">    Builder.SetCurrentDebugLocation(I.getDebugLoc());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeline"></td>
    <td class="lineNumber">1625</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeline">    Type *I32Ty = Builder.getInt32Ty();</td>
    <td class="lineNumber">1626</td>
    <td class="codeline">    Type *I32Ty = Builder.getInt32Ty();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeline">    LoadInst *WidenLoad = Builder.CreateLoad(I32Ty, I.getPointerOperand());</td>
    <td class="lineNumber">1627</td>
    <td class="codeline">    LoadInst *WidenLoad = Builder.CreateLoad(I32Ty, I.getPointerOperand());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeline">    WidenLoad->copyMetadata(I);</td>
    <td class="lineNumber">1628</td>
    <td class="codeline">    WidenLoad->copyMetadata(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeline"></td>
    <td class="lineNumber">1629</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeline">    // If we have range metadata, we need to convert the type, and not make</td>
    <td class="lineNumber">1630</td>
    <td class="codeline">    // If we have range metadata, we need to convert the type, and not make</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeline">    // assumptions about the high bits.</td>
    <td class="lineNumber">1631</td>
    <td class="codeline">    // assumptions about the high bits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeline">    if (auto *Range = WidenLoad->getMetadata(LLVMContext::MD_range)) {</td>
    <td class="lineNumber">1632</td>
    <td class="codeline">    if (auto *Range = WidenLoad->getMetadata(LLVMContext::MD_range)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeline">      ConstantInt *Lower =</td>
    <td class="lineNumber">1633</td>
    <td class="codeline">      ConstantInt *Lower =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeline">        mdconst::extract<ConstantInt>(Range->getOperand(0));</td>
    <td class="lineNumber">1634</td>
    <td class="codeline">        mdconst::extract<ConstantInt>(Range->getOperand(0));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeline"></td>
    <td class="lineNumber">1635</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeline">      if (Lower->isNullValue()) {</td>
    <td class="lineNumber">1636</td>
    <td class="codeline">      if (Lower->isNullValue()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeline">        WidenLoad->setMetadata(LLVMContext::MD_range, nullptr);</td>
    <td class="lineNumber">1637</td>
    <td class="codeline">        WidenLoad->setMetadata(LLVMContext::MD_range, nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">1638</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeline">        Metadata *LowAndHigh[] = {</td>
    <td class="lineNumber">1639</td>
    <td class="codeline">        Metadata *LowAndHigh[] = {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeline">          ConstantAsMetadata::get(ConstantInt::get(I32Ty, Lower->getValue().zext(32))),</td>
    <td class="lineNumber">1640</td>
    <td class="codeline">          ConstantAsMetadata::get(ConstantInt::get(I32Ty, Lower->getValue().zext(32))),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeline">          // Don't make assumptions about the high bits.</td>
    <td class="lineNumber">1641</td>
    <td class="codeline">          // Don't make assumptions about the high bits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeline">          ConstantAsMetadata::get(ConstantInt::get(I32Ty, 0))</td>
    <td class="lineNumber">1642</td>
    <td class="codeline">          ConstantAsMetadata::get(ConstantInt::get(I32Ty, 0))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeline">        };</td>
    <td class="lineNumber">1643</td>
    <td class="codeline">        };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeline"></td>
    <td class="lineNumber">1644</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeline">        WidenLoad->setMetadata(LLVMContext::MD_range,</td>
    <td class="lineNumber">1645</td>
    <td class="codeline">        WidenLoad->setMetadata(LLVMContext::MD_range,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeline">                               MDNode::get(Mod->getContext(), LowAndHigh));</td>
    <td class="lineNumber">1646</td>
    <td class="codeline">                               MDNode::get(Mod->getContext(), LowAndHigh));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1647</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1648</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeline"></td>
    <td class="lineNumber">1649</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeline">    int TySize = Mod->getDataLayout().getTypeSizeInBits(I.getType());</td>
    <td class="lineNumber">1650</td>
    <td class="codeline">    int TySize = Mod->getDataLayout().getTypeSizeInBits(I.getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeline">    Type *IntNTy = Builder.getIntNTy(TySize);</td>
    <td class="lineNumber">1651</td>
    <td class="codeline">    Type *IntNTy = Builder.getIntNTy(TySize);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeline">    Value *ValTrunc = Builder.CreateTrunc(WidenLoad, IntNTy);</td>
    <td class="lineNumber">1652</td>
    <td class="codeline">    Value *ValTrunc = Builder.CreateTrunc(WidenLoad, IntNTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeline">    Value *ValOrig = Builder.CreateBitCast(ValTrunc, I.getType());</td>
    <td class="lineNumber">1653</td>
    <td class="codeline">    Value *ValOrig = Builder.CreateBitCast(ValTrunc, I.getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeline">    I.replaceAllUsesWith(ValOrig);</td>
    <td class="lineNumber">1654</td>
    <td class="codeline">    I.replaceAllUsesWith(ValOrig);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeline">    I.eraseFromParent();</td>
    <td class="lineNumber">1655</td>
    <td class="codeline">    I.eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">1656</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1657</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeline"></td>
    <td class="lineNumber">1658</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">1659</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1660</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeline"></td>
    <td class="lineNumber">1661</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::visitICmpInst(ICmpInst &I) {</td>
    <td class="lineNumber">1662</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::visitICmpInst(ICmpInst &I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeline">  bool Changed = false;</td>
    <td class="lineNumber">1663</td>
    <td class="codeline">  bool Changed = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeline"></td>
    <td class="lineNumber">1664</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeline">  if (ST->has16BitInsts() && needsPromotionToI32(I.getOperand(0)->getType()) &&</td>
    <td class="lineNumber">1665</td>
    <td class="codeline">  if (ST->has16BitInsts() && needsPromotionToI32(I.getOperand(0)->getType()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeline">      UA->isUniform(&I))</td>
    <td class="lineNumber">1666</td>
    <td class="codeline">      UA->isUniform(&I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeline">    Changed |= promoteUniformOpToI32(I);</td>
    <td class="lineNumber">1667</td>
    <td class="codeline">    Changed |= promoteUniformOpToI32(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeline"></td>
    <td class="lineNumber">1668</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeline">  return Changed;</td>
    <td class="lineNumber">1669</td>
    <td class="codeline">  return Changed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1670</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeline"></td>
    <td class="lineNumber">1671</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::visitSelectInst(SelectInst &I) {</td>
    <td class="lineNumber">1672</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::visitSelectInst(SelectInst &I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeline">  Value *Cond = I.getCondition();</td>
    <td class="lineNumber">1673</td>
    <td class="codeline">  Value *Cond = I.getCondition();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeline">  Value *TrueVal = I.getTrueValue();</td>
    <td class="lineNumber">1674</td>
    <td class="codeline">  Value *TrueVal = I.getTrueValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeline">  Value *FalseVal = I.getFalseValue();</td>
    <td class="lineNumber">1675</td>
    <td class="codeline">  Value *FalseVal = I.getFalseValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeline">  Value *CmpVal;</td>
    <td class="lineNumber">1676</td>
    <td class="codeline">  Value *CmpVal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeline">  FCmpInst::Predicate Pred;</td>
    <td class="lineNumber">1677</td>
    <td class="codeline">  FCmpInst::Predicate Pred;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeline"></td>
    <td class="lineNumber">1678</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeline">  if (ST->has16BitInsts() && needsPromotionToI32(I.getType())) {</td>
    <td class="lineNumber">1679</td>
    <td class="codeline">  if (ST->has16BitInsts() && needsPromotionToI32(I.getType())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeline">    if (UA->isUniform(&I))</td>
    <td class="lineNumber">1680</td>
    <td class="codeline">    if (UA->isUniform(&I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeline">      return promoteUniformOpToI32(I);</td>
    <td class="lineNumber">1681</td>
    <td class="codeline">      return promoteUniformOpToI32(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1682</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1683</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeline"></td>
    <td class="lineNumber">1684</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeline">  // Match fract pattern with nan check.</td>
    <td class="lineNumber">1685</td>
    <td class="codeline">  // Match fract pattern with nan check.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeline">  if (!match(Cond, m_FCmp(Pred, m_Value(CmpVal), m_NonNaN())))</td>
    <td class="lineNumber">1686</td>
    <td class="codeline">  if (!match(Cond, m_FCmp(Pred, m_Value(CmpVal), m_NonNaN())))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1687</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeline"></td>
    <td class="lineNumber">1688</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeline">  FPMathOperator *FPOp = dyn_cast<FPMathOperator>(&I);</td>
    <td class="lineNumber">1689</td>
    <td class="codeline">  FPMathOperator *FPOp = dyn_cast<FPMathOperator>(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeline">  if (!FPOp)</td>
    <td class="lineNumber">1690</td>
    <td class="codeline">  if (!FPOp)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1691</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeline"></td>
    <td class="lineNumber">1692</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeline">  IRBuilder<> Builder(&I);</td>
    <td class="lineNumber">1693</td>
    <td class="codeline">  IRBuilder<> Builder(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeline">  Builder.setFastMathFlags(FPOp->getFastMathFlags());</td>
    <td class="lineNumber">1694</td>
    <td class="codeline">  Builder.setFastMathFlags(FPOp->getFastMathFlags());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeline"></td>
    <td class="lineNumber">1695</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeline">  auto *IITrue = dyn_cast<IntrinsicInst>(TrueVal);</td>
    <td class="lineNumber">1696</td>
    <td class="codeline">  auto *IITrue = dyn_cast<IntrinsicInst>(TrueVal);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeline">  auto *IIFalse = dyn_cast<IntrinsicInst>(FalseVal);</td>
    <td class="lineNumber">1697</td>
    <td class="codeline">  auto *IIFalse = dyn_cast<IntrinsicInst>(FalseVal);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeline"></td>
    <td class="lineNumber">1698</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeline">  Value *Fract = nullptr;</td>
    <td class="lineNumber">1699</td>
    <td class="codeline">  Value *Fract = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeline">  if (Pred == FCmpInst::FCMP_UNO && TrueVal == CmpVal && IIFalse &&</td>
    <td class="lineNumber">1700</td>
    <td class="codeline">  if (Pred == FCmpInst::FCMP_UNO && TrueVal == CmpVal && IIFalse &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeline">      CmpVal == matchFractPat(*IIFalse)) {</td>
    <td class="lineNumber">1701</td>
    <td class="codeline">      CmpVal == matchFractPat(*IIFalse)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeline">    // isnan(x) ? x : fract(x)</td>
    <td class="lineNumber">1702</td>
    <td class="codeline">    // isnan(x) ? x : fract(x)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeline">    Fract = applyFractPat(Builder, CmpVal);</td>
    <td class="lineNumber">1703</td>
    <td class="codeline">    Fract = applyFractPat(Builder, CmpVal);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeline">  } else if (Pred == FCmpInst::FCMP_ORD && FalseVal == CmpVal && IITrue &&</td>
    <td class="lineNumber">1704</td>
    <td class="codeline">  } else if (Pred == FCmpInst::FCMP_ORD && FalseVal == CmpVal && IITrue &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeline">             CmpVal == matchFractPat(*IITrue)) {</td>
    <td class="lineNumber">1705</td>
    <td class="codeline">             CmpVal == matchFractPat(*IITrue)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeline">    // !isnan(x) ? fract(x) : x</td>
    <td class="lineNumber">1706</td>
    <td class="codeline">    // !isnan(x) ? fract(x) : x</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeline">    Fract = applyFractPat(Builder, CmpVal);</td>
    <td class="lineNumber">1707</td>
    <td class="codeline">    Fract = applyFractPat(Builder, CmpVal);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeline">  } else</td>
    <td class="lineNumber">1708</td>
    <td class="codeline">  } else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1709</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeline"></td>
    <td class="lineNumber">1710</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeline">  Fract->takeName(&I);</td>
    <td class="lineNumber">1711</td>
    <td class="codeline">  Fract->takeName(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeline">  I.replaceAllUsesWith(Fract);</td>
    <td class="lineNumber">1712</td>
    <td class="codeline">  I.replaceAllUsesWith(Fract);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeline">  RecursivelyDeleteTriviallyDeadInstructions(&I, TLInfo);</td>
    <td class="lineNumber">1713</td>
    <td class="codeline">  RecursivelyDeleteTriviallyDeadInstructions(&I, TLInfo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">1714</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1715</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeline"></td>
    <td class="lineNumber">1716</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeline">static bool areInSameBB(const Value *A, const Value *B) {</td>
    <td class="lineNumber">1717</td>
    <td class="codeline">static bool areInSameBB(const Value *A, const Value *B) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeline">  const auto *IA = dyn_cast<Instruction>(A);</td>
    <td class="lineNumber">1718</td>
    <td class="codeline">  const auto *IA = dyn_cast<Instruction>(A);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeline">  const auto *IB = dyn_cast<Instruction>(B);</td>
    <td class="lineNumber">1719</td>
    <td class="codeline">  const auto *IB = dyn_cast<Instruction>(B);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeline">  return IA && IB && IA->getParent() == IB->getParent();</td>
    <td class="lineNumber">1720</td>
    <td class="codeline">  return IA && IB && IA->getParent() == IB->getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1721</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeline"></td>
    <td class="lineNumber">1722</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeline">// Helper for breaking large PHIs that returns true when an extractelement on V</td>
    <td class="lineNumber">1723</td>
    <td class="codeline">// Helper for breaking large PHIs that returns true when an extractelement on V</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeline">// is likely to be folded away by the DAG combiner.</td>
    <td class="lineNumber">1724</td>
    <td class="codeline">// is likely to be folded away by the DAG combiner.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeline">static bool isInterestingPHIIncomingValue(const Value *V) {</td>
    <td class="lineNumber">1725</td>
    <td class="codeline">static bool isInterestingPHIIncomingValue(const Value *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeline">  const auto *FVT = dyn_cast<FixedVectorType>(V->getType());</td>
    <td class="lineNumber">1726</td>
    <td class="codeline">  const auto *FVT = dyn_cast<FixedVectorType>(V->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeline">  if (!FVT)</td>
    <td class="lineNumber">1727</td>
    <td class="codeline">  if (!FVT)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1728</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeline"></td>
    <td class="lineNumber">1729</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeline">  const Value *CurVal = V;</td>
    <td class="lineNumber">1730</td>
    <td class="codeline">  const Value *CurVal = V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeline"></td>
    <td class="lineNumber">1731</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeline">  // Check for insertelements, keeping track of the elements covered.</td>
    <td class="lineNumber">1732</td>
    <td class="codeline">  // Check for insertelements, keeping track of the elements covered.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeline">  BitVector EltsCovered(FVT->getNumElements());</td>
    <td class="lineNumber">1733</td>
    <td class="codeline">  BitVector EltsCovered(FVT->getNumElements());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeline">  while (const auto *IE = dyn_cast<InsertElementInst>(CurVal)) {</td>
    <td class="lineNumber">1734</td>
    <td class="codeline">  while (const auto *IE = dyn_cast<InsertElementInst>(CurVal)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeline">    const auto *Idx = dyn_cast<ConstantInt>(IE->getOperand(2));</td>
    <td class="lineNumber">1735</td>
    <td class="codeline">    const auto *Idx = dyn_cast<ConstantInt>(IE->getOperand(2));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeline"></td>
    <td class="lineNumber">1736</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeline">    // Non constant index/out of bounds index -> folding is unlikely.</td>
    <td class="lineNumber">1737</td>
    <td class="codeline">    // Non constant index/out of bounds index -> folding is unlikely.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeline">    // The latter is more of a sanity check because canonical IR should just</td>
    <td class="lineNumber">1738</td>
    <td class="codeline">    // The latter is more of a sanity check because canonical IR should just</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeline">    // have replaced those with poison.</td>
    <td class="lineNumber">1739</td>
    <td class="codeline">    // have replaced those with poison.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeline">    if (!Idx || Idx->getSExtValue() >= FVT->getNumElements())</td>
    <td class="lineNumber">1740</td>
    <td class="codeline">    if (!Idx || Idx->getSExtValue() >= FVT->getNumElements())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1741</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeline"></td>
    <td class="lineNumber">1742</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeline">    const auto *VecSrc = IE->getOperand(0);</td>
    <td class="lineNumber">1743</td>
    <td class="codeline">    const auto *VecSrc = IE->getOperand(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeline"></td>
    <td class="lineNumber">1744</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeline">    // If the vector source is another instruction, it must be in the same basic</td>
    <td class="lineNumber">1745</td>
    <td class="codeline">    // If the vector source is another instruction, it must be in the same basic</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeline">    // block. Otherwise, the DAGCombiner won't see the whole thing and is</td>
    <td class="lineNumber">1746</td>
    <td class="codeline">    // block. Otherwise, the DAGCombiner won't see the whole thing and is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeline">    // unlikely to be able to do anything interesting here.</td>
    <td class="lineNumber">1747</td>
    <td class="codeline">    // unlikely to be able to do anything interesting here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeline">    if (isa<Instruction>(VecSrc) && !areInSameBB(VecSrc, IE))</td>
    <td class="lineNumber">1748</td>
    <td class="codeline">    if (isa<Instruction>(VecSrc) && !areInSameBB(VecSrc, IE))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1749</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeline"></td>
    <td class="lineNumber">1750</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeline">    CurVal = VecSrc;</td>
    <td class="lineNumber">1751</td>
    <td class="codeline">    CurVal = VecSrc;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeline">    EltsCovered.set(Idx->getSExtValue());</td>
    <td class="lineNumber">1752</td>
    <td class="codeline">    EltsCovered.set(Idx->getSExtValue());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeline"></td>
    <td class="lineNumber">1753</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeline">    // All elements covered.</td>
    <td class="lineNumber">1754</td>
    <td class="codeline">    // All elements covered.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeline">    if (EltsCovered.all())</td>
    <td class="lineNumber">1755</td>
    <td class="codeline">    if (EltsCovered.all())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">1756</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1757</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeline"></td>
    <td class="lineNumber">1758</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeline">  // We either didn't find a single insertelement, or the insertelement chain</td>
    <td class="lineNumber">1759</td>
    <td class="codeline">  // We either didn't find a single insertelement, or the insertelement chain</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeline">  // ended before all elements were covered. Check for other interesting values.</td>
    <td class="lineNumber">1760</td>
    <td class="codeline">  // ended before all elements were covered. Check for other interesting values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeline"></td>
    <td class="lineNumber">1761</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeline">  // Constants are always interesting because we can just constant fold the</td>
    <td class="lineNumber">1762</td>
    <td class="codeline">  // Constants are always interesting because we can just constant fold the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeline">  // extractelements.</td>
    <td class="lineNumber">1763</td>
    <td class="codeline">  // extractelements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeline">  if (isa<Constant>(CurVal))</td>
    <td class="lineNumber">1764</td>
    <td class="codeline">  if (isa<Constant>(CurVal))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">1765</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeline"></td>
    <td class="lineNumber">1766</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeline">  // shufflevector is likely to be profitable if either operand is a constant,</td>
    <td class="lineNumber">1767</td>
    <td class="codeline">  // shufflevector is likely to be profitable if either operand is a constant,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeline">  // or if either source is in the same block.</td>
    <td class="lineNumber">1768</td>
    <td class="codeline">  // or if either source is in the same block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeline">  // This is because shufflevector is most often lowered as a series of</td>
    <td class="lineNumber">1769</td>
    <td class="codeline">  // This is because shufflevector is most often lowered as a series of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeline">  // insert/extract elements anyway.</td>
    <td class="lineNumber">1770</td>
    <td class="codeline">  // insert/extract elements anyway.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeline">  if (const auto *SV = dyn_cast<ShuffleVectorInst>(CurVal)) {</td>
    <td class="lineNumber">1771</td>
    <td class="codeline">  if (const auto *SV = dyn_cast<ShuffleVectorInst>(CurVal)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeline">    return isa<Constant>(SV->getOperand(1)) ||</td>
    <td class="lineNumber">1772</td>
    <td class="codeline">    return isa<Constant>(SV->getOperand(1)) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeline">           areInSameBB(SV, SV->getOperand(0)) ||</td>
    <td class="lineNumber">1773</td>
    <td class="codeline">           areInSameBB(SV, SV->getOperand(0)) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeline">           areInSameBB(SV, SV->getOperand(1));</td>
    <td class="lineNumber">1774</td>
    <td class="codeline">           areInSameBB(SV, SV->getOperand(1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1775</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeline"></td>
    <td class="lineNumber">1776</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">1777</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1778</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeline"></td>
    <td class="lineNumber">1779</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::canBreakPHINode(const PHINode &I) {</td>
    <td class="lineNumber">1780</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::canBreakPHINode(const PHINode &I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeline">  // Check in the cache, or add an entry for this node.</td>
    <td class="lineNumber">1781</td>
    <td class="codeline">  // Check in the cache, or add an entry for this node.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1782</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeline">  // We init with false because we consider all PHI nodes unbreakable until we</td>
    <td class="lineNumber">1783</td>
    <td class="codeline">  // We init with false because we consider all PHI nodes unbreakable until we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeline">  // reach a conclusion. Doing the opposite - assuming they're break-able until</td>
    <td class="lineNumber">1784</td>
    <td class="codeline">  // reach a conclusion. Doing the opposite - assuming they're break-able until</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeline">  // proven otherwise - can be harmful in some pathological cases so we're</td>
    <td class="lineNumber">1785</td>
    <td class="codeline">  // proven otherwise - can be harmful in some pathological cases so we're</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeline">  // conservative for now.</td>
    <td class="lineNumber">1786</td>
    <td class="codeline">  // conservative for now.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeline">  const auto [It, DidInsert] = BreakPhiNodesCache.insert({&I, false});</td>
    <td class="lineNumber">1787</td>
    <td class="codeline">  const auto [It, DidInsert] = BreakPhiNodesCache.insert({&I, false});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeline">  if (!DidInsert)</td>
    <td class="lineNumber">1788</td>
    <td class="codeline">  if (!DidInsert)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeline">    return It->second;</td>
    <td class="lineNumber">1789</td>
    <td class="codeline">    return It->second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeline"></td>
    <td class="lineNumber">1790</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeline">  // This function may recurse, so to guard against infinite looping, this PHI</td>
    <td class="lineNumber">1791</td>
    <td class="codeline">  // This function may recurse, so to guard against infinite looping, this PHI</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeline">  // is conservatively considered unbreakable until we reach a conclusion.</td>
    <td class="lineNumber">1792</td>
    <td class="codeline">  // is conservatively considered unbreakable until we reach a conclusion.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="codeline"></td>
    <td class="lineNumber">1793</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="codeline">  // Don't break PHIs that have no interesting incoming values. That is, where</td>
    <td class="lineNumber">1794</td>
    <td class="codeline">  // Don't break PHIs that have no interesting incoming values. That is, where</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="codeline">  // there is no clear opportunity to fold the "extractelement" instructions we</td>
    <td class="lineNumber">1795</td>
    <td class="codeline">  // there is no clear opportunity to fold the "extractelement" instructions we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="codeline">  // would add.</td>
    <td class="lineNumber">1796</td>
    <td class="codeline">  // would add.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1797</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="codeline">  // Note: IC does not run after this pass, so we're only interested in the</td>
    <td class="lineNumber">1798</td>
    <td class="codeline">  // Note: IC does not run after this pass, so we're only interested in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="codeline">  // foldings that the DAG combiner can do.</td>
    <td class="lineNumber">1799</td>
    <td class="codeline">  // foldings that the DAG combiner can do.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="codeline">  if (none_of(I.incoming_values(),</td>
    <td class="lineNumber">1800</td>
    <td class="codeline">  if (none_of(I.incoming_values(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="codeline">              [&](Value *V) { return isInterestingPHIIncomingValue(V); }))</td>
    <td class="lineNumber">1801</td>
    <td class="codeline">              [&](Value *V) { return isInterestingPHIIncomingValue(V); }))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1802</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="codeline"></td>
    <td class="lineNumber">1803</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="codeline">  // Now, check users for unbreakable PHI nodes. If we have an unbreakable PHI</td>
    <td class="lineNumber">1804</td>
    <td class="codeline">  // Now, check users for unbreakable PHI nodes. If we have an unbreakable PHI</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="codeline">  // node as user, we don't want to break this PHI either because it's unlikely</td>
    <td class="lineNumber">1805</td>
    <td class="codeline">  // node as user, we don't want to break this PHI either because it's unlikely</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="codeline">  // to be beneficial. We would just explode the vector and reassemble it</td>
    <td class="lineNumber">1806</td>
    <td class="codeline">  // to be beneficial. We would just explode the vector and reassemble it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="codeline">  // directly, wasting instructions.</td>
    <td class="lineNumber">1807</td>
    <td class="codeline">  // directly, wasting instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1808</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="codeline">  // In the case where multiple users are PHI nodes, we want at least half of</td>
    <td class="lineNumber">1809</td>
    <td class="codeline">  // In the case where multiple users are PHI nodes, we want at least half of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="codeline">  // them to be breakable.</td>
    <td class="lineNumber">1810</td>
    <td class="codeline">  // them to be breakable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="codeline">  int Score = 0;</td>
    <td class="lineNumber">1811</td>
    <td class="codeline">  int Score = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="codeline">  for (const Value *U : I.users()) {</td>
    <td class="lineNumber">1812</td>
    <td class="codeline">  for (const Value *U : I.users()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="codeline">    if (const auto *PU = dyn_cast<PHINode>(U))</td>
    <td class="lineNumber">1813</td>
    <td class="codeline">    if (const auto *PU = dyn_cast<PHINode>(U))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="codeline">      Score += canBreakPHINode(*PU) ? 1 : -1;</td>
    <td class="lineNumber">1814</td>
    <td class="codeline">      Score += canBreakPHINode(*PU) ? 1 : -1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1815</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="codeline"></td>
    <td class="lineNumber">1816</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="codeline">  if (Score < 0)</td>
    <td class="lineNumber">1817</td>
    <td class="codeline">  if (Score < 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1818</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="codeline"></td>
    <td class="lineNumber">1819</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="codeline">  return BreakPhiNodesCache[&I] = true;</td>
    <td class="lineNumber">1820</td>
    <td class="codeline">  return BreakPhiNodesCache[&I] = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1821</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="codeline"></td>
    <td class="lineNumber">1822</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="codeline">/// Helper class for "break large PHIs" (visitPHINode).</td>
    <td class="lineNumber">1823</td>
    <td class="codeline">/// Helper class for "break large PHIs" (visitPHINode).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1824</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="codeline">/// This represents a slice of a PHI's incoming value, which is made up of:</td>
    <td class="lineNumber">1825</td>
    <td class="codeline">/// This represents a slice of a PHI's incoming value, which is made up of:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="codeline">///   - The type of the slice (Ty)</td>
    <td class="lineNumber">1826</td>
    <td class="codeline">///   - The type of the slice (Ty)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="codeline">///   - The index in the incoming value's vector where the slice starts (Idx)</td>
    <td class="lineNumber">1827</td>
    <td class="codeline">///   - The index in the incoming value's vector where the slice starts (Idx)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="codeline">///   - The number of elements in the slice (NumElts).</td>
    <td class="lineNumber">1828</td>
    <td class="codeline">///   - The number of elements in the slice (NumElts).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="codeline">/// It also keeps track of the NewPHI node inserted for this particular slice.</td>
    <td class="lineNumber">1829</td>
    <td class="codeline">/// It also keeps track of the NewPHI node inserted for this particular slice.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1830</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="codeline">/// Slice examples:</td>
    <td class="lineNumber">1831</td>
    <td class="codeline">/// Slice examples:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="codeline">///   <4 x i64> -> Split into four i64 slices.</td>
    <td class="lineNumber">1832</td>
    <td class="codeline">///   <4 x i64> -> Split into four i64 slices.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="codeline">///     -> [i64, 0, 1], [i64, 1, 1], [i64, 2, 1], [i64, 3, 1]</td>
    <td class="lineNumber">1833</td>
    <td class="codeline">///     -> [i64, 0, 1], [i64, 1, 1], [i64, 2, 1], [i64, 3, 1]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="codeline">///   <5 x i16> -> Split into 2 <2 x i16> slices + a i16 tail.</td>
    <td class="lineNumber">1834</td>
    <td class="codeline">///   <5 x i16> -> Split into 2 <2 x i16> slices + a i16 tail.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="codeline">///     -> [<2 x i16>, 0, 2], [<2 x i16>, 2, 2], [i16, 4, 1]</td>
    <td class="lineNumber">1835</td>
    <td class="codeline">///     -> [<2 x i16>, 0, 2], [<2 x i16>, 2, 2], [i16, 4, 1]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="codeline">class VectorSlice {</td>
    <td class="lineNumber">1836</td>
    <td class="codeline">class VectorSlice {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">1837</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="codeline">  VectorSlice(Type *Ty, unsigned Idx, unsigned NumElts)</td>
    <td class="lineNumber">1838</td>
    <td class="codeline">  VectorSlice(Type *Ty, unsigned Idx, unsigned NumElts)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="codeline">      : Ty(Ty), Idx(Idx), NumElts(NumElts) {}</td>
    <td class="lineNumber">1839</td>
    <td class="codeline">      : Ty(Ty), Idx(Idx), NumElts(NumElts) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="codeline"></td>
    <td class="lineNumber">1840</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="codeline">  Type *Ty = nullptr;</td>
    <td class="lineNumber">1841</td>
    <td class="codeline">  Type *Ty = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="codeline">  unsigned Idx = 0;</td>
    <td class="lineNumber">1842</td>
    <td class="codeline">  unsigned Idx = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="codeline">  unsigned NumElts = 0;</td>
    <td class="lineNumber">1843</td>
    <td class="codeline">  unsigned NumElts = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="codeline">  PHINode *NewPHI = nullptr;</td>
    <td class="lineNumber">1844</td>
    <td class="codeline">  PHINode *NewPHI = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="codeline"></td>
    <td class="lineNumber">1845</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="codeline">  /// Slice \p Inc according to the information contained within this slice.</td>
    <td class="lineNumber">1846</td>
    <td class="codeline">  /// Slice \p Inc according to the information contained within this slice.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="codeline">  /// This is cached, so if called multiple times for the same \p BB & \p Inc</td>
    <td class="lineNumber">1847</td>
    <td class="codeline">  /// This is cached, so if called multiple times for the same \p BB & \p Inc</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="codeline">  /// pair, it returns the same Sliced value as well.</td>
    <td class="lineNumber">1848</td>
    <td class="codeline">  /// pair, it returns the same Sliced value as well.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1849</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="codeline">  /// Note this *intentionally* does not return the same value for, say,</td>
    <td class="lineNumber">1850</td>
    <td class="codeline">  /// Note this *intentionally* does not return the same value for, say,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="codeline">  /// [%bb.0, %0] & [%bb.1, %0] as:</td>
    <td class="lineNumber">1851</td>
    <td class="codeline">  /// [%bb.0, %0] & [%bb.1, %0] as:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="codeline">  ///   - It could cause issues with dominance (e.g. if bb.1 is seen first, then</td>
    <td class="lineNumber">1852</td>
    <td class="codeline">  ///   - It could cause issues with dominance (e.g. if bb.1 is seen first, then</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="codeline">  ///   the value in bb.1 may not be reachable from bb.0 if it's its</td>
    <td class="lineNumber">1853</td>
    <td class="codeline">  ///   the value in bb.1 may not be reachable from bb.0 if it's its</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="codeline">  ///   predecessor.)</td>
    <td class="lineNumber">1854</td>
    <td class="codeline">  ///   predecessor.)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="codeline">  ///   - We also want to make our extract instructions as local as possible so</td>
    <td class="lineNumber">1855</td>
    <td class="codeline">  ///   - We also want to make our extract instructions as local as possible so</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="codeline">  ///   the DAG has better chances of folding them out. Duplicating them like</td>
    <td class="lineNumber">1856</td>
    <td class="codeline">  ///   the DAG has better chances of folding them out. Duplicating them like</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="codeline">  ///   that is beneficial in that regard.</td>
    <td class="lineNumber">1857</td>
    <td class="codeline">  ///   that is beneficial in that regard.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1858</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="codeline">  /// This is both a minor optimization to avoid creating duplicate</td>
    <td class="lineNumber">1859</td>
    <td class="codeline">  /// This is both a minor optimization to avoid creating duplicate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="codeline">  /// instructions, but also a requirement for correctness. It is not forbidden</td>
    <td class="lineNumber">1860</td>
    <td class="codeline">  /// instructions, but also a requirement for correctness. It is not forbidden</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="codeline">  /// for a PHI node to have the same [BB, Val] pair multiple times. If we</td>
    <td class="lineNumber">1861</td>
    <td class="codeline">  /// for a PHI node to have the same [BB, Val] pair multiple times. If we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="codeline">  /// returned a new value each time, those previously identical pairs would all</td>
    <td class="lineNumber">1862</td>
    <td class="codeline">  /// returned a new value each time, those previously identical pairs would all</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="codeline">  /// have different incoming values (from the same block) and it'd cause a "PHI</td>
    <td class="lineNumber">1863</td>
    <td class="codeline">  /// have different incoming values (from the same block) and it'd cause a "PHI</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="codeline">  /// node has multiple entries for the same basic block with different incoming</td>
    <td class="lineNumber">1864</td>
    <td class="codeline">  /// node has multiple entries for the same basic block with different incoming</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="codeline">  /// values!" verifier error.</td>
    <td class="lineNumber">1865</td>
    <td class="codeline">  /// values!" verifier error.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="codeline">  Value *getSlicedVal(BasicBlock *BB, Value *Inc, StringRef NewValName) {</td>
    <td class="lineNumber">1866</td>
    <td class="codeline">  Value *getSlicedVal(BasicBlock *BB, Value *Inc, StringRef NewValName) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="codeline">    Value *&Res = SlicedVals[{BB, Inc}];</td>
    <td class="lineNumber">1867</td>
    <td class="codeline">    Value *&Res = SlicedVals[{BB, Inc}];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="codeline">    if (Res)</td>
    <td class="lineNumber">1868</td>
    <td class="codeline">    if (Res)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="codeline">      return Res;</td>
    <td class="lineNumber">1869</td>
    <td class="codeline">      return Res;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="codeline"></td>
    <td class="lineNumber">1870</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="codeline">    IRBuilder<> B(BB->getTerminator());</td>
    <td class="lineNumber">1871</td>
    <td class="codeline">    IRBuilder<> B(BB->getTerminator());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="codeline">    if (Instruction *IncInst = dyn_cast<Instruction>(Inc))</td>
    <td class="lineNumber">1872</td>
    <td class="codeline">    if (Instruction *IncInst = dyn_cast<Instruction>(Inc))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="codeline">      B.SetCurrentDebugLocation(IncInst->getDebugLoc());</td>
    <td class="lineNumber">1873</td>
    <td class="codeline">      B.SetCurrentDebugLocation(IncInst->getDebugLoc());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="codeline"></td>
    <td class="lineNumber">1874</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="codeline">    if (NumElts > 1) {</td>
    <td class="lineNumber">1875</td>
    <td class="codeline">    if (NumElts > 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="codeline">      SmallVector<int, 4> Mask;</td>
    <td class="lineNumber">1876</td>
    <td class="codeline">      SmallVector<int, 4> Mask;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="codeline">      for (unsigned K = Idx; K < (Idx + NumElts); ++K)</td>
    <td class="lineNumber">1877</td>
    <td class="codeline">      for (unsigned K = Idx; K < (Idx + NumElts); ++K)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="codeline">        Mask.push_back(K);</td>
    <td class="lineNumber">1878</td>
    <td class="codeline">        Mask.push_back(K);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="codeline">      Res = B.CreateShuffleVector(Inc, Mask, NewValName);</td>
    <td class="lineNumber">1879</td>
    <td class="codeline">      Res = B.CreateShuffleVector(Inc, Mask, NewValName);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="codeline">    } else</td>
    <td class="lineNumber">1880</td>
    <td class="codeline">    } else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="codeline">      Res = B.CreateExtractElement(Inc, Idx, NewValName);</td>
    <td class="lineNumber">1881</td>
    <td class="codeline">      Res = B.CreateExtractElement(Inc, Idx, NewValName);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="codeline"></td>
    <td class="lineNumber">1882</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="codeline">    return Res;</td>
    <td class="lineNumber">1883</td>
    <td class="codeline">    return Res;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1884</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="codeline"></td>
    <td class="lineNumber">1885</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">1886</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="codeline">  SmallDenseMap<std::pair<BasicBlock *, Value *>, Value *> SlicedVals;</td>
    <td class="lineNumber">1887</td>
    <td class="codeline">  SmallDenseMap<std::pair<BasicBlock *, Value *>, Value *> SlicedVals;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1888</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="codeline"></td>
    <td class="lineNumber">1889</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::visitPHINode(PHINode &I) {</td>
    <td class="lineNumber">1890</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::visitPHINode(PHINode &I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="codeline">  // Break-up fixed-vector PHIs into smaller pieces.</td>
    <td class="lineNumber">1891</td>
    <td class="codeline">  // Break-up fixed-vector PHIs into smaller pieces.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="codeline">  // Default threshold is 32, so it breaks up any vector that's >32 bits into</td>
    <td class="lineNumber">1892</td>
    <td class="codeline">  // Default threshold is 32, so it breaks up any vector that's >32 bits into</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="codeline">  // its elements, or into 32-bit pieces (for 8/16 bit elts).</td>
    <td class="lineNumber">1893</td>
    <td class="codeline">  // its elements, or into 32-bit pieces (for 8/16 bit elts).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1894</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="codeline">  // This is only helpful for DAGISel because it doesn't handle large PHIs as</td>
    <td class="lineNumber">1895</td>
    <td class="codeline">  // This is only helpful for DAGISel because it doesn't handle large PHIs as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="codeline">  // well as GlobalISel. DAGISel lowers PHIs by using CopyToReg/CopyFromReg.</td>
    <td class="lineNumber">1896</td>
    <td class="codeline">  // well as GlobalISel. DAGISel lowers PHIs by using CopyToReg/CopyFromReg.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="codeline">  // With large, odd-sized PHIs we may end up needing many `build_vector`</td>
    <td class="lineNumber">1897</td>
    <td class="codeline">  // With large, odd-sized PHIs we may end up needing many `build_vector`</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="codeline">  // operations with most elements being "undef". This inhibits a lot of</td>
    <td class="lineNumber">1898</td>
    <td class="codeline">  // operations with most elements being "undef". This inhibits a lot of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="codeline">  // optimization opportunities and can result in unreasonably high register</td>
    <td class="lineNumber">1899</td>
    <td class="codeline">  // optimization opportunities and can result in unreasonably high register</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="codeline">  // pressure and the inevitable stack spilling.</td>
    <td class="lineNumber">1900</td>
    <td class="codeline">  // pressure and the inevitable stack spilling.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="codeline">  if (!ScalarizeLargePHIs || getCGPassBuilderOption().EnableGlobalISelOption)</td>
    <td class="lineNumber">1901</td>
    <td class="codeline">  if (!ScalarizeLargePHIs || getCGPassBuilderOption().EnableGlobalISelOption)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1902</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="codeline"></td>
    <td class="lineNumber">1903</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="codeline">  FixedVectorType *FVT = dyn_cast<FixedVectorType>(I.getType());</td>
    <td class="lineNumber">1904</td>
    <td class="codeline">  FixedVectorType *FVT = dyn_cast<FixedVectorType>(I.getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="codeline">  if (!FVT || DL->getTypeSizeInBits(FVT) <= ScalarizeLargePHIsThreshold)</td>
    <td class="lineNumber">1905</td>
    <td class="codeline">  if (!FVT || DL->getTypeSizeInBits(FVT) <= ScalarizeLargePHIsThreshold)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1906</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="codeline"></td>
    <td class="lineNumber">1907</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="codeline">  if (!ForceScalarizeLargePHIs && !canBreakPHINode(I))</td>
    <td class="lineNumber">1908</td>
    <td class="codeline">  if (!ForceScalarizeLargePHIs && !canBreakPHINode(I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1909</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="codeline"></td>
    <td class="lineNumber">1910</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="codeline">  std::vector<VectorSlice> Slices;</td>
    <td class="lineNumber">1911</td>
    <td class="codeline">  std::vector<VectorSlice> Slices;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="codeline"></td>
    <td class="lineNumber">1912</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="codeline">  Type *EltTy = FVT->getElementType();</td>
    <td class="lineNumber">1913</td>
    <td class="codeline">  Type *EltTy = FVT->getElementType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="codeline">  {</td>
    <td class="lineNumber">1914</td>
    <td class="codeline">  {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="codeline">    unsigned Idx = 0;</td>
    <td class="lineNumber">1915</td>
    <td class="codeline">    unsigned Idx = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="codeline">    // For 8/16 bits type, don't scalarize fully but break it up into as many</td>
    <td class="lineNumber">1916</td>
    <td class="codeline">    // For 8/16 bits type, don't scalarize fully but break it up into as many</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="codeline">    // 32-bit slices as we can, and scalarize the tail.</td>
    <td class="lineNumber">1917</td>
    <td class="codeline">    // 32-bit slices as we can, and scalarize the tail.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="codeline">    const unsigned EltSize = DL->getTypeSizeInBits(EltTy);</td>
    <td class="lineNumber">1918</td>
    <td class="codeline">    const unsigned EltSize = DL->getTypeSizeInBits(EltTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="codeline">    const unsigned NumElts = FVT->getNumElements();</td>
    <td class="lineNumber">1919</td>
    <td class="codeline">    const unsigned NumElts = FVT->getNumElements();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="codeline">    if (EltSize == 8 || EltSize == 16) {</td>
    <td class="lineNumber">1920</td>
    <td class="codeline">    if (EltSize == 8 || EltSize == 16) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="codeline">      const unsigned SubVecSize = (32 / EltSize);</td>
    <td class="lineNumber">1921</td>
    <td class="codeline">      const unsigned SubVecSize = (32 / EltSize);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="codeline">      Type *SubVecTy = FixedVectorType::get(EltTy, SubVecSize);</td>
    <td class="lineNumber">1922</td>
    <td class="codeline">      Type *SubVecTy = FixedVectorType::get(EltTy, SubVecSize);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="codeline">      for (unsigned End = alignDown(NumElts, SubVecSize); Idx < End;</td>
    <td class="lineNumber">1923</td>
    <td class="codeline">      for (unsigned End = alignDown(NumElts, SubVecSize); Idx < End;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="codeline">           Idx += SubVecSize)</td>
    <td class="lineNumber">1924</td>
    <td class="codeline">           Idx += SubVecSize)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="codeline">        Slices.emplace_back(SubVecTy, Idx, SubVecSize);</td>
    <td class="lineNumber">1925</td>
    <td class="codeline">        Slices.emplace_back(SubVecTy, Idx, SubVecSize);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1926</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="codeline"></td>
    <td class="lineNumber">1927</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="codeline">    // Scalarize all remaining elements.</td>
    <td class="lineNumber">1928</td>
    <td class="codeline">    // Scalarize all remaining elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="codeline">    for (; Idx < NumElts; ++Idx)</td>
    <td class="lineNumber">1929</td>
    <td class="codeline">    for (; Idx < NumElts; ++Idx)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="codeline">      Slices.emplace_back(EltTy, Idx, 1);</td>
    <td class="lineNumber">1930</td>
    <td class="codeline">      Slices.emplace_back(EltTy, Idx, 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1931</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="codeline"></td>
    <td class="lineNumber">1932</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="codeline">  if (Slices.size() == 1)</td>
    <td class="lineNumber">1933</td>
    <td class="codeline">  if (Slices.size() == 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1934</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="codeline"></td>
    <td class="lineNumber">1935</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="codeline">  // Create one PHI per vector piece. The "VectorSlice" class takes care of</td>
    <td class="lineNumber">1936</td>
    <td class="codeline">  // Create one PHI per vector piece. The "VectorSlice" class takes care of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="codeline">  // creating the necessary instruction to extract the relevant slices of each</td>
    <td class="lineNumber">1937</td>
    <td class="codeline">  // creating the necessary instruction to extract the relevant slices of each</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="codeline">  // incoming value.</td>
    <td class="lineNumber">1938</td>
    <td class="codeline">  // incoming value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="codeline">  IRBuilder<> B(I.getParent());</td>
    <td class="lineNumber">1939</td>
    <td class="codeline">  IRBuilder<> B(I.getParent());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="codeline">  B.SetCurrentDebugLocation(I.getDebugLoc());</td>
    <td class="lineNumber">1940</td>
    <td class="codeline">  B.SetCurrentDebugLocation(I.getDebugLoc());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="codeline"></td>
    <td class="lineNumber">1941</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="codeline">  unsigned IncNameSuffix = 0;</td>
    <td class="lineNumber">1942</td>
    <td class="codeline">  unsigned IncNameSuffix = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="codeline">  for (VectorSlice &S : Slices) {</td>
    <td class="lineNumber">1943</td>
    <td class="codeline">  for (VectorSlice &S : Slices) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="codeline">    // We need to reset the build on each iteration, because getSlicedVal may</td>
    <td class="lineNumber">1944</td>
    <td class="codeline">    // We need to reset the build on each iteration, because getSlicedVal may</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="codeline">    // have inserted something into I's BB.</td>
    <td class="lineNumber">1945</td>
    <td class="codeline">    // have inserted something into I's BB.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="codeline">    B.SetInsertPoint(I.getParent()->getFirstNonPHI());</td>
    <td class="lineNumber">1946</td>
    <td class="codeline">    B.SetInsertPoint(I.getParent()->getFirstNonPHI());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="codeline">    S.NewPHI = B.CreatePHI(S.Ty, I.getNumIncomingValues());</td>
    <td class="lineNumber">1947</td>
    <td class="codeline">    S.NewPHI = B.CreatePHI(S.Ty, I.getNumIncomingValues());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="codeline"></td>
    <td class="lineNumber">1948</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="codeline">    for (const auto &[Idx, BB] : enumerate(I.blocks())) {</td>
    <td class="lineNumber">1949</td>
    <td class="codeline">    for (const auto &[Idx, BB] : enumerate(I.blocks())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="codeline">      S.NewPHI->addIncoming(S.getSlicedVal(BB, I.getIncomingValue(Idx),</td>
    <td class="lineNumber">1950</td>
    <td class="codeline">      S.NewPHI->addIncoming(S.getSlicedVal(BB, I.getIncomingValue(Idx),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="codeline">                                           "largephi.extractslice" +</td>
    <td class="lineNumber">1951</td>
    <td class="codeline">                                           "largephi.extractslice" +</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="codeline">                                               std::to_string(IncNameSuffix++)),</td>
    <td class="lineNumber">1952</td>
    <td class="codeline">                                               std::to_string(IncNameSuffix++)),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="codeline">                            BB);</td>
    <td class="lineNumber">1953</td>
    <td class="codeline">                            BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1954</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1955</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="codeline"></td>
    <td class="lineNumber">1956</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="codeline">  // And replace this PHI with a vector of all the previous PHI values.</td>
    <td class="lineNumber">1957</td>
    <td class="codeline">  // And replace this PHI with a vector of all the previous PHI values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="codeline">  Value *Vec = PoisonValue::get(FVT);</td>
    <td class="lineNumber">1958</td>
    <td class="codeline">  Value *Vec = PoisonValue::get(FVT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="codeline">  unsigned NameSuffix = 0;</td>
    <td class="lineNumber">1959</td>
    <td class="codeline">  unsigned NameSuffix = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="codeline">  for (VectorSlice &S : Slices) {</td>
    <td class="lineNumber">1960</td>
    <td class="codeline">  for (VectorSlice &S : Slices) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="codeline">    const auto ValName = "largephi.insertslice" + std::to_string(NameSuffix++);</td>
    <td class="lineNumber">1961</td>
    <td class="codeline">    const auto ValName = "largephi.insertslice" + std::to_string(NameSuffix++);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="codeline">    if (S.NumElts > 1)</td>
    <td class="lineNumber">1962</td>
    <td class="codeline">    if (S.NumElts > 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="codeline">      Vec =</td>
    <td class="lineNumber">1963</td>
    <td class="codeline">      Vec =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="codeline">          B.CreateInsertVector(FVT, Vec, S.NewPHI, B.getInt64(S.Idx), ValName);</td>
    <td class="lineNumber">1964</td>
    <td class="codeline">          B.CreateInsertVector(FVT, Vec, S.NewPHI, B.getInt64(S.Idx), ValName);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">1965</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="codeline">      Vec = B.CreateInsertElement(Vec, S.NewPHI, S.Idx, ValName);</td>
    <td class="lineNumber">1966</td>
    <td class="codeline">      Vec = B.CreateInsertElement(Vec, S.NewPHI, S.Idx, ValName);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1967</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="codeline"></td>
    <td class="lineNumber">1968</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="codeline">  I.replaceAllUsesWith(Vec);</td>
    <td class="lineNumber">1969</td>
    <td class="codeline">  I.replaceAllUsesWith(Vec);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="codeline">  I.eraseFromParent();</td>
    <td class="lineNumber">1970</td>
    <td class="codeline">  I.eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">1971</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1972</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="codeline"></td>
    <td class="lineNumber">1973</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::visitIntrinsicInst(IntrinsicInst &I) {</td>
    <td class="lineNumber">1974</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::visitIntrinsicInst(IntrinsicInst &I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="codeline">  switch (I.getIntrinsicID()) {</td>
    <td class="lineNumber">1975</td>
    <td class="codeline">  switch (I.getIntrinsicID()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="codeline">  case Intrinsic::bitreverse:</td>
    <td class="lineNumber">1976</td>
    <td class="codeline">  case Intrinsic::bitreverse:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="codeline">    return visitBitreverseIntrinsicInst(I);</td>
    <td class="lineNumber">1977</td>
    <td class="codeline">    return visitBitreverseIntrinsicInst(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="codeline">  case Intrinsic::minnum:</td>
    <td class="lineNumber">1978</td>
    <td class="codeline">  case Intrinsic::minnum:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="codeline">    return visitMinNum(I);</td>
    <td class="lineNumber">1979</td>
    <td class="codeline">    return visitMinNum(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="codeline">  default:</td>
    <td class="lineNumber">1980</td>
    <td class="codeline">  default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1981</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1982</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1983</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="codeline"></td>
    <td class="lineNumber">1984</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::visitBitreverseIntrinsicInst(IntrinsicInst &I) {</td>
    <td class="lineNumber">1985</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::visitBitreverseIntrinsicInst(IntrinsicInst &I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="codeline">  bool Changed = false;</td>
    <td class="lineNumber">1986</td>
    <td class="codeline">  bool Changed = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="codeline"></td>
    <td class="lineNumber">1987</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="codeline">  if (ST->has16BitInsts() && needsPromotionToI32(I.getType()) &&</td>
    <td class="lineNumber">1988</td>
    <td class="codeline">  if (ST->has16BitInsts() && needsPromotionToI32(I.getType()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="codeline">      UA->isUniform(&I))</td>
    <td class="lineNumber">1989</td>
    <td class="codeline">      UA->isUniform(&I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="codeline">    Changed |= promoteUniformBitreverseToI32(I);</td>
    <td class="lineNumber">1990</td>
    <td class="codeline">    Changed |= promoteUniformBitreverseToI32(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="codeline"></td>
    <td class="lineNumber">1991</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="codeline">  return Changed;</td>
    <td class="lineNumber">1992</td>
    <td class="codeline">  return Changed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1993</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="codeline"></td>
    <td class="lineNumber">1994</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="codeline">/// Match non-nan fract pattern.</td>
    <td class="lineNumber">1995</td>
    <td class="codeline">/// Match non-nan fract pattern.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="codeline">///   minnum(fsub(x, floor(x)), nextafter(1.0, -1.0)</td>
    <td class="lineNumber">1996</td>
    <td class="codeline">///   minnum(fsub(x, floor(x)), nextafter(1.0, -1.0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1997</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="codeline">/// If fract is a useful instruction for the subtarget. Does not account for the</td>
    <td class="lineNumber">1998</td>
    <td class="codeline">/// If fract is a useful instruction for the subtarget. Does not account for the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="codeline">/// nan handling; the instruction has a nan check on the input value.</td>
    <td class="lineNumber">1999</td>
    <td class="codeline">/// nan handling; the instruction has a nan check on the input value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="codeline">Value *AMDGPUCodeGenPrepareImpl::matchFractPat(IntrinsicInst &I) {</td>
    <td class="lineNumber">2000</td>
    <td class="codeline">Value *AMDGPUCodeGenPrepareImpl::matchFractPat(IntrinsicInst &I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="codeline">  if (ST->hasFractBug())</td>
    <td class="lineNumber">2001</td>
    <td class="codeline">  if (ST->hasFractBug())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">2002</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="codeline"></td>
    <td class="lineNumber">2003</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="codeline">  if (I.getIntrinsicID() != Intrinsic::minnum)</td>
    <td class="lineNumber">2004</td>
    <td class="codeline">  if (I.getIntrinsicID() != Intrinsic::minnum)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">2005</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="codeline"></td>
    <td class="lineNumber">2006</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="codeline">  Type *Ty = I.getType();</td>
    <td class="lineNumber">2007</td>
    <td class="codeline">  Type *Ty = I.getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="codeline">  if (!isLegalFloatingTy(Ty->getScalarType()))</td>
    <td class="lineNumber">2008</td>
    <td class="codeline">  if (!isLegalFloatingTy(Ty->getScalarType()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">2009</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="codeline"></td>
    <td class="lineNumber">2010</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="codeline">  Value *Arg0 = I.getArgOperand(0);</td>
    <td class="lineNumber">2011</td>
    <td class="codeline">  Value *Arg0 = I.getArgOperand(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="codeline">  Value *Arg1 = I.getArgOperand(1);</td>
    <td class="lineNumber">2012</td>
    <td class="codeline">  Value *Arg1 = I.getArgOperand(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="codeline"></td>
    <td class="lineNumber">2013</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="codeline">  const APFloat *C;</td>
    <td class="lineNumber">2014</td>
    <td class="codeline">  const APFloat *C;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="codeline">  if (!match(Arg1, m_APFloat(C)))</td>
    <td class="lineNumber">2015</td>
    <td class="codeline">  if (!match(Arg1, m_APFloat(C)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">2016</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="codeline"></td>
    <td class="lineNumber">2017</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="codeline">  APFloat One(1.0);</td>
    <td class="lineNumber">2018</td>
    <td class="codeline">  APFloat One(1.0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="codeline">  bool LosesInfo;</td>
    <td class="lineNumber">2019</td>
    <td class="codeline">  bool LosesInfo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="codeline">  One.convert(C->getSemantics(), APFloat::rmNearestTiesToEven, &LosesInfo);</td>
    <td class="lineNumber">2020</td>
    <td class="codeline">  One.convert(C->getSemantics(), APFloat::rmNearestTiesToEven, &LosesInfo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="codeline"></td>
    <td class="lineNumber">2021</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="codeline">  // Match nextafter(1.0, -1)</td>
    <td class="lineNumber">2022</td>
    <td class="codeline">  // Match nextafter(1.0, -1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="codeline">  One.next(true);</td>
    <td class="lineNumber">2023</td>
    <td class="codeline">  One.next(true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="codeline">  if (One != *C)</td>
    <td class="lineNumber">2024</td>
    <td class="codeline">  if (One != *C)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">2025</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="codeline"></td>
    <td class="lineNumber">2026</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="codeline">  Value *FloorSrc;</td>
    <td class="lineNumber">2027</td>
    <td class="codeline">  Value *FloorSrc;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="codeline">  if (match(Arg0, m_FSub(m_Value(FloorSrc),</td>
    <td class="lineNumber">2028</td>
    <td class="codeline">  if (match(Arg0, m_FSub(m_Value(FloorSrc),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="codeline">                         m_Intrinsic<Intrinsic::floor>(m_Deferred(FloorSrc)))))</td>
    <td class="lineNumber">2029</td>
    <td class="codeline">                         m_Intrinsic<Intrinsic::floor>(m_Deferred(FloorSrc)))))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="codeline">    return FloorSrc;</td>
    <td class="lineNumber">2030</td>
    <td class="codeline">    return FloorSrc;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="codeline">  return nullptr;</td>
    <td class="lineNumber">2031</td>
    <td class="codeline">  return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2032</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="codeline"></td>
    <td class="lineNumber">2033</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="codeline">Value *AMDGPUCodeGenPrepareImpl::applyFractPat(IRBuilder<> &Builder,</td>
    <td class="lineNumber">2034</td>
    <td class="codeline">Value *AMDGPUCodeGenPrepareImpl::applyFractPat(IRBuilder<> &Builder,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="codeline">                                               Value *FractArg) {</td>
    <td class="lineNumber">2035</td>
    <td class="codeline">                                               Value *FractArg) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="codeline">  SmallVector<Value *, 4> FractVals;</td>
    <td class="lineNumber">2036</td>
    <td class="codeline">  SmallVector<Value *, 4> FractVals;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="codeline">  extractValues(Builder, FractVals, FractArg);</td>
    <td class="lineNumber">2037</td>
    <td class="codeline">  extractValues(Builder, FractVals, FractArg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="codeline"></td>
    <td class="lineNumber">2038</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="codeline">  SmallVector<Value *, 4> ResultVals(FractVals.size());</td>
    <td class="lineNumber">2039</td>
    <td class="codeline">  SmallVector<Value *, 4> ResultVals(FractVals.size());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="codeline"></td>
    <td class="lineNumber">2040</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="codeline">  Type *Ty = FractArg->getType()->getScalarType();</td>
    <td class="lineNumber">2041</td>
    <td class="codeline">  Type *Ty = FractArg->getType()->getScalarType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="codeline">  for (unsigned I = 0, E = FractVals.size(); I != E; ++I) {</td>
    <td class="lineNumber">2042</td>
    <td class="codeline">  for (unsigned I = 0, E = FractVals.size(); I != E; ++I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="codeline">    ResultVals[I] =</td>
    <td class="lineNumber">2043</td>
    <td class="codeline">    ResultVals[I] =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="codeline">        Builder.CreateIntrinsic(Intrinsic::amdgcn_fract, {Ty}, {FractVals[I]});</td>
    <td class="lineNumber">2044</td>
    <td class="codeline">        Builder.CreateIntrinsic(Intrinsic::amdgcn_fract, {Ty}, {FractVals[I]});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2045</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="codeline"></td>
    <td class="lineNumber">2046</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="codeline">  return insertValues(Builder, FractArg->getType(), ResultVals);</td>
    <td class="lineNumber">2047</td>
    <td class="codeline">  return insertValues(Builder, FractArg->getType(), ResultVals);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2048</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="codeline"></td>
    <td class="lineNumber">2049</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::visitMinNum(IntrinsicInst &I) {</td>
    <td class="lineNumber">2050</td>
    <td class="codeline">bool AMDGPUCodeGenPrepareImpl::visitMinNum(IntrinsicInst &I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="codeline">  Value *FractArg = matchFractPat(I);</td>
    <td class="lineNumber">2051</td>
    <td class="codeline">  Value *FractArg = matchFractPat(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="codeline">  if (!FractArg)</td>
    <td class="lineNumber">2052</td>
    <td class="codeline">  if (!FractArg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2053</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="codeline"></td>
    <td class="lineNumber">2054</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="codeline">  // Match pattern for fract intrinsic in contexts where the nan check has been</td>
    <td class="lineNumber">2055</td>
    <td class="codeline">  // Match pattern for fract intrinsic in contexts where the nan check has been</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="codeline">  // optimized out (and hope the knowledge the source can't be nan wasn't lost).</td>
    <td class="lineNumber">2056</td>
    <td class="codeline">  // optimized out (and hope the knowledge the source can't be nan wasn't lost).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="codeline">  if (!I.hasNoNaNs() && !isKnownNeverNaN(FractArg, *DL, TLInfo))</td>
    <td class="lineNumber">2057</td>
    <td class="codeline">  if (!I.hasNoNaNs() && !isKnownNeverNaN(FractArg, *DL, TLInfo))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2058</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="codeline"></td>
    <td class="lineNumber">2059</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="codeline">  IRBuilder<> Builder(&I);</td>
    <td class="lineNumber">2060</td>
    <td class="codeline">  IRBuilder<> Builder(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="codeline">  FastMathFlags FMF = I.getFastMathFlags();</td>
    <td class="lineNumber">2061</td>
    <td class="codeline">  FastMathFlags FMF = I.getFastMathFlags();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="codeline">  FMF.setNoNaNs();</td>
    <td class="lineNumber">2062</td>
    <td class="codeline">  FMF.setNoNaNs();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="codeline">  Builder.setFastMathFlags(FMF);</td>
    <td class="lineNumber">2063</td>
    <td class="codeline">  Builder.setFastMathFlags(FMF);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="codeline"></td>
    <td class="lineNumber">2064</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="codeline">  Value *Fract = applyFractPat(Builder, FractArg);</td>
    <td class="lineNumber">2065</td>
    <td class="codeline">  Value *Fract = applyFractPat(Builder, FractArg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="codeline">  Fract->takeName(&I);</td>
    <td class="lineNumber">2066</td>
    <td class="codeline">  Fract->takeName(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="codeline">  I.replaceAllUsesWith(Fract);</td>
    <td class="lineNumber">2067</td>
    <td class="codeline">  I.replaceAllUsesWith(Fract);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="codeline"></td>
    <td class="lineNumber">2068</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="codeline">  RecursivelyDeleteTriviallyDeadInstructions(&I, TLInfo);</td>
    <td class="lineNumber">2069</td>
    <td class="codeline">  RecursivelyDeleteTriviallyDeadInstructions(&I, TLInfo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">2070</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2071</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="codeline"></td>
    <td class="lineNumber">2072</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="codeline">bool AMDGPUCodeGenPrepare::doInitialization(Module &M) {</td>
    <td class="lineNumber">2073</td>
    <td class="codeline">bool AMDGPUCodeGenPrepare::doInitialization(Module &M) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="codeline">  Impl.Mod = &M;</td>
    <td class="lineNumber">2074</td>
    <td class="codeline">  Impl.Mod = &M;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="codeline">  Impl.DL = &Impl.Mod->getDataLayout();</td>
    <td class="lineNumber">2075</td>
    <td class="codeline">  Impl.DL = &Impl.Mod->getDataLayout();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">2076</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2077</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="codeline"></td>
    <td class="lineNumber">2078</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="codeline">bool AMDGPUCodeGenPrepare::runOnFunction(Function &F) {</td>
    <td class="lineNumber">2079</td>
    <td class="codeline">bool AMDGPUCodeGenPrepare::runOnFunction(Function &F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="codeline">  if (skipFunction(F))</td>
    <td class="lineNumber">2080</td>
    <td class="codeline">  if (skipFunction(F))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2081</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="codeline"></td>
    <td class="lineNumber">2082</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="codeline">  auto *TPC = getAnalysisIfAvailable<TargetPassConfig>();</td>
    <td class="lineNumber">2083</td>
    <td class="codeline">  auto *TPC = getAnalysisIfAvailable<TargetPassConfig>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="codeline">  if (!TPC)</td>
    <td class="lineNumber">2084</td>
    <td class="codeline">  if (!TPC)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2085</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="codeline"></td>
    <td class="lineNumber">2086</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="codeline">  const AMDGPUTargetMachine &TM = TPC->getTM<AMDGPUTargetMachine>();</td>
    <td class="lineNumber">2087</td>
    <td class="codeline">  const AMDGPUTargetMachine &TM = TPC->getTM<AMDGPUTargetMachine>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="codeline">  Impl.TLInfo = &getAnalysis<TargetLibraryInfoWrapperPass>().getTLI(F);</td>
    <td class="lineNumber">2088</td>
    <td class="codeline">  Impl.TLInfo = &getAnalysis<TargetLibraryInfoWrapperPass>().getTLI(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="codeline">  Impl.ST = &TM.getSubtarget<GCNSubtarget>(F);</td>
    <td class="lineNumber">2089</td>
    <td class="codeline">  Impl.ST = &TM.getSubtarget<GCNSubtarget>(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="codeline">  Impl.AC = &getAnalysis<AssumptionCacheTracker>().getAssumptionCache(F);</td>
    <td class="lineNumber">2090</td>
    <td class="codeline">  Impl.AC = &getAnalysis<AssumptionCacheTracker>().getAssumptionCache(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="codeline">  Impl.UA = &getAnalysis<UniformityInfoWrapperPass>().getUniformityInfo();</td>
    <td class="lineNumber">2091</td>
    <td class="codeline">  Impl.UA = &getAnalysis<UniformityInfoWrapperPass>().getUniformityInfo();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="codeline">  auto *DTWP = getAnalysisIfAvailable<DominatorTreeWrapperPass>();</td>
    <td class="lineNumber">2092</td>
    <td class="codeline">  auto *DTWP = getAnalysisIfAvailable<DominatorTreeWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="codeline">  Impl.DT = DTWP ? &DTWP->getDomTree() : nullptr;</td>
    <td class="lineNumber">2093</td>
    <td class="codeline">  Impl.DT = DTWP ? &DTWP->getDomTree() : nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="codeline">  Impl.HasUnsafeFPMath = hasUnsafeFPMath(F);</td>
    <td class="lineNumber">2094</td>
    <td class="codeline">  Impl.HasUnsafeFPMath = hasUnsafeFPMath(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="codeline">  SIModeRegisterDefaults Mode(F);</td>
    <td class="lineNumber">2095</td>
    <td class="codeline">  SIModeRegisterDefaults Mode(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="codeline">  Impl.HasFP32DenormalFlush =</td>
    <td class="lineNumber">2096</td>
    <td class="codeline">  Impl.HasFP32DenormalFlush =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="codeline">      Mode.FP32Denormals == DenormalMode::getPreserveSign();</td>
    <td class="lineNumber">2097</td>
    <td class="codeline">      Mode.FP32Denormals == DenormalMode::getPreserveSign();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="codeline">  return Impl.run(F);</td>
    <td class="lineNumber">2098</td>
    <td class="codeline">  return Impl.run(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2099</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="codeline"></td>
    <td class="lineNumber">2100</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="codeline">PreservedAnalyses AMDGPUCodeGenPreparePass::run(Function &F,</td>
    <td class="lineNumber">2101</td>
    <td class="codeline">PreservedAnalyses AMDGPUCodeGenPreparePass::run(Function &F,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="codeline">                                                FunctionAnalysisManager &FAM) {</td>
    <td class="lineNumber">2102</td>
    <td class="codeline">                                                FunctionAnalysisManager &FAM) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="codeline">  AMDGPUCodeGenPrepareImpl Impl;</td>
    <td class="lineNumber">2103</td>
    <td class="codeline">  AMDGPUCodeGenPrepareImpl Impl;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="codeline">  Impl.Mod = F.getParent();</td>
    <td class="lineNumber">2104</td>
    <td class="codeline">  Impl.Mod = F.getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="codeline">  Impl.DL = &Impl.Mod->getDataLayout();</td>
    <td class="lineNumber">2105</td>
    <td class="codeline">  Impl.DL = &Impl.Mod->getDataLayout();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="codeline">  Impl.TLInfo = &FAM.getResult<TargetLibraryAnalysis>(F);</td>
    <td class="lineNumber">2106</td>
    <td class="codeline">  Impl.TLInfo = &FAM.getResult<TargetLibraryAnalysis>(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="codeline">  Impl.ST = &TM.getSubtarget<GCNSubtarget>(F);</td>
    <td class="lineNumber">2107</td>
    <td class="codeline">  Impl.ST = &TM.getSubtarget<GCNSubtarget>(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="codeline">  Impl.AC = &FAM.getResult<AssumptionAnalysis>(F);</td>
    <td class="lineNumber">2108</td>
    <td class="codeline">  Impl.AC = &FAM.getResult<AssumptionAnalysis>(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="codeline">  Impl.UA = &FAM.getResult<UniformityInfoAnalysis>(F);</td>
    <td class="lineNumber">2109</td>
    <td class="codeline">  Impl.UA = &FAM.getResult<UniformityInfoAnalysis>(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="codeline">  Impl.DT = FAM.getCachedResult<DominatorTreeAnalysis>(F);</td>
    <td class="lineNumber">2110</td>
    <td class="codeline">  Impl.DT = FAM.getCachedResult<DominatorTreeAnalysis>(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="codeline">  Impl.HasUnsafeFPMath = hasUnsafeFPMath(F);</td>
    <td class="lineNumber">2111</td>
    <td class="codeline">  Impl.HasUnsafeFPMath = hasUnsafeFPMath(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="codeline">  SIModeRegisterDefaults Mode(F);</td>
    <td class="lineNumber">2112</td>
    <td class="codeline">  SIModeRegisterDefaults Mode(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="codeline">  Impl.HasFP32DenormalFlush =</td>
    <td class="lineNumber">2113</td>
    <td class="codeline">  Impl.HasFP32DenormalFlush =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="codeline">      Mode.FP32Denormals == DenormalMode::getPreserveSign();</td>
    <td class="lineNumber">2114</td>
    <td class="codeline">      Mode.FP32Denormals == DenormalMode::getPreserveSign();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="codeline">  PreservedAnalyses PA = PreservedAnalyses::none();</td>
    <td class="lineNumber">2115</td>
    <td class="codeline">  PreservedAnalyses PA = PreservedAnalyses::none();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="codeline">  if (!Impl.FlowChanged)</td>
    <td class="lineNumber">2116</td>
    <td class="codeline">  if (!Impl.FlowChanged)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="codeline">    PA.preserveSet<CFGAnalyses>();</td>
    <td class="lineNumber">2117</td>
    <td class="codeline">    PA.preserveSet<CFGAnalyses>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="codeline">  return Impl.run(F) ? PA : PreservedAnalyses::all();</td>
    <td class="lineNumber">2118</td>
    <td class="codeline">  return Impl.run(F) ? PA : PreservedAnalyses::all();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2119</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="codeline"></td>
    <td class="lineNumber">2120</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="codeline">INITIALIZE_PASS_BEGIN(AMDGPUCodeGenPrepare, DEBUG_TYPE,</td>
    <td class="lineNumber">2121</td>
    <td class="codeline">INITIALIZE_PASS_BEGIN(AMDGPUCodeGenPrepare, DEBUG_TYPE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="codeline">                      "AMDGPU IR optimizations", false, false)</td>
    <td class="lineNumber">2122</td>
    <td class="codeline">                      "AMDGPU IR optimizations", false, false)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(AssumptionCacheTracker)</td>
    <td class="lineNumber">2123</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(AssumptionCacheTracker)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(TargetLibraryInfoWrapperPass)</td>
    <td class="lineNumber">2124</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(TargetLibraryInfoWrapperPass)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(UniformityInfoWrapperPass)</td>
    <td class="lineNumber">2125</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(UniformityInfoWrapperPass)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="codeline">INITIALIZE_PASS_END(AMDGPUCodeGenPrepare, DEBUG_TYPE, "AMDGPU IR optimizations",</td>
    <td class="lineNumber">2126</td>
    <td class="codeline">INITIALIZE_PASS_END(AMDGPUCodeGenPrepare, DEBUG_TYPE, "AMDGPU IR optimizations",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="codeline">                    false, false)</td>
    <td class="lineNumber">2127</td>
    <td class="codeline">                    false, false)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="codeline"></td>
    <td class="lineNumber">2128</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="codeline">char AMDGPUCodeGenPrepare::ID = 0;</td>
    <td class="lineNumber">2129</td>
    <td class="codeline">char AMDGPUCodeGenPrepare::ID = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="codeline"></td>
    <td class="lineNumber">2130</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="codeline">FunctionPass *llvm::createAMDGPUCodeGenPreparePass() {</td>
    <td class="lineNumber">2131</td>
    <td class="codeline">FunctionPass *llvm::createAMDGPUCodeGenPreparePass() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="codeline">  return new AMDGPUCodeGenPrepare();</td>
    <td class="lineNumber">2132</td>
    <td class="codeline">  return new AMDGPUCodeGenPrepare();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2133</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="codeline"></td>
    <td class="lineNumber">2134</td>
    <td class="codeline"></td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Side By Side Comparison</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Side By Side Comparison</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeLine">//===-- AMDGPUCodeGenPrepare.cpp ------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1</td>
    <td class="codeLine">//===-- AMDGPUCodeGenPrepare.cpp ------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeLine">/// \file</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">9</td>
    <td class="codeLine">/// \file</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeLine">/// This pass does misc. AMDGPU optimizations on IR before instruction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">10</td>
    <td class="codeLine">/// This pass does misc. AMDGPU optimizations on IR before instruction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeLine">/// selection.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">11</td>
    <td class="codeLine">/// selection.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">12</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">13</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">14</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeLine">#include "AMDGPU.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">15</td>
    <td class="codeLine">#include "AMDGPU.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeLine">#include "AMDGPUTargetMachine.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">16</td>
    <td class="codeLine">#include "AMDGPUTargetMachine.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeLine">#include "SIModeRegisterDefaults.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">17</td>
    <td class="codeLine">#include "SIModeRegisterDefaults.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeLine">#include "llvm/Analysis/AssumptionCache.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">18</td>
    <td class="codeLine">#include "llvm/Analysis/AssumptionCache.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeLine">#include "llvm/Analysis/ConstantFolding.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">19</td>
    <td class="codeLine">#include "llvm/Analysis/ConstantFolding.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeLine">#include "llvm/Analysis/TargetLibraryInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">20</td>
    <td class="codeLine">#include "llvm/Analysis/TargetLibraryInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeLine">#include "llvm/Analysis/UniformityAnalysis.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">21</td>
    <td class="codeLine">#include "llvm/Analysis/UniformityAnalysis.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "llvm/Analysis/ValueTracking.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "llvm/Analysis/ValueTracking.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetPassConfig.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetPassConfig.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/IR/Dominators.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/IR/Dominators.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/IR/IRBuilder.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/IR/IRBuilder.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/IR/InstVisitor.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/IR/InstVisitor.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeLine">#include "llvm/IR/IntrinsicsAMDGPU.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">27</td>
    <td class="codeLine">#include "llvm/IR/IntrinsicsAMDGPU.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeLine">#include "llvm/IR/PatternMatch.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">28</td>
    <td class="codeLine">#include "llvm/IR/PatternMatch.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeLine">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">29</td>
    <td class="codeLine">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeLine">#include "llvm/Pass.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">30</td>
    <td class="codeLine">#include "llvm/Pass.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeLine">#include "llvm/Support/KnownBits.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">31</td>
    <td class="codeLine">#include "llvm/Support/KnownBits.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/IntegerDivision.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">32</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/IntegerDivision.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/Local.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">33</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/Local.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">34</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeLine">#define DEBUG_TYPE "amdgpu-codegenprepare"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">35</td>
    <td class="codeLine">#define DEBUG_TYPE "amdgpu-codegenprepare"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">36</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">37</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeLine">using namespace llvm::PatternMatch;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">38</td>
    <td class="codeLine">using namespace llvm::PatternMatch;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">39</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">40</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">41</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeLine">static cl::opt<bool> WidenLoads(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">42</td>
    <td class="codeLine">static cl::opt<bool> WidenLoads(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeLine">  "amdgpu-codegenprepare-widen-constant-loads",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">43</td>
    <td class="codeLine">  "amdgpu-codegenprepare-widen-constant-loads",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeLine">  cl::desc("Widen sub-dword constant address space loads in AMDGPUCodeGenPrepare"),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">44</td>
    <td class="codeLine">  cl::desc("Widen sub-dword constant address space loads in AMDGPUCodeGenPrepare"),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeLine">  cl::ReallyHidden,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">45</td>
    <td class="codeLine">  cl::ReallyHidden,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeLine">  cl::init(false));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">46</td>
    <td class="codeLine">  cl::init(false));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">47</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeLine">static cl::opt<bool> Widen16BitOps(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">48</td>
    <td class="codeLine">static cl::opt<bool> Widen16BitOps(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeLine">  "amdgpu-codegenprepare-widen-16-bit-ops",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">49</td>
    <td class="codeLine">  "amdgpu-codegenprepare-widen-16-bit-ops",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeLine">  cl::desc("Widen uniform 16-bit instructions to 32-bit in AMDGPUCodeGenPrepare"),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">50</td>
    <td class="codeLine">  cl::desc("Widen uniform 16-bit instructions to 32-bit in AMDGPUCodeGenPrepare"),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeLine">  cl::ReallyHidden,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">51</td>
    <td class="codeLine">  cl::ReallyHidden,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeLine">  cl::init(true));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">52</td>
    <td class="codeLine">  cl::init(true));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">53</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeLine">static cl::opt<bool></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">54</td>
    <td class="codeLine">static cl::opt<bool></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeLine">    ScalarizeLargePHIs("amdgpu-codegenprepare-break-large-phis",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">55</td>
    <td class="codeLine">    ScalarizeLargePHIs("amdgpu-codegenprepare-break-large-phis",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeLine">                       cl::desc("Break large PHI nodes for DAGISel"),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">56</td>
    <td class="codeLine">                       cl::desc("Break large PHI nodes for DAGISel"),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeLine">                       cl::ReallyHidden, cl::init(true));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">57</td>
    <td class="codeLine">                       cl::ReallyHidden, cl::init(true));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">58</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeLine">static cl::opt<bool></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">59</td>
    <td class="codeLine">static cl::opt<bool></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeLine">    ForceScalarizeLargePHIs("amdgpu-codegenprepare-force-break-large-phis",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">60</td>
    <td class="codeLine">    ForceScalarizeLargePHIs("amdgpu-codegenprepare-force-break-large-phis",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeLine">                            cl::desc("For testing purposes, always break large "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">61</td>
    <td class="codeLine">                            cl::desc("For testing purposes, always break large "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeLine">                                     "PHIs even if it isn't profitable."),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">62</td>
    <td class="codeLine">                                     "PHIs even if it isn't profitable."),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeLine">                            cl::ReallyHidden, cl::init(false));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">63</td>
    <td class="codeLine">                            cl::ReallyHidden, cl::init(false));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">64</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeLine">static cl::opt<unsigned> ScalarizeLargePHIsThreshold(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">65</td>
    <td class="codeLine">static cl::opt<unsigned> ScalarizeLargePHIsThreshold(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeLine">    "amdgpu-codegenprepare-break-large-phis-threshold",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">66</td>
    <td class="codeLine">    "amdgpu-codegenprepare-break-large-phis-threshold",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeLine">    cl::desc("Minimum type size in bits for breaking large PHI nodes"),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">67</td>
    <td class="codeLine">    cl::desc("Minimum type size in bits for breaking large PHI nodes"),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeLine">    cl::ReallyHidden, cl::init(32));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">68</td>
    <td class="codeLine">    cl::ReallyHidden, cl::init(32));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">69</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeLine">static cl::opt<bool> UseMul24Intrin(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">70</td>
    <td class="codeLine">static cl::opt<bool> UseMul24Intrin(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeLine">  "amdgpu-codegenprepare-mul24",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">71</td>
    <td class="codeLine">  "amdgpu-codegenprepare-mul24",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeLine">  cl::desc("Introduce mul24 intrinsics in AMDGPUCodeGenPrepare"),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">72</td>
    <td class="codeLine">  cl::desc("Introduce mul24 intrinsics in AMDGPUCodeGenPrepare"),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeLine">  cl::ReallyHidden,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">73</td>
    <td class="codeLine">  cl::ReallyHidden,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeLine">  cl::init(true));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">74</td>
    <td class="codeLine">  cl::init(true));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">75</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeLine">// Legalize 64-bit division by using the generic IR expansion.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">76</td>
    <td class="codeLine">// Legalize 64-bit division by using the generic IR expansion.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeLine">static cl::opt<bool> ExpandDiv64InIR(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">77</td>
    <td class="codeLine">static cl::opt<bool> ExpandDiv64InIR(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeLine">  "amdgpu-codegenprepare-expand-div64",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">78</td>
    <td class="codeLine">  "amdgpu-codegenprepare-expand-div64",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeLine">  cl::desc("Expand 64-bit division in AMDGPUCodeGenPrepare"),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">79</td>
    <td class="codeLine">  cl::desc("Expand 64-bit division in AMDGPUCodeGenPrepare"),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeLine">  cl::ReallyHidden,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">80</td>
    <td class="codeLine">  cl::ReallyHidden,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeLine">  cl::init(false));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">81</td>
    <td class="codeLine">  cl::init(false));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">82</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeLine">// Leave all division operations as they are. This supersedes ExpandDiv64InIR</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">83</td>
    <td class="codeLine">// Leave all division operations as they are. This supersedes ExpandDiv64InIR</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeLine">// and is used for testing the legalizer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">84</td>
    <td class="codeLine">// and is used for testing the legalizer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeLine">static cl::opt<bool> DisableIDivExpand(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">85</td>
    <td class="codeLine">static cl::opt<bool> DisableIDivExpand(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeLine">  "amdgpu-codegenprepare-disable-idiv-expansion",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">86</td>
    <td class="codeLine">  "amdgpu-codegenprepare-disable-idiv-expansion",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeLine">  cl::desc("Prevent expanding integer division in AMDGPUCodeGenPrepare"),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">87</td>
    <td class="codeLine">  cl::desc("Prevent expanding integer division in AMDGPUCodeGenPrepare"),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeLine">  cl::ReallyHidden,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">88</td>
    <td class="codeLine">  cl::ReallyHidden,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeLine">  cl::init(false));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">89</td>
    <td class="codeLine">  cl::init(false));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">90</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeLine">// Disable processing of fdiv so we can better test the backend implementations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">91</td>
    <td class="codeLine">// Disable processing of fdiv so we can better test the backend implementations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeLine">static cl::opt<bool> DisableFDivExpand(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">92</td>
    <td class="codeLine">static cl::opt<bool> DisableFDivExpand(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeLine">  "amdgpu-codegenprepare-disable-fdiv-expansion",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">93</td>
    <td class="codeLine">  "amdgpu-codegenprepare-disable-fdiv-expansion",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeLine">  cl::desc("Prevent expanding floating point division in AMDGPUCodeGenPrepare"),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">94</td>
    <td class="codeLine">  cl::desc("Prevent expanding floating point division in AMDGPUCodeGenPrepare"),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeLine">  cl::ReallyHidden,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">95</td>
    <td class="codeLine">  cl::ReallyHidden,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeLine">  cl::init(false));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">96</td>
    <td class="codeLine">  cl::init(false));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">97</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeLine">class AMDGPUCodeGenPrepareImpl</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">98</td>
    <td class="codeLine">class AMDGPUCodeGenPrepareImpl</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeLine">    : public InstVisitor<AMDGPUCodeGenPrepareImpl, bool> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">99</td>
    <td class="codeLine">    : public InstVisitor<AMDGPUCodeGenPrepareImpl, bool> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">100</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeLine">  const GCNSubtarget *ST = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">101</td>
    <td class="codeLine">  const GCNSubtarget *ST = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeLine">  const TargetLibraryInfo *TLInfo = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">102</td>
    <td class="codeLine">  const TargetLibraryInfo *TLInfo = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeLine">  AssumptionCache *AC = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">103</td>
    <td class="codeLine">  AssumptionCache *AC = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeLine">  DominatorTree *DT = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">104</td>
    <td class="codeLine">  DominatorTree *DT = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeLine">  UniformityInfo *UA = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">105</td>
    <td class="codeLine">  UniformityInfo *UA = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeLine">  Module *Mod = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">106</td>
    <td class="codeLine">  Module *Mod = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeLine">  const DataLayout *DL = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">107</td>
    <td class="codeLine">  const DataLayout *DL = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeLine">  bool HasUnsafeFPMath = false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">108</td>
    <td class="codeLine">  bool HasUnsafeFPMath = false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeLine">  bool HasFP32DenormalFlush = false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">109</td>
    <td class="codeLine">  bool HasFP32DenormalFlush = false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeLine">  bool FlowChanged = false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">110</td>
    <td class="codeLine">  bool FlowChanged = false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">111</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeLine">  DenseMap<const PHINode *, bool> BreakPhiNodesCache;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">112</td>
    <td class="codeLine">  DenseMap<const PHINode *, bool> BreakPhiNodesCache;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">113</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeLine">  bool canBreakPHINode(const PHINode &I);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">114</td>
    <td class="codeLine">  bool canBreakPHINode(const PHINode &I);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">115</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeLine">  /// Copies exact/nsw/nuw flags (if any) from binary operation \p I to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">116</td>
    <td class="codeLine">  /// Copies exact/nsw/nuw flags (if any) from binary operation \p I to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeLine">  /// binary operation \p V.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">117</td>
    <td class="codeLine">  /// binary operation \p V.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">118</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeLine">  /// \returns Binary operation \p V.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">119</td>
    <td class="codeLine">  /// \returns Binary operation \p V.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeLine">  /// \returns \p T's base element bit width.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">120</td>
    <td class="codeLine">  /// \returns \p T's base element bit width.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeLine">  unsigned getBaseElementBitWidth(const Type *T) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">121</td>
    <td class="codeLine">  unsigned getBaseElementBitWidth(const Type *T) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">122</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeLine">  /// \returns Equivalent 32 bit integer type for given type \p T. For example,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">123</td>
    <td class="codeLine">  /// \returns Equivalent 32 bit integer type for given type \p T. For example,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeLine">  /// if \p T is i7, then i32 is returned; if \p T is <3 x i12>, then <3 x i32></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">124</td>
    <td class="codeLine">  /// if \p T is i7, then i32 is returned; if \p T is <3 x i12>, then <3 x i32></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeLine">  /// is returned.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">125</td>
    <td class="codeLine">  /// is returned.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeLine">  Type *getI32Ty(IRBuilder<> &B, const Type *T) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">126</td>
    <td class="codeLine">  Type *getI32Ty(IRBuilder<> &B, const Type *T) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">127</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeLine">  /// \returns True if binary operation \p I is a signed binary operation, false</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">128</td>
    <td class="codeLine">  /// \returns True if binary operation \p I is a signed binary operation, false</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeLine">  /// otherwise.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">129</td>
    <td class="codeLine">  /// otherwise.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeLine">  bool isSigned(const BinaryOperator &I) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">130</td>
    <td class="codeLine">  bool isSigned(const BinaryOperator &I) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">131</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeLine">  /// \returns True if the condition of 'select' operation \p I comes from a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">132</td>
    <td class="codeLine">  /// \returns True if the condition of 'select' operation \p I comes from a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeLine">  /// signed 'icmp' operation, false otherwise.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">133</td>
    <td class="codeLine">  /// signed 'icmp' operation, false otherwise.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeLine">  bool isSigned(const SelectInst &I) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">134</td>
    <td class="codeLine">  bool isSigned(const SelectInst &I) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">135</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeLine">  /// \returns True if type \p T needs to be promoted to 32 bit integer type,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">136</td>
    <td class="codeLine">  /// \returns True if type \p T needs to be promoted to 32 bit integer type,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeLine">  /// false otherwise.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">137</td>
    <td class="codeLine">  /// false otherwise.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeLine">  bool needsPromotionToI32(const Type *T) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">138</td>
    <td class="codeLine">  bool needsPromotionToI32(const Type *T) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">139</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeLine">  /// Return true if \p T is a legal scalar floating point type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">140</td>
    <td class="codeLine">  /// Return true if \p T is a legal scalar floating point type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeLine">  bool isLegalFloatingTy(const Type *T) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">141</td>
    <td class="codeLine">  bool isLegalFloatingTy(const Type *T) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">142</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeLine">  /// Wrapper to pass all the arguments to computeKnownFPClass</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">143</td>
    <td class="codeLine">  /// Wrapper to pass all the arguments to computeKnownFPClass</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeLine">  KnownFPClass computeKnownFPClass(const Value *V, FPClassTest Interested,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">144</td>
    <td class="codeLine">  KnownFPClass computeKnownFPClass(const Value *V, FPClassTest Interested,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeLine">                                   const Instruction *CtxI) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">145</td>
    <td class="codeLine">                                   const Instruction *CtxI) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeLine">    return llvm::computeKnownFPClass(V, *DL, Interested, 0, TLInfo, AC, CtxI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">146</td>
    <td class="codeLine">    return llvm::computeKnownFPClass(V, *DL, Interested, 0, TLInfo, AC, CtxI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeLine">                                     DT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">147</td>
    <td class="codeLine">                                     DT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">148</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">149</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeLine">  bool canIgnoreDenormalInput(const Value *V, const Instruction *CtxI) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">150</td>
    <td class="codeLine">  bool canIgnoreDenormalInput(const Value *V, const Instruction *CtxI) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeLine">    return HasFP32DenormalFlush ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">151</td>
    <td class="codeLine">    return HasFP32DenormalFlush ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeLine">           computeKnownFPClass(V, fcSubnormal, CtxI).isKnownNeverSubnormal();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">152</td>
    <td class="codeLine">           computeKnownFPClass(V, fcSubnormal, CtxI).isKnownNeverSubnormal();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">153</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">154</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeLine">  /// Promotes uniform binary operation \p I to equivalent 32 bit binary</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">155</td>
    <td class="codeLine">  /// Promotes uniform binary operation \p I to equivalent 32 bit binary</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeLine">  /// operation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">156</td>
    <td class="codeLine">  /// operation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">157</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeLine">  /// \details \p I's base element bit width must be greater than 1 and less</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">158</td>
    <td class="codeLine">  /// \details \p I's base element bit width must be greater than 1 and less</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeLine">  /// than or equal 16. Promotion is done by sign or zero extending operands to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">159</td>
    <td class="codeLine">  /// than or equal 16. Promotion is done by sign or zero extending operands to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeLine">  /// 32 bits, replacing \p I with equivalent 32 bit binary operation, and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">160</td>
    <td class="codeLine">  /// 32 bits, replacing \p I with equivalent 32 bit binary operation, and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeLine">  /// truncating the result of 32 bit binary operation back to \p I's original</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">161</td>
    <td class="codeLine">  /// truncating the result of 32 bit binary operation back to \p I's original</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeLine">  /// type. Division operation is not promoted.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">162</td>
    <td class="codeLine">  /// type. Division operation is not promoted.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">163</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeLine">  /// \returns True if \p I is promoted to equivalent 32 bit binary operation,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">164</td>
    <td class="codeLine">  /// \returns True if \p I is promoted to equivalent 32 bit binary operation,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeLine">  /// false otherwise.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">165</td>
    <td class="codeLine">  /// false otherwise.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeLine">  bool promoteUniformOpToI32(BinaryOperator &I) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">166</td>
    <td class="codeLine">  bool promoteUniformOpToI32(BinaryOperator &I) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">167</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeLine">  /// Promotes uniform 'icmp' operation \p I to 32 bit 'icmp' operation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">168</td>
    <td class="codeLine">  /// Promotes uniform 'icmp' operation \p I to 32 bit 'icmp' operation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">169</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeLine">  /// \details \p I's base element bit width must be greater than 1 and less</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">170</td>
    <td class="codeLine">  /// \details \p I's base element bit width must be greater than 1 and less</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeLine">  /// than or equal 16. Promotion is done by sign or zero extending operands to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">171</td>
    <td class="codeLine">  /// than or equal 16. Promotion is done by sign or zero extending operands to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeLine">  /// 32 bits, and replacing \p I with 32 bit 'icmp' operation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">172</td>
    <td class="codeLine">  /// 32 bits, and replacing \p I with 32 bit 'icmp' operation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">173</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeLine">  /// \returns True.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">174</td>
    <td class="codeLine">  /// \returns True.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeLine">  bool promoteUniformOpToI32(ICmpInst &I) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">175</td>
    <td class="codeLine">  bool promoteUniformOpToI32(ICmpInst &I) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">176</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeLine">  /// Promotes uniform 'select' operation \p I to 32 bit 'select'</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">177</td>
    <td class="codeLine">  /// Promotes uniform 'select' operation \p I to 32 bit 'select'</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeLine">  /// operation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">178</td>
    <td class="codeLine">  /// operation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">179</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeLine">  /// \details \p I's base element bit width must be greater than 1 and less</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">180</td>
    <td class="codeLine">  /// \details \p I's base element bit width must be greater than 1 and less</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeLine">  /// than or equal 16. Promotion is done by sign or zero extending operands to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">181</td>
    <td class="codeLine">  /// than or equal 16. Promotion is done by sign or zero extending operands to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeLine">  /// 32 bits, replacing \p I with 32 bit 'select' operation, and truncating the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">182</td>
    <td class="codeLine">  /// 32 bits, replacing \p I with 32 bit 'select' operation, and truncating the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeLine">  /// result of 32 bit 'select' operation back to \p I's original type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">183</td>
    <td class="codeLine">  /// result of 32 bit 'select' operation back to \p I's original type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">184</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeLine">  /// \returns True.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">185</td>
    <td class="codeLine">  /// \returns True.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeLine">  bool promoteUniformOpToI32(SelectInst &I) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">186</td>
    <td class="codeLine">  bool promoteUniformOpToI32(SelectInst &I) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">187</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeLine">  /// Promotes uniform 'bitreverse' intrinsic \p I to 32 bit 'bitreverse'</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">188</td>
    <td class="codeLine">  /// Promotes uniform 'bitreverse' intrinsic \p I to 32 bit 'bitreverse'</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeLine">  /// intrinsic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">189</td>
    <td class="codeLine">  /// intrinsic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">190</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeLine">  /// \details \p I's base element bit width must be greater than 1 and less</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">191</td>
    <td class="codeLine">  /// \details \p I's base element bit width must be greater than 1 and less</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeLine">  /// than or equal 16. Promotion is done by zero extending the operand to 32</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">192</td>
    <td class="codeLine">  /// than or equal 16. Promotion is done by zero extending the operand to 32</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeLine">  /// bits, replacing \p I with 32 bit 'bitreverse' intrinsic, shifting the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">193</td>
    <td class="codeLine">  /// bits, replacing \p I with 32 bit 'bitreverse' intrinsic, shifting the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeLine">  /// result of 32 bit 'bitreverse' intrinsic to the right with zero fill (the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">194</td>
    <td class="codeLine">  /// result of 32 bit 'bitreverse' intrinsic to the right with zero fill (the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeLine">  /// shift amount is 32 minus \p I's base element bit width), and truncating</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">195</td>
    <td class="codeLine">  /// shift amount is 32 minus \p I's base element bit width), and truncating</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeLine">  /// the result of the shift operation back to \p I's original type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">196</td>
    <td class="codeLine">  /// the result of the shift operation back to \p I's original type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">197</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeLine">  /// \returns True.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">198</td>
    <td class="codeLine">  /// \returns True.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeLine">  bool promoteUniformBitreverseToI32(IntrinsicInst &I) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">199</td>
    <td class="codeLine">  bool promoteUniformBitreverseToI32(IntrinsicInst &I) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">200</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeLine">  /// \returns The minimum number of bits needed to store the value of \Op as an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">201</td>
    <td class="codeLine">  /// \returns The minimum number of bits needed to store the value of \Op as an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeLine">  /// unsigned integer. Truncating to this size and then zero-extending to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">202</td>
    <td class="codeLine">  /// unsigned integer. Truncating to this size and then zero-extending to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeLine">  /// the original will not change the value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">203</td>
    <td class="codeLine">  /// the original will not change the value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeLine">  unsigned numBitsUnsigned(Value *Op) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">204</td>
    <td class="codeLine">  unsigned numBitsUnsigned(Value *Op) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">205</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeLine">  /// \returns The minimum number of bits needed to store the value of \Op as a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">206</td>
    <td class="codeLine">  /// \returns The minimum number of bits needed to store the value of \Op as a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeLine">  /// signed integer. Truncating to this size and then sign-extending to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">207</td>
    <td class="codeLine">  /// signed integer. Truncating to this size and then sign-extending to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeLine">  /// the original size will not change the value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">208</td>
    <td class="codeLine">  /// the original size will not change the value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeLine">  unsigned numBitsSigned(Value *Op) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">209</td>
    <td class="codeLine">  unsigned numBitsSigned(Value *Op) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">210</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeLine">  /// Replace mul instructions with llvm.amdgcn.mul.u24 or llvm.amdgcn.mul.s24.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">211</td>
    <td class="codeLine">  /// Replace mul instructions with llvm.amdgcn.mul.u24 or llvm.amdgcn.mul.s24.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeLine">  /// SelectionDAG has an issue where an and asserting the bits are known</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">212</td>
    <td class="codeLine">  /// SelectionDAG has an issue where an and asserting the bits are known</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeLine">  bool replaceMulWithMul24(BinaryOperator &I) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">213</td>
    <td class="codeLine">  bool replaceMulWithMul24(BinaryOperator &I) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">214</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeLine">  /// Perform same function as equivalently named function in DAGCombiner. Since</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">215</td>
    <td class="codeLine">  /// Perform same function as equivalently named function in DAGCombiner. Since</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeLine">  /// we expand some divisions here, we need to perform this before obscuring.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">216</td>
    <td class="codeLine">  /// we expand some divisions here, we need to perform this before obscuring.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeLine">  bool foldBinOpIntoSelect(BinaryOperator &I) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">217</td>
    <td class="codeLine">  bool foldBinOpIntoSelect(BinaryOperator &I) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">218</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeLine">  bool divHasSpecialOptimization(BinaryOperator &I,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">219</td>
    <td class="codeLine">  bool divHasSpecialOptimization(BinaryOperator &I,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeLine">                                 Value *Num, Value *Den) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">220</td>
    <td class="codeLine">                                 Value *Num, Value *Den) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeLine">  int getDivNumBits(BinaryOperator &I,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">221</td>
    <td class="codeLine">  int getDivNumBits(BinaryOperator &I,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeLine">                    Value *Num, Value *Den,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">222</td>
    <td class="codeLine">                    Value *Num, Value *Den,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeLine">                    unsigned AtLeast, bool Signed) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">223</td>
    <td class="codeLine">                    unsigned AtLeast, bool Signed) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">224</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeLine">  /// Expands 24 bit div or rem.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">225</td>
    <td class="codeLine">  /// Expands 24 bit div or rem.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeLine">  Value* expandDivRem24(IRBuilder<> &Builder, BinaryOperator &I,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">226</td>
    <td class="codeLine">  Value* expandDivRem24(IRBuilder<> &Builder, BinaryOperator &I,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeLine">                        Value *Num, Value *Den,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">227</td>
    <td class="codeLine">                        Value *Num, Value *Den,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeLine">                        bool IsDiv, bool IsSigned) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">228</td>
    <td class="codeLine">                        bool IsDiv, bool IsSigned) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">229</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeLine">  Value *expandDivRem24Impl(IRBuilder<> &Builder, BinaryOperator &I,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">230</td>
    <td class="codeLine">  Value *expandDivRem24Impl(IRBuilder<> &Builder, BinaryOperator &I,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeLine">                            Value *Num, Value *Den, unsigned NumBits,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">231</td>
    <td class="codeLine">                            Value *Num, Value *Den, unsigned NumBits,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeLine">                            bool IsDiv, bool IsSigned) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">232</td>
    <td class="codeLine">                            bool IsDiv, bool IsSigned) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">233</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeLine">  /// Expands 32 bit div or rem.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">234</td>
    <td class="codeLine">  /// Expands 32 bit div or rem.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeLine">  Value* expandDivRem32(IRBuilder<> &Builder, BinaryOperator &I,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">235</td>
    <td class="codeLine">  Value* expandDivRem32(IRBuilder<> &Builder, BinaryOperator &I,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeLine">                        Value *Num, Value *Den) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">236</td>
    <td class="codeLine">                        Value *Num, Value *Den) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">237</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeLine">  Value *shrinkDivRem64(IRBuilder<> &Builder, BinaryOperator &I,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">238</td>
    <td class="codeLine">  Value *shrinkDivRem64(IRBuilder<> &Builder, BinaryOperator &I,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeLine">                        Value *Num, Value *Den) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">239</td>
    <td class="codeLine">                        Value *Num, Value *Den) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeLine">  void expandDivRem64(BinaryOperator &I) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">240</td>
    <td class="codeLine">  void expandDivRem64(BinaryOperator &I) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">241</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeLine">  /// Widen a scalar load.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">242</td>
    <td class="codeLine">  /// Widen a scalar load.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">243</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeLine">  /// \details \p Widen scalar load for uniform, small type loads from constant</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">244</td>
    <td class="codeLine">  /// \details \p Widen scalar load for uniform, small type loads from constant</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeLine">  //  memory / to a full 32-bits and then truncate the input to allow a scalar</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">245</td>
    <td class="codeLine">  //  memory / to a full 32-bits and then truncate the input to allow a scalar</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeLine">  //  load instead of a vector load.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">246</td>
    <td class="codeLine">  //  load instead of a vector load.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">247</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeLine">  /// \returns True.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">248</td>
    <td class="codeLine">  /// \returns True.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">249</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeLine">  bool canWidenScalarExtLoad(LoadInst &I) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">250</td>
    <td class="codeLine">  bool canWidenScalarExtLoad(LoadInst &I) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">251</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeLine">  Value *matchFractPat(IntrinsicInst &I);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">252</td>
    <td class="codeLine">  Value *matchFractPat(IntrinsicInst &I);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeLine">  Value *applyFractPat(IRBuilder<> &Builder, Value *FractArg);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">253</td>
    <td class="codeLine">  Value *applyFractPat(IRBuilder<> &Builder, Value *FractArg);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">254</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeLine">  bool canOptimizeWithRsq(const FPMathOperator *SqrtOp, FastMathFlags DivFMF,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">255</td>
    <td class="codeLine">  bool canOptimizeWithRsq(const FPMathOperator *SqrtOp, FastMathFlags DivFMF,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeLine">                          FastMathFlags SqrtFMF) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">256</td>
    <td class="codeLine">                          FastMathFlags SqrtFMF) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">257</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeLine">  Value *optimizeWithRsq(IRBuilder<> &Builder, Value *Num, Value *Den,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">258</td>
    <td class="codeLine">  Value *optimizeWithRsq(IRBuilder<> &Builder, Value *Num, Value *Den,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeLine">                         FastMathFlags DivFMF, FastMathFlags SqrtFMF,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">259</td>
    <td class="codeLine">                         FastMathFlags DivFMF, FastMathFlags SqrtFMF,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeLine">                         const Instruction *CtxI) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">260</td>
    <td class="codeLine">                         const Instruction *CtxI) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">261</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeLine">  Value *optimizeWithRcp(IRBuilder<> &Builder, Value *Num, Value *Den,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">262</td>
    <td class="codeLine">  Value *optimizeWithRcp(IRBuilder<> &Builder, Value *Num, Value *Den,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeLine">                         FastMathFlags FMF, const Instruction *CtxI) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">263</td>
    <td class="codeLine">                         FastMathFlags FMF, const Instruction *CtxI) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeLine">  Value *optimizeWithFDivFast(IRBuilder<> &Builder, Value *Num, Value *Den,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">264</td>
    <td class="codeLine">  Value *optimizeWithFDivFast(IRBuilder<> &Builder, Value *Num, Value *Den,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeLine">                              float ReqdAccuracy) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">265</td>
    <td class="codeLine">                              float ReqdAccuracy) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">266</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeLine">  Value *visitFDivElement(IRBuilder<> &Builder, Value *Num, Value *Den,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">267</td>
    <td class="codeLine">  Value *visitFDivElement(IRBuilder<> &Builder, Value *Num, Value *Den,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeLine">                          FastMathFlags DivFMF, FastMathFlags SqrtFMF,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">268</td>
    <td class="codeLine">                          FastMathFlags DivFMF, FastMathFlags SqrtFMF,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeLine">                          Value *RsqOp, const Instruction *FDiv,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">269</td>
    <td class="codeLine">                          Value *RsqOp, const Instruction *FDiv,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeLine">                          float ReqdAccuracy) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">270</td>
    <td class="codeLine">                          float ReqdAccuracy) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">271</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeLine">  std::pair<Value *, Value *> getFrexpResults(IRBuilder<> &Builder,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">272</td>
    <td class="codeLine">  std::pair<Value *, Value *> getFrexpResults(IRBuilder<> &Builder,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeLine">                                              Value *Src) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">273</td>
    <td class="codeLine">                                              Value *Src) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">274</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeLine">  Value *emitRcpIEEE1ULP(IRBuilder<> &Builder, Value *Src,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">275</td>
    <td class="codeLine">  Value *emitRcpIEEE1ULP(IRBuilder<> &Builder, Value *Src,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeLine">                         bool IsNegative) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">276</td>
    <td class="codeLine">                         bool IsNegative) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeLine">  Value *emitFrexpDiv(IRBuilder<> &Builder, Value *LHS, Value *RHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">277</td>
    <td class="codeLine">  Value *emitFrexpDiv(IRBuilder<> &Builder, Value *LHS, Value *RHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeLine">                      FastMathFlags FMF) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">278</td>
    <td class="codeLine">                      FastMathFlags FMF) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">279</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">280</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeLine">  bool visitFDiv(BinaryOperator &I);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">281</td>
    <td class="codeLine">  bool visitFDiv(BinaryOperator &I);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">282</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeLine">  bool visitInstruction(Instruction &I) { return false; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">283</td>
    <td class="codeLine">  bool visitInstruction(Instruction &I) { return false; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeLine">  bool visitBinaryOperator(BinaryOperator &I);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">284</td>
    <td class="codeLine">  bool visitBinaryOperator(BinaryOperator &I);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeLine">  bool visitLoadInst(LoadInst &I);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">285</td>
    <td class="codeLine">  bool visitLoadInst(LoadInst &I);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeLine">  bool visitICmpInst(ICmpInst &I);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">286</td>
    <td class="codeLine">  bool visitICmpInst(ICmpInst &I);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeLine">  bool visitSelectInst(SelectInst &I);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">287</td>
    <td class="codeLine">  bool visitSelectInst(SelectInst &I);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeLine">  bool visitPHINode(PHINode &I);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">288</td>
    <td class="codeLine">  bool visitPHINode(PHINode &I);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">289</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeLine">  bool visitIntrinsicInst(IntrinsicInst &I);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">290</td>
    <td class="codeLine">  bool visitIntrinsicInst(IntrinsicInst &I);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeLine">  bool visitBitreverseIntrinsicInst(IntrinsicInst &I);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">291</td>
    <td class="codeLine">  bool visitBitreverseIntrinsicInst(IntrinsicInst &I);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeLine">  bool visitMinNum(IntrinsicInst &I);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">292</td>
    <td class="codeLine">  bool visitMinNum(IntrinsicInst &I);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeLine">  bool run(Function &F);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">293</td>
    <td class="codeLine">  bool run(Function &F);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">294</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">295</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeLine">class AMDGPUCodeGenPrepare : public FunctionPass {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">296</td>
    <td class="codeLine">class AMDGPUCodeGenPrepare : public FunctionPass {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">297</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeLine">  AMDGPUCodeGenPrepareImpl Impl;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">298</td>
    <td class="codeLine">  AMDGPUCodeGenPrepareImpl Impl;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">299</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">300</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeLine">  static char ID;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">301</td>
    <td class="codeLine">  static char ID;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeLine">  AMDGPUCodeGenPrepare() : FunctionPass(ID) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">302</td>
    <td class="codeLine">  AMDGPUCodeGenPrepare() : FunctionPass(ID) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeLine">    initializeAMDGPUCodeGenPreparePass(*PassRegistry::getPassRegistry());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">303</td>
    <td class="codeLine">    initializeAMDGPUCodeGenPreparePass(*PassRegistry::getPassRegistry());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">304</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeLine">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">305</td>
    <td class="codeLine">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeLine">    AU.addRequired<AssumptionCacheTracker>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">306</td>
    <td class="codeLine">    AU.addRequired<AssumptionCacheTracker>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeLine">    AU.addRequired<UniformityInfoWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">307</td>
    <td class="codeLine">    AU.addRequired<UniformityInfoWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeLine">    AU.addRequired<TargetLibraryInfoWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">308</td>
    <td class="codeLine">    AU.addRequired<TargetLibraryInfoWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">309</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeLine">    // FIXME: Division expansion needs to preserve the dominator tree.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">310</td>
    <td class="codeLine">    // FIXME: Division expansion needs to preserve the dominator tree.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeLine">    if (!ExpandDiv64InIR)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">311</td>
    <td class="codeLine">    if (!ExpandDiv64InIR)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeLine">      AU.setPreservesAll();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">312</td>
    <td class="codeLine">      AU.setPreservesAll();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">313</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeLine">  bool runOnFunction(Function &F) override;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">314</td>
    <td class="codeLine">  bool runOnFunction(Function &F) override;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeLine">  bool doInitialization(Module &M) override;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">315</td>
    <td class="codeLine">  bool doInitialization(Module &M) override;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeLine">  StringRef getPassName() const override { return "AMDGPU IR optimizations"; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">316</td>
    <td class="codeLine">  StringRef getPassName() const override { return "AMDGPU IR optimizations"; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">317</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">318</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeLine">} // end anonymous namespace</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">319</td>
    <td class="codeLine">} // end anonymous namespace</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">320</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::run(Function &F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">321</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::run(Function &F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeLine">  bool MadeChange = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">322</td>
    <td class="codeLine">  bool MadeChange = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">323</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeLine">  Function::iterator NextBB;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">324</td>
    <td class="codeLine">  Function::iterator NextBB;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeLine">  for (Function::iterator FI = F.begin(), FE = F.end(); FI != FE; FI = NextBB) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">325</td>
    <td class="codeLine">  for (Function::iterator FI = F.begin(), FE = F.end(); FI != FE; FI = NextBB) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeLine">    BasicBlock *BB = &*FI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">326</td>
    <td class="codeLine">    BasicBlock *BB = &*FI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeLine">    NextBB = std::next(FI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">327</td>
    <td class="codeLine">    NextBB = std::next(FI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">328</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeLine">    BasicBlock::iterator Next;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">329</td>
    <td class="codeLine">    BasicBlock::iterator Next;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeLine">    for (BasicBlock::iterator I = BB->begin(), E = BB->end(); I != E;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">330</td>
    <td class="codeLine">    for (BasicBlock::iterator I = BB->begin(), E = BB->end(); I != E;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeLine">         I = Next) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">331</td>
    <td class="codeLine">         I = Next) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeLine">      Next = std::next(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">332</td>
    <td class="codeLine">      Next = std::next(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">333</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeLine">      MadeChange |= visit(*I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">334</td>
    <td class="codeLine">      MadeChange |= visit(*I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">335</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeLine">      if (Next != E) { // Control flow changed</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">336</td>
    <td class="codeLine">      if (Next != E) { // Control flow changed</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeLine">        BasicBlock *NextInstBB = Next->getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">337</td>
    <td class="codeLine">        BasicBlock *NextInstBB = Next->getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeLine">        if (NextInstBB != BB) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">338</td>
    <td class="codeLine">        if (NextInstBB != BB) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeLine">          BB = NextInstBB;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">339</td>
    <td class="codeLine">          BB = NextInstBB;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeLine">          E = BB->end();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">340</td>
    <td class="codeLine">          E = BB->end();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeLine">          FE = F.end();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">341</td>
    <td class="codeLine">          FE = F.end();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">342</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">343</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">344</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">345</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeLine">  return MadeChange;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">346</td>
    <td class="codeLine">  return MadeChange;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">347</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">348</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeLine">unsigned AMDGPUCodeGenPrepareImpl::getBaseElementBitWidth(const Type *T) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">349</td>
    <td class="codeLine">unsigned AMDGPUCodeGenPrepareImpl::getBaseElementBitWidth(const Type *T) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeLine">  assert(needsPromotionToI32(T) && "T does not need promotion to i32");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">350</td>
    <td class="codeLine">  assert(needsPromotionToI32(T) && "T does not need promotion to i32");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">351</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeLine">  if (T->isIntegerTy())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">352</td>
    <td class="codeLine">  if (T->isIntegerTy())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeLine">    return T->getIntegerBitWidth();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">353</td>
    <td class="codeLine">    return T->getIntegerBitWidth();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeLine">  return cast<VectorType>(T)->getElementType()->getIntegerBitWidth();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">354</td>
    <td class="codeLine">  return cast<VectorType>(T)->getElementType()->getIntegerBitWidth();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">355</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">356</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeLine">Type *AMDGPUCodeGenPrepareImpl::getI32Ty(IRBuilder<> &B, const Type *T) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">357</td>
    <td class="codeLine">Type *AMDGPUCodeGenPrepareImpl::getI32Ty(IRBuilder<> &B, const Type *T) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeLine">  assert(needsPromotionToI32(T) && "T does not need promotion to i32");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">358</td>
    <td class="codeLine">  assert(needsPromotionToI32(T) && "T does not need promotion to i32");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">359</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeLine">  if (T->isIntegerTy())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">360</td>
    <td class="codeLine">  if (T->isIntegerTy())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeLine">    return B.getInt32Ty();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">361</td>
    <td class="codeLine">    return B.getInt32Ty();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeLine">  return FixedVectorType::get(B.getInt32Ty(), cast<FixedVectorType>(T));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">362</td>
    <td class="codeLine">  return FixedVectorType::get(B.getInt32Ty(), cast<FixedVectorType>(T));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">363</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">364</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::isSigned(const BinaryOperator &I) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">365</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::isSigned(const BinaryOperator &I) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeLine">  return I.getOpcode() == Instruction::AShr ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">366</td>
    <td class="codeLine">  return I.getOpcode() == Instruction::AShr ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeLine">      I.getOpcode() == Instruction::SDiv || I.getOpcode() == Instruction::SRem;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">367</td>
    <td class="codeLine">      I.getOpcode() == Instruction::SDiv || I.getOpcode() == Instruction::SRem;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">368</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">369</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::isSigned(const SelectInst &I) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">370</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::isSigned(const SelectInst &I) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeLine">  return isa<ICmpInst>(I.getOperand(0)) ?</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">371</td>
    <td class="codeLine">  return isa<ICmpInst>(I.getOperand(0)) ?</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeLine">      cast<ICmpInst>(I.getOperand(0))->isSigned() : false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">372</td>
    <td class="codeLine">      cast<ICmpInst>(I.getOperand(0))->isSigned() : false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">373</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">374</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::needsPromotionToI32(const Type *T) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">375</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::needsPromotionToI32(const Type *T) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeLine">  if (!Widen16BitOps)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">376</td>
    <td class="codeLine">  if (!Widen16BitOps)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">377</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">378</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeLine">  const IntegerType *IntTy = dyn_cast<IntegerType>(T);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">379</td>
    <td class="codeLine">  const IntegerType *IntTy = dyn_cast<IntegerType>(T);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeLine">  if (IntTy && IntTy->getBitWidth() > 1 && IntTy->getBitWidth() <= 16)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">380</td>
    <td class="codeLine">  if (IntTy && IntTy->getBitWidth() > 1 && IntTy->getBitWidth() <= 16)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">381</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">382</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeLine">  if (const VectorType *VT = dyn_cast<VectorType>(T)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">383</td>
    <td class="codeLine">  if (const VectorType *VT = dyn_cast<VectorType>(T)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeLine">    // TODO: The set of packed operations is more limited, so may want to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">384</td>
    <td class="codeLine">    // TODO: The set of packed operations is more limited, so may want to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeLine">    // promote some anyway.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">385</td>
    <td class="codeLine">    // promote some anyway.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeLine">    if (ST->hasVOP3PInsts())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">386</td>
    <td class="codeLine">    if (ST->hasVOP3PInsts())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">387</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">388</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeLine">    return needsPromotionToI32(VT->getElementType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">389</td>
    <td class="codeLine">    return needsPromotionToI32(VT->getElementType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">390</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">391</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">392</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">393</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">394</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::isLegalFloatingTy(const Type *Ty) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">395</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::isLegalFloatingTy(const Type *Ty) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeLine">  return Ty->isFloatTy() || Ty->isDoubleTy() ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">396</td>
    <td class="codeLine">  return Ty->isFloatTy() || Ty->isDoubleTy() ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeLine">         (Ty->isHalfTy() && ST->has16BitInsts());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">397</td>
    <td class="codeLine">         (Ty->isHalfTy() && ST->has16BitInsts());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">398</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">399</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeLine">// Return true if the op promoted to i32 should have nsw set.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">400</td>
    <td class="codeLine">// Return true if the op promoted to i32 should have nsw set.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeLine">static bool promotedOpIsNSW(const Instruction &I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">401</td>
    <td class="codeLine">static bool promotedOpIsNSW(const Instruction &I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeLine">  switch (I.getOpcode()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">402</td>
    <td class="codeLine">  switch (I.getOpcode()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeLine">  case Instruction::Shl:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">403</td>
    <td class="codeLine">  case Instruction::Shl:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeLine">  case Instruction::Add:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">404</td>
    <td class="codeLine">  case Instruction::Add:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeLine">  case Instruction::Sub:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">405</td>
    <td class="codeLine">  case Instruction::Sub:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">406</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeLine">  case Instruction::Mul:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">407</td>
    <td class="codeLine">  case Instruction::Mul:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeLine">    return I.hasNoUnsignedWrap();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">408</td>
    <td class="codeLine">    return I.hasNoUnsignedWrap();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">409</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">410</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">411</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">412</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">413</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeLine">// Return true if the op promoted to i32 should have nuw set.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">414</td>
    <td class="codeLine">// Return true if the op promoted to i32 should have nuw set.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeLine">static bool promotedOpIsNUW(const Instruction &I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">415</td>
    <td class="codeLine">static bool promotedOpIsNUW(const Instruction &I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeLine">  switch (I.getOpcode()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">416</td>
    <td class="codeLine">  switch (I.getOpcode()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeLine">  case Instruction::Shl:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">417</td>
    <td class="codeLine">  case Instruction::Shl:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeLine">  case Instruction::Add:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">418</td>
    <td class="codeLine">  case Instruction::Add:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeLine">  case Instruction::Mul:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">419</td>
    <td class="codeLine">  case Instruction::Mul:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">420</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeLine">  case Instruction::Sub:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">421</td>
    <td class="codeLine">  case Instruction::Sub:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeLine">    return I.hasNoUnsignedWrap();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">422</td>
    <td class="codeLine">    return I.hasNoUnsignedWrap();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">423</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">424</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">425</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">426</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">427</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::canWidenScalarExtLoad(LoadInst &I) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">428</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::canWidenScalarExtLoad(LoadInst &I) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeLine">  Type *Ty = I.getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">429</td>
    <td class="codeLine">  Type *Ty = I.getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeLine">  const DataLayout &DL = Mod->getDataLayout();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">430</td>
    <td class="codeLine">  const DataLayout &DL = Mod->getDataLayout();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeLine">  int TySize = DL.getTypeSizeInBits(Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">431</td>
    <td class="codeLine">  int TySize = DL.getTypeSizeInBits(Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeLine">  Align Alignment = DL.getValueOrABITypeAlignment(I.getAlign(), Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">432</td>
    <td class="codeLine">  Align Alignment = DL.getValueOrABITypeAlignment(I.getAlign(), Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">433</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeLine">  return I.isSimple() && TySize < 32 && Alignment >= 4 && UA->isUniform(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">434</td>
    <td class="codeLine">  return I.isSimple() && TySize < 32 && Alignment >= 4 && UA->isUniform(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">435</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">436</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::promoteUniformOpToI32(BinaryOperator &I) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">437</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::promoteUniformOpToI32(BinaryOperator &I) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeLine">  assert(needsPromotionToI32(I.getType()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">438</td>
    <td class="codeLine">  assert(needsPromotionToI32(I.getType()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeLine">         "I does not need promotion to i32");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">439</td>
    <td class="codeLine">         "I does not need promotion to i32");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">440</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeLine">  if (I.getOpcode() == Instruction::SDiv ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">441</td>
    <td class="codeLine">  if (I.getOpcode() == Instruction::SDiv ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeLine">      I.getOpcode() == Instruction::UDiv ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">442</td>
    <td class="codeLine">      I.getOpcode() == Instruction::UDiv ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeLine">      I.getOpcode() == Instruction::SRem ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">443</td>
    <td class="codeLine">      I.getOpcode() == Instruction::SRem ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeLine">      I.getOpcode() == Instruction::URem)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">444</td>
    <td class="codeLine">      I.getOpcode() == Instruction::URem)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">445</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">446</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeLine">  IRBuilder<> Builder(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">447</td>
    <td class="codeLine">  IRBuilder<> Builder(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeLine">  Builder.SetCurrentDebugLocation(I.getDebugLoc());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">448</td>
    <td class="codeLine">  Builder.SetCurrentDebugLocation(I.getDebugLoc());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">449</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeLine">  Type *I32Ty = getI32Ty(Builder, I.getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">450</td>
    <td class="codeLine">  Type *I32Ty = getI32Ty(Builder, I.getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeLine">  Value *ExtOp0 = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">451</td>
    <td class="codeLine">  Value *ExtOp0 = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeLine">  Value *ExtOp1 = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">452</td>
    <td class="codeLine">  Value *ExtOp1 = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeLine">  Value *ExtRes = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">453</td>
    <td class="codeLine">  Value *ExtRes = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeLine">  Value *TruncRes = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">454</td>
    <td class="codeLine">  Value *TruncRes = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">455</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeLine">  if (isSigned(I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">456</td>
    <td class="codeLine">  if (isSigned(I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeLine">    ExtOp0 = Builder.CreateSExt(I.getOperand(0), I32Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">457</td>
    <td class="codeLine">    ExtOp0 = Builder.CreateSExt(I.getOperand(0), I32Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeLine">    ExtOp1 = Builder.CreateSExt(I.getOperand(1), I32Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">458</td>
    <td class="codeLine">    ExtOp1 = Builder.CreateSExt(I.getOperand(1), I32Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">459</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeLine">    ExtOp0 = Builder.CreateZExt(I.getOperand(0), I32Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">460</td>
    <td class="codeLine">    ExtOp0 = Builder.CreateZExt(I.getOperand(0), I32Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeLine">    ExtOp1 = Builder.CreateZExt(I.getOperand(1), I32Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">461</td>
    <td class="codeLine">    ExtOp1 = Builder.CreateZExt(I.getOperand(1), I32Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">462</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">463</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeLine">  ExtRes = Builder.CreateBinOp(I.getOpcode(), ExtOp0, ExtOp1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">464</td>
    <td class="codeLine">  ExtRes = Builder.CreateBinOp(I.getOpcode(), ExtOp0, ExtOp1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeLine">  if (Instruction *Inst = dyn_cast<Instruction>(ExtRes)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">465</td>
    <td class="codeLine">  if (Instruction *Inst = dyn_cast<Instruction>(ExtRes)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeLine">    if (promotedOpIsNSW(cast<Instruction>(I)))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">466</td>
    <td class="codeLine">    if (promotedOpIsNSW(cast<Instruction>(I)))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeLine">      Inst->setHasNoSignedWrap();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">467</td>
    <td class="codeLine">      Inst->setHasNoSignedWrap();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">468</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeLine">    if (promotedOpIsNUW(cast<Instruction>(I)))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">469</td>
    <td class="codeLine">    if (promotedOpIsNUW(cast<Instruction>(I)))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeLine">      Inst->setHasNoUnsignedWrap();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">470</td>
    <td class="codeLine">      Inst->setHasNoUnsignedWrap();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">471</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeLine">    if (const auto *ExactOp = dyn_cast<PossiblyExactOperator>(&I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">472</td>
    <td class="codeLine">    if (const auto *ExactOp = dyn_cast<PossiblyExactOperator>(&I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeLine">      Inst->setIsExact(ExactOp->isExact());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">473</td>
    <td class="codeLine">      Inst->setIsExact(ExactOp->isExact());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">474</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">475</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeLine">  TruncRes = Builder.CreateTrunc(ExtRes, I.getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">476</td>
    <td class="codeLine">  TruncRes = Builder.CreateTrunc(ExtRes, I.getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">477</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeLine">  I.replaceAllUsesWith(TruncRes);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">478</td>
    <td class="codeLine">  I.replaceAllUsesWith(TruncRes);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeLine">  I.eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">479</td>
    <td class="codeLine">  I.eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">480</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">481</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">482</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">483</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::promoteUniformOpToI32(ICmpInst &I) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">484</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::promoteUniformOpToI32(ICmpInst &I) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeLine">  assert(needsPromotionToI32(I.getOperand(0)->getType()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">485</td>
    <td class="codeLine">  assert(needsPromotionToI32(I.getOperand(0)->getType()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeLine">         "I does not need promotion to i32");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">486</td>
    <td class="codeLine">         "I does not need promotion to i32");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">487</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeLine">  IRBuilder<> Builder(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">488</td>
    <td class="codeLine">  IRBuilder<> Builder(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeLine">  Builder.SetCurrentDebugLocation(I.getDebugLoc());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">489</td>
    <td class="codeLine">  Builder.SetCurrentDebugLocation(I.getDebugLoc());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">490</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeLine">  Type *I32Ty = getI32Ty(Builder, I.getOperand(0)->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">491</td>
    <td class="codeLine">  Type *I32Ty = getI32Ty(Builder, I.getOperand(0)->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeLine">  Value *ExtOp0 = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">492</td>
    <td class="codeLine">  Value *ExtOp0 = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeLine">  Value *ExtOp1 = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">493</td>
    <td class="codeLine">  Value *ExtOp1 = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeLine">  Value *NewICmp  = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">494</td>
    <td class="codeLine">  Value *NewICmp  = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">495</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeLine">  if (I.isSigned()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">496</td>
    <td class="codeLine">  if (I.isSigned()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeLine">    ExtOp0 = Builder.CreateSExt(I.getOperand(0), I32Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">497</td>
    <td class="codeLine">    ExtOp0 = Builder.CreateSExt(I.getOperand(0), I32Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeLine">    ExtOp1 = Builder.CreateSExt(I.getOperand(1), I32Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">498</td>
    <td class="codeLine">    ExtOp1 = Builder.CreateSExt(I.getOperand(1), I32Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">499</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeLine">    ExtOp0 = Builder.CreateZExt(I.getOperand(0), I32Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">500</td>
    <td class="codeLine">    ExtOp0 = Builder.CreateZExt(I.getOperand(0), I32Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeLine">    ExtOp1 = Builder.CreateZExt(I.getOperand(1), I32Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">501</td>
    <td class="codeLine">    ExtOp1 = Builder.CreateZExt(I.getOperand(1), I32Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">502</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeLine">  NewICmp = Builder.CreateICmp(I.getPredicate(), ExtOp0, ExtOp1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">503</td>
    <td class="codeLine">  NewICmp = Builder.CreateICmp(I.getPredicate(), ExtOp0, ExtOp1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">504</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeLine">  I.replaceAllUsesWith(NewICmp);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">505</td>
    <td class="codeLine">  I.replaceAllUsesWith(NewICmp);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeLine">  I.eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">506</td>
    <td class="codeLine">  I.eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">507</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">508</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">509</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">510</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::promoteUniformOpToI32(SelectInst &I) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">511</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::promoteUniformOpToI32(SelectInst &I) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeLine">  assert(needsPromotionToI32(I.getType()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">512</td>
    <td class="codeLine">  assert(needsPromotionToI32(I.getType()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeLine">         "I does not need promotion to i32");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">513</td>
    <td class="codeLine">         "I does not need promotion to i32");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">514</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeLine">  IRBuilder<> Builder(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">515</td>
    <td class="codeLine">  IRBuilder<> Builder(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeLine">  Builder.SetCurrentDebugLocation(I.getDebugLoc());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">516</td>
    <td class="codeLine">  Builder.SetCurrentDebugLocation(I.getDebugLoc());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">517</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeLine">  Type *I32Ty = getI32Ty(Builder, I.getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">518</td>
    <td class="codeLine">  Type *I32Ty = getI32Ty(Builder, I.getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeLine">  Value *ExtOp1 = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">519</td>
    <td class="codeLine">  Value *ExtOp1 = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeLine">  Value *ExtOp2 = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">520</td>
    <td class="codeLine">  Value *ExtOp2 = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeLine">  Value *ExtRes = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">521</td>
    <td class="codeLine">  Value *ExtRes = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeLine">  Value *TruncRes = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">522</td>
    <td class="codeLine">  Value *TruncRes = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">523</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeLine">  if (isSigned(I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">524</td>
    <td class="codeLine">  if (isSigned(I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeLine">    ExtOp1 = Builder.CreateSExt(I.getOperand(1), I32Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">525</td>
    <td class="codeLine">    ExtOp1 = Builder.CreateSExt(I.getOperand(1), I32Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeLine">    ExtOp2 = Builder.CreateSExt(I.getOperand(2), I32Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">526</td>
    <td class="codeLine">    ExtOp2 = Builder.CreateSExt(I.getOperand(2), I32Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">527</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeLine">    ExtOp1 = Builder.CreateZExt(I.getOperand(1), I32Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">528</td>
    <td class="codeLine">    ExtOp1 = Builder.CreateZExt(I.getOperand(1), I32Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeLine">    ExtOp2 = Builder.CreateZExt(I.getOperand(2), I32Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">529</td>
    <td class="codeLine">    ExtOp2 = Builder.CreateZExt(I.getOperand(2), I32Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">530</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeLine">  ExtRes = Builder.CreateSelect(I.getOperand(0), ExtOp1, ExtOp2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">531</td>
    <td class="codeLine">  ExtRes = Builder.CreateSelect(I.getOperand(0), ExtOp1, ExtOp2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeLine">  TruncRes = Builder.CreateTrunc(ExtRes, I.getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">532</td>
    <td class="codeLine">  TruncRes = Builder.CreateTrunc(ExtRes, I.getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">533</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeLine">  I.replaceAllUsesWith(TruncRes);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">534</td>
    <td class="codeLine">  I.replaceAllUsesWith(TruncRes);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeLine">  I.eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">535</td>
    <td class="codeLine">  I.eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">536</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">537</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">538</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">539</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::promoteUniformBitreverseToI32(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">540</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::promoteUniformBitreverseToI32(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeLine">    IntrinsicInst &I) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">541</td>
    <td class="codeLine">    IntrinsicInst &I) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeLine">  assert(I.getIntrinsicID() == Intrinsic::bitreverse &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">542</td>
    <td class="codeLine">  assert(I.getIntrinsicID() == Intrinsic::bitreverse &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeLine">         "I must be bitreverse intrinsic");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">543</td>
    <td class="codeLine">         "I must be bitreverse intrinsic");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeLine">  assert(needsPromotionToI32(I.getType()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">544</td>
    <td class="codeLine">  assert(needsPromotionToI32(I.getType()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeLine">         "I does not need promotion to i32");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">545</td>
    <td class="codeLine">         "I does not need promotion to i32");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">546</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeLine">  IRBuilder<> Builder(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">547</td>
    <td class="codeLine">  IRBuilder<> Builder(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeLine">  Builder.SetCurrentDebugLocation(I.getDebugLoc());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">548</td>
    <td class="codeLine">  Builder.SetCurrentDebugLocation(I.getDebugLoc());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">549</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeLine">  Type *I32Ty = getI32Ty(Builder, I.getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">550</td>
    <td class="codeLine">  Type *I32Ty = getI32Ty(Builder, I.getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeLine">  Function *I32 =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">551</td>
    <td class="codeLine">  Function *I32 =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeLine">      Intrinsic::getDeclaration(Mod, Intrinsic::bitreverse, { I32Ty });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">552</td>
    <td class="codeLine">      Intrinsic::getDeclaration(Mod, Intrinsic::bitreverse, { I32Ty });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeLine">  Value *ExtOp = Builder.CreateZExt(I.getOperand(0), I32Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">553</td>
    <td class="codeLine">  Value *ExtOp = Builder.CreateZExt(I.getOperand(0), I32Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeLine">  Value *ExtRes = Builder.CreateCall(I32, { ExtOp });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">554</td>
    <td class="codeLine">  Value *ExtRes = Builder.CreateCall(I32, { ExtOp });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeLine">  Value *LShrOp =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">555</td>
    <td class="codeLine">  Value *LShrOp =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeLine">      Builder.CreateLShr(ExtRes, 32 - getBaseElementBitWidth(I.getType()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">556</td>
    <td class="codeLine">      Builder.CreateLShr(ExtRes, 32 - getBaseElementBitWidth(I.getType()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeLine">  Value *TruncRes =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">557</td>
    <td class="codeLine">  Value *TruncRes =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeLine">      Builder.CreateTrunc(LShrOp, I.getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">558</td>
    <td class="codeLine">      Builder.CreateTrunc(LShrOp, I.getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">559</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeLine">  I.replaceAllUsesWith(TruncRes);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">560</td>
    <td class="codeLine">  I.replaceAllUsesWith(TruncRes);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeLine">  I.eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">561</td>
    <td class="codeLine">  I.eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">562</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">563</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">564</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">565</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeLine">unsigned AMDGPUCodeGenPrepareImpl::numBitsUnsigned(Value *Op) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">566</td>
    <td class="codeLine">unsigned AMDGPUCodeGenPrepareImpl::numBitsUnsigned(Value *Op) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeLine">  return computeKnownBits(Op, *DL, 0, AC).countMaxActiveBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">567</td>
    <td class="codeLine">  return computeKnownBits(Op, *DL, 0, AC).countMaxActiveBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">568</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">569</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeLine">unsigned AMDGPUCodeGenPrepareImpl::numBitsSigned(Value *Op) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">570</td>
    <td class="codeLine">unsigned AMDGPUCodeGenPrepareImpl::numBitsSigned(Value *Op) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeLine">  return ComputeMaxSignificantBits(Op, *DL, 0, AC);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">571</td>
    <td class="codeLine">  return ComputeMaxSignificantBits(Op, *DL, 0, AC);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">572</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">573</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeLine">static void extractValues(IRBuilder<> &Builder,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">574</td>
    <td class="codeLine">static void extractValues(IRBuilder<> &Builder,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeLine">                          SmallVectorImpl<Value *> &Values, Value *V) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">575</td>
    <td class="codeLine">                          SmallVectorImpl<Value *> &Values, Value *V) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeLine">  auto *VT = dyn_cast<FixedVectorType>(V->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">576</td>
    <td class="codeLine">  auto *VT = dyn_cast<FixedVectorType>(V->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeLine">  if (!VT) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">577</td>
    <td class="codeLine">  if (!VT) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeLine">    Values.push_back(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">578</td>
    <td class="codeLine">    Values.push_back(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">579</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">580</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">581</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeLine">  for (int I = 0, E = VT->getNumElements(); I != E; ++I)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">582</td>
    <td class="codeLine">  for (int I = 0, E = VT->getNumElements(); I != E; ++I)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeLine">    Values.push_back(Builder.CreateExtractElement(V, I));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">583</td>
    <td class="codeLine">    Values.push_back(Builder.CreateExtractElement(V, I));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">584</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">585</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeLine">static Value *insertValues(IRBuilder<> &Builder,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">586</td>
    <td class="codeLine">static Value *insertValues(IRBuilder<> &Builder,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeLine">                           Type *Ty,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">587</td>
    <td class="codeLine">                           Type *Ty,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeLine">                           SmallVectorImpl<Value *> &Values) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">588</td>
    <td class="codeLine">                           SmallVectorImpl<Value *> &Values) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeLine">  if (!Ty->isVectorTy()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">589</td>
    <td class="codeLine">  if (!Ty->isVectorTy()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeLine">    assert(Values.size() == 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">590</td>
    <td class="codeLine">    assert(Values.size() == 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeLine">    return Values[0];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">591</td>
    <td class="codeLine">    return Values[0];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">592</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">593</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeLine">  Value *NewVal = PoisonValue::get(Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">594</td>
    <td class="codeLine">  Value *NewVal = PoisonValue::get(Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeLine">  for (int I = 0, E = Values.size(); I != E; ++I)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">595</td>
    <td class="codeLine">  for (int I = 0, E = Values.size(); I != E; ++I)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeLine">    NewVal = Builder.CreateInsertElement(NewVal, Values[I], I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">596</td>
    <td class="codeLine">    NewVal = Builder.CreateInsertElement(NewVal, Values[I], I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">597</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeLine">  return NewVal;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">598</td>
    <td class="codeLine">  return NewVal;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">599</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">600</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeLine">// Returns 24-bit or 48-bit (as per `NumBits` and `Size`) mul of `LHS` and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">601</td>
    <td class="codeLine">// Returns 24-bit or 48-bit (as per `NumBits` and `Size`) mul of `LHS` and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeLine">// `RHS`. `NumBits` is the number of KnownBits of the result and `Size` is the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">602</td>
    <td class="codeLine">// `RHS`. `NumBits` is the number of KnownBits of the result and `Size` is the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeLine">// width of the original destination.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">603</td>
    <td class="codeLine">// width of the original destination.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeLine">static Value *getMul24(IRBuilder<> &Builder, Value *LHS, Value *RHS,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">604</td>
    <td class="codeLine">static Value *getMul24(IRBuilder<> &Builder, Value *LHS, Value *RHS,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeLine">                       unsigned Size, unsigned NumBits, bool IsSigned) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">605</td>
    <td class="codeLine">                       unsigned Size, unsigned NumBits, bool IsSigned) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeLine">  if (Size <= 32 || NumBits <= 32) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">606</td>
    <td class="codeLine">  if (Size <= 32 || NumBits <= 32) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeLine">    Intrinsic::ID ID =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">607</td>
    <td class="codeLine">    Intrinsic::ID ID =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeLine">        IsSigned ? Intrinsic::amdgcn_mul_i24 : Intrinsic::amdgcn_mul_u24;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">608</td>
    <td class="codeLine">        IsSigned ? Intrinsic::amdgcn_mul_i24 : Intrinsic::amdgcn_mul_u24;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeLine">    return Builder.CreateIntrinsic(ID, {}, {LHS, RHS});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">609</td>
    <td class="codeLine">    return Builder.CreateIntrinsic(ID, {}, {LHS, RHS});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">610</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">611</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeLine">  assert(NumBits <= 48);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">612</td>
    <td class="codeLine">  assert(NumBits <= 48);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">613</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeLine">  Intrinsic::ID LoID =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">614</td>
    <td class="codeLine">  Intrinsic::ID LoID =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeLine">      IsSigned ? Intrinsic::amdgcn_mul_i24 : Intrinsic::amdgcn_mul_u24;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">615</td>
    <td class="codeLine">      IsSigned ? Intrinsic::amdgcn_mul_i24 : Intrinsic::amdgcn_mul_u24;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeLine">  Intrinsic::ID HiID =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">616</td>
    <td class="codeLine">  Intrinsic::ID HiID =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeLine">      IsSigned ? Intrinsic::amdgcn_mulhi_i24 : Intrinsic::amdgcn_mulhi_u24;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">617</td>
    <td class="codeLine">      IsSigned ? Intrinsic::amdgcn_mulhi_i24 : Intrinsic::amdgcn_mulhi_u24;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">618</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeLine">  Value *Lo = Builder.CreateIntrinsic(LoID, {}, {LHS, RHS});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">619</td>
    <td class="codeLine">  Value *Lo = Builder.CreateIntrinsic(LoID, {}, {LHS, RHS});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeLine">  Value *Hi = Builder.CreateIntrinsic(HiID, {}, {LHS, RHS});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">620</td>
    <td class="codeLine">  Value *Hi = Builder.CreateIntrinsic(HiID, {}, {LHS, RHS});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">621</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeLine">  IntegerType *I64Ty = Builder.getInt64Ty();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">622</td>
    <td class="codeLine">  IntegerType *I64Ty = Builder.getInt64Ty();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeLine">  Lo = Builder.CreateZExtOrTrunc(Lo, I64Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">623</td>
    <td class="codeLine">  Lo = Builder.CreateZExtOrTrunc(Lo, I64Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeLine">  Hi = Builder.CreateZExtOrTrunc(Hi, I64Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">624</td>
    <td class="codeLine">  Hi = Builder.CreateZExtOrTrunc(Hi, I64Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">625</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeLine">  return Builder.CreateOr(Lo, Builder.CreateShl(Hi, 32));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">626</td>
    <td class="codeLine">  return Builder.CreateOr(Lo, Builder.CreateShl(Hi, 32));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">627</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">628</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::replaceMulWithMul24(BinaryOperator &I) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">629</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::replaceMulWithMul24(BinaryOperator &I) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeLine">  if (I.getOpcode() != Instruction::Mul)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">630</td>
    <td class="codeLine">  if (I.getOpcode() != Instruction::Mul)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">631</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">632</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeLine">  Type *Ty = I.getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">633</td>
    <td class="codeLine">  Type *Ty = I.getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeLine">  unsigned Size = Ty->getScalarSizeInBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">634</td>
    <td class="codeLine">  unsigned Size = Ty->getScalarSizeInBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeLine">  if (Size <= 16 && ST->has16BitInsts())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">635</td>
    <td class="codeLine">  if (Size <= 16 && ST->has16BitInsts())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">636</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">637</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeLine">  // Prefer scalar if this could be s_mul_i32</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">638</td>
    <td class="codeLine">  // Prefer scalar if this could be s_mul_i32</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeLine">  if (UA->isUniform(&I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">639</td>
    <td class="codeLine">  if (UA->isUniform(&I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">640</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">641</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeLine">  Value *LHS = I.getOperand(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">642</td>
    <td class="codeLine">  Value *LHS = I.getOperand(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeLine">  Value *RHS = I.getOperand(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">643</td>
    <td class="codeLine">  Value *RHS = I.getOperand(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeLine">  IRBuilder<> Builder(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">644</td>
    <td class="codeLine">  IRBuilder<> Builder(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeLine">  Builder.SetCurrentDebugLocation(I.getDebugLoc());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">645</td>
    <td class="codeLine">  Builder.SetCurrentDebugLocation(I.getDebugLoc());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">646</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeLine">  unsigned LHSBits = 0, RHSBits = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">647</td>
    <td class="codeLine">  unsigned LHSBits = 0, RHSBits = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeLine">  bool IsSigned = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">648</td>
    <td class="codeLine">  bool IsSigned = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">649</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeLine">  if (ST->hasMulU24() && (LHSBits = numBitsUnsigned(LHS)) <= 24 &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">650</td>
    <td class="codeLine">  if (ST->hasMulU24() && (LHSBits = numBitsUnsigned(LHS)) <= 24 &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeLine">      (RHSBits = numBitsUnsigned(RHS)) <= 24) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">651</td>
    <td class="codeLine">      (RHSBits = numBitsUnsigned(RHS)) <= 24) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeLine">    IsSigned = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">652</td>
    <td class="codeLine">    IsSigned = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">653</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeLine">  } else if (ST->hasMulI24() && (LHSBits = numBitsSigned(LHS)) <= 24 &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">654</td>
    <td class="codeLine">  } else if (ST->hasMulI24() && (LHSBits = numBitsSigned(LHS)) <= 24 &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeLine">             (RHSBits = numBitsSigned(RHS)) <= 24) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">655</td>
    <td class="codeLine">             (RHSBits = numBitsSigned(RHS)) <= 24) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeLine">    IsSigned = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">656</td>
    <td class="codeLine">    IsSigned = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">657</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeLine">  } else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">658</td>
    <td class="codeLine">  } else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">659</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">660</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeLine">  SmallVector<Value *, 4> LHSVals;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">661</td>
    <td class="codeLine">  SmallVector<Value *, 4> LHSVals;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeLine">  SmallVector<Value *, 4> RHSVals;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">662</td>
    <td class="codeLine">  SmallVector<Value *, 4> RHSVals;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeLine">  SmallVector<Value *, 4> ResultVals;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">663</td>
    <td class="codeLine">  SmallVector<Value *, 4> ResultVals;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeLine">  extractValues(Builder, LHSVals, LHS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">664</td>
    <td class="codeLine">  extractValues(Builder, LHSVals, LHS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeLine">  extractValues(Builder, RHSVals, RHS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">665</td>
    <td class="codeLine">  extractValues(Builder, RHSVals, RHS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">666</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeLine">  IntegerType *I32Ty = Builder.getInt32Ty();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">667</td>
    <td class="codeLine">  IntegerType *I32Ty = Builder.getInt32Ty();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeLine">  for (int I = 0, E = LHSVals.size(); I != E; ++I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">668</td>
    <td class="codeLine">  for (int I = 0, E = LHSVals.size(); I != E; ++I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeLine">    Value *LHS, *RHS;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">669</td>
    <td class="codeLine">    Value *LHS, *RHS;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeLine">    if (IsSigned) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">670</td>
    <td class="codeLine">    if (IsSigned) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeLine">      LHS = Builder.CreateSExtOrTrunc(LHSVals[I], I32Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">671</td>
    <td class="codeLine">      LHS = Builder.CreateSExtOrTrunc(LHSVals[I], I32Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeLine">      RHS = Builder.CreateSExtOrTrunc(RHSVals[I], I32Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">672</td>
    <td class="codeLine">      RHS = Builder.CreateSExtOrTrunc(RHSVals[I], I32Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">673</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeLine">      LHS = Builder.CreateZExtOrTrunc(LHSVals[I], I32Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">674</td>
    <td class="codeLine">      LHS = Builder.CreateZExtOrTrunc(LHSVals[I], I32Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeLine">      RHS = Builder.CreateZExtOrTrunc(RHSVals[I], I32Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">675</td>
    <td class="codeLine">      RHS = Builder.CreateZExtOrTrunc(RHSVals[I], I32Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">676</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">677</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeLine">    Value *Result =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">678</td>
    <td class="codeLine">    Value *Result =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeLine">        getMul24(Builder, LHS, RHS, Size, LHSBits + RHSBits, IsSigned);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">679</td>
    <td class="codeLine">        getMul24(Builder, LHS, RHS, Size, LHSBits + RHSBits, IsSigned);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">680</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeLine">    if (IsSigned) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">681</td>
    <td class="codeLine">    if (IsSigned) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeLine">      ResultVals.push_back(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">682</td>
    <td class="codeLine">      ResultVals.push_back(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeLine">          Builder.CreateSExtOrTrunc(Result, LHSVals[I]->getType()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">683</td>
    <td class="codeLine">          Builder.CreateSExtOrTrunc(Result, LHSVals[I]->getType()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">684</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeLine">      ResultVals.push_back(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">685</td>
    <td class="codeLine">      ResultVals.push_back(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeLine">          Builder.CreateZExtOrTrunc(Result, LHSVals[I]->getType()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">686</td>
    <td class="codeLine">          Builder.CreateZExtOrTrunc(Result, LHSVals[I]->getType()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">687</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">688</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">689</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeLine">  Value *NewVal = insertValues(Builder, Ty, ResultVals);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">690</td>
    <td class="codeLine">  Value *NewVal = insertValues(Builder, Ty, ResultVals);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeLine">  NewVal->takeName(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">691</td>
    <td class="codeLine">  NewVal->takeName(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeLine">  I.replaceAllUsesWith(NewVal);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">692</td>
    <td class="codeLine">  I.replaceAllUsesWith(NewVal);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeLine">  I.eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">693</td>
    <td class="codeLine">  I.eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">694</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">695</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">696</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">697</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeLine">// Find a select instruction, which may have been casted. This is mostly to deal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">698</td>
    <td class="codeLine">// Find a select instruction, which may have been casted. This is mostly to deal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeLine">// with cases where i16 selects were promoted here to i32.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">699</td>
    <td class="codeLine">// with cases where i16 selects were promoted here to i32.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeLine">static SelectInst *findSelectThroughCast(Value *V, CastInst *&Cast) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">700</td>
    <td class="codeLine">static SelectInst *findSelectThroughCast(Value *V, CastInst *&Cast) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeLine">  Cast = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">701</td>
    <td class="codeLine">  Cast = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeLine">  if (SelectInst *Sel = dyn_cast<SelectInst>(V))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">702</td>
    <td class="codeLine">  if (SelectInst *Sel = dyn_cast<SelectInst>(V))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeLine">    return Sel;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">703</td>
    <td class="codeLine">    return Sel;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">704</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeLine">  if ((Cast = dyn_cast<CastInst>(V))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">705</td>
    <td class="codeLine">  if ((Cast = dyn_cast<CastInst>(V))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeLine">    if (SelectInst *Sel = dyn_cast<SelectInst>(Cast->getOperand(0)))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">706</td>
    <td class="codeLine">    if (SelectInst *Sel = dyn_cast<SelectInst>(Cast->getOperand(0)))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeLine">      return Sel;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">707</td>
    <td class="codeLine">      return Sel;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">708</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">709</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">710</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">711</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">712</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::foldBinOpIntoSelect(BinaryOperator &BO) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">713</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::foldBinOpIntoSelect(BinaryOperator &BO) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeLine">  // Don't do this unless the old select is going away. We want to eliminate the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">714</td>
    <td class="codeLine">  // Don't do this unless the old select is going away. We want to eliminate the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeLine">  // binary operator, not replace a binop with a select.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">715</td>
    <td class="codeLine">  // binary operator, not replace a binop with a select.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeLine">  int SelOpNo = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">716</td>
    <td class="codeLine">  int SelOpNo = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">717</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeLine">  CastInst *CastOp;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">718</td>
    <td class="codeLine">  CastInst *CastOp;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">719</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeLine">  // TODO: Should probably try to handle some cases with multiple</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">720</td>
    <td class="codeLine">  // TODO: Should probably try to handle some cases with multiple</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeLine">  // users. Duplicating the select may be profitable for division.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">721</td>
    <td class="codeLine">  // users. Duplicating the select may be profitable for division.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeLine">  SelectInst *Sel = findSelectThroughCast(BO.getOperand(0), CastOp);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">722</td>
    <td class="codeLine">  SelectInst *Sel = findSelectThroughCast(BO.getOperand(0), CastOp);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeLine">  if (!Sel || !Sel->hasOneUse()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">723</td>
    <td class="codeLine">  if (!Sel || !Sel->hasOneUse()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeLine">    SelOpNo = 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">724</td>
    <td class="codeLine">    SelOpNo = 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeLine">    Sel = findSelectThroughCast(BO.getOperand(1), CastOp);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">725</td>
    <td class="codeLine">    Sel = findSelectThroughCast(BO.getOperand(1), CastOp);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">726</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">727</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeLine">  if (!Sel || !Sel->hasOneUse())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">728</td>
    <td class="codeLine">  if (!Sel || !Sel->hasOneUse())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">729</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">730</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeLine">  Constant *CT = dyn_cast<Constant>(Sel->getTrueValue());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">731</td>
    <td class="codeLine">  Constant *CT = dyn_cast<Constant>(Sel->getTrueValue());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeLine">  Constant *CF = dyn_cast<Constant>(Sel->getFalseValue());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">732</td>
    <td class="codeLine">  Constant *CF = dyn_cast<Constant>(Sel->getFalseValue());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeLine">  Constant *CBO = dyn_cast<Constant>(BO.getOperand(SelOpNo ^ 1));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">733</td>
    <td class="codeLine">  Constant *CBO = dyn_cast<Constant>(BO.getOperand(SelOpNo ^ 1));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeLine">  if (!CBO || !CT || !CF)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">734</td>
    <td class="codeLine">  if (!CBO || !CT || !CF)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">735</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">736</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeLine">  if (CastOp) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">737</td>
    <td class="codeLine">  if (CastOp) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeLine">    if (!CastOp->hasOneUse())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">738</td>
    <td class="codeLine">    if (!CastOp->hasOneUse())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">739</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeLine">    CT = ConstantFoldCastOperand(CastOp->getOpcode(), CT, BO.getType(), *DL);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">740</td>
    <td class="codeLine">    CT = ConstantFoldCastOperand(CastOp->getOpcode(), CT, BO.getType(), *DL);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeLine">    CF = ConstantFoldCastOperand(CastOp->getOpcode(), CF, BO.getType(), *DL);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">741</td>
    <td class="codeLine">    CF = ConstantFoldCastOperand(CastOp->getOpcode(), CF, BO.getType(), *DL);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">742</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">743</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeLine">  // TODO: Handle special 0/-1 cases DAG combine does, although we only really</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">744</td>
    <td class="codeLine">  // TODO: Handle special 0/-1 cases DAG combine does, although we only really</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeLine">  // need to handle divisions here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">745</td>
    <td class="codeLine">  // need to handle divisions here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeLine">  Constant *FoldedT = SelOpNo ?</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">746</td>
    <td class="codeLine">  Constant *FoldedT = SelOpNo ?</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeLine">    ConstantFoldBinaryOpOperands(BO.getOpcode(), CBO, CT, *DL) :</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">747</td>
    <td class="codeLine">    ConstantFoldBinaryOpOperands(BO.getOpcode(), CBO, CT, *DL) :</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeLine">    ConstantFoldBinaryOpOperands(BO.getOpcode(), CT, CBO, *DL);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">748</td>
    <td class="codeLine">    ConstantFoldBinaryOpOperands(BO.getOpcode(), CT, CBO, *DL);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeLine">  if (!FoldedT || isa<ConstantExpr>(FoldedT))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">749</td>
    <td class="codeLine">  if (!FoldedT || isa<ConstantExpr>(FoldedT))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">750</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">751</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeLine">  Constant *FoldedF = SelOpNo ?</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">752</td>
    <td class="codeLine">  Constant *FoldedF = SelOpNo ?</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeLine">    ConstantFoldBinaryOpOperands(BO.getOpcode(), CBO, CF, *DL) :</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">753</td>
    <td class="codeLine">    ConstantFoldBinaryOpOperands(BO.getOpcode(), CBO, CF, *DL) :</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeLine">    ConstantFoldBinaryOpOperands(BO.getOpcode(), CF, CBO, *DL);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">754</td>
    <td class="codeLine">    ConstantFoldBinaryOpOperands(BO.getOpcode(), CF, CBO, *DL);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeLine">  if (!FoldedF || isa<ConstantExpr>(FoldedF))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">755</td>
    <td class="codeLine">  if (!FoldedF || isa<ConstantExpr>(FoldedF))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">756</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">757</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeLine">  IRBuilder<> Builder(&BO);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">758</td>
    <td class="codeLine">  IRBuilder<> Builder(&BO);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeLine">  Builder.SetCurrentDebugLocation(BO.getDebugLoc());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">759</td>
    <td class="codeLine">  Builder.SetCurrentDebugLocation(BO.getDebugLoc());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeLine">  if (const FPMathOperator *FPOp = dyn_cast<const FPMathOperator>(&BO))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">760</td>
    <td class="codeLine">  if (const FPMathOperator *FPOp = dyn_cast<const FPMathOperator>(&BO))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeLine">    Builder.setFastMathFlags(FPOp->getFastMathFlags());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">761</td>
    <td class="codeLine">    Builder.setFastMathFlags(FPOp->getFastMathFlags());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">762</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeLine">  Value *NewSelect = Builder.CreateSelect(Sel->getCondition(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">763</td>
    <td class="codeLine">  Value *NewSelect = Builder.CreateSelect(Sel->getCondition(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeLine">                                          FoldedT, FoldedF);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">764</td>
    <td class="codeLine">                                          FoldedT, FoldedF);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeLine">  NewSelect->takeName(&BO);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">765</td>
    <td class="codeLine">  NewSelect->takeName(&BO);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeLine">  BO.replaceAllUsesWith(NewSelect);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">766</td>
    <td class="codeLine">  BO.replaceAllUsesWith(NewSelect);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeLine">  BO.eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">767</td>
    <td class="codeLine">  BO.eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeLine">  if (CastOp)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">768</td>
    <td class="codeLine">  if (CastOp)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeLine">    CastOp->eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">769</td>
    <td class="codeLine">    CastOp->eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeLine">  Sel->eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">770</td>
    <td class="codeLine">  Sel->eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">771</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">772</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">773</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeLine">std::pair<Value *, Value *></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">774</td>
    <td class="codeLine">std::pair<Value *, Value *></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeLine">AMDGPUCodeGenPrepareImpl::getFrexpResults(IRBuilder<> &Builder,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">775</td>
    <td class="codeLine">AMDGPUCodeGenPrepareImpl::getFrexpResults(IRBuilder<> &Builder,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeLine">                                          Value *Src) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">776</td>
    <td class="codeLine">                                          Value *Src) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeLine">  Type *Ty = Src->getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">777</td>
    <td class="codeLine">  Type *Ty = Src->getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeLine">  Value *Frexp = Builder.CreateIntrinsic(Intrinsic::frexp,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">778</td>
    <td class="codeLine">  Value *Frexp = Builder.CreateIntrinsic(Intrinsic::frexp,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeLine">                                         {Ty, Builder.getInt32Ty()}, Src);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">779</td>
    <td class="codeLine">                                         {Ty, Builder.getInt32Ty()}, Src);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeLine">  Value *FrexpMant = Builder.CreateExtractValue(Frexp, {0});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">780</td>
    <td class="codeLine">  Value *FrexpMant = Builder.CreateExtractValue(Frexp, {0});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">781</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeLine">  // Bypass the bug workaround for the exponent result since it doesn't matter.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">782</td>
    <td class="codeLine">  // Bypass the bug workaround for the exponent result since it doesn't matter.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeLine">  // TODO: Does the bug workaround even really need to consider the exponent</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">783</td>
    <td class="codeLine">  // TODO: Does the bug workaround even really need to consider the exponent</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeLine">  // result? It's unspecified by the spec.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">784</td>
    <td class="codeLine">  // result? It's unspecified by the spec.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">785</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeLine">  Value *FrexpExp =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">786</td>
    <td class="codeLine">  Value *FrexpExp =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeLine">      ST->hasFractBug()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">787</td>
    <td class="codeLine">      ST->hasFractBug()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeLine">          ? Builder.CreateIntrinsic(Intrinsic::amdgcn_frexp_exp,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">788</td>
    <td class="codeLine">          ? Builder.CreateIntrinsic(Intrinsic::amdgcn_frexp_exp,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeLine">                                    {Builder.getInt32Ty(), Ty}, Src)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">789</td>
    <td class="codeLine">                                    {Builder.getInt32Ty(), Ty}, Src)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeLine">          : Builder.CreateExtractValue(Frexp, {1});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">790</td>
    <td class="codeLine">          : Builder.CreateExtractValue(Frexp, {1});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeLine">  return {FrexpMant, FrexpExp};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">791</td>
    <td class="codeLine">  return {FrexpMant, FrexpExp};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">792</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">793</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeLine">/// Emit an expansion of 1.0 / Src good for 1ulp that supports denormals.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">794</td>
    <td class="codeLine">/// Emit an expansion of 1.0 / Src good for 1ulp that supports denormals.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeLine">Value *AMDGPUCodeGenPrepareImpl::emitRcpIEEE1ULP(IRBuilder<> &Builder,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">795</td>
    <td class="codeLine">Value *AMDGPUCodeGenPrepareImpl::emitRcpIEEE1ULP(IRBuilder<> &Builder,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeLine">                                                 Value *Src,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">796</td>
    <td class="codeLine">                                                 Value *Src,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeLine">                                                 bool IsNegative) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">797</td>
    <td class="codeLine">                                                 bool IsNegative) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeLine">  // Same as for 1.0, but expand the sign out of the constant.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">798</td>
    <td class="codeLine">  // Same as for 1.0, but expand the sign out of the constant.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeLine">  // -1.0 / x -> rcp (fneg x)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">799</td>
    <td class="codeLine">  // -1.0 / x -> rcp (fneg x)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeLine">  if (IsNegative)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">800</td>
    <td class="codeLine">  if (IsNegative)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeLine">    Src = Builder.CreateFNeg(Src);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">801</td>
    <td class="codeLine">    Src = Builder.CreateFNeg(Src);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">802</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeLine">  // The rcp instruction doesn't support denormals, so scale the input</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">803</td>
    <td class="codeLine">  // The rcp instruction doesn't support denormals, so scale the input</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeLine">  // out of the denormal range and convert at the end.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">804</td>
    <td class="codeLine">  // out of the denormal range and convert at the end.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">805</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeLine">  // Expand as 2^-n * (1.0 / (x * 2^n))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">806</td>
    <td class="codeLine">  // Expand as 2^-n * (1.0 / (x * 2^n))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">807</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeLine">  // TODO: Skip scaling if input is known never denormal and the input</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">808</td>
    <td class="codeLine">  // TODO: Skip scaling if input is known never denormal and the input</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeLine">  // range won't underflow to denormal. The hard part is knowing the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">809</td>
    <td class="codeLine">  // range won't underflow to denormal. The hard part is knowing the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeLine">  // result. We need a range check, the result could be denormal for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">810</td>
    <td class="codeLine">  // result. We need a range check, the result could be denormal for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeLine">  // 0x1p+126 < den <= 0x1p+127.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">811</td>
    <td class="codeLine">  // 0x1p+126 < den <= 0x1p+127.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">812</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeLine">  Type *Ty = Src->getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">813</td>
    <td class="codeLine">  Type *Ty = Src->getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">814</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeLine">  auto [FrexpMant, FrexpExp] = getFrexpResults(Builder, Src);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">815</td>
    <td class="codeLine">  auto [FrexpMant, FrexpExp] = getFrexpResults(Builder, Src);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeLine">  Value *ScaleFactor = Builder.CreateNeg(FrexpExp);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">816</td>
    <td class="codeLine">  Value *ScaleFactor = Builder.CreateNeg(FrexpExp);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeLine">  Value *Rcp = Builder.CreateUnaryIntrinsic(Intrinsic::amdgcn_rcp, FrexpMant);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">817</td>
    <td class="codeLine">  Value *Rcp = Builder.CreateUnaryIntrinsic(Intrinsic::amdgcn_rcp, FrexpMant);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeLine">  return Builder.CreateIntrinsic(Intrinsic::ldexp, {Ty, Builder.getInt32Ty()},</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">818</td>
    <td class="codeLine">  return Builder.CreateIntrinsic(Intrinsic::ldexp, {Ty, Builder.getInt32Ty()},</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeLine">                                 {Rcp, ScaleFactor});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">819</td>
    <td class="codeLine">                                 {Rcp, ScaleFactor});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">820</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">821</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeLine">/// Emit a 2ulp expansion for fdiv by using frexp for input scaling.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">822</td>
    <td class="codeLine">/// Emit a 2ulp expansion for fdiv by using frexp for input scaling.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeLine">Value *AMDGPUCodeGenPrepareImpl::emitFrexpDiv(IRBuilder<> &Builder, Value *LHS,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">823</td>
    <td class="codeLine">Value *AMDGPUCodeGenPrepareImpl::emitFrexpDiv(IRBuilder<> &Builder, Value *LHS,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeLine">                                              Value *RHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">824</td>
    <td class="codeLine">                                              Value *RHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeLine">                                              FastMathFlags FMF) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">825</td>
    <td class="codeLine">                                              FastMathFlags FMF) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeLine">  // If we have have to work around the fract/frexp bug, we're worse off than</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">826</td>
    <td class="codeLine">  // If we have have to work around the fract/frexp bug, we're worse off than</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeLine">  // using the fdiv.fast expansion. The full safe expansion is faster if we have</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">827</td>
    <td class="codeLine">  // using the fdiv.fast expansion. The full safe expansion is faster if we have</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeLine">  // fast FMA.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">828</td>
    <td class="codeLine">  // fast FMA.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeLine">  if (HasFP32DenormalFlush && ST->hasFractBug() && !ST->hasFastFMAF32() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">829</td>
    <td class="codeLine">  if (HasFP32DenormalFlush && ST->hasFractBug() && !ST->hasFastFMAF32() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeLine">      (!FMF.noNaNs() || !FMF.noInfs()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">830</td>
    <td class="codeLine">      (!FMF.noNaNs() || !FMF.noInfs()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">831</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">832</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeLine">  // We're scaling the LHS to avoid a denormal input, and scale the denominator</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">833</td>
    <td class="codeLine">  // We're scaling the LHS to avoid a denormal input, and scale the denominator</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeLine">  // to avoid large values underflowing the result.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">834</td>
    <td class="codeLine">  // to avoid large values underflowing the result.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeLine">  Type *Ty = LHS->getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">835</td>
    <td class="codeLine">  Type *Ty = LHS->getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">836</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeLine">  auto [FrexpMantRHS, FrexpExpRHS] = getFrexpResults(Builder, RHS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">837</td>
    <td class="codeLine">  auto [FrexpMantRHS, FrexpExpRHS] = getFrexpResults(Builder, RHS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">838</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeLine">  Value *Rcp =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">839</td>
    <td class="codeLine">  Value *Rcp =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeLine">      Builder.CreateUnaryIntrinsic(Intrinsic::amdgcn_rcp, FrexpMantRHS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">840</td>
    <td class="codeLine">      Builder.CreateUnaryIntrinsic(Intrinsic::amdgcn_rcp, FrexpMantRHS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">841</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeLine">  auto [FrexpMantLHS, FrexpExpLHS] = getFrexpResults(Builder, LHS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">842</td>
    <td class="codeLine">  auto [FrexpMantLHS, FrexpExpLHS] = getFrexpResults(Builder, LHS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeLine">  Value *Mul = Builder.CreateFMul(FrexpMantLHS, Rcp);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">843</td>
    <td class="codeLine">  Value *Mul = Builder.CreateFMul(FrexpMantLHS, Rcp);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">844</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeLine">  // We multiplied by 2^N/2^M, so we need to multiply by 2^(N-M) to scale the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">845</td>
    <td class="codeLine">  // We multiplied by 2^N/2^M, so we need to multiply by 2^(N-M) to scale the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeLine">  // result.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">846</td>
    <td class="codeLine">  // result.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeLine">  Value *ExpDiff = Builder.CreateSub(FrexpExpLHS, FrexpExpRHS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">847</td>
    <td class="codeLine">  Value *ExpDiff = Builder.CreateSub(FrexpExpLHS, FrexpExpRHS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeLine">  return Builder.CreateIntrinsic(Intrinsic::ldexp, {Ty, Builder.getInt32Ty()},</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">848</td>
    <td class="codeLine">  return Builder.CreateIntrinsic(Intrinsic::ldexp, {Ty, Builder.getInt32Ty()},</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeLine">                                 {Mul, ExpDiff});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">849</td>
    <td class="codeLine">                                 {Mul, ExpDiff});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">850</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">851</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeLine">/// Emit an expansion of 1.0 / sqrt(Src) good for 1ulp that supports denormals.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">852</td>
    <td class="codeLine">/// Emit an expansion of 1.0 / sqrt(Src) good for 1ulp that supports denormals.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeLine">static Value *emitRsqIEEE1ULP(IRBuilder<> &Builder, Value *Src,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">853</td>
    <td class="codeLine">static Value *emitRsqIEEE1ULP(IRBuilder<> &Builder, Value *Src,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeLine">                              bool IsNegative) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">854</td>
    <td class="codeLine">                              bool IsNegative) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeLine">  // bool need_scale = x < 0x1p-126f;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">855</td>
    <td class="codeLine">  // bool need_scale = x < 0x1p-126f;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeLine">  // float input_scale = need_scale ? 0x1.0p+24f : 1.0f;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">856</td>
    <td class="codeLine">  // float input_scale = need_scale ? 0x1.0p+24f : 1.0f;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeLine">  // float output_scale = need_scale ? 0x1.0p+12f : 1.0f;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">857</td>
    <td class="codeLine">  // float output_scale = need_scale ? 0x1.0p+12f : 1.0f;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeLine">  // rsq(x * input_scale) * output_scale;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">858</td>
    <td class="codeLine">  // rsq(x * input_scale) * output_scale;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">859</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeLine">  Type *Ty = Src->getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">860</td>
    <td class="codeLine">  Type *Ty = Src->getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeLine">  APFloat SmallestNormal =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">861</td>
    <td class="codeLine">  APFloat SmallestNormal =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeLine">      APFloat::getSmallestNormalized(Ty->getFltSemantics());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">862</td>
    <td class="codeLine">      APFloat::getSmallestNormalized(Ty->getFltSemantics());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeLine">  Value *NeedScale =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">863</td>
    <td class="codeLine">  Value *NeedScale =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeLine">      Builder.CreateFCmpOLT(Src, ConstantFP::get(Ty, SmallestNormal));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">864</td>
    <td class="codeLine">      Builder.CreateFCmpOLT(Src, ConstantFP::get(Ty, SmallestNormal));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeLine">  Constant *One = ConstantFP::get(Ty, 1.0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">865</td>
    <td class="codeLine">  Constant *One = ConstantFP::get(Ty, 1.0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeLine">  Constant *InputScale = ConstantFP::get(Ty, 0x1.0p+24);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">866</td>
    <td class="codeLine">  Constant *InputScale = ConstantFP::get(Ty, 0x1.0p+24);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeLine">  Constant *OutputScale =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">867</td>
    <td class="codeLine">  Constant *OutputScale =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeLine">      ConstantFP::get(Ty, IsNegative ? -0x1.0p+12 : 0x1.0p+12);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">868</td>
    <td class="codeLine">      ConstantFP::get(Ty, IsNegative ? -0x1.0p+12 : 0x1.0p+12);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">869</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeLine">  Value *InputScaleFactor = Builder.CreateSelect(NeedScale, InputScale, One);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">870</td>
    <td class="codeLine">  Value *InputScaleFactor = Builder.CreateSelect(NeedScale, InputScale, One);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">871</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeLine">  Value *ScaledInput = Builder.CreateFMul(Src, InputScaleFactor);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">872</td>
    <td class="codeLine">  Value *ScaledInput = Builder.CreateFMul(Src, InputScaleFactor);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeLine">  Value *Rsq = Builder.CreateUnaryIntrinsic(Intrinsic::amdgcn_rsq, ScaledInput);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">873</td>
    <td class="codeLine">  Value *Rsq = Builder.CreateUnaryIntrinsic(Intrinsic::amdgcn_rsq, ScaledInput);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeLine">  Value *OutputScaleFactor = Builder.CreateSelect(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">874</td>
    <td class="codeLine">  Value *OutputScaleFactor = Builder.CreateSelect(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeLine">      NeedScale, OutputScale, IsNegative ? ConstantFP::get(Ty, -1.0) : One);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">875</td>
    <td class="codeLine">      NeedScale, OutputScale, IsNegative ? ConstantFP::get(Ty, -1.0) : One);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">876</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeLine">  return Builder.CreateFMul(Rsq, OutputScaleFactor);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">877</td>
    <td class="codeLine">  return Builder.CreateFMul(Rsq, OutputScaleFactor);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">878</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">879</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::canOptimizeWithRsq(const FPMathOperator *SqrtOp,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">880</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::canOptimizeWithRsq(const FPMathOperator *SqrtOp,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeLine">                                                  FastMathFlags DivFMF,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">881</td>
    <td class="codeLine">                                                  FastMathFlags DivFMF,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeLine">                                                  FastMathFlags SqrtFMF) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">882</td>
    <td class="codeLine">                                                  FastMathFlags SqrtFMF) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeLine">  // The rsqrt contraction increases accuracy from ~2ulp to ~1ulp.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">883</td>
    <td class="codeLine">  // The rsqrt contraction increases accuracy from ~2ulp to ~1ulp.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeLine">  if (!DivFMF.allowContract() || !SqrtFMF.allowContract())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">884</td>
    <td class="codeLine">  if (!DivFMF.allowContract() || !SqrtFMF.allowContract())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">885</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">886</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeLine">  // v_rsq_f32 gives 1ulp</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">887</td>
    <td class="codeLine">  // v_rsq_f32 gives 1ulp</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeLine">  return SqrtFMF.approxFunc() || HasUnsafeFPMath ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">888</td>
    <td class="codeLine">  return SqrtFMF.approxFunc() || HasUnsafeFPMath ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeLine">         SqrtOp->getFPAccuracy() >= 1.0f;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">889</td>
    <td class="codeLine">         SqrtOp->getFPAccuracy() >= 1.0f;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">890</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">891</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeLine">Value *AMDGPUCodeGenPrepareImpl::optimizeWithRsq(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">892</td>
    <td class="codeLine">Value *AMDGPUCodeGenPrepareImpl::optimizeWithRsq(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeLine">    IRBuilder<> &Builder, Value *Num, Value *Den, FastMathFlags DivFMF,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">893</td>
    <td class="codeLine">    IRBuilder<> &Builder, Value *Num, Value *Den, FastMathFlags DivFMF,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeLine">    FastMathFlags SqrtFMF, const Instruction *CtxI) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">894</td>
    <td class="codeLine">    FastMathFlags SqrtFMF, const Instruction *CtxI) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeLine">  // The rsqrt contraction increases accuracy from ~2ulp to ~1ulp.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">895</td>
    <td class="codeLine">  // The rsqrt contraction increases accuracy from ~2ulp to ~1ulp.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeLine">  assert(DivFMF.allowContract() && SqrtFMF.allowContract());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">896</td>
    <td class="codeLine">  assert(DivFMF.allowContract() && SqrtFMF.allowContract());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">897</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeLine">  // rsq_f16 is accurate to 0.51 ulp.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">898</td>
    <td class="codeLine">  // rsq_f16 is accurate to 0.51 ulp.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeLine">  // rsq_f32 is accurate for !fpmath >= 1.0ulp and denormals are flushed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">899</td>
    <td class="codeLine">  // rsq_f32 is accurate for !fpmath >= 1.0ulp and denormals are flushed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeLine">  // rsq_f64 is never accurate.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">900</td>
    <td class="codeLine">  // rsq_f64 is never accurate.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeLine">  const ConstantFP *CLHS = dyn_cast<ConstantFP>(Num);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">901</td>
    <td class="codeLine">  const ConstantFP *CLHS = dyn_cast<ConstantFP>(Num);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeLine">  if (!CLHS)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">902</td>
    <td class="codeLine">  if (!CLHS)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">903</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">904</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeLine">  assert(Den->getType()->isFloatTy());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">905</td>
    <td class="codeLine">  assert(Den->getType()->isFloatTy());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">906</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeLine">  bool IsNegative = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">907</td>
    <td class="codeLine">  bool IsNegative = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">908</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeLine">  // TODO: Handle other numerator values with arcp.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">909</td>
    <td class="codeLine">  // TODO: Handle other numerator values with arcp.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeLine">  if (CLHS->isExactlyValue(1.0) || (IsNegative = CLHS->isExactlyValue(-1.0))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">910</td>
    <td class="codeLine">  if (CLHS->isExactlyValue(1.0) || (IsNegative = CLHS->isExactlyValue(-1.0))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeLine">    // Add in the sqrt flags.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">911</td>
    <td class="codeLine">    // Add in the sqrt flags.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeLine">    IRBuilder<>::FastMathFlagGuard Guard(Builder);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">912</td>
    <td class="codeLine">    IRBuilder<>::FastMathFlagGuard Guard(Builder);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeLine">    DivFMF |= SqrtFMF;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">913</td>
    <td class="codeLine">    DivFMF |= SqrtFMF;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeLine">    Builder.setFastMathFlags(DivFMF);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">914</td>
    <td class="codeLine">    Builder.setFastMathFlags(DivFMF);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">915</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeLine">    if ((DivFMF.approxFunc() && SqrtFMF.approxFunc()) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">916</td>
    <td class="codeLine">    if ((DivFMF.approxFunc() && SqrtFMF.approxFunc()) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeLine">        canIgnoreDenormalInput(Den, CtxI)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">917</td>
    <td class="codeLine">        canIgnoreDenormalInput(Den, CtxI)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeLine">      Value *Result = Builder.CreateUnaryIntrinsic(Intrinsic::amdgcn_rsq, Den);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">918</td>
    <td class="codeLine">      Value *Result = Builder.CreateUnaryIntrinsic(Intrinsic::amdgcn_rsq, Den);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeLine">      // -1.0 / sqrt(x) -> fneg(rsq(x))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">919</td>
    <td class="codeLine">      // -1.0 / sqrt(x) -> fneg(rsq(x))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeLine">      return IsNegative ? Builder.CreateFNeg(Result) : Result;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">920</td>
    <td class="codeLine">      return IsNegative ? Builder.CreateFNeg(Result) : Result;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">921</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">922</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeLine">    return emitRsqIEEE1ULP(Builder, Den, IsNegative);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">923</td>
    <td class="codeLine">    return emitRsqIEEE1ULP(Builder, Den, IsNegative);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">924</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">925</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">926</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">927</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">928</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeLine">// Optimize fdiv with rcp:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">929</td>
    <td class="codeLine">// Optimize fdiv with rcp:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">930</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeLine">// 1/x -> rcp(x) when rcp is sufficiently accurate or inaccurate rcp is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">931</td>
    <td class="codeLine">// 1/x -> rcp(x) when rcp is sufficiently accurate or inaccurate rcp is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeLine">//               allowed with unsafe-fp-math or afn.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">932</td>
    <td class="codeLine">//               allowed with unsafe-fp-math or afn.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">933</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeLine">// a/b -> a*rcp(b) when arcp is allowed, and we only need provide ULP 1.0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">934</td>
    <td class="codeLine">// a/b -> a*rcp(b) when arcp is allowed, and we only need provide ULP 1.0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeLine">Value *</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">935</td>
    <td class="codeLine">Value *</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeLine">AMDGPUCodeGenPrepareImpl::optimizeWithRcp(IRBuilder<> &Builder, Value *Num,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">936</td>
    <td class="codeLine">AMDGPUCodeGenPrepareImpl::optimizeWithRcp(IRBuilder<> &Builder, Value *Num,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeLine">                                          Value *Den, FastMathFlags FMF,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">937</td>
    <td class="codeLine">                                          Value *Den, FastMathFlags FMF,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeLine">                                          const Instruction *CtxI) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">938</td>
    <td class="codeLine">                                          const Instruction *CtxI) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeLine">  // rcp_f16 is accurate to 0.51 ulp.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">939</td>
    <td class="codeLine">  // rcp_f16 is accurate to 0.51 ulp.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeLine">  // rcp_f32 is accurate for !fpmath >= 1.0ulp and denormals are flushed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">940</td>
    <td class="codeLine">  // rcp_f32 is accurate for !fpmath >= 1.0ulp and denormals are flushed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeLine">  // rcp_f64 is never accurate.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">941</td>
    <td class="codeLine">  // rcp_f64 is never accurate.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeLine">  assert(Den->getType()->isFloatTy());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">942</td>
    <td class="codeLine">  assert(Den->getType()->isFloatTy());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">943</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeLine">  if (const ConstantFP *CLHS = dyn_cast<ConstantFP>(Num)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">944</td>
    <td class="codeLine">  if (const ConstantFP *CLHS = dyn_cast<ConstantFP>(Num)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeLine">    bool IsNegative = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">945</td>
    <td class="codeLine">    bool IsNegative = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeLine">    if (CLHS->isExactlyValue(1.0) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">946</td>
    <td class="codeLine">    if (CLHS->isExactlyValue(1.0) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeLine">        (IsNegative = CLHS->isExactlyValue(-1.0))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">947</td>
    <td class="codeLine">        (IsNegative = CLHS->isExactlyValue(-1.0))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeLine">      Value *Src = Den;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">948</td>
    <td class="codeLine">      Value *Src = Den;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">949</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeLine">      if (HasFP32DenormalFlush || FMF.approxFunc()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">950</td>
    <td class="codeLine">      if (HasFP32DenormalFlush || FMF.approxFunc()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeLine">        // -1.0 / x -> 1.0 / fneg(x)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">951</td>
    <td class="codeLine">        // -1.0 / x -> 1.0 / fneg(x)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeLine">        if (IsNegative)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">952</td>
    <td class="codeLine">        if (IsNegative)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeLine">          Src = Builder.CreateFNeg(Src);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">953</td>
    <td class="codeLine">          Src = Builder.CreateFNeg(Src);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">954</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeLine">        // v_rcp_f32 and v_rsq_f32 do not support denormals, and according to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">955</td>
    <td class="codeLine">        // v_rcp_f32 and v_rsq_f32 do not support denormals, and according to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeLine">        // the CI documentation has a worst case error of 1 ulp.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">956</td>
    <td class="codeLine">        // the CI documentation has a worst case error of 1 ulp.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeLine">        // OpenCL requires <= 2.5 ulp for 1.0 / x, so it should always be OK</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">957</td>
    <td class="codeLine">        // OpenCL requires <= 2.5 ulp for 1.0 / x, so it should always be OK</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeLine">        // to use it as long as we aren't trying to use denormals.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">958</td>
    <td class="codeLine">        // to use it as long as we aren't trying to use denormals.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeLine">        //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">959</td>
    <td class="codeLine">        //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeLine">        // v_rcp_f16 and v_rsq_f16 DO support denormals.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">960</td>
    <td class="codeLine">        // v_rcp_f16 and v_rsq_f16 DO support denormals.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">961</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeLine">        // NOTE: v_sqrt and v_rcp will be combined to v_rsq later. So we don't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">962</td>
    <td class="codeLine">        // NOTE: v_sqrt and v_rcp will be combined to v_rsq later. So we don't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeLine">        //       insert rsq intrinsic here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">963</td>
    <td class="codeLine">        //       insert rsq intrinsic here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">964</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeLine">        // 1.0 / x -> rcp(x)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">965</td>
    <td class="codeLine">        // 1.0 / x -> rcp(x)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeLine">        return Builder.CreateUnaryIntrinsic(Intrinsic::amdgcn_rcp, Src);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">966</td>
    <td class="codeLine">        return Builder.CreateUnaryIntrinsic(Intrinsic::amdgcn_rcp, Src);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">967</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">968</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeLine">      // TODO: If the input isn't denormal, and we know the input exponent isn't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">969</td>
    <td class="codeLine">      // TODO: If the input isn't denormal, and we know the input exponent isn't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeLine">      // big enough to introduce a denormal we can avoid the scaling.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">970</td>
    <td class="codeLine">      // big enough to introduce a denormal we can avoid the scaling.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeLine">      return emitRcpIEEE1ULP(Builder, Src, IsNegative);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">971</td>
    <td class="codeLine">      return emitRcpIEEE1ULP(Builder, Src, IsNegative);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">972</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">973</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">974</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeLine">  if (FMF.allowReciprocal()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">975</td>
    <td class="codeLine">  if (FMF.allowReciprocal()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeLine">    // x / y -> x * (1.0 / y)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">976</td>
    <td class="codeLine">    // x / y -> x * (1.0 / y)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">977</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeLine">    // TODO: Could avoid denormal scaling and use raw rcp if we knew the output</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">978</td>
    <td class="codeLine">    // TODO: Could avoid denormal scaling and use raw rcp if we knew the output</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeLine">    // will never underflow.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">979</td>
    <td class="codeLine">    // will never underflow.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeLine">    if (HasFP32DenormalFlush || FMF.approxFunc()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">980</td>
    <td class="codeLine">    if (HasFP32DenormalFlush || FMF.approxFunc()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeLine">      Value *Recip = Builder.CreateUnaryIntrinsic(Intrinsic::amdgcn_rcp, Den);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">981</td>
    <td class="codeLine">      Value *Recip = Builder.CreateUnaryIntrinsic(Intrinsic::amdgcn_rcp, Den);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeLine">      return Builder.CreateFMul(Num, Recip);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">982</td>
    <td class="codeLine">      return Builder.CreateFMul(Num, Recip);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">983</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">984</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeLine">    Value *Recip = emitRcpIEEE1ULP(Builder, Den, false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">985</td>
    <td class="codeLine">    Value *Recip = emitRcpIEEE1ULP(Builder, Den, false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeLine">    return Builder.CreateFMul(Num, Recip);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">986</td>
    <td class="codeLine">    return Builder.CreateFMul(Num, Recip);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">987</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">988</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">989</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">990</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">991</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeLine">// optimize with fdiv.fast:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">992</td>
    <td class="codeLine">// optimize with fdiv.fast:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">993</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeLine">// a/b -> fdiv.fast(a, b) when !fpmath >= 2.5ulp with denormals flushed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">994</td>
    <td class="codeLine">// a/b -> fdiv.fast(a, b) when !fpmath >= 2.5ulp with denormals flushed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">995</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeLine">// 1/x -> fdiv.fast(1,x)  when !fpmath >= 2.5ulp.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">996</td>
    <td class="codeLine">// 1/x -> fdiv.fast(1,x)  when !fpmath >= 2.5ulp.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">997</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeLine">// NOTE: optimizeWithRcp should be tried first because rcp is the preference.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">998</td>
    <td class="codeLine">// NOTE: optimizeWithRcp should be tried first because rcp is the preference.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeLine">Value *AMDGPUCodeGenPrepareImpl::optimizeWithFDivFast(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">999</td>
    <td class="codeLine">Value *AMDGPUCodeGenPrepareImpl::optimizeWithFDivFast(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeLine">    IRBuilder<> &Builder, Value *Num, Value *Den, float ReqdAccuracy) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1000</td>
    <td class="codeLine">    IRBuilder<> &Builder, Value *Num, Value *Den, float ReqdAccuracy) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeLine">  // fdiv.fast can achieve 2.5 ULP accuracy.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1001</td>
    <td class="codeLine">  // fdiv.fast can achieve 2.5 ULP accuracy.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeLine">  if (ReqdAccuracy < 2.5f)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1002</td>
    <td class="codeLine">  if (ReqdAccuracy < 2.5f)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1003</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1004</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeLine">  // Only have fdiv.fast for f32.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1005</td>
    <td class="codeLine">  // Only have fdiv.fast for f32.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeLine">  assert(Den->getType()->isFloatTy());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1006</td>
    <td class="codeLine">  assert(Den->getType()->isFloatTy());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1007</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeLine">  bool NumIsOne = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1008</td>
    <td class="codeLine">  bool NumIsOne = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeLine">  if (const ConstantFP *CNum = dyn_cast<ConstantFP>(Num)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1009</td>
    <td class="codeLine">  if (const ConstantFP *CNum = dyn_cast<ConstantFP>(Num)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeLine">    if (CNum->isExactlyValue(+1.0) || CNum->isExactlyValue(-1.0))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1010</td>
    <td class="codeLine">    if (CNum->isExactlyValue(+1.0) || CNum->isExactlyValue(-1.0))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeLine">      NumIsOne = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1011</td>
    <td class="codeLine">      NumIsOne = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1012</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1013</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeLine">  // fdiv does not support denormals. But 1.0/x is always fine to use it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1014</td>
    <td class="codeLine">  // fdiv does not support denormals. But 1.0/x is always fine to use it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1015</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeLine">  // TODO: This works for any value with a specific known exponent range, don't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1016</td>
    <td class="codeLine">  // TODO: This works for any value with a specific known exponent range, don't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeLine">  // just limit to constant 1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1017</td>
    <td class="codeLine">  // just limit to constant 1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeLine">  if (!HasFP32DenormalFlush && !NumIsOne)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1018</td>
    <td class="codeLine">  if (!HasFP32DenormalFlush && !NumIsOne)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1019</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1020</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeLine">  return Builder.CreateIntrinsic(Intrinsic::amdgcn_fdiv_fast, {}, {Num, Den});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1021</td>
    <td class="codeLine">  return Builder.CreateIntrinsic(Intrinsic::amdgcn_fdiv_fast, {}, {Num, Den});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1022</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1023</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeLine">Value *AMDGPUCodeGenPrepareImpl::visitFDivElement(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1024</td>
    <td class="codeLine">Value *AMDGPUCodeGenPrepareImpl::visitFDivElement(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeLine">    IRBuilder<> &Builder, Value *Num, Value *Den, FastMathFlags DivFMF,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1025</td>
    <td class="codeLine">    IRBuilder<> &Builder, Value *Num, Value *Den, FastMathFlags DivFMF,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeLine">    FastMathFlags SqrtFMF, Value *RsqOp, const Instruction *FDivInst,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1026</td>
    <td class="codeLine">    FastMathFlags SqrtFMF, Value *RsqOp, const Instruction *FDivInst,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeLine">    float ReqdDivAccuracy) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1027</td>
    <td class="codeLine">    float ReqdDivAccuracy) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeLine">  if (RsqOp) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1028</td>
    <td class="codeLine">  if (RsqOp) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeLine">    Value *Rsq =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1029</td>
    <td class="codeLine">    Value *Rsq =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeLine">        optimizeWithRsq(Builder, Num, RsqOp, DivFMF, SqrtFMF, FDivInst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1030</td>
    <td class="codeLine">        optimizeWithRsq(Builder, Num, RsqOp, DivFMF, SqrtFMF, FDivInst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeLine">    if (Rsq)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1031</td>
    <td class="codeLine">    if (Rsq)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeLine">      return Rsq;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1032</td>
    <td class="codeLine">      return Rsq;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1033</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1034</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeLine">  Value *Rcp = optimizeWithRcp(Builder, Num, Den, DivFMF, FDivInst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1035</td>
    <td class="codeLine">  Value *Rcp = optimizeWithRcp(Builder, Num, Den, DivFMF, FDivInst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeLine">  if (Rcp)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1036</td>
    <td class="codeLine">  if (Rcp)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeLine">    return Rcp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1037</td>
    <td class="codeLine">    return Rcp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1038</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeLine">  // In the basic case fdiv_fast has the same instruction count as the frexp div</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1039</td>
    <td class="codeLine">  // In the basic case fdiv_fast has the same instruction count as the frexp div</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeLine">  // expansion. Slightly prefer fdiv_fast since it ends in an fmul that can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1040</td>
    <td class="codeLine">  // expansion. Slightly prefer fdiv_fast since it ends in an fmul that can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeLine">  // potentially be fused into a user. Also, materialization of the constants</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1041</td>
    <td class="codeLine">  // potentially be fused into a user. Also, materialization of the constants</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeLine">  // can be reused for multiple instances.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1042</td>
    <td class="codeLine">  // can be reused for multiple instances.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeLine">  Value *FDivFast = optimizeWithFDivFast(Builder, Num, Den, ReqdDivAccuracy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1043</td>
    <td class="codeLine">  Value *FDivFast = optimizeWithFDivFast(Builder, Num, Den, ReqdDivAccuracy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeLine">  if (FDivFast)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1044</td>
    <td class="codeLine">  if (FDivFast)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeLine">    return FDivFast;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1045</td>
    <td class="codeLine">    return FDivFast;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1046</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeLine">  return emitFrexpDiv(Builder, Num, Den, DivFMF);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1047</td>
    <td class="codeLine">  return emitFrexpDiv(Builder, Num, Den, DivFMF);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1048</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1049</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeLine">// Optimizations is performed based on fpmath, fast math flags as well as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1050</td>
    <td class="codeLine">// Optimizations is performed based on fpmath, fast math flags as well as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeLine">// denormals to optimize fdiv with either rcp or fdiv.fast.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1051</td>
    <td class="codeLine">// denormals to optimize fdiv with either rcp or fdiv.fast.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1052</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeLine">// With rcp:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1053</td>
    <td class="codeLine">// With rcp:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeLine">//   1/x -> rcp(x) when rcp is sufficiently accurate or inaccurate rcp is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1054</td>
    <td class="codeLine">//   1/x -> rcp(x) when rcp is sufficiently accurate or inaccurate rcp is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeLine">//                 allowed with unsafe-fp-math or afn.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1055</td>
    <td class="codeLine">//                 allowed with unsafe-fp-math or afn.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1056</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeLine">//   a/b -> a*rcp(b) when inaccurate rcp is allowed with unsafe-fp-math or afn.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1057</td>
    <td class="codeLine">//   a/b -> a*rcp(b) when inaccurate rcp is allowed with unsafe-fp-math or afn.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1058</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeLine">// With fdiv.fast:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1059</td>
    <td class="codeLine">// With fdiv.fast:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeLine">//   a/b -> fdiv.fast(a, b) when !fpmath >= 2.5ulp with denormals flushed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1060</td>
    <td class="codeLine">//   a/b -> fdiv.fast(a, b) when !fpmath >= 2.5ulp with denormals flushed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1061</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeLine">//   1/x -> fdiv.fast(1,x)  when !fpmath >= 2.5ulp.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1062</td>
    <td class="codeLine">//   1/x -> fdiv.fast(1,x)  when !fpmath >= 2.5ulp.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1063</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeLine">// NOTE: rcp is the preference in cases that both are legal.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1064</td>
    <td class="codeLine">// NOTE: rcp is the preference in cases that both are legal.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::visitFDiv(BinaryOperator &FDiv) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1065</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::visitFDiv(BinaryOperator &FDiv) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeLine">  if (DisableFDivExpand)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1066</td>
    <td class="codeLine">  if (DisableFDivExpand)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1067</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1068</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeLine">  Type *Ty = FDiv.getType()->getScalarType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1069</td>
    <td class="codeLine">  Type *Ty = FDiv.getType()->getScalarType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeLine">  if (!Ty->isFloatTy())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1070</td>
    <td class="codeLine">  if (!Ty->isFloatTy())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1071</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1072</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeLine">  // The f64 rcp/rsq approximations are pretty inaccurate. We can do an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1073</td>
    <td class="codeLine">  // The f64 rcp/rsq approximations are pretty inaccurate. We can do an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeLine">  // expansion around them in codegen. f16 is good enough to always use.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1074</td>
    <td class="codeLine">  // expansion around them in codegen. f16 is good enough to always use.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1075</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeLine">  const FPMathOperator *FPOp = cast<const FPMathOperator>(&FDiv);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1076</td>
    <td class="codeLine">  const FPMathOperator *FPOp = cast<const FPMathOperator>(&FDiv);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeLine">  const FastMathFlags DivFMF = FPOp->getFastMathFlags();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1077</td>
    <td class="codeLine">  const FastMathFlags DivFMF = FPOp->getFastMathFlags();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeLine">  const float ReqdAccuracy = FPOp->getFPAccuracy();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1078</td>
    <td class="codeLine">  const float ReqdAccuracy = FPOp->getFPAccuracy();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1079</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeLine">  // Inaccurate rcp is allowed with unsafe-fp-math or afn.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1080</td>
    <td class="codeLine">  // Inaccurate rcp is allowed with unsafe-fp-math or afn.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1081</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeLine">  // Defer to codegen to handle this.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1082</td>
    <td class="codeLine">  // Defer to codegen to handle this.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1083</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeLine">  // TODO: Decide on an interpretation for interactions between afn + arcp +</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1084</td>
    <td class="codeLine">  // TODO: Decide on an interpretation for interactions between afn + arcp +</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeLine">  // !fpmath, and make it consistent between here and codegen. For now, defer</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1085</td>
    <td class="codeLine">  // !fpmath, and make it consistent between here and codegen. For now, defer</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeLine">  // expansion of afn to codegen. The current interpretation is so aggressive we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1086</td>
    <td class="codeLine">  // expansion of afn to codegen. The current interpretation is so aggressive we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeLine">  // don't need any pre-consideration here when we have better information. A</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1087</td>
    <td class="codeLine">  // don't need any pre-consideration here when we have better information. A</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeLine">  // more conservative interpretation could use handling here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1088</td>
    <td class="codeLine">  // more conservative interpretation could use handling here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeLine">  const bool AllowInaccurateRcp = HasUnsafeFPMath || DivFMF.approxFunc();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1089</td>
    <td class="codeLine">  const bool AllowInaccurateRcp = HasUnsafeFPMath || DivFMF.approxFunc();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeLine">  if (AllowInaccurateRcp)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1090</td>
    <td class="codeLine">  if (AllowInaccurateRcp)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1091</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1092</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeLine">  // Defer the correct implementations to codegen.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1093</td>
    <td class="codeLine">  // Defer the correct implementations to codegen.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeLine">  if (ReqdAccuracy < 1.0f)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1094</td>
    <td class="codeLine">  if (ReqdAccuracy < 1.0f)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1095</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1096</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeLine">  FastMathFlags SqrtFMF;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1097</td>
    <td class="codeLine">  FastMathFlags SqrtFMF;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1098</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeLine">  Value *Num = FDiv.getOperand(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1099</td>
    <td class="codeLine">  Value *Num = FDiv.getOperand(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeLine">  Value *Den = FDiv.getOperand(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1100</td>
    <td class="codeLine">  Value *Den = FDiv.getOperand(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1101</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeLine">  Value *RsqOp = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1102</td>
    <td class="codeLine">  Value *RsqOp = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeLine">  auto *DenII = dyn_cast<IntrinsicInst>(Den);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1103</td>
    <td class="codeLine">  auto *DenII = dyn_cast<IntrinsicInst>(Den);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeLine">  if (DenII && DenII->getIntrinsicID() == Intrinsic::sqrt &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1104</td>
    <td class="codeLine">  if (DenII && DenII->getIntrinsicID() == Intrinsic::sqrt &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeLine">      DenII->hasOneUse()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1105</td>
    <td class="codeLine">      DenII->hasOneUse()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeLine">    const auto *SqrtOp = cast<FPMathOperator>(DenII);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1106</td>
    <td class="codeLine">    const auto *SqrtOp = cast<FPMathOperator>(DenII);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeLine">    SqrtFMF = SqrtOp->getFastMathFlags();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1107</td>
    <td class="codeLine">    SqrtFMF = SqrtOp->getFastMathFlags();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeLine">    if (canOptimizeWithRsq(SqrtOp, DivFMF, SqrtFMF))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1108</td>
    <td class="codeLine">    if (canOptimizeWithRsq(SqrtOp, DivFMF, SqrtFMF))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeLine">      RsqOp = SqrtOp->getOperand(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1109</td>
    <td class="codeLine">      RsqOp = SqrtOp->getOperand(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1110</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1111</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeLine">  IRBuilder<> Builder(FDiv.getParent(), std::next(FDiv.getIterator()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1112</td>
    <td class="codeLine">  IRBuilder<> Builder(FDiv.getParent(), std::next(FDiv.getIterator()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeLine">  Builder.setFastMathFlags(DivFMF);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1113</td>
    <td class="codeLine">  Builder.setFastMathFlags(DivFMF);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeLine">  Builder.SetCurrentDebugLocation(FDiv.getDebugLoc());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1114</td>
    <td class="codeLine">  Builder.SetCurrentDebugLocation(FDiv.getDebugLoc());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1115</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeLine">  SmallVector<Value *, 4> NumVals;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1116</td>
    <td class="codeLine">  SmallVector<Value *, 4> NumVals;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeLine">  SmallVector<Value *, 4> DenVals;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1117</td>
    <td class="codeLine">  SmallVector<Value *, 4> DenVals;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeLine">  SmallVector<Value *, 4> RsqDenVals;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1118</td>
    <td class="codeLine">  SmallVector<Value *, 4> RsqDenVals;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeLine">  extractValues(Builder, NumVals, Num);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1119</td>
    <td class="codeLine">  extractValues(Builder, NumVals, Num);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeLine">  extractValues(Builder, DenVals, Den);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1120</td>
    <td class="codeLine">  extractValues(Builder, DenVals, Den);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1121</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeLine">  if (RsqOp)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1122</td>
    <td class="codeLine">  if (RsqOp)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeLine">    extractValues(Builder, RsqDenVals, RsqOp);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1123</td>
    <td class="codeLine">    extractValues(Builder, RsqDenVals, RsqOp);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1124</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeLine">  SmallVector<Value *, 4> ResultVals(NumVals.size());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1125</td>
    <td class="codeLine">  SmallVector<Value *, 4> ResultVals(NumVals.size());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeLine">  for (int I = 0, E = NumVals.size(); I != E; ++I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1126</td>
    <td class="codeLine">  for (int I = 0, E = NumVals.size(); I != E; ++I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeLine">    Value *NumElt = NumVals[I];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1127</td>
    <td class="codeLine">    Value *NumElt = NumVals[I];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeLine">    Value *DenElt = DenVals[I];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1128</td>
    <td class="codeLine">    Value *DenElt = DenVals[I];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeLine">    Value *RsqDenElt = RsqOp ? RsqDenVals[I] : nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1129</td>
    <td class="codeLine">    Value *RsqDenElt = RsqOp ? RsqDenVals[I] : nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1130</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeLine">    Value *NewElt =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1131</td>
    <td class="codeLine">    Value *NewElt =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeLine">        visitFDivElement(Builder, NumElt, DenElt, DivFMF, SqrtFMF, RsqDenElt,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1132</td>
    <td class="codeLine">        visitFDivElement(Builder, NumElt, DenElt, DivFMF, SqrtFMF, RsqDenElt,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeLine">                         cast<Instruction>(FPOp), ReqdAccuracy);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1133</td>
    <td class="codeLine">                         cast<Instruction>(FPOp), ReqdAccuracy);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeLine">    if (!NewElt) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1134</td>
    <td class="codeLine">    if (!NewElt) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeLine">      // Keep the original, but scalarized.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1135</td>
    <td class="codeLine">      // Keep the original, but scalarized.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1136</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeLine">      // This has the unfortunate side effect of sometimes scalarizing when</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1137</td>
    <td class="codeLine">      // This has the unfortunate side effect of sometimes scalarizing when</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeLine">      // we're not going to do anything.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1138</td>
    <td class="codeLine">      // we're not going to do anything.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeLine">      NewElt = Builder.CreateFDiv(NumElt, DenElt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1139</td>
    <td class="codeLine">      NewElt = Builder.CreateFDiv(NumElt, DenElt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeLine">      if (auto *NewEltInst = dyn_cast<Instruction>(NewElt))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1140</td>
    <td class="codeLine">      if (auto *NewEltInst = dyn_cast<Instruction>(NewElt))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeLine">        NewEltInst->copyMetadata(FDiv);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1141</td>
    <td class="codeLine">        NewEltInst->copyMetadata(FDiv);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1142</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1143</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeLine">    ResultVals[I] = NewElt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1144</td>
    <td class="codeLine">    ResultVals[I] = NewElt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1145</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1146</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeLine">  Value *NewVal = insertValues(Builder, FDiv.getType(), ResultVals);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1147</td>
    <td class="codeLine">  Value *NewVal = insertValues(Builder, FDiv.getType(), ResultVals);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1148</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeLine">  if (NewVal) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1149</td>
    <td class="codeLine">  if (NewVal) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeLine">    FDiv.replaceAllUsesWith(NewVal);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1150</td>
    <td class="codeLine">    FDiv.replaceAllUsesWith(NewVal);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeLine">    NewVal->takeName(&FDiv);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1151</td>
    <td class="codeLine">    NewVal->takeName(&FDiv);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeLine">    RecursivelyDeleteTriviallyDeadInstructions(&FDiv, TLInfo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1152</td>
    <td class="codeLine">    RecursivelyDeleteTriviallyDeadInstructions(&FDiv, TLInfo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1153</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1154</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1155</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1156</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1157</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeLine">static bool hasUnsafeFPMath(const Function &F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1158</td>
    <td class="codeLine">static bool hasUnsafeFPMath(const Function &F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeLine">  Attribute Attr = F.getFnAttribute("unsafe-fp-math");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1159</td>
    <td class="codeLine">  Attribute Attr = F.getFnAttribute("unsafe-fp-math");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeLine">  return Attr.getValueAsBool();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1160</td>
    <td class="codeLine">  return Attr.getValueAsBool();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1161</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1162</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeLine">static std::pair<Value*, Value*> getMul64(IRBuilder<> &Builder,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1163</td>
    <td class="codeLine">static std::pair<Value*, Value*> getMul64(IRBuilder<> &Builder,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeLine">                                          Value *LHS, Value *RHS) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1164</td>
    <td class="codeLine">                                          Value *LHS, Value *RHS) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeLine">  Type *I32Ty = Builder.getInt32Ty();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1165</td>
    <td class="codeLine">  Type *I32Ty = Builder.getInt32Ty();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeLine">  Type *I64Ty = Builder.getInt64Ty();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1166</td>
    <td class="codeLine">  Type *I64Ty = Builder.getInt64Ty();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1167</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeLine">  Value *LHS_EXT64 = Builder.CreateZExt(LHS, I64Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1168</td>
    <td class="codeLine">  Value *LHS_EXT64 = Builder.CreateZExt(LHS, I64Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeLine">  Value *RHS_EXT64 = Builder.CreateZExt(RHS, I64Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1169</td>
    <td class="codeLine">  Value *RHS_EXT64 = Builder.CreateZExt(RHS, I64Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeLine">  Value *MUL64 = Builder.CreateMul(LHS_EXT64, RHS_EXT64);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1170</td>
    <td class="codeLine">  Value *MUL64 = Builder.CreateMul(LHS_EXT64, RHS_EXT64);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeLine">  Value *Lo = Builder.CreateTrunc(MUL64, I32Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1171</td>
    <td class="codeLine">  Value *Lo = Builder.CreateTrunc(MUL64, I32Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeLine">  Value *Hi = Builder.CreateLShr(MUL64, Builder.getInt64(32));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1172</td>
    <td class="codeLine">  Value *Hi = Builder.CreateLShr(MUL64, Builder.getInt64(32));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeLine">  Hi = Builder.CreateTrunc(Hi, I32Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1173</td>
    <td class="codeLine">  Hi = Builder.CreateTrunc(Hi, I32Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeLine">  return std::pair(Lo, Hi);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1174</td>
    <td class="codeLine">  return std::pair(Lo, Hi);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1175</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1176</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeLine">static Value* getMulHu(IRBuilder<> &Builder, Value *LHS, Value *RHS) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1177</td>
    <td class="codeLine">static Value* getMulHu(IRBuilder<> &Builder, Value *LHS, Value *RHS) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeLine">  return getMul64(Builder, LHS, RHS).second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1178</td>
    <td class="codeLine">  return getMul64(Builder, LHS, RHS).second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1179</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1180</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeLine">/// Figure out how many bits are really needed for this division. \p AtLeast is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1181</td>
    <td class="codeLine">/// Figure out how many bits are really needed for this division. \p AtLeast is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeLine">/// an optimization hint to bypass the second ComputeNumSignBits call if we the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1182</td>
    <td class="codeLine">/// an optimization hint to bypass the second ComputeNumSignBits call if we the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeLine">/// first one is insufficient. Returns -1 on failure.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1183</td>
    <td class="codeLine">/// first one is insufficient. Returns -1 on failure.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeLine">int AMDGPUCodeGenPrepareImpl::getDivNumBits(BinaryOperator &I, Value *Num,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1184</td>
    <td class="codeLine">int AMDGPUCodeGenPrepareImpl::getDivNumBits(BinaryOperator &I, Value *Num,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeLine">                                            Value *Den, unsigned AtLeast,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1185</td>
    <td class="codeLine">                                            Value *Den, unsigned AtLeast,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeLine">                                            bool IsSigned) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1186</td>
    <td class="codeLine">                                            bool IsSigned) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeLine">  const DataLayout &DL = Mod->getDataLayout();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1187</td>
    <td class="codeLine">  const DataLayout &DL = Mod->getDataLayout();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeLine">  unsigned LHSSignBits = ComputeNumSignBits(Num, DL, 0, AC, &I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1188</td>
    <td class="codeLine">  unsigned LHSSignBits = ComputeNumSignBits(Num, DL, 0, AC, &I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeLine">  if (LHSSignBits < AtLeast)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1189</td>
    <td class="codeLine">  if (LHSSignBits < AtLeast)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeLine">    return -1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1190</td>
    <td class="codeLine">    return -1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1191</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeLine">  unsigned RHSSignBits = ComputeNumSignBits(Den, DL, 0, AC, &I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1192</td>
    <td class="codeLine">  unsigned RHSSignBits = ComputeNumSignBits(Den, DL, 0, AC, &I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeLine">  if (RHSSignBits < AtLeast)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1193</td>
    <td class="codeLine">  if (RHSSignBits < AtLeast)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeLine">    return -1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1194</td>
    <td class="codeLine">    return -1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1195</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeLine">  unsigned SignBits = std::min(LHSSignBits, RHSSignBits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1196</td>
    <td class="codeLine">  unsigned SignBits = std::min(LHSSignBits, RHSSignBits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeLine">  unsigned DivBits = Num->getType()->getScalarSizeInBits() - SignBits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1197</td>
    <td class="codeLine">  unsigned DivBits = Num->getType()->getScalarSizeInBits() - SignBits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeLine">  if (IsSigned)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1198</td>
    <td class="codeLine">  if (IsSigned)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeLine">    ++DivBits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1199</td>
    <td class="codeLine">    ++DivBits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeLine">  return DivBits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1200</td>
    <td class="codeLine">  return DivBits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1201</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1202</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeLine">// The fractional part of a float is enough to accurately represent up to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1203</td>
    <td class="codeLine">// The fractional part of a float is enough to accurately represent up to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeLine">// a 24-bit signed integer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1204</td>
    <td class="codeLine">// a 24-bit signed integer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeLine">Value *AMDGPUCodeGenPrepareImpl::expandDivRem24(IRBuilder<> &Builder,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1205</td>
    <td class="codeLine">Value *AMDGPUCodeGenPrepareImpl::expandDivRem24(IRBuilder<> &Builder,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeLine">                                                BinaryOperator &I, Value *Num,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1206</td>
    <td class="codeLine">                                                BinaryOperator &I, Value *Num,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeLine">                                                Value *Den, bool IsDiv,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1207</td>
    <td class="codeLine">                                                Value *Den, bool IsDiv,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeLine">                                                bool IsSigned) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1208</td>
    <td class="codeLine">                                                bool IsSigned) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeLine">  int DivBits = getDivNumBits(I, Num, Den, 9, IsSigned);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1209</td>
    <td class="codeLine">  int DivBits = getDivNumBits(I, Num, Den, 9, IsSigned);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeLine">  if (DivBits == -1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1210</td>
    <td class="codeLine">  if (DivBits == -1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1211</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeLine">  return expandDivRem24Impl(Builder, I, Num, Den, DivBits, IsDiv, IsSigned);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1212</td>
    <td class="codeLine">  return expandDivRem24Impl(Builder, I, Num, Den, DivBits, IsDiv, IsSigned);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1213</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1214</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeLine">Value *AMDGPUCodeGenPrepareImpl::expandDivRem24Impl(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1215</td>
    <td class="codeLine">Value *AMDGPUCodeGenPrepareImpl::expandDivRem24Impl(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeLine">    IRBuilder<> &Builder, BinaryOperator &I, Value *Num, Value *Den,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1216</td>
    <td class="codeLine">    IRBuilder<> &Builder, BinaryOperator &I, Value *Num, Value *Den,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeLine">    unsigned DivBits, bool IsDiv, bool IsSigned) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1217</td>
    <td class="codeLine">    unsigned DivBits, bool IsDiv, bool IsSigned) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeLine">  Type *I32Ty = Builder.getInt32Ty();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1218</td>
    <td class="codeLine">  Type *I32Ty = Builder.getInt32Ty();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeLine">  Num = Builder.CreateTrunc(Num, I32Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1219</td>
    <td class="codeLine">  Num = Builder.CreateTrunc(Num, I32Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeLine">  Den = Builder.CreateTrunc(Den, I32Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1220</td>
    <td class="codeLine">  Den = Builder.CreateTrunc(Den, I32Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1221</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeLine">  Type *F32Ty = Builder.getFloatTy();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1222</td>
    <td class="codeLine">  Type *F32Ty = Builder.getFloatTy();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeLine">  ConstantInt *One = Builder.getInt32(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1223</td>
    <td class="codeLine">  ConstantInt *One = Builder.getInt32(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeLine">  Value *JQ = One;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1224</td>
    <td class="codeLine">  Value *JQ = One;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeLine">  if (IsSigned) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1226</td>
    <td class="codeLine">  if (IsSigned) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeLine">    // char|short jq = ia ^ ib;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1227</td>
    <td class="codeLine">    // char|short jq = ia ^ ib;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeLine">    JQ = Builder.CreateXor(Num, Den);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1228</td>
    <td class="codeLine">    JQ = Builder.CreateXor(Num, Den);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1229</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeLine">    // jq = jq >> (bitsize - 2)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1230</td>
    <td class="codeLine">    // jq = jq >> (bitsize - 2)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeLine">    JQ = Builder.CreateAShr(JQ, Builder.getInt32(30));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1231</td>
    <td class="codeLine">    JQ = Builder.CreateAShr(JQ, Builder.getInt32(30));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1232</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeLine">    // jq = jq | 0x1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1233</td>
    <td class="codeLine">    // jq = jq | 0x1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeLine">    JQ = Builder.CreateOr(JQ, One);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1234</td>
    <td class="codeLine">    JQ = Builder.CreateOr(JQ, One);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1235</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1236</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeLine">  // int ia = (int)LHS;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1237</td>
    <td class="codeLine">  // int ia = (int)LHS;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeLine">  Value *IA = Num;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1238</td>
    <td class="codeLine">  Value *IA = Num;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1239</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeLine">  // int ib, (int)RHS;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1240</td>
    <td class="codeLine">  // int ib, (int)RHS;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeLine">  Value *IB = Den;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1241</td>
    <td class="codeLine">  Value *IB = Den;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1242</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeLine">  // float fa = (float)ia;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1243</td>
    <td class="codeLine">  // float fa = (float)ia;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeLine">  Value *FA = IsSigned ? Builder.CreateSIToFP(IA, F32Ty)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1244</td>
    <td class="codeLine">  Value *FA = IsSigned ? Builder.CreateSIToFP(IA, F32Ty)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeLine">                       : Builder.CreateUIToFP(IA, F32Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1245</td>
    <td class="codeLine">                       : Builder.CreateUIToFP(IA, F32Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1246</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeLine">  // float fb = (float)ib;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1247</td>
    <td class="codeLine">  // float fb = (float)ib;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeLine">  Value *FB = IsSigned ? Builder.CreateSIToFP(IB,F32Ty)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1248</td>
    <td class="codeLine">  Value *FB = IsSigned ? Builder.CreateSIToFP(IB,F32Ty)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeLine">                       : Builder.CreateUIToFP(IB,F32Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1249</td>
    <td class="codeLine">                       : Builder.CreateUIToFP(IB,F32Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1250</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeLine">  Function *RcpDecl = Intrinsic::getDeclaration(Mod, Intrinsic::amdgcn_rcp,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1251</td>
    <td class="codeLine">  Function *RcpDecl = Intrinsic::getDeclaration(Mod, Intrinsic::amdgcn_rcp,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeLine">                                                Builder.getFloatTy());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1252</td>
    <td class="codeLine">                                                Builder.getFloatTy());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeLine">  Value *RCP = Builder.CreateCall(RcpDecl, { FB });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1253</td>
    <td class="codeLine">  Value *RCP = Builder.CreateCall(RcpDecl, { FB });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeLine">  Value *FQM = Builder.CreateFMul(FA, RCP);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1254</td>
    <td class="codeLine">  Value *FQM = Builder.CreateFMul(FA, RCP);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1255</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeLine">  // fq = trunc(fqm);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1256</td>
    <td class="codeLine">  // fq = trunc(fqm);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeLine">  CallInst *FQ = Builder.CreateUnaryIntrinsic(Intrinsic::trunc, FQM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1257</td>
    <td class="codeLine">  CallInst *FQ = Builder.CreateUnaryIntrinsic(Intrinsic::trunc, FQM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeLine">  FQ->copyFastMathFlags(Builder.getFastMathFlags());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1258</td>
    <td class="codeLine">  FQ->copyFastMathFlags(Builder.getFastMathFlags());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1259</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeLine">  // float fqneg = -fq;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1260</td>
    <td class="codeLine">  // float fqneg = -fq;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeLine">  Value *FQNeg = Builder.CreateFNeg(FQ);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1261</td>
    <td class="codeLine">  Value *FQNeg = Builder.CreateFNeg(FQ);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1262</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeLine">  // float fr = mad(fqneg, fb, fa);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1263</td>
    <td class="codeLine">  // float fr = mad(fqneg, fb, fa);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeLine">  auto FMAD = !ST->hasMadMacF32Insts()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1264</td>
    <td class="codeLine">  auto FMAD = !ST->hasMadMacF32Insts()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeLine">                  ? Intrinsic::fma</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1265</td>
    <td class="codeLine">                  ? Intrinsic::fma</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeLine">                  : (Intrinsic::ID)Intrinsic::amdgcn_fmad_ftz;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1266</td>
    <td class="codeLine">                  : (Intrinsic::ID)Intrinsic::amdgcn_fmad_ftz;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeLine">  Value *FR = Builder.CreateIntrinsic(FMAD,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1267</td>
    <td class="codeLine">  Value *FR = Builder.CreateIntrinsic(FMAD,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeLine">                                      {FQNeg->getType()}, {FQNeg, FB, FA}, FQ);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1268</td>
    <td class="codeLine">                                      {FQNeg->getType()}, {FQNeg, FB, FA}, FQ);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1269</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeLine">  // int iq = (int)fq;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1270</td>
    <td class="codeLine">  // int iq = (int)fq;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeLine">  Value *IQ = IsSigned ? Builder.CreateFPToSI(FQ, I32Ty)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1271</td>
    <td class="codeLine">  Value *IQ = IsSigned ? Builder.CreateFPToSI(FQ, I32Ty)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeLine">                       : Builder.CreateFPToUI(FQ, I32Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1272</td>
    <td class="codeLine">                       : Builder.CreateFPToUI(FQ, I32Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1273</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeLine">  // fr = fabs(fr);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1274</td>
    <td class="codeLine">  // fr = fabs(fr);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeLine">  FR = Builder.CreateUnaryIntrinsic(Intrinsic::fabs, FR, FQ);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1275</td>
    <td class="codeLine">  FR = Builder.CreateUnaryIntrinsic(Intrinsic::fabs, FR, FQ);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1276</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeLine">  // fb = fabs(fb);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1277</td>
    <td class="codeLine">  // fb = fabs(fb);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeLine">  FB = Builder.CreateUnaryIntrinsic(Intrinsic::fabs, FB, FQ);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1278</td>
    <td class="codeLine">  FB = Builder.CreateUnaryIntrinsic(Intrinsic::fabs, FB, FQ);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1279</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeLine">  // int cv = fr >= fb;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1280</td>
    <td class="codeLine">  // int cv = fr >= fb;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeLine">  Value *CV = Builder.CreateFCmpOGE(FR, FB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1281</td>
    <td class="codeLine">  Value *CV = Builder.CreateFCmpOGE(FR, FB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1282</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeLine">  // jq = (cv ? jq : 0);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1283</td>
    <td class="codeLine">  // jq = (cv ? jq : 0);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeLine">  JQ = Builder.CreateSelect(CV, JQ, Builder.getInt32(0));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1284</td>
    <td class="codeLine">  JQ = Builder.CreateSelect(CV, JQ, Builder.getInt32(0));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1285</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeLine">  // dst = iq + jq;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1286</td>
    <td class="codeLine">  // dst = iq + jq;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeLine">  Value *Div = Builder.CreateAdd(IQ, JQ);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1287</td>
    <td class="codeLine">  Value *Div = Builder.CreateAdd(IQ, JQ);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1288</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeLine">  Value *Res = Div;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1289</td>
    <td class="codeLine">  Value *Res = Div;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeLine">  if (!IsDiv) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1290</td>
    <td class="codeLine">  if (!IsDiv) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeLine">    // Rem needs compensation, it's easier to recompute it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1291</td>
    <td class="codeLine">    // Rem needs compensation, it's easier to recompute it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeLine">    Value *Rem = Builder.CreateMul(Div, Den);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1292</td>
    <td class="codeLine">    Value *Rem = Builder.CreateMul(Div, Den);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeLine">    Res = Builder.CreateSub(Num, Rem);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1293</td>
    <td class="codeLine">    Res = Builder.CreateSub(Num, Rem);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1294</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1295</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeLine">  if (DivBits != 0 && DivBits < 32) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1296</td>
    <td class="codeLine">  if (DivBits != 0 && DivBits < 32) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeLine">    // Extend in register from the number of bits this divide really is.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1297</td>
    <td class="codeLine">    // Extend in register from the number of bits this divide really is.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeLine">    if (IsSigned) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1298</td>
    <td class="codeLine">    if (IsSigned) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeLine">      int InRegBits = 32 - DivBits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1299</td>
    <td class="codeLine">      int InRegBits = 32 - DivBits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1300</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeLine">      Res = Builder.CreateShl(Res, InRegBits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1301</td>
    <td class="codeLine">      Res = Builder.CreateShl(Res, InRegBits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeLine">      Res = Builder.CreateAShr(Res, InRegBits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1302</td>
    <td class="codeLine">      Res = Builder.CreateAShr(Res, InRegBits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1303</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeLine">      ConstantInt *TruncMask</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1304</td>
    <td class="codeLine">      ConstantInt *TruncMask</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeLine">        = Builder.getInt32((UINT64_C(1) << DivBits) - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1305</td>
    <td class="codeLine">        = Builder.getInt32((UINT64_C(1) << DivBits) - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeLine">      Res = Builder.CreateAnd(Res, TruncMask);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1306</td>
    <td class="codeLine">      Res = Builder.CreateAnd(Res, TruncMask);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1307</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1308</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1309</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeLine">  return Res;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1310</td>
    <td class="codeLine">  return Res;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1311</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1312</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeLine">// Try to recognize special cases the DAG will emit special, better expansions</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1313</td>
    <td class="codeLine">// Try to recognize special cases the DAG will emit special, better expansions</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeLine">// than the general expansion we do here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1314</td>
    <td class="codeLine">// than the general expansion we do here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1315</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeLine">// TODO: It would be better to just directly handle those optimizations here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1316</td>
    <td class="codeLine">// TODO: It would be better to just directly handle those optimizations here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::divHasSpecialOptimization(BinaryOperator &I,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1317</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::divHasSpecialOptimization(BinaryOperator &I,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeLine">                                                         Value *Num,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1318</td>
    <td class="codeLine">                                                         Value *Num,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeLine">                                                         Value *Den) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1319</td>
    <td class="codeLine">                                                         Value *Den) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeLine">  if (Constant *C = dyn_cast<Constant>(Den)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1320</td>
    <td class="codeLine">  if (Constant *C = dyn_cast<Constant>(Den)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeLine">    // Arbitrary constants get a better expansion as long as a wider mulhi is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1321</td>
    <td class="codeLine">    // Arbitrary constants get a better expansion as long as a wider mulhi is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeLine">    // legal.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1322</td>
    <td class="codeLine">    // legal.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeLine">    if (C->getType()->getScalarSizeInBits() <= 32)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1323</td>
    <td class="codeLine">    if (C->getType()->getScalarSizeInBits() <= 32)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1324</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1325</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeLine">    // TODO: Sdiv check for not exact for some reason.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1326</td>
    <td class="codeLine">    // TODO: Sdiv check for not exact for some reason.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1327</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeLine">    // If there's no wider mulhi, there's only a better expansion for powers of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1328</td>
    <td class="codeLine">    // If there's no wider mulhi, there's only a better expansion for powers of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeLine">    // two.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1329</td>
    <td class="codeLine">    // two.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeLine">    // TODO: Should really know for each vector element.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1330</td>
    <td class="codeLine">    // TODO: Should really know for each vector element.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeLine">    if (isKnownToBeAPowerOfTwo(C, *DL, true, 0, AC, &I, DT))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1331</td>
    <td class="codeLine">    if (isKnownToBeAPowerOfTwo(C, *DL, true, 0, AC, &I, DT))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1332</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1333</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1334</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1335</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1336</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeLine">  if (BinaryOperator *BinOpDen = dyn_cast<BinaryOperator>(Den)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1337</td>
    <td class="codeLine">  if (BinaryOperator *BinOpDen = dyn_cast<BinaryOperator>(Den)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeLine">    // fold (udiv x, (shl c, y)) -> x >>u (log2(c)+y) iff c is power of 2</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1338</td>
    <td class="codeLine">    // fold (udiv x, (shl c, y)) -> x >>u (log2(c)+y) iff c is power of 2</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeLine">    if (BinOpDen->getOpcode() == Instruction::Shl &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1339</td>
    <td class="codeLine">    if (BinOpDen->getOpcode() == Instruction::Shl &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeLine">        isa<Constant>(BinOpDen->getOperand(0)) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1340</td>
    <td class="codeLine">        isa<Constant>(BinOpDen->getOperand(0)) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeLine">        isKnownToBeAPowerOfTwo(BinOpDen->getOperand(0), *DL, true,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1341</td>
    <td class="codeLine">        isKnownToBeAPowerOfTwo(BinOpDen->getOperand(0), *DL, true,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeLine">                               0, AC, &I, DT)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1342</td>
    <td class="codeLine">                               0, AC, &I, DT)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1343</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1344</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1345</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1346</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1347</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1348</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1349</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeLine">static Value *getSign32(Value *V, IRBuilder<> &Builder, const DataLayout *DL) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1350</td>
    <td class="codeLine">static Value *getSign32(Value *V, IRBuilder<> &Builder, const DataLayout *DL) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeLine">  // Check whether the sign can be determined statically.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1351</td>
    <td class="codeLine">  // Check whether the sign can be determined statically.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeLine">  KnownBits Known = computeKnownBits(V, *DL);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1352</td>
    <td class="codeLine">  KnownBits Known = computeKnownBits(V, *DL);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeLine">  if (Known.isNegative())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1353</td>
    <td class="codeLine">  if (Known.isNegative())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeLine">    return Constant::getAllOnesValue(V->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1354</td>
    <td class="codeLine">    return Constant::getAllOnesValue(V->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeLine">  if (Known.isNonNegative())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1355</td>
    <td class="codeLine">  if (Known.isNonNegative())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeLine">    return Constant::getNullValue(V->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1356</td>
    <td class="codeLine">    return Constant::getNullValue(V->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeLine">  return Builder.CreateAShr(V, Builder.getInt32(31));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1357</td>
    <td class="codeLine">  return Builder.CreateAShr(V, Builder.getInt32(31));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1358</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1359</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeLine">Value *AMDGPUCodeGenPrepareImpl::expandDivRem32(IRBuilder<> &Builder,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1360</td>
    <td class="codeLine">Value *AMDGPUCodeGenPrepareImpl::expandDivRem32(IRBuilder<> &Builder,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeLine">                                                BinaryOperator &I, Value *X,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1361</td>
    <td class="codeLine">                                                BinaryOperator &I, Value *X,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeLine">                                                Value *Y) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1362</td>
    <td class="codeLine">                                                Value *Y) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeLine">  Instruction::BinaryOps Opc = I.getOpcode();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1363</td>
    <td class="codeLine">  Instruction::BinaryOps Opc = I.getOpcode();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeLine">  assert(Opc == Instruction::URem || Opc == Instruction::UDiv ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1364</td>
    <td class="codeLine">  assert(Opc == Instruction::URem || Opc == Instruction::UDiv ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeLine">         Opc == Instruction::SRem || Opc == Instruction::SDiv);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1365</td>
    <td class="codeLine">         Opc == Instruction::SRem || Opc == Instruction::SDiv);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1366</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeLine">  FastMathFlags FMF;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1367</td>
    <td class="codeLine">  FastMathFlags FMF;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeLine">  FMF.setFast();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1368</td>
    <td class="codeLine">  FMF.setFast();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeLine">  Builder.setFastMathFlags(FMF);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1369</td>
    <td class="codeLine">  Builder.setFastMathFlags(FMF);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1370</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeLine">  if (divHasSpecialOptimization(I, X, Y))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1371</td>
    <td class="codeLine">  if (divHasSpecialOptimization(I, X, Y))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeLine">    return nullptr;  // Keep it for later optimization.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1372</td>
    <td class="codeLine">    return nullptr;  // Keep it for later optimization.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1373</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeLine">  bool IsDiv = Opc == Instruction::UDiv || Opc == Instruction::SDiv;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1374</td>
    <td class="codeLine">  bool IsDiv = Opc == Instruction::UDiv || Opc == Instruction::SDiv;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeLine">  bool IsSigned = Opc == Instruction::SRem || Opc == Instruction::SDiv;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1375</td>
    <td class="codeLine">  bool IsSigned = Opc == Instruction::SRem || Opc == Instruction::SDiv;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1376</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeLine">  Type *Ty = X->getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1377</td>
    <td class="codeLine">  Type *Ty = X->getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeLine">  Type *I32Ty = Builder.getInt32Ty();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1378</td>
    <td class="codeLine">  Type *I32Ty = Builder.getInt32Ty();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeLine">  Type *F32Ty = Builder.getFloatTy();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1379</td>
    <td class="codeLine">  Type *F32Ty = Builder.getFloatTy();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1380</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeLine">  if (Ty->getScalarSizeInBits() < 32) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1381</td>
    <td class="codeLine">  if (Ty->getScalarSizeInBits() < 32) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeLine">    if (IsSigned) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1382</td>
    <td class="codeLine">    if (IsSigned) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeLine">      X = Builder.CreateSExt(X, I32Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1383</td>
    <td class="codeLine">      X = Builder.CreateSExt(X, I32Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeLine">      Y = Builder.CreateSExt(Y, I32Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1384</td>
    <td class="codeLine">      Y = Builder.CreateSExt(Y, I32Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1385</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeLine">      X = Builder.CreateZExt(X, I32Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1386</td>
    <td class="codeLine">      X = Builder.CreateZExt(X, I32Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeLine">      Y = Builder.CreateZExt(Y, I32Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1387</td>
    <td class="codeLine">      Y = Builder.CreateZExt(Y, I32Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1388</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1389</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1390</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeLine">  if (Value *Res = expandDivRem24(Builder, I, X, Y, IsDiv, IsSigned)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1391</td>
    <td class="codeLine">  if (Value *Res = expandDivRem24(Builder, I, X, Y, IsDiv, IsSigned)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeLine">    return IsSigned ? Builder.CreateSExtOrTrunc(Res, Ty) :</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1392</td>
    <td class="codeLine">    return IsSigned ? Builder.CreateSExtOrTrunc(Res, Ty) :</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeLine">                      Builder.CreateZExtOrTrunc(Res, Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1393</td>
    <td class="codeLine">                      Builder.CreateZExtOrTrunc(Res, Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1394</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1395</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeLine">  ConstantInt *Zero = Builder.getInt32(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1396</td>
    <td class="codeLine">  ConstantInt *Zero = Builder.getInt32(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeLine">  ConstantInt *One = Builder.getInt32(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1397</td>
    <td class="codeLine">  ConstantInt *One = Builder.getInt32(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1398</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeLine">  Value *Sign = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1399</td>
    <td class="codeLine">  Value *Sign = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeLine">  if (IsSigned) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1400</td>
    <td class="codeLine">  if (IsSigned) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeLine">    Value *SignX = getSign32(X, Builder, DL);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1401</td>
    <td class="codeLine">    Value *SignX = getSign32(X, Builder, DL);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeLine">    Value *SignY = getSign32(Y, Builder, DL);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1402</td>
    <td class="codeLine">    Value *SignY = getSign32(Y, Builder, DL);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeLine">    // Remainder sign is the same as LHS</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1403</td>
    <td class="codeLine">    // Remainder sign is the same as LHS</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeLine">    Sign = IsDiv ? Builder.CreateXor(SignX, SignY) : SignX;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1404</td>
    <td class="codeLine">    Sign = IsDiv ? Builder.CreateXor(SignX, SignY) : SignX;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1405</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeLine">    X = Builder.CreateAdd(X, SignX);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1406</td>
    <td class="codeLine">    X = Builder.CreateAdd(X, SignX);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeLine">    Y = Builder.CreateAdd(Y, SignY);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1407</td>
    <td class="codeLine">    Y = Builder.CreateAdd(Y, SignY);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1408</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeLine">    X = Builder.CreateXor(X, SignX);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1409</td>
    <td class="codeLine">    X = Builder.CreateXor(X, SignX);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeLine">    Y = Builder.CreateXor(Y, SignY);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1410</td>
    <td class="codeLine">    Y = Builder.CreateXor(Y, SignY);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1411</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1412</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeLine">  // The algorithm here is based on ideas from "Software Integer Division", Tom</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1413</td>
    <td class="codeLine">  // The algorithm here is based on ideas from "Software Integer Division", Tom</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeLine">  // Rodeheffer, August 2008.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1414</td>
    <td class="codeLine">  // Rodeheffer, August 2008.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1415</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeLine">  // unsigned udiv(unsigned x, unsigned y) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1416</td>
    <td class="codeLine">  // unsigned udiv(unsigned x, unsigned y) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeLine">  //   // Initial estimate of inv(y). The constant is less than 2^32 to ensure</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1417</td>
    <td class="codeLine">  //   // Initial estimate of inv(y). The constant is less than 2^32 to ensure</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeLine">  //   // that this is a lower bound on inv(y), even if some of the calculations</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1418</td>
    <td class="codeLine">  //   // that this is a lower bound on inv(y), even if some of the calculations</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeLine">  //   // round up.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1419</td>
    <td class="codeLine">  //   // round up.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeLine">  //   unsigned z = (unsigned)((4294967296.0 - 512.0) * v_rcp_f32((float)y));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1420</td>
    <td class="codeLine">  //   unsigned z = (unsigned)((4294967296.0 - 512.0) * v_rcp_f32((float)y));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1421</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeLine">  //   // One round of UNR (Unsigned integer Newton-Raphson) to improve z.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1422</td>
    <td class="codeLine">  //   // One round of UNR (Unsigned integer Newton-Raphson) to improve z.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeLine">  //   // Empirically this is guaranteed to give a "two-y" lower bound on</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1423</td>
    <td class="codeLine">  //   // Empirically this is guaranteed to give a "two-y" lower bound on</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeLine">  //   // inv(y).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1424</td>
    <td class="codeLine">  //   // inv(y).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeLine">  //   z += umulh(z, -y * z);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1425</td>
    <td class="codeLine">  //   z += umulh(z, -y * z);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1426</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeLine">  //   // Quotient/remainder estimate.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1427</td>
    <td class="codeLine">  //   // Quotient/remainder estimate.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeLine">  //   unsigned q = umulh(x, z);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1428</td>
    <td class="codeLine">  //   unsigned q = umulh(x, z);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeLine">  //   unsigned r = x - q * y;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1429</td>
    <td class="codeLine">  //   unsigned r = x - q * y;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1430</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeLine">  //   // Two rounds of quotient/remainder refinement.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1431</td>
    <td class="codeLine">  //   // Two rounds of quotient/remainder refinement.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeLine">  //   if (r >= y) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1432</td>
    <td class="codeLine">  //   if (r >= y) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeLine">  //     ++q;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1433</td>
    <td class="codeLine">  //     ++q;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeLine">  //     r -= y;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1434</td>
    <td class="codeLine">  //     r -= y;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeLine">  //   }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1435</td>
    <td class="codeLine">  //   }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeLine">  //   if (r >= y) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1436</td>
    <td class="codeLine">  //   if (r >= y) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeLine">  //     ++q;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1437</td>
    <td class="codeLine">  //     ++q;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeLine">  //     r -= y;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1438</td>
    <td class="codeLine">  //     r -= y;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeLine">  //   }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1439</td>
    <td class="codeLine">  //   }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1440</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeLine">  //   return q;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1441</td>
    <td class="codeLine">  //   return q;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeLine">  // }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1442</td>
    <td class="codeLine">  // }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1443</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeLine">  // Initial estimate of inv(y).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1444</td>
    <td class="codeLine">  // Initial estimate of inv(y).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeLine">  Value *FloatY = Builder.CreateUIToFP(Y, F32Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1445</td>
    <td class="codeLine">  Value *FloatY = Builder.CreateUIToFP(Y, F32Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeLine">  Function *Rcp = Intrinsic::getDeclaration(Mod, Intrinsic::amdgcn_rcp, F32Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1446</td>
    <td class="codeLine">  Function *Rcp = Intrinsic::getDeclaration(Mod, Intrinsic::amdgcn_rcp, F32Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeLine">  Value *RcpY = Builder.CreateCall(Rcp, {FloatY});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1447</td>
    <td class="codeLine">  Value *RcpY = Builder.CreateCall(Rcp, {FloatY});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeLine">  Constant *Scale = ConstantFP::get(F32Ty, llvm::bit_cast<float>(0x4F7FFFFE));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1448</td>
    <td class="codeLine">  Constant *Scale = ConstantFP::get(F32Ty, llvm::bit_cast<float>(0x4F7FFFFE));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeLine">  Value *ScaledY = Builder.CreateFMul(RcpY, Scale);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1449</td>
    <td class="codeLine">  Value *ScaledY = Builder.CreateFMul(RcpY, Scale);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeLine">  Value *Z = Builder.CreateFPToUI(ScaledY, I32Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1450</td>
    <td class="codeLine">  Value *Z = Builder.CreateFPToUI(ScaledY, I32Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1451</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeLine">  // One round of UNR.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1452</td>
    <td class="codeLine">  // One round of UNR.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeLine">  Value *NegY = Builder.CreateSub(Zero, Y);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1453</td>
    <td class="codeLine">  Value *NegY = Builder.CreateSub(Zero, Y);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeLine">  Value *NegYZ = Builder.CreateMul(NegY, Z);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1454</td>
    <td class="codeLine">  Value *NegYZ = Builder.CreateMul(NegY, Z);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeLine">  Z = Builder.CreateAdd(Z, getMulHu(Builder, Z, NegYZ));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1455</td>
    <td class="codeLine">  Z = Builder.CreateAdd(Z, getMulHu(Builder, Z, NegYZ));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1456</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeLine">  // Quotient/remainder estimate.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1457</td>
    <td class="codeLine">  // Quotient/remainder estimate.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeLine">  Value *Q = getMulHu(Builder, X, Z);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1458</td>
    <td class="codeLine">  Value *Q = getMulHu(Builder, X, Z);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeLine">  Value *R = Builder.CreateSub(X, Builder.CreateMul(Q, Y));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1459</td>
    <td class="codeLine">  Value *R = Builder.CreateSub(X, Builder.CreateMul(Q, Y));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1460</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeLine">  // First quotient/remainder refinement.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1461</td>
    <td class="codeLine">  // First quotient/remainder refinement.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeLine">  Value *Cond = Builder.CreateICmpUGE(R, Y);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1462</td>
    <td class="codeLine">  Value *Cond = Builder.CreateICmpUGE(R, Y);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeLine">  if (IsDiv)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1463</td>
    <td class="codeLine">  if (IsDiv)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeLine">    Q = Builder.CreateSelect(Cond, Builder.CreateAdd(Q, One), Q);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1464</td>
    <td class="codeLine">    Q = Builder.CreateSelect(Cond, Builder.CreateAdd(Q, One), Q);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeLine">  R = Builder.CreateSelect(Cond, Builder.CreateSub(R, Y), R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1465</td>
    <td class="codeLine">  R = Builder.CreateSelect(Cond, Builder.CreateSub(R, Y), R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1466</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeLine">  // Second quotient/remainder refinement.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1467</td>
    <td class="codeLine">  // Second quotient/remainder refinement.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeLine">  Cond = Builder.CreateICmpUGE(R, Y);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1468</td>
    <td class="codeLine">  Cond = Builder.CreateICmpUGE(R, Y);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeLine">  Value *Res;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1469</td>
    <td class="codeLine">  Value *Res;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeLine">  if (IsDiv)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1470</td>
    <td class="codeLine">  if (IsDiv)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeLine">    Res = Builder.CreateSelect(Cond, Builder.CreateAdd(Q, One), Q);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1471</td>
    <td class="codeLine">    Res = Builder.CreateSelect(Cond, Builder.CreateAdd(Q, One), Q);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1472</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeLine">    Res = Builder.CreateSelect(Cond, Builder.CreateSub(R, Y), R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1473</td>
    <td class="codeLine">    Res = Builder.CreateSelect(Cond, Builder.CreateSub(R, Y), R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1474</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeLine">  if (IsSigned) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1475</td>
    <td class="codeLine">  if (IsSigned) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeLine">    Res = Builder.CreateXor(Res, Sign);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1476</td>
    <td class="codeLine">    Res = Builder.CreateXor(Res, Sign);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeLine">    Res = Builder.CreateSub(Res, Sign);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1477</td>
    <td class="codeLine">    Res = Builder.CreateSub(Res, Sign);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1478</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1479</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeLine">  Res = Builder.CreateTrunc(Res, Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1480</td>
    <td class="codeLine">  Res = Builder.CreateTrunc(Res, Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1481</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeLine">  return Res;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1482</td>
    <td class="codeLine">  return Res;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1483</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1484</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeLine">Value *AMDGPUCodeGenPrepareImpl::shrinkDivRem64(IRBuilder<> &Builder,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1485</td>
    <td class="codeLine">Value *AMDGPUCodeGenPrepareImpl::shrinkDivRem64(IRBuilder<> &Builder,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeLine">                                                BinaryOperator &I, Value *Num,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1486</td>
    <td class="codeLine">                                                BinaryOperator &I, Value *Num,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeLine">                                                Value *Den) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1487</td>
    <td class="codeLine">                                                Value *Den) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeLine">  if (!ExpandDiv64InIR && divHasSpecialOptimization(I, Num, Den))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1488</td>
    <td class="codeLine">  if (!ExpandDiv64InIR && divHasSpecialOptimization(I, Num, Den))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeLine">    return nullptr;  // Keep it for later optimization.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1489</td>
    <td class="codeLine">    return nullptr;  // Keep it for later optimization.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1490</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeLine">  Instruction::BinaryOps Opc = I.getOpcode();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1491</td>
    <td class="codeLine">  Instruction::BinaryOps Opc = I.getOpcode();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1492</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeLine">  bool IsDiv = Opc == Instruction::SDiv || Opc == Instruction::UDiv;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1493</td>
    <td class="codeLine">  bool IsDiv = Opc == Instruction::SDiv || Opc == Instruction::UDiv;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeLine">  bool IsSigned = Opc == Instruction::SDiv || Opc == Instruction::SRem;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1494</td>
    <td class="codeLine">  bool IsSigned = Opc == Instruction::SDiv || Opc == Instruction::SRem;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1495</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeLine">  int NumDivBits = getDivNumBits(I, Num, Den, 32, IsSigned);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1496</td>
    <td class="codeLine">  int NumDivBits = getDivNumBits(I, Num, Den, 32, IsSigned);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeLine">  if (NumDivBits == -1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1497</td>
    <td class="codeLine">  if (NumDivBits == -1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1498</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1499</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeLine">  Value *Narrowed = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1500</td>
    <td class="codeLine">  Value *Narrowed = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeLine">  if (NumDivBits <= 24) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1501</td>
    <td class="codeLine">  if (NumDivBits <= 24) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeLine">    Narrowed = expandDivRem24Impl(Builder, I, Num, Den, NumDivBits,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1502</td>
    <td class="codeLine">    Narrowed = expandDivRem24Impl(Builder, I, Num, Den, NumDivBits,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeLine">                                  IsDiv, IsSigned);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1503</td>
    <td class="codeLine">                                  IsDiv, IsSigned);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeLine">  } else if (NumDivBits <= 32) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1504</td>
    <td class="codeLine">  } else if (NumDivBits <= 32) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeLine">    Narrowed = expandDivRem32(Builder, I, Num, Den);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1505</td>
    <td class="codeLine">    Narrowed = expandDivRem32(Builder, I, Num, Den);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1506</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1507</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeLine">  if (Narrowed) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1508</td>
    <td class="codeLine">  if (Narrowed) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeLine">    return IsSigned ? Builder.CreateSExt(Narrowed, Num->getType()) :</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1509</td>
    <td class="codeLine">    return IsSigned ? Builder.CreateSExt(Narrowed, Num->getType()) :</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeLine">                      Builder.CreateZExt(Narrowed, Num->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1510</td>
    <td class="codeLine">                      Builder.CreateZExt(Narrowed, Num->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1511</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1512</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1513</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1514</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1515</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeLine">void AMDGPUCodeGenPrepareImpl::expandDivRem64(BinaryOperator &I) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1516</td>
    <td class="codeLine">void AMDGPUCodeGenPrepareImpl::expandDivRem64(BinaryOperator &I) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeLine">  Instruction::BinaryOps Opc = I.getOpcode();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1517</td>
    <td class="codeLine">  Instruction::BinaryOps Opc = I.getOpcode();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeLine">  // Do the general expansion.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1518</td>
    <td class="codeLine">  // Do the general expansion.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeLine">  if (Opc == Instruction::UDiv || Opc == Instruction::SDiv) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1519</td>
    <td class="codeLine">  if (Opc == Instruction::UDiv || Opc == Instruction::SDiv) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeLine">    expandDivisionUpTo64Bits(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1520</td>
    <td class="codeLine">    expandDivisionUpTo64Bits(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1521</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1522</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1523</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeLine">  if (Opc == Instruction::URem || Opc == Instruction::SRem) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1524</td>
    <td class="codeLine">  if (Opc == Instruction::URem || Opc == Instruction::SRem) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeLine">    expandRemainderUpTo64Bits(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1525</td>
    <td class="codeLine">    expandRemainderUpTo64Bits(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1526</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1527</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1528</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeLine">  llvm_unreachable("not a division");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1529</td>
    <td class="codeLine">  llvm_unreachable("not a division");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1530</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1531</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::visitBinaryOperator(BinaryOperator &I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1532</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::visitBinaryOperator(BinaryOperator &I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeLine">  if (foldBinOpIntoSelect(I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1533</td>
    <td class="codeLine">  if (foldBinOpIntoSelect(I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1534</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1535</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeLine">  if (ST->has16BitInsts() && needsPromotionToI32(I.getType()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1536</td>
    <td class="codeLine">  if (ST->has16BitInsts() && needsPromotionToI32(I.getType()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeLine">      UA->isUniform(&I) && promoteUniformOpToI32(I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1537</td>
    <td class="codeLine">      UA->isUniform(&I) && promoteUniformOpToI32(I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1538</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1539</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeLine">  if (UseMul24Intrin && replaceMulWithMul24(I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1540</td>
    <td class="codeLine">  if (UseMul24Intrin && replaceMulWithMul24(I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1541</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1542</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1543</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeLine">  Instruction::BinaryOps Opc = I.getOpcode();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1544</td>
    <td class="codeLine">  Instruction::BinaryOps Opc = I.getOpcode();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeLine">  Type *Ty = I.getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1545</td>
    <td class="codeLine">  Type *Ty = I.getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeLine">  Value *NewDiv = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1546</td>
    <td class="codeLine">  Value *NewDiv = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeLine">  unsigned ScalarSize = Ty->getScalarSizeInBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1547</td>
    <td class="codeLine">  unsigned ScalarSize = Ty->getScalarSizeInBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1548</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeLine">  SmallVector<BinaryOperator *, 8> Div64ToExpand;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1549</td>
    <td class="codeLine">  SmallVector<BinaryOperator *, 8> Div64ToExpand;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1550</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeLine">  if ((Opc == Instruction::URem || Opc == Instruction::UDiv ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1551</td>
    <td class="codeLine">  if ((Opc == Instruction::URem || Opc == Instruction::UDiv ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeLine">       Opc == Instruction::SRem || Opc == Instruction::SDiv) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1552</td>
    <td class="codeLine">       Opc == Instruction::SRem || Opc == Instruction::SDiv) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeLine">      ScalarSize <= 64 &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1553</td>
    <td class="codeLine">      ScalarSize <= 64 &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeLine">      !DisableIDivExpand) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1554</td>
    <td class="codeLine">      !DisableIDivExpand) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeLine">    Value *Num = I.getOperand(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1555</td>
    <td class="codeLine">    Value *Num = I.getOperand(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeLine">    Value *Den = I.getOperand(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1556</td>
    <td class="codeLine">    Value *Den = I.getOperand(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeLine">    IRBuilder<> Builder(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1557</td>
    <td class="codeLine">    IRBuilder<> Builder(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeLine">    Builder.SetCurrentDebugLocation(I.getDebugLoc());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1558</td>
    <td class="codeLine">    Builder.SetCurrentDebugLocation(I.getDebugLoc());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1559</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeLine">    if (auto *VT = dyn_cast<FixedVectorType>(Ty)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1560</td>
    <td class="codeLine">    if (auto *VT = dyn_cast<FixedVectorType>(Ty)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeLine">      NewDiv = PoisonValue::get(VT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1561</td>
    <td class="codeLine">      NewDiv = PoisonValue::get(VT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1562</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeLine">      for (unsigned N = 0, E = VT->getNumElements(); N != E; ++N) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1563</td>
    <td class="codeLine">      for (unsigned N = 0, E = VT->getNumElements(); N != E; ++N) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeLine">        Value *NumEltN = Builder.CreateExtractElement(Num, N);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1564</td>
    <td class="codeLine">        Value *NumEltN = Builder.CreateExtractElement(Num, N);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeLine">        Value *DenEltN = Builder.CreateExtractElement(Den, N);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1565</td>
    <td class="codeLine">        Value *DenEltN = Builder.CreateExtractElement(Den, N);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1566</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeLine">        Value *NewElt;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1567</td>
    <td class="codeLine">        Value *NewElt;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeLine">        if (ScalarSize <= 32) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1568</td>
    <td class="codeLine">        if (ScalarSize <= 32) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeLine">          NewElt = expandDivRem32(Builder, I, NumEltN, DenEltN);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1569</td>
    <td class="codeLine">          NewElt = expandDivRem32(Builder, I, NumEltN, DenEltN);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeLine">          if (!NewElt)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1570</td>
    <td class="codeLine">          if (!NewElt)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeLine">            NewElt = Builder.CreateBinOp(Opc, NumEltN, DenEltN);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1571</td>
    <td class="codeLine">            NewElt = Builder.CreateBinOp(Opc, NumEltN, DenEltN);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeLine">        } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1572</td>
    <td class="codeLine">        } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeLine">          // See if this 64-bit division can be shrunk to 32/24-bits before</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1573</td>
    <td class="codeLine">          // See if this 64-bit division can be shrunk to 32/24-bits before</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeLine">          // producing the general expansion.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1574</td>
    <td class="codeLine">          // producing the general expansion.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeLine">          NewElt = shrinkDivRem64(Builder, I, NumEltN, DenEltN);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1575</td>
    <td class="codeLine">          NewElt = shrinkDivRem64(Builder, I, NumEltN, DenEltN);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeLine">          if (!NewElt) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1576</td>
    <td class="codeLine">          if (!NewElt) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeLine">            // The general 64-bit expansion introduces control flow and doesn't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1577</td>
    <td class="codeLine">            // The general 64-bit expansion introduces control flow and doesn't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeLine">            // return the new value. Just insert a scalar copy and defer</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1578</td>
    <td class="codeLine">            // return the new value. Just insert a scalar copy and defer</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeLine">            // expanding it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1579</td>
    <td class="codeLine">            // expanding it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeLine">            NewElt = Builder.CreateBinOp(Opc, NumEltN, DenEltN);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1580</td>
    <td class="codeLine">            NewElt = Builder.CreateBinOp(Opc, NumEltN, DenEltN);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeLine">            Div64ToExpand.push_back(cast<BinaryOperator>(NewElt));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1581</td>
    <td class="codeLine">            Div64ToExpand.push_back(cast<BinaryOperator>(NewElt));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1582</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1583</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1584</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeLine">        NewDiv = Builder.CreateInsertElement(NewDiv, NewElt, N);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1585</td>
    <td class="codeLine">        NewDiv = Builder.CreateInsertElement(NewDiv, NewElt, N);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1586</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1587</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeLine">      if (ScalarSize <= 32)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1588</td>
    <td class="codeLine">      if (ScalarSize <= 32)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeLine">        NewDiv = expandDivRem32(Builder, I, Num, Den);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1589</td>
    <td class="codeLine">        NewDiv = expandDivRem32(Builder, I, Num, Den);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeLine">      else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1590</td>
    <td class="codeLine">      else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeLine">        NewDiv = shrinkDivRem64(Builder, I, Num, Den);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1591</td>
    <td class="codeLine">        NewDiv = shrinkDivRem64(Builder, I, Num, Den);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeLine">        if (!NewDiv)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1592</td>
    <td class="codeLine">        if (!NewDiv)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeLine">          Div64ToExpand.push_back(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1593</td>
    <td class="codeLine">          Div64ToExpand.push_back(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1594</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1595</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1596</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeLine">    if (NewDiv) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1597</td>
    <td class="codeLine">    if (NewDiv) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeLine">      I.replaceAllUsesWith(NewDiv);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1598</td>
    <td class="codeLine">      I.replaceAllUsesWith(NewDiv);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeLine">      I.eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1599</td>
    <td class="codeLine">      I.eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeLine">      Changed = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1600</td>
    <td class="codeLine">      Changed = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1601</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1602</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1603</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeLine">  if (ExpandDiv64InIR) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1604</td>
    <td class="codeLine">  if (ExpandDiv64InIR) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeLine">    // TODO: We get much worse code in specially handled constant cases.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1605</td>
    <td class="codeLine">    // TODO: We get much worse code in specially handled constant cases.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeLine">    for (BinaryOperator *Div : Div64ToExpand) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1606</td>
    <td class="codeLine">    for (BinaryOperator *Div : Div64ToExpand) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeLine">      expandDivRem64(*Div);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1607</td>
    <td class="codeLine">      expandDivRem64(*Div);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeLine">      FlowChanged = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1608</td>
    <td class="codeLine">      FlowChanged = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeLine">      Changed = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1609</td>
    <td class="codeLine">      Changed = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1610</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1611</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1612</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1613</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1614</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1615</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::visitLoadInst(LoadInst &I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1616</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::visitLoadInst(LoadInst &I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeLine">  if (!WidenLoads)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1617</td>
    <td class="codeLine">  if (!WidenLoads)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1618</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1619</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeLine">  if ((I.getPointerAddressSpace() == AMDGPUAS::CONSTANT_ADDRESS ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1620</td>
    <td class="codeLine">  if ((I.getPointerAddressSpace() == AMDGPUAS::CONSTANT_ADDRESS ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeLine">       I.getPointerAddressSpace() == AMDGPUAS::CONSTANT_ADDRESS_32BIT) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1621</td>
    <td class="codeLine">       I.getPointerAddressSpace() == AMDGPUAS::CONSTANT_ADDRESS_32BIT) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeLine">      canWidenScalarExtLoad(I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1622</td>
    <td class="codeLine">      canWidenScalarExtLoad(I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeLine">    IRBuilder<> Builder(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1623</td>
    <td class="codeLine">    IRBuilder<> Builder(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeLine">    Builder.SetCurrentDebugLocation(I.getDebugLoc());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1624</td>
    <td class="codeLine">    Builder.SetCurrentDebugLocation(I.getDebugLoc());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1625</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeLine">    Type *I32Ty = Builder.getInt32Ty();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1626</td>
    <td class="codeLine">    Type *I32Ty = Builder.getInt32Ty();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeLine">    LoadInst *WidenLoad = Builder.CreateLoad(I32Ty, I.getPointerOperand());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1627</td>
    <td class="codeLine">    LoadInst *WidenLoad = Builder.CreateLoad(I32Ty, I.getPointerOperand());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeLine">    WidenLoad->copyMetadata(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1628</td>
    <td class="codeLine">    WidenLoad->copyMetadata(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1629</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeLine">    // If we have range metadata, we need to convert the type, and not make</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1630</td>
    <td class="codeLine">    // If we have range metadata, we need to convert the type, and not make</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeLine">    // assumptions about the high bits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1631</td>
    <td class="codeLine">    // assumptions about the high bits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeLine">    if (auto *Range = WidenLoad->getMetadata(LLVMContext::MD_range)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1632</td>
    <td class="codeLine">    if (auto *Range = WidenLoad->getMetadata(LLVMContext::MD_range)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeLine">      ConstantInt *Lower =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1633</td>
    <td class="codeLine">      ConstantInt *Lower =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeLine">        mdconst::extract<ConstantInt>(Range->getOperand(0));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1634</td>
    <td class="codeLine">        mdconst::extract<ConstantInt>(Range->getOperand(0));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1635</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeLine">      if (Lower->isNullValue()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1636</td>
    <td class="codeLine">      if (Lower->isNullValue()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeLine">        WidenLoad->setMetadata(LLVMContext::MD_range, nullptr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1637</td>
    <td class="codeLine">        WidenLoad->setMetadata(LLVMContext::MD_range, nullptr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1638</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeLine">        Metadata *LowAndHigh[] = {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1639</td>
    <td class="codeLine">        Metadata *LowAndHigh[] = {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeLine">          ConstantAsMetadata::get(ConstantInt::get(I32Ty, Lower->getValue().zext(32))),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1640</td>
    <td class="codeLine">          ConstantAsMetadata::get(ConstantInt::get(I32Ty, Lower->getValue().zext(32))),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeLine">          // Don't make assumptions about the high bits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1641</td>
    <td class="codeLine">          // Don't make assumptions about the high bits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeLine">          ConstantAsMetadata::get(ConstantInt::get(I32Ty, 0))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1642</td>
    <td class="codeLine">          ConstantAsMetadata::get(ConstantInt::get(I32Ty, 0))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeLine">        };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1643</td>
    <td class="codeLine">        };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1644</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeLine">        WidenLoad->setMetadata(LLVMContext::MD_range,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1645</td>
    <td class="codeLine">        WidenLoad->setMetadata(LLVMContext::MD_range,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeLine">                               MDNode::get(Mod->getContext(), LowAndHigh));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1646</td>
    <td class="codeLine">                               MDNode::get(Mod->getContext(), LowAndHigh));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1647</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1648</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1649</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeLine">    int TySize = Mod->getDataLayout().getTypeSizeInBits(I.getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1650</td>
    <td class="codeLine">    int TySize = Mod->getDataLayout().getTypeSizeInBits(I.getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeLine">    Type *IntNTy = Builder.getIntNTy(TySize);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1651</td>
    <td class="codeLine">    Type *IntNTy = Builder.getIntNTy(TySize);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeLine">    Value *ValTrunc = Builder.CreateTrunc(WidenLoad, IntNTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1652</td>
    <td class="codeLine">    Value *ValTrunc = Builder.CreateTrunc(WidenLoad, IntNTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeLine">    Value *ValOrig = Builder.CreateBitCast(ValTrunc, I.getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1653</td>
    <td class="codeLine">    Value *ValOrig = Builder.CreateBitCast(ValTrunc, I.getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeLine">    I.replaceAllUsesWith(ValOrig);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1654</td>
    <td class="codeLine">    I.replaceAllUsesWith(ValOrig);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeLine">    I.eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1655</td>
    <td class="codeLine">    I.eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1656</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1657</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1658</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1659</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1660</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1661</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::visitICmpInst(ICmpInst &I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1662</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::visitICmpInst(ICmpInst &I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1663</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1664</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeLine">  if (ST->has16BitInsts() && needsPromotionToI32(I.getOperand(0)->getType()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1665</td>
    <td class="codeLine">  if (ST->has16BitInsts() && needsPromotionToI32(I.getOperand(0)->getType()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeLine">      UA->isUniform(&I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1666</td>
    <td class="codeLine">      UA->isUniform(&I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeLine">    Changed |= promoteUniformOpToI32(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1667</td>
    <td class="codeLine">    Changed |= promoteUniformOpToI32(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1668</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1669</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1670</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1671</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::visitSelectInst(SelectInst &I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1672</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::visitSelectInst(SelectInst &I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeLine">  Value *Cond = I.getCondition();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1673</td>
    <td class="codeLine">  Value *Cond = I.getCondition();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeLine">  Value *TrueVal = I.getTrueValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1674</td>
    <td class="codeLine">  Value *TrueVal = I.getTrueValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeLine">  Value *FalseVal = I.getFalseValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1675</td>
    <td class="codeLine">  Value *FalseVal = I.getFalseValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeLine">  Value *CmpVal;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1676</td>
    <td class="codeLine">  Value *CmpVal;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeLine">  FCmpInst::Predicate Pred;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1677</td>
    <td class="codeLine">  FCmpInst::Predicate Pred;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1678</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeLine">  if (ST->has16BitInsts() && needsPromotionToI32(I.getType())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1679</td>
    <td class="codeLine">  if (ST->has16BitInsts() && needsPromotionToI32(I.getType())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeLine">    if (UA->isUniform(&I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1680</td>
    <td class="codeLine">    if (UA->isUniform(&I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeLine">      return promoteUniformOpToI32(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1681</td>
    <td class="codeLine">      return promoteUniformOpToI32(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1682</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1683</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1684</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeLine">  // Match fract pattern with nan check.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1685</td>
    <td class="codeLine">  // Match fract pattern with nan check.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeLine">  if (!match(Cond, m_FCmp(Pred, m_Value(CmpVal), m_NonNaN())))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1686</td>
    <td class="codeLine">  if (!match(Cond, m_FCmp(Pred, m_Value(CmpVal), m_NonNaN())))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1687</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1688</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeLine">  FPMathOperator *FPOp = dyn_cast<FPMathOperator>(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1689</td>
    <td class="codeLine">  FPMathOperator *FPOp = dyn_cast<FPMathOperator>(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeLine">  if (!FPOp)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1690</td>
    <td class="codeLine">  if (!FPOp)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1691</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1692</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeLine">  IRBuilder<> Builder(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1693</td>
    <td class="codeLine">  IRBuilder<> Builder(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeLine">  Builder.setFastMathFlags(FPOp->getFastMathFlags());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1694</td>
    <td class="codeLine">  Builder.setFastMathFlags(FPOp->getFastMathFlags());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1695</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeLine">  auto *IITrue = dyn_cast<IntrinsicInst>(TrueVal);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1696</td>
    <td class="codeLine">  auto *IITrue = dyn_cast<IntrinsicInst>(TrueVal);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeLine">  auto *IIFalse = dyn_cast<IntrinsicInst>(FalseVal);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1697</td>
    <td class="codeLine">  auto *IIFalse = dyn_cast<IntrinsicInst>(FalseVal);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1698</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeLine">  Value *Fract = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1699</td>
    <td class="codeLine">  Value *Fract = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeLine">  if (Pred == FCmpInst::FCMP_UNO && TrueVal == CmpVal && IIFalse &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1700</td>
    <td class="codeLine">  if (Pred == FCmpInst::FCMP_UNO && TrueVal == CmpVal && IIFalse &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeLine">      CmpVal == matchFractPat(*IIFalse)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1701</td>
    <td class="codeLine">      CmpVal == matchFractPat(*IIFalse)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeLine">    // isnan(x) ? x : fract(x)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1702</td>
    <td class="codeLine">    // isnan(x) ? x : fract(x)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeLine">    Fract = applyFractPat(Builder, CmpVal);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1703</td>
    <td class="codeLine">    Fract = applyFractPat(Builder, CmpVal);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeLine">  } else if (Pred == FCmpInst::FCMP_ORD && FalseVal == CmpVal && IITrue &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1704</td>
    <td class="codeLine">  } else if (Pred == FCmpInst::FCMP_ORD && FalseVal == CmpVal && IITrue &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeLine">             CmpVal == matchFractPat(*IITrue)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1705</td>
    <td class="codeLine">             CmpVal == matchFractPat(*IITrue)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeLine">    // !isnan(x) ? fract(x) : x</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1706</td>
    <td class="codeLine">    // !isnan(x) ? fract(x) : x</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeLine">    Fract = applyFractPat(Builder, CmpVal);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1707</td>
    <td class="codeLine">    Fract = applyFractPat(Builder, CmpVal);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeLine">  } else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1708</td>
    <td class="codeLine">  } else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1709</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1710</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeLine">  Fract->takeName(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1711</td>
    <td class="codeLine">  Fract->takeName(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeLine">  I.replaceAllUsesWith(Fract);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1712</td>
    <td class="codeLine">  I.replaceAllUsesWith(Fract);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeLine">  RecursivelyDeleteTriviallyDeadInstructions(&I, TLInfo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1713</td>
    <td class="codeLine">  RecursivelyDeleteTriviallyDeadInstructions(&I, TLInfo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1714</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1715</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1716</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeLine">static bool areInSameBB(const Value *A, const Value *B) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1717</td>
    <td class="codeLine">static bool areInSameBB(const Value *A, const Value *B) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeLine">  const auto *IA = dyn_cast<Instruction>(A);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1718</td>
    <td class="codeLine">  const auto *IA = dyn_cast<Instruction>(A);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeLine">  const auto *IB = dyn_cast<Instruction>(B);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1719</td>
    <td class="codeLine">  const auto *IB = dyn_cast<Instruction>(B);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeLine">  return IA && IB && IA->getParent() == IB->getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1720</td>
    <td class="codeLine">  return IA && IB && IA->getParent() == IB->getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1721</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1722</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeLine">// Helper for breaking large PHIs that returns true when an extractelement on V</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1723</td>
    <td class="codeLine">// Helper for breaking large PHIs that returns true when an extractelement on V</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeLine">// is likely to be folded away by the DAG combiner.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1724</td>
    <td class="codeLine">// is likely to be folded away by the DAG combiner.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeLine">static bool isInterestingPHIIncomingValue(const Value *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1725</td>
    <td class="codeLine">static bool isInterestingPHIIncomingValue(const Value *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeLine">  const auto *FVT = dyn_cast<FixedVectorType>(V->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1726</td>
    <td class="codeLine">  const auto *FVT = dyn_cast<FixedVectorType>(V->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeLine">  if (!FVT)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1727</td>
    <td class="codeLine">  if (!FVT)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1728</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1729</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeLine">  const Value *CurVal = V;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1730</td>
    <td class="codeLine">  const Value *CurVal = V;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1731</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeLine">  // Check for insertelements, keeping track of the elements covered.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1732</td>
    <td class="codeLine">  // Check for insertelements, keeping track of the elements covered.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeLine">  BitVector EltsCovered(FVT->getNumElements());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1733</td>
    <td class="codeLine">  BitVector EltsCovered(FVT->getNumElements());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeLine">  while (const auto *IE = dyn_cast<InsertElementInst>(CurVal)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1734</td>
    <td class="codeLine">  while (const auto *IE = dyn_cast<InsertElementInst>(CurVal)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeLine">    const auto *Idx = dyn_cast<ConstantInt>(IE->getOperand(2));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1735</td>
    <td class="codeLine">    const auto *Idx = dyn_cast<ConstantInt>(IE->getOperand(2));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1736</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeLine">    // Non constant index/out of bounds index -> folding is unlikely.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1737</td>
    <td class="codeLine">    // Non constant index/out of bounds index -> folding is unlikely.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeLine">    // The latter is more of a sanity check because canonical IR should just</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1738</td>
    <td class="codeLine">    // The latter is more of a sanity check because canonical IR should just</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeLine">    // have replaced those with poison.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1739</td>
    <td class="codeLine">    // have replaced those with poison.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeLine">    if (!Idx || Idx->getSExtValue() >= FVT->getNumElements())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1740</td>
    <td class="codeLine">    if (!Idx || Idx->getSExtValue() >= FVT->getNumElements())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1741</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1742</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeLine">    const auto *VecSrc = IE->getOperand(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1743</td>
    <td class="codeLine">    const auto *VecSrc = IE->getOperand(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1744</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeLine">    // If the vector source is another instruction, it must be in the same basic</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1745</td>
    <td class="codeLine">    // If the vector source is another instruction, it must be in the same basic</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeLine">    // block. Otherwise, the DAGCombiner won't see the whole thing and is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1746</td>
    <td class="codeLine">    // block. Otherwise, the DAGCombiner won't see the whole thing and is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeLine">    // unlikely to be able to do anything interesting here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1747</td>
    <td class="codeLine">    // unlikely to be able to do anything interesting here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeLine">    if (isa<Instruction>(VecSrc) && !areInSameBB(VecSrc, IE))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1748</td>
    <td class="codeLine">    if (isa<Instruction>(VecSrc) && !areInSameBB(VecSrc, IE))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1749</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1750</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeLine">    CurVal = VecSrc;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1751</td>
    <td class="codeLine">    CurVal = VecSrc;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeLine">    EltsCovered.set(Idx->getSExtValue());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1752</td>
    <td class="codeLine">    EltsCovered.set(Idx->getSExtValue());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1753</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeLine">    // All elements covered.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1754</td>
    <td class="codeLine">    // All elements covered.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeLine">    if (EltsCovered.all())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1755</td>
    <td class="codeLine">    if (EltsCovered.all())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1756</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1757</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1758</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeLine">  // We either didn't find a single insertelement, or the insertelement chain</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1759</td>
    <td class="codeLine">  // We either didn't find a single insertelement, or the insertelement chain</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeLine">  // ended before all elements were covered. Check for other interesting values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1760</td>
    <td class="codeLine">  // ended before all elements were covered. Check for other interesting values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1761</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeLine">  // Constants are always interesting because we can just constant fold the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1762</td>
    <td class="codeLine">  // Constants are always interesting because we can just constant fold the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeLine">  // extractelements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1763</td>
    <td class="codeLine">  // extractelements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeLine">  if (isa<Constant>(CurVal))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1764</td>
    <td class="codeLine">  if (isa<Constant>(CurVal))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1765</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1766</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeLine">  // shufflevector is likely to be profitable if either operand is a constant,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1767</td>
    <td class="codeLine">  // shufflevector is likely to be profitable if either operand is a constant,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeLine">  // or if either source is in the same block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1768</td>
    <td class="codeLine">  // or if either source is in the same block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeLine">  // This is because shufflevector is most often lowered as a series of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1769</td>
    <td class="codeLine">  // This is because shufflevector is most often lowered as a series of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeLine">  // insert/extract elements anyway.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1770</td>
    <td class="codeLine">  // insert/extract elements anyway.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeLine">  if (const auto *SV = dyn_cast<ShuffleVectorInst>(CurVal)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1771</td>
    <td class="codeLine">  if (const auto *SV = dyn_cast<ShuffleVectorInst>(CurVal)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeLine">    return isa<Constant>(SV->getOperand(1)) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1772</td>
    <td class="codeLine">    return isa<Constant>(SV->getOperand(1)) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeLine">           areInSameBB(SV, SV->getOperand(0)) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1773</td>
    <td class="codeLine">           areInSameBB(SV, SV->getOperand(0)) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeLine">           areInSameBB(SV, SV->getOperand(1));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1774</td>
    <td class="codeLine">           areInSameBB(SV, SV->getOperand(1));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1775</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1776</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1777</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1778</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1779</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::canBreakPHINode(const PHINode &I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1780</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::canBreakPHINode(const PHINode &I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeLine">  // Check in the cache, or add an entry for this node.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1781</td>
    <td class="codeLine">  // Check in the cache, or add an entry for this node.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1782</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeLine">  // We init with false because we consider all PHI nodes unbreakable until we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1783</td>
    <td class="codeLine">  // We init with false because we consider all PHI nodes unbreakable until we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeLine">  // reach a conclusion. Doing the opposite - assuming they're break-able until</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1784</td>
    <td class="codeLine">  // reach a conclusion. Doing the opposite - assuming they're break-able until</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeLine">  // proven otherwise - can be harmful in some pathological cases so we're</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1785</td>
    <td class="codeLine">  // proven otherwise - can be harmful in some pathological cases so we're</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeLine">  // conservative for now.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1786</td>
    <td class="codeLine">  // conservative for now.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeLine">  const auto [It, DidInsert] = BreakPhiNodesCache.insert({&I, false});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1787</td>
    <td class="codeLine">  const auto [It, DidInsert] = BreakPhiNodesCache.insert({&I, false});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeLine">  if (!DidInsert)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1788</td>
    <td class="codeLine">  if (!DidInsert)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeLine">    return It->second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1789</td>
    <td class="codeLine">    return It->second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1790</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeLine">  // This function may recurse, so to guard against infinite looping, this PHI</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1791</td>
    <td class="codeLine">  // This function may recurse, so to guard against infinite looping, this PHI</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeLine">  // is conservatively considered unbreakable until we reach a conclusion.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1792</td>
    <td class="codeLine">  // is conservatively considered unbreakable until we reach a conclusion.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1793</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="codeLine">  // Don't break PHIs that have no interesting incoming values. That is, where</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1794</td>
    <td class="codeLine">  // Don't break PHIs that have no interesting incoming values. That is, where</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="codeLine">  // there is no clear opportunity to fold the "extractelement" instructions we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1795</td>
    <td class="codeLine">  // there is no clear opportunity to fold the "extractelement" instructions we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="codeLine">  // would add.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1796</td>
    <td class="codeLine">  // would add.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1797</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="codeLine">  // Note: IC does not run after this pass, so we're only interested in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1798</td>
    <td class="codeLine">  // Note: IC does not run after this pass, so we're only interested in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="codeLine">  // foldings that the DAG combiner can do.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1799</td>
    <td class="codeLine">  // foldings that the DAG combiner can do.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="codeLine">  if (none_of(I.incoming_values(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1800</td>
    <td class="codeLine">  if (none_of(I.incoming_values(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="codeLine">              [&](Value *V) { return isInterestingPHIIncomingValue(V); }))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1801</td>
    <td class="codeLine">              [&](Value *V) { return isInterestingPHIIncomingValue(V); }))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1802</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1803</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="codeLine">  // Now, check users for unbreakable PHI nodes. If we have an unbreakable PHI</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1804</td>
    <td class="codeLine">  // Now, check users for unbreakable PHI nodes. If we have an unbreakable PHI</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="codeLine">  // node as user, we don't want to break this PHI either because it's unlikely</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1805</td>
    <td class="codeLine">  // node as user, we don't want to break this PHI either because it's unlikely</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="codeLine">  // to be beneficial. We would just explode the vector and reassemble it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1806</td>
    <td class="codeLine">  // to be beneficial. We would just explode the vector and reassemble it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="codeLine">  // directly, wasting instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1807</td>
    <td class="codeLine">  // directly, wasting instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1808</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="codeLine">  // In the case where multiple users are PHI nodes, we want at least half of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1809</td>
    <td class="codeLine">  // In the case where multiple users are PHI nodes, we want at least half of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="codeLine">  // them to be breakable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1810</td>
    <td class="codeLine">  // them to be breakable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="codeLine">  int Score = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1811</td>
    <td class="codeLine">  int Score = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="codeLine">  for (const Value *U : I.users()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1812</td>
    <td class="codeLine">  for (const Value *U : I.users()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="codeLine">    if (const auto *PU = dyn_cast<PHINode>(U))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1813</td>
    <td class="codeLine">    if (const auto *PU = dyn_cast<PHINode>(U))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="codeLine">      Score += canBreakPHINode(*PU) ? 1 : -1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1814</td>
    <td class="codeLine">      Score += canBreakPHINode(*PU) ? 1 : -1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1815</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1816</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="codeLine">  if (Score < 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1817</td>
    <td class="codeLine">  if (Score < 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1818</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1819</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="codeLine">  return BreakPhiNodesCache[&I] = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1820</td>
    <td class="codeLine">  return BreakPhiNodesCache[&I] = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1821</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1822</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="codeLine">/// Helper class for "break large PHIs" (visitPHINode).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1823</td>
    <td class="codeLine">/// Helper class for "break large PHIs" (visitPHINode).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1824</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="codeLine">/// This represents a slice of a PHI's incoming value, which is made up of:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1825</td>
    <td class="codeLine">/// This represents a slice of a PHI's incoming value, which is made up of:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="codeLine">///   - The type of the slice (Ty)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1826</td>
    <td class="codeLine">///   - The type of the slice (Ty)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="codeLine">///   - The index in the incoming value's vector where the slice starts (Idx)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1827</td>
    <td class="codeLine">///   - The index in the incoming value's vector where the slice starts (Idx)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="codeLine">///   - The number of elements in the slice (NumElts).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1828</td>
    <td class="codeLine">///   - The number of elements in the slice (NumElts).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="codeLine">/// It also keeps track of the NewPHI node inserted for this particular slice.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1829</td>
    <td class="codeLine">/// It also keeps track of the NewPHI node inserted for this particular slice.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1830</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="codeLine">/// Slice examples:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1831</td>
    <td class="codeLine">/// Slice examples:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="codeLine">///   <4 x i64> -> Split into four i64 slices.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1832</td>
    <td class="codeLine">///   <4 x i64> -> Split into four i64 slices.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="codeLine">///     -> [i64, 0, 1], [i64, 1, 1], [i64, 2, 1], [i64, 3, 1]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1833</td>
    <td class="codeLine">///     -> [i64, 0, 1], [i64, 1, 1], [i64, 2, 1], [i64, 3, 1]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="codeLine">///   <5 x i16> -> Split into 2 <2 x i16> slices + a i16 tail.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1834</td>
    <td class="codeLine">///   <5 x i16> -> Split into 2 <2 x i16> slices + a i16 tail.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="codeLine">///     -> [<2 x i16>, 0, 2], [<2 x i16>, 2, 2], [i16, 4, 1]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1835</td>
    <td class="codeLine">///     -> [<2 x i16>, 0, 2], [<2 x i16>, 2, 2], [i16, 4, 1]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="codeLine">class VectorSlice {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1836</td>
    <td class="codeLine">class VectorSlice {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1837</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="codeLine">  VectorSlice(Type *Ty, unsigned Idx, unsigned NumElts)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1838</td>
    <td class="codeLine">  VectorSlice(Type *Ty, unsigned Idx, unsigned NumElts)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="codeLine">      : Ty(Ty), Idx(Idx), NumElts(NumElts) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1839</td>
    <td class="codeLine">      : Ty(Ty), Idx(Idx), NumElts(NumElts) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1840</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="codeLine">  Type *Ty = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1841</td>
    <td class="codeLine">  Type *Ty = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="codeLine">  unsigned Idx = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1842</td>
    <td class="codeLine">  unsigned Idx = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="codeLine">  unsigned NumElts = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1843</td>
    <td class="codeLine">  unsigned NumElts = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="codeLine">  PHINode *NewPHI = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1844</td>
    <td class="codeLine">  PHINode *NewPHI = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1845</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="codeLine">  /// Slice \p Inc according to the information contained within this slice.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1846</td>
    <td class="codeLine">  /// Slice \p Inc according to the information contained within this slice.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="codeLine">  /// This is cached, so if called multiple times for the same \p BB & \p Inc</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1847</td>
    <td class="codeLine">  /// This is cached, so if called multiple times for the same \p BB & \p Inc</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="codeLine">  /// pair, it returns the same Sliced value as well.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1848</td>
    <td class="codeLine">  /// pair, it returns the same Sliced value as well.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1849</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="codeLine">  /// Note this *intentionally* does not return the same value for, say,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1850</td>
    <td class="codeLine">  /// Note this *intentionally* does not return the same value for, say,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="codeLine">  /// [%bb.0, %0] & [%bb.1, %0] as:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1851</td>
    <td class="codeLine">  /// [%bb.0, %0] & [%bb.1, %0] as:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="codeLine">  ///   - It could cause issues with dominance (e.g. if bb.1 is seen first, then</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1852</td>
    <td class="codeLine">  ///   - It could cause issues with dominance (e.g. if bb.1 is seen first, then</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="codeLine">  ///   the value in bb.1 may not be reachable from bb.0 if it's its</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1853</td>
    <td class="codeLine">  ///   the value in bb.1 may not be reachable from bb.0 if it's its</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="codeLine">  ///   predecessor.)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1854</td>
    <td class="codeLine">  ///   predecessor.)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="codeLine">  ///   - We also want to make our extract instructions as local as possible so</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1855</td>
    <td class="codeLine">  ///   - We also want to make our extract instructions as local as possible so</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="codeLine">  ///   the DAG has better chances of folding them out. Duplicating them like</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1856</td>
    <td class="codeLine">  ///   the DAG has better chances of folding them out. Duplicating them like</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="codeLine">  ///   that is beneficial in that regard.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1857</td>
    <td class="codeLine">  ///   that is beneficial in that regard.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1858</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="codeLine">  /// This is both a minor optimization to avoid creating duplicate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1859</td>
    <td class="codeLine">  /// This is both a minor optimization to avoid creating duplicate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="codeLine">  /// instructions, but also a requirement for correctness. It is not forbidden</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1860</td>
    <td class="codeLine">  /// instructions, but also a requirement for correctness. It is not forbidden</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="codeLine">  /// for a PHI node to have the same [BB, Val] pair multiple times. If we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1861</td>
    <td class="codeLine">  /// for a PHI node to have the same [BB, Val] pair multiple times. If we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="codeLine">  /// returned a new value each time, those previously identical pairs would all</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1862</td>
    <td class="codeLine">  /// returned a new value each time, those previously identical pairs would all</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="codeLine">  /// have different incoming values (from the same block) and it'd cause a "PHI</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1863</td>
    <td class="codeLine">  /// have different incoming values (from the same block) and it'd cause a "PHI</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="codeLine">  /// node has multiple entries for the same basic block with different incoming</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1864</td>
    <td class="codeLine">  /// node has multiple entries for the same basic block with different incoming</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="codeLine">  /// values!" verifier error.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1865</td>
    <td class="codeLine">  /// values!" verifier error.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="codeLine">  Value *getSlicedVal(BasicBlock *BB, Value *Inc, StringRef NewValName) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1866</td>
    <td class="codeLine">  Value *getSlicedVal(BasicBlock *BB, Value *Inc, StringRef NewValName) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="codeLine">    Value *&Res = SlicedVals[{BB, Inc}];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1867</td>
    <td class="codeLine">    Value *&Res = SlicedVals[{BB, Inc}];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="codeLine">    if (Res)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1868</td>
    <td class="codeLine">    if (Res)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="codeLine">      return Res;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1869</td>
    <td class="codeLine">      return Res;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1870</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="codeLine">    IRBuilder<> B(BB->getTerminator());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1871</td>
    <td class="codeLine">    IRBuilder<> B(BB->getTerminator());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="codeLine">    if (Instruction *IncInst = dyn_cast<Instruction>(Inc))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1872</td>
    <td class="codeLine">    if (Instruction *IncInst = dyn_cast<Instruction>(Inc))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="codeLine">      B.SetCurrentDebugLocation(IncInst->getDebugLoc());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1873</td>
    <td class="codeLine">      B.SetCurrentDebugLocation(IncInst->getDebugLoc());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1874</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="codeLine">    if (NumElts > 1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1875</td>
    <td class="codeLine">    if (NumElts > 1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="codeLine">      SmallVector<int, 4> Mask;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1876</td>
    <td class="codeLine">      SmallVector<int, 4> Mask;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="codeLine">      for (unsigned K = Idx; K < (Idx + NumElts); ++K)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1877</td>
    <td class="codeLine">      for (unsigned K = Idx; K < (Idx + NumElts); ++K)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="codeLine">        Mask.push_back(K);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1878</td>
    <td class="codeLine">        Mask.push_back(K);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="codeLine">      Res = B.CreateShuffleVector(Inc, Mask, NewValName);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1879</td>
    <td class="codeLine">      Res = B.CreateShuffleVector(Inc, Mask, NewValName);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="codeLine">    } else</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1880</td>
    <td class="codeLine">    } else</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="codeLine">      Res = B.CreateExtractElement(Inc, Idx, NewValName);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1881</td>
    <td class="codeLine">      Res = B.CreateExtractElement(Inc, Idx, NewValName);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1882</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="codeLine">    return Res;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1883</td>
    <td class="codeLine">    return Res;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1884</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1885</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1886</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="codeLine">  SmallDenseMap<std::pair<BasicBlock *, Value *>, Value *> SlicedVals;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1887</td>
    <td class="codeLine">  SmallDenseMap<std::pair<BasicBlock *, Value *>, Value *> SlicedVals;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1888</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1889</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::visitPHINode(PHINode &I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1890</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::visitPHINode(PHINode &I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="codeLine">  // Break-up fixed-vector PHIs into smaller pieces.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1891</td>
    <td class="codeLine">  // Break-up fixed-vector PHIs into smaller pieces.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="codeLine">  // Default threshold is 32, so it breaks up any vector that's >32 bits into</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1892</td>
    <td class="codeLine">  // Default threshold is 32, so it breaks up any vector that's >32 bits into</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="codeLine">  // its elements, or into 32-bit pieces (for 8/16 bit elts).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1893</td>
    <td class="codeLine">  // its elements, or into 32-bit pieces (for 8/16 bit elts).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1894</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="codeLine">  // This is only helpful for DAGISel because it doesn't handle large PHIs as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1895</td>
    <td class="codeLine">  // This is only helpful for DAGISel because it doesn't handle large PHIs as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="codeLine">  // well as GlobalISel. DAGISel lowers PHIs by using CopyToReg/CopyFromReg.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1896</td>
    <td class="codeLine">  // well as GlobalISel. DAGISel lowers PHIs by using CopyToReg/CopyFromReg.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="codeLine">  // With large, odd-sized PHIs we may end up needing many `build_vector`</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1897</td>
    <td class="codeLine">  // With large, odd-sized PHIs we may end up needing many `build_vector`</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="codeLine">  // operations with most elements being "undef". This inhibits a lot of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1898</td>
    <td class="codeLine">  // operations with most elements being "undef". This inhibits a lot of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="codeLine">  // optimization opportunities and can result in unreasonably high register</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1899</td>
    <td class="codeLine">  // optimization opportunities and can result in unreasonably high register</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="codeLine">  // pressure and the inevitable stack spilling.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1900</td>
    <td class="codeLine">  // pressure and the inevitable stack spilling.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="codeLine">  if (!ScalarizeLargePHIs || getCGPassBuilderOption().EnableGlobalISelOption)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1901</td>
    <td class="codeLine">  if (!ScalarizeLargePHIs || getCGPassBuilderOption().EnableGlobalISelOption)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1902</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1903</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="codeLine">  FixedVectorType *FVT = dyn_cast<FixedVectorType>(I.getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1904</td>
    <td class="codeLine">  FixedVectorType *FVT = dyn_cast<FixedVectorType>(I.getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="codeLine">  if (!FVT || DL->getTypeSizeInBits(FVT) <= ScalarizeLargePHIsThreshold)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1905</td>
    <td class="codeLine">  if (!FVT || DL->getTypeSizeInBits(FVT) <= ScalarizeLargePHIsThreshold)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1906</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1907</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="codeLine">  if (!ForceScalarizeLargePHIs && !canBreakPHINode(I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1908</td>
    <td class="codeLine">  if (!ForceScalarizeLargePHIs && !canBreakPHINode(I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1909</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1910</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="codeLine">  std::vector<VectorSlice> Slices;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1911</td>
    <td class="codeLine">  std::vector<VectorSlice> Slices;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1912</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="codeLine">  Type *EltTy = FVT->getElementType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1913</td>
    <td class="codeLine">  Type *EltTy = FVT->getElementType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="codeLine">  {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1914</td>
    <td class="codeLine">  {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="codeLine">    unsigned Idx = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1915</td>
    <td class="codeLine">    unsigned Idx = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="codeLine">    // For 8/16 bits type, don't scalarize fully but break it up into as many</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1916</td>
    <td class="codeLine">    // For 8/16 bits type, don't scalarize fully but break it up into as many</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="codeLine">    // 32-bit slices as we can, and scalarize the tail.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1917</td>
    <td class="codeLine">    // 32-bit slices as we can, and scalarize the tail.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="codeLine">    const unsigned EltSize = DL->getTypeSizeInBits(EltTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1918</td>
    <td class="codeLine">    const unsigned EltSize = DL->getTypeSizeInBits(EltTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="codeLine">    const unsigned NumElts = FVT->getNumElements();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1919</td>
    <td class="codeLine">    const unsigned NumElts = FVT->getNumElements();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="codeLine">    if (EltSize == 8 || EltSize == 16) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1920</td>
    <td class="codeLine">    if (EltSize == 8 || EltSize == 16) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="codeLine">      const unsigned SubVecSize = (32 / EltSize);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1921</td>
    <td class="codeLine">      const unsigned SubVecSize = (32 / EltSize);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="codeLine">      Type *SubVecTy = FixedVectorType::get(EltTy, SubVecSize);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1922</td>
    <td class="codeLine">      Type *SubVecTy = FixedVectorType::get(EltTy, SubVecSize);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="codeLine">      for (unsigned End = alignDown(NumElts, SubVecSize); Idx < End;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1923</td>
    <td class="codeLine">      for (unsigned End = alignDown(NumElts, SubVecSize); Idx < End;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="codeLine">           Idx += SubVecSize)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1924</td>
    <td class="codeLine">           Idx += SubVecSize)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="codeLine">        Slices.emplace_back(SubVecTy, Idx, SubVecSize);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1925</td>
    <td class="codeLine">        Slices.emplace_back(SubVecTy, Idx, SubVecSize);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1926</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1927</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="codeLine">    // Scalarize all remaining elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1928</td>
    <td class="codeLine">    // Scalarize all remaining elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="codeLine">    for (; Idx < NumElts; ++Idx)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1929</td>
    <td class="codeLine">    for (; Idx < NumElts; ++Idx)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="codeLine">      Slices.emplace_back(EltTy, Idx, 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1930</td>
    <td class="codeLine">      Slices.emplace_back(EltTy, Idx, 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1931</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1932</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="codeLine">  if (Slices.size() == 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1933</td>
    <td class="codeLine">  if (Slices.size() == 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1934</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1935</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="codeLine">  // Create one PHI per vector piece. The "VectorSlice" class takes care of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1936</td>
    <td class="codeLine">  // Create one PHI per vector piece. The "VectorSlice" class takes care of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="codeLine">  // creating the necessary instruction to extract the relevant slices of each</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1937</td>
    <td class="codeLine">  // creating the necessary instruction to extract the relevant slices of each</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="codeLine">  // incoming value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1938</td>
    <td class="codeLine">  // incoming value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="codeLine">  IRBuilder<> B(I.getParent());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1939</td>
    <td class="codeLine">  IRBuilder<> B(I.getParent());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="codeLine">  B.SetCurrentDebugLocation(I.getDebugLoc());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1940</td>
    <td class="codeLine">  B.SetCurrentDebugLocation(I.getDebugLoc());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1941</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="codeLine">  unsigned IncNameSuffix = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1942</td>
    <td class="codeLine">  unsigned IncNameSuffix = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="codeLine">  for (VectorSlice &S : Slices) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1943</td>
    <td class="codeLine">  for (VectorSlice &S : Slices) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="codeLine">    // We need to reset the build on each iteration, because getSlicedVal may</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1944</td>
    <td class="codeLine">    // We need to reset the build on each iteration, because getSlicedVal may</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="codeLine">    // have inserted something into I's BB.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1945</td>
    <td class="codeLine">    // have inserted something into I's BB.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="codeLine">    B.SetInsertPoint(I.getParent()->getFirstNonPHI());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1946</td>
    <td class="codeLine">    B.SetInsertPoint(I.getParent()->getFirstNonPHI());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="codeLine">    S.NewPHI = B.CreatePHI(S.Ty, I.getNumIncomingValues());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1947</td>
    <td class="codeLine">    S.NewPHI = B.CreatePHI(S.Ty, I.getNumIncomingValues());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1948</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="codeLine">    for (const auto &[Idx, BB] : enumerate(I.blocks())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1949</td>
    <td class="codeLine">    for (const auto &[Idx, BB] : enumerate(I.blocks())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="codeLine">      S.NewPHI->addIncoming(S.getSlicedVal(BB, I.getIncomingValue(Idx),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1950</td>
    <td class="codeLine">      S.NewPHI->addIncoming(S.getSlicedVal(BB, I.getIncomingValue(Idx),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="codeLine">                                           "largephi.extractslice" +</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1951</td>
    <td class="codeLine">                                           "largephi.extractslice" +</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="codeLine">                                               std::to_string(IncNameSuffix++)),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1952</td>
    <td class="codeLine">                                               std::to_string(IncNameSuffix++)),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="codeLine">                            BB);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1953</td>
    <td class="codeLine">                            BB);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1954</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1955</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1956</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="codeLine">  // And replace this PHI with a vector of all the previous PHI values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1957</td>
    <td class="codeLine">  // And replace this PHI with a vector of all the previous PHI values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="codeLine">  Value *Vec = PoisonValue::get(FVT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1958</td>
    <td class="codeLine">  Value *Vec = PoisonValue::get(FVT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="codeLine">  unsigned NameSuffix = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1959</td>
    <td class="codeLine">  unsigned NameSuffix = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="codeLine">  for (VectorSlice &S : Slices) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1960</td>
    <td class="codeLine">  for (VectorSlice &S : Slices) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="codeLine">    const auto ValName = "largephi.insertslice" + std::to_string(NameSuffix++);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1961</td>
    <td class="codeLine">    const auto ValName = "largephi.insertslice" + std::to_string(NameSuffix++);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="codeLine">    if (S.NumElts > 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1962</td>
    <td class="codeLine">    if (S.NumElts > 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="codeLine">      Vec =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1963</td>
    <td class="codeLine">      Vec =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="codeLine">          B.CreateInsertVector(FVT, Vec, S.NewPHI, B.getInt64(S.Idx), ValName);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1964</td>
    <td class="codeLine">          B.CreateInsertVector(FVT, Vec, S.NewPHI, B.getInt64(S.Idx), ValName);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1965</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="codeLine">      Vec = B.CreateInsertElement(Vec, S.NewPHI, S.Idx, ValName);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1966</td>
    <td class="codeLine">      Vec = B.CreateInsertElement(Vec, S.NewPHI, S.Idx, ValName);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1967</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1968</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="codeLine">  I.replaceAllUsesWith(Vec);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1969</td>
    <td class="codeLine">  I.replaceAllUsesWith(Vec);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="codeLine">  I.eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1970</td>
    <td class="codeLine">  I.eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1971</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1972</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1973</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::visitIntrinsicInst(IntrinsicInst &I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1974</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::visitIntrinsicInst(IntrinsicInst &I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="codeLine">  switch (I.getIntrinsicID()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1975</td>
    <td class="codeLine">  switch (I.getIntrinsicID()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="codeLine">  case Intrinsic::bitreverse:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1976</td>
    <td class="codeLine">  case Intrinsic::bitreverse:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="codeLine">    return visitBitreverseIntrinsicInst(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1977</td>
    <td class="codeLine">    return visitBitreverseIntrinsicInst(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="codeLine">  case Intrinsic::minnum:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1978</td>
    <td class="codeLine">  case Intrinsic::minnum:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="codeLine">    return visitMinNum(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1979</td>
    <td class="codeLine">    return visitMinNum(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1980</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1981</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1982</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1983</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1984</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::visitBitreverseIntrinsicInst(IntrinsicInst &I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1985</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::visitBitreverseIntrinsicInst(IntrinsicInst &I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1986</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1987</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="codeLine">  if (ST->has16BitInsts() && needsPromotionToI32(I.getType()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1988</td>
    <td class="codeLine">  if (ST->has16BitInsts() && needsPromotionToI32(I.getType()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="codeLine">      UA->isUniform(&I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1989</td>
    <td class="codeLine">      UA->isUniform(&I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="codeLine">    Changed |= promoteUniformBitreverseToI32(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1990</td>
    <td class="codeLine">    Changed |= promoteUniformBitreverseToI32(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1991</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1992</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1993</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1994</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="codeLine">/// Match non-nan fract pattern.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1995</td>
    <td class="codeLine">/// Match non-nan fract pattern.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="codeLine">///   minnum(fsub(x, floor(x)), nextafter(1.0, -1.0)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1996</td>
    <td class="codeLine">///   minnum(fsub(x, floor(x)), nextafter(1.0, -1.0)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1997</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="codeLine">/// If fract is a useful instruction for the subtarget. Does not account for the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1998</td>
    <td class="codeLine">/// If fract is a useful instruction for the subtarget. Does not account for the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="codeLine">/// nan handling; the instruction has a nan check on the input value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1999</td>
    <td class="codeLine">/// nan handling; the instruction has a nan check on the input value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="codeLine">Value *AMDGPUCodeGenPrepareImpl::matchFractPat(IntrinsicInst &I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2000</td>
    <td class="codeLine">Value *AMDGPUCodeGenPrepareImpl::matchFractPat(IntrinsicInst &I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="codeLine">  if (ST->hasFractBug())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2001</td>
    <td class="codeLine">  if (ST->hasFractBug())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2002</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2003</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="codeLine">  if (I.getIntrinsicID() != Intrinsic::minnum)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2004</td>
    <td class="codeLine">  if (I.getIntrinsicID() != Intrinsic::minnum)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2005</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2006</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="codeLine">  Type *Ty = I.getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2007</td>
    <td class="codeLine">  Type *Ty = I.getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="codeLine">  if (!isLegalFloatingTy(Ty->getScalarType()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2008</td>
    <td class="codeLine">  if (!isLegalFloatingTy(Ty->getScalarType()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2009</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2010</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="codeLine">  Value *Arg0 = I.getArgOperand(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2011</td>
    <td class="codeLine">  Value *Arg0 = I.getArgOperand(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="codeLine">  Value *Arg1 = I.getArgOperand(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2012</td>
    <td class="codeLine">  Value *Arg1 = I.getArgOperand(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2013</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="codeLine">  const APFloat *C;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2014</td>
    <td class="codeLine">  const APFloat *C;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="codeLine">  if (!match(Arg1, m_APFloat(C)))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2015</td>
    <td class="codeLine">  if (!match(Arg1, m_APFloat(C)))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2016</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2017</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="codeLine">  APFloat One(1.0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2018</td>
    <td class="codeLine">  APFloat One(1.0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="codeLine">  bool LosesInfo;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2019</td>
    <td class="codeLine">  bool LosesInfo;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="codeLine">  One.convert(C->getSemantics(), APFloat::rmNearestTiesToEven, &LosesInfo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2020</td>
    <td class="codeLine">  One.convert(C->getSemantics(), APFloat::rmNearestTiesToEven, &LosesInfo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2021</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="codeLine">  // Match nextafter(1.0, -1)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2022</td>
    <td class="codeLine">  // Match nextafter(1.0, -1)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="codeLine">  One.next(true);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2023</td>
    <td class="codeLine">  One.next(true);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="codeLine">  if (One != *C)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2024</td>
    <td class="codeLine">  if (One != *C)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2025</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2026</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="codeLine">  Value *FloorSrc;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2027</td>
    <td class="codeLine">  Value *FloorSrc;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="codeLine">  if (match(Arg0, m_FSub(m_Value(FloorSrc),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2028</td>
    <td class="codeLine">  if (match(Arg0, m_FSub(m_Value(FloorSrc),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="codeLine">                         m_Intrinsic<Intrinsic::floor>(m_Deferred(FloorSrc)))))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2029</td>
    <td class="codeLine">                         m_Intrinsic<Intrinsic::floor>(m_Deferred(FloorSrc)))))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="codeLine">    return FloorSrc;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2030</td>
    <td class="codeLine">    return FloorSrc;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2031</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2032</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2033</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="codeLine">Value *AMDGPUCodeGenPrepareImpl::applyFractPat(IRBuilder<> &Builder,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2034</td>
    <td class="codeLine">Value *AMDGPUCodeGenPrepareImpl::applyFractPat(IRBuilder<> &Builder,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="codeLine">                                               Value *FractArg) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2035</td>
    <td class="codeLine">                                               Value *FractArg) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="codeLine">  SmallVector<Value *, 4> FractVals;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2036</td>
    <td class="codeLine">  SmallVector<Value *, 4> FractVals;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="codeLine">  extractValues(Builder, FractVals, FractArg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2037</td>
    <td class="codeLine">  extractValues(Builder, FractVals, FractArg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2038</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="codeLine">  SmallVector<Value *, 4> ResultVals(FractVals.size());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2039</td>
    <td class="codeLine">  SmallVector<Value *, 4> ResultVals(FractVals.size());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2040</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="codeLine">  Type *Ty = FractArg->getType()->getScalarType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2041</td>
    <td class="codeLine">  Type *Ty = FractArg->getType()->getScalarType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="codeLine">  for (unsigned I = 0, E = FractVals.size(); I != E; ++I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2042</td>
    <td class="codeLine">  for (unsigned I = 0, E = FractVals.size(); I != E; ++I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="codeLine">    ResultVals[I] =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2043</td>
    <td class="codeLine">    ResultVals[I] =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="codeLine">        Builder.CreateIntrinsic(Intrinsic::amdgcn_fract, {Ty}, {FractVals[I]});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2044</td>
    <td class="codeLine">        Builder.CreateIntrinsic(Intrinsic::amdgcn_fract, {Ty}, {FractVals[I]});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2045</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2046</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="codeLine">  return insertValues(Builder, FractArg->getType(), ResultVals);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2047</td>
    <td class="codeLine">  return insertValues(Builder, FractArg->getType(), ResultVals);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2048</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2049</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::visitMinNum(IntrinsicInst &I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2050</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepareImpl::visitMinNum(IntrinsicInst &I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="codeLine">  Value *FractArg = matchFractPat(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2051</td>
    <td class="codeLine">  Value *FractArg = matchFractPat(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="codeLine">  if (!FractArg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2052</td>
    <td class="codeLine">  if (!FractArg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2053</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2054</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="codeLine">  // Match pattern for fract intrinsic in contexts where the nan check has been</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2055</td>
    <td class="codeLine">  // Match pattern for fract intrinsic in contexts where the nan check has been</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="codeLine">  // optimized out (and hope the knowledge the source can't be nan wasn't lost).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2056</td>
    <td class="codeLine">  // optimized out (and hope the knowledge the source can't be nan wasn't lost).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="codeLine">  if (!I.hasNoNaNs() && !isKnownNeverNaN(FractArg, *DL, TLInfo))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2057</td>
    <td class="codeLine">  if (!I.hasNoNaNs() && !isKnownNeverNaN(FractArg, *DL, TLInfo))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2058</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2059</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="codeLine">  IRBuilder<> Builder(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2060</td>
    <td class="codeLine">  IRBuilder<> Builder(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="codeLine">  FastMathFlags FMF = I.getFastMathFlags();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2061</td>
    <td class="codeLine">  FastMathFlags FMF = I.getFastMathFlags();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="codeLine">  FMF.setNoNaNs();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2062</td>
    <td class="codeLine">  FMF.setNoNaNs();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="codeLine">  Builder.setFastMathFlags(FMF);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2063</td>
    <td class="codeLine">  Builder.setFastMathFlags(FMF);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2064</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="codeLine">  Value *Fract = applyFractPat(Builder, FractArg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2065</td>
    <td class="codeLine">  Value *Fract = applyFractPat(Builder, FractArg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="codeLine">  Fract->takeName(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2066</td>
    <td class="codeLine">  Fract->takeName(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="codeLine">  I.replaceAllUsesWith(Fract);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2067</td>
    <td class="codeLine">  I.replaceAllUsesWith(Fract);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2068</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="codeLine">  RecursivelyDeleteTriviallyDeadInstructions(&I, TLInfo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2069</td>
    <td class="codeLine">  RecursivelyDeleteTriviallyDeadInstructions(&I, TLInfo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2070</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2071</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2072</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepare::doInitialization(Module &M) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2073</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepare::doInitialization(Module &M) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="codeLine">  Impl.Mod = &M;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2074</td>
    <td class="codeLine">  Impl.Mod = &M;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="codeLine">  Impl.DL = &Impl.Mod->getDataLayout();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2075</td>
    <td class="codeLine">  Impl.DL = &Impl.Mod->getDataLayout();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2076</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2077</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2078</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepare::runOnFunction(Function &F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2079</td>
    <td class="codeLine">bool AMDGPUCodeGenPrepare::runOnFunction(Function &F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="codeLine">  if (skipFunction(F))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2080</td>
    <td class="codeLine">  if (skipFunction(F))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2081</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2082</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="codeLine">  auto *TPC = getAnalysisIfAvailable<TargetPassConfig>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2083</td>
    <td class="codeLine">  auto *TPC = getAnalysisIfAvailable<TargetPassConfig>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="codeLine">  if (!TPC)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2084</td>
    <td class="codeLine">  if (!TPC)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2085</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2086</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="codeLine">  const AMDGPUTargetMachine &TM = TPC->getTM<AMDGPUTargetMachine>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2087</td>
    <td class="codeLine">  const AMDGPUTargetMachine &TM = TPC->getTM<AMDGPUTargetMachine>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="codeLine">  Impl.TLInfo = &getAnalysis<TargetLibraryInfoWrapperPass>().getTLI(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2088</td>
    <td class="codeLine">  Impl.TLInfo = &getAnalysis<TargetLibraryInfoWrapperPass>().getTLI(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="codeLine">  Impl.ST = &TM.getSubtarget<GCNSubtarget>(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2089</td>
    <td class="codeLine">  Impl.ST = &TM.getSubtarget<GCNSubtarget>(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="codeLine">  Impl.AC = &getAnalysis<AssumptionCacheTracker>().getAssumptionCache(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2090</td>
    <td class="codeLine">  Impl.AC = &getAnalysis<AssumptionCacheTracker>().getAssumptionCache(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="codeLine">  Impl.UA = &getAnalysis<UniformityInfoWrapperPass>().getUniformityInfo();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2091</td>
    <td class="codeLine">  Impl.UA = &getAnalysis<UniformityInfoWrapperPass>().getUniformityInfo();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="codeLine">  auto *DTWP = getAnalysisIfAvailable<DominatorTreeWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2092</td>
    <td class="codeLine">  auto *DTWP = getAnalysisIfAvailable<DominatorTreeWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="codeLine">  Impl.DT = DTWP ? &DTWP->getDomTree() : nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2093</td>
    <td class="codeLine">  Impl.DT = DTWP ? &DTWP->getDomTree() : nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="codeLine">  Impl.HasUnsafeFPMath = hasUnsafeFPMath(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2094</td>
    <td class="codeLine">  Impl.HasUnsafeFPMath = hasUnsafeFPMath(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="codeLine">  SIModeRegisterDefaults Mode(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2095</td>
    <td class="codeLine">  SIModeRegisterDefaults Mode(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="codeLine">  Impl.HasFP32DenormalFlush =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2096</td>
    <td class="codeLine">  Impl.HasFP32DenormalFlush =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="codeLine">      Mode.FP32Denormals == DenormalMode::getPreserveSign();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2097</td>
    <td class="codeLine">      Mode.FP32Denormals == DenormalMode::getPreserveSign();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="codeLine">  return Impl.run(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2098</td>
    <td class="codeLine">  return Impl.run(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2099</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2100</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="codeLine">PreservedAnalyses AMDGPUCodeGenPreparePass::run(Function &F,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2101</td>
    <td class="codeLine">PreservedAnalyses AMDGPUCodeGenPreparePass::run(Function &F,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="codeLine">                                                FunctionAnalysisManager &FAM) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2102</td>
    <td class="codeLine">                                                FunctionAnalysisManager &FAM) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="codeLine">  AMDGPUCodeGenPrepareImpl Impl;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2103</td>
    <td class="codeLine">  AMDGPUCodeGenPrepareImpl Impl;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="codeLine">  Impl.Mod = F.getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2104</td>
    <td class="codeLine">  Impl.Mod = F.getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="codeLine">  Impl.DL = &Impl.Mod->getDataLayout();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2105</td>
    <td class="codeLine">  Impl.DL = &Impl.Mod->getDataLayout();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="codeLine">  Impl.TLInfo = &FAM.getResult<TargetLibraryAnalysis>(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2106</td>
    <td class="codeLine">  Impl.TLInfo = &FAM.getResult<TargetLibraryAnalysis>(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="codeLine">  Impl.ST = &TM.getSubtarget<GCNSubtarget>(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2107</td>
    <td class="codeLine">  Impl.ST = &TM.getSubtarget<GCNSubtarget>(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="codeLine">  Impl.AC = &FAM.getResult<AssumptionAnalysis>(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2108</td>
    <td class="codeLine">  Impl.AC = &FAM.getResult<AssumptionAnalysis>(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="codeLine">  Impl.UA = &FAM.getResult<UniformityInfoAnalysis>(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2109</td>
    <td class="codeLine">  Impl.UA = &FAM.getResult<UniformityInfoAnalysis>(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="codeLine">  Impl.DT = FAM.getCachedResult<DominatorTreeAnalysis>(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2110</td>
    <td class="codeLine">  Impl.DT = FAM.getCachedResult<DominatorTreeAnalysis>(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="codeLine">  Impl.HasUnsafeFPMath = hasUnsafeFPMath(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2111</td>
    <td class="codeLine">  Impl.HasUnsafeFPMath = hasUnsafeFPMath(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="codeLine">  SIModeRegisterDefaults Mode(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2112</td>
    <td class="codeLine">  SIModeRegisterDefaults Mode(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="codeLine">  Impl.HasFP32DenormalFlush =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2113</td>
    <td class="codeLine">  Impl.HasFP32DenormalFlush =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="codeLine">      Mode.FP32Denormals == DenormalMode::getPreserveSign();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2114</td>
    <td class="codeLine">      Mode.FP32Denormals == DenormalMode::getPreserveSign();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="codeLine">  PreservedAnalyses PA = PreservedAnalyses::none();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2115</td>
    <td class="codeLine">  PreservedAnalyses PA = PreservedAnalyses::none();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="codeLine">  if (!Impl.FlowChanged)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2116</td>
    <td class="codeLine">  if (!Impl.FlowChanged)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="codeLine">    PA.preserveSet<CFGAnalyses>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2117</td>
    <td class="codeLine">    PA.preserveSet<CFGAnalyses>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="codeLine">  return Impl.run(F) ? PA : PreservedAnalyses::all();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2118</td>
    <td class="codeLine">  return Impl.run(F) ? PA : PreservedAnalyses::all();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2119</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2120</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_BEGIN(AMDGPUCodeGenPrepare, DEBUG_TYPE,</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2121</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_BEGIN(AMDGPUCodeGenPrepare, DEBUG_TYPE,</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="codeLine">                      "AMDGPU IR optimizations", false, false)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2122</td>
    <td class="codeLine">                      "AMDGPU IR optimizations", false, false)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(AssumptionCacheTracker)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2123</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(AssumptionCacheTracker)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(TargetLibraryInfoWrapperPass)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2124</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(TargetLibraryInfoWrapperPass)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(UniformityInfoWrapperPass)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2125</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(UniformityInfoWrapperPass)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_END(AMDGPUCodeGenPrepare, DEBUG_TYPE, "AMDGPU IR optimizations",</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">2126</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_END(AMDGPUCodeGenPrepare, DEBUG_TYPE, "AMDGPU IR optimizations",</td>
    <td class="lineNumber">2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="codeLine">                    false, false)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2127</td>
    <td class="codeLine">                    false, false)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2128</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="codeLine">char AMDGPUCodeGenPrepare::ID = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2129</td>
    <td class="codeLine">char AMDGPUCodeGenPrepare::ID = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2130</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="codeLine">FunctionPass *llvm::createAMDGPUCodeGenPreparePass() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2131</td>
    <td class="codeLine">FunctionPass *llvm::createAMDGPUCodeGenPreparePass() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="codeLine">  return new AMDGPUCodeGenPrepare();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2132</td>
    <td class="codeLine">  return new AMDGPUCodeGenPrepare();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2133</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2134</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
</table>
    </div>
    <button id="myBtn" onclick="topFunction()" title="Go to top" type="button">Top</button>
    <script src="../Javascript/drop_down.js"></script>
    <script src="../Javascript/top_button.js"></script>
  </body>
</html>