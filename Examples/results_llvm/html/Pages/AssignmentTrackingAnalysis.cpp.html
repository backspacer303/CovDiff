<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>AssignmentTrackingAnalysis.cpp</title>
    <link rel="stylesheet" href="../Style/style.css" />
  </head>
  <body>
    <div class="headerDiv">
      <h1>
        Code Coverage
      </h1>
      <p>
        Source file: /home/nikola/Desktop/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
      </p>
    </div>
    <button class="collapsible" type="button">Open Summary Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Summary Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line number</th>
    <th class="mainTh">Line</th>
    <th class="mainTh">Number of hits</th>
    <th class="mainTh">Tests that cover line</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="">#include "llvm/CodeGen/AssignmentTrackingAnalysis.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="">#include "LiveDebugValues/LiveDebugValues.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="">#include "llvm/ADT/BitVector.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="">#include "llvm/ADT/DenseMapInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="">#include "llvm/ADT/IntervalMap.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="">#include "llvm/ADT/PostOrderIterator.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="">#include "llvm/ADT/STLExtras.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="">#include "llvm/ADT/SmallSet.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="">#include "llvm/ADT/Statistic.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="">#include "llvm/ADT/UniqueVector.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="">#include "llvm/Analysis/Interval.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="">#include "llvm/BinaryFormat/Dwarf.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="">#include "llvm/IR/BasicBlock.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="">#include "llvm/IR/DataLayout.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="">#include "llvm/IR/DebugInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="">#include "llvm/IR/Function.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="">#include "llvm/IR/Instruction.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="">#include "llvm/IR/IntrinsicInst.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="">#include "llvm/IR/PassManager.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="">#include "llvm/IR/PrintPasses.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="">#include "llvm/InitializePasses.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="">#include "llvm/Support/CommandLine.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="">#include "llvm/Support/ErrorHandling.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="">#include "llvm/Support/raw_ostream.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="">#include "llvm/Transforms/Utils/BasicBlockUtils.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="">#include <assert.h></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="">#include <cstdint></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="">#include <optional></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="">#include <sstream></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="">#include <unordered_map></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="">using namespace llvm;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="">#define DEBUG_TYPE "debug-ata"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="">STATISTIC(NumDefsScanned, "Number of dbg locs that get scanned for removal");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="">STATISTIC(NumDefsRemoved, "Number of dbg locs removed");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="">STATISTIC(NumWedgesScanned, "Number of dbg wedges scanned");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="">STATISTIC(NumWedgesChanged, "Number of dbg wedges changed");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="">static cl::opt<unsigned></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="">    MaxNumBlocks("debug-ata-max-blocks", cl::init(10000),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="">                 cl::desc("Maximum num basic blocks before debug info dropped"),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="">                 cl::Hidden);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="">/// Option for debugging the pass, determines if the memory location fragment</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="">/// filling happens after generating the variable locations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="">static cl::opt<bool> EnableMemLocFragFill("mem-loc-frag-fill", cl::init(true),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="">                                          cl::Hidden);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="">/// Print the results of the analysis. Respects -filter-print-funcs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="">static cl::opt<bool> PrintResults("print-debug-ata", cl::init(false),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="">                                  cl::Hidden);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="">/// Coalesce adjacent dbg locs describing memory locations that have contiguous</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="">/// fragments. This reduces the cost of LiveDebugValues which does SSA</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="">/// construction for each explicitly stated variable fragment.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="">static cl::opt<cl::boolOrDefault></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="">    CoalesceAdjacentFragmentsOpt("debug-ata-coalesce-frags", cl::Hidden);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="">// Implicit conversions are disabled for enum class types, so unfortunately we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="">// need to create a DenseMapInfo wrapper around the specified underlying type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="">template <> struct llvm::DenseMapInfo<VariableID> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="">  using Wrapped = DenseMapInfo<unsigned>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="uncoveredLine">  static inline VariableID getEmptyKey() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="uncoveredLine">    return static_cast<VariableID>(Wrapped::getEmptyKey());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="uncoveredLine">  static inline VariableID getTombstoneKey() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="uncoveredLine">    return static_cast<VariableID>(Wrapped::getTombstoneKey());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="uncoveredLine">  static unsigned getHashValue(const VariableID &Val) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="uncoveredLine">    return Wrapped::getHashValue(static_cast<unsigned>(Val));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="uncoveredLine">  static bool isEqual(const VariableID &LHS, const VariableID &RHS) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="uncoveredLine">    return LHS == RHS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="">/// Helper class to build FunctionVarLocs, since that class isn't easy to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="">/// modify. TODO: There's not a great deal of value in the split, it could be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="">/// worth merging the two classes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="">class FunctionVarLocsBuilder {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="">  friend FunctionVarLocs;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="">  UniqueVector<DebugVariable> Variables;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="">  // Use an unordered_map so we don't invalidate iterators after</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="">  // insert/modifications.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="">  std::unordered_map<const Instruction *, SmallVector<VarLocInfo>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="">      VarLocsBeforeInst;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="">  SmallVector<VarLocInfo> SingleLocVars;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="uncoveredLine">  unsigned getNumVariables() const { return Variables.size(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="">  /// Find or insert \p V and return the ID.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="uncoveredLine">  VariableID insertVariable(DebugVariable V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="uncoveredLine">    return static_cast<VariableID>(Variables.insert(V));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="">  /// Get a variable from its \p ID.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="uncoveredLine">  const DebugVariable &getVariable(VariableID ID) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="uncoveredLine">    return Variables[static_cast<unsigned>(ID)];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="">  /// Return ptr to wedge of defs or nullptr if no defs come just before /p</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="">  /// Before.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="uncoveredLine">  const SmallVectorImpl<VarLocInfo> *getWedge(const Instruction *Before) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="uncoveredLine">    auto R = VarLocsBeforeInst.find(Before);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="uncoveredLine">    if (R == VarLocsBeforeInst.end())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="uncoveredLine">      return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="uncoveredLine">    return &R->second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="">  /// Replace the defs that come just before /p Before with /p Wedge.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="uncoveredLine">  void setWedge(const Instruction *Before, SmallVector<VarLocInfo> &&Wedge) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="uncoveredLine">    VarLocsBeforeInst[Before] = std::move(Wedge);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="">  /// Add a def for a variable that is valid for its lifetime.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="uncoveredLine">  void addSingleLocVar(DebugVariable Var, DIExpression *Expr, DebugLoc DL,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="">                       RawLocationWrapper R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="uncoveredLine">    VarLocInfo VarLoc;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="uncoveredLine">    VarLoc.VariableID = insertVariable(Var);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="uncoveredLine">    VarLoc.Expr = Expr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="uncoveredLine">    VarLoc.DL = DL;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="uncoveredLine">    VarLoc.Values = R;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="uncoveredLine">    SingleLocVars.emplace_back(VarLoc);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="">  /// Add a def to the wedge of defs just before /p Before.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="uncoveredLine">  void addVarLoc(Instruction *Before, DebugVariable Var, DIExpression *Expr,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="">                 DebugLoc DL, RawLocationWrapper R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="uncoveredLine">    VarLocInfo VarLoc;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="uncoveredLine">    VarLoc.VariableID = insertVariable(Var);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="uncoveredLine">    VarLoc.Expr = Expr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="uncoveredLine">    VarLoc.DL = DL;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="uncoveredLine">    VarLoc.Values = R;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="uncoveredLine">    VarLocsBeforeInst[Before].emplace_back(VarLoc);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="uncoveredLine">void FunctionVarLocs::print(raw_ostream &OS, const Function &Fn) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="">  // Print the variable table first. TODO: Sorting by variable could make the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="">  // output more stable?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="uncoveredLine">  unsigned Counter = -1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="uncoveredLine">  OS << "=== Variables ===\n";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="uncoveredLine">  for (const DebugVariable &V : Variables) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="uncoveredLine">    ++Counter;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="">    // Skip first entry because it is a dummy entry.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="uncoveredLine">    if (Counter == 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="uncoveredLine">    OS << "[" << Counter << "] " << V.getVariable()->getName();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="uncoveredLine">    if (auto F = V.getFragment())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="uncoveredLine">      OS << " bits [" << F->OffsetInBits << ", "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="uncoveredLine">         << F->OffsetInBits + F->SizeInBits << ")";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="uncoveredLine">    if (const auto *IA = V.getInlinedAt())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="uncoveredLine">      OS << " inlined-at " << *IA;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="uncoveredLine">    OS << "\n";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="uncoveredLine">  auto PrintLoc = [&OS](const VarLocInfo &Loc) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="uncoveredLine">    OS << "DEF Var=[" << (unsigned)Loc.VariableID << "]"</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="uncoveredLine">       << " Expr=" << *Loc.Expr << " Values=(";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="uncoveredLine">    for (auto *Op : Loc.Values.location_ops()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="uncoveredLine">      errs() << Op->getName() << " ";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="uncoveredLine">    errs() << ")\n";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="">  // Print the single location variables.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="uncoveredLine">  OS << "=== Single location vars ===\n";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="uncoveredLine">  for (auto It = single_locs_begin(), End = single_locs_end(); It != End;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="">       ++It) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="uncoveredLine">    PrintLoc(*It);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="">  // Print the non-single-location defs in line with IR.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="uncoveredLine">  OS << "=== In-line variable defs ===";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="uncoveredLine">  for (const BasicBlock &BB : Fn) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="uncoveredLine">    OS << "\n" << BB.getName() << ":\n";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="uncoveredLine">    for (const Instruction &I : BB) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="uncoveredLine">      for (auto It = locs_begin(&I), End = locs_end(&I); It != End; ++It) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="uncoveredLine">        PrintLoc(*It);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="uncoveredLine">      OS << I << "\n";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="uncoveredLine">void FunctionVarLocs::init(FunctionVarLocsBuilder &Builder) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="">  // Add the single-location variables first.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="uncoveredLine">  for (const auto &VarLoc : Builder.SingleLocVars)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="uncoveredLine">    VarLocRecords.emplace_back(VarLoc);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="">  // Mark the end of the section.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="uncoveredLine">  SingleVarLocEnd = VarLocRecords.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="">  // Insert a contiguous block of VarLocInfos for each instruction, mapping it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="">  // to the start and end position in the vector with VarLocsBeforeInst.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="uncoveredLine">  for (auto &P : Builder.VarLocsBeforeInst) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="uncoveredLine">    unsigned BlockStart = VarLocRecords.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="uncoveredLine">    for (const VarLocInfo &VarLoc : P.second)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="uncoveredLine">      VarLocRecords.emplace_back(VarLoc);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="uncoveredLine">    unsigned BlockEnd = VarLocRecords.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="">    // Record the start and end indices.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="uncoveredLine">    if (BlockEnd != BlockStart)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="uncoveredLine">      VarLocsBeforeInst[P.first] = {BlockStart, BlockEnd};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="">  // Copy the Variables vector from the builder's UniqueVector.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="uncoveredLine">  assert(Variables.empty() && "Expect clear before init");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="">  // UniqueVectors IDs are one-based (which means the VarLocInfo VarID values</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="">  // are one-based) so reserve an extra and insert a dummy.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="uncoveredLine">  Variables.reserve(Builder.Variables.size() + 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="uncoveredLine">  Variables.push_back(DebugVariable(nullptr, std::nullopt, nullptr));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="uncoveredLine">  Variables.append(Builder.Variables.begin(), Builder.Variables.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="uncoveredLine">void FunctionVarLocs::clear() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="uncoveredLine">  Variables.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="uncoveredLine">  VarLocRecords.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="uncoveredLine">  VarLocsBeforeInst.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="uncoveredLine">  SingleVarLocEnd = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="">/// Walk backwards along constant GEPs and bitcasts to the base storage from \p</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="">/// Start as far as possible. Prepend \Expression with the offset and append it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="">/// with a DW_OP_deref that haes been implicit until now. Returns the walked-to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="">/// value and modified expression.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="">static std::pair<Value *, DIExpression *></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="uncoveredLine">walkToAllocaAndPrependOffsetDeref(const DataLayout &DL, Value *Start,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="">                                  DIExpression *Expression) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="uncoveredLine">  APInt OffsetInBytes(DL.getTypeSizeInBits(Start->getType()), false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="">  Value *End =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="uncoveredLine">      Start->stripAndAccumulateInBoundsConstantOffsets(DL, OffsetInBytes);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="uncoveredLine">  SmallVector<uint64_t, 3> Ops;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="uncoveredLine">  if (OffsetInBytes.getBoolValue()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="uncoveredLine">    Ops = {dwarf::DW_OP_plus_uconst, OffsetInBytes.getZExtValue()};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="uncoveredLine">    Expression = DIExpression::prependOpcodes(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="">        Expression, Ops, /*StackValue=*/false, /*EntryValue=*/false);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="uncoveredLine">  Expression = DIExpression::append(Expression, {dwarf::DW_OP_deref});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="uncoveredLine">  return {End, Expression};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="">/// Extract the offset used in \p DIExpr. Returns std::nullopt if the expression</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="">/// doesn't explicitly describe a memory location with DW_OP_deref or if the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="">/// expression is too complex to interpret.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="">static std::optional<int64_t></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="uncoveredLine">getDerefOffsetInBytes(const DIExpression *DIExpr) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="uncoveredLine">  int64_t Offset = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="uncoveredLine">  const unsigned NumElements = DIExpr->getNumElements();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="uncoveredLine">  const auto Elements = DIExpr->getElements();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="uncoveredLine">  unsigned ExpectedDerefIdx = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="">  // Extract the offset.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="uncoveredLine">  if (NumElements > 2 && Elements[0] == dwarf::DW_OP_plus_uconst) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="uncoveredLine">    Offset = Elements[1];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="uncoveredLine">    ExpectedDerefIdx = 2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="uncoveredLine">  } else if (NumElements > 3 && Elements[0] == dwarf::DW_OP_constu) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="uncoveredLine">    ExpectedDerefIdx = 3;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="uncoveredLine">    if (Elements[2] == dwarf::DW_OP_plus)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="uncoveredLine">      Offset = Elements[1];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="uncoveredLine">    else if (Elements[2] == dwarf::DW_OP_minus)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="uncoveredLine">      Offset = -Elements[1];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="uncoveredLine">      return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="">  // If that's all there is it means there's no deref.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="uncoveredLine">  if (ExpectedDerefIdx >= NumElements)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="uncoveredLine">    return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="">  // Check the next element is DW_OP_deref - otherwise this is too complex or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="">  // isn't a deref expression.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="uncoveredLine">  if (Elements[ExpectedDerefIdx] != dwarf::DW_OP_deref)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="uncoveredLine">    return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="">  // Check the final operation is either the DW_OP_deref or is a fragment.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="uncoveredLine">  if (NumElements == ExpectedDerefIdx + 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="uncoveredLine">    return Offset; // Ends with deref.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="uncoveredLine">  unsigned ExpectedFragFirstIdx = ExpectedDerefIdx + 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="uncoveredLine">  unsigned ExpectedFragFinalIdx = ExpectedFragFirstIdx + 2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="uncoveredLine">  if (NumElements == ExpectedFragFinalIdx + 1 &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="uncoveredLine">      Elements[ExpectedFragFirstIdx] == dwarf::DW_OP_LLVM_fragment)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="uncoveredLine">    return Offset; // Ends with deref + fragment.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="">  // Don't bother trying to interpret anything more complex.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="uncoveredLine">  return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="">/// A whole (unfragmented) source variable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="">using DebugAggregate = std::pair<const DILocalVariable *, const DILocation *>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="uncoveredLine">static DebugAggregate getAggregate(const DbgVariableIntrinsic *DII) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="uncoveredLine">  return DebugAggregate(DII->getVariable(), DII->getDebugLoc().getInlinedAt());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="uncoveredLine">static DebugAggregate getAggregate(const DebugVariable &Var) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="uncoveredLine">  return DebugAggregate(Var.getVariable(), Var.getInlinedAt());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="uncoveredLine">static bool shouldCoalesceFragments(Function &F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="">  // Enabling fragment coalescing reduces compiler run time when instruction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="">  // referencing is enabled. However, it may cause LiveDebugVariables to create</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="">  // incorrect locations. Since instruction-referencing mode effectively</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="">  // bypasses LiveDebugVariables we only enable coalescing if the cl::opt flag</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="">  // has not been explicitly set and instruction-referencing is turned on.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="uncoveredLine">  switch (CoalesceAdjacentFragmentsOpt) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="uncoveredLine">  case cl::boolOrDefault::BOU_UNSET:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="uncoveredLine">    return debuginfoShouldUseDebugInstrRef(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="uncoveredLine">        Triple(F.getParent()->getTargetTriple()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="uncoveredLine">  case cl::boolOrDefault::BOU_TRUE:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="uncoveredLine">  case cl::boolOrDefault::BOU_FALSE:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="uncoveredLine">  llvm_unreachable("Unknown boolOrDefault value");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="">namespace {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="">/// In dwarf emission, the following sequence</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="">///    1. dbg.value ... Fragment(0, 64)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="">///    2. dbg.value ... Fragment(0, 32)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="">/// effectively sets Fragment(32, 32) to undef (each def sets all bits not in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="">/// the intersection of the fragments to having "no location"). This makes</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="">/// sense for implicit location values because splitting the computed values</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="">/// could be troublesome, and is probably quite uncommon.  When we convert</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="">/// dbg.assigns to dbg.value+deref this kind of thing is common, and describing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="">/// a location (memory) rather than a value means we don't need to worry about</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="">/// splitting any values, so we try to recover the rest of the fragment</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="">/// location here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="">/// This class performs a(nother) dataflow analysis over the function, adding</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="">/// variable locations so that any bits of a variable with a memory location</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="">/// have that location explicitly reinstated at each subsequent variable</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="">/// location definition that that doesn't overwrite those bits. i.e. after a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="">/// variable location def, insert new defs for the memory location with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="">/// fragments for the difference of "all bits currently in memory" and "the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="">/// fragment of the second def".</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="">class MemLocFragmentFill {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="">  Function &Fn;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="">  FunctionVarLocsBuilder *FnVarLocs;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="">  const DenseSet<DebugAggregate> *VarsWithStackSlot;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="">  bool CoalesceAdjacentFragments;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="">  // 0 = no memory location.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="">  using BaseAddress = unsigned;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="">  using OffsetInBitsTy = unsigned;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="">  using FragTraits = IntervalMapHalfOpenInfo<OffsetInBitsTy>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="">  using FragsInMemMap = IntervalMap<</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="">      OffsetInBitsTy, BaseAddress,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="">      IntervalMapImpl::NodeSizer<OffsetInBitsTy, BaseAddress>::LeafSize,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="">      FragTraits>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="">  FragsInMemMap::Allocator IntervalMapAlloc;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="">  using VarFragMap = DenseMap<unsigned, FragsInMemMap>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="">  /// IDs for memory location base addresses in maps. Use 0 to indicate that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="">  /// there's no memory location.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="">  UniqueVector<RawLocationWrapper> Bases;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="">  UniqueVector<DebugAggregate> Aggregates;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="">  DenseMap<const BasicBlock *, VarFragMap> LiveIn;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="">  DenseMap<const BasicBlock *, VarFragMap> LiveOut;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="">  struct FragMemLoc {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="">    unsigned Var;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="">    unsigned Base;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="">    unsigned OffsetInBits;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="">    unsigned SizeInBits;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="">    DebugLoc DL;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="">  using InsertMap = MapVector<Instruction *, SmallVector<FragMemLoc>>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="">  /// BBInsertBeforeMap holds a description for the set of location defs to be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="">  /// inserted after the analysis is complete. It is updated during the dataflow</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="">  /// and the entry for a block is CLEARED each time it is (re-)visited. After</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="">  /// the dataflow is complete, each block entry will contain the set of defs</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="">  /// calculated during the final (fixed-point) iteration.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="">  DenseMap<const BasicBlock *, InsertMap> BBInsertBeforeMap;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="uncoveredLine">  static bool intervalMapsAreEqual(const FragsInMemMap &A,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="">                                   const FragsInMemMap &B) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="uncoveredLine">    auto AIt = A.begin(), AEnd = A.end();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="uncoveredLine">    auto BIt = B.begin(), BEnd = B.end();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="uncoveredLine">    for (; AIt != AEnd; ++AIt, ++BIt) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="uncoveredLine">      if (BIt == BEnd)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="uncoveredLine">        return false; // B has fewer elements than A.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="uncoveredLine">      if (AIt.start() != BIt.start() || AIt.stop() != BIt.stop())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="uncoveredLine">        return false; // Interval is different.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="uncoveredLine">      if (*AIt != *BIt)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="uncoveredLine">        return false; // Value at interval is different.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="">    // AIt == AEnd. Check BIt is also now at end.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="uncoveredLine">    return BIt == BEnd;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="uncoveredLine">  static bool varFragMapsAreEqual(const VarFragMap &A, const VarFragMap &B) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="uncoveredLine">    if (A.size() != B.size())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="uncoveredLine">    for (const auto &APair : A) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="uncoveredLine">      auto BIt = B.find(APair.first);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="uncoveredLine">      if (BIt == B.end())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="uncoveredLine">        return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="uncoveredLine">      if (!intervalMapsAreEqual(APair.second, BIt->second))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="uncoveredLine">        return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="">  /// Return a string for the value that \p BaseID represents.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="uncoveredLine">  std::string toString(unsigned BaseID) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="uncoveredLine">    if (BaseID)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="uncoveredLine">      return Bases[BaseID].getVariableLocationOp(0)->getName().str();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="uncoveredLine">      return "None";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="">  /// Format string describing an FragsInMemMap (IntervalMap) interval.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="uncoveredLine">  std::string toString(FragsInMemMap::const_iterator It, bool Newline = true) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="uncoveredLine">    std::string String;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="uncoveredLine">    std::stringstream S(String);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="uncoveredLine">    if (It.valid()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="uncoveredLine">      S << "[" << It.start() << ", " << It.stop()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="uncoveredLine">        << "): " << toString(It.value());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="uncoveredLine">      S << "invalid iterator (end)";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="uncoveredLine">    if (Newline)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="uncoveredLine">      S << "\n";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="uncoveredLine">    return S.str();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="uncoveredLine">  FragsInMemMap meetFragments(const FragsInMemMap &A, const FragsInMemMap &B) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="uncoveredLine">    FragsInMemMap Result(IntervalMapAlloc);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="uncoveredLine">    for (auto AIt = A.begin(), AEnd = A.end(); AIt != AEnd; ++AIt) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "a " << toString(AIt));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="">      // This is basically copied from process() and inverted (process is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="">      // performing something like a union whereas this is more of an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="">      // intersect).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="">      // There's no work to do if interval `a` overlaps no fragments in map `B`.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="uncoveredLine">      if (!B.overlaps(AIt.start(), AIt.stop()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="">      // Does StartBit intersect an existing fragment?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="uncoveredLine">      auto FirstOverlap = B.find(AIt.start());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="uncoveredLine">      assert(FirstOverlap != B.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="uncoveredLine">      bool IntersectStart = FirstOverlap.start() < AIt.start();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "- FirstOverlap " << toString(FirstOverlap, false)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="">                        << ", IntersectStart: " << IntersectStart << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="">      // Does EndBit intersect an existing fragment?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="uncoveredLine">      auto LastOverlap = B.find(AIt.stop());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="">      bool IntersectEnd =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="uncoveredLine">          LastOverlap != B.end() && LastOverlap.start() < AIt.stop();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "- LastOverlap " << toString(LastOverlap, false)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="">                        << ", IntersectEnd: " << IntersectEnd << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="">      // Check if both ends of `a` intersect the same interval `b`.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="uncoveredLine">      if (IntersectStart && IntersectEnd && FirstOverlap == LastOverlap) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="">        // Insert `a` (`a` is contained in `b`) if the values match.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="">        // [ a ]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="">        // [ - b - ]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="">        // -</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="">        // [ r ]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="uncoveredLine">        LLVM_DEBUG(dbgs() << "- a is contained within "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="">                          << toString(FirstOverlap));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="uncoveredLine">        if (*AIt && *AIt == *FirstOverlap)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="uncoveredLine">          Result.insert(AIt.start(), AIt.stop(), *AIt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="">        // There's an overlap but `a` is not fully contained within</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="">        // `b`. Shorten any end-point intersections.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="">        //     [ - a - ]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="">        // [ - b - ]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="">        // -</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="">        //     [ r ]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="uncoveredLine">        auto Next = FirstOverlap;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="uncoveredLine">        if (IntersectStart) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="uncoveredLine">          LLVM_DEBUG(dbgs() << "- insert intersection of a and "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="">                            << toString(FirstOverlap));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="uncoveredLine">          if (*AIt && *AIt == *FirstOverlap)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="uncoveredLine">            Result.insert(AIt.start(), FirstOverlap.stop(), *AIt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="uncoveredLine">          ++Next;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="">        // [ - a - ]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="">        //     [ - b - ]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="">        // -</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="">        //     [ r ]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="uncoveredLine">        if (IntersectEnd) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="uncoveredLine">          LLVM_DEBUG(dbgs() << "- insert intersection of a and "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="">                            << toString(LastOverlap));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="uncoveredLine">          if (*AIt && *AIt == *LastOverlap)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="uncoveredLine">            Result.insert(LastOverlap.start(), AIt.stop(), *AIt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="">        // Insert all intervals in map `B` that are contained within interval</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="">        // `a` where the values match.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="">        // [ -  - a -  - ]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="">        // [ b1 ]   [ b2 ]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="">        // -</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="">        // [ r1 ]   [ r2 ]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="uncoveredLine">        while (Next != B.end() && Next.start() < AIt.stop() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="uncoveredLine">               Next.stop() <= AIt.stop()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="uncoveredLine">          LLVM_DEBUG(dbgs()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="">                     << "- insert intersection of a and " << toString(Next));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="uncoveredLine">          if (*AIt && *AIt == *Next)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="uncoveredLine">            Result.insert(Next.start(), Next.stop(), *Next);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="uncoveredLine">          ++Next;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="uncoveredLine">      }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="uncoveredLine">    return Result;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="">  /// Meet \p A and \p B, storing the result in \p A.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="uncoveredLine">  void meetVars(VarFragMap &A, const VarFragMap &B) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="">    // Meet A and B.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="">    // Result = meet(a, b) for a in A, b in B where Var(a) == Var(b)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="uncoveredLine">    for (auto It = A.begin(), End = A.end(); It != End; ++It) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="uncoveredLine">      unsigned AVar = It->first;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="uncoveredLine">      FragsInMemMap &AFrags = It->second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="uncoveredLine">      auto BIt = B.find(AVar);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="uncoveredLine">      if (BIt == B.end()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="uncoveredLine">        A.erase(It);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="uncoveredLine">        continue; // Var has no bits defined in B.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "meet fragment maps for "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="">                        << Aggregates[AVar].first->getName() << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="uncoveredLine">      AFrags = meetFragments(AFrags, BIt->second);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="uncoveredLine">  bool meet(const BasicBlock &BB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="">            const SmallPtrSet<BasicBlock *, 16> &Visited) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "meet block info from preds of " << BB.getName()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="">                      << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="uncoveredLine">    VarFragMap BBLiveIn;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="uncoveredLine">    bool FirstMeet = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="">    // LiveIn locs for BB is the meet of the already-processed preds' LiveOut</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="">    // locs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="uncoveredLine">    for (auto I = pred_begin(&BB), E = pred_end(&BB); I != E; I++) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="">      // Ignore preds that haven't been processed yet. This is essentially the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="">      // same as initialising all variables to implicit top value (⊤) which is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="">      // the identity value for the meet operation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="uncoveredLine">      const BasicBlock *Pred = *I;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="uncoveredLine">      if (!Visited.count(Pred))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="uncoveredLine">      auto PredLiveOut = LiveOut.find(Pred);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="uncoveredLine">      assert(PredLiveOut != LiveOut.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="uncoveredLine">      if (FirstMeet) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="uncoveredLine">        LLVM_DEBUG(dbgs() << "BBLiveIn = " << Pred->getName() << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="uncoveredLine">        BBLiveIn = PredLiveOut->second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="uncoveredLine">        FirstMeet = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="uncoveredLine">        LLVM_DEBUG(dbgs() << "BBLiveIn = meet BBLiveIn, " << Pred->getName()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="">                          << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="uncoveredLine">        meetVars(BBLiveIn, PredLiveOut->second);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="">      // An empty set is ⊥ for the intersect-like meet operation. If we've</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="">      // already got ⊥ there's no need to run the code - we know the result is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="">      // ⊥ since `meet(a, ⊥) = ⊥`.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="uncoveredLine">      if (BBLiveIn.size() == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="uncoveredLine">    auto CurrentLiveInEntry = LiveIn.find(&BB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="">    // If there's no LiveIn entry for the block yet, add it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="uncoveredLine">    if (CurrentLiveInEntry == LiveIn.end()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "change=true (first) on meet on " << BB.getName()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="">                        << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="uncoveredLine">      LiveIn[&BB] = std::move(BBLiveIn);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="uncoveredLine">      return /*Changed=*/true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="">    // If the LiveIn set has changed (expensive check) update it and return</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="">    // true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="uncoveredLine">    if (!varFragMapsAreEqual(BBLiveIn, CurrentLiveInEntry->second)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "change=true on meet on " << BB.getName() << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="uncoveredLine">      CurrentLiveInEntry->second = std::move(BBLiveIn);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="uncoveredLine">      return /*Changed=*/true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "change=false on meet on " << BB.getName() << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="uncoveredLine">    return /*Changed=*/false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="uncoveredLine">  void insertMemLoc(BasicBlock &BB, Instruction &Before, unsigned Var,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="">                    unsigned StartBit, unsigned EndBit, unsigned Base,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="">                    DebugLoc DL) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="uncoveredLine">    assert(StartBit < EndBit && "Cannot create fragment of size <= 0");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="uncoveredLine">    if (!Base)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="uncoveredLine">      return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="uncoveredLine">    FragMemLoc Loc;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="uncoveredLine">    Loc.Var = Var;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="uncoveredLine">    Loc.OffsetInBits = StartBit;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="uncoveredLine">    Loc.SizeInBits = EndBit - StartBit;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="uncoveredLine">    assert(Base && "Expected a non-zero ID for Base address");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="uncoveredLine">    Loc.Base = Base;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="uncoveredLine">    Loc.DL = DL;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="uncoveredLine">    BBInsertBeforeMap[&BB][&Before].push_back(Loc);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "Add mem def for " << Aggregates[Var].first->getName()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="">                      << " bits [" << StartBit << ", " << EndBit << ")\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="">  /// Inserts a new dbg def if the interval found when looking up \p StartBit</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="">  /// in \p FragMap starts before \p StartBit or ends after \p EndBit (which</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="">  /// indicates - assuming StartBit->EndBit has just been inserted - that the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="">  /// slice has been coalesced in the map).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="uncoveredLine">  void coalesceFragments(BasicBlock &BB, Instruction &Before, unsigned Var,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="">                         unsigned StartBit, unsigned EndBit, unsigned Base,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="">                         DebugLoc DL, const FragsInMemMap &FragMap) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="uncoveredLine">    if (!CoalesceAdjacentFragments)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="uncoveredLine">      return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="">    // We've inserted the location into the map. The map will have coalesced</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="">    // adjacent intervals (variable fragments) that describe the same memory</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="">    // location. Use this knowledge to insert a debug location that describes</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="">    // that coalesced fragment. This may eclipse other locs we've just</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="">    // inserted. This is okay as redundant locs will be cleaned up later.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="uncoveredLine">    auto CoalescedFrag = FragMap.find(StartBit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="">    // Bail if no coalescing has taken place.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="uncoveredLine">    if (CoalescedFrag.start() == StartBit && CoalescedFrag.stop() == EndBit)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="uncoveredLine">      return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "- Insert loc for bits " << CoalescedFrag.start()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="">                      << " to " << CoalescedFrag.stop() << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="uncoveredLine">    insertMemLoc(BB, Before, Var, CoalescedFrag.start(), CoalescedFrag.stop(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="">                 Base, DL);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="uncoveredLine">  void addDef(const VarLocInfo &VarLoc, Instruction &Before, BasicBlock &BB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="">              VarFragMap &LiveSet) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="uncoveredLine">    DebugVariable DbgVar = FnVarLocs->getVariable(VarLoc.VariableID);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="uncoveredLine">    if (skipVariable(DbgVar.getVariable()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="uncoveredLine">      return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="">    // Don't bother doing anything for this variables if we know it's fully</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="">    // promoted. We're only interested in variables that (sometimes) live on</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="">    // the stack here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="uncoveredLine">    if (!VarsWithStackSlot->count(getAggregate(DbgVar)))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="uncoveredLine">      return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="uncoveredLine">    unsigned Var = Aggregates.insert(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="uncoveredLine">        DebugAggregate(DbgVar.getVariable(), VarLoc.DL.getInlinedAt()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="">    // [StartBit: EndBit) are the bits affected by this def.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="uncoveredLine">    const DIExpression *DIExpr = VarLoc.Expr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="">    unsigned StartBit;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="">    unsigned EndBit;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="uncoveredLine">    if (auto Frag = DIExpr->getFragmentInfo()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="uncoveredLine">      StartBit = Frag->OffsetInBits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="uncoveredLine">      EndBit = StartBit + Frag->SizeInBits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="uncoveredLine">      assert(static_cast<bool>(DbgVar.getVariable()->getSizeInBits()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="uncoveredLine">      StartBit = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="uncoveredLine">      EndBit = *DbgVar.getVariable()->getSizeInBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="">    // We will only fill fragments for simple memory-describing dbg.value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="">    // intrinsics. If the fragment offset is the same as the offset from the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="">    // base pointer, do The Thing, otherwise fall back to normal dbg.value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="">    // behaviour. AssignmentTrackingLowering has generated DIExpressions</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="">    // written in terms of the base pointer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="">    // TODO: Remove this condition since the fragment offset doesn't always</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="">    // equal the offset from base pointer (e.g. for a SROA-split variable).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="uncoveredLine">    const auto DerefOffsetInBytes = getDerefOffsetInBytes(DIExpr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="">    const unsigned Base =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="uncoveredLine">        DerefOffsetInBytes && *DerefOffsetInBytes * 8 == StartBit</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="uncoveredLine">            ? Bases.insert(VarLoc.Values)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="uncoveredLine">            : 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "DEF " << DbgVar.getVariable()->getName() << " ["</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="">                      << StartBit << ", " << EndBit << "): " << toString(Base)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="">                      << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="">    // First of all, any locs that use mem that are disrupted need reinstating.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="">    // Unfortunately, IntervalMap doesn't let us insert intervals that overlap</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="">    // with existing intervals so this code involves a lot of fiddling around</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="">    // with intervals to do that manually.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="uncoveredLine">    auto FragIt = LiveSet.find(Var);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="">    // Check if the variable does not exist in the map.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="uncoveredLine">    if (FragIt == LiveSet.end()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="">      // Add this variable to the BB map.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="uncoveredLine">      auto P = LiveSet.try_emplace(Var, FragsInMemMap(IntervalMapAlloc));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="uncoveredLine">      assert(P.second && "Var already in map?");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="">      // Add the interval to the fragment map.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="uncoveredLine">      P.first->second.insert(StartBit, EndBit, Base);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="uncoveredLine">      return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="">    // The variable has an entry in the map.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="uncoveredLine">    FragsInMemMap &FragMap = FragIt->second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="">    // First check the easy case: the new fragment `f` doesn't overlap with any</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="">    // intervals.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="uncoveredLine">    if (!FragMap.overlaps(StartBit, EndBit)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "- No overlaps\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="uncoveredLine">      FragMap.insert(StartBit, EndBit, Base);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="uncoveredLine">      coalesceFragments(BB, Before, Var, StartBit, EndBit, Base, VarLoc.DL,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="">                        FragMap);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="uncoveredLine">      return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="">    // There is at least one overlap.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="">    // Does StartBit intersect an existing fragment?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="uncoveredLine">    auto FirstOverlap = FragMap.find(StartBit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="uncoveredLine">    assert(FirstOverlap != FragMap.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="uncoveredLine">    bool IntersectStart = FirstOverlap.start() < StartBit;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="">    // Does EndBit intersect an existing fragment?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="uncoveredLine">    auto LastOverlap = FragMap.find(EndBit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="uncoveredLine">    bool IntersectEnd = LastOverlap.valid() && LastOverlap.start() < EndBit;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="">    // Check if both ends of `f` intersect the same interval `i`.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="uncoveredLine">    if (IntersectStart && IntersectEnd && FirstOverlap == LastOverlap) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "- Intersect single interval @ both ends\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="">      // Shorten `i` so that there's space to insert `f`.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="">      //      [ f ]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="">      // [  -   i   -  ]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="">      // +</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="">      // [ i ][ f ][ i ]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="">      // Save values for use after inserting a new interval.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="uncoveredLine">      auto EndBitOfOverlap = FirstOverlap.stop();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="uncoveredLine">      unsigned OverlapValue = FirstOverlap.value();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="">      // Shorten the overlapping interval.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="uncoveredLine">      FirstOverlap.setStop(StartBit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="uncoveredLine">      insertMemLoc(BB, Before, Var, FirstOverlap.start(), StartBit,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="uncoveredLine">                   OverlapValue, VarLoc.DL);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="">      // Insert a new interval to represent the end part.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="uncoveredLine">      FragMap.insert(EndBit, EndBitOfOverlap, OverlapValue);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="uncoveredLine">      insertMemLoc(BB, Before, Var, EndBit, EndBitOfOverlap, OverlapValue,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="uncoveredLine">                   VarLoc.DL);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="">      // Insert the new (middle) fragment now there is space.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="uncoveredLine">      FragMap.insert(StartBit, EndBit, Base);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="">      // There's an overlap but `f` may not be fully contained within</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="">      // `i`. Shorten any end-point intersections so that we can then</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="">      // insert `f`.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="">      //      [ - f - ]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="">      // [ - i - ]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="">      // |   |</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="">      // [ i ]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="">      // Shorten any end-point intersections.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="uncoveredLine">      if (IntersectStart) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="uncoveredLine">        LLVM_DEBUG(dbgs() << "- Intersect interval at start\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="">        // Split off at the intersection.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="uncoveredLine">        FirstOverlap.setStop(StartBit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="uncoveredLine">        insertMemLoc(BB, Before, Var, FirstOverlap.start(), StartBit,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="uncoveredLine">                     *FirstOverlap, VarLoc.DL);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="">      // [ - f - ]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="">      //      [ - i - ]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="">      //          |   |</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="">      //          [ i ]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="uncoveredLine">      if (IntersectEnd) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="uncoveredLine">        LLVM_DEBUG(dbgs() << "- Intersect interval at end\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="">        // Split off at the intersection.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="uncoveredLine">        LastOverlap.setStart(EndBit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="uncoveredLine">        insertMemLoc(BB, Before, Var, EndBit, LastOverlap.stop(), *LastOverlap,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="uncoveredLine">                     VarLoc.DL);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "- Erase intervals contained within\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="">      // FirstOverlap and LastOverlap have been shortened such that they're</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="">      // no longer overlapping with [StartBit, EndBit). Delete any overlaps</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="">      // that remain (these will be fully contained within `f`).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="">      // [ - f - ]       }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="">      //      [ - i - ]  } Intersection shortening that has happened above.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="">      //          |   |  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="">      //          [ i ]  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="">      // -----------------</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="">      // [i2 ]           } Intervals fully contained within `f` get erased.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="">      // -----------------</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="">      // [ - f - ][ i ]  } Completed insertion.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="uncoveredLine">      auto It = FirstOverlap;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="uncoveredLine">      if (IntersectStart)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="uncoveredLine">        ++It; // IntersectStart: first overlap has been shortened.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="uncoveredLine">      while (It.valid() && It.start() >= StartBit && It.stop() <= EndBit) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="uncoveredLine">        LLVM_DEBUG(dbgs() << "- Erase " << toString(It));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="uncoveredLine">        It.erase(); // This increments It after removing the interval.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="">      // We've dealt with all the overlaps now!</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="uncoveredLine">      assert(!FragMap.overlaps(StartBit, EndBit));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "- Insert DEF into now-empty space\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="uncoveredLine">      FragMap.insert(StartBit, EndBit, Base);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="uncoveredLine">    coalesceFragments(BB, Before, Var, StartBit, EndBit, Base, VarLoc.DL,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="">                      FragMap);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="uncoveredLine">  bool skipVariable(const DILocalVariable *V) { return !V->getSizeInBits(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="uncoveredLine">  void process(BasicBlock &BB, VarFragMap &LiveSet) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="uncoveredLine">    BBInsertBeforeMap[&BB].clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="uncoveredLine">    for (auto &I : BB) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="uncoveredLine">      if (const auto *Locs = FnVarLocs->getWedge(&I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="uncoveredLine">        for (const VarLocInfo &Loc : *Locs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="uncoveredLine">          addDef(Loc, I, *I.getParent(), LiveSet);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="uncoveredLine">  MemLocFragmentFill(Function &Fn,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="">                     const DenseSet<DebugAggregate> *VarsWithStackSlot,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="">                     bool CoalesceAdjacentFragments)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="uncoveredLine">      : Fn(Fn), VarsWithStackSlot(VarsWithStackSlot),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="uncoveredLine">        CoalesceAdjacentFragments(CoalesceAdjacentFragments) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="">  /// Add variable locations to \p FnVarLocs so that any bits of a variable</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="">  /// with a memory location have that location explicitly reinstated at each</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="">  /// subsequent variable location definition that that doesn't overwrite those</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="">  /// bits. i.e. after a variable location def, insert new defs for the memory</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="">  /// location with fragments for the difference of "all bits currently in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="">  /// memory" and "the fragment of the second def". e.g.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="">  ///     Before:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="">  ///     var x bits 0 to 63:  value in memory</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="">  ///     more instructions</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="">  ///     var x bits 0 to 31:  value is %0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="">  ///     After:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="">  ///     var x bits 0 to 63:  value in memory</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="">  ///     more instructions</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="">  ///     var x bits 0 to 31:  value is %0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="">  ///     var x bits 32 to 61: value in memory ; <-- new loc def</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="uncoveredLine">  void run(FunctionVarLocsBuilder *FnVarLocs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="uncoveredLine">    if (!EnableMemLocFragFill)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="uncoveredLine">      return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="uncoveredLine">    this->FnVarLocs = FnVarLocs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="">    // Prepare for traversal.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="uncoveredLine">    ReversePostOrderTraversal<Function *> RPOT(&Fn);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="">    std::priority_queue<unsigned int, std::vector<unsigned int>,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="">                        std::greater<unsigned int>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="uncoveredLine">        Worklist;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="">    std::priority_queue<unsigned int, std::vector<unsigned int>,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="">                        std::greater<unsigned int>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="uncoveredLine">        Pending;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="uncoveredLine">    DenseMap<unsigned int, BasicBlock *> OrderToBB;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="uncoveredLine">    DenseMap<BasicBlock *, unsigned int> BBToOrder;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="">    { // Init OrderToBB and BBToOrder.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="uncoveredLine">      unsigned int RPONumber = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="uncoveredLine">      for (auto RI = RPOT.begin(), RE = RPOT.end(); RI != RE; ++RI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="uncoveredLine">        OrderToBB[RPONumber] = *RI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="uncoveredLine">        BBToOrder[*RI] = RPONumber;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="uncoveredLine">        Worklist.push(RPONumber);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="uncoveredLine">        ++RPONumber;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="uncoveredLine">      LiveIn.init(RPONumber);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="uncoveredLine">      LiveOut.init(RPONumber);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="">    // Perform the traversal.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="">    // This is a standard "intersect of predecessor outs" dataflow problem. To</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="">    // solve it, we perform meet() and process() using the two worklist method</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="">    // until the LiveIn data for each block becomes unchanging.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="">    // This dataflow is essentially working on maps of sets and at each meet we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="">    // intersect the maps and the mapped sets. So, initialized live-in maps</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="">    // monotonically decrease in value throughout the dataflow.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="uncoveredLine">    SmallPtrSet<BasicBlock *, 16> Visited;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="uncoveredLine">    while (!Worklist.empty() || !Pending.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="">      // We track what is on the pending worklist to avoid inserting the same</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="">      // thing twice.  We could avoid this with a custom priority queue, but</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="">      // this is probably not worth it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="uncoveredLine">      SmallPtrSet<BasicBlock *, 16> OnPending;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "Processing Worklist\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="uncoveredLine">      while (!Worklist.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="uncoveredLine">        BasicBlock *BB = OrderToBB[Worklist.top()];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="uncoveredLine">        LLVM_DEBUG(dbgs() << "\nPop BB " << BB->getName() << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="uncoveredLine">        Worklist.pop();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="uncoveredLine">        bool InChanged = meet(*BB, Visited);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="">        // Always consider LiveIn changed on the first visit.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="uncoveredLine">        InChanged |= Visited.insert(BB).second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="uncoveredLine">        if (InChanged) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="uncoveredLine">          LLVM_DEBUG(dbgs()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="">                     << BB->getName() << " has new InLocs, process it\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="">          //  Mutate a copy of LiveIn while processing BB. Once we've processed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="">          //  the terminator LiveSet is the LiveOut set for BB.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="">          //  This is an expensive copy!</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="uncoveredLine">          VarFragMap LiveSet = LiveIn[BB];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="">          // Process the instructions in the block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="uncoveredLine">          process(*BB, LiveSet);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="">          // Relatively expensive check: has anything changed in LiveOut for BB?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="uncoveredLine">          if (!varFragMapsAreEqual(LiveOut[BB], LiveSet)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="uncoveredLine">            LLVM_DEBUG(dbgs() << BB->getName()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="">                              << " has new OutLocs, add succs to worklist: [ ");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="uncoveredLine">            LiveOut[BB] = std::move(LiveSet);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="uncoveredLine">            for (auto I = succ_begin(BB), E = succ_end(BB); I != E; I++) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="uncoveredLine">              if (OnPending.insert(*I).second) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="uncoveredLine">                LLVM_DEBUG(dbgs() << I->getName() << " ");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="uncoveredLine">                Pending.push(BBToOrder[*I]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="">              }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="">            }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="uncoveredLine">            LLVM_DEBUG(dbgs() << "]\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="uncoveredLine">        }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="uncoveredLine">      Worklist.swap(Pending);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="">      // At this point, pending must be empty, since it was just the empty</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="">      // worklist</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="uncoveredLine">      assert(Pending.empty() && "Pending should be empty");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="">    // Insert new location defs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="uncoveredLine">    for (auto &Pair : BBInsertBeforeMap) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="uncoveredLine">      InsertMap &Map = Pair.second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="uncoveredLine">      for (auto &Pair : Map) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="uncoveredLine">        Instruction *InsertBefore = Pair.first;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="uncoveredLine">        assert(InsertBefore && "should never be null");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="uncoveredLine">        auto FragMemLocs = Pair.second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="uncoveredLine">        auto &Ctx = Fn.getContext();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="uncoveredLine">        for (auto &FragMemLoc : FragMemLocs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="uncoveredLine">          DIExpression *Expr = DIExpression::get(Ctx, std::nullopt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="uncoveredLine">          if (FragMemLoc.SizeInBits !=</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="uncoveredLine">              *Aggregates[FragMemLoc.Var].first->getSizeInBits())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="uncoveredLine">            Expr = *DIExpression::createFragmentExpression(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="uncoveredLine">                Expr, FragMemLoc.OffsetInBits, FragMemLoc.SizeInBits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="uncoveredLine">          Expr = DIExpression::prepend(Expr, DIExpression::DerefAfter,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="uncoveredLine">                                       FragMemLoc.OffsetInBits / 8);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="uncoveredLine">          DebugVariable Var(Aggregates[FragMemLoc.Var].first, Expr,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="uncoveredLine">                            FragMemLoc.DL.getInlinedAt());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="uncoveredLine">          FnVarLocs->addVarLoc(InsertBefore, Var, Expr, FragMemLoc.DL,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="uncoveredLine">                               Bases[FragMemLoc.Base]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="uncoveredLine">      }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="">/// AssignmentTrackingLowering encapsulates a dataflow analysis over a function</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="">/// that interprets assignment tracking debug info metadata and stores in IR to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="">/// create a map of variable locations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="">class AssignmentTrackingLowering {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="">  /// The kind of location in use for a variable, where Mem is the stack home,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="">  /// Val is an SSA value or const, and None means that there is not one single</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="">  /// kind (either because there are multiple or because there is none; it may</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="">  /// prove useful to split this into two values in the future).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="">  /// LocKind is a join-semilattice with the partial order:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="">  /// None > Mem, Val</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="">  /// i.e.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="">  /// join(Mem, Mem)   = Mem</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="">  /// join(Val, Val)   = Val</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="">  /// join(Mem, Val)   = None</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="">  /// join(None, Mem)  = None</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="">  /// join(None, Val)  = None</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="">  /// join(None, None) = None</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="">  /// Note: the order is not `None > Val > Mem` because we're using DIAssignID</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="">  /// to name assignments and are not tracking the actual stored values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="">  /// Therefore currently there's no way to ensure that Mem values and Val</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="">  /// values are the same. This could be a future extension, though it's not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="">  /// clear that many additional locations would be recovered that way in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="">  /// practice as the likelihood of this sitation arising naturally seems</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="">  /// incredibly low.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="">  enum class LocKind { Mem, Val, None };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="">  /// An abstraction of the assignment of a value to a variable or memory</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="">  /// location.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="">  /// An Assignment is Known or NoneOrPhi. A Known Assignment means we have a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="">  /// DIAssignID ptr that represents it. NoneOrPhi means that we don't (or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="">  /// can't) know the ID of the last assignment that took place.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="">  /// The Status of the Assignment (Known or NoneOrPhi) is another</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="">  /// join-semilattice. The partial order is:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="">  /// NoneOrPhi > Known {id_0, id_1, ...id_N}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="">  /// i.e. for all values x and y where x != y:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="">  /// join(x, x) = x</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="">  /// join(x, y) = NoneOrPhi</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="">  struct Assignment {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="">    enum S { Known, NoneOrPhi } Status;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="">    /// ID of the assignment. nullptr if Status is not Known.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="">    DIAssignID *ID;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="">    /// The dbg.assign that marks this dbg-def. Mem-defs don't use this field.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="">    /// May be nullptr.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="">    DbgAssignIntrinsic *Source;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="uncoveredLine">    bool isSameSourceAssignment(const Assignment &Other) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="">      // Don't include Source in the equality check. Assignments are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="">      // defined by their ID, not debug intrinsic(s).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="uncoveredLine">      return std::tie(Status, ID) == std::tie(Other.Status, Other.ID);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="uncoveredLine">    void dump(raw_ostream &OS) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="">      static const char *LUT[] = {"Known", "NoneOrPhi"};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="uncoveredLine">      OS << LUT[Status] << "(id=";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="uncoveredLine">      if (ID)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="uncoveredLine">        OS << ID;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="">      else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="uncoveredLine">        OS << "null";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="uncoveredLine">      OS << ", s=";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="uncoveredLine">      if (Source)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="uncoveredLine">        OS << *Source;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="">      else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="uncoveredLine">        OS << "null";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="uncoveredLine">      OS << ")";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="uncoveredLine">    static Assignment make(DIAssignID *ID, DbgAssignIntrinsic *Source) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="uncoveredLine">      return Assignment(Known, ID, Source);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="uncoveredLine">    static Assignment makeFromMemDef(DIAssignID *ID) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="uncoveredLine">      return Assignment(Known, ID, nullptr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="uncoveredLine">    static Assignment makeNoneOrPhi() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="uncoveredLine">      return Assignment(NoneOrPhi, nullptr, nullptr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="">    // Again, need a Top value?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="">    Assignment()</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="">        : Status(NoneOrPhi), ID(nullptr), Source(nullptr) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="">    } // Can we delete this?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="uncoveredLine">    Assignment(S Status, DIAssignID *ID, DbgAssignIntrinsic *Source)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="uncoveredLine">        : Status(Status), ID(ID), Source(Source) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="">      // If the Status is Known then we expect there to be an assignment ID.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="uncoveredLine">      assert(Status == NoneOrPhi || ID);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="">  using AssignmentMap = SmallVector<Assignment>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="">  using LocMap = SmallVector<LocKind>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="">  using OverlapMap = DenseMap<VariableID, SmallVector<VariableID>>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="">  using UntaggedStoreAssignmentMap =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="">      DenseMap<const Instruction *,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="">               SmallVector<std::pair<VariableID, at::AssignmentInfo>>>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="">  /// The highest numbered VariableID for partially promoted variables plus 1,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="">  /// the values for which start at 1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="">  unsigned TrackedVariablesVectorSize = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="">  /// Map a variable to the set of variables that it fully contains.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="">  OverlapMap VarContains;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="">  /// Map untagged stores to the variable fragments they assign to. Used by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="">  /// processUntaggedInstruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="">  UntaggedStoreAssignmentMap UntaggedStoreVars;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="">  // Machinery to defer inserting dbg.values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="">  using InsertMap = MapVector<Instruction *, SmallVector<VarLocInfo>>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="">  InsertMap InsertBeforeMap;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="">  /// Clear the location definitions currently cached for insertion after /p</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="">  /// After.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="">  void resetInsertionPoint(Instruction &After);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="">  void emitDbgValue(LocKind Kind, const DbgVariableIntrinsic *Source,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="">                    Instruction *After);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="uncoveredLine">  static bool mapsAreEqual(const BitVector &Mask, const AssignmentMap &A,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="">                           const AssignmentMap &B) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="uncoveredLine">    return llvm::all_of(Mask.set_bits(), [&](unsigned VarID) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="uncoveredLine">      return A[VarID].isSameSourceAssignment(B[VarID]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="uncoveredLine">    });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="">  /// Represents the stack and debug assignments in a block. Used to describe</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="">  /// the live-in and live-out values for blocks, as well as the "current"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="">  /// value as we process each instruction in a block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="">  struct BlockInfo {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="">    /// The set of variables (VariableID) being tracked in this block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="">    BitVector VariableIDsInBlock;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="">    /// Dominating assignment to memory for each variable, indexed by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="">    /// VariableID.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="">    AssignmentMap StackHomeValue;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="">    /// Dominating assignemnt to each variable, indexed by VariableID.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="">    AssignmentMap DebugValue;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="">    /// Location kind for each variable. LiveLoc indicates whether the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="">    /// dominating assignment in StackHomeValue (LocKind::Mem), DebugValue</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="">    /// (LocKind::Val), or neither (LocKind::None) is valid, in that order of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="">    /// preference. This cannot be derived by inspecting DebugValue and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="">    /// StackHomeValue due to the fact that there's no distinction in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="">    /// Assignment (the class) between whether an assignment is unknown or a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="">    /// merge of multiple assignments (both are Status::NoneOrPhi). In other</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="">    /// words, the memory location may well be valid while both DebugValue and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="">    /// StackHomeValue contain Assignments that have a Status of NoneOrPhi.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="">    /// Indexed by VariableID.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="">    LocMap LiveLoc;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="">  public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="">    enum AssignmentKind { Stack, Debug };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="uncoveredLine">    const AssignmentMap &getAssignmentMap(AssignmentKind Kind) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="uncoveredLine">      switch (Kind) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="uncoveredLine">      case Stack:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="uncoveredLine">        return StackHomeValue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="uncoveredLine">      case Debug:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="uncoveredLine">        return DebugValue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="uncoveredLine">      llvm_unreachable("Unknown AssignmentKind");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="uncoveredLine">    AssignmentMap &getAssignmentMap(AssignmentKind Kind) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="">      return const_cast<AssignmentMap &>(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="uncoveredLine">          const_cast<const BlockInfo *>(this)->getAssignmentMap(Kind));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="uncoveredLine">    bool isVariableTracked(VariableID Var) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="uncoveredLine">      return VariableIDsInBlock[static_cast<unsigned>(Var)];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="uncoveredLine">    const Assignment &getAssignment(AssignmentKind Kind, VariableID Var) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="uncoveredLine">      assert(isVariableTracked(Var) && "Var not tracked in block");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="uncoveredLine">      return getAssignmentMap(Kind)[static_cast<unsigned>(Var)];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="uncoveredLine">    LocKind getLocKind(VariableID Var) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="uncoveredLine">      assert(isVariableTracked(Var) && "Var not tracked in block");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="uncoveredLine">      return LiveLoc[static_cast<unsigned>(Var)];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="">    /// Set LocKind for \p Var only: does not set LocKind for VariableIDs of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="">    /// fragments contained win \p Var.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="uncoveredLine">    void setLocKind(VariableID Var, LocKind K) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="uncoveredLine">      VariableIDsInBlock.set(static_cast<unsigned>(Var));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="uncoveredLine">      LiveLoc[static_cast<unsigned>(Var)] = K;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="">    /// Set the assignment in the \p Kind assignment map for \p Var only: does</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="">    /// not set the assignment for VariableIDs of fragments contained win \p</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="">    /// Var.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="uncoveredLine">    void setAssignment(AssignmentKind Kind, VariableID Var,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="">                       const Assignment &AV) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="uncoveredLine">      VariableIDsInBlock.set(static_cast<unsigned>(Var));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="uncoveredLine">      getAssignmentMap(Kind)[static_cast<unsigned>(Var)] = AV;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="">    /// Return true if there is an assignment matching \p AV in the \p Kind</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="">    /// assignment map. Does consider assignments for VariableIDs of fragments</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="">    /// contained win \p Var.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="uncoveredLine">    bool hasAssignment(AssignmentKind Kind, VariableID Var,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="">                       const Assignment &AV) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="uncoveredLine">      if (!isVariableTracked(Var))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="uncoveredLine">        return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="uncoveredLine">      return AV.isSameSourceAssignment(getAssignment(Kind, Var));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="">    /// Compare every element in each map to determine structural equality</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="">    /// (slow).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="uncoveredLine">    bool operator==(const BlockInfo &Other) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="uncoveredLine">      return VariableIDsInBlock == Other.VariableIDsInBlock &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="uncoveredLine">             LiveLoc == Other.LiveLoc &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="uncoveredLine">             mapsAreEqual(VariableIDsInBlock, StackHomeValue,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="uncoveredLine">                          Other.StackHomeValue) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="uncoveredLine">             mapsAreEqual(VariableIDsInBlock, DebugValue, Other.DebugValue);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="uncoveredLine">    bool operator!=(const BlockInfo &Other) const { return !(*this == Other); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="uncoveredLine">    bool isValid() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="uncoveredLine">      return LiveLoc.size() == DebugValue.size() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="uncoveredLine">             LiveLoc.size() == StackHomeValue.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="">    /// Clear everything and initialise with ⊤-values for all variables.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="uncoveredLine">    void init(int NumVars) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="uncoveredLine">      StackHomeValue.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="uncoveredLine">      DebugValue.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="uncoveredLine">      LiveLoc.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="uncoveredLine">      VariableIDsInBlock = BitVector(NumVars);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="uncoveredLine">      StackHomeValue.insert(StackHomeValue.begin(), NumVars,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="uncoveredLine">                            Assignment::makeNoneOrPhi());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="uncoveredLine">      DebugValue.insert(DebugValue.begin(), NumVars,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="uncoveredLine">                        Assignment::makeNoneOrPhi());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="uncoveredLine">      LiveLoc.insert(LiveLoc.begin(), NumVars, LocKind::None);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="">    /// Helper for join.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="">    template <typename ElmtType, typename FnInputType></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="uncoveredLine">    static void joinElmt(int Index, SmallVector<ElmtType> &Target,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="">                         const SmallVector<ElmtType> &A,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="">                         const SmallVector<ElmtType> &B,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="">                         ElmtType (*Fn)(FnInputType, FnInputType)) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="uncoveredLine">      Target[Index] = Fn(A[Index], B[Index]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="">    /// See comment for AssignmentTrackingLowering::joinBlockInfo.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="uncoveredLine">    static BlockInfo join(const BlockInfo &A, const BlockInfo &B, int NumVars) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="">      // Join A and B.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="">      //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="">      // Intersect = join(a, b) for a in A, b in B where Var(a) == Var(b)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="">      // Difference = join(x, ⊤) for x where Var(x) is in A xor B</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="">      // Join = Intersect ∪ Difference</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="">      //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="">      // This is achieved by performing a join on elements from A and B with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="">      // variables common to both A and B (join elements indexed by var</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="">      // intersect), then adding ⊤-value elements for vars in A xor B. The</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="">      // latter part is equivalent to performing join on elements with variables</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="">      // in A xor B with the ⊤-value for the map element since join(x, ⊤) = ⊤.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="">      // BlockInfo::init initializes all variable entries to the ⊤ value so we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="">      // don't need to explicitly perform that step as Join.VariableIDsInBlock</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="">      // is set to the union of the variables in A and B at the end of this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="">      // function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="uncoveredLine">      BlockInfo Join;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="uncoveredLine">      Join.init(NumVars);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="uncoveredLine">      BitVector Intersect = A.VariableIDsInBlock;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="uncoveredLine">      Intersect &= B.VariableIDsInBlock;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="uncoveredLine">      for (auto VarID : Intersect.set_bits()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="uncoveredLine">        joinElmt(VarID, Join.LiveLoc, A.LiveLoc, B.LiveLoc, joinKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="uncoveredLine">        joinElmt(VarID, Join.DebugValue, A.DebugValue, B.DebugValue,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="">                 joinAssignment);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="uncoveredLine">        joinElmt(VarID, Join.StackHomeValue, A.StackHomeValue, B.StackHomeValue,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="">                 joinAssignment);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="uncoveredLine">      Join.VariableIDsInBlock = A.VariableIDsInBlock;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="uncoveredLine">      Join.VariableIDsInBlock |= B.VariableIDsInBlock;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="uncoveredLine">      assert(Join.isValid());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="uncoveredLine">      return Join;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="">  Function &Fn;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="">  const DataLayout &Layout;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="">  const DenseSet<DebugAggregate> *VarsWithStackSlot;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="">  FunctionVarLocsBuilder *FnVarLocs;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="">  DenseMap<const BasicBlock *, BlockInfo> LiveIn;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="">  DenseMap<const BasicBlock *, BlockInfo> LiveOut;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="">  /// Helper for process methods to track variables touched each frame.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="">  DenseSet<VariableID> VarsTouchedThisFrame;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="">  /// The set of variables that sometimes are not located in their stack home.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="">  DenseSet<DebugAggregate> NotAlwaysStackHomed;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="uncoveredLine">  VariableID getVariableID(const DebugVariable &Var) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="uncoveredLine">    return static_cast<VariableID>(FnVarLocs->insertVariable(Var));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="">  /// Join the LiveOut values of preds that are contained in \p Visited into</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="">  /// LiveIn[BB]. Return True if LiveIn[BB] has changed as a result. LiveIn[BB]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="">  /// values monotonically increase. See the @link joinMethods join methods</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="">  /// @endlink documentation for more info.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="">  bool join(const BasicBlock &BB, const SmallPtrSet<BasicBlock *, 16> &Visited);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="">  ///@name joinMethods</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="">  /// Functions that implement `join` (the least upper bound) for the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="">  /// join-semilattice types used in the dataflow. There is an explicit bottom</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="">  /// value (⊥) for some types and and explicit top value (⊤) for all types.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="">  /// By definition:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="">  ///     Join(A, B) >= A && Join(A, B) >= B</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="">  ///     Join(A, ⊥) = A</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="">  ///     Join(A, ⊤) = ⊤</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="">  /// These invariants are important for monotonicity.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="">  /// For the map-type functions, all unmapped keys in an empty map are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="">  /// associated with a bottom value (⊥). This represents their values being</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="">  /// unknown. Unmapped keys in non-empty maps (joining two maps with a key</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="">  /// only present in one) represents either a variable going out of scope or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="">  /// dropped debug info. It is assumed the key is associated with a top value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="">  /// (⊤) in this case (unknown location / assignment).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="">  ///@{</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="">  static LocKind joinKind(LocKind A, LocKind B);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="">  static Assignment joinAssignment(const Assignment &A, const Assignment &B);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="">  BlockInfo joinBlockInfo(const BlockInfo &A, const BlockInfo &B);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="">  ///@}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="">  /// Process the instructions in \p BB updating \p LiveSet along the way. \p</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="">  /// LiveSet must be initialized with the current live-in locations before</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="">  /// calling this.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="">  void process(BasicBlock &BB, BlockInfo *LiveSet);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="">  ///@name processMethods</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="">  /// Methods to process instructions in order to update the LiveSet (current</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="">  /// location information).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="">  ///@{</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="">  void processNonDbgInstruction(Instruction &I, BlockInfo *LiveSet);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="">  void processDbgInstruction(DbgInfoIntrinsic &I, BlockInfo *LiveSet);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="">  /// Update \p LiveSet after encountering an instruction with a DIAssignID</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="">  /// attachment, \p I.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="">  void processTaggedInstruction(Instruction &I, BlockInfo *LiveSet);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="">  /// Update \p LiveSet after encountering an instruciton without a DIAssignID</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="">  /// attachment, \p I.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="">  void processUntaggedInstruction(Instruction &I, BlockInfo *LiveSet);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="">  void processDbgAssign(DbgAssignIntrinsic &DAI, BlockInfo *LiveSet);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="">  void processDbgValue(DbgValueInst &DVI, BlockInfo *LiveSet);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="">  /// Add an assignment to memory for the variable /p Var.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="">  void addMemDef(BlockInfo *LiveSet, VariableID Var, const Assignment &AV);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="">  /// Add an assignment to the variable /p Var.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="">  void addDbgDef(BlockInfo *LiveSet, VariableID Var, const Assignment &AV);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="">  ///@}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="">  /// Set the LocKind for \p Var.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="">  void setLocKind(BlockInfo *LiveSet, VariableID Var, LocKind K);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="">  /// Get the live LocKind for a \p Var. Requires addMemDef or addDbgDef to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="">  /// have been called for \p Var first.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="">  LocKind getLocKind(BlockInfo *LiveSet, VariableID Var);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="">  /// Return true if \p Var has an assignment in \p M matching \p AV.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="">  bool hasVarWithAssignment(BlockInfo *LiveSet, BlockInfo::AssignmentKind Kind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="">                            VariableID Var, const Assignment &AV);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="">  /// Return the set of VariableIDs corresponding the fragments contained fully</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="">  /// within the variable/fragment \p Var.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="">  ArrayRef<VariableID> getContainedFragments(VariableID Var) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="">  /// Mark \p Var as having been touched this frame. Note, this applies only</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="">  /// to the exact fragment \p Var and not to any fragments contained within.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="">  void touchFragment(VariableID Var);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="">  /// Emit info for variables that are fully promoted.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="">  bool emitPromotedVarLocs(FunctionVarLocsBuilder *FnVarLocs);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="uncoveredLine">  AssignmentTrackingLowering(Function &Fn, const DataLayout &Layout,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="">                             const DenseSet<DebugAggregate> *VarsWithStackSlot)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="uncoveredLine">      : Fn(Fn), Layout(Layout), VarsWithStackSlot(VarsWithStackSlot) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="">  /// Run the analysis, adding variable location info to \p FnVarLocs. Returns</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="">  /// true if any variable locations have been added to FnVarLocs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="">  bool run(FunctionVarLocsBuilder *FnVarLocs);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="">} // namespace</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="">ArrayRef<VariableID></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="uncoveredLine">AssignmentTrackingLowering::getContainedFragments(VariableID Var) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="uncoveredLine">  auto R = VarContains.find(Var);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="uncoveredLine">  if (R == VarContains.end())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="uncoveredLine">    return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="uncoveredLine">  return R->second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="uncoveredLine">void AssignmentTrackingLowering::touchFragment(VariableID Var) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="uncoveredLine">  VarsTouchedThisFrame.insert(Var);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="uncoveredLine">void AssignmentTrackingLowering::setLocKind(BlockInfo *LiveSet, VariableID Var,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="">                                            LocKind K) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="uncoveredLine">  auto SetKind = [this](BlockInfo *LiveSet, VariableID Var, LocKind K) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="uncoveredLine">    LiveSet->setLocKind(Var, K);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="uncoveredLine">    touchFragment(Var);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="uncoveredLine">  SetKind(LiveSet, Var, K);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="">  // Update the LocKind for all fragments contained within Var.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="uncoveredLine">  for (VariableID Frag : getContainedFragments(Var))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="uncoveredLine">    SetKind(LiveSet, Frag, K);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="">AssignmentTrackingLowering::LocKind</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="uncoveredLine">AssignmentTrackingLowering::getLocKind(BlockInfo *LiveSet, VariableID Var) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="uncoveredLine">  return LiveSet->getLocKind(Var);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="uncoveredLine">void AssignmentTrackingLowering::addMemDef(BlockInfo *LiveSet, VariableID Var,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="">                                           const Assignment &AV) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="uncoveredLine">  LiveSet->setAssignment(BlockInfo::Stack, Var, AV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="">  // Use this assigment for all fragments contained within Var, but do not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="">  // provide a Source because we cannot convert Var's value to a value for the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="">  // fragment.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="uncoveredLine">  Assignment FragAV = AV;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="uncoveredLine">  FragAV.Source = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="uncoveredLine">  for (VariableID Frag : getContainedFragments(Var))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="uncoveredLine">    LiveSet->setAssignment(BlockInfo::Stack, Frag, FragAV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="uncoveredLine">void AssignmentTrackingLowering::addDbgDef(BlockInfo *LiveSet, VariableID Var,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="">                                           const Assignment &AV) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="uncoveredLine">  LiveSet->setAssignment(BlockInfo::Debug, Var, AV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="">  // Use this assigment for all fragments contained within Var, but do not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="">  // provide a Source because we cannot convert Var's value to a value for the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="">  // fragment.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="uncoveredLine">  Assignment FragAV = AV;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="uncoveredLine">  FragAV.Source = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="uncoveredLine">  for (VariableID Frag : getContainedFragments(Var))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="uncoveredLine">    LiveSet->setAssignment(BlockInfo::Debug, Frag, FragAV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="uncoveredLine">static DIAssignID *getIDFromInst(const Instruction &I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="uncoveredLine">  return cast<DIAssignID>(I.getMetadata(LLVMContext::MD_DIAssignID));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="uncoveredLine">static DIAssignID *getIDFromMarker(const DbgAssignIntrinsic &DAI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="uncoveredLine">  return cast<DIAssignID>(DAI.getAssignID());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="">/// Return true if \p Var has an assignment in \p M matching \p AV.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="uncoveredLine">bool AssignmentTrackingLowering::hasVarWithAssignment(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="">    BlockInfo *LiveSet, BlockInfo::AssignmentKind Kind, VariableID Var,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="">    const Assignment &AV) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="uncoveredLine">  if (!LiveSet->hasAssignment(Kind, Var, AV))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="">  // Check all the frags contained within Var as these will have all been</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="">  // mapped to AV at the last store to Var.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="uncoveredLine">  for (VariableID Frag : getContainedFragments(Var))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="uncoveredLine">    if (!LiveSet->hasAssignment(Kind, Frag, AV))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="">#ifndef NDEBUG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="uncoveredLine">const char *locStr(AssignmentTrackingLowering::LocKind Loc) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="">  using LocKind = AssignmentTrackingLowering::LocKind;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="uncoveredLine">  switch (Loc) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="uncoveredLine">  case LocKind::Val:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="uncoveredLine">    return "Val";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="uncoveredLine">  case LocKind::Mem:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="uncoveredLine">    return "Mem";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="uncoveredLine">  case LocKind::None:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="uncoveredLine">    return "None";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="uncoveredLine">  llvm_unreachable("unknown LocKind");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="uncoveredLine">void AssignmentTrackingLowering::emitDbgValue(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="">    AssignmentTrackingLowering::LocKind Kind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="">    const DbgVariableIntrinsic *Source, Instruction *After) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="uncoveredLine">  DILocation *DL = Source->getDebugLoc();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="uncoveredLine">  auto Emit = [this, Source, After, DL](Metadata *Val, DIExpression *Expr) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="uncoveredLine">    assert(Expr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="uncoveredLine">    if (!Val)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="uncoveredLine">      Val = ValueAsMetadata::get(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="uncoveredLine">          PoisonValue::get(Type::getInt1Ty(Source->getContext())));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="">    // Find a suitable insert point.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="uncoveredLine">    Instruction *InsertBefore = After->getNextNode();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="uncoveredLine">    assert(InsertBefore && "Shouldn't be inserting after a terminator");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="uncoveredLine">    VariableID Var = getVariableID(DebugVariable(Source));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="uncoveredLine">    VarLocInfo VarLoc;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="uncoveredLine">    VarLoc.VariableID = static_cast<VariableID>(Var);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="uncoveredLine">    VarLoc.Expr = Expr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="uncoveredLine">    VarLoc.Values = RawLocationWrapper(Val);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="uncoveredLine">    VarLoc.DL = DL;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="">    // Insert it into the map for later.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="uncoveredLine">    InsertBeforeMap[InsertBefore].push_back(VarLoc);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="">  // NOTE: This block can mutate Kind.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="uncoveredLine">  if (Kind == LocKind::Mem) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="uncoveredLine">    const auto *DAI = cast<DbgAssignIntrinsic>(Source);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="">    // Check the address hasn't been dropped (e.g. the debug uses may not have</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="">    // been replaced before deleting a Value).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="uncoveredLine">    if (DAI->isKillAddress()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="">      // The address isn't valid so treat this as a non-memory def.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="uncoveredLine">      Kind = LocKind::Val;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="uncoveredLine">      Value *Val = DAI->getAddress();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="uncoveredLine">      DIExpression *Expr = DAI->getAddressExpression();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="uncoveredLine">      assert(!Expr->getFragmentInfo() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="">             "fragment info should be stored in value-expression only");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="">      // Copy the fragment info over from the value-expression to the new</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="">      // DIExpression.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="uncoveredLine">      if (auto OptFragInfo = Source->getExpression()->getFragmentInfo()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="uncoveredLine">        auto FragInfo = *OptFragInfo;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="uncoveredLine">        Expr = *DIExpression::createFragmentExpression(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="uncoveredLine">            Expr, FragInfo.OffsetInBits, FragInfo.SizeInBits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="">      // The address-expression has an implicit deref, add it now.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="uncoveredLine">      std::tie(Val, Expr) =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="uncoveredLine">          walkToAllocaAndPrependOffsetDeref(Layout, Val, Expr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="uncoveredLine">      Emit(ValueAsMetadata::get(Val), Expr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="uncoveredLine">      return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="uncoveredLine">  if (Kind == LocKind::Val) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="uncoveredLine">    Emit(Source->getRawLocation(), Source->getExpression());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="uncoveredLine">  if (Kind == LocKind::None) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="uncoveredLine">    Emit(nullptr, Source->getExpression());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="uncoveredLine">void AssignmentTrackingLowering::processNonDbgInstruction(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="">    Instruction &I, AssignmentTrackingLowering::BlockInfo *LiveSet) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="uncoveredLine">  if (I.hasMetadata(LLVMContext::MD_DIAssignID))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="uncoveredLine">    processTaggedInstruction(I, LiveSet);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="uncoveredLine">    processUntaggedInstruction(I, LiveSet);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="uncoveredLine">void AssignmentTrackingLowering::processUntaggedInstruction(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="">    Instruction &I, AssignmentTrackingLowering::BlockInfo *LiveSet) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="">  // Interpret stack stores that are not tagged as an assignment in memory for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="">  // the variables associated with that address. These stores may not be tagged</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="">  // because a) the store cannot be represented using dbg.assigns (non-const</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="">  // length or offset) or b) the tag was accidentally dropped during</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="">  // optimisations. For these stores we fall back to assuming that the stack</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="">  // home is a valid location for the variables. The benefit is that this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="">  // prevents us missing an assignment and therefore incorrectly maintaining</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="">  // earlier location definitions, and in many cases it should be a reasonable</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="">  // assumption. However, this will occasionally lead to slight</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="">  // inaccuracies. The value of a hoisted untagged store will be visible</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="">  // "early", for example.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="uncoveredLine">  assert(!I.hasMetadata(LLVMContext::MD_DIAssignID));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="uncoveredLine">  auto It = UntaggedStoreVars.find(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="uncoveredLine">  if (It == UntaggedStoreVars.end())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="uncoveredLine">    return; // No variables associated with the store destination.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "processUntaggedInstruction on UNTAGGED INST " << I</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="">                    << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="">  // Iterate over the variables that this store affects, add a NoneOrPhi dbg</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="">  // and mem def, set lockind to Mem, and emit a location def for each.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="uncoveredLine">  for (auto [Var, Info] : It->second) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="">    // This instruction is treated as both a debug and memory assignment,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="">    // meaning the memory location should be used. We don't have an assignment</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="">    // ID though so use Assignment::makeNoneOrPhi() to create an imaginary one.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="uncoveredLine">    addMemDef(LiveSet, Var, Assignment::makeNoneOrPhi());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="uncoveredLine">    addDbgDef(LiveSet, Var, Assignment::makeNoneOrPhi());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="uncoveredLine">    setLocKind(LiveSet, Var, LocKind::Mem);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "  setting Stack LocKind to: " << locStr(LocKind::Mem)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="">                      << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="">    // Build the dbg location def to insert.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="">    // DIExpression: Add fragment and offset.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="uncoveredLine">    DebugVariable V = FnVarLocs->getVariable(Var);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="uncoveredLine">    DIExpression *DIE = DIExpression::get(I.getContext(), std::nullopt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="uncoveredLine">    if (auto Frag = V.getFragment()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="uncoveredLine">      auto R = DIExpression::createFragmentExpression(DIE, Frag->OffsetInBits,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="uncoveredLine">                                                      Frag->SizeInBits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="uncoveredLine">      assert(R && "unexpected createFragmentExpression failure");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="uncoveredLine">      DIE = *R;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="uncoveredLine">    SmallVector<uint64_t, 3> Ops;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="uncoveredLine">    if (Info.OffsetInBits)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="uncoveredLine">      Ops = {dwarf::DW_OP_plus_uconst, Info.OffsetInBits / 8};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="uncoveredLine">    Ops.push_back(dwarf::DW_OP_deref);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="uncoveredLine">    DIE = DIExpression::prependOpcodes(DIE, Ops, /*StackValue=*/false,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="">                                       /*EntryValue=*/false);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="">    // Find a suitable insert point.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="uncoveredLine">    Instruction *InsertBefore = I.getNextNode();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="uncoveredLine">    assert(InsertBefore && "Shouldn't be inserting after a terminator");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="">    // Get DILocation for this unrecorded assignment.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="uncoveredLine">    DILocation *InlinedAt = const_cast<DILocation *>(V.getInlinedAt());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="uncoveredLine">    const DILocation *DILoc = DILocation::get(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="uncoveredLine">        Fn.getContext(), 0, 0, V.getVariable()->getScope(), InlinedAt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="uncoveredLine">    VarLocInfo VarLoc;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="uncoveredLine">    VarLoc.VariableID = static_cast<VariableID>(Var);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="uncoveredLine">    VarLoc.Expr = DIE;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="uncoveredLine">    VarLoc.Values = RawLocationWrapper(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="uncoveredLine">        ValueAsMetadata::get(const_cast<AllocaInst *>(Info.Base)));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="uncoveredLine">    VarLoc.DL = DILoc;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="">    // 3. Insert it into the map for later.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="uncoveredLine">    InsertBeforeMap[InsertBefore].push_back(VarLoc);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="uncoveredLine">void AssignmentTrackingLowering::processTaggedInstruction(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="">    Instruction &I, AssignmentTrackingLowering::BlockInfo *LiveSet) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="uncoveredLine">  auto Linked = at::getAssignmentMarkers(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="">  // No dbg.assign intrinsics linked.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="">  // FIXME: All vars that have a stack slot this store modifies that don't have</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="">  // a dbg.assign linked to it should probably treat this like an untagged</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="">  // store.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="uncoveredLine">  if (Linked.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "processTaggedInstruction on " << I << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="uncoveredLine">  for (DbgAssignIntrinsic *DAI : Linked) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="uncoveredLine">    VariableID Var = getVariableID(DebugVariable(DAI));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="">    // Something has gone wrong if VarsWithStackSlot doesn't contain a variable</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="">    // that is linked to a store.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="uncoveredLine">    assert(VarsWithStackSlot->count(getAggregate(DAI)) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="">           "expected DAI's variable to have stack slot");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="uncoveredLine">    Assignment AV = Assignment::makeFromMemDef(getIDFromInst(I));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="uncoveredLine">    addMemDef(LiveSet, Var, AV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "   linked to " << *DAI << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "   LiveLoc " << locStr(getLocKind(LiveSet, Var))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="">                      << " -> ");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="">    // The last assignment to the stack is now AV. Check if the last debug</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="">    // assignment has a matching Assignment.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="uncoveredLine">    if (hasVarWithAssignment(LiveSet, BlockInfo::Debug, Var, AV)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="">      // The StackHomeValue and DebugValue for this variable match so we can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="">      // emit a stack home location here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "Mem, Stack matches Debug program\n";);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "   Stack val: "; AV.dump(dbgs()); dbgs() << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "   Debug val: ";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="">                 LiveSet->DebugValue[static_cast<unsigned>(Var)].dump(dbgs());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="">                 dbgs() << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="uncoveredLine">      setLocKind(LiveSet, Var, LocKind::Mem);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="uncoveredLine">      emitDbgValue(LocKind::Mem, DAI, &I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="">    // The StackHomeValue and DebugValue for this variable do not match. I.e.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="">    // The value currently stored in the stack is not what we'd expect to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="">    // see, so we cannot use emit a stack home location here. Now we will</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="">    // look at the live LocKind for the variable and determine an appropriate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="">    // dbg.value to emit.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="uncoveredLine">    LocKind PrevLoc = getLocKind(LiveSet, Var);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="uncoveredLine">    switch (PrevLoc) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="uncoveredLine">    case LocKind::Val: {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="">      // The value in memory in memory has changed but we're not currently</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="">      // using the memory location. Do nothing.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "Val, (unchanged)\n";);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="uncoveredLine">      setLocKind(LiveSet, Var, LocKind::Val);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="uncoveredLine">    } break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="uncoveredLine">    case LocKind::Mem: {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="">      // There's been an assignment to memory that we were using as a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="">      // location for this variable, and the Assignment doesn't match what</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="">      // we'd expect to see in memory.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="uncoveredLine">      Assignment DbgAV = LiveSet->getAssignment(BlockInfo::Debug, Var);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="uncoveredLine">      if (DbgAV.Status == Assignment::NoneOrPhi) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="">        // We need to terminate any previously open location now.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="uncoveredLine">        LLVM_DEBUG(dbgs() << "None, No Debug value available\n";);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="uncoveredLine">        setLocKind(LiveSet, Var, LocKind::None);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="uncoveredLine">        emitDbgValue(LocKind::None, DAI, &I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="">        // The previous DebugValue Value can be used here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="uncoveredLine">        LLVM_DEBUG(dbgs() << "Val, Debug value is Known\n";);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="uncoveredLine">        setLocKind(LiveSet, Var, LocKind::Val);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="uncoveredLine">        if (DbgAV.Source) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="uncoveredLine">          emitDbgValue(LocKind::Val, DbgAV.Source, &I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="">        } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="">          // PrevAV.Source is nullptr so we must emit undef here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="uncoveredLine">          emitDbgValue(LocKind::None, DAI, &I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="uncoveredLine">    } break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="uncoveredLine">    case LocKind::None: {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="">      // There's been an assignment to memory and we currently are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="">      // not tracking a location for the variable. Do not emit anything.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "None, (unchanged)\n";);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="uncoveredLine">      setLocKind(LiveSet, Var, LocKind::None);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="uncoveredLine">    } break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="uncoveredLine">void AssignmentTrackingLowering::processDbgAssign(DbgAssignIntrinsic &DAI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="">                                                  BlockInfo *LiveSet) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="">  // Only bother tracking variables that are at some point stack homed. Other</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="">  // variables can be dealt with trivially later.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="uncoveredLine">  if (!VarsWithStackSlot->count(getAggregate(&DAI)))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="uncoveredLine">  VariableID Var = getVariableID(DebugVariable(&DAI));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="uncoveredLine">  Assignment AV = Assignment::make(getIDFromMarker(DAI), &DAI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="uncoveredLine">  addDbgDef(LiveSet, Var, AV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "processDbgAssign on " << DAI << "\n";);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "   LiveLoc " << locStr(getLocKind(LiveSet, Var))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="">                    << " -> ");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="">  // Check if the DebugValue and StackHomeValue both hold the same</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="">  // Assignment.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="uncoveredLine">  if (hasVarWithAssignment(LiveSet, BlockInfo::Stack, Var, AV)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="">    // They match. We can use the stack home because the debug intrinsics state</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="">    // that an assignment happened here, and we know that specific assignment</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="">    // was the last one to take place in memory for this variable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="">    LocKind Kind;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="uncoveredLine">    if (DAI.isKillAddress()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="uncoveredLine">      LLVM_DEBUG(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="">          dbgs()</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="">              << "Val, Stack matches Debug program but address is killed\n";);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="uncoveredLine">      Kind = LocKind::Val;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "Mem, Stack matches Debug program\n";);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="uncoveredLine">      Kind = LocKind::Mem;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="">    };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="uncoveredLine">    setLocKind(LiveSet, Var, Kind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="uncoveredLine">    emitDbgValue(Kind, &DAI, &DAI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="">    // The last assignment to the memory location isn't the one that we want to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="">    // show to the user so emit a dbg.value(Value). Value may be undef.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "Val, Stack contents is unknown\n";);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="uncoveredLine">    setLocKind(LiveSet, Var, LocKind::Val);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="uncoveredLine">    emitDbgValue(LocKind::Val, &DAI, &DAI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="uncoveredLine">void AssignmentTrackingLowering::processDbgValue(DbgValueInst &DVI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="">                                                 BlockInfo *LiveSet) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="">  // Only other tracking variables that are at some point stack homed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="">  // Other variables can be dealt with trivally later.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="uncoveredLine">  if (!VarsWithStackSlot->count(getAggregate(&DVI)))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="uncoveredLine">  VariableID Var = getVariableID(DebugVariable(&DVI));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="">  // We have no ID to create an Assignment with so we mark this assignment as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="">  // NoneOrPhi. Note that the dbg.value still exists, we just cannot determine</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="">  // the assignment responsible for setting this value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="">  // This is fine; dbg.values are essentially interchangable with unlinked</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="">  // dbg.assigns, and some passes such as mem2reg and instcombine add them to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="">  // PHIs for promoted variables.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="uncoveredLine">  Assignment AV = Assignment::makeNoneOrPhi();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="uncoveredLine">  addDbgDef(LiveSet, Var, AV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "processDbgValue on " << DVI << "\n";);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "   LiveLoc " << locStr(getLocKind(LiveSet, Var))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="">                    << " -> Val, dbg.value override");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="uncoveredLine">  setLocKind(LiveSet, Var, LocKind::Val);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="uncoveredLine">  emitDbgValue(LocKind::Val, &DVI, &DVI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="uncoveredLine">static bool hasZeroSizedFragment(DbgVariableIntrinsic &DVI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="uncoveredLine">  if (auto F = DVI.getExpression()->getFragmentInfo())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="uncoveredLine">    return F->SizeInBits == 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="uncoveredLine">void AssignmentTrackingLowering::processDbgInstruction(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="">    DbgInfoIntrinsic &I, AssignmentTrackingLowering::BlockInfo *LiveSet) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="uncoveredLine">  auto *DVI = dyn_cast<DbgVariableIntrinsic>(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="uncoveredLine">  if (!DVI)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="">  // Ignore assignments to zero bits of the variable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="uncoveredLine">  if (hasZeroSizedFragment(*DVI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="uncoveredLine">  if (auto *DAI = dyn_cast<DbgAssignIntrinsic>(&I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="uncoveredLine">    processDbgAssign(*DAI, LiveSet);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="uncoveredLine">  else if (auto *DVI = dyn_cast<DbgValueInst>(&I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="uncoveredLine">    processDbgValue(*DVI, LiveSet);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="uncoveredLine">void AssignmentTrackingLowering::resetInsertionPoint(Instruction &After) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="uncoveredLine">  assert(!After.isTerminator() && "Can't insert after a terminator");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="uncoveredLine">  auto R = InsertBeforeMap.find(After.getNextNode());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="uncoveredLine">  if (R == InsertBeforeMap.end())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="uncoveredLine">  R->second.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="uncoveredLine">void AssignmentTrackingLowering::process(BasicBlock &BB, BlockInfo *LiveSet) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="uncoveredLine">  for (auto II = BB.begin(), EI = BB.end(); II != EI;) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="uncoveredLine">    assert(VarsTouchedThisFrame.empty());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="">    // Process the instructions in "frames". A "frame" includes a single</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="">    // non-debug instruction followed any debug instructions before the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="">    // next non-debug instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="uncoveredLine">    if (!isa<DbgInfoIntrinsic>(&*II)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="uncoveredLine">      if (II->isTerminator())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="uncoveredLine">      resetInsertionPoint(*II);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="uncoveredLine">      processNonDbgInstruction(*II, LiveSet);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="uncoveredLine">      assert(LiveSet->isValid());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="uncoveredLine">      ++II;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="uncoveredLine">    while (II != EI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="uncoveredLine">      auto *Dbg = dyn_cast<DbgInfoIntrinsic>(&*II);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="uncoveredLine">      if (!Dbg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="uncoveredLine">      resetInsertionPoint(*II);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="uncoveredLine">      processDbgInstruction(*Dbg, LiveSet);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="uncoveredLine">      assert(LiveSet->isValid());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="uncoveredLine">      ++II;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="">    // We've processed everything in the "frame". Now determine which variables</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="">    // cannot be represented by a dbg.declare.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="uncoveredLine">    for (auto Var : VarsTouchedThisFrame) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="uncoveredLine">      LocKind Loc = getLocKind(LiveSet, Var);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="">      // If a variable's LocKind is anything other than LocKind::Mem then we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="">      // must note that it cannot be represented with a dbg.declare.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="">      // Note that this check is enough without having to check the result of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="">      // joins() because for join to produce anything other than Mem after</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="">      // we've already seen a Mem we'd be joining None or Val with Mem. In that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="">      // case, we've already hit this codepath when we set the LocKind to Val</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="">      // or None in that block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="uncoveredLine">      if (Loc != LocKind::Mem) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="uncoveredLine">        DebugVariable DbgVar = FnVarLocs->getVariable(Var);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="uncoveredLine">        DebugAggregate Aggr{DbgVar.getVariable(), DbgVar.getInlinedAt()};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="uncoveredLine">        NotAlwaysStackHomed.insert(Aggr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="uncoveredLine">    VarsTouchedThisFrame.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="">AssignmentTrackingLowering::LocKind</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="uncoveredLine">AssignmentTrackingLowering::joinKind(LocKind A, LocKind B) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="">  // Partial order:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="">  // None > Mem, Val</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="uncoveredLine">  return A == B ? A : LocKind::None;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="">AssignmentTrackingLowering::Assignment</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="uncoveredLine">AssignmentTrackingLowering::joinAssignment(const Assignment &A,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="">                                           const Assignment &B) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="">  // Partial order:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="">  // NoneOrPhi(null, null) > Known(v, ?s)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="">  // If either are NoneOrPhi the join is NoneOrPhi.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="">  // If either value is different then the result is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="">  // NoneOrPhi (joining two values is a Phi).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="uncoveredLine">  if (!A.isSameSourceAssignment(B))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="uncoveredLine">    return Assignment::makeNoneOrPhi();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="uncoveredLine">  if (A.Status == Assignment::NoneOrPhi)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="uncoveredLine">    return Assignment::makeNoneOrPhi();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="">  // Source is used to lookup the value + expression in the debug program if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="">  // the stack slot gets assigned a value earlier than expected. Because</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="">  // we're only tracking the one dbg.assign, we can't capture debug PHIs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="">  // It's unlikely that we're losing out on much coverage by avoiding that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="">  // extra work.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="">  // The Source may differ in this situation:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="">  // Pred.1:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="">  //   dbg.assign i32 0, ..., !1, ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="">  // Pred.2:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="">  //   dbg.assign i32 1, ..., !1, ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="">  // Here the same assignment (!1) was performed in both preds in the source,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="">  // but we can't use either one unless they are identical (e.g. .we don't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="">  // want to arbitrarily pick between constant values).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="uncoveredLine">  auto JoinSource = [&]() -> DbgAssignIntrinsic * {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="uncoveredLine">    if (A.Source == B.Source)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="uncoveredLine">      return A.Source;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="uncoveredLine">    if (A.Source == nullptr || B.Source == nullptr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="uncoveredLine">      return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="uncoveredLine">    if (A.Source->isIdenticalTo(B.Source))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="uncoveredLine">      return A.Source;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="uncoveredLine">  DbgAssignIntrinsic *Source = JoinSource();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="uncoveredLine">  assert(A.Status == B.Status && A.Status == Assignment::Known);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="uncoveredLine">  assert(A.ID == B.ID);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="uncoveredLine">  return Assignment::make(A.ID, Source);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="">AssignmentTrackingLowering::BlockInfo</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="uncoveredLine">AssignmentTrackingLowering::joinBlockInfo(const BlockInfo &A,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="">                                          const BlockInfo &B) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="uncoveredLine">  return BlockInfo::join(A, B, TrackedVariablesVectorSize);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="uncoveredLine">bool AssignmentTrackingLowering::join(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="">    const BasicBlock &BB, const SmallPtrSet<BasicBlock *, 16> &Visited) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="uncoveredLine">  SmallVector<const BasicBlock *> VisitedPreds;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="">  // Ignore backedges if we have not visited the predecessor yet. As the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="">  // predecessor hasn't yet had locations propagated into it, most locations</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="">  // will not yet be valid, so treat them as all being uninitialized and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="">  // potentially valid. If a location guessed to be correct here is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="">  // invalidated later, we will remove it when we revisit this block. This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="">  // is essentially the same as initialising all LocKinds and Assignments to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="">  // an implicit ⊥ value which is the identity value for the join operation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="uncoveredLine">  for (auto I = pred_begin(&BB), E = pred_end(&BB); I != E; I++) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="uncoveredLine">    const BasicBlock *Pred = *I;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="uncoveredLine">    if (Visited.count(Pred))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="uncoveredLine">      VisitedPreds.push_back(Pred);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="">  // No preds visited yet.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="uncoveredLine">  if (VisitedPreds.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="uncoveredLine">    auto It = LiveIn.try_emplace(&BB, BlockInfo());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="uncoveredLine">    bool DidInsert = It.second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="uncoveredLine">    if (DidInsert)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="uncoveredLine">      It.first->second.init(TrackedVariablesVectorSize);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="uncoveredLine">    return /*Changed*/ DidInsert;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="">  // Exactly one visited pred. Copy the LiveOut from that pred into BB LiveIn.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="uncoveredLine">  if (VisitedPreds.size() == 1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="uncoveredLine">    const BlockInfo &PredLiveOut = LiveOut.find(VisitedPreds[0])->second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="uncoveredLine">    auto CurrentLiveInEntry = LiveIn.find(&BB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="">    // Check if there isn't an entry, or there is but the LiveIn set has</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="">    // changed (expensive check).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="uncoveredLine">    if (CurrentLiveInEntry == LiveIn.end())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="uncoveredLine">      LiveIn.insert(std::make_pair(&BB, PredLiveOut));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="uncoveredLine">    else if (PredLiveOut != CurrentLiveInEntry->second)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="uncoveredLine">      CurrentLiveInEntry->second = PredLiveOut;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="uncoveredLine">      return /*Changed*/ false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="uncoveredLine">    return /*Changed*/ true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="">  // More than one pred. Join LiveOuts of blocks 1 and 2.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="uncoveredLine">  assert(VisitedPreds.size() > 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="uncoveredLine">  const BlockInfo &PredLiveOut0 = LiveOut.find(VisitedPreds[0])->second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="uncoveredLine">  const BlockInfo &PredLiveOut1 = LiveOut.find(VisitedPreds[1])->second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="uncoveredLine">  BlockInfo BBLiveIn = joinBlockInfo(PredLiveOut0, PredLiveOut1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="">  // Join the LiveOuts of subsequent blocks.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="uncoveredLine">  ArrayRef Tail = ArrayRef(VisitedPreds).drop_front(2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="uncoveredLine">  for (const BasicBlock *Pred : Tail) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="uncoveredLine">    const auto &PredLiveOut = LiveOut.find(Pred);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="uncoveredLine">    assert(PredLiveOut != LiveOut.end() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="">           "block should have been processed already");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="uncoveredLine">    BBLiveIn = joinBlockInfo(std::move(BBLiveIn), PredLiveOut->second);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="">  // Save the joined result for BB.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="uncoveredLine">  auto CurrentLiveInEntry = LiveIn.find(&BB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="">  // Check if there isn't an entry, or there is but the LiveIn set has changed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="">  // (expensive check).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="uncoveredLine">  if (CurrentLiveInEntry == LiveIn.end())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="uncoveredLine">    LiveIn.try_emplace(&BB, std::move(BBLiveIn));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="uncoveredLine">  else if (BBLiveIn != CurrentLiveInEntry->second)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="uncoveredLine">    CurrentLiveInEntry->second = std::move(BBLiveIn);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="uncoveredLine">    return /*Changed*/ false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="uncoveredLine">  return /*Changed*/ true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="">/// Return true if A fully contains B.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="uncoveredLine">static bool fullyContains(DIExpression::FragmentInfo A,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="">                          DIExpression::FragmentInfo B) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="uncoveredLine">  auto ALeft = A.OffsetInBits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="uncoveredLine">  auto BLeft = B.OffsetInBits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="uncoveredLine">  if (BLeft < ALeft)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="uncoveredLine">  auto ARight = ALeft + A.SizeInBits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="uncoveredLine">  auto BRight = BLeft + B.SizeInBits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="uncoveredLine">  if (BRight > ARight)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="">static std::optional<at::AssignmentInfo></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="uncoveredLine">getUntaggedStoreAssignmentInfo(const Instruction &I, const DataLayout &Layout) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="">  // Don't bother checking if this is an AllocaInst. We know this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="">  // instruction has no tag which means there are no variables associated</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="">  // with it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="uncoveredLine">  if (const auto *SI = dyn_cast<StoreInst>(&I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="uncoveredLine">    return at::getAssignmentInfo(Layout, SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="uncoveredLine">  if (const auto *MI = dyn_cast<MemIntrinsic>(&I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="uncoveredLine">    return at::getAssignmentInfo(Layout, MI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="">  // Alloca or non-store-like inst.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="uncoveredLine">  return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="">/// Build a map of {Variable x: Variables y} where all variable fragments</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="">/// contained within the variable fragment x are in set y. This means that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="">/// y does not contain all overlaps because partial overlaps are excluded.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="">/// While we're iterating over the function, add single location defs for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="">/// dbg.declares to \p FnVarLocs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="">/// Variables that are interesting to this pass in are added to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="">/// FnVarLocs->Variables first. TrackedVariablesVectorSize is set to the ID of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="">/// the last interesting variable plus 1, meaning variables with ID 1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="">/// (inclusive) to TrackedVariablesVectorSize (exclusive) are interesting. The</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="">/// subsequent variables are either stack homed or fully promoted.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="">/// Finally, populate UntaggedStoreVars with a mapping of untagged stores to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="">/// the stored-to variable fragments.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="">/// These tasks are bundled together to reduce the number of times we need</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="">/// to iterate over the function as they can be achieved together in one pass.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="uncoveredLine">static AssignmentTrackingLowering::OverlapMap buildOverlapMapAndRecordDeclares(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="">    Function &Fn, FunctionVarLocsBuilder *FnVarLocs,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="">    const DenseSet<DebugAggregate> &VarsWithStackSlot,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="">    AssignmentTrackingLowering::UntaggedStoreAssignmentMap &UntaggedStoreVars,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="">    unsigned &TrackedVariablesVectorSize) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="uncoveredLine">  DenseSet<DebugVariable> Seen;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="">  // Map of Variable: [Fragments].</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="uncoveredLine">  DenseMap<DebugAggregate, SmallVector<DebugVariable, 8>> FragmentMap;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="">  // Iterate over all instructions:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="">  // - dbg.declare    -> add single location variable record</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="">  // - dbg.*          -> Add fragments to FragmentMap</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="">  // - untagged store -> Add fragments to FragmentMap and update</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="">  //                     UntaggedStoreVars.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="">  // We need to add fragments for untagged stores too so that we can correctly</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="">  // clobber overlapped fragment locations later.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="uncoveredLine">  SmallVector<DbgDeclareInst *> Declares;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="uncoveredLine">  for (auto &BB : Fn) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="uncoveredLine">    for (auto &I : BB) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="uncoveredLine">      if (auto *DDI = dyn_cast<DbgDeclareInst>(&I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="uncoveredLine">        Declares.push_back(DDI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="uncoveredLine">      } else if (auto *DII = dyn_cast<DbgVariableIntrinsic>(&I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="uncoveredLine">        DebugVariable DV = DebugVariable(DII);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="uncoveredLine">        DebugAggregate DA = {DV.getVariable(), DV.getInlinedAt()};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="uncoveredLine">        if (!VarsWithStackSlot.contains(DA))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="uncoveredLine">        if (Seen.insert(DV).second)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="uncoveredLine">          FragmentMap[DA].push_back(DV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="uncoveredLine">      } else if (auto Info = getUntaggedStoreAssignmentInfo(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="uncoveredLine">                     I, Fn.getParent()->getDataLayout())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="">        // Find markers linked to this alloca.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="uncoveredLine">        for (DbgAssignIntrinsic *DAI : at::getAssignmentMarkers(Info->Base)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="">          // Discard the fragment if it covers the entire variable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="">          std::optional<DIExpression::FragmentInfo> FragInfo =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="uncoveredLine">              [&Info, DAI]() -> std::optional<DIExpression::FragmentInfo> {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="">            DIExpression::FragmentInfo F;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="uncoveredLine">            F.OffsetInBits = Info->OffsetInBits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="uncoveredLine">            F.SizeInBits = Info->SizeInBits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="uncoveredLine">            if (auto ExistingFrag = DAI->getExpression()->getFragmentInfo())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="uncoveredLine">              F.OffsetInBits += ExistingFrag->OffsetInBits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="uncoveredLine">            if (auto Sz = DAI->getVariable()->getSizeInBits()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="uncoveredLine">              if (F.OffsetInBits == 0 && F.SizeInBits == *Sz)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="uncoveredLine">                return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="">            }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="uncoveredLine">            return F;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="uncoveredLine">          }();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="uncoveredLine">          DebugVariable DV = DebugVariable(DAI->getVariable(), FragInfo,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="uncoveredLine">                                           DAI->getDebugLoc().getInlinedAt());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="uncoveredLine">          DebugAggregate DA = {DV.getVariable(), DV.getInlinedAt()};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="uncoveredLine">          if (!VarsWithStackSlot.contains(DA))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="uncoveredLine">            continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="">          // Cache this info for later.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="uncoveredLine">          UntaggedStoreVars[&I].push_back(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="uncoveredLine">              {FnVarLocs->insertVariable(DV), *Info});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="uncoveredLine">          if (Seen.insert(DV).second)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="uncoveredLine">            FragmentMap[DA].push_back(DV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="">  // Sort the fragment map for each DebugAggregate in ascending</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="">  // order of fragment size - there should be no duplicates.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="uncoveredLine">  for (auto &Pair : FragmentMap) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="uncoveredLine">    SmallVector<DebugVariable, 8> &Frags = Pair.second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="uncoveredLine">    std::sort(Frags.begin(), Frags.end(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="uncoveredLine">              [](const DebugVariable &Next, const DebugVariable &Elmt) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="uncoveredLine">                return Elmt.getFragmentOrDefault().SizeInBits ></td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="uncoveredLine">                       Next.getFragmentOrDefault().SizeInBits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="">              });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="">    // Check for duplicates.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="uncoveredLine">    assert(std::adjacent_find(Frags.begin(), Frags.end()) == Frags.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="">  // Build the map.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="uncoveredLine">  AssignmentTrackingLowering::OverlapMap Map;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="uncoveredLine">  for (auto &Pair : FragmentMap) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="uncoveredLine">    auto &Frags = Pair.second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="uncoveredLine">    for (auto It = Frags.begin(), IEnd = Frags.end(); It != IEnd; ++It) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="uncoveredLine">      DIExpression::FragmentInfo Frag = It->getFragmentOrDefault();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="">      // Find the frags that this is contained within.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="">      //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="">      // Because Frags is sorted by size and none have the same offset and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="">      // size, we know that this frag can only be contained by subsequent</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="">      // elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="uncoveredLine">      SmallVector<DebugVariable, 8>::iterator OtherIt = It;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="uncoveredLine">      ++OtherIt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="uncoveredLine">      VariableID ThisVar = FnVarLocs->insertVariable(*It);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="uncoveredLine">      for (; OtherIt != IEnd; ++OtherIt) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="uncoveredLine">        DIExpression::FragmentInfo OtherFrag = OtherIt->getFragmentOrDefault();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="uncoveredLine">        VariableID OtherVar = FnVarLocs->insertVariable(*OtherIt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="uncoveredLine">        if (fullyContains(OtherFrag, Frag))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="uncoveredLine">          Map[OtherVar].push_back(ThisVar);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="">  // VariableIDs are 1-based so the variable-tracking bitvector needs</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="">  // NumVariables plus 1 bits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="uncoveredLine">  TrackedVariablesVectorSize = FnVarLocs->getNumVariables() + 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="">  // Finally, insert the declares afterwards, so the first IDs are all</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="">  // partially stack homed vars.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="uncoveredLine">  for (auto *DDI : Declares)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="uncoveredLine">    FnVarLocs->addSingleLocVar(DebugVariable(DDI), DDI->getExpression(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="">                               DDI->getDebugLoc(), DDI->getWrappedLocation());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="uncoveredLine">  return Map;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="uncoveredLine">bool AssignmentTrackingLowering::run(FunctionVarLocsBuilder *FnVarLocsBuilder) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="uncoveredLine">  if (Fn.size() > MaxNumBlocks) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "[AT] Dropping var locs in: " << Fn.getName()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="">                      << ": too many blocks (" << Fn.size() << ")\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="uncoveredLine">    at::deleteAll(&Fn);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="uncoveredLine">  FnVarLocs = FnVarLocsBuilder;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="">  // The general structure here is inspired by VarLocBasedImpl.cpp</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="">  // (LiveDebugValues).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="">  // Build the variable fragment overlap map.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="">  // Note that this pass doesn't handle partial overlaps correctly (FWIW</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="">  // neither does LiveDebugVariables) because that is difficult to do and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="">  // appears to be rare occurance.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="uncoveredLine">  VarContains = buildOverlapMapAndRecordDeclares(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="uncoveredLine">      Fn, FnVarLocs, *VarsWithStackSlot, UntaggedStoreVars,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="uncoveredLine">      TrackedVariablesVectorSize);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="">  // Prepare for traversal.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="uncoveredLine">  ReversePostOrderTraversal<Function *> RPOT(&Fn);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="">  std::priority_queue<unsigned int, std::vector<unsigned int>,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="">                      std::greater<unsigned int>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="uncoveredLine">      Worklist;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="">  std::priority_queue<unsigned int, std::vector<unsigned int>,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="">                      std::greater<unsigned int>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="uncoveredLine">      Pending;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="uncoveredLine">  DenseMap<unsigned int, BasicBlock *> OrderToBB;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="uncoveredLine">  DenseMap<BasicBlock *, unsigned int> BBToOrder;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="">  { // Init OrderToBB and BBToOrder.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="uncoveredLine">    unsigned int RPONumber = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="uncoveredLine">    for (auto RI = RPOT.begin(), RE = RPOT.end(); RI != RE; ++RI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="uncoveredLine">      OrderToBB[RPONumber] = *RI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="uncoveredLine">      BBToOrder[*RI] = RPONumber;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="uncoveredLine">      Worklist.push(RPONumber);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="uncoveredLine">      ++RPONumber;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="uncoveredLine">    LiveIn.init(RPONumber);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="uncoveredLine">    LiveOut.init(RPONumber);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="">  // Perform the traversal.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="">  // This is a standard "union of predecessor outs" dataflow problem. To solve</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="">  // it, we perform join() and process() using the two worklist method until</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="">  // the LiveIn data for each block becomes unchanging. The "proof" that this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="">  // terminates can be put together by looking at the comments around LocKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="">  // Assignment, and the various join methods, which show that all the elements</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="">  // involved are made up of join-semilattices; LiveIn(n) can only</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="">  // monotonically increase in value throughout the dataflow.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="uncoveredLine">  SmallPtrSet<BasicBlock *, 16> Visited;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="uncoveredLine">  while (!Worklist.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="">    // We track what is on the pending worklist to avoid inserting the same</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="">    // thing twice.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="uncoveredLine">    SmallPtrSet<BasicBlock *, 16> OnPending;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "Processing Worklist\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="uncoveredLine">    while (!Worklist.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="uncoveredLine">      BasicBlock *BB = OrderToBB[Worklist.top()];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "\nPop BB " << BB->getName() << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="uncoveredLine">      Worklist.pop();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="uncoveredLine">      bool InChanged = join(*BB, Visited);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="">      // Always consider LiveIn changed on the first visit.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="uncoveredLine">      InChanged |= Visited.insert(BB).second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="uncoveredLine">      if (InChanged) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="uncoveredLine">        LLVM_DEBUG(dbgs() << BB->getName() << " has new InLocs, process it\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="">        // Mutate a copy of LiveIn while processing BB. After calling process</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="">        // LiveSet is the LiveOut set for BB.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="uncoveredLine">        BlockInfo LiveSet = LiveIn[BB];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="">        // Process the instructions in the block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="uncoveredLine">        process(*BB, &LiveSet);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="">        // Relatively expensive check: has anything changed in LiveOut for BB?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="uncoveredLine">        if (LiveOut[BB] != LiveSet) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="uncoveredLine">          LLVM_DEBUG(dbgs() << BB->getName()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="">                            << " has new OutLocs, add succs to worklist: [ ");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="uncoveredLine">          LiveOut[BB] = std::move(LiveSet);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="uncoveredLine">          for (auto I = succ_begin(BB), E = succ_end(BB); I != E; I++) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="uncoveredLine">            if (OnPending.insert(*I).second) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="uncoveredLine">              LLVM_DEBUG(dbgs() << I->getName() << " ");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="uncoveredLine">              Pending.push(BBToOrder[*I]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="">            }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="uncoveredLine">          LLVM_DEBUG(dbgs() << "]\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="uncoveredLine">      }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="uncoveredLine">    Worklist.swap(Pending);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="">    // At this point, pending must be empty, since it was just the empty</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="">    // worklist</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="uncoveredLine">    assert(Pending.empty() && "Pending should be empty");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="">  // That's the hard part over. Now we just have some admin to do.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="">  // Record whether we inserted any intrinsics.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="uncoveredLine">  bool InsertedAnyIntrinsics = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="">  // Identify and add defs for single location variables.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="">  // Go through all of the defs that we plan to add. If the aggregate variable</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="">  // it's a part of is not in the NotAlwaysStackHomed set we can emit a single</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="">  // location def and omit the rest. Add an entry to AlwaysStackHomed so that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="">  // we can identify those uneeded defs later.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="uncoveredLine">  DenseSet<DebugAggregate> AlwaysStackHomed;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="uncoveredLine">  for (const auto &Pair : InsertBeforeMap) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="uncoveredLine">    const auto &Vec = Pair.second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="uncoveredLine">    for (VarLocInfo VarLoc : Vec) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="uncoveredLine">      DebugVariable Var = FnVarLocs->getVariable(VarLoc.VariableID);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="uncoveredLine">      DebugAggregate Aggr{Var.getVariable(), Var.getInlinedAt()};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="">      // Skip this Var if it's not always stack homed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="uncoveredLine">      if (NotAlwaysStackHomed.contains(Aggr))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="">      // Skip complex cases such as when different fragments of a variable have</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="">      // been split into different allocas. Skipping in this case means falling</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="">      // back to using a list of defs (which could reduce coverage, but is no</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="">      // less correct).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="">      bool Simple =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="uncoveredLine">          VarLoc.Expr->getNumElements() == 1 && VarLoc.Expr->startsWithDeref();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="uncoveredLine">      if (!Simple) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="uncoveredLine">        NotAlwaysStackHomed.insert(Aggr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="">      // All source assignments to this variable remain and all stores to any</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="">      // part of the variable store to the same address (with varying</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="">      // offsets). We can just emit a single location for the whole variable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="">      //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="">      // Unless we've already done so, create the single location def now.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="uncoveredLine">      if (AlwaysStackHomed.insert(Aggr).second) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="uncoveredLine">        assert(!VarLoc.Values.hasArgList());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="">        // TODO: When more complex cases are handled VarLoc.Expr should be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="">        // built appropriately rather than always using an empty DIExpression.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="">        // The assert below is a reminder.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="uncoveredLine">        assert(Simple);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="uncoveredLine">        VarLoc.Expr = DIExpression::get(Fn.getContext(), std::nullopt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="uncoveredLine">        DebugVariable Var = FnVarLocs->getVariable(VarLoc.VariableID);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="uncoveredLine">        FnVarLocs->addSingleLocVar(Var, VarLoc.Expr, VarLoc.DL, VarLoc.Values);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="uncoveredLine">        InsertedAnyIntrinsics = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="">  // Insert the other DEFs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="uncoveredLine">  for (const auto &[InsertBefore, Vec] : InsertBeforeMap) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="uncoveredLine">    SmallVector<VarLocInfo> NewDefs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="uncoveredLine">    for (const VarLocInfo &VarLoc : Vec) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="uncoveredLine">      DebugVariable Var = FnVarLocs->getVariable(VarLoc.VariableID);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="uncoveredLine">      DebugAggregate Aggr{Var.getVariable(), Var.getInlinedAt()};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="">      // If this variable is always stack homed then we have already inserted a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="">      // dbg.declare and deleted this dbg.value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="uncoveredLine">      if (AlwaysStackHomed.contains(Aggr))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="uncoveredLine">      NewDefs.push_back(VarLoc);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="uncoveredLine">      InsertedAnyIntrinsics = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="uncoveredLine">    FnVarLocs->setWedge(InsertBefore, std::move(NewDefs));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="uncoveredLine">  InsertedAnyIntrinsics |= emitPromotedVarLocs(FnVarLocs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="uncoveredLine">  return InsertedAnyIntrinsics;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="uncoveredLine">bool AssignmentTrackingLowering::emitPromotedVarLocs(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="">    FunctionVarLocsBuilder *FnVarLocs) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="uncoveredLine">  bool InsertedAnyIntrinsics = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="">  // Go through every block, translating debug intrinsics for fully promoted</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="">  // variables into FnVarLocs location defs. No analysis required for these.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="uncoveredLine">  for (auto &BB : Fn) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="uncoveredLine">    for (auto &I : BB) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="">      // Skip instructions other than dbg.values and dbg.assigns.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="uncoveredLine">      auto *DVI = dyn_cast<DbgValueInst>(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="uncoveredLine">      if (!DVI)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="">      // Skip variables that haven't been promoted - we've dealt with those</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="">      // already.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="uncoveredLine">      if (VarsWithStackSlot->contains(getAggregate(DVI)))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="uncoveredLine">      Instruction *InsertBefore = I.getNextNode();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="uncoveredLine">      assert(InsertBefore && "Unexpected: debug intrinsics after a terminator");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="uncoveredLine">      FnVarLocs->addVarLoc(InsertBefore, DebugVariable(DVI),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="">                           DVI->getExpression(), DVI->getDebugLoc(),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="">                           DVI->getWrappedLocation());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="uncoveredLine">      InsertedAnyIntrinsics = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="uncoveredLine">  return InsertedAnyIntrinsics;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="">/// Remove redundant definitions within sequences of consecutive location defs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="">/// This is done using a backward scan to keep the last def describing a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="">/// specific variable/fragment.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="">/// This implements removeRedundantDbgInstrsUsingBackwardScan from</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="">/// lib/Transforms/Utils/BasicBlockUtils.cpp for locations described with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="">/// FunctionVarLocsBuilder instead of with intrinsics.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="">static bool</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="uncoveredLine">removeRedundantDbgLocsUsingBackwardScan(const BasicBlock *BB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="">                                        FunctionVarLocsBuilder &FnVarLocs) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="uncoveredLine">  bool Changed = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="uncoveredLine">  SmallDenseMap<DebugAggregate, BitVector> VariableDefinedBits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="">  // Scan over the entire block, not just over the instructions mapped by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="">  // FnVarLocs, because wedges in FnVarLocs may only be seperated by debug</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="">  // instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="uncoveredLine">  for (const Instruction &I : reverse(*BB)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="uncoveredLine">    if (!isa<DbgVariableIntrinsic>(I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="">      // Sequence of consecutive defs ended. Clear map for the next one.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="uncoveredLine">      VariableDefinedBits.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="">    // Get the location defs that start just before this instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="uncoveredLine">    const auto *Locs = FnVarLocs.getWedge(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="uncoveredLine">    if (!Locs)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="uncoveredLine">    NumWedgesScanned++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="uncoveredLine">    bool ChangedThisWedge = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="">    // The new pruned set of defs, reversed because we're scanning backwards.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="uncoveredLine">    SmallVector<VarLocInfo> NewDefsReversed;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="">    // Iterate over the existing defs in reverse.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="uncoveredLine">    for (auto RIt = Locs->rbegin(), REnd = Locs->rend(); RIt != REnd; ++RIt) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="uncoveredLine">      NumDefsScanned++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="">      DebugAggregate Aggr =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="uncoveredLine">          getAggregate(FnVarLocs.getVariable(RIt->VariableID));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="uncoveredLine">      uint64_t SizeInBits = Aggr.first->getSizeInBits().value_or(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="uncoveredLine">      if (SizeInBits == 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="">        // If the size is unknown (0) then keep this location def to be safe.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="uncoveredLine">        NewDefsReversed.push_back(*RIt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="">      // Only keep this location definition if it is not fully eclipsed by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="">      // other definitions in this wedge that come after it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="">      // Inert the bits the location definition defines.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="">      auto InsertResult =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="uncoveredLine">          VariableDefinedBits.try_emplace(Aggr, BitVector(SizeInBits));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="uncoveredLine">      bool FirstDefinition = InsertResult.second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="uncoveredLine">      BitVector &DefinedBits = InsertResult.first->second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="">      DIExpression::FragmentInfo Fragment =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="uncoveredLine">          RIt->Expr->getFragmentInfo().value_or(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="uncoveredLine">              DIExpression::FragmentInfo(SizeInBits, 0));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="uncoveredLine">      bool InvalidFragment = Fragment.endInBits() > SizeInBits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="">      // If this defines any previously undefined bits, keep it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="uncoveredLine">      if (FirstDefinition || InvalidFragment ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="uncoveredLine">          DefinedBits.find_first_unset_in(Fragment.startInBits(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="uncoveredLine">                                          Fragment.endInBits()) != -1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="uncoveredLine">        if (!InvalidFragment)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="uncoveredLine">          DefinedBits.set(Fragment.startInBits(), Fragment.endInBits());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="uncoveredLine">        NewDefsReversed.push_back(*RIt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="">      // Redundant def found: throw it away. Since the wedge of defs is being</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="">      // rebuilt, doing nothing is the same as deleting an entry.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="uncoveredLine">      ChangedThisWedge = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="uncoveredLine">      NumDefsRemoved++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="">    // Un-reverse the defs and replace the wedge with the pruned version.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="uncoveredLine">    if (ChangedThisWedge) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="uncoveredLine">      std::reverse(NewDefsReversed.begin(), NewDefsReversed.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="uncoveredLine">      FnVarLocs.setWedge(&I, std::move(NewDefsReversed));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="uncoveredLine">      NumWedgesChanged++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="uncoveredLine">      Changed = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="uncoveredLine">  return Changed;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="">/// Remove redundant location defs using a forward scan. This can remove a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="">/// location definition that is redundant due to indicating that a variable has</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="">/// the same value as is already being indicated by an earlier def.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="">/// This implements removeRedundantDbgInstrsUsingForwardScan from</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="">/// lib/Transforms/Utils/BasicBlockUtils.cpp for locations described with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="">/// FunctionVarLocsBuilder instead of with intrinsics</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="">static bool</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="uncoveredLine">removeRedundantDbgLocsUsingForwardScan(const BasicBlock *BB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="">                                       FunctionVarLocsBuilder &FnVarLocs) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="uncoveredLine">  bool Changed = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="">  DenseMap<DebugVariable, std::pair<RawLocationWrapper, DIExpression *>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="uncoveredLine">      VariableMap;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="">  // Scan over the entire block, not just over the instructions mapped by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="">  // FnVarLocs, because wedges in FnVarLocs may only be seperated by debug</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="">  // instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="uncoveredLine">  for (const Instruction &I : *BB) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="">    // Get the defs that come just before this instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="uncoveredLine">    const auto *Locs = FnVarLocs.getWedge(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="uncoveredLine">    if (!Locs)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="uncoveredLine">    NumWedgesScanned++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="uncoveredLine">    bool ChangedThisWedge = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="">    // The new pruned set of defs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="uncoveredLine">    SmallVector<VarLocInfo> NewDefs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="">    // Iterate over the existing defs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="uncoveredLine">    for (const VarLocInfo &Loc : *Locs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="uncoveredLine">      NumDefsScanned++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="uncoveredLine">      DebugVariable Key(FnVarLocs.getVariable(Loc.VariableID).getVariable(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="uncoveredLine">                        std::nullopt, Loc.DL.getInlinedAt());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="uncoveredLine">      auto VMI = VariableMap.find(Key);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="">      // Update the map if we found a new value/expression describing the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="">      // variable, or if the variable wasn't mapped already.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="uncoveredLine">      if (VMI == VariableMap.end() || VMI->second.first != Loc.Values ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="uncoveredLine">          VMI->second.second != Loc.Expr) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="uncoveredLine">        VariableMap[Key] = {Loc.Values, Loc.Expr};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="uncoveredLine">        NewDefs.push_back(Loc);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="">      // Did not insert this Loc, which is the same as removing it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="uncoveredLine">      ChangedThisWedge = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="uncoveredLine">      NumDefsRemoved++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="">    // Replace the existing wedge with the pruned version.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="uncoveredLine">    if (ChangedThisWedge) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="uncoveredLine">      FnVarLocs.setWedge(&I, std::move(NewDefs));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="uncoveredLine">      NumWedgesChanged++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="uncoveredLine">      Changed = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="uncoveredLine">  return Changed;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="">static bool</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="uncoveredLine">removeUndefDbgLocsFromEntryBlock(const BasicBlock *BB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="">                                 FunctionVarLocsBuilder &FnVarLocs) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="uncoveredLine">  assert(BB->isEntryBlock());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="">  // Do extra work to ensure that we remove semantically unimportant undefs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="">  // This is to work around the fact that SelectionDAG will hoist dbg.values</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="">  // using argument values to the top of the entry block. That can move arg</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="">  // dbg.values before undef and constant dbg.values which they previously</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="">  // followed. The easiest thing to do is to just try to feed SelectionDAG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="">  // input it's happy with.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="">  // Map of {Variable x: Fragments y} where the fragments y of variable x have</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="">  // have at least one non-undef location defined already. Don't use directly,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="">  // instead call DefineBits and HasDefinedBits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="">  SmallDenseMap<DebugAggregate, SmallDenseSet<DIExpression::FragmentInfo>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="uncoveredLine">      VarsWithDef;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="">  // Specify that V (a fragment of A) has a non-undef location.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="uncoveredLine">  auto DefineBits = [&VarsWithDef](DebugAggregate A, DebugVariable V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="uncoveredLine">    VarsWithDef[A].insert(V.getFragmentOrDefault());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="">  // Return true if a non-undef location has been defined for V (a fragment of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="">  // A). Doesn't imply that the location is currently non-undef, just that a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="">  // non-undef location has been seen previously.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="uncoveredLine">  auto HasDefinedBits = [&VarsWithDef](DebugAggregate A, DebugVariable V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="uncoveredLine">    auto FragsIt = VarsWithDef.find(A);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="uncoveredLine">    if (FragsIt == VarsWithDef.end())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="uncoveredLine">    return llvm::any_of(FragsIt->second, [V](auto Frag) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="uncoveredLine">      return DIExpression::fragmentsOverlap(Frag, V.getFragmentOrDefault());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="uncoveredLine">    });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="uncoveredLine">  bool Changed = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="uncoveredLine">  DenseMap<DebugVariable, std::pair<Value *, DIExpression *>> VariableMap;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="">  // Scan over the entire block, not just over the instructions mapped by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="">  // FnVarLocs, because wedges in FnVarLocs may only be seperated by debug</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="">  // instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="uncoveredLine">  for (const Instruction &I : *BB) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="">    // Get the defs that come just before this instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="uncoveredLine">    const auto *Locs = FnVarLocs.getWedge(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="uncoveredLine">    if (!Locs)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="uncoveredLine">    NumWedgesScanned++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="uncoveredLine">    bool ChangedThisWedge = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="">    // The new pruned set of defs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="uncoveredLine">    SmallVector<VarLocInfo> NewDefs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="">    // Iterate over the existing defs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="uncoveredLine">    for (const VarLocInfo &Loc : *Locs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="uncoveredLine">      NumDefsScanned++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="uncoveredLine">      DebugAggregate Aggr{FnVarLocs.getVariable(Loc.VariableID).getVariable(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="uncoveredLine">                          Loc.DL.getInlinedAt()};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="uncoveredLine">      DebugVariable Var = FnVarLocs.getVariable(Loc.VariableID);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="">      // Remove undef entries that are encountered before any non-undef</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="">      // intrinsics from the entry block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="uncoveredLine">      if (Loc.Values.isKillLocation(Loc.Expr) && !HasDefinedBits(Aggr, Var)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="">        // Did not insert this Loc, which is the same as removing it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="uncoveredLine">        NumDefsRemoved++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="uncoveredLine">        ChangedThisWedge = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="uncoveredLine">      DefineBits(Aggr, Var);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="uncoveredLine">      NewDefs.push_back(Loc);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="">    // Replace the existing wedge with the pruned version.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2475</td>
    <td class="uncoveredLine">    if (ChangedThisWedge) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2476</td>
    <td class="uncoveredLine">      FnVarLocs.setWedge(&I, std::move(NewDefs));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2477</td>
    <td class="uncoveredLine">      NumWedgesChanged++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2478</td>
    <td class="uncoveredLine">      Changed = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2479</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2480</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2481</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2482</td>
    <td class="uncoveredLine">  return Changed;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2483</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2484</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2485</td>
    <td class="uncoveredLine">static bool removeRedundantDbgLocs(const BasicBlock *BB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2486</td>
    <td class="">                                   FunctionVarLocsBuilder &FnVarLocs) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2487</td>
    <td class="uncoveredLine">  bool MadeChanges = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2488</td>
    <td class="uncoveredLine">  MadeChanges |= removeRedundantDbgLocsUsingBackwardScan(BB, FnVarLocs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2489</td>
    <td class="uncoveredLine">  if (BB->isEntryBlock())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2490</td>
    <td class="uncoveredLine">    MadeChanges |= removeUndefDbgLocsFromEntryBlock(BB, FnVarLocs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2491</td>
    <td class="uncoveredLine">  MadeChanges |= removeRedundantDbgLocsUsingForwardScan(BB, FnVarLocs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2492</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2493</td>
    <td class="uncoveredLine">  if (MadeChanges)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2494</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "Removed redundant dbg locs from: " << BB->getName()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2495</td>
    <td class="">                      << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2496</td>
    <td class="uncoveredLine">  return MadeChanges;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2497</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2498</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2499</td>
    <td class="uncoveredLine">static DenseSet<DebugAggregate> findVarsWithStackSlot(Function &Fn) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2500</td>
    <td class="uncoveredLine">  DenseSet<DebugAggregate> Result;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2501</td>
    <td class="uncoveredLine">  for (auto &BB : Fn) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2502</td>
    <td class="uncoveredLine">    for (auto &I : BB) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2503</td>
    <td class="">      // Any variable linked to an instruction is considered</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2504</td>
    <td class="">      // interesting. Ideally we only need to check Allocas, however, a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2505</td>
    <td class="">      // DIAssignID might get dropped from an alloca but not stores. In that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2506</td>
    <td class="">      // case, we need to consider the variable interesting for NFC behaviour</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2507</td>
    <td class="">      // with this change. TODO: Consider only looking at allocas.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2508</td>
    <td class="uncoveredLine">      for (DbgAssignIntrinsic *DAI : at::getAssignmentMarkers(&I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2509</td>
    <td class="uncoveredLine">        Result.insert({DAI->getVariable(), DAI->getDebugLoc().getInlinedAt()});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2510</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2511</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2512</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2513</td>
    <td class="uncoveredLine">  return Result;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2514</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2515</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2516</td>
    <td class="uncoveredLine">static void analyzeFunction(Function &Fn, const DataLayout &Layout,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2517</td>
    <td class="">                            FunctionVarLocsBuilder *FnVarLocs) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2518</td>
    <td class="">  // The analysis will generate location definitions for all variables, but we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2519</td>
    <td class="">  // only need to perform a dataflow on the set of variables which have a stack</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2520</td>
    <td class="">  // slot. Find those now.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2521</td>
    <td class="uncoveredLine">  DenseSet<DebugAggregate> VarsWithStackSlot = findVarsWithStackSlot(Fn);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2522</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2523</td>
    <td class="uncoveredLine">  bool Changed = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2524</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2525</td>
    <td class="">  // Use a scope block to clean up AssignmentTrackingLowering before running</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2526</td>
    <td class="">  // MemLocFragmentFill to reduce peak memory consumption.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2527</td>
    <td class="">  {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2528</td>
    <td class="uncoveredLine">    AssignmentTrackingLowering Pass(Fn, Layout, &VarsWithStackSlot);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2529</td>
    <td class="uncoveredLine">    Changed = Pass.run(FnVarLocs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2530</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2531</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2532</td>
    <td class="uncoveredLine">  if (Changed) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2533</td>
    <td class="">    MemLocFragmentFill Pass(Fn, &VarsWithStackSlot,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2534</td>
    <td class="uncoveredLine">                            shouldCoalesceFragments(Fn));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2535</td>
    <td class="uncoveredLine">    Pass.run(FnVarLocs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2536</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2537</td>
    <td class="">    // Remove redundant entries. As well as reducing memory consumption and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2538</td>
    <td class="">    // avoiding waiting cycles later by burning some now, this has another</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2539</td>
    <td class="">    // important job. That is to work around some SelectionDAG quirks. See</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2540</td>
    <td class="">    // removeRedundantDbgLocsUsingForwardScan comments for more info on that.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2541</td>
    <td class="uncoveredLine">    for (auto &BB : Fn)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2542</td>
    <td class="uncoveredLine">      removeRedundantDbgLocs(&BB, *FnVarLocs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2543</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2544</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2545</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2546</td>
    <td class="coveredLine">bool AssignmentTrackingAnalysis::runOnFunction(Function &F) {</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2547</td>
    <td class="coveredLine">  if (!isAssignmentTrackingEnabled(*F.getParent()))</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2548</td>
    <td class="coveredLine">    return false;</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2549</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2550</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "AssignmentTrackingAnalysis run on " << F.getName()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2551</td>
    <td class="">                    << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2552</td>
    <td class="uncoveredLine">  auto DL = std::make_unique<DataLayout>(F.getParent());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2553</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2554</td>
    <td class="">  // Clear previous results.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2555</td>
    <td class="uncoveredLine">  Results->clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2556</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2557</td>
    <td class="uncoveredLine">  FunctionVarLocsBuilder Builder;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2558</td>
    <td class="uncoveredLine">  analyzeFunction(F, *DL.get(), &Builder);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2559</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2560</td>
    <td class="">  // Save these results.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2561</td>
    <td class="uncoveredLine">  Results->init(Builder);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2562</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2563</td>
    <td class="uncoveredLine">  if (PrintResults && isFunctionInPrintList(F.getName()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2564</td>
    <td class="uncoveredLine">    Results->print(errs(), F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2565</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2566</td>
    <td class="">  // Return false because this pass does not modify the function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2567</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2568</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2569</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2570</td>
    <td class="coveredLine">AssignmentTrackingAnalysis::AssignmentTrackingAnalysis()</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2571</td>
    <td class="coveredLine">    : FunctionPass(ID), Results(std::make_unique<FunctionVarLocs>()) {}</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2572</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2573</td>
    <td class="">char AssignmentTrackingAnalysis::ID = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2574</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2575</td>
    <td class="coveredLine">INITIALIZE_PASS(AssignmentTrackingAnalysis, DEBUG_TYPE,</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2576</td>
    <td class="">                "Assignment Tracking Analysis", false, true)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2577</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Functions Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Functions Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Function name</th>
    <th class="mainTh">Number of hits</th>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12DenseMapInfoINS_10VariableIDEvE11getEmptyKeyEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12DenseMapInfoINS_10VariableIDEvE15getTombstoneKeyEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12DenseMapInfoINS_10VariableIDEvE12getHashValueERKS1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12DenseMapInfoINS_10VariableIDEvE7isEqualERKS1_S4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK22FunctionVarLocsBuilder15getNumVariablesEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN22FunctionVarLocsBuilder14insertVariableEN4llvm13DebugVariableE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK22FunctionVarLocsBuilder11getVariableEN4llvm10VariableIDE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK22FunctionVarLocsBuilder8getWedgeEPKN4llvm11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN22FunctionVarLocsBuilder8setWedgeEPKN4llvm11InstructionEONS0_11SmallVectorINS0_10VarLocInfoELj1EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN22FunctionVarLocsBuilder15addSingleLocVarEN4llvm13DebugVariableEPNS0_12DIExpressionENS0_8DebugLocENS0_18RawLocationWrapperE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN22FunctionVarLocsBuilder9addVarLocEPN4llvm11InstructionENS0_13DebugVariableEPNS0_12DIExpressionENS0_8DebugLocENS0_18RawLocationWrapperE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15FunctionVarLocs5printERNS_11raw_ostreamERKNS_8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK4llvm15FunctionVarLocs5printERNS_11raw_ostreamERKNS_8FunctionEENKUlRKNS_10VarLocInfoEE_clES8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15FunctionVarLocs4initER22FunctionVarLocsBuilder</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15FunctionVarLocs5clearEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL33walkToAllocaAndPrependOffsetDerefRKN4llvm10DataLayoutEPNS_5ValueEPNS_12DIExpressionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL21getDerefOffsetInBytesPKN4llvm12DIExpressionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL12getAggregatePKN4llvm20DbgVariableIntrinsicE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL12getAggregateRKN4llvm13DebugVariableE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL23shouldCoalesceFragmentsRN4llvm8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_118MemLocFragmentFill20intervalMapsAreEqualERKN4llvm11IntervalMapIjjLj16ENS1_23IntervalMapHalfOpenInfoIjEEEES7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_118MemLocFragmentFill19varFragMapsAreEqualERKN4llvm8DenseMapIjNS1_11IntervalMapIjjLj16ENS1_23IntervalMapHalfOpenInfoIjEEEENS1_12DenseMapInfoIjvEENS1_6detail12DenseMapPairIjS6_EEEESE_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_118MemLocFragmentFill8toStringEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_118MemLocFragmentFill8toStringEN4llvm11IntervalMapIjjLj16ENS1_23IntervalMapHalfOpenInfoIjEEE14const_iteratorEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_118MemLocFragmentFill13meetFragmentsERKN4llvm11IntervalMapIjjLj16ENS1_23IntervalMapHalfOpenInfoIjEEEES7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_118MemLocFragmentFill8meetVarsERN4llvm8DenseMapIjNS1_11IntervalMapIjjLj16ENS1_23IntervalMapHalfOpenInfoIjEEEENS1_12DenseMapInfoIjvEENS1_6detail12DenseMapPairIjS6_EEEERKSC_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_118MemLocFragmentFill4meetERKN4llvm10BasicBlockERKNS1_11SmallPtrSetIPS2_Lj16EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_118MemLocFragmentFill12insertMemLocERN4llvm10BasicBlockERNS1_11InstructionEjjjjNS1_8DebugLocE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_118MemLocFragmentFill17coalesceFragmentsERN4llvm10BasicBlockERNS1_11InstructionEjjjjNS1_8DebugLocERKNS1_11IntervalMapIjjLj16ENS1_23IntervalMapHalfOpenInfoIjEEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_118MemLocFragmentFill6addDefERKN4llvm10VarLocInfoERNS1_11InstructionERNS1_10BasicBlockERNS1_8DenseMapIjNS1_11IntervalMapIjjLj16ENS1_23IntervalMapHalfOpenInfoIjEEEENS1_12DenseMapInfoIjvEENS1_6detail12DenseMapPairIjSD_EEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_118MemLocFragmentFill12skipVariableEPKN4llvm15DILocalVariableE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_118MemLocFragmentFill7processERN4llvm10BasicBlockERNS1_8DenseMapIjNS1_11IntervalMapIjjLj16ENS1_23IntervalMapHalfOpenInfoIjEEEENS1_12DenseMapInfoIjvEENS1_6detail12DenseMapPairIjS8_EEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_118MemLocFragmentFillC2ERN4llvm8FunctionEPKNS1_8DenseSetISt4pairIPKNS1_15DILocalVariableEPKNS1_10DILocationEENS1_12DenseMapInfoISC_vEEEEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_118MemLocFragmentFill3runEP22FunctionVarLocsBuilder</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_126AssignmentTrackingLowering10Assignment22isSameSourceAssignmentERKS1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126AssignmentTrackingLowering10Assignment4dumpERN4llvm11raw_ostreamE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126AssignmentTrackingLowering10Assignment4makeEPN4llvm10DIAssignIDEPNS2_18DbgAssignIntrinsicE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126AssignmentTrackingLowering10Assignment14makeFromMemDefEPN4llvm10DIAssignIDE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126AssignmentTrackingLowering10Assignment13makeNoneOrPhiEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126AssignmentTrackingLowering10AssignmentC2ENS1_1SEPN4llvm10DIAssignIDEPNS3_18DbgAssignIntrinsicE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126AssignmentTrackingLowering12mapsAreEqualERKN4llvm9BitVectorERKNS1_11SmallVectorINS0_10AssignmentELj2EEES9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_126AssignmentTrackingLowering12mapsAreEqualERKN4llvm9BitVectorERKNS1_11SmallVectorINS0_10AssignmentELj2EEES9_ENKUljE_clEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_126AssignmentTrackingLowering9BlockInfo16getAssignmentMapENS1_14AssignmentKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126AssignmentTrackingLowering9BlockInfo16getAssignmentMapENS1_14AssignmentKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_126AssignmentTrackingLowering9BlockInfo17isVariableTrackedEN4llvm10VariableIDE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_126AssignmentTrackingLowering9BlockInfo13getAssignmentENS1_14AssignmentKindEN4llvm10VariableIDE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_126AssignmentTrackingLowering9BlockInfo10getLocKindEN4llvm10VariableIDE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126AssignmentTrackingLowering9BlockInfo10setLocKindEN4llvm10VariableIDENS0_7LocKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126AssignmentTrackingLowering9BlockInfo13setAssignmentENS1_14AssignmentKindEN4llvm10VariableIDERKNS0_10AssignmentE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_126AssignmentTrackingLowering9BlockInfo13hasAssignmentENS1_14AssignmentKindEN4llvm10VariableIDERKNS0_10AssignmentE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_126AssignmentTrackingLowering9BlockInfoeqERKS1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_126AssignmentTrackingLowering9BlockInfoneERKS1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126AssignmentTrackingLowering9BlockInfo7isValidEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126AssignmentTrackingLowering9BlockInfo4initEi</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126AssignmentTrackingLowering9BlockInfo8joinElmtINS0_10AssignmentERKS3_EEviRN4llvm11SmallVectorIT_XsrNS6_42CalculateSmallVectorDefaultInlinedElementsIS8_EE5valueEEERKSB_SE_PFS8_T0_SF_E</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126AssignmentTrackingLowering9BlockInfo8joinElmtINS0_7LocKindES3_EEviRN4llvm11SmallVectorIT_XsrNS4_42CalculateSmallVectorDefaultInlinedElementsIS6_EE5valueEEERKS9_SC_PFS6_T0_SD_E</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126AssignmentTrackingLowering9BlockInfo4joinERKS1_S3_i</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126AssignmentTrackingLowering13getVariableIDERKN4llvm13DebugVariableE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126AssignmentTrackingLoweringC2ERN4llvm8FunctionERKNS1_10DataLayoutEPKNS1_8DenseSetISt4pairIPKNS1_15DILocalVariableEPKNS1_10DILocationEENS1_12DenseMapInfoISF_vEEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_126AssignmentTrackingLowering21getContainedFragmentsEN4llvm10VariableIDE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126AssignmentTrackingLowering13touchFragmentEN4llvm10VariableIDE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126AssignmentTrackingLowering10setLocKindEPNS0_9BlockInfoEN4llvm10VariableIDENS0_7LocKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_126AssignmentTrackingLowering10setLocKindEPNS0_9BlockInfoEN4llvm10VariableIDENS0_7LocKindEENKUlS2_S4_S5_E_clES2_S4_S5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126AssignmentTrackingLowering10getLocKindEPNS0_9BlockInfoEN4llvm10VariableIDE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126AssignmentTrackingLowering9addMemDefEPNS0_9BlockInfoEN4llvm10VariableIDERKNS0_10AssignmentE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126AssignmentTrackingLowering9addDbgDefEPNS0_9BlockInfoEN4llvm10VariableIDERKNS0_10AssignmentE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL13getIDFromInstRKN4llvm11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL15getIDFromMarkerRKN4llvm18DbgAssignIntrinsicE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126AssignmentTrackingLowering20hasVarWithAssignmentEPNS0_9BlockInfoENS1_14AssignmentKindEN4llvm10VariableIDERKNS0_10AssignmentE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_Z6locStrN12_GLOBAL__N_126AssignmentTrackingLowering7LocKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126AssignmentTrackingLowering12emitDbgValueENS0_7LocKindEPKN4llvm20DbgVariableIntrinsicEPNS2_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_126AssignmentTrackingLowering12emitDbgValueENS0_7LocKindEPKN4llvm20DbgVariableIntrinsicEPNS2_11InstructionEENKUlPNS2_8MetadataEPNS2_12DIExpressionEE_clES9_SB_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126AssignmentTrackingLowering24processNonDbgInstructionERN4llvm11InstructionEPNS0_9BlockInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126AssignmentTrackingLowering26processUntaggedInstructionERN4llvm11InstructionEPNS0_9BlockInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126AssignmentTrackingLowering24processTaggedInstructionERN4llvm11InstructionEPNS0_9BlockInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126AssignmentTrackingLowering16processDbgAssignERN4llvm18DbgAssignIntrinsicEPNS0_9BlockInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126AssignmentTrackingLowering15processDbgValueERN4llvm12DbgValueInstEPNS0_9BlockInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL20hasZeroSizedFragmentRN4llvm20DbgVariableIntrinsicE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126AssignmentTrackingLowering21processDbgInstructionERN4llvm16DbgInfoIntrinsicEPNS0_9BlockInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126AssignmentTrackingLowering19resetInsertionPointERN4llvm11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126AssignmentTrackingLowering7processERN4llvm10BasicBlockEPNS0_9BlockInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126AssignmentTrackingLowering8joinKindENS0_7LocKindES1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126AssignmentTrackingLowering14joinAssignmentERKNS0_10AssignmentES3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_126AssignmentTrackingLowering14joinAssignmentERKNS0_10AssignmentES3_ENKUlvE_clEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126AssignmentTrackingLowering13joinBlockInfoERKNS0_9BlockInfoES3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126AssignmentTrackingLowering4joinERKN4llvm10BasicBlockERKNS1_11SmallPtrSetIPS2_Lj16EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL13fullyContainsN4llvm12DIExpression12FragmentInfoES1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL30getUntaggedStoreAssignmentInfoRKN4llvm11InstructionERKNS_10DataLayoutE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL32buildOverlapMapAndRecordDeclaresRN4llvm8FunctionEP22FunctionVarLocsBuilderRKNS_8DenseSetISt4pairIPKNS_15DILocalVariableEPKNS_10DILocationEENS_12DenseMapInfoISC_vEEEERNS_8DenseMapIPKNS_11InstructionENS_11SmallVectorIS5_INS_10VariableIDENS_2at14AssignmentInfoEELj1EEENSD_ISL_vEENS_6detail12DenseMapPairISL_SR_EEEERj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZL32buildOverlapMapAndRecordDeclaresRN4llvm8FunctionEP22FunctionVarLocsBuilderRKNS_8DenseSetISt4pairIPKNS_15DILocalVariableEPKNS_10DILocationEENS_12DenseMapInfoISC_vEEEERNS_8DenseMapIPKNS_11InstructionENS_11SmallVectorIS5_INS_10VariableIDENS_2at14AssignmentInfoEELj1EEENSD_ISL_vEENS_6detail12DenseMapPairISL_SR_EEEERjENKUlvE_clEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZL32buildOverlapMapAndRecordDeclaresRN4llvm8FunctionEP22FunctionVarLocsBuilderRKNS_8DenseSetISt4pairIPKNS_15DILocalVariableEPKNS_10DILocationEENS_12DenseMapInfoISC_vEEEERNS_8DenseMapIPKNS_11InstructionENS_11SmallVectorIS5_INS_10VariableIDENS_2at14AssignmentInfoEELj1EEENSD_ISL_vEENS_6detail12DenseMapPairISL_SR_EEEERjENKUlRKNS_13DebugVariableES11_E0_clES11_S11_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126AssignmentTrackingLowering3runEP22FunctionVarLocsBuilder</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_126AssignmentTrackingLowering19emitPromotedVarLocsEP22FunctionVarLocsBuilder</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL39removeRedundantDbgLocsUsingBackwardScanPKN4llvm10BasicBlockER22FunctionVarLocsBuilder</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL38removeRedundantDbgLocsUsingForwardScanPKN4llvm10BasicBlockER22FunctionVarLocsBuilder</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL32removeUndefDbgLocsFromEntryBlockPKN4llvm10BasicBlockER22FunctionVarLocsBuilder</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZL32removeUndefDbgLocsFromEntryBlockPKN4llvm10BasicBlockER22FunctionVarLocsBuilderENKUlSt4pairIPKNS_15DILocalVariableEPKNS_10DILocationEENS_13DebugVariableEE_clESC_SD_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZL32removeUndefDbgLocsFromEntryBlockPKN4llvm10BasicBlockER22FunctionVarLocsBuilderENKUlSt4pairIPKNS_15DILocalVariableEPKNS_10DILocationEENS_13DebugVariableEE0_clESC_SD_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZZL32removeUndefDbgLocsFromEntryBlockPKN4llvm10BasicBlockER22FunctionVarLocsBuilderENKUlSt4pairIPKNS_15DILocalVariableEPKNS_10DILocationEENS_13DebugVariableEE0_clESC_SD_ENKUlT_E_clINS_12DIExpression12FragmentInfoEEEDaSF_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL22removeRedundantDbgLocsPKN4llvm10BasicBlockER22FunctionVarLocsBuilder</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL21findVarsWithStackSlotRN4llvm8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL15analyzeFunctionRN4llvm8FunctionERKNS_10DataLayoutEP22FunctionVarLocsBuilder</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm26AssignmentTrackingAnalysis13runOnFunctionERNS_8FunctionE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm26AssignmentTrackingAnalysisC2Ev</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL44initializeAssignmentTrackingAnalysisPassOnceRN4llvm12PassRegistryE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm40initializeAssignmentTrackingAnalysisPassERNS_12PassRegistryE</td>
    <td class="numberOfCalls">4</td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Coverage Diff</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Coverage Diff</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeline">#include "llvm/CodeGen/AssignmentTrackingAnalysis.h"</td>
    <td class="lineNumber">1</td>
    <td class="codeline">#include "llvm/CodeGen/AssignmentTrackingAnalysis.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeline">#include "LiveDebugValues/LiveDebugValues.h"</td>
    <td class="lineNumber">2</td>
    <td class="codeline">#include "LiveDebugValues/LiveDebugValues.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeline">#include "llvm/ADT/BitVector.h"</td>
    <td class="lineNumber">3</td>
    <td class="codeline">#include "llvm/ADT/BitVector.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeline">#include "llvm/ADT/DenseMapInfo.h"</td>
    <td class="lineNumber">4</td>
    <td class="codeline">#include "llvm/ADT/DenseMapInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeline">#include "llvm/ADT/IntervalMap.h"</td>
    <td class="lineNumber">5</td>
    <td class="codeline">#include "llvm/ADT/IntervalMap.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeline">#include "llvm/ADT/PostOrderIterator.h"</td>
    <td class="lineNumber">6</td>
    <td class="codeline">#include "llvm/ADT/PostOrderIterator.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeline">#include "llvm/ADT/STLExtras.h"</td>
    <td class="lineNumber">7</td>
    <td class="codeline">#include "llvm/ADT/STLExtras.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeline">#include "llvm/ADT/SmallSet.h"</td>
    <td class="lineNumber">8</td>
    <td class="codeline">#include "llvm/ADT/SmallSet.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeline">#include "llvm/ADT/Statistic.h"</td>
    <td class="lineNumber">9</td>
    <td class="codeline">#include "llvm/ADT/Statistic.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeline">#include "llvm/ADT/UniqueVector.h"</td>
    <td class="lineNumber">10</td>
    <td class="codeline">#include "llvm/ADT/UniqueVector.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeline">#include "llvm/Analysis/Interval.h"</td>
    <td class="lineNumber">11</td>
    <td class="codeline">#include "llvm/Analysis/Interval.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeline">#include "llvm/BinaryFormat/Dwarf.h"</td>
    <td class="lineNumber">12</td>
    <td class="codeline">#include "llvm/BinaryFormat/Dwarf.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeline">#include "llvm/IR/BasicBlock.h"</td>
    <td class="lineNumber">13</td>
    <td class="codeline">#include "llvm/IR/BasicBlock.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeline">#include "llvm/IR/DataLayout.h"</td>
    <td class="lineNumber">14</td>
    <td class="codeline">#include "llvm/IR/DataLayout.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeline">#include "llvm/IR/DebugInfo.h"</td>
    <td class="lineNumber">15</td>
    <td class="codeline">#include "llvm/IR/DebugInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeline">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">16</td>
    <td class="codeline">#include "llvm/IR/Function.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeline">#include "llvm/IR/Instruction.h"</td>
    <td class="lineNumber">17</td>
    <td class="codeline">#include "llvm/IR/Instruction.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeline">#include "llvm/IR/IntrinsicInst.h"</td>
    <td class="lineNumber">18</td>
    <td class="codeline">#include "llvm/IR/IntrinsicInst.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeline">#include "llvm/IR/PassManager.h"</td>
    <td class="lineNumber">19</td>
    <td class="codeline">#include "llvm/IR/PassManager.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeline">#include "llvm/IR/PrintPasses.h"</td>
    <td class="lineNumber">20</td>
    <td class="codeline">#include "llvm/IR/PrintPasses.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeline">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">21</td>
    <td class="codeline">#include "llvm/InitializePasses.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeline">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">22</td>
    <td class="codeline">#include "llvm/Support/CommandLine.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/Support/ErrorHandling.h"</td>
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/Support/ErrorHandling.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/Support/raw_ostream.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/Transforms/Utils/BasicBlockUtils.h"</td>
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/Transforms/Utils/BasicBlockUtils.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeline">#include <assert.h></td>
    <td class="lineNumber">26</td>
    <td class="codeline">#include <assert.h></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeline">#include <cstdint></td>
    <td class="lineNumber">27</td>
    <td class="codeline">#include <cstdint></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeline">#include <optional></td>
    <td class="lineNumber">28</td>
    <td class="codeline">#include <optional></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeline">#include <sstream></td>
    <td class="lineNumber">29</td>
    <td class="codeline">#include <sstream></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeline">#include <unordered_map></td>
    <td class="lineNumber">30</td>
    <td class="codeline">#include <unordered_map></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeline"></td>
    <td class="lineNumber">31</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeline">using namespace llvm;</td>
    <td class="lineNumber">32</td>
    <td class="codeline">using namespace llvm;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeline">#define DEBUG_TYPE "debug-ata"</td>
    <td class="lineNumber">33</td>
    <td class="codeline">#define DEBUG_TYPE "debug-ata"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeline"></td>
    <td class="lineNumber">34</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeline">STATISTIC(NumDefsScanned, "Number of dbg locs that get scanned for removal");</td>
    <td class="lineNumber">35</td>
    <td class="codeline">STATISTIC(NumDefsScanned, "Number of dbg locs that get scanned for removal");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeline">STATISTIC(NumDefsRemoved, "Number of dbg locs removed");</td>
    <td class="lineNumber">36</td>
    <td class="codeline">STATISTIC(NumDefsRemoved, "Number of dbg locs removed");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeline">STATISTIC(NumWedgesScanned, "Number of dbg wedges scanned");</td>
    <td class="lineNumber">37</td>
    <td class="codeline">STATISTIC(NumWedgesScanned, "Number of dbg wedges scanned");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeline">STATISTIC(NumWedgesChanged, "Number of dbg wedges changed");</td>
    <td class="lineNumber">38</td>
    <td class="codeline">STATISTIC(NumWedgesChanged, "Number of dbg wedges changed");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeline"></td>
    <td class="lineNumber">39</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeline">static cl::opt<unsigned></td>
    <td class="lineNumber">40</td>
    <td class="codeline">static cl::opt<unsigned></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeline">    MaxNumBlocks("debug-ata-max-blocks", cl::init(10000),</td>
    <td class="lineNumber">41</td>
    <td class="codeline">    MaxNumBlocks("debug-ata-max-blocks", cl::init(10000),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeline">                 cl::desc("Maximum num basic blocks before debug info dropped"),</td>
    <td class="lineNumber">42</td>
    <td class="codeline">                 cl::desc("Maximum num basic blocks before debug info dropped"),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeline">                 cl::Hidden);</td>
    <td class="lineNumber">43</td>
    <td class="codeline">                 cl::Hidden);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeline">/// Option for debugging the pass, determines if the memory location fragment</td>
    <td class="lineNumber">44</td>
    <td class="codeline">/// Option for debugging the pass, determines if the memory location fragment</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeline">/// filling happens after generating the variable locations.</td>
    <td class="lineNumber">45</td>
    <td class="codeline">/// filling happens after generating the variable locations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeline">static cl::opt<bool> EnableMemLocFragFill("mem-loc-frag-fill", cl::init(true),</td>
    <td class="lineNumber">46</td>
    <td class="codeline">static cl::opt<bool> EnableMemLocFragFill("mem-loc-frag-fill", cl::init(true),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeline">                                          cl::Hidden);</td>
    <td class="lineNumber">47</td>
    <td class="codeline">                                          cl::Hidden);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeline">/// Print the results of the analysis. Respects -filter-print-funcs.</td>
    <td class="lineNumber">48</td>
    <td class="codeline">/// Print the results of the analysis. Respects -filter-print-funcs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeline">static cl::opt<bool> PrintResults("print-debug-ata", cl::init(false),</td>
    <td class="lineNumber">49</td>
    <td class="codeline">static cl::opt<bool> PrintResults("print-debug-ata", cl::init(false),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeline">                                  cl::Hidden);</td>
    <td class="lineNumber">50</td>
    <td class="codeline">                                  cl::Hidden);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeline"></td>
    <td class="lineNumber">51</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeline">/// Coalesce adjacent dbg locs describing memory locations that have contiguous</td>
    <td class="lineNumber">52</td>
    <td class="codeline">/// Coalesce adjacent dbg locs describing memory locations that have contiguous</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeline">/// fragments. This reduces the cost of LiveDebugValues which does SSA</td>
    <td class="lineNumber">53</td>
    <td class="codeline">/// fragments. This reduces the cost of LiveDebugValues which does SSA</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeline">/// construction for each explicitly stated variable fragment.</td>
    <td class="lineNumber">54</td>
    <td class="codeline">/// construction for each explicitly stated variable fragment.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeline">static cl::opt<cl::boolOrDefault></td>
    <td class="lineNumber">55</td>
    <td class="codeline">static cl::opt<cl::boolOrDefault></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeline">    CoalesceAdjacentFragmentsOpt("debug-ata-coalesce-frags", cl::Hidden);</td>
    <td class="lineNumber">56</td>
    <td class="codeline">    CoalesceAdjacentFragmentsOpt("debug-ata-coalesce-frags", cl::Hidden);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeline"></td>
    <td class="lineNumber">57</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeline">// Implicit conversions are disabled for enum class types, so unfortunately we</td>
    <td class="lineNumber">58</td>
    <td class="codeline">// Implicit conversions are disabled for enum class types, so unfortunately we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeline">// need to create a DenseMapInfo wrapper around the specified underlying type.</td>
    <td class="lineNumber">59</td>
    <td class="codeline">// need to create a DenseMapInfo wrapper around the specified underlying type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeline">template <> struct llvm::DenseMapInfo<VariableID> {</td>
    <td class="lineNumber">60</td>
    <td class="codeline">template <> struct llvm::DenseMapInfo<VariableID> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeline">  using Wrapped = DenseMapInfo<unsigned>;</td>
    <td class="lineNumber">61</td>
    <td class="codeline">  using Wrapped = DenseMapInfo<unsigned>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeline">  static inline VariableID getEmptyKey() {</td>
    <td class="lineNumber">62</td>
    <td class="codeline">  static inline VariableID getEmptyKey() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeline">    return static_cast<VariableID>(Wrapped::getEmptyKey());</td>
    <td class="lineNumber">63</td>
    <td class="codeline">    return static_cast<VariableID>(Wrapped::getEmptyKey());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">64</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeline">  static inline VariableID getTombstoneKey() {</td>
    <td class="lineNumber">65</td>
    <td class="codeline">  static inline VariableID getTombstoneKey() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeline">    return static_cast<VariableID>(Wrapped::getTombstoneKey());</td>
    <td class="lineNumber">66</td>
    <td class="codeline">    return static_cast<VariableID>(Wrapped::getTombstoneKey());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">67</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeline">  static unsigned getHashValue(const VariableID &Val) {</td>
    <td class="lineNumber">68</td>
    <td class="codeline">  static unsigned getHashValue(const VariableID &Val) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeline">    return Wrapped::getHashValue(static_cast<unsigned>(Val));</td>
    <td class="lineNumber">69</td>
    <td class="codeline">    return Wrapped::getHashValue(static_cast<unsigned>(Val));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">70</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeline">  static bool isEqual(const VariableID &LHS, const VariableID &RHS) {</td>
    <td class="lineNumber">71</td>
    <td class="codeline">  static bool isEqual(const VariableID &LHS, const VariableID &RHS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeline">    return LHS == RHS;</td>
    <td class="lineNumber">72</td>
    <td class="codeline">    return LHS == RHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">73</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeline">};</td>
    <td class="lineNumber">74</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeline"></td>
    <td class="lineNumber">75</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeline">/// Helper class to build FunctionVarLocs, since that class isn't easy to</td>
    <td class="lineNumber">76</td>
    <td class="codeline">/// Helper class to build FunctionVarLocs, since that class isn't easy to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeline">/// modify. TODO: There's not a great deal of value in the split, it could be</td>
    <td class="lineNumber">77</td>
    <td class="codeline">/// modify. TODO: There's not a great deal of value in the split, it could be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeline">/// worth merging the two classes.</td>
    <td class="lineNumber">78</td>
    <td class="codeline">/// worth merging the two classes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeline">class FunctionVarLocsBuilder {</td>
    <td class="lineNumber">79</td>
    <td class="codeline">class FunctionVarLocsBuilder {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeline">  friend FunctionVarLocs;</td>
    <td class="lineNumber">80</td>
    <td class="codeline">  friend FunctionVarLocs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeline">  UniqueVector<DebugVariable> Variables;</td>
    <td class="lineNumber">81</td>
    <td class="codeline">  UniqueVector<DebugVariable> Variables;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeline">  // Use an unordered_map so we don't invalidate iterators after</td>
    <td class="lineNumber">82</td>
    <td class="codeline">  // Use an unordered_map so we don't invalidate iterators after</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeline">  // insert/modifications.</td>
    <td class="lineNumber">83</td>
    <td class="codeline">  // insert/modifications.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeline">  std::unordered_map<const Instruction *, SmallVector<VarLocInfo>></td>
    <td class="lineNumber">84</td>
    <td class="codeline">  std::unordered_map<const Instruction *, SmallVector<VarLocInfo>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeline">      VarLocsBeforeInst;</td>
    <td class="lineNumber">85</td>
    <td class="codeline">      VarLocsBeforeInst;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeline"></td>
    <td class="lineNumber">86</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeline">  SmallVector<VarLocInfo> SingleLocVars;</td>
    <td class="lineNumber">87</td>
    <td class="codeline">  SmallVector<VarLocInfo> SingleLocVars;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeline"></td>
    <td class="lineNumber">88</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">89</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeline">  unsigned getNumVariables() const { return Variables.size(); }</td>
    <td class="lineNumber">90</td>
    <td class="codeline">  unsigned getNumVariables() const { return Variables.size(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeline"></td>
    <td class="lineNumber">91</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeline">  /// Find or insert \p V and return the ID.</td>
    <td class="lineNumber">92</td>
    <td class="codeline">  /// Find or insert \p V and return the ID.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeline">  VariableID insertVariable(DebugVariable V) {</td>
    <td class="lineNumber">93</td>
    <td class="codeline">  VariableID insertVariable(DebugVariable V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeline">    return static_cast<VariableID>(Variables.insert(V));</td>
    <td class="lineNumber">94</td>
    <td class="codeline">    return static_cast<VariableID>(Variables.insert(V));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">95</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeline"></td>
    <td class="lineNumber">96</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeline">  /// Get a variable from its \p ID.</td>
    <td class="lineNumber">97</td>
    <td class="codeline">  /// Get a variable from its \p ID.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeline">  const DebugVariable &getVariable(VariableID ID) const {</td>
    <td class="lineNumber">98</td>
    <td class="codeline">  const DebugVariable &getVariable(VariableID ID) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeline">    return Variables[static_cast<unsigned>(ID)];</td>
    <td class="lineNumber">99</td>
    <td class="codeline">    return Variables[static_cast<unsigned>(ID)];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">100</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeline"></td>
    <td class="lineNumber">101</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeline">  /// Return ptr to wedge of defs or nullptr if no defs come just before /p</td>
    <td class="lineNumber">102</td>
    <td class="codeline">  /// Return ptr to wedge of defs or nullptr if no defs come just before /p</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeline">  /// Before.</td>
    <td class="lineNumber">103</td>
    <td class="codeline">  /// Before.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeline">  const SmallVectorImpl<VarLocInfo> *getWedge(const Instruction *Before) const {</td>
    <td class="lineNumber">104</td>
    <td class="codeline">  const SmallVectorImpl<VarLocInfo> *getWedge(const Instruction *Before) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeline">    auto R = VarLocsBeforeInst.find(Before);</td>
    <td class="lineNumber">105</td>
    <td class="codeline">    auto R = VarLocsBeforeInst.find(Before);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeline">    if (R == VarLocsBeforeInst.end())</td>
    <td class="lineNumber">106</td>
    <td class="codeline">    if (R == VarLocsBeforeInst.end())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeline">      return nullptr;</td>
    <td class="lineNumber">107</td>
    <td class="codeline">      return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeline">    return &R->second;</td>
    <td class="lineNumber">108</td>
    <td class="codeline">    return &R->second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">109</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeline"></td>
    <td class="lineNumber">110</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeline">  /// Replace the defs that come just before /p Before with /p Wedge.</td>
    <td class="lineNumber">111</td>
    <td class="codeline">  /// Replace the defs that come just before /p Before with /p Wedge.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeline">  void setWedge(const Instruction *Before, SmallVector<VarLocInfo> &&Wedge) {</td>
    <td class="lineNumber">112</td>
    <td class="codeline">  void setWedge(const Instruction *Before, SmallVector<VarLocInfo> &&Wedge) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeline">    VarLocsBeforeInst[Before] = std::move(Wedge);</td>
    <td class="lineNumber">113</td>
    <td class="codeline">    VarLocsBeforeInst[Before] = std::move(Wedge);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">114</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeline"></td>
    <td class="lineNumber">115</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeline">  /// Add a def for a variable that is valid for its lifetime.</td>
    <td class="lineNumber">116</td>
    <td class="codeline">  /// Add a def for a variable that is valid for its lifetime.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeline">  void addSingleLocVar(DebugVariable Var, DIExpression *Expr, DebugLoc DL,</td>
    <td class="lineNumber">117</td>
    <td class="codeline">  void addSingleLocVar(DebugVariable Var, DIExpression *Expr, DebugLoc DL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeline">                       RawLocationWrapper R) {</td>
    <td class="lineNumber">118</td>
    <td class="codeline">                       RawLocationWrapper R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeline">    VarLocInfo VarLoc;</td>
    <td class="lineNumber">119</td>
    <td class="codeline">    VarLocInfo VarLoc;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeline">    VarLoc.VariableID = insertVariable(Var);</td>
    <td class="lineNumber">120</td>
    <td class="codeline">    VarLoc.VariableID = insertVariable(Var);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeline">    VarLoc.Expr = Expr;</td>
    <td class="lineNumber">121</td>
    <td class="codeline">    VarLoc.Expr = Expr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeline">    VarLoc.DL = DL;</td>
    <td class="lineNumber">122</td>
    <td class="codeline">    VarLoc.DL = DL;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeline">    VarLoc.Values = R;</td>
    <td class="lineNumber">123</td>
    <td class="codeline">    VarLoc.Values = R;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeline">    SingleLocVars.emplace_back(VarLoc);</td>
    <td class="lineNumber">124</td>
    <td class="codeline">    SingleLocVars.emplace_back(VarLoc);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">125</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeline"></td>
    <td class="lineNumber">126</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeline">  /// Add a def to the wedge of defs just before /p Before.</td>
    <td class="lineNumber">127</td>
    <td class="codeline">  /// Add a def to the wedge of defs just before /p Before.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeline">  void addVarLoc(Instruction *Before, DebugVariable Var, DIExpression *Expr,</td>
    <td class="lineNumber">128</td>
    <td class="codeline">  void addVarLoc(Instruction *Before, DebugVariable Var, DIExpression *Expr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeline">                 DebugLoc DL, RawLocationWrapper R) {</td>
    <td class="lineNumber">129</td>
    <td class="codeline">                 DebugLoc DL, RawLocationWrapper R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeline">    VarLocInfo VarLoc;</td>
    <td class="lineNumber">130</td>
    <td class="codeline">    VarLocInfo VarLoc;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeline">    VarLoc.VariableID = insertVariable(Var);</td>
    <td class="lineNumber">131</td>
    <td class="codeline">    VarLoc.VariableID = insertVariable(Var);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeline">    VarLoc.Expr = Expr;</td>
    <td class="lineNumber">132</td>
    <td class="codeline">    VarLoc.Expr = Expr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeline">    VarLoc.DL = DL;</td>
    <td class="lineNumber">133</td>
    <td class="codeline">    VarLoc.DL = DL;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeline">    VarLoc.Values = R;</td>
    <td class="lineNumber">134</td>
    <td class="codeline">    VarLoc.Values = R;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeline">    VarLocsBeforeInst[Before].emplace_back(VarLoc);</td>
    <td class="lineNumber">135</td>
    <td class="codeline">    VarLocsBeforeInst[Before].emplace_back(VarLoc);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">136</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeline">};</td>
    <td class="lineNumber">137</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeline"></td>
    <td class="lineNumber">138</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeline">void FunctionVarLocs::print(raw_ostream &OS, const Function &Fn) const {</td>
    <td class="lineNumber">139</td>
    <td class="codeline">void FunctionVarLocs::print(raw_ostream &OS, const Function &Fn) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeline">  // Print the variable table first. TODO: Sorting by variable could make the</td>
    <td class="lineNumber">140</td>
    <td class="codeline">  // Print the variable table first. TODO: Sorting by variable could make the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeline">  // output more stable?</td>
    <td class="lineNumber">141</td>
    <td class="codeline">  // output more stable?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeline">  unsigned Counter = -1;</td>
    <td class="lineNumber">142</td>
    <td class="codeline">  unsigned Counter = -1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeline">  OS << "=== Variables ===\n";</td>
    <td class="lineNumber">143</td>
    <td class="codeline">  OS << "=== Variables ===\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeline">  for (const DebugVariable &V : Variables) {</td>
    <td class="lineNumber">144</td>
    <td class="codeline">  for (const DebugVariable &V : Variables) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeline">    ++Counter;</td>
    <td class="lineNumber">145</td>
    <td class="codeline">    ++Counter;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeline">    // Skip first entry because it is a dummy entry.</td>
    <td class="lineNumber">146</td>
    <td class="codeline">    // Skip first entry because it is a dummy entry.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeline">    if (Counter == 0) {</td>
    <td class="lineNumber">147</td>
    <td class="codeline">    if (Counter == 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">148</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">149</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeline">    OS << "[" << Counter << "] " << V.getVariable()->getName();</td>
    <td class="lineNumber">150</td>
    <td class="codeline">    OS << "[" << Counter << "] " << V.getVariable()->getName();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeline">    if (auto F = V.getFragment())</td>
    <td class="lineNumber">151</td>
    <td class="codeline">    if (auto F = V.getFragment())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeline">      OS << " bits [" << F->OffsetInBits << ", "</td>
    <td class="lineNumber">152</td>
    <td class="codeline">      OS << " bits [" << F->OffsetInBits << ", "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeline">         << F->OffsetInBits + F->SizeInBits << ")";</td>
    <td class="lineNumber">153</td>
    <td class="codeline">         << F->OffsetInBits + F->SizeInBits << ")";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeline">    if (const auto *IA = V.getInlinedAt())</td>
    <td class="lineNumber">154</td>
    <td class="codeline">    if (const auto *IA = V.getInlinedAt())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeline">      OS << " inlined-at " << *IA;</td>
    <td class="lineNumber">155</td>
    <td class="codeline">      OS << " inlined-at " << *IA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeline">    OS << "\n";</td>
    <td class="lineNumber">156</td>
    <td class="codeline">    OS << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">157</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeline"></td>
    <td class="lineNumber">158</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeline">  auto PrintLoc = [&OS](const VarLocInfo &Loc) {</td>
    <td class="lineNumber">159</td>
    <td class="codeline">  auto PrintLoc = [&OS](const VarLocInfo &Loc) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeline">    OS << "DEF Var=[" << (unsigned)Loc.VariableID << "]"</td>
    <td class="lineNumber">160</td>
    <td class="codeline">    OS << "DEF Var=[" << (unsigned)Loc.VariableID << "]"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeline">       << " Expr=" << *Loc.Expr << " Values=(";</td>
    <td class="lineNumber">161</td>
    <td class="codeline">       << " Expr=" << *Loc.Expr << " Values=(";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeline">    for (auto *Op : Loc.Values.location_ops()) {</td>
    <td class="lineNumber">162</td>
    <td class="codeline">    for (auto *Op : Loc.Values.location_ops()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeline">      errs() << Op->getName() << " ";</td>
    <td class="lineNumber">163</td>
    <td class="codeline">      errs() << Op->getName() << " ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">164</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeline">    errs() << ")\n";</td>
    <td class="lineNumber">165</td>
    <td class="codeline">    errs() << ")\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">166</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeline"></td>
    <td class="lineNumber">167</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeline">  // Print the single location variables.</td>
    <td class="lineNumber">168</td>
    <td class="codeline">  // Print the single location variables.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeline">  OS << "=== Single location vars ===\n";</td>
    <td class="lineNumber">169</td>
    <td class="codeline">  OS << "=== Single location vars ===\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeline">  for (auto It = single_locs_begin(), End = single_locs_end(); It != End;</td>
    <td class="lineNumber">170</td>
    <td class="codeline">  for (auto It = single_locs_begin(), End = single_locs_end(); It != End;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeline">       ++It) {</td>
    <td class="lineNumber">171</td>
    <td class="codeline">       ++It) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeline">    PrintLoc(*It);</td>
    <td class="lineNumber">172</td>
    <td class="codeline">    PrintLoc(*It);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">173</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeline"></td>
    <td class="lineNumber">174</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeline">  // Print the non-single-location defs in line with IR.</td>
    <td class="lineNumber">175</td>
    <td class="codeline">  // Print the non-single-location defs in line with IR.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeline">  OS << "=== In-line variable defs ===";</td>
    <td class="lineNumber">176</td>
    <td class="codeline">  OS << "=== In-line variable defs ===";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeline">  for (const BasicBlock &BB : Fn) {</td>
    <td class="lineNumber">177</td>
    <td class="codeline">  for (const BasicBlock &BB : Fn) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeline">    OS << "\n" << BB.getName() << ":\n";</td>
    <td class="lineNumber">178</td>
    <td class="codeline">    OS << "\n" << BB.getName() << ":\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeline">    for (const Instruction &I : BB) {</td>
    <td class="lineNumber">179</td>
    <td class="codeline">    for (const Instruction &I : BB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeline">      for (auto It = locs_begin(&I), End = locs_end(&I); It != End; ++It) {</td>
    <td class="lineNumber">180</td>
    <td class="codeline">      for (auto It = locs_begin(&I), End = locs_end(&I); It != End; ++It) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeline">        PrintLoc(*It);</td>
    <td class="lineNumber">181</td>
    <td class="codeline">        PrintLoc(*It);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">182</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeline">      OS << I << "\n";</td>
    <td class="lineNumber">183</td>
    <td class="codeline">      OS << I << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">184</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">185</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeline">}</td>
    <td class="lineNumber">186</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeline"></td>
    <td class="lineNumber">187</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeline">void FunctionVarLocs::init(FunctionVarLocsBuilder &Builder) {</td>
    <td class="lineNumber">188</td>
    <td class="codeline">void FunctionVarLocs::init(FunctionVarLocsBuilder &Builder) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeline">  // Add the single-location variables first.</td>
    <td class="lineNumber">189</td>
    <td class="codeline">  // Add the single-location variables first.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeline">  for (const auto &VarLoc : Builder.SingleLocVars)</td>
    <td class="lineNumber">190</td>
    <td class="codeline">  for (const auto &VarLoc : Builder.SingleLocVars)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeline">    VarLocRecords.emplace_back(VarLoc);</td>
    <td class="lineNumber">191</td>
    <td class="codeline">    VarLocRecords.emplace_back(VarLoc);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeline">  // Mark the end of the section.</td>
    <td class="lineNumber">192</td>
    <td class="codeline">  // Mark the end of the section.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeline">  SingleVarLocEnd = VarLocRecords.size();</td>
    <td class="lineNumber">193</td>
    <td class="codeline">  SingleVarLocEnd = VarLocRecords.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeline"></td>
    <td class="lineNumber">194</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeline">  // Insert a contiguous block of VarLocInfos for each instruction, mapping it</td>
    <td class="lineNumber">195</td>
    <td class="codeline">  // Insert a contiguous block of VarLocInfos for each instruction, mapping it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeline">  // to the start and end position in the vector with VarLocsBeforeInst.</td>
    <td class="lineNumber">196</td>
    <td class="codeline">  // to the start and end position in the vector with VarLocsBeforeInst.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeline">  for (auto &P : Builder.VarLocsBeforeInst) {</td>
    <td class="lineNumber">197</td>
    <td class="codeline">  for (auto &P : Builder.VarLocsBeforeInst) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeline">    unsigned BlockStart = VarLocRecords.size();</td>
    <td class="lineNumber">198</td>
    <td class="codeline">    unsigned BlockStart = VarLocRecords.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeline">    for (const VarLocInfo &VarLoc : P.second)</td>
    <td class="lineNumber">199</td>
    <td class="codeline">    for (const VarLocInfo &VarLoc : P.second)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeline">      VarLocRecords.emplace_back(VarLoc);</td>
    <td class="lineNumber">200</td>
    <td class="codeline">      VarLocRecords.emplace_back(VarLoc);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeline">    unsigned BlockEnd = VarLocRecords.size();</td>
    <td class="lineNumber">201</td>
    <td class="codeline">    unsigned BlockEnd = VarLocRecords.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeline">    // Record the start and end indices.</td>
    <td class="lineNumber">202</td>
    <td class="codeline">    // Record the start and end indices.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeline">    if (BlockEnd != BlockStart)</td>
    <td class="lineNumber">203</td>
    <td class="codeline">    if (BlockEnd != BlockStart)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeline">      VarLocsBeforeInst[P.first] = {BlockStart, BlockEnd};</td>
    <td class="lineNumber">204</td>
    <td class="codeline">      VarLocsBeforeInst[P.first] = {BlockStart, BlockEnd};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">205</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeline"></td>
    <td class="lineNumber">206</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeline">  // Copy the Variables vector from the builder's UniqueVector.</td>
    <td class="lineNumber">207</td>
    <td class="codeline">  // Copy the Variables vector from the builder's UniqueVector.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeline">  assert(Variables.empty() && "Expect clear before init");</td>
    <td class="lineNumber">208</td>
    <td class="codeline">  assert(Variables.empty() && "Expect clear before init");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeline">  // UniqueVectors IDs are one-based (which means the VarLocInfo VarID values</td>
    <td class="lineNumber">209</td>
    <td class="codeline">  // UniqueVectors IDs are one-based (which means the VarLocInfo VarID values</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeline">  // are one-based) so reserve an extra and insert a dummy.</td>
    <td class="lineNumber">210</td>
    <td class="codeline">  // are one-based) so reserve an extra and insert a dummy.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeline">  Variables.reserve(Builder.Variables.size() + 1);</td>
    <td class="lineNumber">211</td>
    <td class="codeline">  Variables.reserve(Builder.Variables.size() + 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeline">  Variables.push_back(DebugVariable(nullptr, std::nullopt, nullptr));</td>
    <td class="lineNumber">212</td>
    <td class="codeline">  Variables.push_back(DebugVariable(nullptr, std::nullopt, nullptr));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeline">  Variables.append(Builder.Variables.begin(), Builder.Variables.end());</td>
    <td class="lineNumber">213</td>
    <td class="codeline">  Variables.append(Builder.Variables.begin(), Builder.Variables.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeline">}</td>
    <td class="lineNumber">214</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeline"></td>
    <td class="lineNumber">215</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeline">void FunctionVarLocs::clear() {</td>
    <td class="lineNumber">216</td>
    <td class="codeline">void FunctionVarLocs::clear() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeline">  Variables.clear();</td>
    <td class="lineNumber">217</td>
    <td class="codeline">  Variables.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeline">  VarLocRecords.clear();</td>
    <td class="lineNumber">218</td>
    <td class="codeline">  VarLocRecords.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeline">  VarLocsBeforeInst.clear();</td>
    <td class="lineNumber">219</td>
    <td class="codeline">  VarLocsBeforeInst.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeline">  SingleVarLocEnd = 0;</td>
    <td class="lineNumber">220</td>
    <td class="codeline">  SingleVarLocEnd = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeline">}</td>
    <td class="lineNumber">221</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeline"></td>
    <td class="lineNumber">222</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeline">/// Walk backwards along constant GEPs and bitcasts to the base storage from \p</td>
    <td class="lineNumber">223</td>
    <td class="codeline">/// Walk backwards along constant GEPs and bitcasts to the base storage from \p</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeline">/// Start as far as possible. Prepend \Expression with the offset and append it</td>
    <td class="lineNumber">224</td>
    <td class="codeline">/// Start as far as possible. Prepend \Expression with the offset and append it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeline">/// with a DW_OP_deref that haes been implicit until now. Returns the walked-to</td>
    <td class="lineNumber">225</td>
    <td class="codeline">/// with a DW_OP_deref that haes been implicit until now. Returns the walked-to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeline">/// value and modified expression.</td>
    <td class="lineNumber">226</td>
    <td class="codeline">/// value and modified expression.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeline">static std::pair<Value *, DIExpression *></td>
    <td class="lineNumber">227</td>
    <td class="codeline">static std::pair<Value *, DIExpression *></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeline">walkToAllocaAndPrependOffsetDeref(const DataLayout &DL, Value *Start,</td>
    <td class="lineNumber">228</td>
    <td class="codeline">walkToAllocaAndPrependOffsetDeref(const DataLayout &DL, Value *Start,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeline">                                  DIExpression *Expression) {</td>
    <td class="lineNumber">229</td>
    <td class="codeline">                                  DIExpression *Expression) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeline">  APInt OffsetInBytes(DL.getTypeSizeInBits(Start->getType()), false);</td>
    <td class="lineNumber">230</td>
    <td class="codeline">  APInt OffsetInBytes(DL.getTypeSizeInBits(Start->getType()), false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeline">  Value *End =</td>
    <td class="lineNumber">231</td>
    <td class="codeline">  Value *End =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeline">      Start->stripAndAccumulateInBoundsConstantOffsets(DL, OffsetInBytes);</td>
    <td class="lineNumber">232</td>
    <td class="codeline">      Start->stripAndAccumulateInBoundsConstantOffsets(DL, OffsetInBytes);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeline">  SmallVector<uint64_t, 3> Ops;</td>
    <td class="lineNumber">233</td>
    <td class="codeline">  SmallVector<uint64_t, 3> Ops;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeline">  if (OffsetInBytes.getBoolValue()) {</td>
    <td class="lineNumber">234</td>
    <td class="codeline">  if (OffsetInBytes.getBoolValue()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeline">    Ops = {dwarf::DW_OP_plus_uconst, OffsetInBytes.getZExtValue()};</td>
    <td class="lineNumber">235</td>
    <td class="codeline">    Ops = {dwarf::DW_OP_plus_uconst, OffsetInBytes.getZExtValue()};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeline">    Expression = DIExpression::prependOpcodes(</td>
    <td class="lineNumber">236</td>
    <td class="codeline">    Expression = DIExpression::prependOpcodes(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeline">        Expression, Ops, /*StackValue=*/false, /*EntryValue=*/false);</td>
    <td class="lineNumber">237</td>
    <td class="codeline">        Expression, Ops, /*StackValue=*/false, /*EntryValue=*/false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">238</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeline">  Expression = DIExpression::append(Expression, {dwarf::DW_OP_deref});</td>
    <td class="lineNumber">239</td>
    <td class="codeline">  Expression = DIExpression::append(Expression, {dwarf::DW_OP_deref});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeline">  return {End, Expression};</td>
    <td class="lineNumber">240</td>
    <td class="codeline">  return {End, Expression};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeline">}</td>
    <td class="lineNumber">241</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeline"></td>
    <td class="lineNumber">242</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeline">/// Extract the offset used in \p DIExpr. Returns std::nullopt if the expression</td>
    <td class="lineNumber">243</td>
    <td class="codeline">/// Extract the offset used in \p DIExpr. Returns std::nullopt if the expression</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeline">/// doesn't explicitly describe a memory location with DW_OP_deref or if the</td>
    <td class="lineNumber">244</td>
    <td class="codeline">/// doesn't explicitly describe a memory location with DW_OP_deref or if the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeline">/// expression is too complex to interpret.</td>
    <td class="lineNumber">245</td>
    <td class="codeline">/// expression is too complex to interpret.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeline">static std::optional<int64_t></td>
    <td class="lineNumber">246</td>
    <td class="codeline">static std::optional<int64_t></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeline">getDerefOffsetInBytes(const DIExpression *DIExpr) {</td>
    <td class="lineNumber">247</td>
    <td class="codeline">getDerefOffsetInBytes(const DIExpression *DIExpr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeline">  int64_t Offset = 0;</td>
    <td class="lineNumber">248</td>
    <td class="codeline">  int64_t Offset = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeline">  const unsigned NumElements = DIExpr->getNumElements();</td>
    <td class="lineNumber">249</td>
    <td class="codeline">  const unsigned NumElements = DIExpr->getNumElements();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeline">  const auto Elements = DIExpr->getElements();</td>
    <td class="lineNumber">250</td>
    <td class="codeline">  const auto Elements = DIExpr->getElements();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeline">  unsigned ExpectedDerefIdx = 0;</td>
    <td class="lineNumber">251</td>
    <td class="codeline">  unsigned ExpectedDerefIdx = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeline">  // Extract the offset.</td>
    <td class="lineNumber">252</td>
    <td class="codeline">  // Extract the offset.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeline">  if (NumElements > 2 && Elements[0] == dwarf::DW_OP_plus_uconst) {</td>
    <td class="lineNumber">253</td>
    <td class="codeline">  if (NumElements > 2 && Elements[0] == dwarf::DW_OP_plus_uconst) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeline">    Offset = Elements[1];</td>
    <td class="lineNumber">254</td>
    <td class="codeline">    Offset = Elements[1];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeline">    ExpectedDerefIdx = 2;</td>
    <td class="lineNumber">255</td>
    <td class="codeline">    ExpectedDerefIdx = 2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeline">  } else if (NumElements > 3 && Elements[0] == dwarf::DW_OP_constu) {</td>
    <td class="lineNumber">256</td>
    <td class="codeline">  } else if (NumElements > 3 && Elements[0] == dwarf::DW_OP_constu) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeline">    ExpectedDerefIdx = 3;</td>
    <td class="lineNumber">257</td>
    <td class="codeline">    ExpectedDerefIdx = 3;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeline">    if (Elements[2] == dwarf::DW_OP_plus)</td>
    <td class="lineNumber">258</td>
    <td class="codeline">    if (Elements[2] == dwarf::DW_OP_plus)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeline">      Offset = Elements[1];</td>
    <td class="lineNumber">259</td>
    <td class="codeline">      Offset = Elements[1];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeline">    else if (Elements[2] == dwarf::DW_OP_minus)</td>
    <td class="lineNumber">260</td>
    <td class="codeline">    else if (Elements[2] == dwarf::DW_OP_minus)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeline">      Offset = -Elements[1];</td>
    <td class="lineNumber">261</td>
    <td class="codeline">      Offset = -Elements[1];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">262</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeline">      return std::nullopt;</td>
    <td class="lineNumber">263</td>
    <td class="codeline">      return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">264</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeline"></td>
    <td class="lineNumber">265</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeline">  // If that's all there is it means there's no deref.</td>
    <td class="lineNumber">266</td>
    <td class="codeline">  // If that's all there is it means there's no deref.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeline">  if (ExpectedDerefIdx >= NumElements)</td>
    <td class="lineNumber">267</td>
    <td class="codeline">  if (ExpectedDerefIdx >= NumElements)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeline">    return std::nullopt;</td>
    <td class="lineNumber">268</td>
    <td class="codeline">    return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeline"></td>
    <td class="lineNumber">269</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeline">  // Check the next element is DW_OP_deref - otherwise this is too complex or</td>
    <td class="lineNumber">270</td>
    <td class="codeline">  // Check the next element is DW_OP_deref - otherwise this is too complex or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeline">  // isn't a deref expression.</td>
    <td class="lineNumber">271</td>
    <td class="codeline">  // isn't a deref expression.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeline">  if (Elements[ExpectedDerefIdx] != dwarf::DW_OP_deref)</td>
    <td class="lineNumber">272</td>
    <td class="codeline">  if (Elements[ExpectedDerefIdx] != dwarf::DW_OP_deref)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeline">    return std::nullopt;</td>
    <td class="lineNumber">273</td>
    <td class="codeline">    return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeline"></td>
    <td class="lineNumber">274</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeline">  // Check the final operation is either the DW_OP_deref or is a fragment.</td>
    <td class="lineNumber">275</td>
    <td class="codeline">  // Check the final operation is either the DW_OP_deref or is a fragment.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeline">  if (NumElements == ExpectedDerefIdx + 1)</td>
    <td class="lineNumber">276</td>
    <td class="codeline">  if (NumElements == ExpectedDerefIdx + 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeline">    return Offset; // Ends with deref.</td>
    <td class="lineNumber">277</td>
    <td class="codeline">    return Offset; // Ends with deref.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeline">  unsigned ExpectedFragFirstIdx = ExpectedDerefIdx + 1;</td>
    <td class="lineNumber">278</td>
    <td class="codeline">  unsigned ExpectedFragFirstIdx = ExpectedDerefIdx + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeline">  unsigned ExpectedFragFinalIdx = ExpectedFragFirstIdx + 2;</td>
    <td class="lineNumber">279</td>
    <td class="codeline">  unsigned ExpectedFragFinalIdx = ExpectedFragFirstIdx + 2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeline">  if (NumElements == ExpectedFragFinalIdx + 1 &&</td>
    <td class="lineNumber">280</td>
    <td class="codeline">  if (NumElements == ExpectedFragFinalIdx + 1 &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeline">      Elements[ExpectedFragFirstIdx] == dwarf::DW_OP_LLVM_fragment)</td>
    <td class="lineNumber">281</td>
    <td class="codeline">      Elements[ExpectedFragFirstIdx] == dwarf::DW_OP_LLVM_fragment)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeline">    return Offset; // Ends with deref + fragment.</td>
    <td class="lineNumber">282</td>
    <td class="codeline">    return Offset; // Ends with deref + fragment.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeline"></td>
    <td class="lineNumber">283</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeline">  // Don't bother trying to interpret anything more complex.</td>
    <td class="lineNumber">284</td>
    <td class="codeline">  // Don't bother trying to interpret anything more complex.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeline">  return std::nullopt;</td>
    <td class="lineNumber">285</td>
    <td class="codeline">  return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeline">}</td>
    <td class="lineNumber">286</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeline"></td>
    <td class="lineNumber">287</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeline">/// A whole (unfragmented) source variable.</td>
    <td class="lineNumber">288</td>
    <td class="codeline">/// A whole (unfragmented) source variable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeline">using DebugAggregate = std::pair<const DILocalVariable *, const DILocation *>;</td>
    <td class="lineNumber">289</td>
    <td class="codeline">using DebugAggregate = std::pair<const DILocalVariable *, const DILocation *>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeline">static DebugAggregate getAggregate(const DbgVariableIntrinsic *DII) {</td>
    <td class="lineNumber">290</td>
    <td class="codeline">static DebugAggregate getAggregate(const DbgVariableIntrinsic *DII) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeline">  return DebugAggregate(DII->getVariable(), DII->getDebugLoc().getInlinedAt());</td>
    <td class="lineNumber">291</td>
    <td class="codeline">  return DebugAggregate(DII->getVariable(), DII->getDebugLoc().getInlinedAt());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeline">}</td>
    <td class="lineNumber">292</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeline">static DebugAggregate getAggregate(const DebugVariable &Var) {</td>
    <td class="lineNumber">293</td>
    <td class="codeline">static DebugAggregate getAggregate(const DebugVariable &Var) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeline">  return DebugAggregate(Var.getVariable(), Var.getInlinedAt());</td>
    <td class="lineNumber">294</td>
    <td class="codeline">  return DebugAggregate(Var.getVariable(), Var.getInlinedAt());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeline">}</td>
    <td class="lineNumber">295</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeline"></td>
    <td class="lineNumber">296</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeline">static bool shouldCoalesceFragments(Function &F) {</td>
    <td class="lineNumber">297</td>
    <td class="codeline">static bool shouldCoalesceFragments(Function &F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeline">  // Enabling fragment coalescing reduces compiler run time when instruction</td>
    <td class="lineNumber">298</td>
    <td class="codeline">  // Enabling fragment coalescing reduces compiler run time when instruction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeline">  // referencing is enabled. However, it may cause LiveDebugVariables to create</td>
    <td class="lineNumber">299</td>
    <td class="codeline">  // referencing is enabled. However, it may cause LiveDebugVariables to create</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeline">  // incorrect locations. Since instruction-referencing mode effectively</td>
    <td class="lineNumber">300</td>
    <td class="codeline">  // incorrect locations. Since instruction-referencing mode effectively</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeline">  // bypasses LiveDebugVariables we only enable coalescing if the cl::opt flag</td>
    <td class="lineNumber">301</td>
    <td class="codeline">  // bypasses LiveDebugVariables we only enable coalescing if the cl::opt flag</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeline">  // has not been explicitly set and instruction-referencing is turned on.</td>
    <td class="lineNumber">302</td>
    <td class="codeline">  // has not been explicitly set and instruction-referencing is turned on.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeline">  switch (CoalesceAdjacentFragmentsOpt) {</td>
    <td class="lineNumber">303</td>
    <td class="codeline">  switch (CoalesceAdjacentFragmentsOpt) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeline">  case cl::boolOrDefault::BOU_UNSET:</td>
    <td class="lineNumber">304</td>
    <td class="codeline">  case cl::boolOrDefault::BOU_UNSET:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeline">    return debuginfoShouldUseDebugInstrRef(</td>
    <td class="lineNumber">305</td>
    <td class="codeline">    return debuginfoShouldUseDebugInstrRef(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeline">        Triple(F.getParent()->getTargetTriple()));</td>
    <td class="lineNumber">306</td>
    <td class="codeline">        Triple(F.getParent()->getTargetTriple()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeline">  case cl::boolOrDefault::BOU_TRUE:</td>
    <td class="lineNumber">307</td>
    <td class="codeline">  case cl::boolOrDefault::BOU_TRUE:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">308</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeline">  case cl::boolOrDefault::BOU_FALSE:</td>
    <td class="lineNumber">309</td>
    <td class="codeline">  case cl::boolOrDefault::BOU_FALSE:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">310</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">311</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeline">  llvm_unreachable("Unknown boolOrDefault value");</td>
    <td class="lineNumber">312</td>
    <td class="codeline">  llvm_unreachable("Unknown boolOrDefault value");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeline">}</td>
    <td class="lineNumber">313</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeline"></td>
    <td class="lineNumber">314</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeline">namespace {</td>
    <td class="lineNumber">315</td>
    <td class="codeline">namespace {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeline">/// In dwarf emission, the following sequence</td>
    <td class="lineNumber">316</td>
    <td class="codeline">/// In dwarf emission, the following sequence</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeline">///    1. dbg.value ... Fragment(0, 64)</td>
    <td class="lineNumber">317</td>
    <td class="codeline">///    1. dbg.value ... Fragment(0, 64)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeline">///    2. dbg.value ... Fragment(0, 32)</td>
    <td class="lineNumber">318</td>
    <td class="codeline">///    2. dbg.value ... Fragment(0, 32)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeline">/// effectively sets Fragment(32, 32) to undef (each def sets all bits not in</td>
    <td class="lineNumber">319</td>
    <td class="codeline">/// effectively sets Fragment(32, 32) to undef (each def sets all bits not in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeline">/// the intersection of the fragments to having "no location"). This makes</td>
    <td class="lineNumber">320</td>
    <td class="codeline">/// the intersection of the fragments to having "no location"). This makes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeline">/// sense for implicit location values because splitting the computed values</td>
    <td class="lineNumber">321</td>
    <td class="codeline">/// sense for implicit location values because splitting the computed values</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeline">/// could be troublesome, and is probably quite uncommon.  When we convert</td>
    <td class="lineNumber">322</td>
    <td class="codeline">/// could be troublesome, and is probably quite uncommon.  When we convert</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeline">/// dbg.assigns to dbg.value+deref this kind of thing is common, and describing</td>
    <td class="lineNumber">323</td>
    <td class="codeline">/// dbg.assigns to dbg.value+deref this kind of thing is common, and describing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeline">/// a location (memory) rather than a value means we don't need to worry about</td>
    <td class="lineNumber">324</td>
    <td class="codeline">/// a location (memory) rather than a value means we don't need to worry about</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeline">/// splitting any values, so we try to recover the rest of the fragment</td>
    <td class="lineNumber">325</td>
    <td class="codeline">/// splitting any values, so we try to recover the rest of the fragment</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeline">/// location here.</td>
    <td class="lineNumber">326</td>
    <td class="codeline">/// location here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeline">/// This class performs a(nother) dataflow analysis over the function, adding</td>
    <td class="lineNumber">327</td>
    <td class="codeline">/// This class performs a(nother) dataflow analysis over the function, adding</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeline">/// variable locations so that any bits of a variable with a memory location</td>
    <td class="lineNumber">328</td>
    <td class="codeline">/// variable locations so that any bits of a variable with a memory location</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeline">/// have that location explicitly reinstated at each subsequent variable</td>
    <td class="lineNumber">329</td>
    <td class="codeline">/// have that location explicitly reinstated at each subsequent variable</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeline">/// location definition that that doesn't overwrite those bits. i.e. after a</td>
    <td class="lineNumber">330</td>
    <td class="codeline">/// location definition that that doesn't overwrite those bits. i.e. after a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeline">/// variable location def, insert new defs for the memory location with</td>
    <td class="lineNumber">331</td>
    <td class="codeline">/// variable location def, insert new defs for the memory location with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeline">/// fragments for the difference of "all bits currently in memory" and "the</td>
    <td class="lineNumber">332</td>
    <td class="codeline">/// fragments for the difference of "all bits currently in memory" and "the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeline">/// fragment of the second def".</td>
    <td class="lineNumber">333</td>
    <td class="codeline">/// fragment of the second def".</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeline">class MemLocFragmentFill {</td>
    <td class="lineNumber">334</td>
    <td class="codeline">class MemLocFragmentFill {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeline">  Function &Fn;</td>
    <td class="lineNumber">335</td>
    <td class="codeline">  Function &Fn;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeline">  FunctionVarLocsBuilder *FnVarLocs;</td>
    <td class="lineNumber">336</td>
    <td class="codeline">  FunctionVarLocsBuilder *FnVarLocs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeline">  const DenseSet<DebugAggregate> *VarsWithStackSlot;</td>
    <td class="lineNumber">337</td>
    <td class="codeline">  const DenseSet<DebugAggregate> *VarsWithStackSlot;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeline">  bool CoalesceAdjacentFragments;</td>
    <td class="lineNumber">338</td>
    <td class="codeline">  bool CoalesceAdjacentFragments;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeline"></td>
    <td class="lineNumber">339</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeline">  // 0 = no memory location.</td>
    <td class="lineNumber">340</td>
    <td class="codeline">  // 0 = no memory location.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeline">  using BaseAddress = unsigned;</td>
    <td class="lineNumber">341</td>
    <td class="codeline">  using BaseAddress = unsigned;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeline">  using OffsetInBitsTy = unsigned;</td>
    <td class="lineNumber">342</td>
    <td class="codeline">  using OffsetInBitsTy = unsigned;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeline">  using FragTraits = IntervalMapHalfOpenInfo<OffsetInBitsTy>;</td>
    <td class="lineNumber">343</td>
    <td class="codeline">  using FragTraits = IntervalMapHalfOpenInfo<OffsetInBitsTy>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeline">  using FragsInMemMap = IntervalMap<</td>
    <td class="lineNumber">344</td>
    <td class="codeline">  using FragsInMemMap = IntervalMap<</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeline">      OffsetInBitsTy, BaseAddress,</td>
    <td class="lineNumber">345</td>
    <td class="codeline">      OffsetInBitsTy, BaseAddress,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeline">      IntervalMapImpl::NodeSizer<OffsetInBitsTy, BaseAddress>::LeafSize,</td>
    <td class="lineNumber">346</td>
    <td class="codeline">      IntervalMapImpl::NodeSizer<OffsetInBitsTy, BaseAddress>::LeafSize,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeline">      FragTraits>;</td>
    <td class="lineNumber">347</td>
    <td class="codeline">      FragTraits>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeline">  FragsInMemMap::Allocator IntervalMapAlloc;</td>
    <td class="lineNumber">348</td>
    <td class="codeline">  FragsInMemMap::Allocator IntervalMapAlloc;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeline">  using VarFragMap = DenseMap<unsigned, FragsInMemMap>;</td>
    <td class="lineNumber">349</td>
    <td class="codeline">  using VarFragMap = DenseMap<unsigned, FragsInMemMap>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeline"></td>
    <td class="lineNumber">350</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeline">  /// IDs for memory location base addresses in maps. Use 0 to indicate that</td>
    <td class="lineNumber">351</td>
    <td class="codeline">  /// IDs for memory location base addresses in maps. Use 0 to indicate that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeline">  /// there's no memory location.</td>
    <td class="lineNumber">352</td>
    <td class="codeline">  /// there's no memory location.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeline">  UniqueVector<RawLocationWrapper> Bases;</td>
    <td class="lineNumber">353</td>
    <td class="codeline">  UniqueVector<RawLocationWrapper> Bases;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeline">  UniqueVector<DebugAggregate> Aggregates;</td>
    <td class="lineNumber">354</td>
    <td class="codeline">  UniqueVector<DebugAggregate> Aggregates;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeline">  DenseMap<const BasicBlock *, VarFragMap> LiveIn;</td>
    <td class="lineNumber">355</td>
    <td class="codeline">  DenseMap<const BasicBlock *, VarFragMap> LiveIn;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeline">  DenseMap<const BasicBlock *, VarFragMap> LiveOut;</td>
    <td class="lineNumber">356</td>
    <td class="codeline">  DenseMap<const BasicBlock *, VarFragMap> LiveOut;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeline"></td>
    <td class="lineNumber">357</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeline">  struct FragMemLoc {</td>
    <td class="lineNumber">358</td>
    <td class="codeline">  struct FragMemLoc {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeline">    unsigned Var;</td>
    <td class="lineNumber">359</td>
    <td class="codeline">    unsigned Var;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeline">    unsigned Base;</td>
    <td class="lineNumber">360</td>
    <td class="codeline">    unsigned Base;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeline">    unsigned OffsetInBits;</td>
    <td class="lineNumber">361</td>
    <td class="codeline">    unsigned OffsetInBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeline">    unsigned SizeInBits;</td>
    <td class="lineNumber">362</td>
    <td class="codeline">    unsigned SizeInBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeline">    DebugLoc DL;</td>
    <td class="lineNumber">363</td>
    <td class="codeline">    DebugLoc DL;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">364</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeline">  using InsertMap = MapVector<Instruction *, SmallVector<FragMemLoc>>;</td>
    <td class="lineNumber">365</td>
    <td class="codeline">  using InsertMap = MapVector<Instruction *, SmallVector<FragMemLoc>>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeline"></td>
    <td class="lineNumber">366</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeline">  /// BBInsertBeforeMap holds a description for the set of location defs to be</td>
    <td class="lineNumber">367</td>
    <td class="codeline">  /// BBInsertBeforeMap holds a description for the set of location defs to be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeline">  /// inserted after the analysis is complete. It is updated during the dataflow</td>
    <td class="lineNumber">368</td>
    <td class="codeline">  /// inserted after the analysis is complete. It is updated during the dataflow</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeline">  /// and the entry for a block is CLEARED each time it is (re-)visited. After</td>
    <td class="lineNumber">369</td>
    <td class="codeline">  /// and the entry for a block is CLEARED each time it is (re-)visited. After</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeline">  /// the dataflow is complete, each block entry will contain the set of defs</td>
    <td class="lineNumber">370</td>
    <td class="codeline">  /// the dataflow is complete, each block entry will contain the set of defs</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeline">  /// calculated during the final (fixed-point) iteration.</td>
    <td class="lineNumber">371</td>
    <td class="codeline">  /// calculated during the final (fixed-point) iteration.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeline">  DenseMap<const BasicBlock *, InsertMap> BBInsertBeforeMap;</td>
    <td class="lineNumber">372</td>
    <td class="codeline">  DenseMap<const BasicBlock *, InsertMap> BBInsertBeforeMap;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeline"></td>
    <td class="lineNumber">373</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeline">  static bool intervalMapsAreEqual(const FragsInMemMap &A,</td>
    <td class="lineNumber">374</td>
    <td class="codeline">  static bool intervalMapsAreEqual(const FragsInMemMap &A,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeline">                                   const FragsInMemMap &B) {</td>
    <td class="lineNumber">375</td>
    <td class="codeline">                                   const FragsInMemMap &B) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeline">    auto AIt = A.begin(), AEnd = A.end();</td>
    <td class="lineNumber">376</td>
    <td class="codeline">    auto AIt = A.begin(), AEnd = A.end();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeline">    auto BIt = B.begin(), BEnd = B.end();</td>
    <td class="lineNumber">377</td>
    <td class="codeline">    auto BIt = B.begin(), BEnd = B.end();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeline">    for (; AIt != AEnd; ++AIt, ++BIt) {</td>
    <td class="lineNumber">378</td>
    <td class="codeline">    for (; AIt != AEnd; ++AIt, ++BIt) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeline">      if (BIt == BEnd)</td>
    <td class="lineNumber">379</td>
    <td class="codeline">      if (BIt == BEnd)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeline">        return false; // B has fewer elements than A.</td>
    <td class="lineNumber">380</td>
    <td class="codeline">        return false; // B has fewer elements than A.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeline">      if (AIt.start() != BIt.start() || AIt.stop() != BIt.stop())</td>
    <td class="lineNumber">381</td>
    <td class="codeline">      if (AIt.start() != BIt.start() || AIt.stop() != BIt.stop())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeline">        return false; // Interval is different.</td>
    <td class="lineNumber">382</td>
    <td class="codeline">        return false; // Interval is different.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeline">      if (*AIt != *BIt)</td>
    <td class="lineNumber">383</td>
    <td class="codeline">      if (*AIt != *BIt)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeline">        return false; // Value at interval is different.</td>
    <td class="lineNumber">384</td>
    <td class="codeline">        return false; // Value at interval is different.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">385</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeline">    // AIt == AEnd. Check BIt is also now at end.</td>
    <td class="lineNumber">386</td>
    <td class="codeline">    // AIt == AEnd. Check BIt is also now at end.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeline">    return BIt == BEnd;</td>
    <td class="lineNumber">387</td>
    <td class="codeline">    return BIt == BEnd;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">388</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeline"></td>
    <td class="lineNumber">389</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeline">  static bool varFragMapsAreEqual(const VarFragMap &A, const VarFragMap &B) {</td>
    <td class="lineNumber">390</td>
    <td class="codeline">  static bool varFragMapsAreEqual(const VarFragMap &A, const VarFragMap &B) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeline">    if (A.size() != B.size())</td>
    <td class="lineNumber">391</td>
    <td class="codeline">    if (A.size() != B.size())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">392</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeline">    for (const auto &APair : A) {</td>
    <td class="lineNumber">393</td>
    <td class="codeline">    for (const auto &APair : A) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeline">      auto BIt = B.find(APair.first);</td>
    <td class="lineNumber">394</td>
    <td class="codeline">      auto BIt = B.find(APair.first);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeline">      if (BIt == B.end())</td>
    <td class="lineNumber">395</td>
    <td class="codeline">      if (BIt == B.end())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeline">        return false;</td>
    <td class="lineNumber">396</td>
    <td class="codeline">        return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeline">      if (!intervalMapsAreEqual(APair.second, BIt->second))</td>
    <td class="lineNumber">397</td>
    <td class="codeline">      if (!intervalMapsAreEqual(APair.second, BIt->second))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeline">        return false;</td>
    <td class="lineNumber">398</td>
    <td class="codeline">        return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">399</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">400</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">401</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeline"></td>
    <td class="lineNumber">402</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeline">  /// Return a string for the value that \p BaseID represents.</td>
    <td class="lineNumber">403</td>
    <td class="codeline">  /// Return a string for the value that \p BaseID represents.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeline">  std::string toString(unsigned BaseID) {</td>
    <td class="lineNumber">404</td>
    <td class="codeline">  std::string toString(unsigned BaseID) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeline">    if (BaseID)</td>
    <td class="lineNumber">405</td>
    <td class="codeline">    if (BaseID)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeline">      return Bases[BaseID].getVariableLocationOp(0)->getName().str();</td>
    <td class="lineNumber">406</td>
    <td class="codeline">      return Bases[BaseID].getVariableLocationOp(0)->getName().str();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">407</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeline">      return "None";</td>
    <td class="lineNumber">408</td>
    <td class="codeline">      return "None";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">409</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeline"></td>
    <td class="lineNumber">410</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeline">  /// Format string describing an FragsInMemMap (IntervalMap) interval.</td>
    <td class="lineNumber">411</td>
    <td class="codeline">  /// Format string describing an FragsInMemMap (IntervalMap) interval.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeline">  std::string toString(FragsInMemMap::const_iterator It, bool Newline = true) {</td>
    <td class="lineNumber">412</td>
    <td class="codeline">  std::string toString(FragsInMemMap::const_iterator It, bool Newline = true) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeline">    std::string String;</td>
    <td class="lineNumber">413</td>
    <td class="codeline">    std::string String;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeline">    std::stringstream S(String);</td>
    <td class="lineNumber">414</td>
    <td class="codeline">    std::stringstream S(String);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeline">    if (It.valid()) {</td>
    <td class="lineNumber">415</td>
    <td class="codeline">    if (It.valid()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeline">      S << "[" << It.start() << ", " << It.stop()</td>
    <td class="lineNumber">416</td>
    <td class="codeline">      S << "[" << It.start() << ", " << It.stop()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeline">        << "): " << toString(It.value());</td>
    <td class="lineNumber">417</td>
    <td class="codeline">        << "): " << toString(It.value());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">418</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeline">      S << "invalid iterator (end)";</td>
    <td class="lineNumber">419</td>
    <td class="codeline">      S << "invalid iterator (end)";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">420</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeline">    if (Newline)</td>
    <td class="lineNumber">421</td>
    <td class="codeline">    if (Newline)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeline">      S << "\n";</td>
    <td class="lineNumber">422</td>
    <td class="codeline">      S << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeline">    return S.str();</td>
    <td class="lineNumber">423</td>
    <td class="codeline">    return S.str();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">424</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeline"></td>
    <td class="lineNumber">425</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeline">  FragsInMemMap meetFragments(const FragsInMemMap &A, const FragsInMemMap &B) {</td>
    <td class="lineNumber">426</td>
    <td class="codeline">  FragsInMemMap meetFragments(const FragsInMemMap &A, const FragsInMemMap &B) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeline">    FragsInMemMap Result(IntervalMapAlloc);</td>
    <td class="lineNumber">427</td>
    <td class="codeline">    FragsInMemMap Result(IntervalMapAlloc);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeline">    for (auto AIt = A.begin(), AEnd = A.end(); AIt != AEnd; ++AIt) {</td>
    <td class="lineNumber">428</td>
    <td class="codeline">    for (auto AIt = A.begin(), AEnd = A.end(); AIt != AEnd; ++AIt) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "a " << toString(AIt));</td>
    <td class="lineNumber">429</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "a " << toString(AIt));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeline">      // This is basically copied from process() and inverted (process is</td>
    <td class="lineNumber">430</td>
    <td class="codeline">      // This is basically copied from process() and inverted (process is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeline">      // performing something like a union whereas this is more of an</td>
    <td class="lineNumber">431</td>
    <td class="codeline">      // performing something like a union whereas this is more of an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeline">      // intersect).</td>
    <td class="lineNumber">432</td>
    <td class="codeline">      // intersect).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeline"></td>
    <td class="lineNumber">433</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeline">      // There's no work to do if interval `a` overlaps no fragments in map `B`.</td>
    <td class="lineNumber">434</td>
    <td class="codeline">      // There's no work to do if interval `a` overlaps no fragments in map `B`.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeline">      if (!B.overlaps(AIt.start(), AIt.stop()))</td>
    <td class="lineNumber">435</td>
    <td class="codeline">      if (!B.overlaps(AIt.start(), AIt.stop()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">436</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeline"></td>
    <td class="lineNumber">437</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeline">      // Does StartBit intersect an existing fragment?</td>
    <td class="lineNumber">438</td>
    <td class="codeline">      // Does StartBit intersect an existing fragment?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeline">      auto FirstOverlap = B.find(AIt.start());</td>
    <td class="lineNumber">439</td>
    <td class="codeline">      auto FirstOverlap = B.find(AIt.start());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeline">      assert(FirstOverlap != B.end());</td>
    <td class="lineNumber">440</td>
    <td class="codeline">      assert(FirstOverlap != B.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeline">      bool IntersectStart = FirstOverlap.start() < AIt.start();</td>
    <td class="lineNumber">441</td>
    <td class="codeline">      bool IntersectStart = FirstOverlap.start() < AIt.start();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "- FirstOverlap " << toString(FirstOverlap, false)</td>
    <td class="lineNumber">442</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "- FirstOverlap " << toString(FirstOverlap, false)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeline">                        << ", IntersectStart: " << IntersectStart << "\n");</td>
    <td class="lineNumber">443</td>
    <td class="codeline">                        << ", IntersectStart: " << IntersectStart << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeline"></td>
    <td class="lineNumber">444</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeline">      // Does EndBit intersect an existing fragment?</td>
    <td class="lineNumber">445</td>
    <td class="codeline">      // Does EndBit intersect an existing fragment?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeline">      auto LastOverlap = B.find(AIt.stop());</td>
    <td class="lineNumber">446</td>
    <td class="codeline">      auto LastOverlap = B.find(AIt.stop());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeline">      bool IntersectEnd =</td>
    <td class="lineNumber">447</td>
    <td class="codeline">      bool IntersectEnd =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeline">          LastOverlap != B.end() && LastOverlap.start() < AIt.stop();</td>
    <td class="lineNumber">448</td>
    <td class="codeline">          LastOverlap != B.end() && LastOverlap.start() < AIt.stop();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "- LastOverlap " << toString(LastOverlap, false)</td>
    <td class="lineNumber">449</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "- LastOverlap " << toString(LastOverlap, false)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeline">                        << ", IntersectEnd: " << IntersectEnd << "\n");</td>
    <td class="lineNumber">450</td>
    <td class="codeline">                        << ", IntersectEnd: " << IntersectEnd << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeline"></td>
    <td class="lineNumber">451</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeline">      // Check if both ends of `a` intersect the same interval `b`.</td>
    <td class="lineNumber">452</td>
    <td class="codeline">      // Check if both ends of `a` intersect the same interval `b`.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeline">      if (IntersectStart && IntersectEnd && FirstOverlap == LastOverlap) {</td>
    <td class="lineNumber">453</td>
    <td class="codeline">      if (IntersectStart && IntersectEnd && FirstOverlap == LastOverlap) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeline">        // Insert `a` (`a` is contained in `b`) if the values match.</td>
    <td class="lineNumber">454</td>
    <td class="codeline">        // Insert `a` (`a` is contained in `b`) if the values match.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeline">        // [ a ]</td>
    <td class="lineNumber">455</td>
    <td class="codeline">        // [ a ]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeline">        // [ - b - ]</td>
    <td class="lineNumber">456</td>
    <td class="codeline">        // [ - b - ]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeline">        // -</td>
    <td class="lineNumber">457</td>
    <td class="codeline">        // -</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeline">        // [ r ]</td>
    <td class="lineNumber">458</td>
    <td class="codeline">        // [ r ]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "- a is contained within "</td>
    <td class="lineNumber">459</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "- a is contained within "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeline">                          << toString(FirstOverlap));</td>
    <td class="lineNumber">460</td>
    <td class="codeline">                          << toString(FirstOverlap));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeline">        if (*AIt && *AIt == *FirstOverlap)</td>
    <td class="lineNumber">461</td>
    <td class="codeline">        if (*AIt && *AIt == *FirstOverlap)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeline">          Result.insert(AIt.start(), AIt.stop(), *AIt);</td>
    <td class="lineNumber">462</td>
    <td class="codeline">          Result.insert(AIt.start(), AIt.stop(), *AIt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">463</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeline">        // There's an overlap but `a` is not fully contained within</td>
    <td class="lineNumber">464</td>
    <td class="codeline">        // There's an overlap but `a` is not fully contained within</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeline">        // `b`. Shorten any end-point intersections.</td>
    <td class="lineNumber">465</td>
    <td class="codeline">        // `b`. Shorten any end-point intersections.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeline">        //     [ - a - ]</td>
    <td class="lineNumber">466</td>
    <td class="codeline">        //     [ - a - ]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeline">        // [ - b - ]</td>
    <td class="lineNumber">467</td>
    <td class="codeline">        // [ - b - ]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeline">        // -</td>
    <td class="lineNumber">468</td>
    <td class="codeline">        // -</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeline">        //     [ r ]</td>
    <td class="lineNumber">469</td>
    <td class="codeline">        //     [ r ]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeline">        auto Next = FirstOverlap;</td>
    <td class="lineNumber">470</td>
    <td class="codeline">        auto Next = FirstOverlap;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeline">        if (IntersectStart) {</td>
    <td class="lineNumber">471</td>
    <td class="codeline">        if (IntersectStart) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeline">          LLVM_DEBUG(dbgs() << "- insert intersection of a and "</td>
    <td class="lineNumber">472</td>
    <td class="codeline">          LLVM_DEBUG(dbgs() << "- insert intersection of a and "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeline">                            << toString(FirstOverlap));</td>
    <td class="lineNumber">473</td>
    <td class="codeline">                            << toString(FirstOverlap));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeline">          if (*AIt && *AIt == *FirstOverlap)</td>
    <td class="lineNumber">474</td>
    <td class="codeline">          if (*AIt && *AIt == *FirstOverlap)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeline">            Result.insert(AIt.start(), FirstOverlap.stop(), *AIt);</td>
    <td class="lineNumber">475</td>
    <td class="codeline">            Result.insert(AIt.start(), FirstOverlap.stop(), *AIt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeline">          ++Next;</td>
    <td class="lineNumber">476</td>
    <td class="codeline">          ++Next;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">477</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeline">        // [ - a - ]</td>
    <td class="lineNumber">478</td>
    <td class="codeline">        // [ - a - ]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeline">        //     [ - b - ]</td>
    <td class="lineNumber">479</td>
    <td class="codeline">        //     [ - b - ]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeline">        // -</td>
    <td class="lineNumber">480</td>
    <td class="codeline">        // -</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeline">        //     [ r ]</td>
    <td class="lineNumber">481</td>
    <td class="codeline">        //     [ r ]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeline">        if (IntersectEnd) {</td>
    <td class="lineNumber">482</td>
    <td class="codeline">        if (IntersectEnd) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeline">          LLVM_DEBUG(dbgs() << "- insert intersection of a and "</td>
    <td class="lineNumber">483</td>
    <td class="codeline">          LLVM_DEBUG(dbgs() << "- insert intersection of a and "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeline">                            << toString(LastOverlap));</td>
    <td class="lineNumber">484</td>
    <td class="codeline">                            << toString(LastOverlap));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeline">          if (*AIt && *AIt == *LastOverlap)</td>
    <td class="lineNumber">485</td>
    <td class="codeline">          if (*AIt && *AIt == *LastOverlap)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeline">            Result.insert(LastOverlap.start(), AIt.stop(), *AIt);</td>
    <td class="lineNumber">486</td>
    <td class="codeline">            Result.insert(LastOverlap.start(), AIt.stop(), *AIt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">487</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeline"></td>
    <td class="lineNumber">488</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeline">        // Insert all intervals in map `B` that are contained within interval</td>
    <td class="lineNumber">489</td>
    <td class="codeline">        // Insert all intervals in map `B` that are contained within interval</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeline">        // `a` where the values match.</td>
    <td class="lineNumber">490</td>
    <td class="codeline">        // `a` where the values match.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeline">        // [ -  - a -  - ]</td>
    <td class="lineNumber">491</td>
    <td class="codeline">        // [ -  - a -  - ]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeline">        // [ b1 ]   [ b2 ]</td>
    <td class="lineNumber">492</td>
    <td class="codeline">        // [ b1 ]   [ b2 ]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeline">        // -</td>
    <td class="lineNumber">493</td>
    <td class="codeline">        // -</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeline">        // [ r1 ]   [ r2 ]</td>
    <td class="lineNumber">494</td>
    <td class="codeline">        // [ r1 ]   [ r2 ]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeline">        while (Next != B.end() && Next.start() < AIt.stop() &&</td>
    <td class="lineNumber">495</td>
    <td class="codeline">        while (Next != B.end() && Next.start() < AIt.stop() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeline">               Next.stop() <= AIt.stop()) {</td>
    <td class="lineNumber">496</td>
    <td class="codeline">               Next.stop() <= AIt.stop()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeline">          LLVM_DEBUG(dbgs()</td>
    <td class="lineNumber">497</td>
    <td class="codeline">          LLVM_DEBUG(dbgs()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeline">                     << "- insert intersection of a and " << toString(Next));</td>
    <td class="lineNumber">498</td>
    <td class="codeline">                     << "- insert intersection of a and " << toString(Next));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeline">          if (*AIt && *AIt == *Next)</td>
    <td class="lineNumber">499</td>
    <td class="codeline">          if (*AIt && *AIt == *Next)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeline">            Result.insert(Next.start(), Next.stop(), *Next);</td>
    <td class="lineNumber">500</td>
    <td class="codeline">            Result.insert(Next.start(), Next.stop(), *Next);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeline">          ++Next;</td>
    <td class="lineNumber">501</td>
    <td class="codeline">          ++Next;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">502</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">503</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">504</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeline">    return Result;</td>
    <td class="lineNumber">505</td>
    <td class="codeline">    return Result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">506</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeline"></td>
    <td class="lineNumber">507</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeline">  /// Meet \p A and \p B, storing the result in \p A.</td>
    <td class="lineNumber">508</td>
    <td class="codeline">  /// Meet \p A and \p B, storing the result in \p A.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeline">  void meetVars(VarFragMap &A, const VarFragMap &B) {</td>
    <td class="lineNumber">509</td>
    <td class="codeline">  void meetVars(VarFragMap &A, const VarFragMap &B) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeline">    // Meet A and B.</td>
    <td class="lineNumber">510</td>
    <td class="codeline">    // Meet A and B.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">511</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeline">    // Result = meet(a, b) for a in A, b in B where Var(a) == Var(b)</td>
    <td class="lineNumber">512</td>
    <td class="codeline">    // Result = meet(a, b) for a in A, b in B where Var(a) == Var(b)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeline">    for (auto It = A.begin(), End = A.end(); It != End; ++It) {</td>
    <td class="lineNumber">513</td>
    <td class="codeline">    for (auto It = A.begin(), End = A.end(); It != End; ++It) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeline">      unsigned AVar = It->first;</td>
    <td class="lineNumber">514</td>
    <td class="codeline">      unsigned AVar = It->first;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeline">      FragsInMemMap &AFrags = It->second;</td>
    <td class="lineNumber">515</td>
    <td class="codeline">      FragsInMemMap &AFrags = It->second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeline">      auto BIt = B.find(AVar);</td>
    <td class="lineNumber">516</td>
    <td class="codeline">      auto BIt = B.find(AVar);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeline">      if (BIt == B.end()) {</td>
    <td class="lineNumber">517</td>
    <td class="codeline">      if (BIt == B.end()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeline">        A.erase(It);</td>
    <td class="lineNumber">518</td>
    <td class="codeline">        A.erase(It);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeline">        continue; // Var has no bits defined in B.</td>
    <td class="lineNumber">519</td>
    <td class="codeline">        continue; // Var has no bits defined in B.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">520</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "meet fragment maps for "</td>
    <td class="lineNumber">521</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "meet fragment maps for "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeline">                        << Aggregates[AVar].first->getName() << "\n");</td>
    <td class="lineNumber">522</td>
    <td class="codeline">                        << Aggregates[AVar].first->getName() << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeline">      AFrags = meetFragments(AFrags, BIt->second);</td>
    <td class="lineNumber">523</td>
    <td class="codeline">      AFrags = meetFragments(AFrags, BIt->second);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">524</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">525</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeline"></td>
    <td class="lineNumber">526</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeline">  bool meet(const BasicBlock &BB,</td>
    <td class="lineNumber">527</td>
    <td class="codeline">  bool meet(const BasicBlock &BB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeline">            const SmallPtrSet<BasicBlock *, 16> &Visited) {</td>
    <td class="lineNumber">528</td>
    <td class="codeline">            const SmallPtrSet<BasicBlock *, 16> &Visited) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "meet block info from preds of " << BB.getName()</td>
    <td class="lineNumber">529</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "meet block info from preds of " << BB.getName()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeline">                      << "\n");</td>
    <td class="lineNumber">530</td>
    <td class="codeline">                      << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeline"></td>
    <td class="lineNumber">531</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeline">    VarFragMap BBLiveIn;</td>
    <td class="lineNumber">532</td>
    <td class="codeline">    VarFragMap BBLiveIn;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeline">    bool FirstMeet = true;</td>
    <td class="lineNumber">533</td>
    <td class="codeline">    bool FirstMeet = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeline">    // LiveIn locs for BB is the meet of the already-processed preds' LiveOut</td>
    <td class="lineNumber">534</td>
    <td class="codeline">    // LiveIn locs for BB is the meet of the already-processed preds' LiveOut</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeline">    // locs.</td>
    <td class="lineNumber">535</td>
    <td class="codeline">    // locs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeline">    for (auto I = pred_begin(&BB), E = pred_end(&BB); I != E; I++) {</td>
    <td class="lineNumber">536</td>
    <td class="codeline">    for (auto I = pred_begin(&BB), E = pred_end(&BB); I != E; I++) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeline">      // Ignore preds that haven't been processed yet. This is essentially the</td>
    <td class="lineNumber">537</td>
    <td class="codeline">      // Ignore preds that haven't been processed yet. This is essentially the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeline">      // same as initialising all variables to implicit top value (⊤) which is</td>
    <td class="lineNumber">538</td>
    <td class="codeline">      // same as initialising all variables to implicit top value (⊤) which is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeline">      // the identity value for the meet operation.</td>
    <td class="lineNumber">539</td>
    <td class="codeline">      // the identity value for the meet operation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeline">      const BasicBlock *Pred = *I;</td>
    <td class="lineNumber">540</td>
    <td class="codeline">      const BasicBlock *Pred = *I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeline">      if (!Visited.count(Pred))</td>
    <td class="lineNumber">541</td>
    <td class="codeline">      if (!Visited.count(Pred))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">542</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeline"></td>
    <td class="lineNumber">543</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeline">      auto PredLiveOut = LiveOut.find(Pred);</td>
    <td class="lineNumber">544</td>
    <td class="codeline">      auto PredLiveOut = LiveOut.find(Pred);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeline">      assert(PredLiveOut != LiveOut.end());</td>
    <td class="lineNumber">545</td>
    <td class="codeline">      assert(PredLiveOut != LiveOut.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeline"></td>
    <td class="lineNumber">546</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeline">      if (FirstMeet) {</td>
    <td class="lineNumber">547</td>
    <td class="codeline">      if (FirstMeet) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "BBLiveIn = " << Pred->getName() << "\n");</td>
    <td class="lineNumber">548</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "BBLiveIn = " << Pred->getName() << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeline">        BBLiveIn = PredLiveOut->second;</td>
    <td class="lineNumber">549</td>
    <td class="codeline">        BBLiveIn = PredLiveOut->second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeline">        FirstMeet = false;</td>
    <td class="lineNumber">550</td>
    <td class="codeline">        FirstMeet = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">551</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "BBLiveIn = meet BBLiveIn, " << Pred->getName()</td>
    <td class="lineNumber">552</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "BBLiveIn = meet BBLiveIn, " << Pred->getName()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeline">                          << "\n");</td>
    <td class="lineNumber">553</td>
    <td class="codeline">                          << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeline">        meetVars(BBLiveIn, PredLiveOut->second);</td>
    <td class="lineNumber">554</td>
    <td class="codeline">        meetVars(BBLiveIn, PredLiveOut->second);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">555</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeline"></td>
    <td class="lineNumber">556</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeline">      // An empty set is ⊥ for the intersect-like meet operation. If we've</td>
    <td class="lineNumber">557</td>
    <td class="codeline">      // An empty set is ⊥ for the intersect-like meet operation. If we've</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeline">      // already got ⊥ there's no need to run the code - we know the result is</td>
    <td class="lineNumber">558</td>
    <td class="codeline">      // already got ⊥ there's no need to run the code - we know the result is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeline">      // ⊥ since `meet(a, ⊥) = ⊥`.</td>
    <td class="lineNumber">559</td>
    <td class="codeline">      // ⊥ since `meet(a, ⊥) = ⊥`.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeline">      if (BBLiveIn.size() == 0)</td>
    <td class="lineNumber">560</td>
    <td class="codeline">      if (BBLiveIn.size() == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">561</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">562</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeline"></td>
    <td class="lineNumber">563</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeline">    auto CurrentLiveInEntry = LiveIn.find(&BB);</td>
    <td class="lineNumber">564</td>
    <td class="codeline">    auto CurrentLiveInEntry = LiveIn.find(&BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeline">    // If there's no LiveIn entry for the block yet, add it.</td>
    <td class="lineNumber">565</td>
    <td class="codeline">    // If there's no LiveIn entry for the block yet, add it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeline">    if (CurrentLiveInEntry == LiveIn.end()) {</td>
    <td class="lineNumber">566</td>
    <td class="codeline">    if (CurrentLiveInEntry == LiveIn.end()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "change=true (first) on meet on " << BB.getName()</td>
    <td class="lineNumber">567</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "change=true (first) on meet on " << BB.getName()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeline">                        << "\n");</td>
    <td class="lineNumber">568</td>
    <td class="codeline">                        << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeline">      LiveIn[&BB] = std::move(BBLiveIn);</td>
    <td class="lineNumber">569</td>
    <td class="codeline">      LiveIn[&BB] = std::move(BBLiveIn);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeline">      return /*Changed=*/true;</td>
    <td class="lineNumber">570</td>
    <td class="codeline">      return /*Changed=*/true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">571</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeline"></td>
    <td class="lineNumber">572</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeline">    // If the LiveIn set has changed (expensive check) update it and return</td>
    <td class="lineNumber">573</td>
    <td class="codeline">    // If the LiveIn set has changed (expensive check) update it and return</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeline">    // true.</td>
    <td class="lineNumber">574</td>
    <td class="codeline">    // true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeline">    if (!varFragMapsAreEqual(BBLiveIn, CurrentLiveInEntry->second)) {</td>
    <td class="lineNumber">575</td>
    <td class="codeline">    if (!varFragMapsAreEqual(BBLiveIn, CurrentLiveInEntry->second)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "change=true on meet on " << BB.getName() << "\n");</td>
    <td class="lineNumber">576</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "change=true on meet on " << BB.getName() << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeline">      CurrentLiveInEntry->second = std::move(BBLiveIn);</td>
    <td class="lineNumber">577</td>
    <td class="codeline">      CurrentLiveInEntry->second = std::move(BBLiveIn);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeline">      return /*Changed=*/true;</td>
    <td class="lineNumber">578</td>
    <td class="codeline">      return /*Changed=*/true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">579</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeline"></td>
    <td class="lineNumber">580</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "change=false on meet on " << BB.getName() << "\n");</td>
    <td class="lineNumber">581</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "change=false on meet on " << BB.getName() << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeline">    return /*Changed=*/false;</td>
    <td class="lineNumber">582</td>
    <td class="codeline">    return /*Changed=*/false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">583</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeline"></td>
    <td class="lineNumber">584</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeline">  void insertMemLoc(BasicBlock &BB, Instruction &Before, unsigned Var,</td>
    <td class="lineNumber">585</td>
    <td class="codeline">  void insertMemLoc(BasicBlock &BB, Instruction &Before, unsigned Var,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeline">                    unsigned StartBit, unsigned EndBit, unsigned Base,</td>
    <td class="lineNumber">586</td>
    <td class="codeline">                    unsigned StartBit, unsigned EndBit, unsigned Base,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeline">                    DebugLoc DL) {</td>
    <td class="lineNumber">587</td>
    <td class="codeline">                    DebugLoc DL) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeline">    assert(StartBit < EndBit && "Cannot create fragment of size <= 0");</td>
    <td class="lineNumber">588</td>
    <td class="codeline">    assert(StartBit < EndBit && "Cannot create fragment of size <= 0");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeline">    if (!Base)</td>
    <td class="lineNumber">589</td>
    <td class="codeline">    if (!Base)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">590</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeline">    FragMemLoc Loc;</td>
    <td class="lineNumber">591</td>
    <td class="codeline">    FragMemLoc Loc;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeline">    Loc.Var = Var;</td>
    <td class="lineNumber">592</td>
    <td class="codeline">    Loc.Var = Var;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeline">    Loc.OffsetInBits = StartBit;</td>
    <td class="lineNumber">593</td>
    <td class="codeline">    Loc.OffsetInBits = StartBit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeline">    Loc.SizeInBits = EndBit - StartBit;</td>
    <td class="lineNumber">594</td>
    <td class="codeline">    Loc.SizeInBits = EndBit - StartBit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeline">    assert(Base && "Expected a non-zero ID for Base address");</td>
    <td class="lineNumber">595</td>
    <td class="codeline">    assert(Base && "Expected a non-zero ID for Base address");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeline">    Loc.Base = Base;</td>
    <td class="lineNumber">596</td>
    <td class="codeline">    Loc.Base = Base;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeline">    Loc.DL = DL;</td>
    <td class="lineNumber">597</td>
    <td class="codeline">    Loc.DL = DL;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeline">    BBInsertBeforeMap[&BB][&Before].push_back(Loc);</td>
    <td class="lineNumber">598</td>
    <td class="codeline">    BBInsertBeforeMap[&BB][&Before].push_back(Loc);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Add mem def for " << Aggregates[Var].first->getName()</td>
    <td class="lineNumber">599</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Add mem def for " << Aggregates[Var].first->getName()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeline">                      << " bits [" << StartBit << ", " << EndBit << ")\n");</td>
    <td class="lineNumber">600</td>
    <td class="codeline">                      << " bits [" << StartBit << ", " << EndBit << ")\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">601</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeline"></td>
    <td class="lineNumber">602</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeline">  /// Inserts a new dbg def if the interval found when looking up \p StartBit</td>
    <td class="lineNumber">603</td>
    <td class="codeline">  /// Inserts a new dbg def if the interval found when looking up \p StartBit</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeline">  /// in \p FragMap starts before \p StartBit or ends after \p EndBit (which</td>
    <td class="lineNumber">604</td>
    <td class="codeline">  /// in \p FragMap starts before \p StartBit or ends after \p EndBit (which</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeline">  /// indicates - assuming StartBit->EndBit has just been inserted - that the</td>
    <td class="lineNumber">605</td>
    <td class="codeline">  /// indicates - assuming StartBit->EndBit has just been inserted - that the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeline">  /// slice has been coalesced in the map).</td>
    <td class="lineNumber">606</td>
    <td class="codeline">  /// slice has been coalesced in the map).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeline">  void coalesceFragments(BasicBlock &BB, Instruction &Before, unsigned Var,</td>
    <td class="lineNumber">607</td>
    <td class="codeline">  void coalesceFragments(BasicBlock &BB, Instruction &Before, unsigned Var,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeline">                         unsigned StartBit, unsigned EndBit, unsigned Base,</td>
    <td class="lineNumber">608</td>
    <td class="codeline">                         unsigned StartBit, unsigned EndBit, unsigned Base,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeline">                         DebugLoc DL, const FragsInMemMap &FragMap) {</td>
    <td class="lineNumber">609</td>
    <td class="codeline">                         DebugLoc DL, const FragsInMemMap &FragMap) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeline">    if (!CoalesceAdjacentFragments)</td>
    <td class="lineNumber">610</td>
    <td class="codeline">    if (!CoalesceAdjacentFragments)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">611</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeline">    // We've inserted the location into the map. The map will have coalesced</td>
    <td class="lineNumber">612</td>
    <td class="codeline">    // We've inserted the location into the map. The map will have coalesced</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeline">    // adjacent intervals (variable fragments) that describe the same memory</td>
    <td class="lineNumber">613</td>
    <td class="codeline">    // adjacent intervals (variable fragments) that describe the same memory</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeline">    // location. Use this knowledge to insert a debug location that describes</td>
    <td class="lineNumber">614</td>
    <td class="codeline">    // location. Use this knowledge to insert a debug location that describes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeline">    // that coalesced fragment. This may eclipse other locs we've just</td>
    <td class="lineNumber">615</td>
    <td class="codeline">    // that coalesced fragment. This may eclipse other locs we've just</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeline">    // inserted. This is okay as redundant locs will be cleaned up later.</td>
    <td class="lineNumber">616</td>
    <td class="codeline">    // inserted. This is okay as redundant locs will be cleaned up later.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeline">    auto CoalescedFrag = FragMap.find(StartBit);</td>
    <td class="lineNumber">617</td>
    <td class="codeline">    auto CoalescedFrag = FragMap.find(StartBit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeline">    // Bail if no coalescing has taken place.</td>
    <td class="lineNumber">618</td>
    <td class="codeline">    // Bail if no coalescing has taken place.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeline">    if (CoalescedFrag.start() == StartBit && CoalescedFrag.stop() == EndBit)</td>
    <td class="lineNumber">619</td>
    <td class="codeline">    if (CoalescedFrag.start() == StartBit && CoalescedFrag.stop() == EndBit)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">620</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeline"></td>
    <td class="lineNumber">621</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "- Insert loc for bits " << CoalescedFrag.start()</td>
    <td class="lineNumber">622</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "- Insert loc for bits " << CoalescedFrag.start()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeline">                      << " to " << CoalescedFrag.stop() << "\n");</td>
    <td class="lineNumber">623</td>
    <td class="codeline">                      << " to " << CoalescedFrag.stop() << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeline">    insertMemLoc(BB, Before, Var, CoalescedFrag.start(), CoalescedFrag.stop(),</td>
    <td class="lineNumber">624</td>
    <td class="codeline">    insertMemLoc(BB, Before, Var, CoalescedFrag.start(), CoalescedFrag.stop(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeline">                 Base, DL);</td>
    <td class="lineNumber">625</td>
    <td class="codeline">                 Base, DL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">626</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeline"></td>
    <td class="lineNumber">627</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeline">  void addDef(const VarLocInfo &VarLoc, Instruction &Before, BasicBlock &BB,</td>
    <td class="lineNumber">628</td>
    <td class="codeline">  void addDef(const VarLocInfo &VarLoc, Instruction &Before, BasicBlock &BB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeline">              VarFragMap &LiveSet) {</td>
    <td class="lineNumber">629</td>
    <td class="codeline">              VarFragMap &LiveSet) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeline">    DebugVariable DbgVar = FnVarLocs->getVariable(VarLoc.VariableID);</td>
    <td class="lineNumber">630</td>
    <td class="codeline">    DebugVariable DbgVar = FnVarLocs->getVariable(VarLoc.VariableID);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeline">    if (skipVariable(DbgVar.getVariable()))</td>
    <td class="lineNumber">631</td>
    <td class="codeline">    if (skipVariable(DbgVar.getVariable()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">632</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeline">    // Don't bother doing anything for this variables if we know it's fully</td>
    <td class="lineNumber">633</td>
    <td class="codeline">    // Don't bother doing anything for this variables if we know it's fully</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeline">    // promoted. We're only interested in variables that (sometimes) live on</td>
    <td class="lineNumber">634</td>
    <td class="codeline">    // promoted. We're only interested in variables that (sometimes) live on</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeline">    // the stack here.</td>
    <td class="lineNumber">635</td>
    <td class="codeline">    // the stack here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeline">    if (!VarsWithStackSlot->count(getAggregate(DbgVar)))</td>
    <td class="lineNumber">636</td>
    <td class="codeline">    if (!VarsWithStackSlot->count(getAggregate(DbgVar)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">637</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeline">    unsigned Var = Aggregates.insert(</td>
    <td class="lineNumber">638</td>
    <td class="codeline">    unsigned Var = Aggregates.insert(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeline">        DebugAggregate(DbgVar.getVariable(), VarLoc.DL.getInlinedAt()));</td>
    <td class="lineNumber">639</td>
    <td class="codeline">        DebugAggregate(DbgVar.getVariable(), VarLoc.DL.getInlinedAt()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeline"></td>
    <td class="lineNumber">640</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeline">    // [StartBit: EndBit) are the bits affected by this def.</td>
    <td class="lineNumber">641</td>
    <td class="codeline">    // [StartBit: EndBit) are the bits affected by this def.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeline">    const DIExpression *DIExpr = VarLoc.Expr;</td>
    <td class="lineNumber">642</td>
    <td class="codeline">    const DIExpression *DIExpr = VarLoc.Expr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeline">    unsigned StartBit;</td>
    <td class="lineNumber">643</td>
    <td class="codeline">    unsigned StartBit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeline">    unsigned EndBit;</td>
    <td class="lineNumber">644</td>
    <td class="codeline">    unsigned EndBit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeline">    if (auto Frag = DIExpr->getFragmentInfo()) {</td>
    <td class="lineNumber">645</td>
    <td class="codeline">    if (auto Frag = DIExpr->getFragmentInfo()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeline">      StartBit = Frag->OffsetInBits;</td>
    <td class="lineNumber">646</td>
    <td class="codeline">      StartBit = Frag->OffsetInBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeline">      EndBit = StartBit + Frag->SizeInBits;</td>
    <td class="lineNumber">647</td>
    <td class="codeline">      EndBit = StartBit + Frag->SizeInBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">648</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeline">      assert(static_cast<bool>(DbgVar.getVariable()->getSizeInBits()));</td>
    <td class="lineNumber">649</td>
    <td class="codeline">      assert(static_cast<bool>(DbgVar.getVariable()->getSizeInBits()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeline">      StartBit = 0;</td>
    <td class="lineNumber">650</td>
    <td class="codeline">      StartBit = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeline">      EndBit = *DbgVar.getVariable()->getSizeInBits();</td>
    <td class="lineNumber">651</td>
    <td class="codeline">      EndBit = *DbgVar.getVariable()->getSizeInBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">652</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeline"></td>
    <td class="lineNumber">653</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeline">    // We will only fill fragments for simple memory-describing dbg.value</td>
    <td class="lineNumber">654</td>
    <td class="codeline">    // We will only fill fragments for simple memory-describing dbg.value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeline">    // intrinsics. If the fragment offset is the same as the offset from the</td>
    <td class="lineNumber">655</td>
    <td class="codeline">    // intrinsics. If the fragment offset is the same as the offset from the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeline">    // base pointer, do The Thing, otherwise fall back to normal dbg.value</td>
    <td class="lineNumber">656</td>
    <td class="codeline">    // base pointer, do The Thing, otherwise fall back to normal dbg.value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeline">    // behaviour. AssignmentTrackingLowering has generated DIExpressions</td>
    <td class="lineNumber">657</td>
    <td class="codeline">    // behaviour. AssignmentTrackingLowering has generated DIExpressions</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeline">    // written in terms of the base pointer.</td>
    <td class="lineNumber">658</td>
    <td class="codeline">    // written in terms of the base pointer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeline">    // TODO: Remove this condition since the fragment offset doesn't always</td>
    <td class="lineNumber">659</td>
    <td class="codeline">    // TODO: Remove this condition since the fragment offset doesn't always</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeline">    // equal the offset from base pointer (e.g. for a SROA-split variable).</td>
    <td class="lineNumber">660</td>
    <td class="codeline">    // equal the offset from base pointer (e.g. for a SROA-split variable).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeline">    const auto DerefOffsetInBytes = getDerefOffsetInBytes(DIExpr);</td>
    <td class="lineNumber">661</td>
    <td class="codeline">    const auto DerefOffsetInBytes = getDerefOffsetInBytes(DIExpr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeline">    const unsigned Base =</td>
    <td class="lineNumber">662</td>
    <td class="codeline">    const unsigned Base =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeline">        DerefOffsetInBytes && *DerefOffsetInBytes * 8 == StartBit</td>
    <td class="lineNumber">663</td>
    <td class="codeline">        DerefOffsetInBytes && *DerefOffsetInBytes * 8 == StartBit</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeline">            ? Bases.insert(VarLoc.Values)</td>
    <td class="lineNumber">664</td>
    <td class="codeline">            ? Bases.insert(VarLoc.Values)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeline">            : 0;</td>
    <td class="lineNumber">665</td>
    <td class="codeline">            : 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "DEF " << DbgVar.getVariable()->getName() << " ["</td>
    <td class="lineNumber">666</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "DEF " << DbgVar.getVariable()->getName() << " ["</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeline">                      << StartBit << ", " << EndBit << "): " << toString(Base)</td>
    <td class="lineNumber">667</td>
    <td class="codeline">                      << StartBit << ", " << EndBit << "): " << toString(Base)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeline">                      << "\n");</td>
    <td class="lineNumber">668</td>
    <td class="codeline">                      << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeline"></td>
    <td class="lineNumber">669</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeline">    // First of all, any locs that use mem that are disrupted need reinstating.</td>
    <td class="lineNumber">670</td>
    <td class="codeline">    // First of all, any locs that use mem that are disrupted need reinstating.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeline">    // Unfortunately, IntervalMap doesn't let us insert intervals that overlap</td>
    <td class="lineNumber">671</td>
    <td class="codeline">    // Unfortunately, IntervalMap doesn't let us insert intervals that overlap</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeline">    // with existing intervals so this code involves a lot of fiddling around</td>
    <td class="lineNumber">672</td>
    <td class="codeline">    // with existing intervals so this code involves a lot of fiddling around</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeline">    // with intervals to do that manually.</td>
    <td class="lineNumber">673</td>
    <td class="codeline">    // with intervals to do that manually.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeline">    auto FragIt = LiveSet.find(Var);</td>
    <td class="lineNumber">674</td>
    <td class="codeline">    auto FragIt = LiveSet.find(Var);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeline"></td>
    <td class="lineNumber">675</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeline">    // Check if the variable does not exist in the map.</td>
    <td class="lineNumber">676</td>
    <td class="codeline">    // Check if the variable does not exist in the map.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeline">    if (FragIt == LiveSet.end()) {</td>
    <td class="lineNumber">677</td>
    <td class="codeline">    if (FragIt == LiveSet.end()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeline">      // Add this variable to the BB map.</td>
    <td class="lineNumber">678</td>
    <td class="codeline">      // Add this variable to the BB map.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeline">      auto P = LiveSet.try_emplace(Var, FragsInMemMap(IntervalMapAlloc));</td>
    <td class="lineNumber">679</td>
    <td class="codeline">      auto P = LiveSet.try_emplace(Var, FragsInMemMap(IntervalMapAlloc));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeline">      assert(P.second && "Var already in map?");</td>
    <td class="lineNumber">680</td>
    <td class="codeline">      assert(P.second && "Var already in map?");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeline">      // Add the interval to the fragment map.</td>
    <td class="lineNumber">681</td>
    <td class="codeline">      // Add the interval to the fragment map.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeline">      P.first->second.insert(StartBit, EndBit, Base);</td>
    <td class="lineNumber">682</td>
    <td class="codeline">      P.first->second.insert(StartBit, EndBit, Base);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">683</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">684</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeline">    // The variable has an entry in the map.</td>
    <td class="lineNumber">685</td>
    <td class="codeline">    // The variable has an entry in the map.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeline"></td>
    <td class="lineNumber">686</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeline">    FragsInMemMap &FragMap = FragIt->second;</td>
    <td class="lineNumber">687</td>
    <td class="codeline">    FragsInMemMap &FragMap = FragIt->second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeline">    // First check the easy case: the new fragment `f` doesn't overlap with any</td>
    <td class="lineNumber">688</td>
    <td class="codeline">    // First check the easy case: the new fragment `f` doesn't overlap with any</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeline">    // intervals.</td>
    <td class="lineNumber">689</td>
    <td class="codeline">    // intervals.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeline">    if (!FragMap.overlaps(StartBit, EndBit)) {</td>
    <td class="lineNumber">690</td>
    <td class="codeline">    if (!FragMap.overlaps(StartBit, EndBit)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "- No overlaps\n");</td>
    <td class="lineNumber">691</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "- No overlaps\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeline">      FragMap.insert(StartBit, EndBit, Base);</td>
    <td class="lineNumber">692</td>
    <td class="codeline">      FragMap.insert(StartBit, EndBit, Base);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeline">      coalesceFragments(BB, Before, Var, StartBit, EndBit, Base, VarLoc.DL,</td>
    <td class="lineNumber">693</td>
    <td class="codeline">      coalesceFragments(BB, Before, Var, StartBit, EndBit, Base, VarLoc.DL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeline">                        FragMap);</td>
    <td class="lineNumber">694</td>
    <td class="codeline">                        FragMap);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">695</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">696</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeline">    // There is at least one overlap.</td>
    <td class="lineNumber">697</td>
    <td class="codeline">    // There is at least one overlap.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeline"></td>
    <td class="lineNumber">698</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeline">    // Does StartBit intersect an existing fragment?</td>
    <td class="lineNumber">699</td>
    <td class="codeline">    // Does StartBit intersect an existing fragment?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeline">    auto FirstOverlap = FragMap.find(StartBit);</td>
    <td class="lineNumber">700</td>
    <td class="codeline">    auto FirstOverlap = FragMap.find(StartBit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeline">    assert(FirstOverlap != FragMap.end());</td>
    <td class="lineNumber">701</td>
    <td class="codeline">    assert(FirstOverlap != FragMap.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeline">    bool IntersectStart = FirstOverlap.start() < StartBit;</td>
    <td class="lineNumber">702</td>
    <td class="codeline">    bool IntersectStart = FirstOverlap.start() < StartBit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeline"></td>
    <td class="lineNumber">703</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeline">    // Does EndBit intersect an existing fragment?</td>
    <td class="lineNumber">704</td>
    <td class="codeline">    // Does EndBit intersect an existing fragment?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeline">    auto LastOverlap = FragMap.find(EndBit);</td>
    <td class="lineNumber">705</td>
    <td class="codeline">    auto LastOverlap = FragMap.find(EndBit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeline">    bool IntersectEnd = LastOverlap.valid() && LastOverlap.start() < EndBit;</td>
    <td class="lineNumber">706</td>
    <td class="codeline">    bool IntersectEnd = LastOverlap.valid() && LastOverlap.start() < EndBit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeline"></td>
    <td class="lineNumber">707</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeline">    // Check if both ends of `f` intersect the same interval `i`.</td>
    <td class="lineNumber">708</td>
    <td class="codeline">    // Check if both ends of `f` intersect the same interval `i`.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeline">    if (IntersectStart && IntersectEnd && FirstOverlap == LastOverlap) {</td>
    <td class="lineNumber">709</td>
    <td class="codeline">    if (IntersectStart && IntersectEnd && FirstOverlap == LastOverlap) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "- Intersect single interval @ both ends\n");</td>
    <td class="lineNumber">710</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "- Intersect single interval @ both ends\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeline">      // Shorten `i` so that there's space to insert `f`.</td>
    <td class="lineNumber">711</td>
    <td class="codeline">      // Shorten `i` so that there's space to insert `f`.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeline">      //      [ f ]</td>
    <td class="lineNumber">712</td>
    <td class="codeline">      //      [ f ]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeline">      // [  -   i   -  ]</td>
    <td class="lineNumber">713</td>
    <td class="codeline">      // [  -   i   -  ]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeline">      // +</td>
    <td class="lineNumber">714</td>
    <td class="codeline">      // +</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeline">      // [ i ][ f ][ i ]</td>
    <td class="lineNumber">715</td>
    <td class="codeline">      // [ i ][ f ][ i ]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeline"></td>
    <td class="lineNumber">716</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeline">      // Save values for use after inserting a new interval.</td>
    <td class="lineNumber">717</td>
    <td class="codeline">      // Save values for use after inserting a new interval.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeline">      auto EndBitOfOverlap = FirstOverlap.stop();</td>
    <td class="lineNumber">718</td>
    <td class="codeline">      auto EndBitOfOverlap = FirstOverlap.stop();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeline">      unsigned OverlapValue = FirstOverlap.value();</td>
    <td class="lineNumber">719</td>
    <td class="codeline">      unsigned OverlapValue = FirstOverlap.value();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeline"></td>
    <td class="lineNumber">720</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeline">      // Shorten the overlapping interval.</td>
    <td class="lineNumber">721</td>
    <td class="codeline">      // Shorten the overlapping interval.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeline">      FirstOverlap.setStop(StartBit);</td>
    <td class="lineNumber">722</td>
    <td class="codeline">      FirstOverlap.setStop(StartBit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeline">      insertMemLoc(BB, Before, Var, FirstOverlap.start(), StartBit,</td>
    <td class="lineNumber">723</td>
    <td class="codeline">      insertMemLoc(BB, Before, Var, FirstOverlap.start(), StartBit,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeline">                   OverlapValue, VarLoc.DL);</td>
    <td class="lineNumber">724</td>
    <td class="codeline">                   OverlapValue, VarLoc.DL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeline"></td>
    <td class="lineNumber">725</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeline">      // Insert a new interval to represent the end part.</td>
    <td class="lineNumber">726</td>
    <td class="codeline">      // Insert a new interval to represent the end part.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeline">      FragMap.insert(EndBit, EndBitOfOverlap, OverlapValue);</td>
    <td class="lineNumber">727</td>
    <td class="codeline">      FragMap.insert(EndBit, EndBitOfOverlap, OverlapValue);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeline">      insertMemLoc(BB, Before, Var, EndBit, EndBitOfOverlap, OverlapValue,</td>
    <td class="lineNumber">728</td>
    <td class="codeline">      insertMemLoc(BB, Before, Var, EndBit, EndBitOfOverlap, OverlapValue,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeline">                   VarLoc.DL);</td>
    <td class="lineNumber">729</td>
    <td class="codeline">                   VarLoc.DL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeline"></td>
    <td class="lineNumber">730</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeline">      // Insert the new (middle) fragment now there is space.</td>
    <td class="lineNumber">731</td>
    <td class="codeline">      // Insert the new (middle) fragment now there is space.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeline">      FragMap.insert(StartBit, EndBit, Base);</td>
    <td class="lineNumber">732</td>
    <td class="codeline">      FragMap.insert(StartBit, EndBit, Base);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">733</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeline">      // There's an overlap but `f` may not be fully contained within</td>
    <td class="lineNumber">734</td>
    <td class="codeline">      // There's an overlap but `f` may not be fully contained within</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeline">      // `i`. Shorten any end-point intersections so that we can then</td>
    <td class="lineNumber">735</td>
    <td class="codeline">      // `i`. Shorten any end-point intersections so that we can then</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeline">      // insert `f`.</td>
    <td class="lineNumber">736</td>
    <td class="codeline">      // insert `f`.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeline">      //      [ - f - ]</td>
    <td class="lineNumber">737</td>
    <td class="codeline">      //      [ - f - ]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeline">      // [ - i - ]</td>
    <td class="lineNumber">738</td>
    <td class="codeline">      // [ - i - ]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeline">      // |   |</td>
    <td class="lineNumber">739</td>
    <td class="codeline">      // |   |</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeline">      // [ i ]</td>
    <td class="lineNumber">740</td>
    <td class="codeline">      // [ i ]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeline">      // Shorten any end-point intersections.</td>
    <td class="lineNumber">741</td>
    <td class="codeline">      // Shorten any end-point intersections.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeline">      if (IntersectStart) {</td>
    <td class="lineNumber">742</td>
    <td class="codeline">      if (IntersectStart) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "- Intersect interval at start\n");</td>
    <td class="lineNumber">743</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "- Intersect interval at start\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeline">        // Split off at the intersection.</td>
    <td class="lineNumber">744</td>
    <td class="codeline">        // Split off at the intersection.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeline">        FirstOverlap.setStop(StartBit);</td>
    <td class="lineNumber">745</td>
    <td class="codeline">        FirstOverlap.setStop(StartBit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeline">        insertMemLoc(BB, Before, Var, FirstOverlap.start(), StartBit,</td>
    <td class="lineNumber">746</td>
    <td class="codeline">        insertMemLoc(BB, Before, Var, FirstOverlap.start(), StartBit,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeline">                     *FirstOverlap, VarLoc.DL);</td>
    <td class="lineNumber">747</td>
    <td class="codeline">                     *FirstOverlap, VarLoc.DL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">748</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeline">      // [ - f - ]</td>
    <td class="lineNumber">749</td>
    <td class="codeline">      // [ - f - ]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeline">      //      [ - i - ]</td>
    <td class="lineNumber">750</td>
    <td class="codeline">      //      [ - i - ]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeline">      //          |   |</td>
    <td class="lineNumber">751</td>
    <td class="codeline">      //          |   |</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeline">      //          [ i ]</td>
    <td class="lineNumber">752</td>
    <td class="codeline">      //          [ i ]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeline">      if (IntersectEnd) {</td>
    <td class="lineNumber">753</td>
    <td class="codeline">      if (IntersectEnd) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "- Intersect interval at end\n");</td>
    <td class="lineNumber">754</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "- Intersect interval at end\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeline">        // Split off at the intersection.</td>
    <td class="lineNumber">755</td>
    <td class="codeline">        // Split off at the intersection.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeline">        LastOverlap.setStart(EndBit);</td>
    <td class="lineNumber">756</td>
    <td class="codeline">        LastOverlap.setStart(EndBit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeline">        insertMemLoc(BB, Before, Var, EndBit, LastOverlap.stop(), *LastOverlap,</td>
    <td class="lineNumber">757</td>
    <td class="codeline">        insertMemLoc(BB, Before, Var, EndBit, LastOverlap.stop(), *LastOverlap,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeline">                     VarLoc.DL);</td>
    <td class="lineNumber">758</td>
    <td class="codeline">                     VarLoc.DL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">759</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeline"></td>
    <td class="lineNumber">760</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "- Erase intervals contained within\n");</td>
    <td class="lineNumber">761</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "- Erase intervals contained within\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeline">      // FirstOverlap and LastOverlap have been shortened such that they're</td>
    <td class="lineNumber">762</td>
    <td class="codeline">      // FirstOverlap and LastOverlap have been shortened such that they're</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeline">      // no longer overlapping with [StartBit, EndBit). Delete any overlaps</td>
    <td class="lineNumber">763</td>
    <td class="codeline">      // no longer overlapping with [StartBit, EndBit). Delete any overlaps</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeline">      // that remain (these will be fully contained within `f`).</td>
    <td class="lineNumber">764</td>
    <td class="codeline">      // that remain (these will be fully contained within `f`).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeline">      // [ - f - ]       }</td>
    <td class="lineNumber">765</td>
    <td class="codeline">      // [ - f - ]       }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeline">      //      [ - i - ]  } Intersection shortening that has happened above.</td>
    <td class="lineNumber">766</td>
    <td class="codeline">      //      [ - i - ]  } Intersection shortening that has happened above.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeline">      //          |   |  }</td>
    <td class="lineNumber">767</td>
    <td class="codeline">      //          |   |  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeline">      //          [ i ]  }</td>
    <td class="lineNumber">768</td>
    <td class="codeline">      //          [ i ]  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeline">      // -----------------</td>
    <td class="lineNumber">769</td>
    <td class="codeline">      // -----------------</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeline">      // [i2 ]           } Intervals fully contained within `f` get erased.</td>
    <td class="lineNumber">770</td>
    <td class="codeline">      // [i2 ]           } Intervals fully contained within `f` get erased.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeline">      // -----------------</td>
    <td class="lineNumber">771</td>
    <td class="codeline">      // -----------------</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeline">      // [ - f - ][ i ]  } Completed insertion.</td>
    <td class="lineNumber">772</td>
    <td class="codeline">      // [ - f - ][ i ]  } Completed insertion.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeline">      auto It = FirstOverlap;</td>
    <td class="lineNumber">773</td>
    <td class="codeline">      auto It = FirstOverlap;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeline">      if (IntersectStart)</td>
    <td class="lineNumber">774</td>
    <td class="codeline">      if (IntersectStart)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeline">        ++It; // IntersectStart: first overlap has been shortened.</td>
    <td class="lineNumber">775</td>
    <td class="codeline">        ++It; // IntersectStart: first overlap has been shortened.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeline">      while (It.valid() && It.start() >= StartBit && It.stop() <= EndBit) {</td>
    <td class="lineNumber">776</td>
    <td class="codeline">      while (It.valid() && It.start() >= StartBit && It.stop() <= EndBit) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "- Erase " << toString(It));</td>
    <td class="lineNumber">777</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "- Erase " << toString(It));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeline">        It.erase(); // This increments It after removing the interval.</td>
    <td class="lineNumber">778</td>
    <td class="codeline">        It.erase(); // This increments It after removing the interval.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">779</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeline">      // We've dealt with all the overlaps now!</td>
    <td class="lineNumber">780</td>
    <td class="codeline">      // We've dealt with all the overlaps now!</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeline">      assert(!FragMap.overlaps(StartBit, EndBit));</td>
    <td class="lineNumber">781</td>
    <td class="codeline">      assert(!FragMap.overlaps(StartBit, EndBit));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "- Insert DEF into now-empty space\n");</td>
    <td class="lineNumber">782</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "- Insert DEF into now-empty space\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeline">      FragMap.insert(StartBit, EndBit, Base);</td>
    <td class="lineNumber">783</td>
    <td class="codeline">      FragMap.insert(StartBit, EndBit, Base);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">784</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeline"></td>
    <td class="lineNumber">785</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeline">    coalesceFragments(BB, Before, Var, StartBit, EndBit, Base, VarLoc.DL,</td>
    <td class="lineNumber">786</td>
    <td class="codeline">    coalesceFragments(BB, Before, Var, StartBit, EndBit, Base, VarLoc.DL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeline">                      FragMap);</td>
    <td class="lineNumber">787</td>
    <td class="codeline">                      FragMap);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">788</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeline"></td>
    <td class="lineNumber">789</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeline">  bool skipVariable(const DILocalVariable *V) { return !V->getSizeInBits(); }</td>
    <td class="lineNumber">790</td>
    <td class="codeline">  bool skipVariable(const DILocalVariable *V) { return !V->getSizeInBits(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeline"></td>
    <td class="lineNumber">791</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeline">  void process(BasicBlock &BB, VarFragMap &LiveSet) {</td>
    <td class="lineNumber">792</td>
    <td class="codeline">  void process(BasicBlock &BB, VarFragMap &LiveSet) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeline">    BBInsertBeforeMap[&BB].clear();</td>
    <td class="lineNumber">793</td>
    <td class="codeline">    BBInsertBeforeMap[&BB].clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeline">    for (auto &I : BB) {</td>
    <td class="lineNumber">794</td>
    <td class="codeline">    for (auto &I : BB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeline">      if (const auto *Locs = FnVarLocs->getWedge(&I)) {</td>
    <td class="lineNumber">795</td>
    <td class="codeline">      if (const auto *Locs = FnVarLocs->getWedge(&I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeline">        for (const VarLocInfo &Loc : *Locs) {</td>
    <td class="lineNumber">796</td>
    <td class="codeline">        for (const VarLocInfo &Loc : *Locs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeline">          addDef(Loc, I, *I.getParent(), LiveSet);</td>
    <td class="lineNumber">797</td>
    <td class="codeline">          addDef(Loc, I, *I.getParent(), LiveSet);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">798</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">799</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">800</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">801</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeline"></td>
    <td class="lineNumber">802</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">803</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeline">  MemLocFragmentFill(Function &Fn,</td>
    <td class="lineNumber">804</td>
    <td class="codeline">  MemLocFragmentFill(Function &Fn,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeline">                     const DenseSet<DebugAggregate> *VarsWithStackSlot,</td>
    <td class="lineNumber">805</td>
    <td class="codeline">                     const DenseSet<DebugAggregate> *VarsWithStackSlot,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeline">                     bool CoalesceAdjacentFragments)</td>
    <td class="lineNumber">806</td>
    <td class="codeline">                     bool CoalesceAdjacentFragments)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeline">      : Fn(Fn), VarsWithStackSlot(VarsWithStackSlot),</td>
    <td class="lineNumber">807</td>
    <td class="codeline">      : Fn(Fn), VarsWithStackSlot(VarsWithStackSlot),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeline">        CoalesceAdjacentFragments(CoalesceAdjacentFragments) {}</td>
    <td class="lineNumber">808</td>
    <td class="codeline">        CoalesceAdjacentFragments(CoalesceAdjacentFragments) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeline"></td>
    <td class="lineNumber">809</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeline">  /// Add variable locations to \p FnVarLocs so that any bits of a variable</td>
    <td class="lineNumber">810</td>
    <td class="codeline">  /// Add variable locations to \p FnVarLocs so that any bits of a variable</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeline">  /// with a memory location have that location explicitly reinstated at each</td>
    <td class="lineNumber">811</td>
    <td class="codeline">  /// with a memory location have that location explicitly reinstated at each</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeline">  /// subsequent variable location definition that that doesn't overwrite those</td>
    <td class="lineNumber">812</td>
    <td class="codeline">  /// subsequent variable location definition that that doesn't overwrite those</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeline">  /// bits. i.e. after a variable location def, insert new defs for the memory</td>
    <td class="lineNumber">813</td>
    <td class="codeline">  /// bits. i.e. after a variable location def, insert new defs for the memory</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeline">  /// location with fragments for the difference of "all bits currently in</td>
    <td class="lineNumber">814</td>
    <td class="codeline">  /// location with fragments for the difference of "all bits currently in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeline">  /// memory" and "the fragment of the second def". e.g.</td>
    <td class="lineNumber">815</td>
    <td class="codeline">  /// memory" and "the fragment of the second def". e.g.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">816</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeline">  ///     Before:</td>
    <td class="lineNumber">817</td>
    <td class="codeline">  ///     Before:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">818</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeline">  ///     var x bits 0 to 63:  value in memory</td>
    <td class="lineNumber">819</td>
    <td class="codeline">  ///     var x bits 0 to 63:  value in memory</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeline">  ///     more instructions</td>
    <td class="lineNumber">820</td>
    <td class="codeline">  ///     more instructions</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeline">  ///     var x bits 0 to 31:  value is %0</td>
    <td class="lineNumber">821</td>
    <td class="codeline">  ///     var x bits 0 to 31:  value is %0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">822</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeline">  ///     After:</td>
    <td class="lineNumber">823</td>
    <td class="codeline">  ///     After:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">824</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeline">  ///     var x bits 0 to 63:  value in memory</td>
    <td class="lineNumber">825</td>
    <td class="codeline">  ///     var x bits 0 to 63:  value in memory</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeline">  ///     more instructions</td>
    <td class="lineNumber">826</td>
    <td class="codeline">  ///     more instructions</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeline">  ///     var x bits 0 to 31:  value is %0</td>
    <td class="lineNumber">827</td>
    <td class="codeline">  ///     var x bits 0 to 31:  value is %0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeline">  ///     var x bits 32 to 61: value in memory ; <-- new loc def</td>
    <td class="lineNumber">828</td>
    <td class="codeline">  ///     var x bits 32 to 61: value in memory ; <-- new loc def</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">829</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeline">  void run(FunctionVarLocsBuilder *FnVarLocs) {</td>
    <td class="lineNumber">830</td>
    <td class="codeline">  void run(FunctionVarLocsBuilder *FnVarLocs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeline">    if (!EnableMemLocFragFill)</td>
    <td class="lineNumber">831</td>
    <td class="codeline">    if (!EnableMemLocFragFill)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">832</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeline"></td>
    <td class="lineNumber">833</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeline">    this->FnVarLocs = FnVarLocs;</td>
    <td class="lineNumber">834</td>
    <td class="codeline">    this->FnVarLocs = FnVarLocs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeline"></td>
    <td class="lineNumber">835</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeline">    // Prepare for traversal.</td>
    <td class="lineNumber">836</td>
    <td class="codeline">    // Prepare for traversal.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">837</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeline">    ReversePostOrderTraversal<Function *> RPOT(&Fn);</td>
    <td class="lineNumber">838</td>
    <td class="codeline">    ReversePostOrderTraversal<Function *> RPOT(&Fn);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeline">    std::priority_queue<unsigned int, std::vector<unsigned int>,</td>
    <td class="lineNumber">839</td>
    <td class="codeline">    std::priority_queue<unsigned int, std::vector<unsigned int>,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeline">                        std::greater<unsigned int>></td>
    <td class="lineNumber">840</td>
    <td class="codeline">                        std::greater<unsigned int>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeline">        Worklist;</td>
    <td class="lineNumber">841</td>
    <td class="codeline">        Worklist;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeline">    std::priority_queue<unsigned int, std::vector<unsigned int>,</td>
    <td class="lineNumber">842</td>
    <td class="codeline">    std::priority_queue<unsigned int, std::vector<unsigned int>,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeline">                        std::greater<unsigned int>></td>
    <td class="lineNumber">843</td>
    <td class="codeline">                        std::greater<unsigned int>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeline">        Pending;</td>
    <td class="lineNumber">844</td>
    <td class="codeline">        Pending;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeline">    DenseMap<unsigned int, BasicBlock *> OrderToBB;</td>
    <td class="lineNumber">845</td>
    <td class="codeline">    DenseMap<unsigned int, BasicBlock *> OrderToBB;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeline">    DenseMap<BasicBlock *, unsigned int> BBToOrder;</td>
    <td class="lineNumber">846</td>
    <td class="codeline">    DenseMap<BasicBlock *, unsigned int> BBToOrder;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeline">    { // Init OrderToBB and BBToOrder.</td>
    <td class="lineNumber">847</td>
    <td class="codeline">    { // Init OrderToBB and BBToOrder.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeline">      unsigned int RPONumber = 0;</td>
    <td class="lineNumber">848</td>
    <td class="codeline">      unsigned int RPONumber = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeline">      for (auto RI = RPOT.begin(), RE = RPOT.end(); RI != RE; ++RI) {</td>
    <td class="lineNumber">849</td>
    <td class="codeline">      for (auto RI = RPOT.begin(), RE = RPOT.end(); RI != RE; ++RI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeline">        OrderToBB[RPONumber] = *RI;</td>
    <td class="lineNumber">850</td>
    <td class="codeline">        OrderToBB[RPONumber] = *RI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeline">        BBToOrder[*RI] = RPONumber;</td>
    <td class="lineNumber">851</td>
    <td class="codeline">        BBToOrder[*RI] = RPONumber;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeline">        Worklist.push(RPONumber);</td>
    <td class="lineNumber">852</td>
    <td class="codeline">        Worklist.push(RPONumber);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeline">        ++RPONumber;</td>
    <td class="lineNumber">853</td>
    <td class="codeline">        ++RPONumber;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">854</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeline">      LiveIn.init(RPONumber);</td>
    <td class="lineNumber">855</td>
    <td class="codeline">      LiveIn.init(RPONumber);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeline">      LiveOut.init(RPONumber);</td>
    <td class="lineNumber">856</td>
    <td class="codeline">      LiveOut.init(RPONumber);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">857</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeline"></td>
    <td class="lineNumber">858</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeline">    // Perform the traversal.</td>
    <td class="lineNumber">859</td>
    <td class="codeline">    // Perform the traversal.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">860</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeline">    // This is a standard "intersect of predecessor outs" dataflow problem. To</td>
    <td class="lineNumber">861</td>
    <td class="codeline">    // This is a standard "intersect of predecessor outs" dataflow problem. To</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeline">    // solve it, we perform meet() and process() using the two worklist method</td>
    <td class="lineNumber">862</td>
    <td class="codeline">    // solve it, we perform meet() and process() using the two worklist method</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeline">    // until the LiveIn data for each block becomes unchanging.</td>
    <td class="lineNumber">863</td>
    <td class="codeline">    // until the LiveIn data for each block becomes unchanging.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">864</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeline">    // This dataflow is essentially working on maps of sets and at each meet we</td>
    <td class="lineNumber">865</td>
    <td class="codeline">    // This dataflow is essentially working on maps of sets and at each meet we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeline">    // intersect the maps and the mapped sets. So, initialized live-in maps</td>
    <td class="lineNumber">866</td>
    <td class="codeline">    // intersect the maps and the mapped sets. So, initialized live-in maps</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeline">    // monotonically decrease in value throughout the dataflow.</td>
    <td class="lineNumber">867</td>
    <td class="codeline">    // monotonically decrease in value throughout the dataflow.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeline">    SmallPtrSet<BasicBlock *, 16> Visited;</td>
    <td class="lineNumber">868</td>
    <td class="codeline">    SmallPtrSet<BasicBlock *, 16> Visited;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeline">    while (!Worklist.empty() || !Pending.empty()) {</td>
    <td class="lineNumber">869</td>
    <td class="codeline">    while (!Worklist.empty() || !Pending.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeline">      // We track what is on the pending worklist to avoid inserting the same</td>
    <td class="lineNumber">870</td>
    <td class="codeline">      // We track what is on the pending worklist to avoid inserting the same</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeline">      // thing twice.  We could avoid this with a custom priority queue, but</td>
    <td class="lineNumber">871</td>
    <td class="codeline">      // thing twice.  We could avoid this with a custom priority queue, but</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeline">      // this is probably not worth it.</td>
    <td class="lineNumber">872</td>
    <td class="codeline">      // this is probably not worth it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeline">      SmallPtrSet<BasicBlock *, 16> OnPending;</td>
    <td class="lineNumber">873</td>
    <td class="codeline">      SmallPtrSet<BasicBlock *, 16> OnPending;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "Processing Worklist\n");</td>
    <td class="lineNumber">874</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "Processing Worklist\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeline">      while (!Worklist.empty()) {</td>
    <td class="lineNumber">875</td>
    <td class="codeline">      while (!Worklist.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeline">        BasicBlock *BB = OrderToBB[Worklist.top()];</td>
    <td class="lineNumber">876</td>
    <td class="codeline">        BasicBlock *BB = OrderToBB[Worklist.top()];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "\nPop BB " << BB->getName() << "\n");</td>
    <td class="lineNumber">877</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "\nPop BB " << BB->getName() << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeline">        Worklist.pop();</td>
    <td class="lineNumber">878</td>
    <td class="codeline">        Worklist.pop();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeline">        bool InChanged = meet(*BB, Visited);</td>
    <td class="lineNumber">879</td>
    <td class="codeline">        bool InChanged = meet(*BB, Visited);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeline">        // Always consider LiveIn changed on the first visit.</td>
    <td class="lineNumber">880</td>
    <td class="codeline">        // Always consider LiveIn changed on the first visit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeline">        InChanged |= Visited.insert(BB).second;</td>
    <td class="lineNumber">881</td>
    <td class="codeline">        InChanged |= Visited.insert(BB).second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeline">        if (InChanged) {</td>
    <td class="lineNumber">882</td>
    <td class="codeline">        if (InChanged) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeline">          LLVM_DEBUG(dbgs()</td>
    <td class="lineNumber">883</td>
    <td class="codeline">          LLVM_DEBUG(dbgs()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeline">                     << BB->getName() << " has new InLocs, process it\n");</td>
    <td class="lineNumber">884</td>
    <td class="codeline">                     << BB->getName() << " has new InLocs, process it\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeline">          //  Mutate a copy of LiveIn while processing BB. Once we've processed</td>
    <td class="lineNumber">885</td>
    <td class="codeline">          //  Mutate a copy of LiveIn while processing BB. Once we've processed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeline">          //  the terminator LiveSet is the LiveOut set for BB.</td>
    <td class="lineNumber">886</td>
    <td class="codeline">          //  the terminator LiveSet is the LiveOut set for BB.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeline">          //  This is an expensive copy!</td>
    <td class="lineNumber">887</td>
    <td class="codeline">          //  This is an expensive copy!</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeline">          VarFragMap LiveSet = LiveIn[BB];</td>
    <td class="lineNumber">888</td>
    <td class="codeline">          VarFragMap LiveSet = LiveIn[BB];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeline"></td>
    <td class="lineNumber">889</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeline">          // Process the instructions in the block.</td>
    <td class="lineNumber">890</td>
    <td class="codeline">          // Process the instructions in the block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeline">          process(*BB, LiveSet);</td>
    <td class="lineNumber">891</td>
    <td class="codeline">          process(*BB, LiveSet);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeline"></td>
    <td class="lineNumber">892</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeline">          // Relatively expensive check: has anything changed in LiveOut for BB?</td>
    <td class="lineNumber">893</td>
    <td class="codeline">          // Relatively expensive check: has anything changed in LiveOut for BB?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeline">          if (!varFragMapsAreEqual(LiveOut[BB], LiveSet)) {</td>
    <td class="lineNumber">894</td>
    <td class="codeline">          if (!varFragMapsAreEqual(LiveOut[BB], LiveSet)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeline">            LLVM_DEBUG(dbgs() << BB->getName()</td>
    <td class="lineNumber">895</td>
    <td class="codeline">            LLVM_DEBUG(dbgs() << BB->getName()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeline">                              << " has new OutLocs, add succs to worklist: [ ");</td>
    <td class="lineNumber">896</td>
    <td class="codeline">                              << " has new OutLocs, add succs to worklist: [ ");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeline">            LiveOut[BB] = std::move(LiveSet);</td>
    <td class="lineNumber">897</td>
    <td class="codeline">            LiveOut[BB] = std::move(LiveSet);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeline">            for (auto I = succ_begin(BB), E = succ_end(BB); I != E; I++) {</td>
    <td class="lineNumber">898</td>
    <td class="codeline">            for (auto I = succ_begin(BB), E = succ_end(BB); I != E; I++) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeline">              if (OnPending.insert(*I).second) {</td>
    <td class="lineNumber">899</td>
    <td class="codeline">              if (OnPending.insert(*I).second) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeline">                LLVM_DEBUG(dbgs() << I->getName() << " ");</td>
    <td class="lineNumber">900</td>
    <td class="codeline">                LLVM_DEBUG(dbgs() << I->getName() << " ");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeline">                Pending.push(BBToOrder[*I]);</td>
    <td class="lineNumber">901</td>
    <td class="codeline">                Pending.push(BBToOrder[*I]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeline">              }</td>
    <td class="lineNumber">902</td>
    <td class="codeline">              }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeline">            }</td>
    <td class="lineNumber">903</td>
    <td class="codeline">            }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeline">            LLVM_DEBUG(dbgs() << "]\n");</td>
    <td class="lineNumber">904</td>
    <td class="codeline">            LLVM_DEBUG(dbgs() << "]\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">905</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">906</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">907</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeline">      Worklist.swap(Pending);</td>
    <td class="lineNumber">908</td>
    <td class="codeline">      Worklist.swap(Pending);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeline">      // At this point, pending must be empty, since it was just the empty</td>
    <td class="lineNumber">909</td>
    <td class="codeline">      // At this point, pending must be empty, since it was just the empty</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeline">      // worklist</td>
    <td class="lineNumber">910</td>
    <td class="codeline">      // worklist</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeline">      assert(Pending.empty() && "Pending should be empty");</td>
    <td class="lineNumber">911</td>
    <td class="codeline">      assert(Pending.empty() && "Pending should be empty");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">912</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeline"></td>
    <td class="lineNumber">913</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeline">    // Insert new location defs.</td>
    <td class="lineNumber">914</td>
    <td class="codeline">    // Insert new location defs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeline">    for (auto &Pair : BBInsertBeforeMap) {</td>
    <td class="lineNumber">915</td>
    <td class="codeline">    for (auto &Pair : BBInsertBeforeMap) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeline">      InsertMap &Map = Pair.second;</td>
    <td class="lineNumber">916</td>
    <td class="codeline">      InsertMap &Map = Pair.second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeline">      for (auto &Pair : Map) {</td>
    <td class="lineNumber">917</td>
    <td class="codeline">      for (auto &Pair : Map) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeline">        Instruction *InsertBefore = Pair.first;</td>
    <td class="lineNumber">918</td>
    <td class="codeline">        Instruction *InsertBefore = Pair.first;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeline">        assert(InsertBefore && "should never be null");</td>
    <td class="lineNumber">919</td>
    <td class="codeline">        assert(InsertBefore && "should never be null");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeline">        auto FragMemLocs = Pair.second;</td>
    <td class="lineNumber">920</td>
    <td class="codeline">        auto FragMemLocs = Pair.second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeline">        auto &Ctx = Fn.getContext();</td>
    <td class="lineNumber">921</td>
    <td class="codeline">        auto &Ctx = Fn.getContext();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeline"></td>
    <td class="lineNumber">922</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeline">        for (auto &FragMemLoc : FragMemLocs) {</td>
    <td class="lineNumber">923</td>
    <td class="codeline">        for (auto &FragMemLoc : FragMemLocs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeline">          DIExpression *Expr = DIExpression::get(Ctx, std::nullopt);</td>
    <td class="lineNumber">924</td>
    <td class="codeline">          DIExpression *Expr = DIExpression::get(Ctx, std::nullopt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeline">          if (FragMemLoc.SizeInBits !=</td>
    <td class="lineNumber">925</td>
    <td class="codeline">          if (FragMemLoc.SizeInBits !=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeline">              *Aggregates[FragMemLoc.Var].first->getSizeInBits())</td>
    <td class="lineNumber">926</td>
    <td class="codeline">              *Aggregates[FragMemLoc.Var].first->getSizeInBits())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeline">            Expr = *DIExpression::createFragmentExpression(</td>
    <td class="lineNumber">927</td>
    <td class="codeline">            Expr = *DIExpression::createFragmentExpression(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeline">                Expr, FragMemLoc.OffsetInBits, FragMemLoc.SizeInBits);</td>
    <td class="lineNumber">928</td>
    <td class="codeline">                Expr, FragMemLoc.OffsetInBits, FragMemLoc.SizeInBits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeline">          Expr = DIExpression::prepend(Expr, DIExpression::DerefAfter,</td>
    <td class="lineNumber">929</td>
    <td class="codeline">          Expr = DIExpression::prepend(Expr, DIExpression::DerefAfter,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeline">                                       FragMemLoc.OffsetInBits / 8);</td>
    <td class="lineNumber">930</td>
    <td class="codeline">                                       FragMemLoc.OffsetInBits / 8);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeline">          DebugVariable Var(Aggregates[FragMemLoc.Var].first, Expr,</td>
    <td class="lineNumber">931</td>
    <td class="codeline">          DebugVariable Var(Aggregates[FragMemLoc.Var].first, Expr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeline">                            FragMemLoc.DL.getInlinedAt());</td>
    <td class="lineNumber">932</td>
    <td class="codeline">                            FragMemLoc.DL.getInlinedAt());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeline">          FnVarLocs->addVarLoc(InsertBefore, Var, Expr, FragMemLoc.DL,</td>
    <td class="lineNumber">933</td>
    <td class="codeline">          FnVarLocs->addVarLoc(InsertBefore, Var, Expr, FragMemLoc.DL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeline">                               Bases[FragMemLoc.Base]);</td>
    <td class="lineNumber">934</td>
    <td class="codeline">                               Bases[FragMemLoc.Base]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">935</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">936</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">937</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">938</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeline">};</td>
    <td class="lineNumber">939</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeline"></td>
    <td class="lineNumber">940</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeline">/// AssignmentTrackingLowering encapsulates a dataflow analysis over a function</td>
    <td class="lineNumber">941</td>
    <td class="codeline">/// AssignmentTrackingLowering encapsulates a dataflow analysis over a function</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeline">/// that interprets assignment tracking debug info metadata and stores in IR to</td>
    <td class="lineNumber">942</td>
    <td class="codeline">/// that interprets assignment tracking debug info metadata and stores in IR to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeline">/// create a map of variable locations.</td>
    <td class="lineNumber">943</td>
    <td class="codeline">/// create a map of variable locations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeline">class AssignmentTrackingLowering {</td>
    <td class="lineNumber">944</td>
    <td class="codeline">class AssignmentTrackingLowering {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">945</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeline">  /// The kind of location in use for a variable, where Mem is the stack home,</td>
    <td class="lineNumber">946</td>
    <td class="codeline">  /// The kind of location in use for a variable, where Mem is the stack home,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeline">  /// Val is an SSA value or const, and None means that there is not one single</td>
    <td class="lineNumber">947</td>
    <td class="codeline">  /// Val is an SSA value or const, and None means that there is not one single</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeline">  /// kind (either because there are multiple or because there is none; it may</td>
    <td class="lineNumber">948</td>
    <td class="codeline">  /// kind (either because there are multiple or because there is none; it may</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeline">  /// prove useful to split this into two values in the future).</td>
    <td class="lineNumber">949</td>
    <td class="codeline">  /// prove useful to split this into two values in the future).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">950</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeline">  /// LocKind is a join-semilattice with the partial order:</td>
    <td class="lineNumber">951</td>
    <td class="codeline">  /// LocKind is a join-semilattice with the partial order:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeline">  /// None > Mem, Val</td>
    <td class="lineNumber">952</td>
    <td class="codeline">  /// None > Mem, Val</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">953</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeline">  /// i.e.</td>
    <td class="lineNumber">954</td>
    <td class="codeline">  /// i.e.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeline">  /// join(Mem, Mem)   = Mem</td>
    <td class="lineNumber">955</td>
    <td class="codeline">  /// join(Mem, Mem)   = Mem</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeline">  /// join(Val, Val)   = Val</td>
    <td class="lineNumber">956</td>
    <td class="codeline">  /// join(Val, Val)   = Val</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeline">  /// join(Mem, Val)   = None</td>
    <td class="lineNumber">957</td>
    <td class="codeline">  /// join(Mem, Val)   = None</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeline">  /// join(None, Mem)  = None</td>
    <td class="lineNumber">958</td>
    <td class="codeline">  /// join(None, Mem)  = None</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeline">  /// join(None, Val)  = None</td>
    <td class="lineNumber">959</td>
    <td class="codeline">  /// join(None, Val)  = None</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeline">  /// join(None, None) = None</td>
    <td class="lineNumber">960</td>
    <td class="codeline">  /// join(None, None) = None</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">961</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeline">  /// Note: the order is not `None > Val > Mem` because we're using DIAssignID</td>
    <td class="lineNumber">962</td>
    <td class="codeline">  /// Note: the order is not `None > Val > Mem` because we're using DIAssignID</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeline">  /// to name assignments and are not tracking the actual stored values.</td>
    <td class="lineNumber">963</td>
    <td class="codeline">  /// to name assignments and are not tracking the actual stored values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeline">  /// Therefore currently there's no way to ensure that Mem values and Val</td>
    <td class="lineNumber">964</td>
    <td class="codeline">  /// Therefore currently there's no way to ensure that Mem values and Val</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeline">  /// values are the same. This could be a future extension, though it's not</td>
    <td class="lineNumber">965</td>
    <td class="codeline">  /// values are the same. This could be a future extension, though it's not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeline">  /// clear that many additional locations would be recovered that way in</td>
    <td class="lineNumber">966</td>
    <td class="codeline">  /// clear that many additional locations would be recovered that way in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeline">  /// practice as the likelihood of this sitation arising naturally seems</td>
    <td class="lineNumber">967</td>
    <td class="codeline">  /// practice as the likelihood of this sitation arising naturally seems</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeline">  /// incredibly low.</td>
    <td class="lineNumber">968</td>
    <td class="codeline">  /// incredibly low.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeline">  enum class LocKind { Mem, Val, None };</td>
    <td class="lineNumber">969</td>
    <td class="codeline">  enum class LocKind { Mem, Val, None };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeline"></td>
    <td class="lineNumber">970</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeline">  /// An abstraction of the assignment of a value to a variable or memory</td>
    <td class="lineNumber">971</td>
    <td class="codeline">  /// An abstraction of the assignment of a value to a variable or memory</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeline">  /// location.</td>
    <td class="lineNumber">972</td>
    <td class="codeline">  /// location.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">973</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeline">  /// An Assignment is Known or NoneOrPhi. A Known Assignment means we have a</td>
    <td class="lineNumber">974</td>
    <td class="codeline">  /// An Assignment is Known or NoneOrPhi. A Known Assignment means we have a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeline">  /// DIAssignID ptr that represents it. NoneOrPhi means that we don't (or</td>
    <td class="lineNumber">975</td>
    <td class="codeline">  /// DIAssignID ptr that represents it. NoneOrPhi means that we don't (or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeline">  /// can't) know the ID of the last assignment that took place.</td>
    <td class="lineNumber">976</td>
    <td class="codeline">  /// can't) know the ID of the last assignment that took place.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">977</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeline">  /// The Status of the Assignment (Known or NoneOrPhi) is another</td>
    <td class="lineNumber">978</td>
    <td class="codeline">  /// The Status of the Assignment (Known or NoneOrPhi) is another</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeline">  /// join-semilattice. The partial order is:</td>
    <td class="lineNumber">979</td>
    <td class="codeline">  /// join-semilattice. The partial order is:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeline">  /// NoneOrPhi > Known {id_0, id_1, ...id_N}</td>
    <td class="lineNumber">980</td>
    <td class="codeline">  /// NoneOrPhi > Known {id_0, id_1, ...id_N}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">981</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeline">  /// i.e. for all values x and y where x != y:</td>
    <td class="lineNumber">982</td>
    <td class="codeline">  /// i.e. for all values x and y where x != y:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeline">  /// join(x, x) = x</td>
    <td class="lineNumber">983</td>
    <td class="codeline">  /// join(x, x) = x</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeline">  /// join(x, y) = NoneOrPhi</td>
    <td class="lineNumber">984</td>
    <td class="codeline">  /// join(x, y) = NoneOrPhi</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeline">  struct Assignment {</td>
    <td class="lineNumber">985</td>
    <td class="codeline">  struct Assignment {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeline">    enum S { Known, NoneOrPhi } Status;</td>
    <td class="lineNumber">986</td>
    <td class="codeline">    enum S { Known, NoneOrPhi } Status;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeline">    /// ID of the assignment. nullptr if Status is not Known.</td>
    <td class="lineNumber">987</td>
    <td class="codeline">    /// ID of the assignment. nullptr if Status is not Known.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeline">    DIAssignID *ID;</td>
    <td class="lineNumber">988</td>
    <td class="codeline">    DIAssignID *ID;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeline">    /// The dbg.assign that marks this dbg-def. Mem-defs don't use this field.</td>
    <td class="lineNumber">989</td>
    <td class="codeline">    /// The dbg.assign that marks this dbg-def. Mem-defs don't use this field.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeline">    /// May be nullptr.</td>
    <td class="lineNumber">990</td>
    <td class="codeline">    /// May be nullptr.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeline">    DbgAssignIntrinsic *Source;</td>
    <td class="lineNumber">991</td>
    <td class="codeline">    DbgAssignIntrinsic *Source;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeline"></td>
    <td class="lineNumber">992</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeline">    bool isSameSourceAssignment(const Assignment &Other) const {</td>
    <td class="lineNumber">993</td>
    <td class="codeline">    bool isSameSourceAssignment(const Assignment &Other) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeline">      // Don't include Source in the equality check. Assignments are</td>
    <td class="lineNumber">994</td>
    <td class="codeline">      // Don't include Source in the equality check. Assignments are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeline">      // defined by their ID, not debug intrinsic(s).</td>
    <td class="lineNumber">995</td>
    <td class="codeline">      // defined by their ID, not debug intrinsic(s).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeline">      return std::tie(Status, ID) == std::tie(Other.Status, Other.ID);</td>
    <td class="lineNumber">996</td>
    <td class="codeline">      return std::tie(Status, ID) == std::tie(Other.Status, Other.ID);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">997</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeline">    void dump(raw_ostream &OS) {</td>
    <td class="lineNumber">998</td>
    <td class="codeline">    void dump(raw_ostream &OS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeline">      static const char *LUT[] = {"Known", "NoneOrPhi"};</td>
    <td class="lineNumber">999</td>
    <td class="codeline">      static const char *LUT[] = {"Known", "NoneOrPhi"};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeline">      OS << LUT[Status] << "(id=";</td>
    <td class="lineNumber">1000</td>
    <td class="codeline">      OS << LUT[Status] << "(id=";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeline">      if (ID)</td>
    <td class="lineNumber">1001</td>
    <td class="codeline">      if (ID)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeline">        OS << ID;</td>
    <td class="lineNumber">1002</td>
    <td class="codeline">        OS << ID;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeline">      else</td>
    <td class="lineNumber">1003</td>
    <td class="codeline">      else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeline">        OS << "null";</td>
    <td class="lineNumber">1004</td>
    <td class="codeline">        OS << "null";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeline">      OS << ", s=";</td>
    <td class="lineNumber">1005</td>
    <td class="codeline">      OS << ", s=";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeline">      if (Source)</td>
    <td class="lineNumber">1006</td>
    <td class="codeline">      if (Source)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeline">        OS << *Source;</td>
    <td class="lineNumber">1007</td>
    <td class="codeline">        OS << *Source;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeline">      else</td>
    <td class="lineNumber">1008</td>
    <td class="codeline">      else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeline">        OS << "null";</td>
    <td class="lineNumber">1009</td>
    <td class="codeline">        OS << "null";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeline">      OS << ")";</td>
    <td class="lineNumber">1010</td>
    <td class="codeline">      OS << ")";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1011</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeline"></td>
    <td class="lineNumber">1012</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeline">    static Assignment make(DIAssignID *ID, DbgAssignIntrinsic *Source) {</td>
    <td class="lineNumber">1013</td>
    <td class="codeline">    static Assignment make(DIAssignID *ID, DbgAssignIntrinsic *Source) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeline">      return Assignment(Known, ID, Source);</td>
    <td class="lineNumber">1014</td>
    <td class="codeline">      return Assignment(Known, ID, Source);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1015</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeline">    static Assignment makeFromMemDef(DIAssignID *ID) {</td>
    <td class="lineNumber">1016</td>
    <td class="codeline">    static Assignment makeFromMemDef(DIAssignID *ID) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeline">      return Assignment(Known, ID, nullptr);</td>
    <td class="lineNumber">1017</td>
    <td class="codeline">      return Assignment(Known, ID, nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1018</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeline">    static Assignment makeNoneOrPhi() {</td>
    <td class="lineNumber">1019</td>
    <td class="codeline">    static Assignment makeNoneOrPhi() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeline">      return Assignment(NoneOrPhi, nullptr, nullptr);</td>
    <td class="lineNumber">1020</td>
    <td class="codeline">      return Assignment(NoneOrPhi, nullptr, nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1021</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeline">    // Again, need a Top value?</td>
    <td class="lineNumber">1022</td>
    <td class="codeline">    // Again, need a Top value?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeline">    Assignment()</td>
    <td class="lineNumber">1023</td>
    <td class="codeline">    Assignment()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeline">        : Status(NoneOrPhi), ID(nullptr), Source(nullptr) {</td>
    <td class="lineNumber">1024</td>
    <td class="codeline">        : Status(NoneOrPhi), ID(nullptr), Source(nullptr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeline">    } // Can we delete this?</td>
    <td class="lineNumber">1025</td>
    <td class="codeline">    } // Can we delete this?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeline">    Assignment(S Status, DIAssignID *ID, DbgAssignIntrinsic *Source)</td>
    <td class="lineNumber">1026</td>
    <td class="codeline">    Assignment(S Status, DIAssignID *ID, DbgAssignIntrinsic *Source)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeline">        : Status(Status), ID(ID), Source(Source) {</td>
    <td class="lineNumber">1027</td>
    <td class="codeline">        : Status(Status), ID(ID), Source(Source) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeline">      // If the Status is Known then we expect there to be an assignment ID.</td>
    <td class="lineNumber">1028</td>
    <td class="codeline">      // If the Status is Known then we expect there to be an assignment ID.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeline">      assert(Status == NoneOrPhi || ID);</td>
    <td class="lineNumber">1029</td>
    <td class="codeline">      assert(Status == NoneOrPhi || ID);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1030</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1031</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeline"></td>
    <td class="lineNumber">1032</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeline">  using AssignmentMap = SmallVector<Assignment>;</td>
    <td class="lineNumber">1033</td>
    <td class="codeline">  using AssignmentMap = SmallVector<Assignment>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeline">  using LocMap = SmallVector<LocKind>;</td>
    <td class="lineNumber">1034</td>
    <td class="codeline">  using LocMap = SmallVector<LocKind>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeline">  using OverlapMap = DenseMap<VariableID, SmallVector<VariableID>>;</td>
    <td class="lineNumber">1035</td>
    <td class="codeline">  using OverlapMap = DenseMap<VariableID, SmallVector<VariableID>>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeline">  using UntaggedStoreAssignmentMap =</td>
    <td class="lineNumber">1036</td>
    <td class="codeline">  using UntaggedStoreAssignmentMap =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeline">      DenseMap<const Instruction *,</td>
    <td class="lineNumber">1037</td>
    <td class="codeline">      DenseMap<const Instruction *,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeline">               SmallVector<std::pair<VariableID, at::AssignmentInfo>>>;</td>
    <td class="lineNumber">1038</td>
    <td class="codeline">               SmallVector<std::pair<VariableID, at::AssignmentInfo>>>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeline"></td>
    <td class="lineNumber">1039</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">1040</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeline">  /// The highest numbered VariableID for partially promoted variables plus 1,</td>
    <td class="lineNumber">1041</td>
    <td class="codeline">  /// The highest numbered VariableID for partially promoted variables plus 1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeline">  /// the values for which start at 1.</td>
    <td class="lineNumber">1042</td>
    <td class="codeline">  /// the values for which start at 1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeline">  unsigned TrackedVariablesVectorSize = 0;</td>
    <td class="lineNumber">1043</td>
    <td class="codeline">  unsigned TrackedVariablesVectorSize = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeline">  /// Map a variable to the set of variables that it fully contains.</td>
    <td class="lineNumber">1044</td>
    <td class="codeline">  /// Map a variable to the set of variables that it fully contains.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeline">  OverlapMap VarContains;</td>
    <td class="lineNumber">1045</td>
    <td class="codeline">  OverlapMap VarContains;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeline">  /// Map untagged stores to the variable fragments they assign to. Used by</td>
    <td class="lineNumber">1046</td>
    <td class="codeline">  /// Map untagged stores to the variable fragments they assign to. Used by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeline">  /// processUntaggedInstruction.</td>
    <td class="lineNumber">1047</td>
    <td class="codeline">  /// processUntaggedInstruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeline">  UntaggedStoreAssignmentMap UntaggedStoreVars;</td>
    <td class="lineNumber">1048</td>
    <td class="codeline">  UntaggedStoreAssignmentMap UntaggedStoreVars;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeline"></td>
    <td class="lineNumber">1049</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeline">  // Machinery to defer inserting dbg.values.</td>
    <td class="lineNumber">1050</td>
    <td class="codeline">  // Machinery to defer inserting dbg.values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeline">  using InsertMap = MapVector<Instruction *, SmallVector<VarLocInfo>>;</td>
    <td class="lineNumber">1051</td>
    <td class="codeline">  using InsertMap = MapVector<Instruction *, SmallVector<VarLocInfo>>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeline">  InsertMap InsertBeforeMap;</td>
    <td class="lineNumber">1052</td>
    <td class="codeline">  InsertMap InsertBeforeMap;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeline">  /// Clear the location definitions currently cached for insertion after /p</td>
    <td class="lineNumber">1053</td>
    <td class="codeline">  /// Clear the location definitions currently cached for insertion after /p</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeline">  /// After.</td>
    <td class="lineNumber">1054</td>
    <td class="codeline">  /// After.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeline">  void resetInsertionPoint(Instruction &After);</td>
    <td class="lineNumber">1055</td>
    <td class="codeline">  void resetInsertionPoint(Instruction &After);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeline">  void emitDbgValue(LocKind Kind, const DbgVariableIntrinsic *Source,</td>
    <td class="lineNumber">1056</td>
    <td class="codeline">  void emitDbgValue(LocKind Kind, const DbgVariableIntrinsic *Source,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeline">                    Instruction *After);</td>
    <td class="lineNumber">1057</td>
    <td class="codeline">                    Instruction *After);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeline"></td>
    <td class="lineNumber">1058</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeline">  static bool mapsAreEqual(const BitVector &Mask, const AssignmentMap &A,</td>
    <td class="lineNumber">1059</td>
    <td class="codeline">  static bool mapsAreEqual(const BitVector &Mask, const AssignmentMap &A,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeline">                           const AssignmentMap &B) {</td>
    <td class="lineNumber">1060</td>
    <td class="codeline">                           const AssignmentMap &B) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeline">    return llvm::all_of(Mask.set_bits(), [&](unsigned VarID) {</td>
    <td class="lineNumber">1061</td>
    <td class="codeline">    return llvm::all_of(Mask.set_bits(), [&](unsigned VarID) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeline">      return A[VarID].isSameSourceAssignment(B[VarID]);</td>
    <td class="lineNumber">1062</td>
    <td class="codeline">      return A[VarID].isSameSourceAssignment(B[VarID]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeline">    });</td>
    <td class="lineNumber">1063</td>
    <td class="codeline">    });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1064</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeline"></td>
    <td class="lineNumber">1065</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeline">  /// Represents the stack and debug assignments in a block. Used to describe</td>
    <td class="lineNumber">1066</td>
    <td class="codeline">  /// Represents the stack and debug assignments in a block. Used to describe</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeline">  /// the live-in and live-out values for blocks, as well as the "current"</td>
    <td class="lineNumber">1067</td>
    <td class="codeline">  /// the live-in and live-out values for blocks, as well as the "current"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeline">  /// value as we process each instruction in a block.</td>
    <td class="lineNumber">1068</td>
    <td class="codeline">  /// value as we process each instruction in a block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeline">  struct BlockInfo {</td>
    <td class="lineNumber">1069</td>
    <td class="codeline">  struct BlockInfo {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeline">    /// The set of variables (VariableID) being tracked in this block.</td>
    <td class="lineNumber">1070</td>
    <td class="codeline">    /// The set of variables (VariableID) being tracked in this block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeline">    BitVector VariableIDsInBlock;</td>
    <td class="lineNumber">1071</td>
    <td class="codeline">    BitVector VariableIDsInBlock;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeline">    /// Dominating assignment to memory for each variable, indexed by</td>
    <td class="lineNumber">1072</td>
    <td class="codeline">    /// Dominating assignment to memory for each variable, indexed by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeline">    /// VariableID.</td>
    <td class="lineNumber">1073</td>
    <td class="codeline">    /// VariableID.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeline">    AssignmentMap StackHomeValue;</td>
    <td class="lineNumber">1074</td>
    <td class="codeline">    AssignmentMap StackHomeValue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeline">    /// Dominating assignemnt to each variable, indexed by VariableID.</td>
    <td class="lineNumber">1075</td>
    <td class="codeline">    /// Dominating assignemnt to each variable, indexed by VariableID.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeline">    AssignmentMap DebugValue;</td>
    <td class="lineNumber">1076</td>
    <td class="codeline">    AssignmentMap DebugValue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeline">    /// Location kind for each variable. LiveLoc indicates whether the</td>
    <td class="lineNumber">1077</td>
    <td class="codeline">    /// Location kind for each variable. LiveLoc indicates whether the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeline">    /// dominating assignment in StackHomeValue (LocKind::Mem), DebugValue</td>
    <td class="lineNumber">1078</td>
    <td class="codeline">    /// dominating assignment in StackHomeValue (LocKind::Mem), DebugValue</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeline">    /// (LocKind::Val), or neither (LocKind::None) is valid, in that order of</td>
    <td class="lineNumber">1079</td>
    <td class="codeline">    /// (LocKind::Val), or neither (LocKind::None) is valid, in that order of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeline">    /// preference. This cannot be derived by inspecting DebugValue and</td>
    <td class="lineNumber">1080</td>
    <td class="codeline">    /// preference. This cannot be derived by inspecting DebugValue and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeline">    /// StackHomeValue due to the fact that there's no distinction in</td>
    <td class="lineNumber">1081</td>
    <td class="codeline">    /// StackHomeValue due to the fact that there's no distinction in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeline">    /// Assignment (the class) between whether an assignment is unknown or a</td>
    <td class="lineNumber">1082</td>
    <td class="codeline">    /// Assignment (the class) between whether an assignment is unknown or a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeline">    /// merge of multiple assignments (both are Status::NoneOrPhi). In other</td>
    <td class="lineNumber">1083</td>
    <td class="codeline">    /// merge of multiple assignments (both are Status::NoneOrPhi). In other</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeline">    /// words, the memory location may well be valid while both DebugValue and</td>
    <td class="lineNumber">1084</td>
    <td class="codeline">    /// words, the memory location may well be valid while both DebugValue and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeline">    /// StackHomeValue contain Assignments that have a Status of NoneOrPhi.</td>
    <td class="lineNumber">1085</td>
    <td class="codeline">    /// StackHomeValue contain Assignments that have a Status of NoneOrPhi.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeline">    /// Indexed by VariableID.</td>
    <td class="lineNumber">1086</td>
    <td class="codeline">    /// Indexed by VariableID.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeline">    LocMap LiveLoc;</td>
    <td class="lineNumber">1087</td>
    <td class="codeline">    LocMap LiveLoc;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeline"></td>
    <td class="lineNumber">1088</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeline">  public:</td>
    <td class="lineNumber">1089</td>
    <td class="codeline">  public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeline">    enum AssignmentKind { Stack, Debug };</td>
    <td class="lineNumber">1090</td>
    <td class="codeline">    enum AssignmentKind { Stack, Debug };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeline">    const AssignmentMap &getAssignmentMap(AssignmentKind Kind) const {</td>
    <td class="lineNumber">1091</td>
    <td class="codeline">    const AssignmentMap &getAssignmentMap(AssignmentKind Kind) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeline">      switch (Kind) {</td>
    <td class="lineNumber">1092</td>
    <td class="codeline">      switch (Kind) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeline">      case Stack:</td>
    <td class="lineNumber">1093</td>
    <td class="codeline">      case Stack:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeline">        return StackHomeValue;</td>
    <td class="lineNumber">1094</td>
    <td class="codeline">        return StackHomeValue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeline">      case Debug:</td>
    <td class="lineNumber">1095</td>
    <td class="codeline">      case Debug:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeline">        return DebugValue;</td>
    <td class="lineNumber">1096</td>
    <td class="codeline">        return DebugValue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1097</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeline">      llvm_unreachable("Unknown AssignmentKind");</td>
    <td class="lineNumber">1098</td>
    <td class="codeline">      llvm_unreachable("Unknown AssignmentKind");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1099</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeline">    AssignmentMap &getAssignmentMap(AssignmentKind Kind) {</td>
    <td class="lineNumber">1100</td>
    <td class="codeline">    AssignmentMap &getAssignmentMap(AssignmentKind Kind) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeline">      return const_cast<AssignmentMap &>(</td>
    <td class="lineNumber">1101</td>
    <td class="codeline">      return const_cast<AssignmentMap &>(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeline">          const_cast<const BlockInfo *>(this)->getAssignmentMap(Kind));</td>
    <td class="lineNumber">1102</td>
    <td class="codeline">          const_cast<const BlockInfo *>(this)->getAssignmentMap(Kind));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1103</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeline"></td>
    <td class="lineNumber">1104</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeline">    bool isVariableTracked(VariableID Var) const {</td>
    <td class="lineNumber">1105</td>
    <td class="codeline">    bool isVariableTracked(VariableID Var) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeline">      return VariableIDsInBlock[static_cast<unsigned>(Var)];</td>
    <td class="lineNumber">1106</td>
    <td class="codeline">      return VariableIDsInBlock[static_cast<unsigned>(Var)];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1107</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeline"></td>
    <td class="lineNumber">1108</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeline">    const Assignment &getAssignment(AssignmentKind Kind, VariableID Var) const {</td>
    <td class="lineNumber">1109</td>
    <td class="codeline">    const Assignment &getAssignment(AssignmentKind Kind, VariableID Var) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeline">      assert(isVariableTracked(Var) && "Var not tracked in block");</td>
    <td class="lineNumber">1110</td>
    <td class="codeline">      assert(isVariableTracked(Var) && "Var not tracked in block");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeline">      return getAssignmentMap(Kind)[static_cast<unsigned>(Var)];</td>
    <td class="lineNumber">1111</td>
    <td class="codeline">      return getAssignmentMap(Kind)[static_cast<unsigned>(Var)];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1112</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeline"></td>
    <td class="lineNumber">1113</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeline">    LocKind getLocKind(VariableID Var) const {</td>
    <td class="lineNumber">1114</td>
    <td class="codeline">    LocKind getLocKind(VariableID Var) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeline">      assert(isVariableTracked(Var) && "Var not tracked in block");</td>
    <td class="lineNumber">1115</td>
    <td class="codeline">      assert(isVariableTracked(Var) && "Var not tracked in block");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeline">      return LiveLoc[static_cast<unsigned>(Var)];</td>
    <td class="lineNumber">1116</td>
    <td class="codeline">      return LiveLoc[static_cast<unsigned>(Var)];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1117</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeline"></td>
    <td class="lineNumber">1118</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeline">    /// Set LocKind for \p Var only: does not set LocKind for VariableIDs of</td>
    <td class="lineNumber">1119</td>
    <td class="codeline">    /// Set LocKind for \p Var only: does not set LocKind for VariableIDs of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeline">    /// fragments contained win \p Var.</td>
    <td class="lineNumber">1120</td>
    <td class="codeline">    /// fragments contained win \p Var.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeline">    void setLocKind(VariableID Var, LocKind K) {</td>
    <td class="lineNumber">1121</td>
    <td class="codeline">    void setLocKind(VariableID Var, LocKind K) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeline">      VariableIDsInBlock.set(static_cast<unsigned>(Var));</td>
    <td class="lineNumber">1122</td>
    <td class="codeline">      VariableIDsInBlock.set(static_cast<unsigned>(Var));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeline">      LiveLoc[static_cast<unsigned>(Var)] = K;</td>
    <td class="lineNumber">1123</td>
    <td class="codeline">      LiveLoc[static_cast<unsigned>(Var)] = K;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1124</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeline"></td>
    <td class="lineNumber">1125</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeline">    /// Set the assignment in the \p Kind assignment map for \p Var only: does</td>
    <td class="lineNumber">1126</td>
    <td class="codeline">    /// Set the assignment in the \p Kind assignment map for \p Var only: does</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeline">    /// not set the assignment for VariableIDs of fragments contained win \p</td>
    <td class="lineNumber">1127</td>
    <td class="codeline">    /// not set the assignment for VariableIDs of fragments contained win \p</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeline">    /// Var.</td>
    <td class="lineNumber">1128</td>
    <td class="codeline">    /// Var.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeline">    void setAssignment(AssignmentKind Kind, VariableID Var,</td>
    <td class="lineNumber">1129</td>
    <td class="codeline">    void setAssignment(AssignmentKind Kind, VariableID Var,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeline">                       const Assignment &AV) {</td>
    <td class="lineNumber">1130</td>
    <td class="codeline">                       const Assignment &AV) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeline">      VariableIDsInBlock.set(static_cast<unsigned>(Var));</td>
    <td class="lineNumber">1131</td>
    <td class="codeline">      VariableIDsInBlock.set(static_cast<unsigned>(Var));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeline">      getAssignmentMap(Kind)[static_cast<unsigned>(Var)] = AV;</td>
    <td class="lineNumber">1132</td>
    <td class="codeline">      getAssignmentMap(Kind)[static_cast<unsigned>(Var)] = AV;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1133</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeline"></td>
    <td class="lineNumber">1134</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeline">    /// Return true if there is an assignment matching \p AV in the \p Kind</td>
    <td class="lineNumber">1135</td>
    <td class="codeline">    /// Return true if there is an assignment matching \p AV in the \p Kind</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeline">    /// assignment map. Does consider assignments for VariableIDs of fragments</td>
    <td class="lineNumber">1136</td>
    <td class="codeline">    /// assignment map. Does consider assignments for VariableIDs of fragments</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeline">    /// contained win \p Var.</td>
    <td class="lineNumber">1137</td>
    <td class="codeline">    /// contained win \p Var.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeline">    bool hasAssignment(AssignmentKind Kind, VariableID Var,</td>
    <td class="lineNumber">1138</td>
    <td class="codeline">    bool hasAssignment(AssignmentKind Kind, VariableID Var,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeline">                       const Assignment &AV) const {</td>
    <td class="lineNumber">1139</td>
    <td class="codeline">                       const Assignment &AV) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeline">      if (!isVariableTracked(Var))</td>
    <td class="lineNumber">1140</td>
    <td class="codeline">      if (!isVariableTracked(Var))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeline">        return false;</td>
    <td class="lineNumber">1141</td>
    <td class="codeline">        return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeline">      return AV.isSameSourceAssignment(getAssignment(Kind, Var));</td>
    <td class="lineNumber">1142</td>
    <td class="codeline">      return AV.isSameSourceAssignment(getAssignment(Kind, Var));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1143</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeline"></td>
    <td class="lineNumber">1144</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeline">    /// Compare every element in each map to determine structural equality</td>
    <td class="lineNumber">1145</td>
    <td class="codeline">    /// Compare every element in each map to determine structural equality</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeline">    /// (slow).</td>
    <td class="lineNumber">1146</td>
    <td class="codeline">    /// (slow).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeline">    bool operator==(const BlockInfo &Other) const {</td>
    <td class="lineNumber">1147</td>
    <td class="codeline">    bool operator==(const BlockInfo &Other) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeline">      return VariableIDsInBlock == Other.VariableIDsInBlock &&</td>
    <td class="lineNumber">1148</td>
    <td class="codeline">      return VariableIDsInBlock == Other.VariableIDsInBlock &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeline">             LiveLoc == Other.LiveLoc &&</td>
    <td class="lineNumber">1149</td>
    <td class="codeline">             LiveLoc == Other.LiveLoc &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeline">             mapsAreEqual(VariableIDsInBlock, StackHomeValue,</td>
    <td class="lineNumber">1150</td>
    <td class="codeline">             mapsAreEqual(VariableIDsInBlock, StackHomeValue,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeline">                          Other.StackHomeValue) &&</td>
    <td class="lineNumber">1151</td>
    <td class="codeline">                          Other.StackHomeValue) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeline">             mapsAreEqual(VariableIDsInBlock, DebugValue, Other.DebugValue);</td>
    <td class="lineNumber">1152</td>
    <td class="codeline">             mapsAreEqual(VariableIDsInBlock, DebugValue, Other.DebugValue);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1153</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeline">    bool operator!=(const BlockInfo &Other) const { return !(*this == Other); }</td>
    <td class="lineNumber">1154</td>
    <td class="codeline">    bool operator!=(const BlockInfo &Other) const { return !(*this == Other); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeline">    bool isValid() {</td>
    <td class="lineNumber">1155</td>
    <td class="codeline">    bool isValid() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeline">      return LiveLoc.size() == DebugValue.size() &&</td>
    <td class="lineNumber">1156</td>
    <td class="codeline">      return LiveLoc.size() == DebugValue.size() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeline">             LiveLoc.size() == StackHomeValue.size();</td>
    <td class="lineNumber">1157</td>
    <td class="codeline">             LiveLoc.size() == StackHomeValue.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1158</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeline"></td>
    <td class="lineNumber">1159</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeline">    /// Clear everything and initialise with ⊤-values for all variables.</td>
    <td class="lineNumber">1160</td>
    <td class="codeline">    /// Clear everything and initialise with ⊤-values for all variables.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeline">    void init(int NumVars) {</td>
    <td class="lineNumber">1161</td>
    <td class="codeline">    void init(int NumVars) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeline">      StackHomeValue.clear();</td>
    <td class="lineNumber">1162</td>
    <td class="codeline">      StackHomeValue.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeline">      DebugValue.clear();</td>
    <td class="lineNumber">1163</td>
    <td class="codeline">      DebugValue.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeline">      LiveLoc.clear();</td>
    <td class="lineNumber">1164</td>
    <td class="codeline">      LiveLoc.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeline">      VariableIDsInBlock = BitVector(NumVars);</td>
    <td class="lineNumber">1165</td>
    <td class="codeline">      VariableIDsInBlock = BitVector(NumVars);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeline">      StackHomeValue.insert(StackHomeValue.begin(), NumVars,</td>
    <td class="lineNumber">1166</td>
    <td class="codeline">      StackHomeValue.insert(StackHomeValue.begin(), NumVars,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeline">                            Assignment::makeNoneOrPhi());</td>
    <td class="lineNumber">1167</td>
    <td class="codeline">                            Assignment::makeNoneOrPhi());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeline">      DebugValue.insert(DebugValue.begin(), NumVars,</td>
    <td class="lineNumber">1168</td>
    <td class="codeline">      DebugValue.insert(DebugValue.begin(), NumVars,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeline">                        Assignment::makeNoneOrPhi());</td>
    <td class="lineNumber">1169</td>
    <td class="codeline">                        Assignment::makeNoneOrPhi());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeline">      LiveLoc.insert(LiveLoc.begin(), NumVars, LocKind::None);</td>
    <td class="lineNumber">1170</td>
    <td class="codeline">      LiveLoc.insert(LiveLoc.begin(), NumVars, LocKind::None);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1171</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeline"></td>
    <td class="lineNumber">1172</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeline">    /// Helper for join.</td>
    <td class="lineNumber">1173</td>
    <td class="codeline">    /// Helper for join.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeline">    template <typename ElmtType, typename FnInputType></td>
    <td class="lineNumber">1174</td>
    <td class="codeline">    template <typename ElmtType, typename FnInputType></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeline">    static void joinElmt(int Index, SmallVector<ElmtType> &Target,</td>
    <td class="lineNumber">1175</td>
    <td class="codeline">    static void joinElmt(int Index, SmallVector<ElmtType> &Target,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeline">                         const SmallVector<ElmtType> &A,</td>
    <td class="lineNumber">1176</td>
    <td class="codeline">                         const SmallVector<ElmtType> &A,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeline">                         const SmallVector<ElmtType> &B,</td>
    <td class="lineNumber">1177</td>
    <td class="codeline">                         const SmallVector<ElmtType> &B,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeline">                         ElmtType (*Fn)(FnInputType, FnInputType)) {</td>
    <td class="lineNumber">1178</td>
    <td class="codeline">                         ElmtType (*Fn)(FnInputType, FnInputType)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeline">      Target[Index] = Fn(A[Index], B[Index]);</td>
    <td class="lineNumber">1179</td>
    <td class="codeline">      Target[Index] = Fn(A[Index], B[Index]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1180</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeline"></td>
    <td class="lineNumber">1181</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeline">    /// See comment for AssignmentTrackingLowering::joinBlockInfo.</td>
    <td class="lineNumber">1182</td>
    <td class="codeline">    /// See comment for AssignmentTrackingLowering::joinBlockInfo.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeline">    static BlockInfo join(const BlockInfo &A, const BlockInfo &B, int NumVars) {</td>
    <td class="lineNumber">1183</td>
    <td class="codeline">    static BlockInfo join(const BlockInfo &A, const BlockInfo &B, int NumVars) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeline">      // Join A and B.</td>
    <td class="lineNumber">1184</td>
    <td class="codeline">      // Join A and B.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeline">      //</td>
    <td class="lineNumber">1185</td>
    <td class="codeline">      //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeline">      // Intersect = join(a, b) for a in A, b in B where Var(a) == Var(b)</td>
    <td class="lineNumber">1186</td>
    <td class="codeline">      // Intersect = join(a, b) for a in A, b in B where Var(a) == Var(b)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeline">      // Difference = join(x, ⊤) for x where Var(x) is in A xor B</td>
    <td class="lineNumber">1187</td>
    <td class="codeline">      // Difference = join(x, ⊤) for x where Var(x) is in A xor B</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeline">      // Join = Intersect ∪ Difference</td>
    <td class="lineNumber">1188</td>
    <td class="codeline">      // Join = Intersect ∪ Difference</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeline">      //</td>
    <td class="lineNumber">1189</td>
    <td class="codeline">      //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeline">      // This is achieved by performing a join on elements from A and B with</td>
    <td class="lineNumber">1190</td>
    <td class="codeline">      // This is achieved by performing a join on elements from A and B with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeline">      // variables common to both A and B (join elements indexed by var</td>
    <td class="lineNumber">1191</td>
    <td class="codeline">      // variables common to both A and B (join elements indexed by var</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeline">      // intersect), then adding ⊤-value elements for vars in A xor B. The</td>
    <td class="lineNumber">1192</td>
    <td class="codeline">      // intersect), then adding ⊤-value elements for vars in A xor B. The</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeline">      // latter part is equivalent to performing join on elements with variables</td>
    <td class="lineNumber">1193</td>
    <td class="codeline">      // latter part is equivalent to performing join on elements with variables</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeline">      // in A xor B with the ⊤-value for the map element since join(x, ⊤) = ⊤.</td>
    <td class="lineNumber">1194</td>
    <td class="codeline">      // in A xor B with the ⊤-value for the map element since join(x, ⊤) = ⊤.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeline">      // BlockInfo::init initializes all variable entries to the ⊤ value so we</td>
    <td class="lineNumber">1195</td>
    <td class="codeline">      // BlockInfo::init initializes all variable entries to the ⊤ value so we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeline">      // don't need to explicitly perform that step as Join.VariableIDsInBlock</td>
    <td class="lineNumber">1196</td>
    <td class="codeline">      // don't need to explicitly perform that step as Join.VariableIDsInBlock</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeline">      // is set to the union of the variables in A and B at the end of this</td>
    <td class="lineNumber">1197</td>
    <td class="codeline">      // is set to the union of the variables in A and B at the end of this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeline">      // function.</td>
    <td class="lineNumber">1198</td>
    <td class="codeline">      // function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeline">      BlockInfo Join;</td>
    <td class="lineNumber">1199</td>
    <td class="codeline">      BlockInfo Join;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeline">      Join.init(NumVars);</td>
    <td class="lineNumber">1200</td>
    <td class="codeline">      Join.init(NumVars);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeline"></td>
    <td class="lineNumber">1201</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeline">      BitVector Intersect = A.VariableIDsInBlock;</td>
    <td class="lineNumber">1202</td>
    <td class="codeline">      BitVector Intersect = A.VariableIDsInBlock;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeline">      Intersect &= B.VariableIDsInBlock;</td>
    <td class="lineNumber">1203</td>
    <td class="codeline">      Intersect &= B.VariableIDsInBlock;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeline"></td>
    <td class="lineNumber">1204</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeline">      for (auto VarID : Intersect.set_bits()) {</td>
    <td class="lineNumber">1205</td>
    <td class="codeline">      for (auto VarID : Intersect.set_bits()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeline">        joinElmt(VarID, Join.LiveLoc, A.LiveLoc, B.LiveLoc, joinKind);</td>
    <td class="lineNumber">1206</td>
    <td class="codeline">        joinElmt(VarID, Join.LiveLoc, A.LiveLoc, B.LiveLoc, joinKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeline">        joinElmt(VarID, Join.DebugValue, A.DebugValue, B.DebugValue,</td>
    <td class="lineNumber">1207</td>
    <td class="codeline">        joinElmt(VarID, Join.DebugValue, A.DebugValue, B.DebugValue,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeline">                 joinAssignment);</td>
    <td class="lineNumber">1208</td>
    <td class="codeline">                 joinAssignment);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeline">        joinElmt(VarID, Join.StackHomeValue, A.StackHomeValue, B.StackHomeValue,</td>
    <td class="lineNumber">1209</td>
    <td class="codeline">        joinElmt(VarID, Join.StackHomeValue, A.StackHomeValue, B.StackHomeValue,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeline">                 joinAssignment);</td>
    <td class="lineNumber">1210</td>
    <td class="codeline">                 joinAssignment);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1211</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeline"></td>
    <td class="lineNumber">1212</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeline">      Join.VariableIDsInBlock = A.VariableIDsInBlock;</td>
    <td class="lineNumber">1213</td>
    <td class="codeline">      Join.VariableIDsInBlock = A.VariableIDsInBlock;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeline">      Join.VariableIDsInBlock |= B.VariableIDsInBlock;</td>
    <td class="lineNumber">1214</td>
    <td class="codeline">      Join.VariableIDsInBlock |= B.VariableIDsInBlock;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeline">      assert(Join.isValid());</td>
    <td class="lineNumber">1215</td>
    <td class="codeline">      assert(Join.isValid());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeline">      return Join;</td>
    <td class="lineNumber">1216</td>
    <td class="codeline">      return Join;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1217</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1218</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeline"></td>
    <td class="lineNumber">1219</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeline">  Function &Fn;</td>
    <td class="lineNumber">1220</td>
    <td class="codeline">  Function &Fn;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeline">  const DataLayout &Layout;</td>
    <td class="lineNumber">1221</td>
    <td class="codeline">  const DataLayout &Layout;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeline">  const DenseSet<DebugAggregate> *VarsWithStackSlot;</td>
    <td class="lineNumber">1222</td>
    <td class="codeline">  const DenseSet<DebugAggregate> *VarsWithStackSlot;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeline">  FunctionVarLocsBuilder *FnVarLocs;</td>
    <td class="lineNumber">1223</td>
    <td class="codeline">  FunctionVarLocsBuilder *FnVarLocs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeline">  DenseMap<const BasicBlock *, BlockInfo> LiveIn;</td>
    <td class="lineNumber">1224</td>
    <td class="codeline">  DenseMap<const BasicBlock *, BlockInfo> LiveIn;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeline">  DenseMap<const BasicBlock *, BlockInfo> LiveOut;</td>
    <td class="lineNumber">1225</td>
    <td class="codeline">  DenseMap<const BasicBlock *, BlockInfo> LiveOut;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeline"></td>
    <td class="lineNumber">1226</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeline">  /// Helper for process methods to track variables touched each frame.</td>
    <td class="lineNumber">1227</td>
    <td class="codeline">  /// Helper for process methods to track variables touched each frame.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeline">  DenseSet<VariableID> VarsTouchedThisFrame;</td>
    <td class="lineNumber">1228</td>
    <td class="codeline">  DenseSet<VariableID> VarsTouchedThisFrame;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeline"></td>
    <td class="lineNumber">1229</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeline">  /// The set of variables that sometimes are not located in their stack home.</td>
    <td class="lineNumber">1230</td>
    <td class="codeline">  /// The set of variables that sometimes are not located in their stack home.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeline">  DenseSet<DebugAggregate> NotAlwaysStackHomed;</td>
    <td class="lineNumber">1231</td>
    <td class="codeline">  DenseSet<DebugAggregate> NotAlwaysStackHomed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeline"></td>
    <td class="lineNumber">1232</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeline">  VariableID getVariableID(const DebugVariable &Var) {</td>
    <td class="lineNumber">1233</td>
    <td class="codeline">  VariableID getVariableID(const DebugVariable &Var) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeline">    return static_cast<VariableID>(FnVarLocs->insertVariable(Var));</td>
    <td class="lineNumber">1234</td>
    <td class="codeline">    return static_cast<VariableID>(FnVarLocs->insertVariable(Var));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1235</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeline"></td>
    <td class="lineNumber">1236</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeline">  /// Join the LiveOut values of preds that are contained in \p Visited into</td>
    <td class="lineNumber">1237</td>
    <td class="codeline">  /// Join the LiveOut values of preds that are contained in \p Visited into</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeline">  /// LiveIn[BB]. Return True if LiveIn[BB] has changed as a result. LiveIn[BB]</td>
    <td class="lineNumber">1238</td>
    <td class="codeline">  /// LiveIn[BB]. Return True if LiveIn[BB] has changed as a result. LiveIn[BB]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeline">  /// values monotonically increase. See the @link joinMethods join methods</td>
    <td class="lineNumber">1239</td>
    <td class="codeline">  /// values monotonically increase. See the @link joinMethods join methods</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeline">  /// @endlink documentation for more info.</td>
    <td class="lineNumber">1240</td>
    <td class="codeline">  /// @endlink documentation for more info.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeline">  bool join(const BasicBlock &BB, const SmallPtrSet<BasicBlock *, 16> &Visited);</td>
    <td class="lineNumber">1241</td>
    <td class="codeline">  bool join(const BasicBlock &BB, const SmallPtrSet<BasicBlock *, 16> &Visited);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeline">  ///@name joinMethods</td>
    <td class="lineNumber">1242</td>
    <td class="codeline">  ///@name joinMethods</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeline">  /// Functions that implement `join` (the least upper bound) for the</td>
    <td class="lineNumber">1243</td>
    <td class="codeline">  /// Functions that implement `join` (the least upper bound) for the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeline">  /// join-semilattice types used in the dataflow. There is an explicit bottom</td>
    <td class="lineNumber">1244</td>
    <td class="codeline">  /// join-semilattice types used in the dataflow. There is an explicit bottom</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeline">  /// value (⊥) for some types and and explicit top value (⊤) for all types.</td>
    <td class="lineNumber">1245</td>
    <td class="codeline">  /// value (⊥) for some types and and explicit top value (⊤) for all types.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeline">  /// By definition:</td>
    <td class="lineNumber">1246</td>
    <td class="codeline">  /// By definition:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1247</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeline">  ///     Join(A, B) >= A && Join(A, B) >= B</td>
    <td class="lineNumber">1248</td>
    <td class="codeline">  ///     Join(A, B) >= A && Join(A, B) >= B</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeline">  ///     Join(A, ⊥) = A</td>
    <td class="lineNumber">1249</td>
    <td class="codeline">  ///     Join(A, ⊥) = A</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeline">  ///     Join(A, ⊤) = ⊤</td>
    <td class="lineNumber">1250</td>
    <td class="codeline">  ///     Join(A, ⊤) = ⊤</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1251</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeline">  /// These invariants are important for monotonicity.</td>
    <td class="lineNumber">1252</td>
    <td class="codeline">  /// These invariants are important for monotonicity.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1253</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeline">  /// For the map-type functions, all unmapped keys in an empty map are</td>
    <td class="lineNumber">1254</td>
    <td class="codeline">  /// For the map-type functions, all unmapped keys in an empty map are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeline">  /// associated with a bottom value (⊥). This represents their values being</td>
    <td class="lineNumber">1255</td>
    <td class="codeline">  /// associated with a bottom value (⊥). This represents their values being</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeline">  /// unknown. Unmapped keys in non-empty maps (joining two maps with a key</td>
    <td class="lineNumber">1256</td>
    <td class="codeline">  /// unknown. Unmapped keys in non-empty maps (joining two maps with a key</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeline">  /// only present in one) represents either a variable going out of scope or</td>
    <td class="lineNumber">1257</td>
    <td class="codeline">  /// only present in one) represents either a variable going out of scope or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeline">  /// dropped debug info. It is assumed the key is associated with a top value</td>
    <td class="lineNumber">1258</td>
    <td class="codeline">  /// dropped debug info. It is assumed the key is associated with a top value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeline">  /// (⊤) in this case (unknown location / assignment).</td>
    <td class="lineNumber">1259</td>
    <td class="codeline">  /// (⊤) in this case (unknown location / assignment).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeline">  ///@{</td>
    <td class="lineNumber">1260</td>
    <td class="codeline">  ///@{</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeline">  static LocKind joinKind(LocKind A, LocKind B);</td>
    <td class="lineNumber">1261</td>
    <td class="codeline">  static LocKind joinKind(LocKind A, LocKind B);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeline">  static Assignment joinAssignment(const Assignment &A, const Assignment &B);</td>
    <td class="lineNumber">1262</td>
    <td class="codeline">  static Assignment joinAssignment(const Assignment &A, const Assignment &B);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeline">  BlockInfo joinBlockInfo(const BlockInfo &A, const BlockInfo &B);</td>
    <td class="lineNumber">1263</td>
    <td class="codeline">  BlockInfo joinBlockInfo(const BlockInfo &A, const BlockInfo &B);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeline">  ///@}</td>
    <td class="lineNumber">1264</td>
    <td class="codeline">  ///@}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeline"></td>
    <td class="lineNumber">1265</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeline">  /// Process the instructions in \p BB updating \p LiveSet along the way. \p</td>
    <td class="lineNumber">1266</td>
    <td class="codeline">  /// Process the instructions in \p BB updating \p LiveSet along the way. \p</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeline">  /// LiveSet must be initialized with the current live-in locations before</td>
    <td class="lineNumber">1267</td>
    <td class="codeline">  /// LiveSet must be initialized with the current live-in locations before</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeline">  /// calling this.</td>
    <td class="lineNumber">1268</td>
    <td class="codeline">  /// calling this.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeline">  void process(BasicBlock &BB, BlockInfo *LiveSet);</td>
    <td class="lineNumber">1269</td>
    <td class="codeline">  void process(BasicBlock &BB, BlockInfo *LiveSet);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeline">  ///@name processMethods</td>
    <td class="lineNumber">1270</td>
    <td class="codeline">  ///@name processMethods</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeline">  /// Methods to process instructions in order to update the LiveSet (current</td>
    <td class="lineNumber">1271</td>
    <td class="codeline">  /// Methods to process instructions in order to update the LiveSet (current</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeline">  /// location information).</td>
    <td class="lineNumber">1272</td>
    <td class="codeline">  /// location information).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeline">  ///@{</td>
    <td class="lineNumber">1273</td>
    <td class="codeline">  ///@{</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeline">  void processNonDbgInstruction(Instruction &I, BlockInfo *LiveSet);</td>
    <td class="lineNumber">1274</td>
    <td class="codeline">  void processNonDbgInstruction(Instruction &I, BlockInfo *LiveSet);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeline">  void processDbgInstruction(DbgInfoIntrinsic &I, BlockInfo *LiveSet);</td>
    <td class="lineNumber">1275</td>
    <td class="codeline">  void processDbgInstruction(DbgInfoIntrinsic &I, BlockInfo *LiveSet);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeline">  /// Update \p LiveSet after encountering an instruction with a DIAssignID</td>
    <td class="lineNumber">1276</td>
    <td class="codeline">  /// Update \p LiveSet after encountering an instruction with a DIAssignID</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeline">  /// attachment, \p I.</td>
    <td class="lineNumber">1277</td>
    <td class="codeline">  /// attachment, \p I.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeline">  void processTaggedInstruction(Instruction &I, BlockInfo *LiveSet);</td>
    <td class="lineNumber">1278</td>
    <td class="codeline">  void processTaggedInstruction(Instruction &I, BlockInfo *LiveSet);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeline">  /// Update \p LiveSet after encountering an instruciton without a DIAssignID</td>
    <td class="lineNumber">1279</td>
    <td class="codeline">  /// Update \p LiveSet after encountering an instruciton without a DIAssignID</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeline">  /// attachment, \p I.</td>
    <td class="lineNumber">1280</td>
    <td class="codeline">  /// attachment, \p I.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeline">  void processUntaggedInstruction(Instruction &I, BlockInfo *LiveSet);</td>
    <td class="lineNumber">1281</td>
    <td class="codeline">  void processUntaggedInstruction(Instruction &I, BlockInfo *LiveSet);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeline">  void processDbgAssign(DbgAssignIntrinsic &DAI, BlockInfo *LiveSet);</td>
    <td class="lineNumber">1282</td>
    <td class="codeline">  void processDbgAssign(DbgAssignIntrinsic &DAI, BlockInfo *LiveSet);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeline">  void processDbgValue(DbgValueInst &DVI, BlockInfo *LiveSet);</td>
    <td class="lineNumber">1283</td>
    <td class="codeline">  void processDbgValue(DbgValueInst &DVI, BlockInfo *LiveSet);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeline">  /// Add an assignment to memory for the variable /p Var.</td>
    <td class="lineNumber">1284</td>
    <td class="codeline">  /// Add an assignment to memory for the variable /p Var.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeline">  void addMemDef(BlockInfo *LiveSet, VariableID Var, const Assignment &AV);</td>
    <td class="lineNumber">1285</td>
    <td class="codeline">  void addMemDef(BlockInfo *LiveSet, VariableID Var, const Assignment &AV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeline">  /// Add an assignment to the variable /p Var.</td>
    <td class="lineNumber">1286</td>
    <td class="codeline">  /// Add an assignment to the variable /p Var.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeline">  void addDbgDef(BlockInfo *LiveSet, VariableID Var, const Assignment &AV);</td>
    <td class="lineNumber">1287</td>
    <td class="codeline">  void addDbgDef(BlockInfo *LiveSet, VariableID Var, const Assignment &AV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeline">  ///@}</td>
    <td class="lineNumber">1288</td>
    <td class="codeline">  ///@}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeline"></td>
    <td class="lineNumber">1289</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeline">  /// Set the LocKind for \p Var.</td>
    <td class="lineNumber">1290</td>
    <td class="codeline">  /// Set the LocKind for \p Var.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeline">  void setLocKind(BlockInfo *LiveSet, VariableID Var, LocKind K);</td>
    <td class="lineNumber">1291</td>
    <td class="codeline">  void setLocKind(BlockInfo *LiveSet, VariableID Var, LocKind K);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeline">  /// Get the live LocKind for a \p Var. Requires addMemDef or addDbgDef to</td>
    <td class="lineNumber">1292</td>
    <td class="codeline">  /// Get the live LocKind for a \p Var. Requires addMemDef or addDbgDef to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeline">  /// have been called for \p Var first.</td>
    <td class="lineNumber">1293</td>
    <td class="codeline">  /// have been called for \p Var first.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeline">  LocKind getLocKind(BlockInfo *LiveSet, VariableID Var);</td>
    <td class="lineNumber">1294</td>
    <td class="codeline">  LocKind getLocKind(BlockInfo *LiveSet, VariableID Var);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeline">  /// Return true if \p Var has an assignment in \p M matching \p AV.</td>
    <td class="lineNumber">1295</td>
    <td class="codeline">  /// Return true if \p Var has an assignment in \p M matching \p AV.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeline">  bool hasVarWithAssignment(BlockInfo *LiveSet, BlockInfo::AssignmentKind Kind,</td>
    <td class="lineNumber">1296</td>
    <td class="codeline">  bool hasVarWithAssignment(BlockInfo *LiveSet, BlockInfo::AssignmentKind Kind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeline">                            VariableID Var, const Assignment &AV);</td>
    <td class="lineNumber">1297</td>
    <td class="codeline">                            VariableID Var, const Assignment &AV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeline">  /// Return the set of VariableIDs corresponding the fragments contained fully</td>
    <td class="lineNumber">1298</td>
    <td class="codeline">  /// Return the set of VariableIDs corresponding the fragments contained fully</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeline">  /// within the variable/fragment \p Var.</td>
    <td class="lineNumber">1299</td>
    <td class="codeline">  /// within the variable/fragment \p Var.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeline">  ArrayRef<VariableID> getContainedFragments(VariableID Var) const;</td>
    <td class="lineNumber">1300</td>
    <td class="codeline">  ArrayRef<VariableID> getContainedFragments(VariableID Var) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeline"></td>
    <td class="lineNumber">1301</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeline">  /// Mark \p Var as having been touched this frame. Note, this applies only</td>
    <td class="lineNumber">1302</td>
    <td class="codeline">  /// Mark \p Var as having been touched this frame. Note, this applies only</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeline">  /// to the exact fragment \p Var and not to any fragments contained within.</td>
    <td class="lineNumber">1303</td>
    <td class="codeline">  /// to the exact fragment \p Var and not to any fragments contained within.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeline">  void touchFragment(VariableID Var);</td>
    <td class="lineNumber">1304</td>
    <td class="codeline">  void touchFragment(VariableID Var);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeline"></td>
    <td class="lineNumber">1305</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeline">  /// Emit info for variables that are fully promoted.</td>
    <td class="lineNumber">1306</td>
    <td class="codeline">  /// Emit info for variables that are fully promoted.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeline">  bool emitPromotedVarLocs(FunctionVarLocsBuilder *FnVarLocs);</td>
    <td class="lineNumber">1307</td>
    <td class="codeline">  bool emitPromotedVarLocs(FunctionVarLocsBuilder *FnVarLocs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeline"></td>
    <td class="lineNumber">1308</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">1309</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeline">  AssignmentTrackingLowering(Function &Fn, const DataLayout &Layout,</td>
    <td class="lineNumber">1310</td>
    <td class="codeline">  AssignmentTrackingLowering(Function &Fn, const DataLayout &Layout,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeline">                             const DenseSet<DebugAggregate> *VarsWithStackSlot)</td>
    <td class="lineNumber">1311</td>
    <td class="codeline">                             const DenseSet<DebugAggregate> *VarsWithStackSlot)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeline">      : Fn(Fn), Layout(Layout), VarsWithStackSlot(VarsWithStackSlot) {}</td>
    <td class="lineNumber">1312</td>
    <td class="codeline">      : Fn(Fn), Layout(Layout), VarsWithStackSlot(VarsWithStackSlot) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeline">  /// Run the analysis, adding variable location info to \p FnVarLocs. Returns</td>
    <td class="lineNumber">1313</td>
    <td class="codeline">  /// Run the analysis, adding variable location info to \p FnVarLocs. Returns</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeline">  /// true if any variable locations have been added to FnVarLocs.</td>
    <td class="lineNumber">1314</td>
    <td class="codeline">  /// true if any variable locations have been added to FnVarLocs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeline">  bool run(FunctionVarLocsBuilder *FnVarLocs);</td>
    <td class="lineNumber">1315</td>
    <td class="codeline">  bool run(FunctionVarLocsBuilder *FnVarLocs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1316</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeline">} // namespace</td>
    <td class="lineNumber">1317</td>
    <td class="codeline">} // namespace</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeline"></td>
    <td class="lineNumber">1318</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeline">ArrayRef<VariableID></td>
    <td class="lineNumber">1319</td>
    <td class="codeline">ArrayRef<VariableID></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeline">AssignmentTrackingLowering::getContainedFragments(VariableID Var) const {</td>
    <td class="lineNumber">1320</td>
    <td class="codeline">AssignmentTrackingLowering::getContainedFragments(VariableID Var) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeline">  auto R = VarContains.find(Var);</td>
    <td class="lineNumber">1321</td>
    <td class="codeline">  auto R = VarContains.find(Var);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeline">  if (R == VarContains.end())</td>
    <td class="lineNumber">1322</td>
    <td class="codeline">  if (R == VarContains.end())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeline">    return std::nullopt;</td>
    <td class="lineNumber">1323</td>
    <td class="codeline">    return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeline">  return R->second;</td>
    <td class="lineNumber">1324</td>
    <td class="codeline">  return R->second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1325</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeline"></td>
    <td class="lineNumber">1326</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeline">void AssignmentTrackingLowering::touchFragment(VariableID Var) {</td>
    <td class="lineNumber">1327</td>
    <td class="codeline">void AssignmentTrackingLowering::touchFragment(VariableID Var) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeline">  VarsTouchedThisFrame.insert(Var);</td>
    <td class="lineNumber">1328</td>
    <td class="codeline">  VarsTouchedThisFrame.insert(Var);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1329</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeline"></td>
    <td class="lineNumber">1330</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeline">void AssignmentTrackingLowering::setLocKind(BlockInfo *LiveSet, VariableID Var,</td>
    <td class="lineNumber">1331</td>
    <td class="codeline">void AssignmentTrackingLowering::setLocKind(BlockInfo *LiveSet, VariableID Var,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeline">                                            LocKind K) {</td>
    <td class="lineNumber">1332</td>
    <td class="codeline">                                            LocKind K) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeline">  auto SetKind = [this](BlockInfo *LiveSet, VariableID Var, LocKind K) {</td>
    <td class="lineNumber">1333</td>
    <td class="codeline">  auto SetKind = [this](BlockInfo *LiveSet, VariableID Var, LocKind K) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeline">    LiveSet->setLocKind(Var, K);</td>
    <td class="lineNumber">1334</td>
    <td class="codeline">    LiveSet->setLocKind(Var, K);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeline">    touchFragment(Var);</td>
    <td class="lineNumber">1335</td>
    <td class="codeline">    touchFragment(Var);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1336</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeline">  SetKind(LiveSet, Var, K);</td>
    <td class="lineNumber">1337</td>
    <td class="codeline">  SetKind(LiveSet, Var, K);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeline"></td>
    <td class="lineNumber">1338</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeline">  // Update the LocKind for all fragments contained within Var.</td>
    <td class="lineNumber">1339</td>
    <td class="codeline">  // Update the LocKind for all fragments contained within Var.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeline">  for (VariableID Frag : getContainedFragments(Var))</td>
    <td class="lineNumber">1340</td>
    <td class="codeline">  for (VariableID Frag : getContainedFragments(Var))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeline">    SetKind(LiveSet, Frag, K);</td>
    <td class="lineNumber">1341</td>
    <td class="codeline">    SetKind(LiveSet, Frag, K);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1342</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeline"></td>
    <td class="lineNumber">1343</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeline">AssignmentTrackingLowering::LocKind</td>
    <td class="lineNumber">1344</td>
    <td class="codeline">AssignmentTrackingLowering::LocKind</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeline">AssignmentTrackingLowering::getLocKind(BlockInfo *LiveSet, VariableID Var) {</td>
    <td class="lineNumber">1345</td>
    <td class="codeline">AssignmentTrackingLowering::getLocKind(BlockInfo *LiveSet, VariableID Var) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeline">  return LiveSet->getLocKind(Var);</td>
    <td class="lineNumber">1346</td>
    <td class="codeline">  return LiveSet->getLocKind(Var);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1347</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeline"></td>
    <td class="lineNumber">1348</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeline">void AssignmentTrackingLowering::addMemDef(BlockInfo *LiveSet, VariableID Var,</td>
    <td class="lineNumber">1349</td>
    <td class="codeline">void AssignmentTrackingLowering::addMemDef(BlockInfo *LiveSet, VariableID Var,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeline">                                           const Assignment &AV) {</td>
    <td class="lineNumber">1350</td>
    <td class="codeline">                                           const Assignment &AV) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeline">  LiveSet->setAssignment(BlockInfo::Stack, Var, AV);</td>
    <td class="lineNumber">1351</td>
    <td class="codeline">  LiveSet->setAssignment(BlockInfo::Stack, Var, AV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeline"></td>
    <td class="lineNumber">1352</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeline">  // Use this assigment for all fragments contained within Var, but do not</td>
    <td class="lineNumber">1353</td>
    <td class="codeline">  // Use this assigment for all fragments contained within Var, but do not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeline">  // provide a Source because we cannot convert Var's value to a value for the</td>
    <td class="lineNumber">1354</td>
    <td class="codeline">  // provide a Source because we cannot convert Var's value to a value for the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeline">  // fragment.</td>
    <td class="lineNumber">1355</td>
    <td class="codeline">  // fragment.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeline">  Assignment FragAV = AV;</td>
    <td class="lineNumber">1356</td>
    <td class="codeline">  Assignment FragAV = AV;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeline">  FragAV.Source = nullptr;</td>
    <td class="lineNumber">1357</td>
    <td class="codeline">  FragAV.Source = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeline">  for (VariableID Frag : getContainedFragments(Var))</td>
    <td class="lineNumber">1358</td>
    <td class="codeline">  for (VariableID Frag : getContainedFragments(Var))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeline">    LiveSet->setAssignment(BlockInfo::Stack, Frag, FragAV);</td>
    <td class="lineNumber">1359</td>
    <td class="codeline">    LiveSet->setAssignment(BlockInfo::Stack, Frag, FragAV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1360</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeline"></td>
    <td class="lineNumber">1361</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeline">void AssignmentTrackingLowering::addDbgDef(BlockInfo *LiveSet, VariableID Var,</td>
    <td class="lineNumber">1362</td>
    <td class="codeline">void AssignmentTrackingLowering::addDbgDef(BlockInfo *LiveSet, VariableID Var,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeline">                                           const Assignment &AV) {</td>
    <td class="lineNumber">1363</td>
    <td class="codeline">                                           const Assignment &AV) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeline">  LiveSet->setAssignment(BlockInfo::Debug, Var, AV);</td>
    <td class="lineNumber">1364</td>
    <td class="codeline">  LiveSet->setAssignment(BlockInfo::Debug, Var, AV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeline"></td>
    <td class="lineNumber">1365</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeline">  // Use this assigment for all fragments contained within Var, but do not</td>
    <td class="lineNumber">1366</td>
    <td class="codeline">  // Use this assigment for all fragments contained within Var, but do not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeline">  // provide a Source because we cannot convert Var's value to a value for the</td>
    <td class="lineNumber">1367</td>
    <td class="codeline">  // provide a Source because we cannot convert Var's value to a value for the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeline">  // fragment.</td>
    <td class="lineNumber">1368</td>
    <td class="codeline">  // fragment.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeline">  Assignment FragAV = AV;</td>
    <td class="lineNumber">1369</td>
    <td class="codeline">  Assignment FragAV = AV;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeline">  FragAV.Source = nullptr;</td>
    <td class="lineNumber">1370</td>
    <td class="codeline">  FragAV.Source = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeline">  for (VariableID Frag : getContainedFragments(Var))</td>
    <td class="lineNumber">1371</td>
    <td class="codeline">  for (VariableID Frag : getContainedFragments(Var))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeline">    LiveSet->setAssignment(BlockInfo::Debug, Frag, FragAV);</td>
    <td class="lineNumber">1372</td>
    <td class="codeline">    LiveSet->setAssignment(BlockInfo::Debug, Frag, FragAV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1373</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeline"></td>
    <td class="lineNumber">1374</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeline">static DIAssignID *getIDFromInst(const Instruction &I) {</td>
    <td class="lineNumber">1375</td>
    <td class="codeline">static DIAssignID *getIDFromInst(const Instruction &I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeline">  return cast<DIAssignID>(I.getMetadata(LLVMContext::MD_DIAssignID));</td>
    <td class="lineNumber">1376</td>
    <td class="codeline">  return cast<DIAssignID>(I.getMetadata(LLVMContext::MD_DIAssignID));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1377</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeline"></td>
    <td class="lineNumber">1378</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeline">static DIAssignID *getIDFromMarker(const DbgAssignIntrinsic &DAI) {</td>
    <td class="lineNumber">1379</td>
    <td class="codeline">static DIAssignID *getIDFromMarker(const DbgAssignIntrinsic &DAI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeline">  return cast<DIAssignID>(DAI.getAssignID());</td>
    <td class="lineNumber">1380</td>
    <td class="codeline">  return cast<DIAssignID>(DAI.getAssignID());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1381</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeline"></td>
    <td class="lineNumber">1382</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeline">/// Return true if \p Var has an assignment in \p M matching \p AV.</td>
    <td class="lineNumber">1383</td>
    <td class="codeline">/// Return true if \p Var has an assignment in \p M matching \p AV.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeline">bool AssignmentTrackingLowering::hasVarWithAssignment(</td>
    <td class="lineNumber">1384</td>
    <td class="codeline">bool AssignmentTrackingLowering::hasVarWithAssignment(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeline">    BlockInfo *LiveSet, BlockInfo::AssignmentKind Kind, VariableID Var,</td>
    <td class="lineNumber">1385</td>
    <td class="codeline">    BlockInfo *LiveSet, BlockInfo::AssignmentKind Kind, VariableID Var,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeline">    const Assignment &AV) {</td>
    <td class="lineNumber">1386</td>
    <td class="codeline">    const Assignment &AV) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeline">  if (!LiveSet->hasAssignment(Kind, Var, AV))</td>
    <td class="lineNumber">1387</td>
    <td class="codeline">  if (!LiveSet->hasAssignment(Kind, Var, AV))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1388</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeline"></td>
    <td class="lineNumber">1389</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeline">  // Check all the frags contained within Var as these will have all been</td>
    <td class="lineNumber">1390</td>
    <td class="codeline">  // Check all the frags contained within Var as these will have all been</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeline">  // mapped to AV at the last store to Var.</td>
    <td class="lineNumber">1391</td>
    <td class="codeline">  // mapped to AV at the last store to Var.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeline">  for (VariableID Frag : getContainedFragments(Var))</td>
    <td class="lineNumber">1392</td>
    <td class="codeline">  for (VariableID Frag : getContainedFragments(Var))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeline">    if (!LiveSet->hasAssignment(Kind, Frag, AV))</td>
    <td class="lineNumber">1393</td>
    <td class="codeline">    if (!LiveSet->hasAssignment(Kind, Frag, AV))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1394</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">1395</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1396</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeline"></td>
    <td class="lineNumber">1397</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeline">#ifndef NDEBUG</td>
    <td class="lineNumber">1398</td>
    <td class="codeline">#ifndef NDEBUG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeline">const char *locStr(AssignmentTrackingLowering::LocKind Loc) {</td>
    <td class="lineNumber">1399</td>
    <td class="codeline">const char *locStr(AssignmentTrackingLowering::LocKind Loc) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeline">  using LocKind = AssignmentTrackingLowering::LocKind;</td>
    <td class="lineNumber">1400</td>
    <td class="codeline">  using LocKind = AssignmentTrackingLowering::LocKind;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeline">  switch (Loc) {</td>
    <td class="lineNumber">1401</td>
    <td class="codeline">  switch (Loc) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeline">  case LocKind::Val:</td>
    <td class="lineNumber">1402</td>
    <td class="codeline">  case LocKind::Val:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeline">    return "Val";</td>
    <td class="lineNumber">1403</td>
    <td class="codeline">    return "Val";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeline">  case LocKind::Mem:</td>
    <td class="lineNumber">1404</td>
    <td class="codeline">  case LocKind::Mem:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeline">    return "Mem";</td>
    <td class="lineNumber">1405</td>
    <td class="codeline">    return "Mem";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeline">  case LocKind::None:</td>
    <td class="lineNumber">1406</td>
    <td class="codeline">  case LocKind::None:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeline">    return "None";</td>
    <td class="lineNumber">1407</td>
    <td class="codeline">    return "None";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1408</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeline">  llvm_unreachable("unknown LocKind");</td>
    <td class="lineNumber">1409</td>
    <td class="codeline">  llvm_unreachable("unknown LocKind");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1410</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">1411</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeline"></td>
    <td class="lineNumber">1412</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeline">void AssignmentTrackingLowering::emitDbgValue(</td>
    <td class="lineNumber">1413</td>
    <td class="codeline">void AssignmentTrackingLowering::emitDbgValue(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeline">    AssignmentTrackingLowering::LocKind Kind,</td>
    <td class="lineNumber">1414</td>
    <td class="codeline">    AssignmentTrackingLowering::LocKind Kind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeline">    const DbgVariableIntrinsic *Source, Instruction *After) {</td>
    <td class="lineNumber">1415</td>
    <td class="codeline">    const DbgVariableIntrinsic *Source, Instruction *After) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeline"></td>
    <td class="lineNumber">1416</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeline">  DILocation *DL = Source->getDebugLoc();</td>
    <td class="lineNumber">1417</td>
    <td class="codeline">  DILocation *DL = Source->getDebugLoc();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeline">  auto Emit = [this, Source, After, DL](Metadata *Val, DIExpression *Expr) {</td>
    <td class="lineNumber">1418</td>
    <td class="codeline">  auto Emit = [this, Source, After, DL](Metadata *Val, DIExpression *Expr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeline">    assert(Expr);</td>
    <td class="lineNumber">1419</td>
    <td class="codeline">    assert(Expr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeline">    if (!Val)</td>
    <td class="lineNumber">1420</td>
    <td class="codeline">    if (!Val)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeline">      Val = ValueAsMetadata::get(</td>
    <td class="lineNumber">1421</td>
    <td class="codeline">      Val = ValueAsMetadata::get(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeline">          PoisonValue::get(Type::getInt1Ty(Source->getContext())));</td>
    <td class="lineNumber">1422</td>
    <td class="codeline">          PoisonValue::get(Type::getInt1Ty(Source->getContext())));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeline"></td>
    <td class="lineNumber">1423</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeline">    // Find a suitable insert point.</td>
    <td class="lineNumber">1424</td>
    <td class="codeline">    // Find a suitable insert point.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeline">    Instruction *InsertBefore = After->getNextNode();</td>
    <td class="lineNumber">1425</td>
    <td class="codeline">    Instruction *InsertBefore = After->getNextNode();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeline">    assert(InsertBefore && "Shouldn't be inserting after a terminator");</td>
    <td class="lineNumber">1426</td>
    <td class="codeline">    assert(InsertBefore && "Shouldn't be inserting after a terminator");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeline"></td>
    <td class="lineNumber">1427</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeline">    VariableID Var = getVariableID(DebugVariable(Source));</td>
    <td class="lineNumber">1428</td>
    <td class="codeline">    VariableID Var = getVariableID(DebugVariable(Source));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeline">    VarLocInfo VarLoc;</td>
    <td class="lineNumber">1429</td>
    <td class="codeline">    VarLocInfo VarLoc;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeline">    VarLoc.VariableID = static_cast<VariableID>(Var);</td>
    <td class="lineNumber">1430</td>
    <td class="codeline">    VarLoc.VariableID = static_cast<VariableID>(Var);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeline">    VarLoc.Expr = Expr;</td>
    <td class="lineNumber">1431</td>
    <td class="codeline">    VarLoc.Expr = Expr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeline">    VarLoc.Values = RawLocationWrapper(Val);</td>
    <td class="lineNumber">1432</td>
    <td class="codeline">    VarLoc.Values = RawLocationWrapper(Val);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeline">    VarLoc.DL = DL;</td>
    <td class="lineNumber">1433</td>
    <td class="codeline">    VarLoc.DL = DL;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeline">    // Insert it into the map for later.</td>
    <td class="lineNumber">1434</td>
    <td class="codeline">    // Insert it into the map for later.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeline">    InsertBeforeMap[InsertBefore].push_back(VarLoc);</td>
    <td class="lineNumber">1435</td>
    <td class="codeline">    InsertBeforeMap[InsertBefore].push_back(VarLoc);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1436</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeline"></td>
    <td class="lineNumber">1437</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeline">  // NOTE: This block can mutate Kind.</td>
    <td class="lineNumber">1438</td>
    <td class="codeline">  // NOTE: This block can mutate Kind.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeline">  if (Kind == LocKind::Mem) {</td>
    <td class="lineNumber">1439</td>
    <td class="codeline">  if (Kind == LocKind::Mem) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeline">    const auto *DAI = cast<DbgAssignIntrinsic>(Source);</td>
    <td class="lineNumber">1440</td>
    <td class="codeline">    const auto *DAI = cast<DbgAssignIntrinsic>(Source);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeline">    // Check the address hasn't been dropped (e.g. the debug uses may not have</td>
    <td class="lineNumber">1441</td>
    <td class="codeline">    // Check the address hasn't been dropped (e.g. the debug uses may not have</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeline">    // been replaced before deleting a Value).</td>
    <td class="lineNumber">1442</td>
    <td class="codeline">    // been replaced before deleting a Value).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeline">    if (DAI->isKillAddress()) {</td>
    <td class="lineNumber">1443</td>
    <td class="codeline">    if (DAI->isKillAddress()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeline">      // The address isn't valid so treat this as a non-memory def.</td>
    <td class="lineNumber">1444</td>
    <td class="codeline">      // The address isn't valid so treat this as a non-memory def.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeline">      Kind = LocKind::Val;</td>
    <td class="lineNumber">1445</td>
    <td class="codeline">      Kind = LocKind::Val;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">1446</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeline">      Value *Val = DAI->getAddress();</td>
    <td class="lineNumber">1447</td>
    <td class="codeline">      Value *Val = DAI->getAddress();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeline">      DIExpression *Expr = DAI->getAddressExpression();</td>
    <td class="lineNumber">1448</td>
    <td class="codeline">      DIExpression *Expr = DAI->getAddressExpression();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeline">      assert(!Expr->getFragmentInfo() &&</td>
    <td class="lineNumber">1449</td>
    <td class="codeline">      assert(!Expr->getFragmentInfo() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeline">             "fragment info should be stored in value-expression only");</td>
    <td class="lineNumber">1450</td>
    <td class="codeline">             "fragment info should be stored in value-expression only");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeline">      // Copy the fragment info over from the value-expression to the new</td>
    <td class="lineNumber">1451</td>
    <td class="codeline">      // Copy the fragment info over from the value-expression to the new</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeline">      // DIExpression.</td>
    <td class="lineNumber">1452</td>
    <td class="codeline">      // DIExpression.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeline">      if (auto OptFragInfo = Source->getExpression()->getFragmentInfo()) {</td>
    <td class="lineNumber">1453</td>
    <td class="codeline">      if (auto OptFragInfo = Source->getExpression()->getFragmentInfo()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeline">        auto FragInfo = *OptFragInfo;</td>
    <td class="lineNumber">1454</td>
    <td class="codeline">        auto FragInfo = *OptFragInfo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeline">        Expr = *DIExpression::createFragmentExpression(</td>
    <td class="lineNumber">1455</td>
    <td class="codeline">        Expr = *DIExpression::createFragmentExpression(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeline">            Expr, FragInfo.OffsetInBits, FragInfo.SizeInBits);</td>
    <td class="lineNumber">1456</td>
    <td class="codeline">            Expr, FragInfo.OffsetInBits, FragInfo.SizeInBits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1457</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeline">      // The address-expression has an implicit deref, add it now.</td>
    <td class="lineNumber">1458</td>
    <td class="codeline">      // The address-expression has an implicit deref, add it now.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeline">      std::tie(Val, Expr) =</td>
    <td class="lineNumber">1459</td>
    <td class="codeline">      std::tie(Val, Expr) =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeline">          walkToAllocaAndPrependOffsetDeref(Layout, Val, Expr);</td>
    <td class="lineNumber">1460</td>
    <td class="codeline">          walkToAllocaAndPrependOffsetDeref(Layout, Val, Expr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeline">      Emit(ValueAsMetadata::get(Val), Expr);</td>
    <td class="lineNumber">1461</td>
    <td class="codeline">      Emit(ValueAsMetadata::get(Val), Expr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">1462</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1463</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1464</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeline"></td>
    <td class="lineNumber">1465</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeline">  if (Kind == LocKind::Val) {</td>
    <td class="lineNumber">1466</td>
    <td class="codeline">  if (Kind == LocKind::Val) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeline">    Emit(Source->getRawLocation(), Source->getExpression());</td>
    <td class="lineNumber">1467</td>
    <td class="codeline">    Emit(Source->getRawLocation(), Source->getExpression());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">1468</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1469</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeline"></td>
    <td class="lineNumber">1470</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeline">  if (Kind == LocKind::None) {</td>
    <td class="lineNumber">1471</td>
    <td class="codeline">  if (Kind == LocKind::None) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeline">    Emit(nullptr, Source->getExpression());</td>
    <td class="lineNumber">1472</td>
    <td class="codeline">    Emit(nullptr, Source->getExpression());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">1473</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1474</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1475</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeline"></td>
    <td class="lineNumber">1476</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeline">void AssignmentTrackingLowering::processNonDbgInstruction(</td>
    <td class="lineNumber">1477</td>
    <td class="codeline">void AssignmentTrackingLowering::processNonDbgInstruction(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeline">    Instruction &I, AssignmentTrackingLowering::BlockInfo *LiveSet) {</td>
    <td class="lineNumber">1478</td>
    <td class="codeline">    Instruction &I, AssignmentTrackingLowering::BlockInfo *LiveSet) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeline">  if (I.hasMetadata(LLVMContext::MD_DIAssignID))</td>
    <td class="lineNumber">1479</td>
    <td class="codeline">  if (I.hasMetadata(LLVMContext::MD_DIAssignID))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeline">    processTaggedInstruction(I, LiveSet);</td>
    <td class="lineNumber">1480</td>
    <td class="codeline">    processTaggedInstruction(I, LiveSet);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">1481</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeline">    processUntaggedInstruction(I, LiveSet);</td>
    <td class="lineNumber">1482</td>
    <td class="codeline">    processUntaggedInstruction(I, LiveSet);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1483</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeline"></td>
    <td class="lineNumber">1484</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeline">void AssignmentTrackingLowering::processUntaggedInstruction(</td>
    <td class="lineNumber">1485</td>
    <td class="codeline">void AssignmentTrackingLowering::processUntaggedInstruction(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeline">    Instruction &I, AssignmentTrackingLowering::BlockInfo *LiveSet) {</td>
    <td class="lineNumber">1486</td>
    <td class="codeline">    Instruction &I, AssignmentTrackingLowering::BlockInfo *LiveSet) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeline">  // Interpret stack stores that are not tagged as an assignment in memory for</td>
    <td class="lineNumber">1487</td>
    <td class="codeline">  // Interpret stack stores that are not tagged as an assignment in memory for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeline">  // the variables associated with that address. These stores may not be tagged</td>
    <td class="lineNumber">1488</td>
    <td class="codeline">  // the variables associated with that address. These stores may not be tagged</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeline">  // because a) the store cannot be represented using dbg.assigns (non-const</td>
    <td class="lineNumber">1489</td>
    <td class="codeline">  // because a) the store cannot be represented using dbg.assigns (non-const</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeline">  // length or offset) or b) the tag was accidentally dropped during</td>
    <td class="lineNumber">1490</td>
    <td class="codeline">  // length or offset) or b) the tag was accidentally dropped during</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeline">  // optimisations. For these stores we fall back to assuming that the stack</td>
    <td class="lineNumber">1491</td>
    <td class="codeline">  // optimisations. For these stores we fall back to assuming that the stack</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeline">  // home is a valid location for the variables. The benefit is that this</td>
    <td class="lineNumber">1492</td>
    <td class="codeline">  // home is a valid location for the variables. The benefit is that this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeline">  // prevents us missing an assignment and therefore incorrectly maintaining</td>
    <td class="lineNumber">1493</td>
    <td class="codeline">  // prevents us missing an assignment and therefore incorrectly maintaining</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeline">  // earlier location definitions, and in many cases it should be a reasonable</td>
    <td class="lineNumber">1494</td>
    <td class="codeline">  // earlier location definitions, and in many cases it should be a reasonable</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeline">  // assumption. However, this will occasionally lead to slight</td>
    <td class="lineNumber">1495</td>
    <td class="codeline">  // assumption. However, this will occasionally lead to slight</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeline">  // inaccuracies. The value of a hoisted untagged store will be visible</td>
    <td class="lineNumber">1496</td>
    <td class="codeline">  // inaccuracies. The value of a hoisted untagged store will be visible</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeline">  // "early", for example.</td>
    <td class="lineNumber">1497</td>
    <td class="codeline">  // "early", for example.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeline">  assert(!I.hasMetadata(LLVMContext::MD_DIAssignID));</td>
    <td class="lineNumber">1498</td>
    <td class="codeline">  assert(!I.hasMetadata(LLVMContext::MD_DIAssignID));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeline">  auto It = UntaggedStoreVars.find(&I);</td>
    <td class="lineNumber">1499</td>
    <td class="codeline">  auto It = UntaggedStoreVars.find(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeline">  if (It == UntaggedStoreVars.end())</td>
    <td class="lineNumber">1500</td>
    <td class="codeline">  if (It == UntaggedStoreVars.end())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeline">    return; // No variables associated with the store destination.</td>
    <td class="lineNumber">1501</td>
    <td class="codeline">    return; // No variables associated with the store destination.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeline"></td>
    <td class="lineNumber">1502</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "processUntaggedInstruction on UNTAGGED INST " << I</td>
    <td class="lineNumber">1503</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "processUntaggedInstruction on UNTAGGED INST " << I</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeline">                    << "\n");</td>
    <td class="lineNumber">1504</td>
    <td class="codeline">                    << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeline">  // Iterate over the variables that this store affects, add a NoneOrPhi dbg</td>
    <td class="lineNumber">1505</td>
    <td class="codeline">  // Iterate over the variables that this store affects, add a NoneOrPhi dbg</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeline">  // and mem def, set lockind to Mem, and emit a location def for each.</td>
    <td class="lineNumber">1506</td>
    <td class="codeline">  // and mem def, set lockind to Mem, and emit a location def for each.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeline">  for (auto [Var, Info] : It->second) {</td>
    <td class="lineNumber">1507</td>
    <td class="codeline">  for (auto [Var, Info] : It->second) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeline">    // This instruction is treated as both a debug and memory assignment,</td>
    <td class="lineNumber">1508</td>
    <td class="codeline">    // This instruction is treated as both a debug and memory assignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeline">    // meaning the memory location should be used. We don't have an assignment</td>
    <td class="lineNumber">1509</td>
    <td class="codeline">    // meaning the memory location should be used. We don't have an assignment</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeline">    // ID though so use Assignment::makeNoneOrPhi() to create an imaginary one.</td>
    <td class="lineNumber">1510</td>
    <td class="codeline">    // ID though so use Assignment::makeNoneOrPhi() to create an imaginary one.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeline">    addMemDef(LiveSet, Var, Assignment::makeNoneOrPhi());</td>
    <td class="lineNumber">1511</td>
    <td class="codeline">    addMemDef(LiveSet, Var, Assignment::makeNoneOrPhi());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeline">    addDbgDef(LiveSet, Var, Assignment::makeNoneOrPhi());</td>
    <td class="lineNumber">1512</td>
    <td class="codeline">    addDbgDef(LiveSet, Var, Assignment::makeNoneOrPhi());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeline">    setLocKind(LiveSet, Var, LocKind::Mem);</td>
    <td class="lineNumber">1513</td>
    <td class="codeline">    setLocKind(LiveSet, Var, LocKind::Mem);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "  setting Stack LocKind to: " << locStr(LocKind::Mem)</td>
    <td class="lineNumber">1514</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "  setting Stack LocKind to: " << locStr(LocKind::Mem)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeline">                      << "\n");</td>
    <td class="lineNumber">1515</td>
    <td class="codeline">                      << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeline">    // Build the dbg location def to insert.</td>
    <td class="lineNumber">1516</td>
    <td class="codeline">    // Build the dbg location def to insert.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">1517</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeline">    // DIExpression: Add fragment and offset.</td>
    <td class="lineNumber">1518</td>
    <td class="codeline">    // DIExpression: Add fragment and offset.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeline">    DebugVariable V = FnVarLocs->getVariable(Var);</td>
    <td class="lineNumber">1519</td>
    <td class="codeline">    DebugVariable V = FnVarLocs->getVariable(Var);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeline">    DIExpression *DIE = DIExpression::get(I.getContext(), std::nullopt);</td>
    <td class="lineNumber">1520</td>
    <td class="codeline">    DIExpression *DIE = DIExpression::get(I.getContext(), std::nullopt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeline">    if (auto Frag = V.getFragment()) {</td>
    <td class="lineNumber">1521</td>
    <td class="codeline">    if (auto Frag = V.getFragment()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeline">      auto R = DIExpression::createFragmentExpression(DIE, Frag->OffsetInBits,</td>
    <td class="lineNumber">1522</td>
    <td class="codeline">      auto R = DIExpression::createFragmentExpression(DIE, Frag->OffsetInBits,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeline">                                                      Frag->SizeInBits);</td>
    <td class="lineNumber">1523</td>
    <td class="codeline">                                                      Frag->SizeInBits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeline">      assert(R && "unexpected createFragmentExpression failure");</td>
    <td class="lineNumber">1524</td>
    <td class="codeline">      assert(R && "unexpected createFragmentExpression failure");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeline">      DIE = *R;</td>
    <td class="lineNumber">1525</td>
    <td class="codeline">      DIE = *R;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1526</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeline">    SmallVector<uint64_t, 3> Ops;</td>
    <td class="lineNumber">1527</td>
    <td class="codeline">    SmallVector<uint64_t, 3> Ops;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeline">    if (Info.OffsetInBits)</td>
    <td class="lineNumber">1528</td>
    <td class="codeline">    if (Info.OffsetInBits)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeline">      Ops = {dwarf::DW_OP_plus_uconst, Info.OffsetInBits / 8};</td>
    <td class="lineNumber">1529</td>
    <td class="codeline">      Ops = {dwarf::DW_OP_plus_uconst, Info.OffsetInBits / 8};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeline">    Ops.push_back(dwarf::DW_OP_deref);</td>
    <td class="lineNumber">1530</td>
    <td class="codeline">    Ops.push_back(dwarf::DW_OP_deref);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeline">    DIE = DIExpression::prependOpcodes(DIE, Ops, /*StackValue=*/false,</td>
    <td class="lineNumber">1531</td>
    <td class="codeline">    DIE = DIExpression::prependOpcodes(DIE, Ops, /*StackValue=*/false,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeline">                                       /*EntryValue=*/false);</td>
    <td class="lineNumber">1532</td>
    <td class="codeline">                                       /*EntryValue=*/false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeline">    // Find a suitable insert point.</td>
    <td class="lineNumber">1533</td>
    <td class="codeline">    // Find a suitable insert point.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeline">    Instruction *InsertBefore = I.getNextNode();</td>
    <td class="lineNumber">1534</td>
    <td class="codeline">    Instruction *InsertBefore = I.getNextNode();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeline">    assert(InsertBefore && "Shouldn't be inserting after a terminator");</td>
    <td class="lineNumber">1535</td>
    <td class="codeline">    assert(InsertBefore && "Shouldn't be inserting after a terminator");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeline"></td>
    <td class="lineNumber">1536</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeline">    // Get DILocation for this unrecorded assignment.</td>
    <td class="lineNumber">1537</td>
    <td class="codeline">    // Get DILocation for this unrecorded assignment.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeline">    DILocation *InlinedAt = const_cast<DILocation *>(V.getInlinedAt());</td>
    <td class="lineNumber">1538</td>
    <td class="codeline">    DILocation *InlinedAt = const_cast<DILocation *>(V.getInlinedAt());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeline">    const DILocation *DILoc = DILocation::get(</td>
    <td class="lineNumber">1539</td>
    <td class="codeline">    const DILocation *DILoc = DILocation::get(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeline">        Fn.getContext(), 0, 0, V.getVariable()->getScope(), InlinedAt);</td>
    <td class="lineNumber">1540</td>
    <td class="codeline">        Fn.getContext(), 0, 0, V.getVariable()->getScope(), InlinedAt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeline"></td>
    <td class="lineNumber">1541</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeline">    VarLocInfo VarLoc;</td>
    <td class="lineNumber">1542</td>
    <td class="codeline">    VarLocInfo VarLoc;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeline">    VarLoc.VariableID = static_cast<VariableID>(Var);</td>
    <td class="lineNumber">1543</td>
    <td class="codeline">    VarLoc.VariableID = static_cast<VariableID>(Var);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeline">    VarLoc.Expr = DIE;</td>
    <td class="lineNumber">1544</td>
    <td class="codeline">    VarLoc.Expr = DIE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeline">    VarLoc.Values = RawLocationWrapper(</td>
    <td class="lineNumber">1545</td>
    <td class="codeline">    VarLoc.Values = RawLocationWrapper(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeline">        ValueAsMetadata::get(const_cast<AllocaInst *>(Info.Base)));</td>
    <td class="lineNumber">1546</td>
    <td class="codeline">        ValueAsMetadata::get(const_cast<AllocaInst *>(Info.Base)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeline">    VarLoc.DL = DILoc;</td>
    <td class="lineNumber">1547</td>
    <td class="codeline">    VarLoc.DL = DILoc;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeline">    // 3. Insert it into the map for later.</td>
    <td class="lineNumber">1548</td>
    <td class="codeline">    // 3. Insert it into the map for later.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeline">    InsertBeforeMap[InsertBefore].push_back(VarLoc);</td>
    <td class="lineNumber">1549</td>
    <td class="codeline">    InsertBeforeMap[InsertBefore].push_back(VarLoc);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1550</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1551</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeline"></td>
    <td class="lineNumber">1552</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeline">void AssignmentTrackingLowering::processTaggedInstruction(</td>
    <td class="lineNumber">1553</td>
    <td class="codeline">void AssignmentTrackingLowering::processTaggedInstruction(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeline">    Instruction &I, AssignmentTrackingLowering::BlockInfo *LiveSet) {</td>
    <td class="lineNumber">1554</td>
    <td class="codeline">    Instruction &I, AssignmentTrackingLowering::BlockInfo *LiveSet) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeline">  auto Linked = at::getAssignmentMarkers(&I);</td>
    <td class="lineNumber">1555</td>
    <td class="codeline">  auto Linked = at::getAssignmentMarkers(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeline">  // No dbg.assign intrinsics linked.</td>
    <td class="lineNumber">1556</td>
    <td class="codeline">  // No dbg.assign intrinsics linked.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeline">  // FIXME: All vars that have a stack slot this store modifies that don't have</td>
    <td class="lineNumber">1557</td>
    <td class="codeline">  // FIXME: All vars that have a stack slot this store modifies that don't have</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeline">  // a dbg.assign linked to it should probably treat this like an untagged</td>
    <td class="lineNumber">1558</td>
    <td class="codeline">  // a dbg.assign linked to it should probably treat this like an untagged</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeline">  // store.</td>
    <td class="lineNumber">1559</td>
    <td class="codeline">  // store.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeline">  if (Linked.empty())</td>
    <td class="lineNumber">1560</td>
    <td class="codeline">  if (Linked.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">1561</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeline"></td>
    <td class="lineNumber">1562</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "processTaggedInstruction on " << I << "\n");</td>
    <td class="lineNumber">1563</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "processTaggedInstruction on " << I << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeline">  for (DbgAssignIntrinsic *DAI : Linked) {</td>
    <td class="lineNumber">1564</td>
    <td class="codeline">  for (DbgAssignIntrinsic *DAI : Linked) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeline">    VariableID Var = getVariableID(DebugVariable(DAI));</td>
    <td class="lineNumber">1565</td>
    <td class="codeline">    VariableID Var = getVariableID(DebugVariable(DAI));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeline">    // Something has gone wrong if VarsWithStackSlot doesn't contain a variable</td>
    <td class="lineNumber">1566</td>
    <td class="codeline">    // Something has gone wrong if VarsWithStackSlot doesn't contain a variable</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeline">    // that is linked to a store.</td>
    <td class="lineNumber">1567</td>
    <td class="codeline">    // that is linked to a store.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeline">    assert(VarsWithStackSlot->count(getAggregate(DAI)) &&</td>
    <td class="lineNumber">1568</td>
    <td class="codeline">    assert(VarsWithStackSlot->count(getAggregate(DAI)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeline">           "expected DAI's variable to have stack slot");</td>
    <td class="lineNumber">1569</td>
    <td class="codeline">           "expected DAI's variable to have stack slot");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeline"></td>
    <td class="lineNumber">1570</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeline">    Assignment AV = Assignment::makeFromMemDef(getIDFromInst(I));</td>
    <td class="lineNumber">1571</td>
    <td class="codeline">    Assignment AV = Assignment::makeFromMemDef(getIDFromInst(I));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeline">    addMemDef(LiveSet, Var, AV);</td>
    <td class="lineNumber">1572</td>
    <td class="codeline">    addMemDef(LiveSet, Var, AV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeline"></td>
    <td class="lineNumber">1573</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "   linked to " << *DAI << "\n");</td>
    <td class="lineNumber">1574</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "   linked to " << *DAI << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "   LiveLoc " << locStr(getLocKind(LiveSet, Var))</td>
    <td class="lineNumber">1575</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "   LiveLoc " << locStr(getLocKind(LiveSet, Var))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeline">                      << " -> ");</td>
    <td class="lineNumber">1576</td>
    <td class="codeline">                      << " -> ");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeline"></td>
    <td class="lineNumber">1577</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeline">    // The last assignment to the stack is now AV. Check if the last debug</td>
    <td class="lineNumber">1578</td>
    <td class="codeline">    // The last assignment to the stack is now AV. Check if the last debug</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeline">    // assignment has a matching Assignment.</td>
    <td class="lineNumber">1579</td>
    <td class="codeline">    // assignment has a matching Assignment.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeline">    if (hasVarWithAssignment(LiveSet, BlockInfo::Debug, Var, AV)) {</td>
    <td class="lineNumber">1580</td>
    <td class="codeline">    if (hasVarWithAssignment(LiveSet, BlockInfo::Debug, Var, AV)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeline">      // The StackHomeValue and DebugValue for this variable match so we can</td>
    <td class="lineNumber">1581</td>
    <td class="codeline">      // The StackHomeValue and DebugValue for this variable match so we can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeline">      // emit a stack home location here.</td>
    <td class="lineNumber">1582</td>
    <td class="codeline">      // emit a stack home location here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "Mem, Stack matches Debug program\n";);</td>
    <td class="lineNumber">1583</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "Mem, Stack matches Debug program\n";);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "   Stack val: "; AV.dump(dbgs()); dbgs() << "\n");</td>
    <td class="lineNumber">1584</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "   Stack val: "; AV.dump(dbgs()); dbgs() << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "   Debug val: ";</td>
    <td class="lineNumber">1585</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "   Debug val: ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeline">                 LiveSet->DebugValue[static_cast<unsigned>(Var)].dump(dbgs());</td>
    <td class="lineNumber">1586</td>
    <td class="codeline">                 LiveSet->DebugValue[static_cast<unsigned>(Var)].dump(dbgs());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeline">                 dbgs() << "\n");</td>
    <td class="lineNumber">1587</td>
    <td class="codeline">                 dbgs() << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeline">      setLocKind(LiveSet, Var, LocKind::Mem);</td>
    <td class="lineNumber">1588</td>
    <td class="codeline">      setLocKind(LiveSet, Var, LocKind::Mem);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeline">      emitDbgValue(LocKind::Mem, DAI, &I);</td>
    <td class="lineNumber">1589</td>
    <td class="codeline">      emitDbgValue(LocKind::Mem, DAI, &I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1590</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1591</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeline"></td>
    <td class="lineNumber">1592</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeline">    // The StackHomeValue and DebugValue for this variable do not match. I.e.</td>
    <td class="lineNumber">1593</td>
    <td class="codeline">    // The StackHomeValue and DebugValue for this variable do not match. I.e.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeline">    // The value currently stored in the stack is not what we'd expect to</td>
    <td class="lineNumber">1594</td>
    <td class="codeline">    // The value currently stored in the stack is not what we'd expect to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeline">    // see, so we cannot use emit a stack home location here. Now we will</td>
    <td class="lineNumber">1595</td>
    <td class="codeline">    // see, so we cannot use emit a stack home location here. Now we will</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeline">    // look at the live LocKind for the variable and determine an appropriate</td>
    <td class="lineNumber">1596</td>
    <td class="codeline">    // look at the live LocKind for the variable and determine an appropriate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeline">    // dbg.value to emit.</td>
    <td class="lineNumber">1597</td>
    <td class="codeline">    // dbg.value to emit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeline">    LocKind PrevLoc = getLocKind(LiveSet, Var);</td>
    <td class="lineNumber">1598</td>
    <td class="codeline">    LocKind PrevLoc = getLocKind(LiveSet, Var);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeline">    switch (PrevLoc) {</td>
    <td class="lineNumber">1599</td>
    <td class="codeline">    switch (PrevLoc) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeline">    case LocKind::Val: {</td>
    <td class="lineNumber">1600</td>
    <td class="codeline">    case LocKind::Val: {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeline">      // The value in memory in memory has changed but we're not currently</td>
    <td class="lineNumber">1601</td>
    <td class="codeline">      // The value in memory in memory has changed but we're not currently</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeline">      // using the memory location. Do nothing.</td>
    <td class="lineNumber">1602</td>
    <td class="codeline">      // using the memory location. Do nothing.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "Val, (unchanged)\n";);</td>
    <td class="lineNumber">1603</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "Val, (unchanged)\n";);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeline">      setLocKind(LiveSet, Var, LocKind::Val);</td>
    <td class="lineNumber">1604</td>
    <td class="codeline">      setLocKind(LiveSet, Var, LocKind::Val);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeline">    } break;</td>
    <td class="lineNumber">1605</td>
    <td class="codeline">    } break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeline">    case LocKind::Mem: {</td>
    <td class="lineNumber">1606</td>
    <td class="codeline">    case LocKind::Mem: {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeline">      // There's been an assignment to memory that we were using as a</td>
    <td class="lineNumber">1607</td>
    <td class="codeline">      // There's been an assignment to memory that we were using as a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeline">      // location for this variable, and the Assignment doesn't match what</td>
    <td class="lineNumber">1608</td>
    <td class="codeline">      // location for this variable, and the Assignment doesn't match what</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeline">      // we'd expect to see in memory.</td>
    <td class="lineNumber">1609</td>
    <td class="codeline">      // we'd expect to see in memory.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeline">      Assignment DbgAV = LiveSet->getAssignment(BlockInfo::Debug, Var);</td>
    <td class="lineNumber">1610</td>
    <td class="codeline">      Assignment DbgAV = LiveSet->getAssignment(BlockInfo::Debug, Var);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeline">      if (DbgAV.Status == Assignment::NoneOrPhi) {</td>
    <td class="lineNumber">1611</td>
    <td class="codeline">      if (DbgAV.Status == Assignment::NoneOrPhi) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeline">        // We need to terminate any previously open location now.</td>
    <td class="lineNumber">1612</td>
    <td class="codeline">        // We need to terminate any previously open location now.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "None, No Debug value available\n";);</td>
    <td class="lineNumber">1613</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "None, No Debug value available\n";);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeline">        setLocKind(LiveSet, Var, LocKind::None);</td>
    <td class="lineNumber">1614</td>
    <td class="codeline">        setLocKind(LiveSet, Var, LocKind::None);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeline">        emitDbgValue(LocKind::None, DAI, &I);</td>
    <td class="lineNumber">1615</td>
    <td class="codeline">        emitDbgValue(LocKind::None, DAI, &I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">1616</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeline">        // The previous DebugValue Value can be used here.</td>
    <td class="lineNumber">1617</td>
    <td class="codeline">        // The previous DebugValue Value can be used here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "Val, Debug value is Known\n";);</td>
    <td class="lineNumber">1618</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "Val, Debug value is Known\n";);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeline">        setLocKind(LiveSet, Var, LocKind::Val);</td>
    <td class="lineNumber">1619</td>
    <td class="codeline">        setLocKind(LiveSet, Var, LocKind::Val);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeline">        if (DbgAV.Source) {</td>
    <td class="lineNumber">1620</td>
    <td class="codeline">        if (DbgAV.Source) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeline">          emitDbgValue(LocKind::Val, DbgAV.Source, &I);</td>
    <td class="lineNumber">1621</td>
    <td class="codeline">          emitDbgValue(LocKind::Val, DbgAV.Source, &I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeline">        } else {</td>
    <td class="lineNumber">1622</td>
    <td class="codeline">        } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeline">          // PrevAV.Source is nullptr so we must emit undef here.</td>
    <td class="lineNumber">1623</td>
    <td class="codeline">          // PrevAV.Source is nullptr so we must emit undef here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeline">          emitDbgValue(LocKind::None, DAI, &I);</td>
    <td class="lineNumber">1624</td>
    <td class="codeline">          emitDbgValue(LocKind::None, DAI, &I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1625</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1626</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeline">    } break;</td>
    <td class="lineNumber">1627</td>
    <td class="codeline">    } break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeline">    case LocKind::None: {</td>
    <td class="lineNumber">1628</td>
    <td class="codeline">    case LocKind::None: {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeline">      // There's been an assignment to memory and we currently are</td>
    <td class="lineNumber">1629</td>
    <td class="codeline">      // There's been an assignment to memory and we currently are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeline">      // not tracking a location for the variable. Do not emit anything.</td>
    <td class="lineNumber">1630</td>
    <td class="codeline">      // not tracking a location for the variable. Do not emit anything.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "None, (unchanged)\n";);</td>
    <td class="lineNumber">1631</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "None, (unchanged)\n";);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeline">      setLocKind(LiveSet, Var, LocKind::None);</td>
    <td class="lineNumber">1632</td>
    <td class="codeline">      setLocKind(LiveSet, Var, LocKind::None);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeline">    } break;</td>
    <td class="lineNumber">1633</td>
    <td class="codeline">    } break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1634</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1635</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1636</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeline"></td>
    <td class="lineNumber">1637</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeline">void AssignmentTrackingLowering::processDbgAssign(DbgAssignIntrinsic &DAI,</td>
    <td class="lineNumber">1638</td>
    <td class="codeline">void AssignmentTrackingLowering::processDbgAssign(DbgAssignIntrinsic &DAI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeline">                                                  BlockInfo *LiveSet) {</td>
    <td class="lineNumber">1639</td>
    <td class="codeline">                                                  BlockInfo *LiveSet) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeline">  // Only bother tracking variables that are at some point stack homed. Other</td>
    <td class="lineNumber">1640</td>
    <td class="codeline">  // Only bother tracking variables that are at some point stack homed. Other</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeline">  // variables can be dealt with trivially later.</td>
    <td class="lineNumber">1641</td>
    <td class="codeline">  // variables can be dealt with trivially later.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeline">  if (!VarsWithStackSlot->count(getAggregate(&DAI)))</td>
    <td class="lineNumber">1642</td>
    <td class="codeline">  if (!VarsWithStackSlot->count(getAggregate(&DAI)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">1643</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeline"></td>
    <td class="lineNumber">1644</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeline">  VariableID Var = getVariableID(DebugVariable(&DAI));</td>
    <td class="lineNumber">1645</td>
    <td class="codeline">  VariableID Var = getVariableID(DebugVariable(&DAI));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeline">  Assignment AV = Assignment::make(getIDFromMarker(DAI), &DAI);</td>
    <td class="lineNumber">1646</td>
    <td class="codeline">  Assignment AV = Assignment::make(getIDFromMarker(DAI), &DAI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeline">  addDbgDef(LiveSet, Var, AV);</td>
    <td class="lineNumber">1647</td>
    <td class="codeline">  addDbgDef(LiveSet, Var, AV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeline"></td>
    <td class="lineNumber">1648</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "processDbgAssign on " << DAI << "\n";);</td>
    <td class="lineNumber">1649</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "processDbgAssign on " << DAI << "\n";);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "   LiveLoc " << locStr(getLocKind(LiveSet, Var))</td>
    <td class="lineNumber">1650</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "   LiveLoc " << locStr(getLocKind(LiveSet, Var))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeline">                    << " -> ");</td>
    <td class="lineNumber">1651</td>
    <td class="codeline">                    << " -> ");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeline"></td>
    <td class="lineNumber">1652</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeline">  // Check if the DebugValue and StackHomeValue both hold the same</td>
    <td class="lineNumber">1653</td>
    <td class="codeline">  // Check if the DebugValue and StackHomeValue both hold the same</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeline">  // Assignment.</td>
    <td class="lineNumber">1654</td>
    <td class="codeline">  // Assignment.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeline">  if (hasVarWithAssignment(LiveSet, BlockInfo::Stack, Var, AV)) {</td>
    <td class="lineNumber">1655</td>
    <td class="codeline">  if (hasVarWithAssignment(LiveSet, BlockInfo::Stack, Var, AV)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeline">    // They match. We can use the stack home because the debug intrinsics state</td>
    <td class="lineNumber">1656</td>
    <td class="codeline">    // They match. We can use the stack home because the debug intrinsics state</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeline">    // that an assignment happened here, and we know that specific assignment</td>
    <td class="lineNumber">1657</td>
    <td class="codeline">    // that an assignment happened here, and we know that specific assignment</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeline">    // was the last one to take place in memory for this variable.</td>
    <td class="lineNumber">1658</td>
    <td class="codeline">    // was the last one to take place in memory for this variable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeline">    LocKind Kind;</td>
    <td class="lineNumber">1659</td>
    <td class="codeline">    LocKind Kind;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeline">    if (DAI.isKillAddress()) {</td>
    <td class="lineNumber">1660</td>
    <td class="codeline">    if (DAI.isKillAddress()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeline">      LLVM_DEBUG(</td>
    <td class="lineNumber">1661</td>
    <td class="codeline">      LLVM_DEBUG(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeline">          dbgs()</td>
    <td class="lineNumber">1662</td>
    <td class="codeline">          dbgs()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeline">              << "Val, Stack matches Debug program but address is killed\n";);</td>
    <td class="lineNumber">1663</td>
    <td class="codeline">              << "Val, Stack matches Debug program but address is killed\n";);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeline">      Kind = LocKind::Val;</td>
    <td class="lineNumber">1664</td>
    <td class="codeline">      Kind = LocKind::Val;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">1665</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "Mem, Stack matches Debug program\n";);</td>
    <td class="lineNumber">1666</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "Mem, Stack matches Debug program\n";);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeline">      Kind = LocKind::Mem;</td>
    <td class="lineNumber">1667</td>
    <td class="codeline">      Kind = LocKind::Mem;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeline">    };</td>
    <td class="lineNumber">1668</td>
    <td class="codeline">    };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeline">    setLocKind(LiveSet, Var, Kind);</td>
    <td class="lineNumber">1669</td>
    <td class="codeline">    setLocKind(LiveSet, Var, Kind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeline">    emitDbgValue(Kind, &DAI, &DAI);</td>
    <td class="lineNumber">1670</td>
    <td class="codeline">    emitDbgValue(Kind, &DAI, &DAI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">1671</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeline">    // The last assignment to the memory location isn't the one that we want to</td>
    <td class="lineNumber">1672</td>
    <td class="codeline">    // The last assignment to the memory location isn't the one that we want to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeline">    // show to the user so emit a dbg.value(Value). Value may be undef.</td>
    <td class="lineNumber">1673</td>
    <td class="codeline">    // show to the user so emit a dbg.value(Value). Value may be undef.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Val, Stack contents is unknown\n";);</td>
    <td class="lineNumber">1674</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Val, Stack contents is unknown\n";);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeline">    setLocKind(LiveSet, Var, LocKind::Val);</td>
    <td class="lineNumber">1675</td>
    <td class="codeline">    setLocKind(LiveSet, Var, LocKind::Val);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeline">    emitDbgValue(LocKind::Val, &DAI, &DAI);</td>
    <td class="lineNumber">1676</td>
    <td class="codeline">    emitDbgValue(LocKind::Val, &DAI, &DAI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1677</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1678</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeline"></td>
    <td class="lineNumber">1679</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeline">void AssignmentTrackingLowering::processDbgValue(DbgValueInst &DVI,</td>
    <td class="lineNumber">1680</td>
    <td class="codeline">void AssignmentTrackingLowering::processDbgValue(DbgValueInst &DVI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeline">                                                 BlockInfo *LiveSet) {</td>
    <td class="lineNumber">1681</td>
    <td class="codeline">                                                 BlockInfo *LiveSet) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeline">  // Only other tracking variables that are at some point stack homed.</td>
    <td class="lineNumber">1682</td>
    <td class="codeline">  // Only other tracking variables that are at some point stack homed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeline">  // Other variables can be dealt with trivally later.</td>
    <td class="lineNumber">1683</td>
    <td class="codeline">  // Other variables can be dealt with trivally later.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeline">  if (!VarsWithStackSlot->count(getAggregate(&DVI)))</td>
    <td class="lineNumber">1684</td>
    <td class="codeline">  if (!VarsWithStackSlot->count(getAggregate(&DVI)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">1685</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeline"></td>
    <td class="lineNumber">1686</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeline">  VariableID Var = getVariableID(DebugVariable(&DVI));</td>
    <td class="lineNumber">1687</td>
    <td class="codeline">  VariableID Var = getVariableID(DebugVariable(&DVI));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeline">  // We have no ID to create an Assignment with so we mark this assignment as</td>
    <td class="lineNumber">1688</td>
    <td class="codeline">  // We have no ID to create an Assignment with so we mark this assignment as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeline">  // NoneOrPhi. Note that the dbg.value still exists, we just cannot determine</td>
    <td class="lineNumber">1689</td>
    <td class="codeline">  // NoneOrPhi. Note that the dbg.value still exists, we just cannot determine</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeline">  // the assignment responsible for setting this value.</td>
    <td class="lineNumber">1690</td>
    <td class="codeline">  // the assignment responsible for setting this value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeline">  // This is fine; dbg.values are essentially interchangable with unlinked</td>
    <td class="lineNumber">1691</td>
    <td class="codeline">  // This is fine; dbg.values are essentially interchangable with unlinked</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeline">  // dbg.assigns, and some passes such as mem2reg and instcombine add them to</td>
    <td class="lineNumber">1692</td>
    <td class="codeline">  // dbg.assigns, and some passes such as mem2reg and instcombine add them to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeline">  // PHIs for promoted variables.</td>
    <td class="lineNumber">1693</td>
    <td class="codeline">  // PHIs for promoted variables.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeline">  Assignment AV = Assignment::makeNoneOrPhi();</td>
    <td class="lineNumber">1694</td>
    <td class="codeline">  Assignment AV = Assignment::makeNoneOrPhi();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeline">  addDbgDef(LiveSet, Var, AV);</td>
    <td class="lineNumber">1695</td>
    <td class="codeline">  addDbgDef(LiveSet, Var, AV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeline"></td>
    <td class="lineNumber">1696</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "processDbgValue on " << DVI << "\n";);</td>
    <td class="lineNumber">1697</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "processDbgValue on " << DVI << "\n";);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "   LiveLoc " << locStr(getLocKind(LiveSet, Var))</td>
    <td class="lineNumber">1698</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "   LiveLoc " << locStr(getLocKind(LiveSet, Var))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeline">                    << " -> Val, dbg.value override");</td>
    <td class="lineNumber">1699</td>
    <td class="codeline">                    << " -> Val, dbg.value override");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeline"></td>
    <td class="lineNumber">1700</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeline">  setLocKind(LiveSet, Var, LocKind::Val);</td>
    <td class="lineNumber">1701</td>
    <td class="codeline">  setLocKind(LiveSet, Var, LocKind::Val);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeline">  emitDbgValue(LocKind::Val, &DVI, &DVI);</td>
    <td class="lineNumber">1702</td>
    <td class="codeline">  emitDbgValue(LocKind::Val, &DVI, &DVI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1703</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeline"></td>
    <td class="lineNumber">1704</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeline">static bool hasZeroSizedFragment(DbgVariableIntrinsic &DVI) {</td>
    <td class="lineNumber">1705</td>
    <td class="codeline">static bool hasZeroSizedFragment(DbgVariableIntrinsic &DVI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeline">  if (auto F = DVI.getExpression()->getFragmentInfo())</td>
    <td class="lineNumber">1706</td>
    <td class="codeline">  if (auto F = DVI.getExpression()->getFragmentInfo())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeline">    return F->SizeInBits == 0;</td>
    <td class="lineNumber">1707</td>
    <td class="codeline">    return F->SizeInBits == 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">1708</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1709</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeline"></td>
    <td class="lineNumber">1710</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeline">void AssignmentTrackingLowering::processDbgInstruction(</td>
    <td class="lineNumber">1711</td>
    <td class="codeline">void AssignmentTrackingLowering::processDbgInstruction(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeline">    DbgInfoIntrinsic &I, AssignmentTrackingLowering::BlockInfo *LiveSet) {</td>
    <td class="lineNumber">1712</td>
    <td class="codeline">    DbgInfoIntrinsic &I, AssignmentTrackingLowering::BlockInfo *LiveSet) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeline">  auto *DVI = dyn_cast<DbgVariableIntrinsic>(&I);</td>
    <td class="lineNumber">1713</td>
    <td class="codeline">  auto *DVI = dyn_cast<DbgVariableIntrinsic>(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeline">  if (!DVI)</td>
    <td class="lineNumber">1714</td>
    <td class="codeline">  if (!DVI)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">1715</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeline"></td>
    <td class="lineNumber">1716</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeline">  // Ignore assignments to zero bits of the variable.</td>
    <td class="lineNumber">1717</td>
    <td class="codeline">  // Ignore assignments to zero bits of the variable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeline">  if (hasZeroSizedFragment(*DVI))</td>
    <td class="lineNumber">1718</td>
    <td class="codeline">  if (hasZeroSizedFragment(*DVI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">1719</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeline"></td>
    <td class="lineNumber">1720</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeline">  if (auto *DAI = dyn_cast<DbgAssignIntrinsic>(&I))</td>
    <td class="lineNumber">1721</td>
    <td class="codeline">  if (auto *DAI = dyn_cast<DbgAssignIntrinsic>(&I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeline">    processDbgAssign(*DAI, LiveSet);</td>
    <td class="lineNumber">1722</td>
    <td class="codeline">    processDbgAssign(*DAI, LiveSet);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeline">  else if (auto *DVI = dyn_cast<DbgValueInst>(&I))</td>
    <td class="lineNumber">1723</td>
    <td class="codeline">  else if (auto *DVI = dyn_cast<DbgValueInst>(&I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeline">    processDbgValue(*DVI, LiveSet);</td>
    <td class="lineNumber">1724</td>
    <td class="codeline">    processDbgValue(*DVI, LiveSet);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1725</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeline"></td>
    <td class="lineNumber">1726</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeline">void AssignmentTrackingLowering::resetInsertionPoint(Instruction &After) {</td>
    <td class="lineNumber">1727</td>
    <td class="codeline">void AssignmentTrackingLowering::resetInsertionPoint(Instruction &After) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeline">  assert(!After.isTerminator() && "Can't insert after a terminator");</td>
    <td class="lineNumber">1728</td>
    <td class="codeline">  assert(!After.isTerminator() && "Can't insert after a terminator");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeline">  auto R = InsertBeforeMap.find(After.getNextNode());</td>
    <td class="lineNumber">1729</td>
    <td class="codeline">  auto R = InsertBeforeMap.find(After.getNextNode());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeline">  if (R == InsertBeforeMap.end())</td>
    <td class="lineNumber">1730</td>
    <td class="codeline">  if (R == InsertBeforeMap.end())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">1731</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeline">  R->second.clear();</td>
    <td class="lineNumber">1732</td>
    <td class="codeline">  R->second.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1733</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeline"></td>
    <td class="lineNumber">1734</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeline">void AssignmentTrackingLowering::process(BasicBlock &BB, BlockInfo *LiveSet) {</td>
    <td class="lineNumber">1735</td>
    <td class="codeline">void AssignmentTrackingLowering::process(BasicBlock &BB, BlockInfo *LiveSet) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeline">  for (auto II = BB.begin(), EI = BB.end(); II != EI;) {</td>
    <td class="lineNumber">1736</td>
    <td class="codeline">  for (auto II = BB.begin(), EI = BB.end(); II != EI;) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeline">    assert(VarsTouchedThisFrame.empty());</td>
    <td class="lineNumber">1737</td>
    <td class="codeline">    assert(VarsTouchedThisFrame.empty());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeline">    // Process the instructions in "frames". A "frame" includes a single</td>
    <td class="lineNumber">1738</td>
    <td class="codeline">    // Process the instructions in "frames". A "frame" includes a single</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeline">    // non-debug instruction followed any debug instructions before the</td>
    <td class="lineNumber">1739</td>
    <td class="codeline">    // non-debug instruction followed any debug instructions before the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeline">    // next non-debug instruction.</td>
    <td class="lineNumber">1740</td>
    <td class="codeline">    // next non-debug instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeline">    if (!isa<DbgInfoIntrinsic>(&*II)) {</td>
    <td class="lineNumber">1741</td>
    <td class="codeline">    if (!isa<DbgInfoIntrinsic>(&*II)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeline">      if (II->isTerminator())</td>
    <td class="lineNumber">1742</td>
    <td class="codeline">      if (II->isTerminator())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">1743</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeline">      resetInsertionPoint(*II);</td>
    <td class="lineNumber">1744</td>
    <td class="codeline">      resetInsertionPoint(*II);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeline">      processNonDbgInstruction(*II, LiveSet);</td>
    <td class="lineNumber">1745</td>
    <td class="codeline">      processNonDbgInstruction(*II, LiveSet);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeline">      assert(LiveSet->isValid());</td>
    <td class="lineNumber">1746</td>
    <td class="codeline">      assert(LiveSet->isValid());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeline">      ++II;</td>
    <td class="lineNumber">1747</td>
    <td class="codeline">      ++II;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1748</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeline">    while (II != EI) {</td>
    <td class="lineNumber">1749</td>
    <td class="codeline">    while (II != EI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeline">      auto *Dbg = dyn_cast<DbgInfoIntrinsic>(&*II);</td>
    <td class="lineNumber">1750</td>
    <td class="codeline">      auto *Dbg = dyn_cast<DbgInfoIntrinsic>(&*II);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeline">      if (!Dbg)</td>
    <td class="lineNumber">1751</td>
    <td class="codeline">      if (!Dbg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">1752</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeline">      resetInsertionPoint(*II);</td>
    <td class="lineNumber">1753</td>
    <td class="codeline">      resetInsertionPoint(*II);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeline">      processDbgInstruction(*Dbg, LiveSet);</td>
    <td class="lineNumber">1754</td>
    <td class="codeline">      processDbgInstruction(*Dbg, LiveSet);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeline">      assert(LiveSet->isValid());</td>
    <td class="lineNumber">1755</td>
    <td class="codeline">      assert(LiveSet->isValid());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeline">      ++II;</td>
    <td class="lineNumber">1756</td>
    <td class="codeline">      ++II;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1757</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeline"></td>
    <td class="lineNumber">1758</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeline">    // We've processed everything in the "frame". Now determine which variables</td>
    <td class="lineNumber">1759</td>
    <td class="codeline">    // We've processed everything in the "frame". Now determine which variables</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeline">    // cannot be represented by a dbg.declare.</td>
    <td class="lineNumber">1760</td>
    <td class="codeline">    // cannot be represented by a dbg.declare.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeline">    for (auto Var : VarsTouchedThisFrame) {</td>
    <td class="lineNumber">1761</td>
    <td class="codeline">    for (auto Var : VarsTouchedThisFrame) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeline">      LocKind Loc = getLocKind(LiveSet, Var);</td>
    <td class="lineNumber">1762</td>
    <td class="codeline">      LocKind Loc = getLocKind(LiveSet, Var);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeline">      // If a variable's LocKind is anything other than LocKind::Mem then we</td>
    <td class="lineNumber">1763</td>
    <td class="codeline">      // If a variable's LocKind is anything other than LocKind::Mem then we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeline">      // must note that it cannot be represented with a dbg.declare.</td>
    <td class="lineNumber">1764</td>
    <td class="codeline">      // must note that it cannot be represented with a dbg.declare.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeline">      // Note that this check is enough without having to check the result of</td>
    <td class="lineNumber">1765</td>
    <td class="codeline">      // Note that this check is enough without having to check the result of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeline">      // joins() because for join to produce anything other than Mem after</td>
    <td class="lineNumber">1766</td>
    <td class="codeline">      // joins() because for join to produce anything other than Mem after</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeline">      // we've already seen a Mem we'd be joining None or Val with Mem. In that</td>
    <td class="lineNumber">1767</td>
    <td class="codeline">      // we've already seen a Mem we'd be joining None or Val with Mem. In that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeline">      // case, we've already hit this codepath when we set the LocKind to Val</td>
    <td class="lineNumber">1768</td>
    <td class="codeline">      // case, we've already hit this codepath when we set the LocKind to Val</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeline">      // or None in that block.</td>
    <td class="lineNumber">1769</td>
    <td class="codeline">      // or None in that block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeline">      if (Loc != LocKind::Mem) {</td>
    <td class="lineNumber">1770</td>
    <td class="codeline">      if (Loc != LocKind::Mem) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeline">        DebugVariable DbgVar = FnVarLocs->getVariable(Var);</td>
    <td class="lineNumber">1771</td>
    <td class="codeline">        DebugVariable DbgVar = FnVarLocs->getVariable(Var);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeline">        DebugAggregate Aggr{DbgVar.getVariable(), DbgVar.getInlinedAt()};</td>
    <td class="lineNumber">1772</td>
    <td class="codeline">        DebugAggregate Aggr{DbgVar.getVariable(), DbgVar.getInlinedAt()};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeline">        NotAlwaysStackHomed.insert(Aggr);</td>
    <td class="lineNumber">1773</td>
    <td class="codeline">        NotAlwaysStackHomed.insert(Aggr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1774</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1775</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeline">    VarsTouchedThisFrame.clear();</td>
    <td class="lineNumber">1776</td>
    <td class="codeline">    VarsTouchedThisFrame.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1777</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1778</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeline"></td>
    <td class="lineNumber">1779</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeline">AssignmentTrackingLowering::LocKind</td>
    <td class="lineNumber">1780</td>
    <td class="codeline">AssignmentTrackingLowering::LocKind</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeline">AssignmentTrackingLowering::joinKind(LocKind A, LocKind B) {</td>
    <td class="lineNumber">1781</td>
    <td class="codeline">AssignmentTrackingLowering::joinKind(LocKind A, LocKind B) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeline">  // Partial order:</td>
    <td class="lineNumber">1782</td>
    <td class="codeline">  // Partial order:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeline">  // None > Mem, Val</td>
    <td class="lineNumber">1783</td>
    <td class="codeline">  // None > Mem, Val</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeline">  return A == B ? A : LocKind::None;</td>
    <td class="lineNumber">1784</td>
    <td class="codeline">  return A == B ? A : LocKind::None;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1785</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeline"></td>
    <td class="lineNumber">1786</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeline">AssignmentTrackingLowering::Assignment</td>
    <td class="lineNumber">1787</td>
    <td class="codeline">AssignmentTrackingLowering::Assignment</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeline">AssignmentTrackingLowering::joinAssignment(const Assignment &A,</td>
    <td class="lineNumber">1788</td>
    <td class="codeline">AssignmentTrackingLowering::joinAssignment(const Assignment &A,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeline">                                           const Assignment &B) {</td>
    <td class="lineNumber">1789</td>
    <td class="codeline">                                           const Assignment &B) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeline">  // Partial order:</td>
    <td class="lineNumber">1790</td>
    <td class="codeline">  // Partial order:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeline">  // NoneOrPhi(null, null) > Known(v, ?s)</td>
    <td class="lineNumber">1791</td>
    <td class="codeline">  // NoneOrPhi(null, null) > Known(v, ?s)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeline"></td>
    <td class="lineNumber">1792</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="codeline">  // If either are NoneOrPhi the join is NoneOrPhi.</td>
    <td class="lineNumber">1793</td>
    <td class="codeline">  // If either are NoneOrPhi the join is NoneOrPhi.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="codeline">  // If either value is different then the result is</td>
    <td class="lineNumber">1794</td>
    <td class="codeline">  // If either value is different then the result is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="codeline">  // NoneOrPhi (joining two values is a Phi).</td>
    <td class="lineNumber">1795</td>
    <td class="codeline">  // NoneOrPhi (joining two values is a Phi).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="codeline">  if (!A.isSameSourceAssignment(B))</td>
    <td class="lineNumber">1796</td>
    <td class="codeline">  if (!A.isSameSourceAssignment(B))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="codeline">    return Assignment::makeNoneOrPhi();</td>
    <td class="lineNumber">1797</td>
    <td class="codeline">    return Assignment::makeNoneOrPhi();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="codeline">  if (A.Status == Assignment::NoneOrPhi)</td>
    <td class="lineNumber">1798</td>
    <td class="codeline">  if (A.Status == Assignment::NoneOrPhi)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="codeline">    return Assignment::makeNoneOrPhi();</td>
    <td class="lineNumber">1799</td>
    <td class="codeline">    return Assignment::makeNoneOrPhi();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="codeline"></td>
    <td class="lineNumber">1800</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="codeline">  // Source is used to lookup the value + expression in the debug program if</td>
    <td class="lineNumber">1801</td>
    <td class="codeline">  // Source is used to lookup the value + expression in the debug program if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="codeline">  // the stack slot gets assigned a value earlier than expected. Because</td>
    <td class="lineNumber">1802</td>
    <td class="codeline">  // the stack slot gets assigned a value earlier than expected. Because</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="codeline">  // we're only tracking the one dbg.assign, we can't capture debug PHIs.</td>
    <td class="lineNumber">1803</td>
    <td class="codeline">  // we're only tracking the one dbg.assign, we can't capture debug PHIs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="codeline">  // It's unlikely that we're losing out on much coverage by avoiding that</td>
    <td class="lineNumber">1804</td>
    <td class="codeline">  // It's unlikely that we're losing out on much coverage by avoiding that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="codeline">  // extra work.</td>
    <td class="lineNumber">1805</td>
    <td class="codeline">  // extra work.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="codeline">  // The Source may differ in this situation:</td>
    <td class="lineNumber">1806</td>
    <td class="codeline">  // The Source may differ in this situation:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="codeline">  // Pred.1:</td>
    <td class="lineNumber">1807</td>
    <td class="codeline">  // Pred.1:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="codeline">  //   dbg.assign i32 0, ..., !1, ...</td>
    <td class="lineNumber">1808</td>
    <td class="codeline">  //   dbg.assign i32 0, ..., !1, ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="codeline">  // Pred.2:</td>
    <td class="lineNumber">1809</td>
    <td class="codeline">  // Pred.2:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="codeline">  //   dbg.assign i32 1, ..., !1, ...</td>
    <td class="lineNumber">1810</td>
    <td class="codeline">  //   dbg.assign i32 1, ..., !1, ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="codeline">  // Here the same assignment (!1) was performed in both preds in the source,</td>
    <td class="lineNumber">1811</td>
    <td class="codeline">  // Here the same assignment (!1) was performed in both preds in the source,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="codeline">  // but we can't use either one unless they are identical (e.g. .we don't</td>
    <td class="lineNumber">1812</td>
    <td class="codeline">  // but we can't use either one unless they are identical (e.g. .we don't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="codeline">  // want to arbitrarily pick between constant values).</td>
    <td class="lineNumber">1813</td>
    <td class="codeline">  // want to arbitrarily pick between constant values).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="codeline">  auto JoinSource = [&]() -> DbgAssignIntrinsic * {</td>
    <td class="lineNumber">1814</td>
    <td class="codeline">  auto JoinSource = [&]() -> DbgAssignIntrinsic * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="codeline">    if (A.Source == B.Source)</td>
    <td class="lineNumber">1815</td>
    <td class="codeline">    if (A.Source == B.Source)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="codeline">      return A.Source;</td>
    <td class="lineNumber">1816</td>
    <td class="codeline">      return A.Source;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="codeline">    if (A.Source == nullptr || B.Source == nullptr)</td>
    <td class="lineNumber">1817</td>
    <td class="codeline">    if (A.Source == nullptr || B.Source == nullptr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="codeline">      return nullptr;</td>
    <td class="lineNumber">1818</td>
    <td class="codeline">      return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="codeline">    if (A.Source->isIdenticalTo(B.Source))</td>
    <td class="lineNumber">1819</td>
    <td class="codeline">    if (A.Source->isIdenticalTo(B.Source))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="codeline">      return A.Source;</td>
    <td class="lineNumber">1820</td>
    <td class="codeline">      return A.Source;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">1821</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1822</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="codeline">  DbgAssignIntrinsic *Source = JoinSource();</td>
    <td class="lineNumber">1823</td>
    <td class="codeline">  DbgAssignIntrinsic *Source = JoinSource();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="codeline">  assert(A.Status == B.Status && A.Status == Assignment::Known);</td>
    <td class="lineNumber">1824</td>
    <td class="codeline">  assert(A.Status == B.Status && A.Status == Assignment::Known);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="codeline">  assert(A.ID == B.ID);</td>
    <td class="lineNumber">1825</td>
    <td class="codeline">  assert(A.ID == B.ID);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="codeline">  return Assignment::make(A.ID, Source);</td>
    <td class="lineNumber">1826</td>
    <td class="codeline">  return Assignment::make(A.ID, Source);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1827</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="codeline"></td>
    <td class="lineNumber">1828</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="codeline">AssignmentTrackingLowering::BlockInfo</td>
    <td class="lineNumber">1829</td>
    <td class="codeline">AssignmentTrackingLowering::BlockInfo</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="codeline">AssignmentTrackingLowering::joinBlockInfo(const BlockInfo &A,</td>
    <td class="lineNumber">1830</td>
    <td class="codeline">AssignmentTrackingLowering::joinBlockInfo(const BlockInfo &A,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="codeline">                                          const BlockInfo &B) {</td>
    <td class="lineNumber">1831</td>
    <td class="codeline">                                          const BlockInfo &B) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="codeline">  return BlockInfo::join(A, B, TrackedVariablesVectorSize);</td>
    <td class="lineNumber">1832</td>
    <td class="codeline">  return BlockInfo::join(A, B, TrackedVariablesVectorSize);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1833</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="codeline"></td>
    <td class="lineNumber">1834</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="codeline">bool AssignmentTrackingLowering::join(</td>
    <td class="lineNumber">1835</td>
    <td class="codeline">bool AssignmentTrackingLowering::join(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="codeline">    const BasicBlock &BB, const SmallPtrSet<BasicBlock *, 16> &Visited) {</td>
    <td class="lineNumber">1836</td>
    <td class="codeline">    const BasicBlock &BB, const SmallPtrSet<BasicBlock *, 16> &Visited) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="codeline"></td>
    <td class="lineNumber">1837</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="codeline">  SmallVector<const BasicBlock *> VisitedPreds;</td>
    <td class="lineNumber">1838</td>
    <td class="codeline">  SmallVector<const BasicBlock *> VisitedPreds;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="codeline">  // Ignore backedges if we have not visited the predecessor yet. As the</td>
    <td class="lineNumber">1839</td>
    <td class="codeline">  // Ignore backedges if we have not visited the predecessor yet. As the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="codeline">  // predecessor hasn't yet had locations propagated into it, most locations</td>
    <td class="lineNumber">1840</td>
    <td class="codeline">  // predecessor hasn't yet had locations propagated into it, most locations</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="codeline">  // will not yet be valid, so treat them as all being uninitialized and</td>
    <td class="lineNumber">1841</td>
    <td class="codeline">  // will not yet be valid, so treat them as all being uninitialized and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="codeline">  // potentially valid. If a location guessed to be correct here is</td>
    <td class="lineNumber">1842</td>
    <td class="codeline">  // potentially valid. If a location guessed to be correct here is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="codeline">  // invalidated later, we will remove it when we revisit this block. This</td>
    <td class="lineNumber">1843</td>
    <td class="codeline">  // invalidated later, we will remove it when we revisit this block. This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="codeline">  // is essentially the same as initialising all LocKinds and Assignments to</td>
    <td class="lineNumber">1844</td>
    <td class="codeline">  // is essentially the same as initialising all LocKinds and Assignments to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="codeline">  // an implicit ⊥ value which is the identity value for the join operation.</td>
    <td class="lineNumber">1845</td>
    <td class="codeline">  // an implicit ⊥ value which is the identity value for the join operation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="codeline">  for (auto I = pred_begin(&BB), E = pred_end(&BB); I != E; I++) {</td>
    <td class="lineNumber">1846</td>
    <td class="codeline">  for (auto I = pred_begin(&BB), E = pred_end(&BB); I != E; I++) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="codeline">    const BasicBlock *Pred = *I;</td>
    <td class="lineNumber">1847</td>
    <td class="codeline">    const BasicBlock *Pred = *I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="codeline">    if (Visited.count(Pred))</td>
    <td class="lineNumber">1848</td>
    <td class="codeline">    if (Visited.count(Pred))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="codeline">      VisitedPreds.push_back(Pred);</td>
    <td class="lineNumber">1849</td>
    <td class="codeline">      VisitedPreds.push_back(Pred);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1850</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="codeline"></td>
    <td class="lineNumber">1851</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="codeline">  // No preds visited yet.</td>
    <td class="lineNumber">1852</td>
    <td class="codeline">  // No preds visited yet.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="codeline">  if (VisitedPreds.empty()) {</td>
    <td class="lineNumber">1853</td>
    <td class="codeline">  if (VisitedPreds.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="codeline">    auto It = LiveIn.try_emplace(&BB, BlockInfo());</td>
    <td class="lineNumber">1854</td>
    <td class="codeline">    auto It = LiveIn.try_emplace(&BB, BlockInfo());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="codeline">    bool DidInsert = It.second;</td>
    <td class="lineNumber">1855</td>
    <td class="codeline">    bool DidInsert = It.second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="codeline">    if (DidInsert)</td>
    <td class="lineNumber">1856</td>
    <td class="codeline">    if (DidInsert)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="codeline">      It.first->second.init(TrackedVariablesVectorSize);</td>
    <td class="lineNumber">1857</td>
    <td class="codeline">      It.first->second.init(TrackedVariablesVectorSize);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="codeline">    return /*Changed*/ DidInsert;</td>
    <td class="lineNumber">1858</td>
    <td class="codeline">    return /*Changed*/ DidInsert;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1859</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="codeline"></td>
    <td class="lineNumber">1860</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="codeline">  // Exactly one visited pred. Copy the LiveOut from that pred into BB LiveIn.</td>
    <td class="lineNumber">1861</td>
    <td class="codeline">  // Exactly one visited pred. Copy the LiveOut from that pred into BB LiveIn.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="codeline">  if (VisitedPreds.size() == 1) {</td>
    <td class="lineNumber">1862</td>
    <td class="codeline">  if (VisitedPreds.size() == 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="codeline">    const BlockInfo &PredLiveOut = LiveOut.find(VisitedPreds[0])->second;</td>
    <td class="lineNumber">1863</td>
    <td class="codeline">    const BlockInfo &PredLiveOut = LiveOut.find(VisitedPreds[0])->second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="codeline">    auto CurrentLiveInEntry = LiveIn.find(&BB);</td>
    <td class="lineNumber">1864</td>
    <td class="codeline">    auto CurrentLiveInEntry = LiveIn.find(&BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="codeline"></td>
    <td class="lineNumber">1865</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="codeline">    // Check if there isn't an entry, or there is but the LiveIn set has</td>
    <td class="lineNumber">1866</td>
    <td class="codeline">    // Check if there isn't an entry, or there is but the LiveIn set has</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="codeline">    // changed (expensive check).</td>
    <td class="lineNumber">1867</td>
    <td class="codeline">    // changed (expensive check).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="codeline">    if (CurrentLiveInEntry == LiveIn.end())</td>
    <td class="lineNumber">1868</td>
    <td class="codeline">    if (CurrentLiveInEntry == LiveIn.end())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="codeline">      LiveIn.insert(std::make_pair(&BB, PredLiveOut));</td>
    <td class="lineNumber">1869</td>
    <td class="codeline">      LiveIn.insert(std::make_pair(&BB, PredLiveOut));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="codeline">    else if (PredLiveOut != CurrentLiveInEntry->second)</td>
    <td class="lineNumber">1870</td>
    <td class="codeline">    else if (PredLiveOut != CurrentLiveInEntry->second)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="codeline">      CurrentLiveInEntry->second = PredLiveOut;</td>
    <td class="lineNumber">1871</td>
    <td class="codeline">      CurrentLiveInEntry->second = PredLiveOut;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">1872</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="codeline">      return /*Changed*/ false;</td>
    <td class="lineNumber">1873</td>
    <td class="codeline">      return /*Changed*/ false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="codeline">    return /*Changed*/ true;</td>
    <td class="lineNumber">1874</td>
    <td class="codeline">    return /*Changed*/ true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1875</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="codeline"></td>
    <td class="lineNumber">1876</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="codeline">  // More than one pred. Join LiveOuts of blocks 1 and 2.</td>
    <td class="lineNumber">1877</td>
    <td class="codeline">  // More than one pred. Join LiveOuts of blocks 1 and 2.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="codeline">  assert(VisitedPreds.size() > 1);</td>
    <td class="lineNumber">1878</td>
    <td class="codeline">  assert(VisitedPreds.size() > 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="codeline">  const BlockInfo &PredLiveOut0 = LiveOut.find(VisitedPreds[0])->second;</td>
    <td class="lineNumber">1879</td>
    <td class="codeline">  const BlockInfo &PredLiveOut0 = LiveOut.find(VisitedPreds[0])->second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="codeline">  const BlockInfo &PredLiveOut1 = LiveOut.find(VisitedPreds[1])->second;</td>
    <td class="lineNumber">1880</td>
    <td class="codeline">  const BlockInfo &PredLiveOut1 = LiveOut.find(VisitedPreds[1])->second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="codeline">  BlockInfo BBLiveIn = joinBlockInfo(PredLiveOut0, PredLiveOut1);</td>
    <td class="lineNumber">1881</td>
    <td class="codeline">  BlockInfo BBLiveIn = joinBlockInfo(PredLiveOut0, PredLiveOut1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="codeline"></td>
    <td class="lineNumber">1882</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="codeline">  // Join the LiveOuts of subsequent blocks.</td>
    <td class="lineNumber">1883</td>
    <td class="codeline">  // Join the LiveOuts of subsequent blocks.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="codeline">  ArrayRef Tail = ArrayRef(VisitedPreds).drop_front(2);</td>
    <td class="lineNumber">1884</td>
    <td class="codeline">  ArrayRef Tail = ArrayRef(VisitedPreds).drop_front(2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="codeline">  for (const BasicBlock *Pred : Tail) {</td>
    <td class="lineNumber">1885</td>
    <td class="codeline">  for (const BasicBlock *Pred : Tail) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="codeline">    const auto &PredLiveOut = LiveOut.find(Pred);</td>
    <td class="lineNumber">1886</td>
    <td class="codeline">    const auto &PredLiveOut = LiveOut.find(Pred);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="codeline">    assert(PredLiveOut != LiveOut.end() &&</td>
    <td class="lineNumber">1887</td>
    <td class="codeline">    assert(PredLiveOut != LiveOut.end() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="codeline">           "block should have been processed already");</td>
    <td class="lineNumber">1888</td>
    <td class="codeline">           "block should have been processed already");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="codeline">    BBLiveIn = joinBlockInfo(std::move(BBLiveIn), PredLiveOut->second);</td>
    <td class="lineNumber">1889</td>
    <td class="codeline">    BBLiveIn = joinBlockInfo(std::move(BBLiveIn), PredLiveOut->second);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1890</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="codeline"></td>
    <td class="lineNumber">1891</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="codeline">  // Save the joined result for BB.</td>
    <td class="lineNumber">1892</td>
    <td class="codeline">  // Save the joined result for BB.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="codeline">  auto CurrentLiveInEntry = LiveIn.find(&BB);</td>
    <td class="lineNumber">1893</td>
    <td class="codeline">  auto CurrentLiveInEntry = LiveIn.find(&BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="codeline">  // Check if there isn't an entry, or there is but the LiveIn set has changed</td>
    <td class="lineNumber">1894</td>
    <td class="codeline">  // Check if there isn't an entry, or there is but the LiveIn set has changed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="codeline">  // (expensive check).</td>
    <td class="lineNumber">1895</td>
    <td class="codeline">  // (expensive check).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="codeline">  if (CurrentLiveInEntry == LiveIn.end())</td>
    <td class="lineNumber">1896</td>
    <td class="codeline">  if (CurrentLiveInEntry == LiveIn.end())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="codeline">    LiveIn.try_emplace(&BB, std::move(BBLiveIn));</td>
    <td class="lineNumber">1897</td>
    <td class="codeline">    LiveIn.try_emplace(&BB, std::move(BBLiveIn));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="codeline">  else if (BBLiveIn != CurrentLiveInEntry->second)</td>
    <td class="lineNumber">1898</td>
    <td class="codeline">  else if (BBLiveIn != CurrentLiveInEntry->second)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="codeline">    CurrentLiveInEntry->second = std::move(BBLiveIn);</td>
    <td class="lineNumber">1899</td>
    <td class="codeline">    CurrentLiveInEntry->second = std::move(BBLiveIn);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">1900</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="codeline">    return /*Changed*/ false;</td>
    <td class="lineNumber">1901</td>
    <td class="codeline">    return /*Changed*/ false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="codeline">  return /*Changed*/ true;</td>
    <td class="lineNumber">1902</td>
    <td class="codeline">  return /*Changed*/ true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1903</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="codeline"></td>
    <td class="lineNumber">1904</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="codeline">/// Return true if A fully contains B.</td>
    <td class="lineNumber">1905</td>
    <td class="codeline">/// Return true if A fully contains B.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="codeline">static bool fullyContains(DIExpression::FragmentInfo A,</td>
    <td class="lineNumber">1906</td>
    <td class="codeline">static bool fullyContains(DIExpression::FragmentInfo A,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="codeline">                          DIExpression::FragmentInfo B) {</td>
    <td class="lineNumber">1907</td>
    <td class="codeline">                          DIExpression::FragmentInfo B) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="codeline">  auto ALeft = A.OffsetInBits;</td>
    <td class="lineNumber">1908</td>
    <td class="codeline">  auto ALeft = A.OffsetInBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="codeline">  auto BLeft = B.OffsetInBits;</td>
    <td class="lineNumber">1909</td>
    <td class="codeline">  auto BLeft = B.OffsetInBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="codeline">  if (BLeft < ALeft)</td>
    <td class="lineNumber">1910</td>
    <td class="codeline">  if (BLeft < ALeft)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1911</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="codeline"></td>
    <td class="lineNumber">1912</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="codeline">  auto ARight = ALeft + A.SizeInBits;</td>
    <td class="lineNumber">1913</td>
    <td class="codeline">  auto ARight = ALeft + A.SizeInBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="codeline">  auto BRight = BLeft + B.SizeInBits;</td>
    <td class="lineNumber">1914</td>
    <td class="codeline">  auto BRight = BLeft + B.SizeInBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="codeline">  if (BRight > ARight)</td>
    <td class="lineNumber">1915</td>
    <td class="codeline">  if (BRight > ARight)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1916</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">1917</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1918</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="codeline"></td>
    <td class="lineNumber">1919</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="codeline">static std::optional<at::AssignmentInfo></td>
    <td class="lineNumber">1920</td>
    <td class="codeline">static std::optional<at::AssignmentInfo></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="codeline">getUntaggedStoreAssignmentInfo(const Instruction &I, const DataLayout &Layout) {</td>
    <td class="lineNumber">1921</td>
    <td class="codeline">getUntaggedStoreAssignmentInfo(const Instruction &I, const DataLayout &Layout) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="codeline">  // Don't bother checking if this is an AllocaInst. We know this</td>
    <td class="lineNumber">1922</td>
    <td class="codeline">  // Don't bother checking if this is an AllocaInst. We know this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="codeline">  // instruction has no tag which means there are no variables associated</td>
    <td class="lineNumber">1923</td>
    <td class="codeline">  // instruction has no tag which means there are no variables associated</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="codeline">  // with it.</td>
    <td class="lineNumber">1924</td>
    <td class="codeline">  // with it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="codeline">  if (const auto *SI = dyn_cast<StoreInst>(&I))</td>
    <td class="lineNumber">1925</td>
    <td class="codeline">  if (const auto *SI = dyn_cast<StoreInst>(&I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="codeline">    return at::getAssignmentInfo(Layout, SI);</td>
    <td class="lineNumber">1926</td>
    <td class="codeline">    return at::getAssignmentInfo(Layout, SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="codeline">  if (const auto *MI = dyn_cast<MemIntrinsic>(&I))</td>
    <td class="lineNumber">1927</td>
    <td class="codeline">  if (const auto *MI = dyn_cast<MemIntrinsic>(&I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="codeline">    return at::getAssignmentInfo(Layout, MI);</td>
    <td class="lineNumber">1928</td>
    <td class="codeline">    return at::getAssignmentInfo(Layout, MI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="codeline">  // Alloca or non-store-like inst.</td>
    <td class="lineNumber">1929</td>
    <td class="codeline">  // Alloca or non-store-like inst.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="codeline">  return std::nullopt;</td>
    <td class="lineNumber">1930</td>
    <td class="codeline">  return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1931</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="codeline"></td>
    <td class="lineNumber">1932</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="codeline">/// Build a map of {Variable x: Variables y} where all variable fragments</td>
    <td class="lineNumber">1933</td>
    <td class="codeline">/// Build a map of {Variable x: Variables y} where all variable fragments</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="codeline">/// contained within the variable fragment x are in set y. This means that</td>
    <td class="lineNumber">1934</td>
    <td class="codeline">/// contained within the variable fragment x are in set y. This means that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="codeline">/// y does not contain all overlaps because partial overlaps are excluded.</td>
    <td class="lineNumber">1935</td>
    <td class="codeline">/// y does not contain all overlaps because partial overlaps are excluded.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1936</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="codeline">/// While we're iterating over the function, add single location defs for</td>
    <td class="lineNumber">1937</td>
    <td class="codeline">/// While we're iterating over the function, add single location defs for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="codeline">/// dbg.declares to \p FnVarLocs.</td>
    <td class="lineNumber">1938</td>
    <td class="codeline">/// dbg.declares to \p FnVarLocs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1939</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="codeline">/// Variables that are interesting to this pass in are added to</td>
    <td class="lineNumber">1940</td>
    <td class="codeline">/// Variables that are interesting to this pass in are added to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="codeline">/// FnVarLocs->Variables first. TrackedVariablesVectorSize is set to the ID of</td>
    <td class="lineNumber">1941</td>
    <td class="codeline">/// FnVarLocs->Variables first. TrackedVariablesVectorSize is set to the ID of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="codeline">/// the last interesting variable plus 1, meaning variables with ID 1</td>
    <td class="lineNumber">1942</td>
    <td class="codeline">/// the last interesting variable plus 1, meaning variables with ID 1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="codeline">/// (inclusive) to TrackedVariablesVectorSize (exclusive) are interesting. The</td>
    <td class="lineNumber">1943</td>
    <td class="codeline">/// (inclusive) to TrackedVariablesVectorSize (exclusive) are interesting. The</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="codeline">/// subsequent variables are either stack homed or fully promoted.</td>
    <td class="lineNumber">1944</td>
    <td class="codeline">/// subsequent variables are either stack homed or fully promoted.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1945</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="codeline">/// Finally, populate UntaggedStoreVars with a mapping of untagged stores to</td>
    <td class="lineNumber">1946</td>
    <td class="codeline">/// Finally, populate UntaggedStoreVars with a mapping of untagged stores to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="codeline">/// the stored-to variable fragments.</td>
    <td class="lineNumber">1947</td>
    <td class="codeline">/// the stored-to variable fragments.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1948</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="codeline">/// These tasks are bundled together to reduce the number of times we need</td>
    <td class="lineNumber">1949</td>
    <td class="codeline">/// These tasks are bundled together to reduce the number of times we need</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="codeline">/// to iterate over the function as they can be achieved together in one pass.</td>
    <td class="lineNumber">1950</td>
    <td class="codeline">/// to iterate over the function as they can be achieved together in one pass.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="codeline">static AssignmentTrackingLowering::OverlapMap buildOverlapMapAndRecordDeclares(</td>
    <td class="lineNumber">1951</td>
    <td class="codeline">static AssignmentTrackingLowering::OverlapMap buildOverlapMapAndRecordDeclares(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="codeline">    Function &Fn, FunctionVarLocsBuilder *FnVarLocs,</td>
    <td class="lineNumber">1952</td>
    <td class="codeline">    Function &Fn, FunctionVarLocsBuilder *FnVarLocs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="codeline">    const DenseSet<DebugAggregate> &VarsWithStackSlot,</td>
    <td class="lineNumber">1953</td>
    <td class="codeline">    const DenseSet<DebugAggregate> &VarsWithStackSlot,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="codeline">    AssignmentTrackingLowering::UntaggedStoreAssignmentMap &UntaggedStoreVars,</td>
    <td class="lineNumber">1954</td>
    <td class="codeline">    AssignmentTrackingLowering::UntaggedStoreAssignmentMap &UntaggedStoreVars,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="codeline">    unsigned &TrackedVariablesVectorSize) {</td>
    <td class="lineNumber">1955</td>
    <td class="codeline">    unsigned &TrackedVariablesVectorSize) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="codeline">  DenseSet<DebugVariable> Seen;</td>
    <td class="lineNumber">1956</td>
    <td class="codeline">  DenseSet<DebugVariable> Seen;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="codeline">  // Map of Variable: [Fragments].</td>
    <td class="lineNumber">1957</td>
    <td class="codeline">  // Map of Variable: [Fragments].</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="codeline">  DenseMap<DebugAggregate, SmallVector<DebugVariable, 8>> FragmentMap;</td>
    <td class="lineNumber">1958</td>
    <td class="codeline">  DenseMap<DebugAggregate, SmallVector<DebugVariable, 8>> FragmentMap;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="codeline">  // Iterate over all instructions:</td>
    <td class="lineNumber">1959</td>
    <td class="codeline">  // Iterate over all instructions:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="codeline">  // - dbg.declare    -> add single location variable record</td>
    <td class="lineNumber">1960</td>
    <td class="codeline">  // - dbg.declare    -> add single location variable record</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="codeline">  // - dbg.*          -> Add fragments to FragmentMap</td>
    <td class="lineNumber">1961</td>
    <td class="codeline">  // - dbg.*          -> Add fragments to FragmentMap</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="codeline">  // - untagged store -> Add fragments to FragmentMap and update</td>
    <td class="lineNumber">1962</td>
    <td class="codeline">  // - untagged store -> Add fragments to FragmentMap and update</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="codeline">  //                     UntaggedStoreVars.</td>
    <td class="lineNumber">1963</td>
    <td class="codeline">  //                     UntaggedStoreVars.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="codeline">  // We need to add fragments for untagged stores too so that we can correctly</td>
    <td class="lineNumber">1964</td>
    <td class="codeline">  // We need to add fragments for untagged stores too so that we can correctly</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="codeline">  // clobber overlapped fragment locations later.</td>
    <td class="lineNumber">1965</td>
    <td class="codeline">  // clobber overlapped fragment locations later.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="codeline">  SmallVector<DbgDeclareInst *> Declares;</td>
    <td class="lineNumber">1966</td>
    <td class="codeline">  SmallVector<DbgDeclareInst *> Declares;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="codeline">  for (auto &BB : Fn) {</td>
    <td class="lineNumber">1967</td>
    <td class="codeline">  for (auto &BB : Fn) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="codeline">    for (auto &I : BB) {</td>
    <td class="lineNumber">1968</td>
    <td class="codeline">    for (auto &I : BB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="codeline">      if (auto *DDI = dyn_cast<DbgDeclareInst>(&I)) {</td>
    <td class="lineNumber">1969</td>
    <td class="codeline">      if (auto *DDI = dyn_cast<DbgDeclareInst>(&I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="codeline">        Declares.push_back(DDI);</td>
    <td class="lineNumber">1970</td>
    <td class="codeline">        Declares.push_back(DDI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="codeline">      } else if (auto *DII = dyn_cast<DbgVariableIntrinsic>(&I)) {</td>
    <td class="lineNumber">1971</td>
    <td class="codeline">      } else if (auto *DII = dyn_cast<DbgVariableIntrinsic>(&I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="codeline">        DebugVariable DV = DebugVariable(DII);</td>
    <td class="lineNumber">1972</td>
    <td class="codeline">        DebugVariable DV = DebugVariable(DII);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="codeline">        DebugAggregate DA = {DV.getVariable(), DV.getInlinedAt()};</td>
    <td class="lineNumber">1973</td>
    <td class="codeline">        DebugAggregate DA = {DV.getVariable(), DV.getInlinedAt()};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="codeline">        if (!VarsWithStackSlot.contains(DA))</td>
    <td class="lineNumber">1974</td>
    <td class="codeline">        if (!VarsWithStackSlot.contains(DA))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">1975</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="codeline">        if (Seen.insert(DV).second)</td>
    <td class="lineNumber">1976</td>
    <td class="codeline">        if (Seen.insert(DV).second)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="codeline">          FragmentMap[DA].push_back(DV);</td>
    <td class="lineNumber">1977</td>
    <td class="codeline">          FragmentMap[DA].push_back(DV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="codeline">      } else if (auto Info = getUntaggedStoreAssignmentInfo(</td>
    <td class="lineNumber">1978</td>
    <td class="codeline">      } else if (auto Info = getUntaggedStoreAssignmentInfo(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="codeline">                     I, Fn.getParent()->getDataLayout())) {</td>
    <td class="lineNumber">1979</td>
    <td class="codeline">                     I, Fn.getParent()->getDataLayout())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="codeline">        // Find markers linked to this alloca.</td>
    <td class="lineNumber">1980</td>
    <td class="codeline">        // Find markers linked to this alloca.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="codeline">        for (DbgAssignIntrinsic *DAI : at::getAssignmentMarkers(Info->Base)) {</td>
    <td class="lineNumber">1981</td>
    <td class="codeline">        for (DbgAssignIntrinsic *DAI : at::getAssignmentMarkers(Info->Base)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="codeline">          // Discard the fragment if it covers the entire variable.</td>
    <td class="lineNumber">1982</td>
    <td class="codeline">          // Discard the fragment if it covers the entire variable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="codeline">          std::optional<DIExpression::FragmentInfo> FragInfo =</td>
    <td class="lineNumber">1983</td>
    <td class="codeline">          std::optional<DIExpression::FragmentInfo> FragInfo =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="codeline">              [&Info, DAI]() -> std::optional<DIExpression::FragmentInfo> {</td>
    <td class="lineNumber">1984</td>
    <td class="codeline">              [&Info, DAI]() -> std::optional<DIExpression::FragmentInfo> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="codeline">            DIExpression::FragmentInfo F;</td>
    <td class="lineNumber">1985</td>
    <td class="codeline">            DIExpression::FragmentInfo F;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="codeline">            F.OffsetInBits = Info->OffsetInBits;</td>
    <td class="lineNumber">1986</td>
    <td class="codeline">            F.OffsetInBits = Info->OffsetInBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="codeline">            F.SizeInBits = Info->SizeInBits;</td>
    <td class="lineNumber">1987</td>
    <td class="codeline">            F.SizeInBits = Info->SizeInBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="codeline">            if (auto ExistingFrag = DAI->getExpression()->getFragmentInfo())</td>
    <td class="lineNumber">1988</td>
    <td class="codeline">            if (auto ExistingFrag = DAI->getExpression()->getFragmentInfo())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="codeline">              F.OffsetInBits += ExistingFrag->OffsetInBits;</td>
    <td class="lineNumber">1989</td>
    <td class="codeline">              F.OffsetInBits += ExistingFrag->OffsetInBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="codeline">            if (auto Sz = DAI->getVariable()->getSizeInBits()) {</td>
    <td class="lineNumber">1990</td>
    <td class="codeline">            if (auto Sz = DAI->getVariable()->getSizeInBits()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="codeline">              if (F.OffsetInBits == 0 && F.SizeInBits == *Sz)</td>
    <td class="lineNumber">1991</td>
    <td class="codeline">              if (F.OffsetInBits == 0 && F.SizeInBits == *Sz)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="codeline">                return std::nullopt;</td>
    <td class="lineNumber">1992</td>
    <td class="codeline">                return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="codeline">            }</td>
    <td class="lineNumber">1993</td>
    <td class="codeline">            }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="codeline">            return F;</td>
    <td class="lineNumber">1994</td>
    <td class="codeline">            return F;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="codeline">          }();</td>
    <td class="lineNumber">1995</td>
    <td class="codeline">          }();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="codeline"></td>
    <td class="lineNumber">1996</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="codeline">          DebugVariable DV = DebugVariable(DAI->getVariable(), FragInfo,</td>
    <td class="lineNumber">1997</td>
    <td class="codeline">          DebugVariable DV = DebugVariable(DAI->getVariable(), FragInfo,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="codeline">                                           DAI->getDebugLoc().getInlinedAt());</td>
    <td class="lineNumber">1998</td>
    <td class="codeline">                                           DAI->getDebugLoc().getInlinedAt());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="codeline">          DebugAggregate DA = {DV.getVariable(), DV.getInlinedAt()};</td>
    <td class="lineNumber">1999</td>
    <td class="codeline">          DebugAggregate DA = {DV.getVariable(), DV.getInlinedAt()};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="codeline">          if (!VarsWithStackSlot.contains(DA))</td>
    <td class="lineNumber">2000</td>
    <td class="codeline">          if (!VarsWithStackSlot.contains(DA))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="codeline">            continue;</td>
    <td class="lineNumber">2001</td>
    <td class="codeline">            continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="codeline"></td>
    <td class="lineNumber">2002</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="codeline">          // Cache this info for later.</td>
    <td class="lineNumber">2003</td>
    <td class="codeline">          // Cache this info for later.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="codeline">          UntaggedStoreVars[&I].push_back(</td>
    <td class="lineNumber">2004</td>
    <td class="codeline">          UntaggedStoreVars[&I].push_back(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="codeline">              {FnVarLocs->insertVariable(DV), *Info});</td>
    <td class="lineNumber">2005</td>
    <td class="codeline">              {FnVarLocs->insertVariable(DV), *Info});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="codeline"></td>
    <td class="lineNumber">2006</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="codeline">          if (Seen.insert(DV).second)</td>
    <td class="lineNumber">2007</td>
    <td class="codeline">          if (Seen.insert(DV).second)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="codeline">            FragmentMap[DA].push_back(DV);</td>
    <td class="lineNumber">2008</td>
    <td class="codeline">            FragmentMap[DA].push_back(DV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">2009</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2010</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2011</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2012</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="codeline"></td>
    <td class="lineNumber">2013</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="codeline">  // Sort the fragment map for each DebugAggregate in ascending</td>
    <td class="lineNumber">2014</td>
    <td class="codeline">  // Sort the fragment map for each DebugAggregate in ascending</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="codeline">  // order of fragment size - there should be no duplicates.</td>
    <td class="lineNumber">2015</td>
    <td class="codeline">  // order of fragment size - there should be no duplicates.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="codeline">  for (auto &Pair : FragmentMap) {</td>
    <td class="lineNumber">2016</td>
    <td class="codeline">  for (auto &Pair : FragmentMap) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="codeline">    SmallVector<DebugVariable, 8> &Frags = Pair.second;</td>
    <td class="lineNumber">2017</td>
    <td class="codeline">    SmallVector<DebugVariable, 8> &Frags = Pair.second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="codeline">    std::sort(Frags.begin(), Frags.end(),</td>
    <td class="lineNumber">2018</td>
    <td class="codeline">    std::sort(Frags.begin(), Frags.end(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="codeline">              [](const DebugVariable &Next, const DebugVariable &Elmt) {</td>
    <td class="lineNumber">2019</td>
    <td class="codeline">              [](const DebugVariable &Next, const DebugVariable &Elmt) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="codeline">                return Elmt.getFragmentOrDefault().SizeInBits ></td>
    <td class="lineNumber">2020</td>
    <td class="codeline">                return Elmt.getFragmentOrDefault().SizeInBits ></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="codeline">                       Next.getFragmentOrDefault().SizeInBits;</td>
    <td class="lineNumber">2021</td>
    <td class="codeline">                       Next.getFragmentOrDefault().SizeInBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="codeline">              });</td>
    <td class="lineNumber">2022</td>
    <td class="codeline">              });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="codeline">    // Check for duplicates.</td>
    <td class="lineNumber">2023</td>
    <td class="codeline">    // Check for duplicates.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="codeline">    assert(std::adjacent_find(Frags.begin(), Frags.end()) == Frags.end());</td>
    <td class="lineNumber">2024</td>
    <td class="codeline">    assert(std::adjacent_find(Frags.begin(), Frags.end()) == Frags.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2025</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="codeline"></td>
    <td class="lineNumber">2026</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="codeline">  // Build the map.</td>
    <td class="lineNumber">2027</td>
    <td class="codeline">  // Build the map.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="codeline">  AssignmentTrackingLowering::OverlapMap Map;</td>
    <td class="lineNumber">2028</td>
    <td class="codeline">  AssignmentTrackingLowering::OverlapMap Map;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="codeline">  for (auto &Pair : FragmentMap) {</td>
    <td class="lineNumber">2029</td>
    <td class="codeline">  for (auto &Pair : FragmentMap) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="codeline">    auto &Frags = Pair.second;</td>
    <td class="lineNumber">2030</td>
    <td class="codeline">    auto &Frags = Pair.second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="codeline">    for (auto It = Frags.begin(), IEnd = Frags.end(); It != IEnd; ++It) {</td>
    <td class="lineNumber">2031</td>
    <td class="codeline">    for (auto It = Frags.begin(), IEnd = Frags.end(); It != IEnd; ++It) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="codeline">      DIExpression::FragmentInfo Frag = It->getFragmentOrDefault();</td>
    <td class="lineNumber">2032</td>
    <td class="codeline">      DIExpression::FragmentInfo Frag = It->getFragmentOrDefault();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="codeline">      // Find the frags that this is contained within.</td>
    <td class="lineNumber">2033</td>
    <td class="codeline">      // Find the frags that this is contained within.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="codeline">      //</td>
    <td class="lineNumber">2034</td>
    <td class="codeline">      //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="codeline">      // Because Frags is sorted by size and none have the same offset and</td>
    <td class="lineNumber">2035</td>
    <td class="codeline">      // Because Frags is sorted by size and none have the same offset and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="codeline">      // size, we know that this frag can only be contained by subsequent</td>
    <td class="lineNumber">2036</td>
    <td class="codeline">      // size, we know that this frag can only be contained by subsequent</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="codeline">      // elements.</td>
    <td class="lineNumber">2037</td>
    <td class="codeline">      // elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="codeline">      SmallVector<DebugVariable, 8>::iterator OtherIt = It;</td>
    <td class="lineNumber">2038</td>
    <td class="codeline">      SmallVector<DebugVariable, 8>::iterator OtherIt = It;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="codeline">      ++OtherIt;</td>
    <td class="lineNumber">2039</td>
    <td class="codeline">      ++OtherIt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="codeline">      VariableID ThisVar = FnVarLocs->insertVariable(*It);</td>
    <td class="lineNumber">2040</td>
    <td class="codeline">      VariableID ThisVar = FnVarLocs->insertVariable(*It);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="codeline">      for (; OtherIt != IEnd; ++OtherIt) {</td>
    <td class="lineNumber">2041</td>
    <td class="codeline">      for (; OtherIt != IEnd; ++OtherIt) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="codeline">        DIExpression::FragmentInfo OtherFrag = OtherIt->getFragmentOrDefault();</td>
    <td class="lineNumber">2042</td>
    <td class="codeline">        DIExpression::FragmentInfo OtherFrag = OtherIt->getFragmentOrDefault();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="codeline">        VariableID OtherVar = FnVarLocs->insertVariable(*OtherIt);</td>
    <td class="lineNumber">2043</td>
    <td class="codeline">        VariableID OtherVar = FnVarLocs->insertVariable(*OtherIt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="codeline">        if (fullyContains(OtherFrag, Frag))</td>
    <td class="lineNumber">2044</td>
    <td class="codeline">        if (fullyContains(OtherFrag, Frag))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="codeline">          Map[OtherVar].push_back(ThisVar);</td>
    <td class="lineNumber">2045</td>
    <td class="codeline">          Map[OtherVar].push_back(ThisVar);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2046</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2047</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2048</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="codeline"></td>
    <td class="lineNumber">2049</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="codeline">  // VariableIDs are 1-based so the variable-tracking bitvector needs</td>
    <td class="lineNumber">2050</td>
    <td class="codeline">  // VariableIDs are 1-based so the variable-tracking bitvector needs</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="codeline">  // NumVariables plus 1 bits.</td>
    <td class="lineNumber">2051</td>
    <td class="codeline">  // NumVariables plus 1 bits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="codeline">  TrackedVariablesVectorSize = FnVarLocs->getNumVariables() + 1;</td>
    <td class="lineNumber">2052</td>
    <td class="codeline">  TrackedVariablesVectorSize = FnVarLocs->getNumVariables() + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="codeline"></td>
    <td class="lineNumber">2053</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="codeline">  // Finally, insert the declares afterwards, so the first IDs are all</td>
    <td class="lineNumber">2054</td>
    <td class="codeline">  // Finally, insert the declares afterwards, so the first IDs are all</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="codeline">  // partially stack homed vars.</td>
    <td class="lineNumber">2055</td>
    <td class="codeline">  // partially stack homed vars.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="codeline">  for (auto *DDI : Declares)</td>
    <td class="lineNumber">2056</td>
    <td class="codeline">  for (auto *DDI : Declares)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="codeline">    FnVarLocs->addSingleLocVar(DebugVariable(DDI), DDI->getExpression(),</td>
    <td class="lineNumber">2057</td>
    <td class="codeline">    FnVarLocs->addSingleLocVar(DebugVariable(DDI), DDI->getExpression(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="codeline">                               DDI->getDebugLoc(), DDI->getWrappedLocation());</td>
    <td class="lineNumber">2058</td>
    <td class="codeline">                               DDI->getDebugLoc(), DDI->getWrappedLocation());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="codeline">  return Map;</td>
    <td class="lineNumber">2059</td>
    <td class="codeline">  return Map;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2060</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="codeline"></td>
    <td class="lineNumber">2061</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="codeline">bool AssignmentTrackingLowering::run(FunctionVarLocsBuilder *FnVarLocsBuilder) {</td>
    <td class="lineNumber">2062</td>
    <td class="codeline">bool AssignmentTrackingLowering::run(FunctionVarLocsBuilder *FnVarLocsBuilder) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="codeline">  if (Fn.size() > MaxNumBlocks) {</td>
    <td class="lineNumber">2063</td>
    <td class="codeline">  if (Fn.size() > MaxNumBlocks) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "[AT] Dropping var locs in: " << Fn.getName()</td>
    <td class="lineNumber">2064</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "[AT] Dropping var locs in: " << Fn.getName()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="codeline">                      << ": too many blocks (" << Fn.size() << ")\n");</td>
    <td class="lineNumber">2065</td>
    <td class="codeline">                      << ": too many blocks (" << Fn.size() << ")\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="codeline">    at::deleteAll(&Fn);</td>
    <td class="lineNumber">2066</td>
    <td class="codeline">    at::deleteAll(&Fn);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2067</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2068</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="codeline"></td>
    <td class="lineNumber">2069</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="codeline">  FnVarLocs = FnVarLocsBuilder;</td>
    <td class="lineNumber">2070</td>
    <td class="codeline">  FnVarLocs = FnVarLocsBuilder;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="codeline"></td>
    <td class="lineNumber">2071</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="codeline">  // The general structure here is inspired by VarLocBasedImpl.cpp</td>
    <td class="lineNumber">2072</td>
    <td class="codeline">  // The general structure here is inspired by VarLocBasedImpl.cpp</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="codeline">  // (LiveDebugValues).</td>
    <td class="lineNumber">2073</td>
    <td class="codeline">  // (LiveDebugValues).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="codeline"></td>
    <td class="lineNumber">2074</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="codeline">  // Build the variable fragment overlap map.</td>
    <td class="lineNumber">2075</td>
    <td class="codeline">  // Build the variable fragment overlap map.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="codeline">  // Note that this pass doesn't handle partial overlaps correctly (FWIW</td>
    <td class="lineNumber">2076</td>
    <td class="codeline">  // Note that this pass doesn't handle partial overlaps correctly (FWIW</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="codeline">  // neither does LiveDebugVariables) because that is difficult to do and</td>
    <td class="lineNumber">2077</td>
    <td class="codeline">  // neither does LiveDebugVariables) because that is difficult to do and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="codeline">  // appears to be rare occurance.</td>
    <td class="lineNumber">2078</td>
    <td class="codeline">  // appears to be rare occurance.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="codeline">  VarContains = buildOverlapMapAndRecordDeclares(</td>
    <td class="lineNumber">2079</td>
    <td class="codeline">  VarContains = buildOverlapMapAndRecordDeclares(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="codeline">      Fn, FnVarLocs, *VarsWithStackSlot, UntaggedStoreVars,</td>
    <td class="lineNumber">2080</td>
    <td class="codeline">      Fn, FnVarLocs, *VarsWithStackSlot, UntaggedStoreVars,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="codeline">      TrackedVariablesVectorSize);</td>
    <td class="lineNumber">2081</td>
    <td class="codeline">      TrackedVariablesVectorSize);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="codeline"></td>
    <td class="lineNumber">2082</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="codeline">  // Prepare for traversal.</td>
    <td class="lineNumber">2083</td>
    <td class="codeline">  // Prepare for traversal.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="codeline">  ReversePostOrderTraversal<Function *> RPOT(&Fn);</td>
    <td class="lineNumber">2084</td>
    <td class="codeline">  ReversePostOrderTraversal<Function *> RPOT(&Fn);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="codeline">  std::priority_queue<unsigned int, std::vector<unsigned int>,</td>
    <td class="lineNumber">2085</td>
    <td class="codeline">  std::priority_queue<unsigned int, std::vector<unsigned int>,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="codeline">                      std::greater<unsigned int>></td>
    <td class="lineNumber">2086</td>
    <td class="codeline">                      std::greater<unsigned int>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="codeline">      Worklist;</td>
    <td class="lineNumber">2087</td>
    <td class="codeline">      Worklist;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="codeline">  std::priority_queue<unsigned int, std::vector<unsigned int>,</td>
    <td class="lineNumber">2088</td>
    <td class="codeline">  std::priority_queue<unsigned int, std::vector<unsigned int>,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="codeline">                      std::greater<unsigned int>></td>
    <td class="lineNumber">2089</td>
    <td class="codeline">                      std::greater<unsigned int>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="codeline">      Pending;</td>
    <td class="lineNumber">2090</td>
    <td class="codeline">      Pending;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="codeline">  DenseMap<unsigned int, BasicBlock *> OrderToBB;</td>
    <td class="lineNumber">2091</td>
    <td class="codeline">  DenseMap<unsigned int, BasicBlock *> OrderToBB;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="codeline">  DenseMap<BasicBlock *, unsigned int> BBToOrder;</td>
    <td class="lineNumber">2092</td>
    <td class="codeline">  DenseMap<BasicBlock *, unsigned int> BBToOrder;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="codeline">  { // Init OrderToBB and BBToOrder.</td>
    <td class="lineNumber">2093</td>
    <td class="codeline">  { // Init OrderToBB and BBToOrder.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="codeline">    unsigned int RPONumber = 0;</td>
    <td class="lineNumber">2094</td>
    <td class="codeline">    unsigned int RPONumber = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="codeline">    for (auto RI = RPOT.begin(), RE = RPOT.end(); RI != RE; ++RI) {</td>
    <td class="lineNumber">2095</td>
    <td class="codeline">    for (auto RI = RPOT.begin(), RE = RPOT.end(); RI != RE; ++RI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="codeline">      OrderToBB[RPONumber] = *RI;</td>
    <td class="lineNumber">2096</td>
    <td class="codeline">      OrderToBB[RPONumber] = *RI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="codeline">      BBToOrder[*RI] = RPONumber;</td>
    <td class="lineNumber">2097</td>
    <td class="codeline">      BBToOrder[*RI] = RPONumber;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="codeline">      Worklist.push(RPONumber);</td>
    <td class="lineNumber">2098</td>
    <td class="codeline">      Worklist.push(RPONumber);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="codeline">      ++RPONumber;</td>
    <td class="lineNumber">2099</td>
    <td class="codeline">      ++RPONumber;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2100</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="codeline">    LiveIn.init(RPONumber);</td>
    <td class="lineNumber">2101</td>
    <td class="codeline">    LiveIn.init(RPONumber);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="codeline">    LiveOut.init(RPONumber);</td>
    <td class="lineNumber">2102</td>
    <td class="codeline">    LiveOut.init(RPONumber);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2103</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="codeline"></td>
    <td class="lineNumber">2104</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="codeline">  // Perform the traversal.</td>
    <td class="lineNumber">2105</td>
    <td class="codeline">  // Perform the traversal.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">2106</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="codeline">  // This is a standard "union of predecessor outs" dataflow problem. To solve</td>
    <td class="lineNumber">2107</td>
    <td class="codeline">  // This is a standard "union of predecessor outs" dataflow problem. To solve</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="codeline">  // it, we perform join() and process() using the two worklist method until</td>
    <td class="lineNumber">2108</td>
    <td class="codeline">  // it, we perform join() and process() using the two worklist method until</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="codeline">  // the LiveIn data for each block becomes unchanging. The "proof" that this</td>
    <td class="lineNumber">2109</td>
    <td class="codeline">  // the LiveIn data for each block becomes unchanging. The "proof" that this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="codeline">  // terminates can be put together by looking at the comments around LocKind,</td>
    <td class="lineNumber">2110</td>
    <td class="codeline">  // terminates can be put together by looking at the comments around LocKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="codeline">  // Assignment, and the various join methods, which show that all the elements</td>
    <td class="lineNumber">2111</td>
    <td class="codeline">  // Assignment, and the various join methods, which show that all the elements</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="codeline">  // involved are made up of join-semilattices; LiveIn(n) can only</td>
    <td class="lineNumber">2112</td>
    <td class="codeline">  // involved are made up of join-semilattices; LiveIn(n) can only</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="codeline">  // monotonically increase in value throughout the dataflow.</td>
    <td class="lineNumber">2113</td>
    <td class="codeline">  // monotonically increase in value throughout the dataflow.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">2114</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="codeline">  SmallPtrSet<BasicBlock *, 16> Visited;</td>
    <td class="lineNumber">2115</td>
    <td class="codeline">  SmallPtrSet<BasicBlock *, 16> Visited;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="codeline">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">2116</td>
    <td class="codeline">  while (!Worklist.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="codeline">    // We track what is on the pending worklist to avoid inserting the same</td>
    <td class="lineNumber">2117</td>
    <td class="codeline">    // We track what is on the pending worklist to avoid inserting the same</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="codeline">    // thing twice.</td>
    <td class="lineNumber">2118</td>
    <td class="codeline">    // thing twice.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="codeline">    SmallPtrSet<BasicBlock *, 16> OnPending;</td>
    <td class="lineNumber">2119</td>
    <td class="codeline">    SmallPtrSet<BasicBlock *, 16> OnPending;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Processing Worklist\n");</td>
    <td class="lineNumber">2120</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Processing Worklist\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="codeline">    while (!Worklist.empty()) {</td>
    <td class="lineNumber">2121</td>
    <td class="codeline">    while (!Worklist.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="codeline">      BasicBlock *BB = OrderToBB[Worklist.top()];</td>
    <td class="lineNumber">2122</td>
    <td class="codeline">      BasicBlock *BB = OrderToBB[Worklist.top()];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "\nPop BB " << BB->getName() << "\n");</td>
    <td class="lineNumber">2123</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "\nPop BB " << BB->getName() << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="codeline">      Worklist.pop();</td>
    <td class="lineNumber">2124</td>
    <td class="codeline">      Worklist.pop();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="codeline">      bool InChanged = join(*BB, Visited);</td>
    <td class="lineNumber">2125</td>
    <td class="codeline">      bool InChanged = join(*BB, Visited);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="codeline">      // Always consider LiveIn changed on the first visit.</td>
    <td class="lineNumber">2126</td>
    <td class="codeline">      // Always consider LiveIn changed on the first visit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="codeline">      InChanged |= Visited.insert(BB).second;</td>
    <td class="lineNumber">2127</td>
    <td class="codeline">      InChanged |= Visited.insert(BB).second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="codeline">      if (InChanged) {</td>
    <td class="lineNumber">2128</td>
    <td class="codeline">      if (InChanged) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << BB->getName() << " has new InLocs, process it\n");</td>
    <td class="lineNumber">2129</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << BB->getName() << " has new InLocs, process it\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="codeline">        // Mutate a copy of LiveIn while processing BB. After calling process</td>
    <td class="lineNumber">2130</td>
    <td class="codeline">        // Mutate a copy of LiveIn while processing BB. After calling process</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="codeline">        // LiveSet is the LiveOut set for BB.</td>
    <td class="lineNumber">2131</td>
    <td class="codeline">        // LiveSet is the LiveOut set for BB.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="codeline">        BlockInfo LiveSet = LiveIn[BB];</td>
    <td class="lineNumber">2132</td>
    <td class="codeline">        BlockInfo LiveSet = LiveIn[BB];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="codeline"></td>
    <td class="lineNumber">2133</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="codeline">        // Process the instructions in the block.</td>
    <td class="lineNumber">2134</td>
    <td class="codeline">        // Process the instructions in the block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="codeline">        process(*BB, &LiveSet);</td>
    <td class="lineNumber">2135</td>
    <td class="codeline">        process(*BB, &LiveSet);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="codeline"></td>
    <td class="lineNumber">2136</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="codeline">        // Relatively expensive check: has anything changed in LiveOut for BB?</td>
    <td class="lineNumber">2137</td>
    <td class="codeline">        // Relatively expensive check: has anything changed in LiveOut for BB?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="codeline">        if (LiveOut[BB] != LiveSet) {</td>
    <td class="lineNumber">2138</td>
    <td class="codeline">        if (LiveOut[BB] != LiveSet) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="codeline">          LLVM_DEBUG(dbgs() << BB->getName()</td>
    <td class="lineNumber">2139</td>
    <td class="codeline">          LLVM_DEBUG(dbgs() << BB->getName()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="codeline">                            << " has new OutLocs, add succs to worklist: [ ");</td>
    <td class="lineNumber">2140</td>
    <td class="codeline">                            << " has new OutLocs, add succs to worklist: [ ");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="codeline">          LiveOut[BB] = std::move(LiveSet);</td>
    <td class="lineNumber">2141</td>
    <td class="codeline">          LiveOut[BB] = std::move(LiveSet);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="codeline">          for (auto I = succ_begin(BB), E = succ_end(BB); I != E; I++) {</td>
    <td class="lineNumber">2142</td>
    <td class="codeline">          for (auto I = succ_begin(BB), E = succ_end(BB); I != E; I++) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="codeline">            if (OnPending.insert(*I).second) {</td>
    <td class="lineNumber">2143</td>
    <td class="codeline">            if (OnPending.insert(*I).second) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="codeline">              LLVM_DEBUG(dbgs() << I->getName() << " ");</td>
    <td class="lineNumber">2144</td>
    <td class="codeline">              LLVM_DEBUG(dbgs() << I->getName() << " ");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="codeline">              Pending.push(BBToOrder[*I]);</td>
    <td class="lineNumber">2145</td>
    <td class="codeline">              Pending.push(BBToOrder[*I]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="codeline">            }</td>
    <td class="lineNumber">2146</td>
    <td class="codeline">            }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">2147</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="codeline">          LLVM_DEBUG(dbgs() << "]\n");</td>
    <td class="lineNumber">2148</td>
    <td class="codeline">          LLVM_DEBUG(dbgs() << "]\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">2149</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2150</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2151</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="codeline">    Worklist.swap(Pending);</td>
    <td class="lineNumber">2152</td>
    <td class="codeline">    Worklist.swap(Pending);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="codeline">    // At this point, pending must be empty, since it was just the empty</td>
    <td class="lineNumber">2153</td>
    <td class="codeline">    // At this point, pending must be empty, since it was just the empty</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="codeline">    // worklist</td>
    <td class="lineNumber">2154</td>
    <td class="codeline">    // worklist</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="codeline">    assert(Pending.empty() && "Pending should be empty");</td>
    <td class="lineNumber">2155</td>
    <td class="codeline">    assert(Pending.empty() && "Pending should be empty");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2156</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="codeline"></td>
    <td class="lineNumber">2157</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="codeline">  // That's the hard part over. Now we just have some admin to do.</td>
    <td class="lineNumber">2158</td>
    <td class="codeline">  // That's the hard part over. Now we just have some admin to do.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="codeline"></td>
    <td class="lineNumber">2159</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="codeline">  // Record whether we inserted any intrinsics.</td>
    <td class="lineNumber">2160</td>
    <td class="codeline">  // Record whether we inserted any intrinsics.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="codeline">  bool InsertedAnyIntrinsics = false;</td>
    <td class="lineNumber">2161</td>
    <td class="codeline">  bool InsertedAnyIntrinsics = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="codeline"></td>
    <td class="lineNumber">2162</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="codeline">  // Identify and add defs for single location variables.</td>
    <td class="lineNumber">2163</td>
    <td class="codeline">  // Identify and add defs for single location variables.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">2164</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="codeline">  // Go through all of the defs that we plan to add. If the aggregate variable</td>
    <td class="lineNumber">2165</td>
    <td class="codeline">  // Go through all of the defs that we plan to add. If the aggregate variable</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="codeline">  // it's a part of is not in the NotAlwaysStackHomed set we can emit a single</td>
    <td class="lineNumber">2166</td>
    <td class="codeline">  // it's a part of is not in the NotAlwaysStackHomed set we can emit a single</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="codeline">  // location def and omit the rest. Add an entry to AlwaysStackHomed so that</td>
    <td class="lineNumber">2167</td>
    <td class="codeline">  // location def and omit the rest. Add an entry to AlwaysStackHomed so that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="codeline">  // we can identify those uneeded defs later.</td>
    <td class="lineNumber">2168</td>
    <td class="codeline">  // we can identify those uneeded defs later.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="codeline">  DenseSet<DebugAggregate> AlwaysStackHomed;</td>
    <td class="lineNumber">2169</td>
    <td class="codeline">  DenseSet<DebugAggregate> AlwaysStackHomed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="codeline">  for (const auto &Pair : InsertBeforeMap) {</td>
    <td class="lineNumber">2170</td>
    <td class="codeline">  for (const auto &Pair : InsertBeforeMap) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="codeline">    const auto &Vec = Pair.second;</td>
    <td class="lineNumber">2171</td>
    <td class="codeline">    const auto &Vec = Pair.second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="codeline">    for (VarLocInfo VarLoc : Vec) {</td>
    <td class="lineNumber">2172</td>
    <td class="codeline">    for (VarLocInfo VarLoc : Vec) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="codeline">      DebugVariable Var = FnVarLocs->getVariable(VarLoc.VariableID);</td>
    <td class="lineNumber">2173</td>
    <td class="codeline">      DebugVariable Var = FnVarLocs->getVariable(VarLoc.VariableID);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="codeline">      DebugAggregate Aggr{Var.getVariable(), Var.getInlinedAt()};</td>
    <td class="lineNumber">2174</td>
    <td class="codeline">      DebugAggregate Aggr{Var.getVariable(), Var.getInlinedAt()};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="codeline"></td>
    <td class="lineNumber">2175</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="codeline">      // Skip this Var if it's not always stack homed.</td>
    <td class="lineNumber">2176</td>
    <td class="codeline">      // Skip this Var if it's not always stack homed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="codeline">      if (NotAlwaysStackHomed.contains(Aggr))</td>
    <td class="lineNumber">2177</td>
    <td class="codeline">      if (NotAlwaysStackHomed.contains(Aggr))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">2178</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="codeline"></td>
    <td class="lineNumber">2179</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="codeline">      // Skip complex cases such as when different fragments of a variable have</td>
    <td class="lineNumber">2180</td>
    <td class="codeline">      // Skip complex cases such as when different fragments of a variable have</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="codeline">      // been split into different allocas. Skipping in this case means falling</td>
    <td class="lineNumber">2181</td>
    <td class="codeline">      // been split into different allocas. Skipping in this case means falling</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="codeline">      // back to using a list of defs (which could reduce coverage, but is no</td>
    <td class="lineNumber">2182</td>
    <td class="codeline">      // back to using a list of defs (which could reduce coverage, but is no</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="codeline">      // less correct).</td>
    <td class="lineNumber">2183</td>
    <td class="codeline">      // less correct).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="codeline">      bool Simple =</td>
    <td class="lineNumber">2184</td>
    <td class="codeline">      bool Simple =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="codeline">          VarLoc.Expr->getNumElements() == 1 && VarLoc.Expr->startsWithDeref();</td>
    <td class="lineNumber">2185</td>
    <td class="codeline">          VarLoc.Expr->getNumElements() == 1 && VarLoc.Expr->startsWithDeref();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="codeline">      if (!Simple) {</td>
    <td class="lineNumber">2186</td>
    <td class="codeline">      if (!Simple) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="codeline">        NotAlwaysStackHomed.insert(Aggr);</td>
    <td class="lineNumber">2187</td>
    <td class="codeline">        NotAlwaysStackHomed.insert(Aggr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">2188</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2189</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="codeline"></td>
    <td class="lineNumber">2190</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="codeline">      // All source assignments to this variable remain and all stores to any</td>
    <td class="lineNumber">2191</td>
    <td class="codeline">      // All source assignments to this variable remain and all stores to any</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="codeline">      // part of the variable store to the same address (with varying</td>
    <td class="lineNumber">2192</td>
    <td class="codeline">      // part of the variable store to the same address (with varying</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="codeline">      // offsets). We can just emit a single location for the whole variable.</td>
    <td class="lineNumber">2193</td>
    <td class="codeline">      // offsets). We can just emit a single location for the whole variable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="codeline">      //</td>
    <td class="lineNumber">2194</td>
    <td class="codeline">      //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="codeline">      // Unless we've already done so, create the single location def now.</td>
    <td class="lineNumber">2195</td>
    <td class="codeline">      // Unless we've already done so, create the single location def now.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="codeline">      if (AlwaysStackHomed.insert(Aggr).second) {</td>
    <td class="lineNumber">2196</td>
    <td class="codeline">      if (AlwaysStackHomed.insert(Aggr).second) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="codeline">        assert(!VarLoc.Values.hasArgList());</td>
    <td class="lineNumber">2197</td>
    <td class="codeline">        assert(!VarLoc.Values.hasArgList());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="codeline">        // TODO: When more complex cases are handled VarLoc.Expr should be</td>
    <td class="lineNumber">2198</td>
    <td class="codeline">        // TODO: When more complex cases are handled VarLoc.Expr should be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="codeline">        // built appropriately rather than always using an empty DIExpression.</td>
    <td class="lineNumber">2199</td>
    <td class="codeline">        // built appropriately rather than always using an empty DIExpression.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="codeline">        // The assert below is a reminder.</td>
    <td class="lineNumber">2200</td>
    <td class="codeline">        // The assert below is a reminder.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="codeline">        assert(Simple);</td>
    <td class="lineNumber">2201</td>
    <td class="codeline">        assert(Simple);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="codeline">        VarLoc.Expr = DIExpression::get(Fn.getContext(), std::nullopt);</td>
    <td class="lineNumber">2202</td>
    <td class="codeline">        VarLoc.Expr = DIExpression::get(Fn.getContext(), std::nullopt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="codeline">        DebugVariable Var = FnVarLocs->getVariable(VarLoc.VariableID);</td>
    <td class="lineNumber">2203</td>
    <td class="codeline">        DebugVariable Var = FnVarLocs->getVariable(VarLoc.VariableID);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="codeline">        FnVarLocs->addSingleLocVar(Var, VarLoc.Expr, VarLoc.DL, VarLoc.Values);</td>
    <td class="lineNumber">2204</td>
    <td class="codeline">        FnVarLocs->addSingleLocVar(Var, VarLoc.Expr, VarLoc.DL, VarLoc.Values);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="codeline">        InsertedAnyIntrinsics = true;</td>
    <td class="lineNumber">2205</td>
    <td class="codeline">        InsertedAnyIntrinsics = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2206</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2207</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2208</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="codeline"></td>
    <td class="lineNumber">2209</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="codeline">  // Insert the other DEFs.</td>
    <td class="lineNumber">2210</td>
    <td class="codeline">  // Insert the other DEFs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="codeline">  for (const auto &[InsertBefore, Vec] : InsertBeforeMap) {</td>
    <td class="lineNumber">2211</td>
    <td class="codeline">  for (const auto &[InsertBefore, Vec] : InsertBeforeMap) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="codeline">    SmallVector<VarLocInfo> NewDefs;</td>
    <td class="lineNumber">2212</td>
    <td class="codeline">    SmallVector<VarLocInfo> NewDefs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="codeline">    for (const VarLocInfo &VarLoc : Vec) {</td>
    <td class="lineNumber">2213</td>
    <td class="codeline">    for (const VarLocInfo &VarLoc : Vec) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="codeline">      DebugVariable Var = FnVarLocs->getVariable(VarLoc.VariableID);</td>
    <td class="lineNumber">2214</td>
    <td class="codeline">      DebugVariable Var = FnVarLocs->getVariable(VarLoc.VariableID);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="codeline">      DebugAggregate Aggr{Var.getVariable(), Var.getInlinedAt()};</td>
    <td class="lineNumber">2215</td>
    <td class="codeline">      DebugAggregate Aggr{Var.getVariable(), Var.getInlinedAt()};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="codeline">      // If this variable is always stack homed then we have already inserted a</td>
    <td class="lineNumber">2216</td>
    <td class="codeline">      // If this variable is always stack homed then we have already inserted a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="codeline">      // dbg.declare and deleted this dbg.value.</td>
    <td class="lineNumber">2217</td>
    <td class="codeline">      // dbg.declare and deleted this dbg.value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="codeline">      if (AlwaysStackHomed.contains(Aggr))</td>
    <td class="lineNumber">2218</td>
    <td class="codeline">      if (AlwaysStackHomed.contains(Aggr))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">2219</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="codeline">      NewDefs.push_back(VarLoc);</td>
    <td class="lineNumber">2220</td>
    <td class="codeline">      NewDefs.push_back(VarLoc);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="codeline">      InsertedAnyIntrinsics = true;</td>
    <td class="lineNumber">2221</td>
    <td class="codeline">      InsertedAnyIntrinsics = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2222</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="codeline"></td>
    <td class="lineNumber">2223</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="codeline">    FnVarLocs->setWedge(InsertBefore, std::move(NewDefs));</td>
    <td class="lineNumber">2224</td>
    <td class="codeline">    FnVarLocs->setWedge(InsertBefore, std::move(NewDefs));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2225</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="codeline"></td>
    <td class="lineNumber">2226</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="codeline">  InsertedAnyIntrinsics |= emitPromotedVarLocs(FnVarLocs);</td>
    <td class="lineNumber">2227</td>
    <td class="codeline">  InsertedAnyIntrinsics |= emitPromotedVarLocs(FnVarLocs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="codeline"></td>
    <td class="lineNumber">2228</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="codeline">  return InsertedAnyIntrinsics;</td>
    <td class="lineNumber">2229</td>
    <td class="codeline">  return InsertedAnyIntrinsics;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2230</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="codeline"></td>
    <td class="lineNumber">2231</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="codeline">bool AssignmentTrackingLowering::emitPromotedVarLocs(</td>
    <td class="lineNumber">2232</td>
    <td class="codeline">bool AssignmentTrackingLowering::emitPromotedVarLocs(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="codeline">    FunctionVarLocsBuilder *FnVarLocs) {</td>
    <td class="lineNumber">2233</td>
    <td class="codeline">    FunctionVarLocsBuilder *FnVarLocs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="codeline">  bool InsertedAnyIntrinsics = false;</td>
    <td class="lineNumber">2234</td>
    <td class="codeline">  bool InsertedAnyIntrinsics = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="codeline">  // Go through every block, translating debug intrinsics for fully promoted</td>
    <td class="lineNumber">2235</td>
    <td class="codeline">  // Go through every block, translating debug intrinsics for fully promoted</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="codeline">  // variables into FnVarLocs location defs. No analysis required for these.</td>
    <td class="lineNumber">2236</td>
    <td class="codeline">  // variables into FnVarLocs location defs. No analysis required for these.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="codeline">  for (auto &BB : Fn) {</td>
    <td class="lineNumber">2237</td>
    <td class="codeline">  for (auto &BB : Fn) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="codeline">    for (auto &I : BB) {</td>
    <td class="lineNumber">2238</td>
    <td class="codeline">    for (auto &I : BB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="codeline">      // Skip instructions other than dbg.values and dbg.assigns.</td>
    <td class="lineNumber">2239</td>
    <td class="codeline">      // Skip instructions other than dbg.values and dbg.assigns.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="codeline">      auto *DVI = dyn_cast<DbgValueInst>(&I);</td>
    <td class="lineNumber">2240</td>
    <td class="codeline">      auto *DVI = dyn_cast<DbgValueInst>(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="codeline">      if (!DVI)</td>
    <td class="lineNumber">2241</td>
    <td class="codeline">      if (!DVI)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">2242</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="codeline">      // Skip variables that haven't been promoted - we've dealt with those</td>
    <td class="lineNumber">2243</td>
    <td class="codeline">      // Skip variables that haven't been promoted - we've dealt with those</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="codeline">      // already.</td>
    <td class="lineNumber">2244</td>
    <td class="codeline">      // already.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="codeline">      if (VarsWithStackSlot->contains(getAggregate(DVI)))</td>
    <td class="lineNumber">2245</td>
    <td class="codeline">      if (VarsWithStackSlot->contains(getAggregate(DVI)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">2246</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="codeline">      Instruction *InsertBefore = I.getNextNode();</td>
    <td class="lineNumber">2247</td>
    <td class="codeline">      Instruction *InsertBefore = I.getNextNode();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="codeline">      assert(InsertBefore && "Unexpected: debug intrinsics after a terminator");</td>
    <td class="lineNumber">2248</td>
    <td class="codeline">      assert(InsertBefore && "Unexpected: debug intrinsics after a terminator");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="codeline">      FnVarLocs->addVarLoc(InsertBefore, DebugVariable(DVI),</td>
    <td class="lineNumber">2249</td>
    <td class="codeline">      FnVarLocs->addVarLoc(InsertBefore, DebugVariable(DVI),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="codeline">                           DVI->getExpression(), DVI->getDebugLoc(),</td>
    <td class="lineNumber">2250</td>
    <td class="codeline">                           DVI->getExpression(), DVI->getDebugLoc(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="codeline">                           DVI->getWrappedLocation());</td>
    <td class="lineNumber">2251</td>
    <td class="codeline">                           DVI->getWrappedLocation());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="codeline">      InsertedAnyIntrinsics = true;</td>
    <td class="lineNumber">2252</td>
    <td class="codeline">      InsertedAnyIntrinsics = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2253</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2254</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="codeline">  return InsertedAnyIntrinsics;</td>
    <td class="lineNumber">2255</td>
    <td class="codeline">  return InsertedAnyIntrinsics;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2256</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="codeline"></td>
    <td class="lineNumber">2257</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="codeline">/// Remove redundant definitions within sequences of consecutive location defs.</td>
    <td class="lineNumber">2258</td>
    <td class="codeline">/// Remove redundant definitions within sequences of consecutive location defs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="codeline">/// This is done using a backward scan to keep the last def describing a</td>
    <td class="lineNumber">2259</td>
    <td class="codeline">/// This is done using a backward scan to keep the last def describing a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="codeline">/// specific variable/fragment.</td>
    <td class="lineNumber">2260</td>
    <td class="codeline">/// specific variable/fragment.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="codeline">///</td>
    <td class="lineNumber">2261</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="codeline">/// This implements removeRedundantDbgInstrsUsingBackwardScan from</td>
    <td class="lineNumber">2262</td>
    <td class="codeline">/// This implements removeRedundantDbgInstrsUsingBackwardScan from</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="codeline">/// lib/Transforms/Utils/BasicBlockUtils.cpp for locations described with</td>
    <td class="lineNumber">2263</td>
    <td class="codeline">/// lib/Transforms/Utils/BasicBlockUtils.cpp for locations described with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="codeline">/// FunctionVarLocsBuilder instead of with intrinsics.</td>
    <td class="lineNumber">2264</td>
    <td class="codeline">/// FunctionVarLocsBuilder instead of with intrinsics.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="codeline">static bool</td>
    <td class="lineNumber">2265</td>
    <td class="codeline">static bool</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="codeline">removeRedundantDbgLocsUsingBackwardScan(const BasicBlock *BB,</td>
    <td class="lineNumber">2266</td>
    <td class="codeline">removeRedundantDbgLocsUsingBackwardScan(const BasicBlock *BB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="codeline">                                        FunctionVarLocsBuilder &FnVarLocs) {</td>
    <td class="lineNumber">2267</td>
    <td class="codeline">                                        FunctionVarLocsBuilder &FnVarLocs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="codeline">  bool Changed = false;</td>
    <td class="lineNumber">2268</td>
    <td class="codeline">  bool Changed = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="codeline">  SmallDenseMap<DebugAggregate, BitVector> VariableDefinedBits;</td>
    <td class="lineNumber">2269</td>
    <td class="codeline">  SmallDenseMap<DebugAggregate, BitVector> VariableDefinedBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="codeline">  // Scan over the entire block, not just over the instructions mapped by</td>
    <td class="lineNumber">2270</td>
    <td class="codeline">  // Scan over the entire block, not just over the instructions mapped by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="codeline">  // FnVarLocs, because wedges in FnVarLocs may only be seperated by debug</td>
    <td class="lineNumber">2271</td>
    <td class="codeline">  // FnVarLocs, because wedges in FnVarLocs may only be seperated by debug</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="codeline">  // instructions.</td>
    <td class="lineNumber">2272</td>
    <td class="codeline">  // instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="codeline">  for (const Instruction &I : reverse(*BB)) {</td>
    <td class="lineNumber">2273</td>
    <td class="codeline">  for (const Instruction &I : reverse(*BB)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="codeline">    if (!isa<DbgVariableIntrinsic>(I)) {</td>
    <td class="lineNumber">2274</td>
    <td class="codeline">    if (!isa<DbgVariableIntrinsic>(I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="codeline">      // Sequence of consecutive defs ended. Clear map for the next one.</td>
    <td class="lineNumber">2275</td>
    <td class="codeline">      // Sequence of consecutive defs ended. Clear map for the next one.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="codeline">      VariableDefinedBits.clear();</td>
    <td class="lineNumber">2276</td>
    <td class="codeline">      VariableDefinedBits.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2277</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="codeline"></td>
    <td class="lineNumber">2278</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="codeline">    // Get the location defs that start just before this instruction.</td>
    <td class="lineNumber">2279</td>
    <td class="codeline">    // Get the location defs that start just before this instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="codeline">    const auto *Locs = FnVarLocs.getWedge(&I);</td>
    <td class="lineNumber">2280</td>
    <td class="codeline">    const auto *Locs = FnVarLocs.getWedge(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="codeline">    if (!Locs)</td>
    <td class="lineNumber">2281</td>
    <td class="codeline">    if (!Locs)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">2282</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="codeline"></td>
    <td class="lineNumber">2283</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="codeline">    NumWedgesScanned++;</td>
    <td class="lineNumber">2284</td>
    <td class="codeline">    NumWedgesScanned++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="codeline">    bool ChangedThisWedge = false;</td>
    <td class="lineNumber">2285</td>
    <td class="codeline">    bool ChangedThisWedge = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="codeline">    // The new pruned set of defs, reversed because we're scanning backwards.</td>
    <td class="lineNumber">2286</td>
    <td class="codeline">    // The new pruned set of defs, reversed because we're scanning backwards.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="codeline">    SmallVector<VarLocInfo> NewDefsReversed;</td>
    <td class="lineNumber">2287</td>
    <td class="codeline">    SmallVector<VarLocInfo> NewDefsReversed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="codeline"></td>
    <td class="lineNumber">2288</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="codeline">    // Iterate over the existing defs in reverse.</td>
    <td class="lineNumber">2289</td>
    <td class="codeline">    // Iterate over the existing defs in reverse.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="codeline">    for (auto RIt = Locs->rbegin(), REnd = Locs->rend(); RIt != REnd; ++RIt) {</td>
    <td class="lineNumber">2290</td>
    <td class="codeline">    for (auto RIt = Locs->rbegin(), REnd = Locs->rend(); RIt != REnd; ++RIt) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="codeline">      NumDefsScanned++;</td>
    <td class="lineNumber">2291</td>
    <td class="codeline">      NumDefsScanned++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="codeline">      DebugAggregate Aggr =</td>
    <td class="lineNumber">2292</td>
    <td class="codeline">      DebugAggregate Aggr =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="codeline">          getAggregate(FnVarLocs.getVariable(RIt->VariableID));</td>
    <td class="lineNumber">2293</td>
    <td class="codeline">          getAggregate(FnVarLocs.getVariable(RIt->VariableID));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="codeline">      uint64_t SizeInBits = Aggr.first->getSizeInBits().value_or(0);</td>
    <td class="lineNumber">2294</td>
    <td class="codeline">      uint64_t SizeInBits = Aggr.first->getSizeInBits().value_or(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="codeline"></td>
    <td class="lineNumber">2295</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="codeline">      if (SizeInBits == 0) {</td>
    <td class="lineNumber">2296</td>
    <td class="codeline">      if (SizeInBits == 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="codeline">        // If the size is unknown (0) then keep this location def to be safe.</td>
    <td class="lineNumber">2297</td>
    <td class="codeline">        // If the size is unknown (0) then keep this location def to be safe.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="codeline">        NewDefsReversed.push_back(*RIt);</td>
    <td class="lineNumber">2298</td>
    <td class="codeline">        NewDefsReversed.push_back(*RIt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">2299</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2300</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="codeline"></td>
    <td class="lineNumber">2301</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="codeline">      // Only keep this location definition if it is not fully eclipsed by</td>
    <td class="lineNumber">2302</td>
    <td class="codeline">      // Only keep this location definition if it is not fully eclipsed by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="codeline">      // other definitions in this wedge that come after it</td>
    <td class="lineNumber">2303</td>
    <td class="codeline">      // other definitions in this wedge that come after it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="codeline"></td>
    <td class="lineNumber">2304</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="codeline">      // Inert the bits the location definition defines.</td>
    <td class="lineNumber">2305</td>
    <td class="codeline">      // Inert the bits the location definition defines.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="codeline">      auto InsertResult =</td>
    <td class="lineNumber">2306</td>
    <td class="codeline">      auto InsertResult =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="codeline">          VariableDefinedBits.try_emplace(Aggr, BitVector(SizeInBits));</td>
    <td class="lineNumber">2307</td>
    <td class="codeline">          VariableDefinedBits.try_emplace(Aggr, BitVector(SizeInBits));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="codeline">      bool FirstDefinition = InsertResult.second;</td>
    <td class="lineNumber">2308</td>
    <td class="codeline">      bool FirstDefinition = InsertResult.second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="codeline">      BitVector &DefinedBits = InsertResult.first->second;</td>
    <td class="lineNumber">2309</td>
    <td class="codeline">      BitVector &DefinedBits = InsertResult.first->second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="codeline"></td>
    <td class="lineNumber">2310</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="codeline">      DIExpression::FragmentInfo Fragment =</td>
    <td class="lineNumber">2311</td>
    <td class="codeline">      DIExpression::FragmentInfo Fragment =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="codeline">          RIt->Expr->getFragmentInfo().value_or(</td>
    <td class="lineNumber">2312</td>
    <td class="codeline">          RIt->Expr->getFragmentInfo().value_or(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="codeline">              DIExpression::FragmentInfo(SizeInBits, 0));</td>
    <td class="lineNumber">2313</td>
    <td class="codeline">              DIExpression::FragmentInfo(SizeInBits, 0));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="codeline">      bool InvalidFragment = Fragment.endInBits() > SizeInBits;</td>
    <td class="lineNumber">2314</td>
    <td class="codeline">      bool InvalidFragment = Fragment.endInBits() > SizeInBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="codeline"></td>
    <td class="lineNumber">2315</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="codeline">      // If this defines any previously undefined bits, keep it.</td>
    <td class="lineNumber">2316</td>
    <td class="codeline">      // If this defines any previously undefined bits, keep it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="codeline">      if (FirstDefinition || InvalidFragment ||</td>
    <td class="lineNumber">2317</td>
    <td class="codeline">      if (FirstDefinition || InvalidFragment ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="codeline">          DefinedBits.find_first_unset_in(Fragment.startInBits(),</td>
    <td class="lineNumber">2318</td>
    <td class="codeline">          DefinedBits.find_first_unset_in(Fragment.startInBits(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="codeline">                                          Fragment.endInBits()) != -1) {</td>
    <td class="lineNumber">2319</td>
    <td class="codeline">                                          Fragment.endInBits()) != -1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="codeline">        if (!InvalidFragment)</td>
    <td class="lineNumber">2320</td>
    <td class="codeline">        if (!InvalidFragment)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="codeline">          DefinedBits.set(Fragment.startInBits(), Fragment.endInBits());</td>
    <td class="lineNumber">2321</td>
    <td class="codeline">          DefinedBits.set(Fragment.startInBits(), Fragment.endInBits());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="codeline">        NewDefsReversed.push_back(*RIt);</td>
    <td class="lineNumber">2322</td>
    <td class="codeline">        NewDefsReversed.push_back(*RIt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">2323</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2324</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="codeline"></td>
    <td class="lineNumber">2325</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="codeline">      // Redundant def found: throw it away. Since the wedge of defs is being</td>
    <td class="lineNumber">2326</td>
    <td class="codeline">      // Redundant def found: throw it away. Since the wedge of defs is being</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="codeline">      // rebuilt, doing nothing is the same as deleting an entry.</td>
    <td class="lineNumber">2327</td>
    <td class="codeline">      // rebuilt, doing nothing is the same as deleting an entry.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="codeline">      ChangedThisWedge = true;</td>
    <td class="lineNumber">2328</td>
    <td class="codeline">      ChangedThisWedge = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="codeline">      NumDefsRemoved++;</td>
    <td class="lineNumber">2329</td>
    <td class="codeline">      NumDefsRemoved++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2330</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="codeline"></td>
    <td class="lineNumber">2331</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="codeline">    // Un-reverse the defs and replace the wedge with the pruned version.</td>
    <td class="lineNumber">2332</td>
    <td class="codeline">    // Un-reverse the defs and replace the wedge with the pruned version.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="codeline">    if (ChangedThisWedge) {</td>
    <td class="lineNumber">2333</td>
    <td class="codeline">    if (ChangedThisWedge) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="codeline">      std::reverse(NewDefsReversed.begin(), NewDefsReversed.end());</td>
    <td class="lineNumber">2334</td>
    <td class="codeline">      std::reverse(NewDefsReversed.begin(), NewDefsReversed.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="codeline">      FnVarLocs.setWedge(&I, std::move(NewDefsReversed));</td>
    <td class="lineNumber">2335</td>
    <td class="codeline">      FnVarLocs.setWedge(&I, std::move(NewDefsReversed));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="codeline">      NumWedgesChanged++;</td>
    <td class="lineNumber">2336</td>
    <td class="codeline">      NumWedgesChanged++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="codeline">      Changed = true;</td>
    <td class="lineNumber">2337</td>
    <td class="codeline">      Changed = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2338</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2339</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="codeline"></td>
    <td class="lineNumber">2340</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="codeline">  return Changed;</td>
    <td class="lineNumber">2341</td>
    <td class="codeline">  return Changed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2342</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="codeline"></td>
    <td class="lineNumber">2343</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="codeline">/// Remove redundant location defs using a forward scan. This can remove a</td>
    <td class="lineNumber">2344</td>
    <td class="codeline">/// Remove redundant location defs using a forward scan. This can remove a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="codeline">/// location definition that is redundant due to indicating that a variable has</td>
    <td class="lineNumber">2345</td>
    <td class="codeline">/// location definition that is redundant due to indicating that a variable has</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="codeline">/// the same value as is already being indicated by an earlier def.</td>
    <td class="lineNumber">2346</td>
    <td class="codeline">/// the same value as is already being indicated by an earlier def.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="codeline">///</td>
    <td class="lineNumber">2347</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="codeline">/// This implements removeRedundantDbgInstrsUsingForwardScan from</td>
    <td class="lineNumber">2348</td>
    <td class="codeline">/// This implements removeRedundantDbgInstrsUsingForwardScan from</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="codeline">/// lib/Transforms/Utils/BasicBlockUtils.cpp for locations described with</td>
    <td class="lineNumber">2349</td>
    <td class="codeline">/// lib/Transforms/Utils/BasicBlockUtils.cpp for locations described with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="codeline">/// FunctionVarLocsBuilder instead of with intrinsics</td>
    <td class="lineNumber">2350</td>
    <td class="codeline">/// FunctionVarLocsBuilder instead of with intrinsics</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="codeline">static bool</td>
    <td class="lineNumber">2351</td>
    <td class="codeline">static bool</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="codeline">removeRedundantDbgLocsUsingForwardScan(const BasicBlock *BB,</td>
    <td class="lineNumber">2352</td>
    <td class="codeline">removeRedundantDbgLocsUsingForwardScan(const BasicBlock *BB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="codeline">                                       FunctionVarLocsBuilder &FnVarLocs) {</td>
    <td class="lineNumber">2353</td>
    <td class="codeline">                                       FunctionVarLocsBuilder &FnVarLocs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="codeline">  bool Changed = false;</td>
    <td class="lineNumber">2354</td>
    <td class="codeline">  bool Changed = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="codeline">  DenseMap<DebugVariable, std::pair<RawLocationWrapper, DIExpression *>></td>
    <td class="lineNumber">2355</td>
    <td class="codeline">  DenseMap<DebugVariable, std::pair<RawLocationWrapper, DIExpression *>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="codeline">      VariableMap;</td>
    <td class="lineNumber">2356</td>
    <td class="codeline">      VariableMap;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="codeline"></td>
    <td class="lineNumber">2357</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="codeline">  // Scan over the entire block, not just over the instructions mapped by</td>
    <td class="lineNumber">2358</td>
    <td class="codeline">  // Scan over the entire block, not just over the instructions mapped by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="codeline">  // FnVarLocs, because wedges in FnVarLocs may only be seperated by debug</td>
    <td class="lineNumber">2359</td>
    <td class="codeline">  // FnVarLocs, because wedges in FnVarLocs may only be seperated by debug</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="codeline">  // instructions.</td>
    <td class="lineNumber">2360</td>
    <td class="codeline">  // instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="codeline">  for (const Instruction &I : *BB) {</td>
    <td class="lineNumber">2361</td>
    <td class="codeline">  for (const Instruction &I : *BB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="codeline">    // Get the defs that come just before this instruction.</td>
    <td class="lineNumber">2362</td>
    <td class="codeline">    // Get the defs that come just before this instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="codeline">    const auto *Locs = FnVarLocs.getWedge(&I);</td>
    <td class="lineNumber">2363</td>
    <td class="codeline">    const auto *Locs = FnVarLocs.getWedge(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="codeline">    if (!Locs)</td>
    <td class="lineNumber">2364</td>
    <td class="codeline">    if (!Locs)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">2365</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="codeline"></td>
    <td class="lineNumber">2366</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="codeline">    NumWedgesScanned++;</td>
    <td class="lineNumber">2367</td>
    <td class="codeline">    NumWedgesScanned++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="codeline">    bool ChangedThisWedge = false;</td>
    <td class="lineNumber">2368</td>
    <td class="codeline">    bool ChangedThisWedge = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="codeline">    // The new pruned set of defs.</td>
    <td class="lineNumber">2369</td>
    <td class="codeline">    // The new pruned set of defs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="codeline">    SmallVector<VarLocInfo> NewDefs;</td>
    <td class="lineNumber">2370</td>
    <td class="codeline">    SmallVector<VarLocInfo> NewDefs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="codeline"></td>
    <td class="lineNumber">2371</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="codeline">    // Iterate over the existing defs.</td>
    <td class="lineNumber">2372</td>
    <td class="codeline">    // Iterate over the existing defs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="codeline">    for (const VarLocInfo &Loc : *Locs) {</td>
    <td class="lineNumber">2373</td>
    <td class="codeline">    for (const VarLocInfo &Loc : *Locs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="codeline">      NumDefsScanned++;</td>
    <td class="lineNumber">2374</td>
    <td class="codeline">      NumDefsScanned++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="codeline">      DebugVariable Key(FnVarLocs.getVariable(Loc.VariableID).getVariable(),</td>
    <td class="lineNumber">2375</td>
    <td class="codeline">      DebugVariable Key(FnVarLocs.getVariable(Loc.VariableID).getVariable(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="codeline">                        std::nullopt, Loc.DL.getInlinedAt());</td>
    <td class="lineNumber">2376</td>
    <td class="codeline">                        std::nullopt, Loc.DL.getInlinedAt());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="codeline">      auto VMI = VariableMap.find(Key);</td>
    <td class="lineNumber">2377</td>
    <td class="codeline">      auto VMI = VariableMap.find(Key);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="codeline"></td>
    <td class="lineNumber">2378</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="codeline">      // Update the map if we found a new value/expression describing the</td>
    <td class="lineNumber">2379</td>
    <td class="codeline">      // Update the map if we found a new value/expression describing the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="codeline">      // variable, or if the variable wasn't mapped already.</td>
    <td class="lineNumber">2380</td>
    <td class="codeline">      // variable, or if the variable wasn't mapped already.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="codeline">      if (VMI == VariableMap.end() || VMI->second.first != Loc.Values ||</td>
    <td class="lineNumber">2381</td>
    <td class="codeline">      if (VMI == VariableMap.end() || VMI->second.first != Loc.Values ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="codeline">          VMI->second.second != Loc.Expr) {</td>
    <td class="lineNumber">2382</td>
    <td class="codeline">          VMI->second.second != Loc.Expr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="codeline">        VariableMap[Key] = {Loc.Values, Loc.Expr};</td>
    <td class="lineNumber">2383</td>
    <td class="codeline">        VariableMap[Key] = {Loc.Values, Loc.Expr};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="codeline">        NewDefs.push_back(Loc);</td>
    <td class="lineNumber">2384</td>
    <td class="codeline">        NewDefs.push_back(Loc);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">2385</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2386</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="codeline"></td>
    <td class="lineNumber">2387</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="codeline">      // Did not insert this Loc, which is the same as removing it.</td>
    <td class="lineNumber">2388</td>
    <td class="codeline">      // Did not insert this Loc, which is the same as removing it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="codeline">      ChangedThisWedge = true;</td>
    <td class="lineNumber">2389</td>
    <td class="codeline">      ChangedThisWedge = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="codeline">      NumDefsRemoved++;</td>
    <td class="lineNumber">2390</td>
    <td class="codeline">      NumDefsRemoved++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2391</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="codeline"></td>
    <td class="lineNumber">2392</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="codeline">    // Replace the existing wedge with the pruned version.</td>
    <td class="lineNumber">2393</td>
    <td class="codeline">    // Replace the existing wedge with the pruned version.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="codeline">    if (ChangedThisWedge) {</td>
    <td class="lineNumber">2394</td>
    <td class="codeline">    if (ChangedThisWedge) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="codeline">      FnVarLocs.setWedge(&I, std::move(NewDefs));</td>
    <td class="lineNumber">2395</td>
    <td class="codeline">      FnVarLocs.setWedge(&I, std::move(NewDefs));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="codeline">      NumWedgesChanged++;</td>
    <td class="lineNumber">2396</td>
    <td class="codeline">      NumWedgesChanged++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="codeline">      Changed = true;</td>
    <td class="lineNumber">2397</td>
    <td class="codeline">      Changed = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2398</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2399</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="codeline"></td>
    <td class="lineNumber">2400</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="codeline">  return Changed;</td>
    <td class="lineNumber">2401</td>
    <td class="codeline">  return Changed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2402</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="codeline"></td>
    <td class="lineNumber">2403</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="codeline">static bool</td>
    <td class="lineNumber">2404</td>
    <td class="codeline">static bool</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="codeline">removeUndefDbgLocsFromEntryBlock(const BasicBlock *BB,</td>
    <td class="lineNumber">2405</td>
    <td class="codeline">removeUndefDbgLocsFromEntryBlock(const BasicBlock *BB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="codeline">                                 FunctionVarLocsBuilder &FnVarLocs) {</td>
    <td class="lineNumber">2406</td>
    <td class="codeline">                                 FunctionVarLocsBuilder &FnVarLocs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="codeline">  assert(BB->isEntryBlock());</td>
    <td class="lineNumber">2407</td>
    <td class="codeline">  assert(BB->isEntryBlock());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="codeline">  // Do extra work to ensure that we remove semantically unimportant undefs.</td>
    <td class="lineNumber">2408</td>
    <td class="codeline">  // Do extra work to ensure that we remove semantically unimportant undefs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">2409</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="codeline">  // This is to work around the fact that SelectionDAG will hoist dbg.values</td>
    <td class="lineNumber">2410</td>
    <td class="codeline">  // This is to work around the fact that SelectionDAG will hoist dbg.values</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="codeline">  // using argument values to the top of the entry block. That can move arg</td>
    <td class="lineNumber">2411</td>
    <td class="codeline">  // using argument values to the top of the entry block. That can move arg</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="codeline">  // dbg.values before undef and constant dbg.values which they previously</td>
    <td class="lineNumber">2412</td>
    <td class="codeline">  // dbg.values before undef and constant dbg.values which they previously</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="codeline">  // followed. The easiest thing to do is to just try to feed SelectionDAG</td>
    <td class="lineNumber">2413</td>
    <td class="codeline">  // followed. The easiest thing to do is to just try to feed SelectionDAG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="codeline">  // input it's happy with.</td>
    <td class="lineNumber">2414</td>
    <td class="codeline">  // input it's happy with.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">2415</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="codeline">  // Map of {Variable x: Fragments y} where the fragments y of variable x have</td>
    <td class="lineNumber">2416</td>
    <td class="codeline">  // Map of {Variable x: Fragments y} where the fragments y of variable x have</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="codeline">  // have at least one non-undef location defined already. Don't use directly,</td>
    <td class="lineNumber">2417</td>
    <td class="codeline">  // have at least one non-undef location defined already. Don't use directly,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="codeline">  // instead call DefineBits and HasDefinedBits.</td>
    <td class="lineNumber">2418</td>
    <td class="codeline">  // instead call DefineBits and HasDefinedBits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="codeline">  SmallDenseMap<DebugAggregate, SmallDenseSet<DIExpression::FragmentInfo>></td>
    <td class="lineNumber">2419</td>
    <td class="codeline">  SmallDenseMap<DebugAggregate, SmallDenseSet<DIExpression::FragmentInfo>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="codeline">      VarsWithDef;</td>
    <td class="lineNumber">2420</td>
    <td class="codeline">      VarsWithDef;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="codeline">  // Specify that V (a fragment of A) has a non-undef location.</td>
    <td class="lineNumber">2421</td>
    <td class="codeline">  // Specify that V (a fragment of A) has a non-undef location.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="codeline">  auto DefineBits = [&VarsWithDef](DebugAggregate A, DebugVariable V) {</td>
    <td class="lineNumber">2422</td>
    <td class="codeline">  auto DefineBits = [&VarsWithDef](DebugAggregate A, DebugVariable V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="codeline">    VarsWithDef[A].insert(V.getFragmentOrDefault());</td>
    <td class="lineNumber">2423</td>
    <td class="codeline">    VarsWithDef[A].insert(V.getFragmentOrDefault());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">2424</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="codeline">  // Return true if a non-undef location has been defined for V (a fragment of</td>
    <td class="lineNumber">2425</td>
    <td class="codeline">  // Return true if a non-undef location has been defined for V (a fragment of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="codeline">  // A). Doesn't imply that the location is currently non-undef, just that a</td>
    <td class="lineNumber">2426</td>
    <td class="codeline">  // A). Doesn't imply that the location is currently non-undef, just that a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="codeline">  // non-undef location has been seen previously.</td>
    <td class="lineNumber">2427</td>
    <td class="codeline">  // non-undef location has been seen previously.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="codeline">  auto HasDefinedBits = [&VarsWithDef](DebugAggregate A, DebugVariable V) {</td>
    <td class="lineNumber">2428</td>
    <td class="codeline">  auto HasDefinedBits = [&VarsWithDef](DebugAggregate A, DebugVariable V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="codeline">    auto FragsIt = VarsWithDef.find(A);</td>
    <td class="lineNumber">2429</td>
    <td class="codeline">    auto FragsIt = VarsWithDef.find(A);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="codeline">    if (FragsIt == VarsWithDef.end())</td>
    <td class="lineNumber">2430</td>
    <td class="codeline">    if (FragsIt == VarsWithDef.end())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">2431</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="codeline">    return llvm::any_of(FragsIt->second, [V](auto Frag) {</td>
    <td class="lineNumber">2432</td>
    <td class="codeline">    return llvm::any_of(FragsIt->second, [V](auto Frag) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="codeline">      return DIExpression::fragmentsOverlap(Frag, V.getFragmentOrDefault());</td>
    <td class="lineNumber">2433</td>
    <td class="codeline">      return DIExpression::fragmentsOverlap(Frag, V.getFragmentOrDefault());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="codeline">    });</td>
    <td class="lineNumber">2434</td>
    <td class="codeline">    });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">2435</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="codeline"></td>
    <td class="lineNumber">2436</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="codeline">  bool Changed = false;</td>
    <td class="lineNumber">2437</td>
    <td class="codeline">  bool Changed = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="codeline">  DenseMap<DebugVariable, std::pair<Value *, DIExpression *>> VariableMap;</td>
    <td class="lineNumber">2438</td>
    <td class="codeline">  DenseMap<DebugVariable, std::pair<Value *, DIExpression *>> VariableMap;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="codeline"></td>
    <td class="lineNumber">2439</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="codeline">  // Scan over the entire block, not just over the instructions mapped by</td>
    <td class="lineNumber">2440</td>
    <td class="codeline">  // Scan over the entire block, not just over the instructions mapped by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="codeline">  // FnVarLocs, because wedges in FnVarLocs may only be seperated by debug</td>
    <td class="lineNumber">2441</td>
    <td class="codeline">  // FnVarLocs, because wedges in FnVarLocs may only be seperated by debug</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="codeline">  // instructions.</td>
    <td class="lineNumber">2442</td>
    <td class="codeline">  // instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="codeline">  for (const Instruction &I : *BB) {</td>
    <td class="lineNumber">2443</td>
    <td class="codeline">  for (const Instruction &I : *BB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="codeline">    // Get the defs that come just before this instruction.</td>
    <td class="lineNumber">2444</td>
    <td class="codeline">    // Get the defs that come just before this instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="codeline">    const auto *Locs = FnVarLocs.getWedge(&I);</td>
    <td class="lineNumber">2445</td>
    <td class="codeline">    const auto *Locs = FnVarLocs.getWedge(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="codeline">    if (!Locs)</td>
    <td class="lineNumber">2446</td>
    <td class="codeline">    if (!Locs)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">2447</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="codeline"></td>
    <td class="lineNumber">2448</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="codeline">    NumWedgesScanned++;</td>
    <td class="lineNumber">2449</td>
    <td class="codeline">    NumWedgesScanned++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="codeline">    bool ChangedThisWedge = false;</td>
    <td class="lineNumber">2450</td>
    <td class="codeline">    bool ChangedThisWedge = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="codeline">    // The new pruned set of defs.</td>
    <td class="lineNumber">2451</td>
    <td class="codeline">    // The new pruned set of defs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="codeline">    SmallVector<VarLocInfo> NewDefs;</td>
    <td class="lineNumber">2452</td>
    <td class="codeline">    SmallVector<VarLocInfo> NewDefs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="codeline"></td>
    <td class="lineNumber">2453</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="codeline">    // Iterate over the existing defs.</td>
    <td class="lineNumber">2454</td>
    <td class="codeline">    // Iterate over the existing defs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="codeline">    for (const VarLocInfo &Loc : *Locs) {</td>
    <td class="lineNumber">2455</td>
    <td class="codeline">    for (const VarLocInfo &Loc : *Locs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="codeline">      NumDefsScanned++;</td>
    <td class="lineNumber">2456</td>
    <td class="codeline">      NumDefsScanned++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="codeline">      DebugAggregate Aggr{FnVarLocs.getVariable(Loc.VariableID).getVariable(),</td>
    <td class="lineNumber">2457</td>
    <td class="codeline">      DebugAggregate Aggr{FnVarLocs.getVariable(Loc.VariableID).getVariable(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="codeline">                          Loc.DL.getInlinedAt()};</td>
    <td class="lineNumber">2458</td>
    <td class="codeline">                          Loc.DL.getInlinedAt()};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="codeline">      DebugVariable Var = FnVarLocs.getVariable(Loc.VariableID);</td>
    <td class="lineNumber">2459</td>
    <td class="codeline">      DebugVariable Var = FnVarLocs.getVariable(Loc.VariableID);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="codeline"></td>
    <td class="lineNumber">2460</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="codeline">      // Remove undef entries that are encountered before any non-undef</td>
    <td class="lineNumber">2461</td>
    <td class="codeline">      // Remove undef entries that are encountered before any non-undef</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="codeline">      // intrinsics from the entry block.</td>
    <td class="lineNumber">2462</td>
    <td class="codeline">      // intrinsics from the entry block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="codeline">      if (Loc.Values.isKillLocation(Loc.Expr) && !HasDefinedBits(Aggr, Var)) {</td>
    <td class="lineNumber">2463</td>
    <td class="codeline">      if (Loc.Values.isKillLocation(Loc.Expr) && !HasDefinedBits(Aggr, Var)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="codeline">        // Did not insert this Loc, which is the same as removing it.</td>
    <td class="lineNumber">2464</td>
    <td class="codeline">        // Did not insert this Loc, which is the same as removing it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="codeline">        NumDefsRemoved++;</td>
    <td class="lineNumber">2465</td>
    <td class="codeline">        NumDefsRemoved++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="codeline">        ChangedThisWedge = true;</td>
    <td class="lineNumber">2466</td>
    <td class="codeline">        ChangedThisWedge = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">2467</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2468</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="codeline"></td>
    <td class="lineNumber">2469</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="codeline">      DefineBits(Aggr, Var);</td>
    <td class="lineNumber">2470</td>
    <td class="codeline">      DefineBits(Aggr, Var);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="codeline">      NewDefs.push_back(Loc);</td>
    <td class="lineNumber">2471</td>
    <td class="codeline">      NewDefs.push_back(Loc);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2472</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="codeline"></td>
    <td class="lineNumber">2473</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="codeline">    // Replace the existing wedge with the pruned version.</td>
    <td class="lineNumber">2474</td>
    <td class="codeline">    // Replace the existing wedge with the pruned version.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2475</td>
    <td class="codeline">    if (ChangedThisWedge) {</td>
    <td class="lineNumber">2475</td>
    <td class="codeline">    if (ChangedThisWedge) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2476</td>
    <td class="codeline">      FnVarLocs.setWedge(&I, std::move(NewDefs));</td>
    <td class="lineNumber">2476</td>
    <td class="codeline">      FnVarLocs.setWedge(&I, std::move(NewDefs));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2477</td>
    <td class="codeline">      NumWedgesChanged++;</td>
    <td class="lineNumber">2477</td>
    <td class="codeline">      NumWedgesChanged++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2478</td>
    <td class="codeline">      Changed = true;</td>
    <td class="lineNumber">2478</td>
    <td class="codeline">      Changed = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2479</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2479</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2480</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2480</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2481</td>
    <td class="codeline"></td>
    <td class="lineNumber">2481</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2482</td>
    <td class="codeline">  return Changed;</td>
    <td class="lineNumber">2482</td>
    <td class="codeline">  return Changed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2483</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2483</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2484</td>
    <td class="codeline"></td>
    <td class="lineNumber">2484</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2485</td>
    <td class="codeline">static bool removeRedundantDbgLocs(const BasicBlock *BB,</td>
    <td class="lineNumber">2485</td>
    <td class="codeline">static bool removeRedundantDbgLocs(const BasicBlock *BB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2486</td>
    <td class="codeline">                                   FunctionVarLocsBuilder &FnVarLocs) {</td>
    <td class="lineNumber">2486</td>
    <td class="codeline">                                   FunctionVarLocsBuilder &FnVarLocs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2487</td>
    <td class="codeline">  bool MadeChanges = false;</td>
    <td class="lineNumber">2487</td>
    <td class="codeline">  bool MadeChanges = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2488</td>
    <td class="codeline">  MadeChanges |= removeRedundantDbgLocsUsingBackwardScan(BB, FnVarLocs);</td>
    <td class="lineNumber">2488</td>
    <td class="codeline">  MadeChanges |= removeRedundantDbgLocsUsingBackwardScan(BB, FnVarLocs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2489</td>
    <td class="codeline">  if (BB->isEntryBlock())</td>
    <td class="lineNumber">2489</td>
    <td class="codeline">  if (BB->isEntryBlock())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2490</td>
    <td class="codeline">    MadeChanges |= removeUndefDbgLocsFromEntryBlock(BB, FnVarLocs);</td>
    <td class="lineNumber">2490</td>
    <td class="codeline">    MadeChanges |= removeUndefDbgLocsFromEntryBlock(BB, FnVarLocs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2491</td>
    <td class="codeline">  MadeChanges |= removeRedundantDbgLocsUsingForwardScan(BB, FnVarLocs);</td>
    <td class="lineNumber">2491</td>
    <td class="codeline">  MadeChanges |= removeRedundantDbgLocsUsingForwardScan(BB, FnVarLocs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2492</td>
    <td class="codeline"></td>
    <td class="lineNumber">2492</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2493</td>
    <td class="codeline">  if (MadeChanges)</td>
    <td class="lineNumber">2493</td>
    <td class="codeline">  if (MadeChanges)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2494</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Removed redundant dbg locs from: " << BB->getName()</td>
    <td class="lineNumber">2494</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Removed redundant dbg locs from: " << BB->getName()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2495</td>
    <td class="codeline">                      << "\n");</td>
    <td class="lineNumber">2495</td>
    <td class="codeline">                      << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2496</td>
    <td class="codeline">  return MadeChanges;</td>
    <td class="lineNumber">2496</td>
    <td class="codeline">  return MadeChanges;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2497</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2497</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2498</td>
    <td class="codeline"></td>
    <td class="lineNumber">2498</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2499</td>
    <td class="codeline">static DenseSet<DebugAggregate> findVarsWithStackSlot(Function &Fn) {</td>
    <td class="lineNumber">2499</td>
    <td class="codeline">static DenseSet<DebugAggregate> findVarsWithStackSlot(Function &Fn) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2500</td>
    <td class="codeline">  DenseSet<DebugAggregate> Result;</td>
    <td class="lineNumber">2500</td>
    <td class="codeline">  DenseSet<DebugAggregate> Result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2501</td>
    <td class="codeline">  for (auto &BB : Fn) {</td>
    <td class="lineNumber">2501</td>
    <td class="codeline">  for (auto &BB : Fn) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2502</td>
    <td class="codeline">    for (auto &I : BB) {</td>
    <td class="lineNumber">2502</td>
    <td class="codeline">    for (auto &I : BB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2503</td>
    <td class="codeline">      // Any variable linked to an instruction is considered</td>
    <td class="lineNumber">2503</td>
    <td class="codeline">      // Any variable linked to an instruction is considered</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2504</td>
    <td class="codeline">      // interesting. Ideally we only need to check Allocas, however, a</td>
    <td class="lineNumber">2504</td>
    <td class="codeline">      // interesting. Ideally we only need to check Allocas, however, a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2505</td>
    <td class="codeline">      // DIAssignID might get dropped from an alloca but not stores. In that</td>
    <td class="lineNumber">2505</td>
    <td class="codeline">      // DIAssignID might get dropped from an alloca but not stores. In that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2506</td>
    <td class="codeline">      // case, we need to consider the variable interesting for NFC behaviour</td>
    <td class="lineNumber">2506</td>
    <td class="codeline">      // case, we need to consider the variable interesting for NFC behaviour</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2507</td>
    <td class="codeline">      // with this change. TODO: Consider only looking at allocas.</td>
    <td class="lineNumber">2507</td>
    <td class="codeline">      // with this change. TODO: Consider only looking at allocas.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2508</td>
    <td class="codeline">      for (DbgAssignIntrinsic *DAI : at::getAssignmentMarkers(&I)) {</td>
    <td class="lineNumber">2508</td>
    <td class="codeline">      for (DbgAssignIntrinsic *DAI : at::getAssignmentMarkers(&I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2509</td>
    <td class="codeline">        Result.insert({DAI->getVariable(), DAI->getDebugLoc().getInlinedAt()});</td>
    <td class="lineNumber">2509</td>
    <td class="codeline">        Result.insert({DAI->getVariable(), DAI->getDebugLoc().getInlinedAt()});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2510</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2510</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2511</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2511</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2512</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2512</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2513</td>
    <td class="codeline">  return Result;</td>
    <td class="lineNumber">2513</td>
    <td class="codeline">  return Result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2514</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2514</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2515</td>
    <td class="codeline"></td>
    <td class="lineNumber">2515</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2516</td>
    <td class="codeline">static void analyzeFunction(Function &Fn, const DataLayout &Layout,</td>
    <td class="lineNumber">2516</td>
    <td class="codeline">static void analyzeFunction(Function &Fn, const DataLayout &Layout,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2517</td>
    <td class="codeline">                            FunctionVarLocsBuilder *FnVarLocs) {</td>
    <td class="lineNumber">2517</td>
    <td class="codeline">                            FunctionVarLocsBuilder *FnVarLocs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2518</td>
    <td class="codeline">  // The analysis will generate location definitions for all variables, but we</td>
    <td class="lineNumber">2518</td>
    <td class="codeline">  // The analysis will generate location definitions for all variables, but we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2519</td>
    <td class="codeline">  // only need to perform a dataflow on the set of variables which have a stack</td>
    <td class="lineNumber">2519</td>
    <td class="codeline">  // only need to perform a dataflow on the set of variables which have a stack</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2520</td>
    <td class="codeline">  // slot. Find those now.</td>
    <td class="lineNumber">2520</td>
    <td class="codeline">  // slot. Find those now.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2521</td>
    <td class="codeline">  DenseSet<DebugAggregate> VarsWithStackSlot = findVarsWithStackSlot(Fn);</td>
    <td class="lineNumber">2521</td>
    <td class="codeline">  DenseSet<DebugAggregate> VarsWithStackSlot = findVarsWithStackSlot(Fn);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2522</td>
    <td class="codeline"></td>
    <td class="lineNumber">2522</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2523</td>
    <td class="codeline">  bool Changed = false;</td>
    <td class="lineNumber">2523</td>
    <td class="codeline">  bool Changed = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2524</td>
    <td class="codeline"></td>
    <td class="lineNumber">2524</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2525</td>
    <td class="codeline">  // Use a scope block to clean up AssignmentTrackingLowering before running</td>
    <td class="lineNumber">2525</td>
    <td class="codeline">  // Use a scope block to clean up AssignmentTrackingLowering before running</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2526</td>
    <td class="codeline">  // MemLocFragmentFill to reduce peak memory consumption.</td>
    <td class="lineNumber">2526</td>
    <td class="codeline">  // MemLocFragmentFill to reduce peak memory consumption.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2527</td>
    <td class="codeline">  {</td>
    <td class="lineNumber">2527</td>
    <td class="codeline">  {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2528</td>
    <td class="codeline">    AssignmentTrackingLowering Pass(Fn, Layout, &VarsWithStackSlot);</td>
    <td class="lineNumber">2528</td>
    <td class="codeline">    AssignmentTrackingLowering Pass(Fn, Layout, &VarsWithStackSlot);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2529</td>
    <td class="codeline">    Changed = Pass.run(FnVarLocs);</td>
    <td class="lineNumber">2529</td>
    <td class="codeline">    Changed = Pass.run(FnVarLocs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2530</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2530</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2531</td>
    <td class="codeline"></td>
    <td class="lineNumber">2531</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2532</td>
    <td class="codeline">  if (Changed) {</td>
    <td class="lineNumber">2532</td>
    <td class="codeline">  if (Changed) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2533</td>
    <td class="codeline">    MemLocFragmentFill Pass(Fn, &VarsWithStackSlot,</td>
    <td class="lineNumber">2533</td>
    <td class="codeline">    MemLocFragmentFill Pass(Fn, &VarsWithStackSlot,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2534</td>
    <td class="codeline">                            shouldCoalesceFragments(Fn));</td>
    <td class="lineNumber">2534</td>
    <td class="codeline">                            shouldCoalesceFragments(Fn));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2535</td>
    <td class="codeline">    Pass.run(FnVarLocs);</td>
    <td class="lineNumber">2535</td>
    <td class="codeline">    Pass.run(FnVarLocs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2536</td>
    <td class="codeline"></td>
    <td class="lineNumber">2536</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2537</td>
    <td class="codeline">    // Remove redundant entries. As well as reducing memory consumption and</td>
    <td class="lineNumber">2537</td>
    <td class="codeline">    // Remove redundant entries. As well as reducing memory consumption and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2538</td>
    <td class="codeline">    // avoiding waiting cycles later by burning some now, this has another</td>
    <td class="lineNumber">2538</td>
    <td class="codeline">    // avoiding waiting cycles later by burning some now, this has another</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2539</td>
    <td class="codeline">    // important job. That is to work around some SelectionDAG quirks. See</td>
    <td class="lineNumber">2539</td>
    <td class="codeline">    // important job. That is to work around some SelectionDAG quirks. See</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2540</td>
    <td class="codeline">    // removeRedundantDbgLocsUsingForwardScan comments for more info on that.</td>
    <td class="lineNumber">2540</td>
    <td class="codeline">    // removeRedundantDbgLocsUsingForwardScan comments for more info on that.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2541</td>
    <td class="codeline">    for (auto &BB : Fn)</td>
    <td class="lineNumber">2541</td>
    <td class="codeline">    for (auto &BB : Fn)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2542</td>
    <td class="codeline">      removeRedundantDbgLocs(&BB, *FnVarLocs);</td>
    <td class="lineNumber">2542</td>
    <td class="codeline">      removeRedundantDbgLocs(&BB, *FnVarLocs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2543</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2543</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2544</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2544</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2545</td>
    <td class="codeline"></td>
    <td class="lineNumber">2545</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2546</td>
    <td class="codeline">bool AssignmentTrackingAnalysis::runOnFunction(Function &F) {</td>
    <td class="lineNumber">2546</td>
    <td class="codeline">bool AssignmentTrackingAnalysis::runOnFunction(Function &F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2547</td>
    <td class="codeline">  if (!isAssignmentTrackingEnabled(*F.getParent()))</td>
    <td class="lineNumber">2547</td>
    <td class="codeline">  if (!isAssignmentTrackingEnabled(*F.getParent()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2548</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2548</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2549</td>
    <td class="codeline"></td>
    <td class="lineNumber">2549</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2550</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "AssignmentTrackingAnalysis run on " << F.getName()</td>
    <td class="lineNumber">2550</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "AssignmentTrackingAnalysis run on " << F.getName()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2551</td>
    <td class="codeline">                    << "\n");</td>
    <td class="lineNumber">2551</td>
    <td class="codeline">                    << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2552</td>
    <td class="codeline">  auto DL = std::make_unique<DataLayout>(F.getParent());</td>
    <td class="lineNumber">2552</td>
    <td class="codeline">  auto DL = std::make_unique<DataLayout>(F.getParent());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2553</td>
    <td class="codeline"></td>
    <td class="lineNumber">2553</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2554</td>
    <td class="codeline">  // Clear previous results.</td>
    <td class="lineNumber">2554</td>
    <td class="codeline">  // Clear previous results.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2555</td>
    <td class="codeline">  Results->clear();</td>
    <td class="lineNumber">2555</td>
    <td class="codeline">  Results->clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2556</td>
    <td class="codeline"></td>
    <td class="lineNumber">2556</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2557</td>
    <td class="codeline">  FunctionVarLocsBuilder Builder;</td>
    <td class="lineNumber">2557</td>
    <td class="codeline">  FunctionVarLocsBuilder Builder;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2558</td>
    <td class="codeline">  analyzeFunction(F, *DL.get(), &Builder);</td>
    <td class="lineNumber">2558</td>
    <td class="codeline">  analyzeFunction(F, *DL.get(), &Builder);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2559</td>
    <td class="codeline"></td>
    <td class="lineNumber">2559</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2560</td>
    <td class="codeline">  // Save these results.</td>
    <td class="lineNumber">2560</td>
    <td class="codeline">  // Save these results.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2561</td>
    <td class="codeline">  Results->init(Builder);</td>
    <td class="lineNumber">2561</td>
    <td class="codeline">  Results->init(Builder);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2562</td>
    <td class="codeline"></td>
    <td class="lineNumber">2562</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2563</td>
    <td class="codeline">  if (PrintResults && isFunctionInPrintList(F.getName()))</td>
    <td class="lineNumber">2563</td>
    <td class="codeline">  if (PrintResults && isFunctionInPrintList(F.getName()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2564</td>
    <td class="codeline">    Results->print(errs(), F);</td>
    <td class="lineNumber">2564</td>
    <td class="codeline">    Results->print(errs(), F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2565</td>
    <td class="codeline"></td>
    <td class="lineNumber">2565</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2566</td>
    <td class="codeline">  // Return false because this pass does not modify the function.</td>
    <td class="lineNumber">2566</td>
    <td class="codeline">  // Return false because this pass does not modify the function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2567</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">2567</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2568</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2568</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2569</td>
    <td class="codeline"></td>
    <td class="lineNumber">2569</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2570</td>
    <td class="codeline">AssignmentTrackingAnalysis::AssignmentTrackingAnalysis()</td>
    <td class="lineNumber">2570</td>
    <td class="codeline">AssignmentTrackingAnalysis::AssignmentTrackingAnalysis()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2571</td>
    <td class="codeline">    : FunctionPass(ID), Results(std::make_unique<FunctionVarLocs>()) {}</td>
    <td class="lineNumber">2571</td>
    <td class="codeline">    : FunctionPass(ID), Results(std::make_unique<FunctionVarLocs>()) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2572</td>
    <td class="codeline"></td>
    <td class="lineNumber">2572</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2573</td>
    <td class="codeline">char AssignmentTrackingAnalysis::ID = 0;</td>
    <td class="lineNumber">2573</td>
    <td class="codeline">char AssignmentTrackingAnalysis::ID = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2574</td>
    <td class="codeline"></td>
    <td class="lineNumber">2574</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2575</td>
    <td class="codeline">INITIALIZE_PASS(AssignmentTrackingAnalysis, DEBUG_TYPE,</td>
    <td class="lineNumber">2575</td>
    <td class="codeline">INITIALIZE_PASS(AssignmentTrackingAnalysis, DEBUG_TYPE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2576</td>
    <td class="codeline">                "Assignment Tracking Analysis", false, true)</td>
    <td class="lineNumber">2576</td>
    <td class="codeline">                "Assignment Tracking Analysis", false, true)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2577</td>
    <td class="codeline"></td>
    <td class="lineNumber">2577</td>
    <td class="codeline"></td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Side By Side Comparison</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Side By Side Comparison</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeLine">#include "llvm/CodeGen/AssignmentTrackingAnalysis.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1</td>
    <td class="codeLine">#include "llvm/CodeGen/AssignmentTrackingAnalysis.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeLine">#include "LiveDebugValues/LiveDebugValues.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2</td>
    <td class="codeLine">#include "LiveDebugValues/LiveDebugValues.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeLine">#include "llvm/ADT/BitVector.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3</td>
    <td class="codeLine">#include "llvm/ADT/BitVector.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeLine">#include "llvm/ADT/DenseMapInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4</td>
    <td class="codeLine">#include "llvm/ADT/DenseMapInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeLine">#include "llvm/ADT/IntervalMap.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5</td>
    <td class="codeLine">#include "llvm/ADT/IntervalMap.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeLine">#include "llvm/ADT/PostOrderIterator.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">6</td>
    <td class="codeLine">#include "llvm/ADT/PostOrderIterator.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeLine">#include "llvm/ADT/STLExtras.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">7</td>
    <td class="codeLine">#include "llvm/ADT/STLExtras.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeLine">#include "llvm/ADT/SmallSet.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">8</td>
    <td class="codeLine">#include "llvm/ADT/SmallSet.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeLine">#include "llvm/ADT/Statistic.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">9</td>
    <td class="codeLine">#include "llvm/ADT/Statistic.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeLine">#include "llvm/ADT/UniqueVector.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">10</td>
    <td class="codeLine">#include "llvm/ADT/UniqueVector.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeLine">#include "llvm/Analysis/Interval.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">11</td>
    <td class="codeLine">#include "llvm/Analysis/Interval.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeLine">#include "llvm/BinaryFormat/Dwarf.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">12</td>
    <td class="codeLine">#include "llvm/BinaryFormat/Dwarf.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeLine">#include "llvm/IR/BasicBlock.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">13</td>
    <td class="codeLine">#include "llvm/IR/BasicBlock.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeLine">#include "llvm/IR/DataLayout.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">14</td>
    <td class="codeLine">#include "llvm/IR/DataLayout.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeLine">#include "llvm/IR/DebugInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">15</td>
    <td class="codeLine">#include "llvm/IR/DebugInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeLine">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">16</td>
    <td class="codeLine">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeLine">#include "llvm/IR/Instruction.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">17</td>
    <td class="codeLine">#include "llvm/IR/Instruction.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeLine">#include "llvm/IR/IntrinsicInst.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">18</td>
    <td class="codeLine">#include "llvm/IR/IntrinsicInst.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeLine">#include "llvm/IR/PassManager.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">19</td>
    <td class="codeLine">#include "llvm/IR/PassManager.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeLine">#include "llvm/IR/PrintPasses.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">20</td>
    <td class="codeLine">#include "llvm/IR/PrintPasses.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeLine">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">21</td>
    <td class="codeLine">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/Support/ErrorHandling.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/Support/ErrorHandling.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/BasicBlockUtils.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/BasicBlockUtils.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeLine">#include <assert.h></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">26</td>
    <td class="codeLine">#include <assert.h></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeLine">#include <cstdint></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">27</td>
    <td class="codeLine">#include <cstdint></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeLine">#include <optional></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">28</td>
    <td class="codeLine">#include <optional></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeLine">#include <sstream></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">29</td>
    <td class="codeLine">#include <sstream></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeLine">#include <unordered_map></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">30</td>
    <td class="codeLine">#include <unordered_map></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">31</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">32</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeLine">#define DEBUG_TYPE "debug-ata"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">33</td>
    <td class="codeLine">#define DEBUG_TYPE "debug-ata"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">34</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeLine">STATISTIC(NumDefsScanned, "Number of dbg locs that get scanned for removal");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">35</td>
    <td class="codeLine">STATISTIC(NumDefsScanned, "Number of dbg locs that get scanned for removal");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeLine">STATISTIC(NumDefsRemoved, "Number of dbg locs removed");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">36</td>
    <td class="codeLine">STATISTIC(NumDefsRemoved, "Number of dbg locs removed");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeLine">STATISTIC(NumWedgesScanned, "Number of dbg wedges scanned");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">37</td>
    <td class="codeLine">STATISTIC(NumWedgesScanned, "Number of dbg wedges scanned");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeLine">STATISTIC(NumWedgesChanged, "Number of dbg wedges changed");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">38</td>
    <td class="codeLine">STATISTIC(NumWedgesChanged, "Number of dbg wedges changed");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">39</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeLine">static cl::opt<unsigned></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">40</td>
    <td class="codeLine">static cl::opt<unsigned></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeLine">    MaxNumBlocks("debug-ata-max-blocks", cl::init(10000),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">41</td>
    <td class="codeLine">    MaxNumBlocks("debug-ata-max-blocks", cl::init(10000),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeLine">                 cl::desc("Maximum num basic blocks before debug info dropped"),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">42</td>
    <td class="codeLine">                 cl::desc("Maximum num basic blocks before debug info dropped"),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeLine">                 cl::Hidden);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">43</td>
    <td class="codeLine">                 cl::Hidden);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeLine">/// Option for debugging the pass, determines if the memory location fragment</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">44</td>
    <td class="codeLine">/// Option for debugging the pass, determines if the memory location fragment</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeLine">/// filling happens after generating the variable locations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">45</td>
    <td class="codeLine">/// filling happens after generating the variable locations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeLine">static cl::opt<bool> EnableMemLocFragFill("mem-loc-frag-fill", cl::init(true),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">46</td>
    <td class="codeLine">static cl::opt<bool> EnableMemLocFragFill("mem-loc-frag-fill", cl::init(true),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeLine">                                          cl::Hidden);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">47</td>
    <td class="codeLine">                                          cl::Hidden);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeLine">/// Print the results of the analysis. Respects -filter-print-funcs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">48</td>
    <td class="codeLine">/// Print the results of the analysis. Respects -filter-print-funcs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeLine">static cl::opt<bool> PrintResults("print-debug-ata", cl::init(false),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">49</td>
    <td class="codeLine">static cl::opt<bool> PrintResults("print-debug-ata", cl::init(false),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeLine">                                  cl::Hidden);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">50</td>
    <td class="codeLine">                                  cl::Hidden);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">51</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeLine">/// Coalesce adjacent dbg locs describing memory locations that have contiguous</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">52</td>
    <td class="codeLine">/// Coalesce adjacent dbg locs describing memory locations that have contiguous</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeLine">/// fragments. This reduces the cost of LiveDebugValues which does SSA</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">53</td>
    <td class="codeLine">/// fragments. This reduces the cost of LiveDebugValues which does SSA</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeLine">/// construction for each explicitly stated variable fragment.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">54</td>
    <td class="codeLine">/// construction for each explicitly stated variable fragment.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeLine">static cl::opt<cl::boolOrDefault></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">55</td>
    <td class="codeLine">static cl::opt<cl::boolOrDefault></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeLine">    CoalesceAdjacentFragmentsOpt("debug-ata-coalesce-frags", cl::Hidden);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">56</td>
    <td class="codeLine">    CoalesceAdjacentFragmentsOpt("debug-ata-coalesce-frags", cl::Hidden);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">57</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeLine">// Implicit conversions are disabled for enum class types, so unfortunately we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">58</td>
    <td class="codeLine">// Implicit conversions are disabled for enum class types, so unfortunately we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeLine">// need to create a DenseMapInfo wrapper around the specified underlying type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">59</td>
    <td class="codeLine">// need to create a DenseMapInfo wrapper around the specified underlying type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeLine">template <> struct llvm::DenseMapInfo<VariableID> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">60</td>
    <td class="codeLine">template <> struct llvm::DenseMapInfo<VariableID> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeLine">  using Wrapped = DenseMapInfo<unsigned>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">61</td>
    <td class="codeLine">  using Wrapped = DenseMapInfo<unsigned>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeLine">  static inline VariableID getEmptyKey() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">62</td>
    <td class="codeLine">  static inline VariableID getEmptyKey() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeLine">    return static_cast<VariableID>(Wrapped::getEmptyKey());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">63</td>
    <td class="codeLine">    return static_cast<VariableID>(Wrapped::getEmptyKey());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">64</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeLine">  static inline VariableID getTombstoneKey() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">65</td>
    <td class="codeLine">  static inline VariableID getTombstoneKey() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeLine">    return static_cast<VariableID>(Wrapped::getTombstoneKey());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">66</td>
    <td class="codeLine">    return static_cast<VariableID>(Wrapped::getTombstoneKey());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">67</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeLine">  static unsigned getHashValue(const VariableID &Val) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">68</td>
    <td class="codeLine">  static unsigned getHashValue(const VariableID &Val) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeLine">    return Wrapped::getHashValue(static_cast<unsigned>(Val));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">69</td>
    <td class="codeLine">    return Wrapped::getHashValue(static_cast<unsigned>(Val));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">70</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeLine">  static bool isEqual(const VariableID &LHS, const VariableID &RHS) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">71</td>
    <td class="codeLine">  static bool isEqual(const VariableID &LHS, const VariableID &RHS) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeLine">    return LHS == RHS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">72</td>
    <td class="codeLine">    return LHS == RHS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">73</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">74</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">75</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeLine">/// Helper class to build FunctionVarLocs, since that class isn't easy to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">76</td>
    <td class="codeLine">/// Helper class to build FunctionVarLocs, since that class isn't easy to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeLine">/// modify. TODO: There's not a great deal of value in the split, it could be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">77</td>
    <td class="codeLine">/// modify. TODO: There's not a great deal of value in the split, it could be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeLine">/// worth merging the two classes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">78</td>
    <td class="codeLine">/// worth merging the two classes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeLine">class FunctionVarLocsBuilder {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">79</td>
    <td class="codeLine">class FunctionVarLocsBuilder {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeLine">  friend FunctionVarLocs;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">80</td>
    <td class="codeLine">  friend FunctionVarLocs;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeLine">  UniqueVector<DebugVariable> Variables;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">81</td>
    <td class="codeLine">  UniqueVector<DebugVariable> Variables;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeLine">  // Use an unordered_map so we don't invalidate iterators after</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">82</td>
    <td class="codeLine">  // Use an unordered_map so we don't invalidate iterators after</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeLine">  // insert/modifications.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">83</td>
    <td class="codeLine">  // insert/modifications.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeLine">  std::unordered_map<const Instruction *, SmallVector<VarLocInfo>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">84</td>
    <td class="codeLine">  std::unordered_map<const Instruction *, SmallVector<VarLocInfo>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeLine">      VarLocsBeforeInst;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">85</td>
    <td class="codeLine">      VarLocsBeforeInst;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">86</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeLine">  SmallVector<VarLocInfo> SingleLocVars;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">87</td>
    <td class="codeLine">  SmallVector<VarLocInfo> SingleLocVars;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">88</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">89</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeLine">  unsigned getNumVariables() const { return Variables.size(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">90</td>
    <td class="codeLine">  unsigned getNumVariables() const { return Variables.size(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">91</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeLine">  /// Find or insert \p V and return the ID.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">92</td>
    <td class="codeLine">  /// Find or insert \p V and return the ID.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeLine">  VariableID insertVariable(DebugVariable V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">93</td>
    <td class="codeLine">  VariableID insertVariable(DebugVariable V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeLine">    return static_cast<VariableID>(Variables.insert(V));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">94</td>
    <td class="codeLine">    return static_cast<VariableID>(Variables.insert(V));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">95</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">96</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeLine">  /// Get a variable from its \p ID.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">97</td>
    <td class="codeLine">  /// Get a variable from its \p ID.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeLine">  const DebugVariable &getVariable(VariableID ID) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">98</td>
    <td class="codeLine">  const DebugVariable &getVariable(VariableID ID) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeLine">    return Variables[static_cast<unsigned>(ID)];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">99</td>
    <td class="codeLine">    return Variables[static_cast<unsigned>(ID)];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">100</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">101</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeLine">  /// Return ptr to wedge of defs or nullptr if no defs come just before /p</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">102</td>
    <td class="codeLine">  /// Return ptr to wedge of defs or nullptr if no defs come just before /p</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeLine">  /// Before.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">103</td>
    <td class="codeLine">  /// Before.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeLine">  const SmallVectorImpl<VarLocInfo> *getWedge(const Instruction *Before) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">104</td>
    <td class="codeLine">  const SmallVectorImpl<VarLocInfo> *getWedge(const Instruction *Before) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeLine">    auto R = VarLocsBeforeInst.find(Before);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">105</td>
    <td class="codeLine">    auto R = VarLocsBeforeInst.find(Before);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeLine">    if (R == VarLocsBeforeInst.end())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">106</td>
    <td class="codeLine">    if (R == VarLocsBeforeInst.end())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeLine">      return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">107</td>
    <td class="codeLine">      return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeLine">    return &R->second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">108</td>
    <td class="codeLine">    return &R->second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">109</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">110</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeLine">  /// Replace the defs that come just before /p Before with /p Wedge.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">111</td>
    <td class="codeLine">  /// Replace the defs that come just before /p Before with /p Wedge.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeLine">  void setWedge(const Instruction *Before, SmallVector<VarLocInfo> &&Wedge) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">112</td>
    <td class="codeLine">  void setWedge(const Instruction *Before, SmallVector<VarLocInfo> &&Wedge) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeLine">    VarLocsBeforeInst[Before] = std::move(Wedge);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">113</td>
    <td class="codeLine">    VarLocsBeforeInst[Before] = std::move(Wedge);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">114</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">115</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeLine">  /// Add a def for a variable that is valid for its lifetime.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">116</td>
    <td class="codeLine">  /// Add a def for a variable that is valid for its lifetime.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeLine">  void addSingleLocVar(DebugVariable Var, DIExpression *Expr, DebugLoc DL,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">117</td>
    <td class="codeLine">  void addSingleLocVar(DebugVariable Var, DIExpression *Expr, DebugLoc DL,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeLine">                       RawLocationWrapper R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">118</td>
    <td class="codeLine">                       RawLocationWrapper R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeLine">    VarLocInfo VarLoc;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">119</td>
    <td class="codeLine">    VarLocInfo VarLoc;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeLine">    VarLoc.VariableID = insertVariable(Var);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">120</td>
    <td class="codeLine">    VarLoc.VariableID = insertVariable(Var);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeLine">    VarLoc.Expr = Expr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">121</td>
    <td class="codeLine">    VarLoc.Expr = Expr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeLine">    VarLoc.DL = DL;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">122</td>
    <td class="codeLine">    VarLoc.DL = DL;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeLine">    VarLoc.Values = R;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">123</td>
    <td class="codeLine">    VarLoc.Values = R;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeLine">    SingleLocVars.emplace_back(VarLoc);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">124</td>
    <td class="codeLine">    SingleLocVars.emplace_back(VarLoc);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">125</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">126</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeLine">  /// Add a def to the wedge of defs just before /p Before.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">127</td>
    <td class="codeLine">  /// Add a def to the wedge of defs just before /p Before.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeLine">  void addVarLoc(Instruction *Before, DebugVariable Var, DIExpression *Expr,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">128</td>
    <td class="codeLine">  void addVarLoc(Instruction *Before, DebugVariable Var, DIExpression *Expr,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeLine">                 DebugLoc DL, RawLocationWrapper R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">129</td>
    <td class="codeLine">                 DebugLoc DL, RawLocationWrapper R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeLine">    VarLocInfo VarLoc;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">130</td>
    <td class="codeLine">    VarLocInfo VarLoc;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeLine">    VarLoc.VariableID = insertVariable(Var);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">131</td>
    <td class="codeLine">    VarLoc.VariableID = insertVariable(Var);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeLine">    VarLoc.Expr = Expr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">132</td>
    <td class="codeLine">    VarLoc.Expr = Expr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeLine">    VarLoc.DL = DL;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">133</td>
    <td class="codeLine">    VarLoc.DL = DL;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeLine">    VarLoc.Values = R;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">134</td>
    <td class="codeLine">    VarLoc.Values = R;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeLine">    VarLocsBeforeInst[Before].emplace_back(VarLoc);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">135</td>
    <td class="codeLine">    VarLocsBeforeInst[Before].emplace_back(VarLoc);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">136</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">137</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">138</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeLine">void FunctionVarLocs::print(raw_ostream &OS, const Function &Fn) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">139</td>
    <td class="codeLine">void FunctionVarLocs::print(raw_ostream &OS, const Function &Fn) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeLine">  // Print the variable table first. TODO: Sorting by variable could make the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">140</td>
    <td class="codeLine">  // Print the variable table first. TODO: Sorting by variable could make the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeLine">  // output more stable?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">141</td>
    <td class="codeLine">  // output more stable?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeLine">  unsigned Counter = -1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">142</td>
    <td class="codeLine">  unsigned Counter = -1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeLine">  OS << "=== Variables ===\n";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">143</td>
    <td class="codeLine">  OS << "=== Variables ===\n";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeLine">  for (const DebugVariable &V : Variables) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">144</td>
    <td class="codeLine">  for (const DebugVariable &V : Variables) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeLine">    ++Counter;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">145</td>
    <td class="codeLine">    ++Counter;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeLine">    // Skip first entry because it is a dummy entry.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">146</td>
    <td class="codeLine">    // Skip first entry because it is a dummy entry.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeLine">    if (Counter == 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">147</td>
    <td class="codeLine">    if (Counter == 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">148</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">149</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeLine">    OS << "[" << Counter << "] " << V.getVariable()->getName();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">150</td>
    <td class="codeLine">    OS << "[" << Counter << "] " << V.getVariable()->getName();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeLine">    if (auto F = V.getFragment())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">151</td>
    <td class="codeLine">    if (auto F = V.getFragment())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeLine">      OS << " bits [" << F->OffsetInBits << ", "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">152</td>
    <td class="codeLine">      OS << " bits [" << F->OffsetInBits << ", "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeLine">         << F->OffsetInBits + F->SizeInBits << ")";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">153</td>
    <td class="codeLine">         << F->OffsetInBits + F->SizeInBits << ")";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeLine">    if (const auto *IA = V.getInlinedAt())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">154</td>
    <td class="codeLine">    if (const auto *IA = V.getInlinedAt())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeLine">      OS << " inlined-at " << *IA;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">155</td>
    <td class="codeLine">      OS << " inlined-at " << *IA;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeLine">    OS << "\n";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">156</td>
    <td class="codeLine">    OS << "\n";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">157</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">158</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeLine">  auto PrintLoc = [&OS](const VarLocInfo &Loc) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">159</td>
    <td class="codeLine">  auto PrintLoc = [&OS](const VarLocInfo &Loc) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeLine">    OS << "DEF Var=[" << (unsigned)Loc.VariableID << "]"</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">160</td>
    <td class="codeLine">    OS << "DEF Var=[" << (unsigned)Loc.VariableID << "]"</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeLine">       << " Expr=" << *Loc.Expr << " Values=(";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">161</td>
    <td class="codeLine">       << " Expr=" << *Loc.Expr << " Values=(";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeLine">    for (auto *Op : Loc.Values.location_ops()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">162</td>
    <td class="codeLine">    for (auto *Op : Loc.Values.location_ops()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeLine">      errs() << Op->getName() << " ";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">163</td>
    <td class="codeLine">      errs() << Op->getName() << " ";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">164</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeLine">    errs() << ")\n";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">165</td>
    <td class="codeLine">    errs() << ")\n";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">166</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">167</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeLine">  // Print the single location variables.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">168</td>
    <td class="codeLine">  // Print the single location variables.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeLine">  OS << "=== Single location vars ===\n";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">169</td>
    <td class="codeLine">  OS << "=== Single location vars ===\n";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeLine">  for (auto It = single_locs_begin(), End = single_locs_end(); It != End;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">170</td>
    <td class="codeLine">  for (auto It = single_locs_begin(), End = single_locs_end(); It != End;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeLine">       ++It) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">171</td>
    <td class="codeLine">       ++It) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeLine">    PrintLoc(*It);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">172</td>
    <td class="codeLine">    PrintLoc(*It);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">173</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">174</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeLine">  // Print the non-single-location defs in line with IR.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">175</td>
    <td class="codeLine">  // Print the non-single-location defs in line with IR.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeLine">  OS << "=== In-line variable defs ===";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">176</td>
    <td class="codeLine">  OS << "=== In-line variable defs ===";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeLine">  for (const BasicBlock &BB : Fn) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">177</td>
    <td class="codeLine">  for (const BasicBlock &BB : Fn) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeLine">    OS << "\n" << BB.getName() << ":\n";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">178</td>
    <td class="codeLine">    OS << "\n" << BB.getName() << ":\n";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeLine">    for (const Instruction &I : BB) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">179</td>
    <td class="codeLine">    for (const Instruction &I : BB) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeLine">      for (auto It = locs_begin(&I), End = locs_end(&I); It != End; ++It) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">180</td>
    <td class="codeLine">      for (auto It = locs_begin(&I), End = locs_end(&I); It != End; ++It) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeLine">        PrintLoc(*It);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">181</td>
    <td class="codeLine">        PrintLoc(*It);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">182</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeLine">      OS << I << "\n";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">183</td>
    <td class="codeLine">      OS << I << "\n";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">184</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">185</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">186</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">187</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeLine">void FunctionVarLocs::init(FunctionVarLocsBuilder &Builder) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">188</td>
    <td class="codeLine">void FunctionVarLocs::init(FunctionVarLocsBuilder &Builder) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeLine">  // Add the single-location variables first.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">189</td>
    <td class="codeLine">  // Add the single-location variables first.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeLine">  for (const auto &VarLoc : Builder.SingleLocVars)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">190</td>
    <td class="codeLine">  for (const auto &VarLoc : Builder.SingleLocVars)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeLine">    VarLocRecords.emplace_back(VarLoc);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">191</td>
    <td class="codeLine">    VarLocRecords.emplace_back(VarLoc);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeLine">  // Mark the end of the section.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">192</td>
    <td class="codeLine">  // Mark the end of the section.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeLine">  SingleVarLocEnd = VarLocRecords.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">193</td>
    <td class="codeLine">  SingleVarLocEnd = VarLocRecords.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">194</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeLine">  // Insert a contiguous block of VarLocInfos for each instruction, mapping it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">195</td>
    <td class="codeLine">  // Insert a contiguous block of VarLocInfos for each instruction, mapping it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeLine">  // to the start and end position in the vector with VarLocsBeforeInst.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">196</td>
    <td class="codeLine">  // to the start and end position in the vector with VarLocsBeforeInst.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeLine">  for (auto &P : Builder.VarLocsBeforeInst) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">197</td>
    <td class="codeLine">  for (auto &P : Builder.VarLocsBeforeInst) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeLine">    unsigned BlockStart = VarLocRecords.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">198</td>
    <td class="codeLine">    unsigned BlockStart = VarLocRecords.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeLine">    for (const VarLocInfo &VarLoc : P.second)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">199</td>
    <td class="codeLine">    for (const VarLocInfo &VarLoc : P.second)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeLine">      VarLocRecords.emplace_back(VarLoc);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">200</td>
    <td class="codeLine">      VarLocRecords.emplace_back(VarLoc);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeLine">    unsigned BlockEnd = VarLocRecords.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">201</td>
    <td class="codeLine">    unsigned BlockEnd = VarLocRecords.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeLine">    // Record the start and end indices.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">202</td>
    <td class="codeLine">    // Record the start and end indices.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeLine">    if (BlockEnd != BlockStart)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">203</td>
    <td class="codeLine">    if (BlockEnd != BlockStart)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeLine">      VarLocsBeforeInst[P.first] = {BlockStart, BlockEnd};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">204</td>
    <td class="codeLine">      VarLocsBeforeInst[P.first] = {BlockStart, BlockEnd};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">205</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">206</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeLine">  // Copy the Variables vector from the builder's UniqueVector.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">207</td>
    <td class="codeLine">  // Copy the Variables vector from the builder's UniqueVector.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeLine">  assert(Variables.empty() && "Expect clear before init");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">208</td>
    <td class="codeLine">  assert(Variables.empty() && "Expect clear before init");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeLine">  // UniqueVectors IDs are one-based (which means the VarLocInfo VarID values</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">209</td>
    <td class="codeLine">  // UniqueVectors IDs are one-based (which means the VarLocInfo VarID values</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeLine">  // are one-based) so reserve an extra and insert a dummy.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">210</td>
    <td class="codeLine">  // are one-based) so reserve an extra and insert a dummy.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeLine">  Variables.reserve(Builder.Variables.size() + 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">211</td>
    <td class="codeLine">  Variables.reserve(Builder.Variables.size() + 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeLine">  Variables.push_back(DebugVariable(nullptr, std::nullopt, nullptr));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">212</td>
    <td class="codeLine">  Variables.push_back(DebugVariable(nullptr, std::nullopt, nullptr));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeLine">  Variables.append(Builder.Variables.begin(), Builder.Variables.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">213</td>
    <td class="codeLine">  Variables.append(Builder.Variables.begin(), Builder.Variables.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">214</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">215</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeLine">void FunctionVarLocs::clear() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">216</td>
    <td class="codeLine">void FunctionVarLocs::clear() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeLine">  Variables.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">217</td>
    <td class="codeLine">  Variables.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeLine">  VarLocRecords.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">218</td>
    <td class="codeLine">  VarLocRecords.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeLine">  VarLocsBeforeInst.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">219</td>
    <td class="codeLine">  VarLocsBeforeInst.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeLine">  SingleVarLocEnd = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">220</td>
    <td class="codeLine">  SingleVarLocEnd = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">221</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">222</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeLine">/// Walk backwards along constant GEPs and bitcasts to the base storage from \p</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">223</td>
    <td class="codeLine">/// Walk backwards along constant GEPs and bitcasts to the base storage from \p</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeLine">/// Start as far as possible. Prepend \Expression with the offset and append it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">224</td>
    <td class="codeLine">/// Start as far as possible. Prepend \Expression with the offset and append it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeLine">/// with a DW_OP_deref that haes been implicit until now. Returns the walked-to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">225</td>
    <td class="codeLine">/// with a DW_OP_deref that haes been implicit until now. Returns the walked-to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeLine">/// value and modified expression.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">226</td>
    <td class="codeLine">/// value and modified expression.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeLine">static std::pair<Value *, DIExpression *></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">227</td>
    <td class="codeLine">static std::pair<Value *, DIExpression *></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeLine">walkToAllocaAndPrependOffsetDeref(const DataLayout &DL, Value *Start,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">228</td>
    <td class="codeLine">walkToAllocaAndPrependOffsetDeref(const DataLayout &DL, Value *Start,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeLine">                                  DIExpression *Expression) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">229</td>
    <td class="codeLine">                                  DIExpression *Expression) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeLine">  APInt OffsetInBytes(DL.getTypeSizeInBits(Start->getType()), false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">230</td>
    <td class="codeLine">  APInt OffsetInBytes(DL.getTypeSizeInBits(Start->getType()), false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeLine">  Value *End =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">231</td>
    <td class="codeLine">  Value *End =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeLine">      Start->stripAndAccumulateInBoundsConstantOffsets(DL, OffsetInBytes);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">232</td>
    <td class="codeLine">      Start->stripAndAccumulateInBoundsConstantOffsets(DL, OffsetInBytes);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeLine">  SmallVector<uint64_t, 3> Ops;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">233</td>
    <td class="codeLine">  SmallVector<uint64_t, 3> Ops;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeLine">  if (OffsetInBytes.getBoolValue()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">234</td>
    <td class="codeLine">  if (OffsetInBytes.getBoolValue()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeLine">    Ops = {dwarf::DW_OP_plus_uconst, OffsetInBytes.getZExtValue()};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">235</td>
    <td class="codeLine">    Ops = {dwarf::DW_OP_plus_uconst, OffsetInBytes.getZExtValue()};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeLine">    Expression = DIExpression::prependOpcodes(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">236</td>
    <td class="codeLine">    Expression = DIExpression::prependOpcodes(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeLine">        Expression, Ops, /*StackValue=*/false, /*EntryValue=*/false);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">237</td>
    <td class="codeLine">        Expression, Ops, /*StackValue=*/false, /*EntryValue=*/false);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">238</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeLine">  Expression = DIExpression::append(Expression, {dwarf::DW_OP_deref});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">239</td>
    <td class="codeLine">  Expression = DIExpression::append(Expression, {dwarf::DW_OP_deref});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeLine">  return {End, Expression};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">240</td>
    <td class="codeLine">  return {End, Expression};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">241</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">242</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeLine">/// Extract the offset used in \p DIExpr. Returns std::nullopt if the expression</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">243</td>
    <td class="codeLine">/// Extract the offset used in \p DIExpr. Returns std::nullopt if the expression</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeLine">/// doesn't explicitly describe a memory location with DW_OP_deref or if the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">244</td>
    <td class="codeLine">/// doesn't explicitly describe a memory location with DW_OP_deref or if the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeLine">/// expression is too complex to interpret.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">245</td>
    <td class="codeLine">/// expression is too complex to interpret.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeLine">static std::optional<int64_t></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">246</td>
    <td class="codeLine">static std::optional<int64_t></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeLine">getDerefOffsetInBytes(const DIExpression *DIExpr) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">247</td>
    <td class="codeLine">getDerefOffsetInBytes(const DIExpression *DIExpr) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeLine">  int64_t Offset = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">248</td>
    <td class="codeLine">  int64_t Offset = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeLine">  const unsigned NumElements = DIExpr->getNumElements();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">249</td>
    <td class="codeLine">  const unsigned NumElements = DIExpr->getNumElements();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeLine">  const auto Elements = DIExpr->getElements();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">250</td>
    <td class="codeLine">  const auto Elements = DIExpr->getElements();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeLine">  unsigned ExpectedDerefIdx = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">251</td>
    <td class="codeLine">  unsigned ExpectedDerefIdx = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeLine">  // Extract the offset.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">252</td>
    <td class="codeLine">  // Extract the offset.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeLine">  if (NumElements > 2 && Elements[0] == dwarf::DW_OP_plus_uconst) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">253</td>
    <td class="codeLine">  if (NumElements > 2 && Elements[0] == dwarf::DW_OP_plus_uconst) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeLine">    Offset = Elements[1];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">254</td>
    <td class="codeLine">    Offset = Elements[1];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeLine">    ExpectedDerefIdx = 2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">255</td>
    <td class="codeLine">    ExpectedDerefIdx = 2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeLine">  } else if (NumElements > 3 && Elements[0] == dwarf::DW_OP_constu) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">256</td>
    <td class="codeLine">  } else if (NumElements > 3 && Elements[0] == dwarf::DW_OP_constu) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeLine">    ExpectedDerefIdx = 3;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">257</td>
    <td class="codeLine">    ExpectedDerefIdx = 3;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeLine">    if (Elements[2] == dwarf::DW_OP_plus)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">258</td>
    <td class="codeLine">    if (Elements[2] == dwarf::DW_OP_plus)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeLine">      Offset = Elements[1];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">259</td>
    <td class="codeLine">      Offset = Elements[1];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeLine">    else if (Elements[2] == dwarf::DW_OP_minus)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">260</td>
    <td class="codeLine">    else if (Elements[2] == dwarf::DW_OP_minus)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeLine">      Offset = -Elements[1];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">261</td>
    <td class="codeLine">      Offset = -Elements[1];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">262</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeLine">      return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">263</td>
    <td class="codeLine">      return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">264</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">265</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeLine">  // If that's all there is it means there's no deref.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">266</td>
    <td class="codeLine">  // If that's all there is it means there's no deref.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeLine">  if (ExpectedDerefIdx >= NumElements)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">267</td>
    <td class="codeLine">  if (ExpectedDerefIdx >= NumElements)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">268</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">269</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeLine">  // Check the next element is DW_OP_deref - otherwise this is too complex or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">270</td>
    <td class="codeLine">  // Check the next element is DW_OP_deref - otherwise this is too complex or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeLine">  // isn't a deref expression.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">271</td>
    <td class="codeLine">  // isn't a deref expression.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeLine">  if (Elements[ExpectedDerefIdx] != dwarf::DW_OP_deref)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">272</td>
    <td class="codeLine">  if (Elements[ExpectedDerefIdx] != dwarf::DW_OP_deref)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">273</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">274</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeLine">  // Check the final operation is either the DW_OP_deref or is a fragment.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">275</td>
    <td class="codeLine">  // Check the final operation is either the DW_OP_deref or is a fragment.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeLine">  if (NumElements == ExpectedDerefIdx + 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">276</td>
    <td class="codeLine">  if (NumElements == ExpectedDerefIdx + 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeLine">    return Offset; // Ends with deref.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">277</td>
    <td class="codeLine">    return Offset; // Ends with deref.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeLine">  unsigned ExpectedFragFirstIdx = ExpectedDerefIdx + 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">278</td>
    <td class="codeLine">  unsigned ExpectedFragFirstIdx = ExpectedDerefIdx + 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeLine">  unsigned ExpectedFragFinalIdx = ExpectedFragFirstIdx + 2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">279</td>
    <td class="codeLine">  unsigned ExpectedFragFinalIdx = ExpectedFragFirstIdx + 2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeLine">  if (NumElements == ExpectedFragFinalIdx + 1 &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">280</td>
    <td class="codeLine">  if (NumElements == ExpectedFragFinalIdx + 1 &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeLine">      Elements[ExpectedFragFirstIdx] == dwarf::DW_OP_LLVM_fragment)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">281</td>
    <td class="codeLine">      Elements[ExpectedFragFirstIdx] == dwarf::DW_OP_LLVM_fragment)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeLine">    return Offset; // Ends with deref + fragment.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">282</td>
    <td class="codeLine">    return Offset; // Ends with deref + fragment.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">283</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeLine">  // Don't bother trying to interpret anything more complex.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">284</td>
    <td class="codeLine">  // Don't bother trying to interpret anything more complex.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeLine">  return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">285</td>
    <td class="codeLine">  return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">286</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">287</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeLine">/// A whole (unfragmented) source variable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">288</td>
    <td class="codeLine">/// A whole (unfragmented) source variable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeLine">using DebugAggregate = std::pair<const DILocalVariable *, const DILocation *>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">289</td>
    <td class="codeLine">using DebugAggregate = std::pair<const DILocalVariable *, const DILocation *>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeLine">static DebugAggregate getAggregate(const DbgVariableIntrinsic *DII) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">290</td>
    <td class="codeLine">static DebugAggregate getAggregate(const DbgVariableIntrinsic *DII) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeLine">  return DebugAggregate(DII->getVariable(), DII->getDebugLoc().getInlinedAt());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">291</td>
    <td class="codeLine">  return DebugAggregate(DII->getVariable(), DII->getDebugLoc().getInlinedAt());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">292</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeLine">static DebugAggregate getAggregate(const DebugVariable &Var) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">293</td>
    <td class="codeLine">static DebugAggregate getAggregate(const DebugVariable &Var) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeLine">  return DebugAggregate(Var.getVariable(), Var.getInlinedAt());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">294</td>
    <td class="codeLine">  return DebugAggregate(Var.getVariable(), Var.getInlinedAt());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">295</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">296</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeLine">static bool shouldCoalesceFragments(Function &F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">297</td>
    <td class="codeLine">static bool shouldCoalesceFragments(Function &F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeLine">  // Enabling fragment coalescing reduces compiler run time when instruction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">298</td>
    <td class="codeLine">  // Enabling fragment coalescing reduces compiler run time when instruction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeLine">  // referencing is enabled. However, it may cause LiveDebugVariables to create</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">299</td>
    <td class="codeLine">  // referencing is enabled. However, it may cause LiveDebugVariables to create</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeLine">  // incorrect locations. Since instruction-referencing mode effectively</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">300</td>
    <td class="codeLine">  // incorrect locations. Since instruction-referencing mode effectively</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeLine">  // bypasses LiveDebugVariables we only enable coalescing if the cl::opt flag</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">301</td>
    <td class="codeLine">  // bypasses LiveDebugVariables we only enable coalescing if the cl::opt flag</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeLine">  // has not been explicitly set and instruction-referencing is turned on.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">302</td>
    <td class="codeLine">  // has not been explicitly set and instruction-referencing is turned on.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeLine">  switch (CoalesceAdjacentFragmentsOpt) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">303</td>
    <td class="codeLine">  switch (CoalesceAdjacentFragmentsOpt) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeLine">  case cl::boolOrDefault::BOU_UNSET:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">304</td>
    <td class="codeLine">  case cl::boolOrDefault::BOU_UNSET:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeLine">    return debuginfoShouldUseDebugInstrRef(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">305</td>
    <td class="codeLine">    return debuginfoShouldUseDebugInstrRef(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeLine">        Triple(F.getParent()->getTargetTriple()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">306</td>
    <td class="codeLine">        Triple(F.getParent()->getTargetTriple()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeLine">  case cl::boolOrDefault::BOU_TRUE:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">307</td>
    <td class="codeLine">  case cl::boolOrDefault::BOU_TRUE:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">308</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeLine">  case cl::boolOrDefault::BOU_FALSE:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">309</td>
    <td class="codeLine">  case cl::boolOrDefault::BOU_FALSE:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">310</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">311</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeLine">  llvm_unreachable("Unknown boolOrDefault value");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">312</td>
    <td class="codeLine">  llvm_unreachable("Unknown boolOrDefault value");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">313</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">314</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">315</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeLine">/// In dwarf emission, the following sequence</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">316</td>
    <td class="codeLine">/// In dwarf emission, the following sequence</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeLine">///    1. dbg.value ... Fragment(0, 64)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">317</td>
    <td class="codeLine">///    1. dbg.value ... Fragment(0, 64)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeLine">///    2. dbg.value ... Fragment(0, 32)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">318</td>
    <td class="codeLine">///    2. dbg.value ... Fragment(0, 32)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeLine">/// effectively sets Fragment(32, 32) to undef (each def sets all bits not in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">319</td>
    <td class="codeLine">/// effectively sets Fragment(32, 32) to undef (each def sets all bits not in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeLine">/// the intersection of the fragments to having "no location"). This makes</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">320</td>
    <td class="codeLine">/// the intersection of the fragments to having "no location"). This makes</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeLine">/// sense for implicit location values because splitting the computed values</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">321</td>
    <td class="codeLine">/// sense for implicit location values because splitting the computed values</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeLine">/// could be troublesome, and is probably quite uncommon.  When we convert</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">322</td>
    <td class="codeLine">/// could be troublesome, and is probably quite uncommon.  When we convert</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeLine">/// dbg.assigns to dbg.value+deref this kind of thing is common, and describing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">323</td>
    <td class="codeLine">/// dbg.assigns to dbg.value+deref this kind of thing is common, and describing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeLine">/// a location (memory) rather than a value means we don't need to worry about</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">324</td>
    <td class="codeLine">/// a location (memory) rather than a value means we don't need to worry about</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeLine">/// splitting any values, so we try to recover the rest of the fragment</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">325</td>
    <td class="codeLine">/// splitting any values, so we try to recover the rest of the fragment</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeLine">/// location here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">326</td>
    <td class="codeLine">/// location here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeLine">/// This class performs a(nother) dataflow analysis over the function, adding</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">327</td>
    <td class="codeLine">/// This class performs a(nother) dataflow analysis over the function, adding</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeLine">/// variable locations so that any bits of a variable with a memory location</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">328</td>
    <td class="codeLine">/// variable locations so that any bits of a variable with a memory location</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeLine">/// have that location explicitly reinstated at each subsequent variable</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">329</td>
    <td class="codeLine">/// have that location explicitly reinstated at each subsequent variable</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeLine">/// location definition that that doesn't overwrite those bits. i.e. after a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">330</td>
    <td class="codeLine">/// location definition that that doesn't overwrite those bits. i.e. after a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeLine">/// variable location def, insert new defs for the memory location with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">331</td>
    <td class="codeLine">/// variable location def, insert new defs for the memory location with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeLine">/// fragments for the difference of "all bits currently in memory" and "the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">332</td>
    <td class="codeLine">/// fragments for the difference of "all bits currently in memory" and "the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeLine">/// fragment of the second def".</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">333</td>
    <td class="codeLine">/// fragment of the second def".</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeLine">class MemLocFragmentFill {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">334</td>
    <td class="codeLine">class MemLocFragmentFill {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeLine">  Function &Fn;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">335</td>
    <td class="codeLine">  Function &Fn;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeLine">  FunctionVarLocsBuilder *FnVarLocs;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">336</td>
    <td class="codeLine">  FunctionVarLocsBuilder *FnVarLocs;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeLine">  const DenseSet<DebugAggregate> *VarsWithStackSlot;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">337</td>
    <td class="codeLine">  const DenseSet<DebugAggregate> *VarsWithStackSlot;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeLine">  bool CoalesceAdjacentFragments;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">338</td>
    <td class="codeLine">  bool CoalesceAdjacentFragments;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">339</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeLine">  // 0 = no memory location.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">340</td>
    <td class="codeLine">  // 0 = no memory location.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeLine">  using BaseAddress = unsigned;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">341</td>
    <td class="codeLine">  using BaseAddress = unsigned;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeLine">  using OffsetInBitsTy = unsigned;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">342</td>
    <td class="codeLine">  using OffsetInBitsTy = unsigned;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeLine">  using FragTraits = IntervalMapHalfOpenInfo<OffsetInBitsTy>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">343</td>
    <td class="codeLine">  using FragTraits = IntervalMapHalfOpenInfo<OffsetInBitsTy>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeLine">  using FragsInMemMap = IntervalMap<</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">344</td>
    <td class="codeLine">  using FragsInMemMap = IntervalMap<</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeLine">      OffsetInBitsTy, BaseAddress,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">345</td>
    <td class="codeLine">      OffsetInBitsTy, BaseAddress,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeLine">      IntervalMapImpl::NodeSizer<OffsetInBitsTy, BaseAddress>::LeafSize,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">346</td>
    <td class="codeLine">      IntervalMapImpl::NodeSizer<OffsetInBitsTy, BaseAddress>::LeafSize,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeLine">      FragTraits>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">347</td>
    <td class="codeLine">      FragTraits>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeLine">  FragsInMemMap::Allocator IntervalMapAlloc;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">348</td>
    <td class="codeLine">  FragsInMemMap::Allocator IntervalMapAlloc;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeLine">  using VarFragMap = DenseMap<unsigned, FragsInMemMap>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">349</td>
    <td class="codeLine">  using VarFragMap = DenseMap<unsigned, FragsInMemMap>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">350</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeLine">  /// IDs for memory location base addresses in maps. Use 0 to indicate that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">351</td>
    <td class="codeLine">  /// IDs for memory location base addresses in maps. Use 0 to indicate that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeLine">  /// there's no memory location.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">352</td>
    <td class="codeLine">  /// there's no memory location.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeLine">  UniqueVector<RawLocationWrapper> Bases;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">353</td>
    <td class="codeLine">  UniqueVector<RawLocationWrapper> Bases;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeLine">  UniqueVector<DebugAggregate> Aggregates;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">354</td>
    <td class="codeLine">  UniqueVector<DebugAggregate> Aggregates;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeLine">  DenseMap<const BasicBlock *, VarFragMap> LiveIn;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">355</td>
    <td class="codeLine">  DenseMap<const BasicBlock *, VarFragMap> LiveIn;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeLine">  DenseMap<const BasicBlock *, VarFragMap> LiveOut;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">356</td>
    <td class="codeLine">  DenseMap<const BasicBlock *, VarFragMap> LiveOut;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">357</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeLine">  struct FragMemLoc {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">358</td>
    <td class="codeLine">  struct FragMemLoc {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeLine">    unsigned Var;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">359</td>
    <td class="codeLine">    unsigned Var;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeLine">    unsigned Base;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">360</td>
    <td class="codeLine">    unsigned Base;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeLine">    unsigned OffsetInBits;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">361</td>
    <td class="codeLine">    unsigned OffsetInBits;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeLine">    unsigned SizeInBits;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">362</td>
    <td class="codeLine">    unsigned SizeInBits;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeLine">    DebugLoc DL;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">363</td>
    <td class="codeLine">    DebugLoc DL;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">364</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeLine">  using InsertMap = MapVector<Instruction *, SmallVector<FragMemLoc>>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">365</td>
    <td class="codeLine">  using InsertMap = MapVector<Instruction *, SmallVector<FragMemLoc>>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">366</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeLine">  /// BBInsertBeforeMap holds a description for the set of location defs to be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">367</td>
    <td class="codeLine">  /// BBInsertBeforeMap holds a description for the set of location defs to be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeLine">  /// inserted after the analysis is complete. It is updated during the dataflow</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">368</td>
    <td class="codeLine">  /// inserted after the analysis is complete. It is updated during the dataflow</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeLine">  /// and the entry for a block is CLEARED each time it is (re-)visited. After</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">369</td>
    <td class="codeLine">  /// and the entry for a block is CLEARED each time it is (re-)visited. After</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeLine">  /// the dataflow is complete, each block entry will contain the set of defs</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">370</td>
    <td class="codeLine">  /// the dataflow is complete, each block entry will contain the set of defs</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeLine">  /// calculated during the final (fixed-point) iteration.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">371</td>
    <td class="codeLine">  /// calculated during the final (fixed-point) iteration.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeLine">  DenseMap<const BasicBlock *, InsertMap> BBInsertBeforeMap;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">372</td>
    <td class="codeLine">  DenseMap<const BasicBlock *, InsertMap> BBInsertBeforeMap;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">373</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeLine">  static bool intervalMapsAreEqual(const FragsInMemMap &A,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">374</td>
    <td class="codeLine">  static bool intervalMapsAreEqual(const FragsInMemMap &A,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeLine">                                   const FragsInMemMap &B) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">375</td>
    <td class="codeLine">                                   const FragsInMemMap &B) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeLine">    auto AIt = A.begin(), AEnd = A.end();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">376</td>
    <td class="codeLine">    auto AIt = A.begin(), AEnd = A.end();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeLine">    auto BIt = B.begin(), BEnd = B.end();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">377</td>
    <td class="codeLine">    auto BIt = B.begin(), BEnd = B.end();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeLine">    for (; AIt != AEnd; ++AIt, ++BIt) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">378</td>
    <td class="codeLine">    for (; AIt != AEnd; ++AIt, ++BIt) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeLine">      if (BIt == BEnd)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">379</td>
    <td class="codeLine">      if (BIt == BEnd)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeLine">        return false; // B has fewer elements than A.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">380</td>
    <td class="codeLine">        return false; // B has fewer elements than A.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeLine">      if (AIt.start() != BIt.start() || AIt.stop() != BIt.stop())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">381</td>
    <td class="codeLine">      if (AIt.start() != BIt.start() || AIt.stop() != BIt.stop())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeLine">        return false; // Interval is different.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">382</td>
    <td class="codeLine">        return false; // Interval is different.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeLine">      if (*AIt != *BIt)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">383</td>
    <td class="codeLine">      if (*AIt != *BIt)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeLine">        return false; // Value at interval is different.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">384</td>
    <td class="codeLine">        return false; // Value at interval is different.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">385</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeLine">    // AIt == AEnd. Check BIt is also now at end.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">386</td>
    <td class="codeLine">    // AIt == AEnd. Check BIt is also now at end.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeLine">    return BIt == BEnd;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">387</td>
    <td class="codeLine">    return BIt == BEnd;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">388</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">389</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeLine">  static bool varFragMapsAreEqual(const VarFragMap &A, const VarFragMap &B) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">390</td>
    <td class="codeLine">  static bool varFragMapsAreEqual(const VarFragMap &A, const VarFragMap &B) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeLine">    if (A.size() != B.size())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">391</td>
    <td class="codeLine">    if (A.size() != B.size())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">392</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeLine">    for (const auto &APair : A) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">393</td>
    <td class="codeLine">    for (const auto &APair : A) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeLine">      auto BIt = B.find(APair.first);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">394</td>
    <td class="codeLine">      auto BIt = B.find(APair.first);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeLine">      if (BIt == B.end())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">395</td>
    <td class="codeLine">      if (BIt == B.end())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">396</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeLine">      if (!intervalMapsAreEqual(APair.second, BIt->second))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">397</td>
    <td class="codeLine">      if (!intervalMapsAreEqual(APair.second, BIt->second))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">398</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">399</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">400</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">401</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">402</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeLine">  /// Return a string for the value that \p BaseID represents.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">403</td>
    <td class="codeLine">  /// Return a string for the value that \p BaseID represents.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeLine">  std::string toString(unsigned BaseID) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">404</td>
    <td class="codeLine">  std::string toString(unsigned BaseID) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeLine">    if (BaseID)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">405</td>
    <td class="codeLine">    if (BaseID)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeLine">      return Bases[BaseID].getVariableLocationOp(0)->getName().str();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">406</td>
    <td class="codeLine">      return Bases[BaseID].getVariableLocationOp(0)->getName().str();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">407</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeLine">      return "None";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">408</td>
    <td class="codeLine">      return "None";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">409</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">410</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeLine">  /// Format string describing an FragsInMemMap (IntervalMap) interval.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">411</td>
    <td class="codeLine">  /// Format string describing an FragsInMemMap (IntervalMap) interval.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeLine">  std::string toString(FragsInMemMap::const_iterator It, bool Newline = true) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">412</td>
    <td class="codeLine">  std::string toString(FragsInMemMap::const_iterator It, bool Newline = true) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeLine">    std::string String;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">413</td>
    <td class="codeLine">    std::string String;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeLine">    std::stringstream S(String);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">414</td>
    <td class="codeLine">    std::stringstream S(String);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeLine">    if (It.valid()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">415</td>
    <td class="codeLine">    if (It.valid()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeLine">      S << "[" << It.start() << ", " << It.stop()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">416</td>
    <td class="codeLine">      S << "[" << It.start() << ", " << It.stop()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeLine">        << "): " << toString(It.value());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">417</td>
    <td class="codeLine">        << "): " << toString(It.value());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">418</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeLine">      S << "invalid iterator (end)";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">419</td>
    <td class="codeLine">      S << "invalid iterator (end)";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">420</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeLine">    if (Newline)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">421</td>
    <td class="codeLine">    if (Newline)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeLine">      S << "\n";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">422</td>
    <td class="codeLine">      S << "\n";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeLine">    return S.str();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">423</td>
    <td class="codeLine">    return S.str();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">424</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">425</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeLine">  FragsInMemMap meetFragments(const FragsInMemMap &A, const FragsInMemMap &B) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">426</td>
    <td class="codeLine">  FragsInMemMap meetFragments(const FragsInMemMap &A, const FragsInMemMap &B) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeLine">    FragsInMemMap Result(IntervalMapAlloc);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">427</td>
    <td class="codeLine">    FragsInMemMap Result(IntervalMapAlloc);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeLine">    for (auto AIt = A.begin(), AEnd = A.end(); AIt != AEnd; ++AIt) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">428</td>
    <td class="codeLine">    for (auto AIt = A.begin(), AEnd = A.end(); AIt != AEnd; ++AIt) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "a " << toString(AIt));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">429</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "a " << toString(AIt));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeLine">      // This is basically copied from process() and inverted (process is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">430</td>
    <td class="codeLine">      // This is basically copied from process() and inverted (process is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeLine">      // performing something like a union whereas this is more of an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">431</td>
    <td class="codeLine">      // performing something like a union whereas this is more of an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeLine">      // intersect).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">432</td>
    <td class="codeLine">      // intersect).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">433</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeLine">      // There's no work to do if interval `a` overlaps no fragments in map `B`.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">434</td>
    <td class="codeLine">      // There's no work to do if interval `a` overlaps no fragments in map `B`.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeLine">      if (!B.overlaps(AIt.start(), AIt.stop()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">435</td>
    <td class="codeLine">      if (!B.overlaps(AIt.start(), AIt.stop()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">436</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">437</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeLine">      // Does StartBit intersect an existing fragment?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">438</td>
    <td class="codeLine">      // Does StartBit intersect an existing fragment?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeLine">      auto FirstOverlap = B.find(AIt.start());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">439</td>
    <td class="codeLine">      auto FirstOverlap = B.find(AIt.start());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeLine">      assert(FirstOverlap != B.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">440</td>
    <td class="codeLine">      assert(FirstOverlap != B.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeLine">      bool IntersectStart = FirstOverlap.start() < AIt.start();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">441</td>
    <td class="codeLine">      bool IntersectStart = FirstOverlap.start() < AIt.start();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "- FirstOverlap " << toString(FirstOverlap, false)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">442</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "- FirstOverlap " << toString(FirstOverlap, false)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeLine">                        << ", IntersectStart: " << IntersectStart << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">443</td>
    <td class="codeLine">                        << ", IntersectStart: " << IntersectStart << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">444</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeLine">      // Does EndBit intersect an existing fragment?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">445</td>
    <td class="codeLine">      // Does EndBit intersect an existing fragment?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeLine">      auto LastOverlap = B.find(AIt.stop());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">446</td>
    <td class="codeLine">      auto LastOverlap = B.find(AIt.stop());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeLine">      bool IntersectEnd =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">447</td>
    <td class="codeLine">      bool IntersectEnd =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeLine">          LastOverlap != B.end() && LastOverlap.start() < AIt.stop();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">448</td>
    <td class="codeLine">          LastOverlap != B.end() && LastOverlap.start() < AIt.stop();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "- LastOverlap " << toString(LastOverlap, false)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">449</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "- LastOverlap " << toString(LastOverlap, false)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeLine">                        << ", IntersectEnd: " << IntersectEnd << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">450</td>
    <td class="codeLine">                        << ", IntersectEnd: " << IntersectEnd << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">451</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeLine">      // Check if both ends of `a` intersect the same interval `b`.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">452</td>
    <td class="codeLine">      // Check if both ends of `a` intersect the same interval `b`.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeLine">      if (IntersectStart && IntersectEnd && FirstOverlap == LastOverlap) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">453</td>
    <td class="codeLine">      if (IntersectStart && IntersectEnd && FirstOverlap == LastOverlap) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeLine">        // Insert `a` (`a` is contained in `b`) if the values match.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">454</td>
    <td class="codeLine">        // Insert `a` (`a` is contained in `b`) if the values match.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeLine">        // [ a ]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">455</td>
    <td class="codeLine">        // [ a ]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeLine">        // [ - b - ]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">456</td>
    <td class="codeLine">        // [ - b - ]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeLine">        // -</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">457</td>
    <td class="codeLine">        // -</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeLine">        // [ r ]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">458</td>
    <td class="codeLine">        // [ r ]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "- a is contained within "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">459</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "- a is contained within "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeLine">                          << toString(FirstOverlap));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">460</td>
    <td class="codeLine">                          << toString(FirstOverlap));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeLine">        if (*AIt && *AIt == *FirstOverlap)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">461</td>
    <td class="codeLine">        if (*AIt && *AIt == *FirstOverlap)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeLine">          Result.insert(AIt.start(), AIt.stop(), *AIt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">462</td>
    <td class="codeLine">          Result.insert(AIt.start(), AIt.stop(), *AIt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">463</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeLine">        // There's an overlap but `a` is not fully contained within</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">464</td>
    <td class="codeLine">        // There's an overlap but `a` is not fully contained within</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeLine">        // `b`. Shorten any end-point intersections.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">465</td>
    <td class="codeLine">        // `b`. Shorten any end-point intersections.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeLine">        //     [ - a - ]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">466</td>
    <td class="codeLine">        //     [ - a - ]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeLine">        // [ - b - ]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">467</td>
    <td class="codeLine">        // [ - b - ]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeLine">        // -</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">468</td>
    <td class="codeLine">        // -</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeLine">        //     [ r ]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">469</td>
    <td class="codeLine">        //     [ r ]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeLine">        auto Next = FirstOverlap;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">470</td>
    <td class="codeLine">        auto Next = FirstOverlap;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeLine">        if (IntersectStart) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">471</td>
    <td class="codeLine">        if (IntersectStart) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeLine">          LLVM_DEBUG(dbgs() << "- insert intersection of a and "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">472</td>
    <td class="codeLine">          LLVM_DEBUG(dbgs() << "- insert intersection of a and "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeLine">                            << toString(FirstOverlap));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">473</td>
    <td class="codeLine">                            << toString(FirstOverlap));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeLine">          if (*AIt && *AIt == *FirstOverlap)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">474</td>
    <td class="codeLine">          if (*AIt && *AIt == *FirstOverlap)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeLine">            Result.insert(AIt.start(), FirstOverlap.stop(), *AIt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">475</td>
    <td class="codeLine">            Result.insert(AIt.start(), FirstOverlap.stop(), *AIt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeLine">          ++Next;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">476</td>
    <td class="codeLine">          ++Next;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">477</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeLine">        // [ - a - ]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">478</td>
    <td class="codeLine">        // [ - a - ]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeLine">        //     [ - b - ]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">479</td>
    <td class="codeLine">        //     [ - b - ]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeLine">        // -</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">480</td>
    <td class="codeLine">        // -</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeLine">        //     [ r ]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">481</td>
    <td class="codeLine">        //     [ r ]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeLine">        if (IntersectEnd) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">482</td>
    <td class="codeLine">        if (IntersectEnd) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeLine">          LLVM_DEBUG(dbgs() << "- insert intersection of a and "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">483</td>
    <td class="codeLine">          LLVM_DEBUG(dbgs() << "- insert intersection of a and "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeLine">                            << toString(LastOverlap));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">484</td>
    <td class="codeLine">                            << toString(LastOverlap));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeLine">          if (*AIt && *AIt == *LastOverlap)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">485</td>
    <td class="codeLine">          if (*AIt && *AIt == *LastOverlap)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeLine">            Result.insert(LastOverlap.start(), AIt.stop(), *AIt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">486</td>
    <td class="codeLine">            Result.insert(LastOverlap.start(), AIt.stop(), *AIt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">487</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">488</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeLine">        // Insert all intervals in map `B` that are contained within interval</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">489</td>
    <td class="codeLine">        // Insert all intervals in map `B` that are contained within interval</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeLine">        // `a` where the values match.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">490</td>
    <td class="codeLine">        // `a` where the values match.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeLine">        // [ -  - a -  - ]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">491</td>
    <td class="codeLine">        // [ -  - a -  - ]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeLine">        // [ b1 ]   [ b2 ]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">492</td>
    <td class="codeLine">        // [ b1 ]   [ b2 ]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeLine">        // -</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">493</td>
    <td class="codeLine">        // -</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeLine">        // [ r1 ]   [ r2 ]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">494</td>
    <td class="codeLine">        // [ r1 ]   [ r2 ]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeLine">        while (Next != B.end() && Next.start() < AIt.stop() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">495</td>
    <td class="codeLine">        while (Next != B.end() && Next.start() < AIt.stop() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeLine">               Next.stop() <= AIt.stop()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">496</td>
    <td class="codeLine">               Next.stop() <= AIt.stop()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeLine">          LLVM_DEBUG(dbgs()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">497</td>
    <td class="codeLine">          LLVM_DEBUG(dbgs()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeLine">                     << "- insert intersection of a and " << toString(Next));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">498</td>
    <td class="codeLine">                     << "- insert intersection of a and " << toString(Next));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeLine">          if (*AIt && *AIt == *Next)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">499</td>
    <td class="codeLine">          if (*AIt && *AIt == *Next)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeLine">            Result.insert(Next.start(), Next.stop(), *Next);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">500</td>
    <td class="codeLine">            Result.insert(Next.start(), Next.stop(), *Next);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeLine">          ++Next;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">501</td>
    <td class="codeLine">          ++Next;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">502</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">503</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">504</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeLine">    return Result;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">505</td>
    <td class="codeLine">    return Result;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">506</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">507</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeLine">  /// Meet \p A and \p B, storing the result in \p A.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">508</td>
    <td class="codeLine">  /// Meet \p A and \p B, storing the result in \p A.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeLine">  void meetVars(VarFragMap &A, const VarFragMap &B) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">509</td>
    <td class="codeLine">  void meetVars(VarFragMap &A, const VarFragMap &B) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeLine">    // Meet A and B.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">510</td>
    <td class="codeLine">    // Meet A and B.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">511</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeLine">    // Result = meet(a, b) for a in A, b in B where Var(a) == Var(b)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">512</td>
    <td class="codeLine">    // Result = meet(a, b) for a in A, b in B where Var(a) == Var(b)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeLine">    for (auto It = A.begin(), End = A.end(); It != End; ++It) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">513</td>
    <td class="codeLine">    for (auto It = A.begin(), End = A.end(); It != End; ++It) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeLine">      unsigned AVar = It->first;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">514</td>
    <td class="codeLine">      unsigned AVar = It->first;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeLine">      FragsInMemMap &AFrags = It->second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">515</td>
    <td class="codeLine">      FragsInMemMap &AFrags = It->second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeLine">      auto BIt = B.find(AVar);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">516</td>
    <td class="codeLine">      auto BIt = B.find(AVar);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeLine">      if (BIt == B.end()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">517</td>
    <td class="codeLine">      if (BIt == B.end()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeLine">        A.erase(It);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">518</td>
    <td class="codeLine">        A.erase(It);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeLine">        continue; // Var has no bits defined in B.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">519</td>
    <td class="codeLine">        continue; // Var has no bits defined in B.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">520</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "meet fragment maps for "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">521</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "meet fragment maps for "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeLine">                        << Aggregates[AVar].first->getName() << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">522</td>
    <td class="codeLine">                        << Aggregates[AVar].first->getName() << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeLine">      AFrags = meetFragments(AFrags, BIt->second);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">523</td>
    <td class="codeLine">      AFrags = meetFragments(AFrags, BIt->second);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">524</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">525</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">526</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeLine">  bool meet(const BasicBlock &BB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">527</td>
    <td class="codeLine">  bool meet(const BasicBlock &BB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeLine">            const SmallPtrSet<BasicBlock *, 16> &Visited) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">528</td>
    <td class="codeLine">            const SmallPtrSet<BasicBlock *, 16> &Visited) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "meet block info from preds of " << BB.getName()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">529</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "meet block info from preds of " << BB.getName()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeLine">                      << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">530</td>
    <td class="codeLine">                      << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">531</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeLine">    VarFragMap BBLiveIn;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">532</td>
    <td class="codeLine">    VarFragMap BBLiveIn;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeLine">    bool FirstMeet = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">533</td>
    <td class="codeLine">    bool FirstMeet = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeLine">    // LiveIn locs for BB is the meet of the already-processed preds' LiveOut</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">534</td>
    <td class="codeLine">    // LiveIn locs for BB is the meet of the already-processed preds' LiveOut</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeLine">    // locs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">535</td>
    <td class="codeLine">    // locs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeLine">    for (auto I = pred_begin(&BB), E = pred_end(&BB); I != E; I++) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">536</td>
    <td class="codeLine">    for (auto I = pred_begin(&BB), E = pred_end(&BB); I != E; I++) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeLine">      // Ignore preds that haven't been processed yet. This is essentially the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">537</td>
    <td class="codeLine">      // Ignore preds that haven't been processed yet. This is essentially the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeLine">      // same as initialising all variables to implicit top value (⊤) which is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">538</td>
    <td class="codeLine">      // same as initialising all variables to implicit top value (⊤) which is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeLine">      // the identity value for the meet operation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">539</td>
    <td class="codeLine">      // the identity value for the meet operation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeLine">      const BasicBlock *Pred = *I;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">540</td>
    <td class="codeLine">      const BasicBlock *Pred = *I;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeLine">      if (!Visited.count(Pred))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">541</td>
    <td class="codeLine">      if (!Visited.count(Pred))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">542</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">543</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeLine">      auto PredLiveOut = LiveOut.find(Pred);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">544</td>
    <td class="codeLine">      auto PredLiveOut = LiveOut.find(Pred);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeLine">      assert(PredLiveOut != LiveOut.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">545</td>
    <td class="codeLine">      assert(PredLiveOut != LiveOut.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">546</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeLine">      if (FirstMeet) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">547</td>
    <td class="codeLine">      if (FirstMeet) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "BBLiveIn = " << Pred->getName() << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">548</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "BBLiveIn = " << Pred->getName() << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeLine">        BBLiveIn = PredLiveOut->second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">549</td>
    <td class="codeLine">        BBLiveIn = PredLiveOut->second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeLine">        FirstMeet = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">550</td>
    <td class="codeLine">        FirstMeet = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">551</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "BBLiveIn = meet BBLiveIn, " << Pred->getName()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">552</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "BBLiveIn = meet BBLiveIn, " << Pred->getName()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeLine">                          << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">553</td>
    <td class="codeLine">                          << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeLine">        meetVars(BBLiveIn, PredLiveOut->second);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">554</td>
    <td class="codeLine">        meetVars(BBLiveIn, PredLiveOut->second);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">555</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">556</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeLine">      // An empty set is ⊥ for the intersect-like meet operation. If we've</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">557</td>
    <td class="codeLine">      // An empty set is ⊥ for the intersect-like meet operation. If we've</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeLine">      // already got ⊥ there's no need to run the code - we know the result is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">558</td>
    <td class="codeLine">      // already got ⊥ there's no need to run the code - we know the result is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeLine">      // ⊥ since `meet(a, ⊥) = ⊥`.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">559</td>
    <td class="codeLine">      // ⊥ since `meet(a, ⊥) = ⊥`.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeLine">      if (BBLiveIn.size() == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">560</td>
    <td class="codeLine">      if (BBLiveIn.size() == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">561</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">562</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">563</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeLine">    auto CurrentLiveInEntry = LiveIn.find(&BB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">564</td>
    <td class="codeLine">    auto CurrentLiveInEntry = LiveIn.find(&BB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeLine">    // If there's no LiveIn entry for the block yet, add it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">565</td>
    <td class="codeLine">    // If there's no LiveIn entry for the block yet, add it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeLine">    if (CurrentLiveInEntry == LiveIn.end()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">566</td>
    <td class="codeLine">    if (CurrentLiveInEntry == LiveIn.end()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "change=true (first) on meet on " << BB.getName()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">567</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "change=true (first) on meet on " << BB.getName()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeLine">                        << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">568</td>
    <td class="codeLine">                        << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeLine">      LiveIn[&BB] = std::move(BBLiveIn);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">569</td>
    <td class="codeLine">      LiveIn[&BB] = std::move(BBLiveIn);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeLine">      return /*Changed=*/true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">570</td>
    <td class="codeLine">      return /*Changed=*/true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">571</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">572</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeLine">    // If the LiveIn set has changed (expensive check) update it and return</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">573</td>
    <td class="codeLine">    // If the LiveIn set has changed (expensive check) update it and return</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeLine">    // true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">574</td>
    <td class="codeLine">    // true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeLine">    if (!varFragMapsAreEqual(BBLiveIn, CurrentLiveInEntry->second)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">575</td>
    <td class="codeLine">    if (!varFragMapsAreEqual(BBLiveIn, CurrentLiveInEntry->second)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "change=true on meet on " << BB.getName() << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">576</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "change=true on meet on " << BB.getName() << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeLine">      CurrentLiveInEntry->second = std::move(BBLiveIn);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">577</td>
    <td class="codeLine">      CurrentLiveInEntry->second = std::move(BBLiveIn);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeLine">      return /*Changed=*/true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">578</td>
    <td class="codeLine">      return /*Changed=*/true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">579</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">580</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "change=false on meet on " << BB.getName() << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">581</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "change=false on meet on " << BB.getName() << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeLine">    return /*Changed=*/false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">582</td>
    <td class="codeLine">    return /*Changed=*/false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">583</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">584</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeLine">  void insertMemLoc(BasicBlock &BB, Instruction &Before, unsigned Var,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">585</td>
    <td class="codeLine">  void insertMemLoc(BasicBlock &BB, Instruction &Before, unsigned Var,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeLine">                    unsigned StartBit, unsigned EndBit, unsigned Base,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">586</td>
    <td class="codeLine">                    unsigned StartBit, unsigned EndBit, unsigned Base,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeLine">                    DebugLoc DL) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">587</td>
    <td class="codeLine">                    DebugLoc DL) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeLine">    assert(StartBit < EndBit && "Cannot create fragment of size <= 0");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">588</td>
    <td class="codeLine">    assert(StartBit < EndBit && "Cannot create fragment of size <= 0");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeLine">    if (!Base)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">589</td>
    <td class="codeLine">    if (!Base)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">590</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeLine">    FragMemLoc Loc;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">591</td>
    <td class="codeLine">    FragMemLoc Loc;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeLine">    Loc.Var = Var;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">592</td>
    <td class="codeLine">    Loc.Var = Var;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeLine">    Loc.OffsetInBits = StartBit;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">593</td>
    <td class="codeLine">    Loc.OffsetInBits = StartBit;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeLine">    Loc.SizeInBits = EndBit - StartBit;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">594</td>
    <td class="codeLine">    Loc.SizeInBits = EndBit - StartBit;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeLine">    assert(Base && "Expected a non-zero ID for Base address");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">595</td>
    <td class="codeLine">    assert(Base && "Expected a non-zero ID for Base address");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeLine">    Loc.Base = Base;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">596</td>
    <td class="codeLine">    Loc.Base = Base;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeLine">    Loc.DL = DL;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">597</td>
    <td class="codeLine">    Loc.DL = DL;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeLine">    BBInsertBeforeMap[&BB][&Before].push_back(Loc);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">598</td>
    <td class="codeLine">    BBInsertBeforeMap[&BB][&Before].push_back(Loc);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Add mem def for " << Aggregates[Var].first->getName()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">599</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Add mem def for " << Aggregates[Var].first->getName()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeLine">                      << " bits [" << StartBit << ", " << EndBit << ")\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">600</td>
    <td class="codeLine">                      << " bits [" << StartBit << ", " << EndBit << ")\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">601</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">602</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeLine">  /// Inserts a new dbg def if the interval found when looking up \p StartBit</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">603</td>
    <td class="codeLine">  /// Inserts a new dbg def if the interval found when looking up \p StartBit</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeLine">  /// in \p FragMap starts before \p StartBit or ends after \p EndBit (which</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">604</td>
    <td class="codeLine">  /// in \p FragMap starts before \p StartBit or ends after \p EndBit (which</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeLine">  /// indicates - assuming StartBit->EndBit has just been inserted - that the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">605</td>
    <td class="codeLine">  /// indicates - assuming StartBit->EndBit has just been inserted - that the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeLine">  /// slice has been coalesced in the map).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">606</td>
    <td class="codeLine">  /// slice has been coalesced in the map).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeLine">  void coalesceFragments(BasicBlock &BB, Instruction &Before, unsigned Var,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">607</td>
    <td class="codeLine">  void coalesceFragments(BasicBlock &BB, Instruction &Before, unsigned Var,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeLine">                         unsigned StartBit, unsigned EndBit, unsigned Base,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">608</td>
    <td class="codeLine">                         unsigned StartBit, unsigned EndBit, unsigned Base,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeLine">                         DebugLoc DL, const FragsInMemMap &FragMap) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">609</td>
    <td class="codeLine">                         DebugLoc DL, const FragsInMemMap &FragMap) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeLine">    if (!CoalesceAdjacentFragments)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">610</td>
    <td class="codeLine">    if (!CoalesceAdjacentFragments)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">611</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeLine">    // We've inserted the location into the map. The map will have coalesced</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">612</td>
    <td class="codeLine">    // We've inserted the location into the map. The map will have coalesced</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeLine">    // adjacent intervals (variable fragments) that describe the same memory</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">613</td>
    <td class="codeLine">    // adjacent intervals (variable fragments) that describe the same memory</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeLine">    // location. Use this knowledge to insert a debug location that describes</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">614</td>
    <td class="codeLine">    // location. Use this knowledge to insert a debug location that describes</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeLine">    // that coalesced fragment. This may eclipse other locs we've just</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">615</td>
    <td class="codeLine">    // that coalesced fragment. This may eclipse other locs we've just</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeLine">    // inserted. This is okay as redundant locs will be cleaned up later.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">616</td>
    <td class="codeLine">    // inserted. This is okay as redundant locs will be cleaned up later.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeLine">    auto CoalescedFrag = FragMap.find(StartBit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">617</td>
    <td class="codeLine">    auto CoalescedFrag = FragMap.find(StartBit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeLine">    // Bail if no coalescing has taken place.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">618</td>
    <td class="codeLine">    // Bail if no coalescing has taken place.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeLine">    if (CoalescedFrag.start() == StartBit && CoalescedFrag.stop() == EndBit)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">619</td>
    <td class="codeLine">    if (CoalescedFrag.start() == StartBit && CoalescedFrag.stop() == EndBit)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">620</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">621</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "- Insert loc for bits " << CoalescedFrag.start()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">622</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "- Insert loc for bits " << CoalescedFrag.start()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeLine">                      << " to " << CoalescedFrag.stop() << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">623</td>
    <td class="codeLine">                      << " to " << CoalescedFrag.stop() << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeLine">    insertMemLoc(BB, Before, Var, CoalescedFrag.start(), CoalescedFrag.stop(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">624</td>
    <td class="codeLine">    insertMemLoc(BB, Before, Var, CoalescedFrag.start(), CoalescedFrag.stop(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeLine">                 Base, DL);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">625</td>
    <td class="codeLine">                 Base, DL);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">626</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">627</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeLine">  void addDef(const VarLocInfo &VarLoc, Instruction &Before, BasicBlock &BB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">628</td>
    <td class="codeLine">  void addDef(const VarLocInfo &VarLoc, Instruction &Before, BasicBlock &BB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeLine">              VarFragMap &LiveSet) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">629</td>
    <td class="codeLine">              VarFragMap &LiveSet) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeLine">    DebugVariable DbgVar = FnVarLocs->getVariable(VarLoc.VariableID);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">630</td>
    <td class="codeLine">    DebugVariable DbgVar = FnVarLocs->getVariable(VarLoc.VariableID);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeLine">    if (skipVariable(DbgVar.getVariable()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">631</td>
    <td class="codeLine">    if (skipVariable(DbgVar.getVariable()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">632</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeLine">    // Don't bother doing anything for this variables if we know it's fully</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">633</td>
    <td class="codeLine">    // Don't bother doing anything for this variables if we know it's fully</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeLine">    // promoted. We're only interested in variables that (sometimes) live on</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">634</td>
    <td class="codeLine">    // promoted. We're only interested in variables that (sometimes) live on</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeLine">    // the stack here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">635</td>
    <td class="codeLine">    // the stack here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeLine">    if (!VarsWithStackSlot->count(getAggregate(DbgVar)))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">636</td>
    <td class="codeLine">    if (!VarsWithStackSlot->count(getAggregate(DbgVar)))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">637</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeLine">    unsigned Var = Aggregates.insert(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">638</td>
    <td class="codeLine">    unsigned Var = Aggregates.insert(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeLine">        DebugAggregate(DbgVar.getVariable(), VarLoc.DL.getInlinedAt()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">639</td>
    <td class="codeLine">        DebugAggregate(DbgVar.getVariable(), VarLoc.DL.getInlinedAt()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">640</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeLine">    // [StartBit: EndBit) are the bits affected by this def.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">641</td>
    <td class="codeLine">    // [StartBit: EndBit) are the bits affected by this def.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeLine">    const DIExpression *DIExpr = VarLoc.Expr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">642</td>
    <td class="codeLine">    const DIExpression *DIExpr = VarLoc.Expr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeLine">    unsigned StartBit;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">643</td>
    <td class="codeLine">    unsigned StartBit;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeLine">    unsigned EndBit;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">644</td>
    <td class="codeLine">    unsigned EndBit;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeLine">    if (auto Frag = DIExpr->getFragmentInfo()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">645</td>
    <td class="codeLine">    if (auto Frag = DIExpr->getFragmentInfo()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeLine">      StartBit = Frag->OffsetInBits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">646</td>
    <td class="codeLine">      StartBit = Frag->OffsetInBits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeLine">      EndBit = StartBit + Frag->SizeInBits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">647</td>
    <td class="codeLine">      EndBit = StartBit + Frag->SizeInBits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">648</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeLine">      assert(static_cast<bool>(DbgVar.getVariable()->getSizeInBits()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">649</td>
    <td class="codeLine">      assert(static_cast<bool>(DbgVar.getVariable()->getSizeInBits()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeLine">      StartBit = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">650</td>
    <td class="codeLine">      StartBit = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeLine">      EndBit = *DbgVar.getVariable()->getSizeInBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">651</td>
    <td class="codeLine">      EndBit = *DbgVar.getVariable()->getSizeInBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">652</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">653</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeLine">    // We will only fill fragments for simple memory-describing dbg.value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">654</td>
    <td class="codeLine">    // We will only fill fragments for simple memory-describing dbg.value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeLine">    // intrinsics. If the fragment offset is the same as the offset from the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">655</td>
    <td class="codeLine">    // intrinsics. If the fragment offset is the same as the offset from the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeLine">    // base pointer, do The Thing, otherwise fall back to normal dbg.value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">656</td>
    <td class="codeLine">    // base pointer, do The Thing, otherwise fall back to normal dbg.value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeLine">    // behaviour. AssignmentTrackingLowering has generated DIExpressions</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">657</td>
    <td class="codeLine">    // behaviour. AssignmentTrackingLowering has generated DIExpressions</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeLine">    // written in terms of the base pointer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">658</td>
    <td class="codeLine">    // written in terms of the base pointer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeLine">    // TODO: Remove this condition since the fragment offset doesn't always</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">659</td>
    <td class="codeLine">    // TODO: Remove this condition since the fragment offset doesn't always</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeLine">    // equal the offset from base pointer (e.g. for a SROA-split variable).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">660</td>
    <td class="codeLine">    // equal the offset from base pointer (e.g. for a SROA-split variable).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeLine">    const auto DerefOffsetInBytes = getDerefOffsetInBytes(DIExpr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">661</td>
    <td class="codeLine">    const auto DerefOffsetInBytes = getDerefOffsetInBytes(DIExpr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeLine">    const unsigned Base =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">662</td>
    <td class="codeLine">    const unsigned Base =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeLine">        DerefOffsetInBytes && *DerefOffsetInBytes * 8 == StartBit</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">663</td>
    <td class="codeLine">        DerefOffsetInBytes && *DerefOffsetInBytes * 8 == StartBit</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeLine">            ? Bases.insert(VarLoc.Values)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">664</td>
    <td class="codeLine">            ? Bases.insert(VarLoc.Values)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeLine">            : 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">665</td>
    <td class="codeLine">            : 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "DEF " << DbgVar.getVariable()->getName() << " ["</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">666</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "DEF " << DbgVar.getVariable()->getName() << " ["</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeLine">                      << StartBit << ", " << EndBit << "): " << toString(Base)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">667</td>
    <td class="codeLine">                      << StartBit << ", " << EndBit << "): " << toString(Base)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeLine">                      << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">668</td>
    <td class="codeLine">                      << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">669</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeLine">    // First of all, any locs that use mem that are disrupted need reinstating.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">670</td>
    <td class="codeLine">    // First of all, any locs that use mem that are disrupted need reinstating.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeLine">    // Unfortunately, IntervalMap doesn't let us insert intervals that overlap</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">671</td>
    <td class="codeLine">    // Unfortunately, IntervalMap doesn't let us insert intervals that overlap</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeLine">    // with existing intervals so this code involves a lot of fiddling around</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">672</td>
    <td class="codeLine">    // with existing intervals so this code involves a lot of fiddling around</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeLine">    // with intervals to do that manually.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">673</td>
    <td class="codeLine">    // with intervals to do that manually.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeLine">    auto FragIt = LiveSet.find(Var);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">674</td>
    <td class="codeLine">    auto FragIt = LiveSet.find(Var);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">675</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeLine">    // Check if the variable does not exist in the map.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">676</td>
    <td class="codeLine">    // Check if the variable does not exist in the map.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeLine">    if (FragIt == LiveSet.end()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">677</td>
    <td class="codeLine">    if (FragIt == LiveSet.end()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeLine">      // Add this variable to the BB map.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">678</td>
    <td class="codeLine">      // Add this variable to the BB map.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeLine">      auto P = LiveSet.try_emplace(Var, FragsInMemMap(IntervalMapAlloc));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">679</td>
    <td class="codeLine">      auto P = LiveSet.try_emplace(Var, FragsInMemMap(IntervalMapAlloc));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeLine">      assert(P.second && "Var already in map?");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">680</td>
    <td class="codeLine">      assert(P.second && "Var already in map?");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeLine">      // Add the interval to the fragment map.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">681</td>
    <td class="codeLine">      // Add the interval to the fragment map.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeLine">      P.first->second.insert(StartBit, EndBit, Base);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">682</td>
    <td class="codeLine">      P.first->second.insert(StartBit, EndBit, Base);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">683</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">684</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeLine">    // The variable has an entry in the map.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">685</td>
    <td class="codeLine">    // The variable has an entry in the map.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">686</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeLine">    FragsInMemMap &FragMap = FragIt->second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">687</td>
    <td class="codeLine">    FragsInMemMap &FragMap = FragIt->second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeLine">    // First check the easy case: the new fragment `f` doesn't overlap with any</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">688</td>
    <td class="codeLine">    // First check the easy case: the new fragment `f` doesn't overlap with any</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeLine">    // intervals.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">689</td>
    <td class="codeLine">    // intervals.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeLine">    if (!FragMap.overlaps(StartBit, EndBit)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">690</td>
    <td class="codeLine">    if (!FragMap.overlaps(StartBit, EndBit)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "- No overlaps\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">691</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "- No overlaps\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeLine">      FragMap.insert(StartBit, EndBit, Base);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">692</td>
    <td class="codeLine">      FragMap.insert(StartBit, EndBit, Base);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeLine">      coalesceFragments(BB, Before, Var, StartBit, EndBit, Base, VarLoc.DL,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">693</td>
    <td class="codeLine">      coalesceFragments(BB, Before, Var, StartBit, EndBit, Base, VarLoc.DL,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeLine">                        FragMap);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">694</td>
    <td class="codeLine">                        FragMap);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">695</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">696</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeLine">    // There is at least one overlap.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">697</td>
    <td class="codeLine">    // There is at least one overlap.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">698</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeLine">    // Does StartBit intersect an existing fragment?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">699</td>
    <td class="codeLine">    // Does StartBit intersect an existing fragment?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeLine">    auto FirstOverlap = FragMap.find(StartBit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">700</td>
    <td class="codeLine">    auto FirstOverlap = FragMap.find(StartBit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeLine">    assert(FirstOverlap != FragMap.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">701</td>
    <td class="codeLine">    assert(FirstOverlap != FragMap.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeLine">    bool IntersectStart = FirstOverlap.start() < StartBit;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">702</td>
    <td class="codeLine">    bool IntersectStart = FirstOverlap.start() < StartBit;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">703</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeLine">    // Does EndBit intersect an existing fragment?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">704</td>
    <td class="codeLine">    // Does EndBit intersect an existing fragment?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeLine">    auto LastOverlap = FragMap.find(EndBit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">705</td>
    <td class="codeLine">    auto LastOverlap = FragMap.find(EndBit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeLine">    bool IntersectEnd = LastOverlap.valid() && LastOverlap.start() < EndBit;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">706</td>
    <td class="codeLine">    bool IntersectEnd = LastOverlap.valid() && LastOverlap.start() < EndBit;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">707</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeLine">    // Check if both ends of `f` intersect the same interval `i`.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">708</td>
    <td class="codeLine">    // Check if both ends of `f` intersect the same interval `i`.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeLine">    if (IntersectStart && IntersectEnd && FirstOverlap == LastOverlap) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">709</td>
    <td class="codeLine">    if (IntersectStart && IntersectEnd && FirstOverlap == LastOverlap) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "- Intersect single interval @ both ends\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">710</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "- Intersect single interval @ both ends\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeLine">      // Shorten `i` so that there's space to insert `f`.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">711</td>
    <td class="codeLine">      // Shorten `i` so that there's space to insert `f`.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeLine">      //      [ f ]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">712</td>
    <td class="codeLine">      //      [ f ]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeLine">      // [  -   i   -  ]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">713</td>
    <td class="codeLine">      // [  -   i   -  ]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeLine">      // +</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">714</td>
    <td class="codeLine">      // +</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeLine">      // [ i ][ f ][ i ]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">715</td>
    <td class="codeLine">      // [ i ][ f ][ i ]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">716</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeLine">      // Save values for use after inserting a new interval.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">717</td>
    <td class="codeLine">      // Save values for use after inserting a new interval.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeLine">      auto EndBitOfOverlap = FirstOverlap.stop();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">718</td>
    <td class="codeLine">      auto EndBitOfOverlap = FirstOverlap.stop();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeLine">      unsigned OverlapValue = FirstOverlap.value();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">719</td>
    <td class="codeLine">      unsigned OverlapValue = FirstOverlap.value();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">720</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeLine">      // Shorten the overlapping interval.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">721</td>
    <td class="codeLine">      // Shorten the overlapping interval.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeLine">      FirstOverlap.setStop(StartBit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">722</td>
    <td class="codeLine">      FirstOverlap.setStop(StartBit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeLine">      insertMemLoc(BB, Before, Var, FirstOverlap.start(), StartBit,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">723</td>
    <td class="codeLine">      insertMemLoc(BB, Before, Var, FirstOverlap.start(), StartBit,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeLine">                   OverlapValue, VarLoc.DL);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">724</td>
    <td class="codeLine">                   OverlapValue, VarLoc.DL);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">725</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeLine">      // Insert a new interval to represent the end part.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">726</td>
    <td class="codeLine">      // Insert a new interval to represent the end part.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeLine">      FragMap.insert(EndBit, EndBitOfOverlap, OverlapValue);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">727</td>
    <td class="codeLine">      FragMap.insert(EndBit, EndBitOfOverlap, OverlapValue);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeLine">      insertMemLoc(BB, Before, Var, EndBit, EndBitOfOverlap, OverlapValue,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">728</td>
    <td class="codeLine">      insertMemLoc(BB, Before, Var, EndBit, EndBitOfOverlap, OverlapValue,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeLine">                   VarLoc.DL);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">729</td>
    <td class="codeLine">                   VarLoc.DL);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">730</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeLine">      // Insert the new (middle) fragment now there is space.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">731</td>
    <td class="codeLine">      // Insert the new (middle) fragment now there is space.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeLine">      FragMap.insert(StartBit, EndBit, Base);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">732</td>
    <td class="codeLine">      FragMap.insert(StartBit, EndBit, Base);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">733</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeLine">      // There's an overlap but `f` may not be fully contained within</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">734</td>
    <td class="codeLine">      // There's an overlap but `f` may not be fully contained within</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeLine">      // `i`. Shorten any end-point intersections so that we can then</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">735</td>
    <td class="codeLine">      // `i`. Shorten any end-point intersections so that we can then</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeLine">      // insert `f`.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">736</td>
    <td class="codeLine">      // insert `f`.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeLine">      //      [ - f - ]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">737</td>
    <td class="codeLine">      //      [ - f - ]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeLine">      // [ - i - ]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">738</td>
    <td class="codeLine">      // [ - i - ]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeLine">      // |   |</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">739</td>
    <td class="codeLine">      // |   |</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeLine">      // [ i ]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">740</td>
    <td class="codeLine">      // [ i ]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeLine">      // Shorten any end-point intersections.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">741</td>
    <td class="codeLine">      // Shorten any end-point intersections.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeLine">      if (IntersectStart) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">742</td>
    <td class="codeLine">      if (IntersectStart) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "- Intersect interval at start\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">743</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "- Intersect interval at start\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeLine">        // Split off at the intersection.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">744</td>
    <td class="codeLine">        // Split off at the intersection.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeLine">        FirstOverlap.setStop(StartBit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">745</td>
    <td class="codeLine">        FirstOverlap.setStop(StartBit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeLine">        insertMemLoc(BB, Before, Var, FirstOverlap.start(), StartBit,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">746</td>
    <td class="codeLine">        insertMemLoc(BB, Before, Var, FirstOverlap.start(), StartBit,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeLine">                     *FirstOverlap, VarLoc.DL);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">747</td>
    <td class="codeLine">                     *FirstOverlap, VarLoc.DL);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">748</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeLine">      // [ - f - ]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">749</td>
    <td class="codeLine">      // [ - f - ]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeLine">      //      [ - i - ]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">750</td>
    <td class="codeLine">      //      [ - i - ]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeLine">      //          |   |</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">751</td>
    <td class="codeLine">      //          |   |</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeLine">      //          [ i ]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">752</td>
    <td class="codeLine">      //          [ i ]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeLine">      if (IntersectEnd) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">753</td>
    <td class="codeLine">      if (IntersectEnd) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "- Intersect interval at end\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">754</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "- Intersect interval at end\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeLine">        // Split off at the intersection.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">755</td>
    <td class="codeLine">        // Split off at the intersection.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeLine">        LastOverlap.setStart(EndBit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">756</td>
    <td class="codeLine">        LastOverlap.setStart(EndBit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeLine">        insertMemLoc(BB, Before, Var, EndBit, LastOverlap.stop(), *LastOverlap,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">757</td>
    <td class="codeLine">        insertMemLoc(BB, Before, Var, EndBit, LastOverlap.stop(), *LastOverlap,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeLine">                     VarLoc.DL);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">758</td>
    <td class="codeLine">                     VarLoc.DL);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">759</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">760</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "- Erase intervals contained within\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">761</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "- Erase intervals contained within\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeLine">      // FirstOverlap and LastOverlap have been shortened such that they're</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">762</td>
    <td class="codeLine">      // FirstOverlap and LastOverlap have been shortened such that they're</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeLine">      // no longer overlapping with [StartBit, EndBit). Delete any overlaps</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">763</td>
    <td class="codeLine">      // no longer overlapping with [StartBit, EndBit). Delete any overlaps</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeLine">      // that remain (these will be fully contained within `f`).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">764</td>
    <td class="codeLine">      // that remain (these will be fully contained within `f`).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeLine">      // [ - f - ]       }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">765</td>
    <td class="codeLine">      // [ - f - ]       }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeLine">      //      [ - i - ]  } Intersection shortening that has happened above.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">766</td>
    <td class="codeLine">      //      [ - i - ]  } Intersection shortening that has happened above.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeLine">      //          |   |  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">767</td>
    <td class="codeLine">      //          |   |  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeLine">      //          [ i ]  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">768</td>
    <td class="codeLine">      //          [ i ]  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeLine">      // -----------------</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">769</td>
    <td class="codeLine">      // -----------------</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeLine">      // [i2 ]           } Intervals fully contained within `f` get erased.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">770</td>
    <td class="codeLine">      // [i2 ]           } Intervals fully contained within `f` get erased.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeLine">      // -----------------</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">771</td>
    <td class="codeLine">      // -----------------</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeLine">      // [ - f - ][ i ]  } Completed insertion.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">772</td>
    <td class="codeLine">      // [ - f - ][ i ]  } Completed insertion.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeLine">      auto It = FirstOverlap;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">773</td>
    <td class="codeLine">      auto It = FirstOverlap;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeLine">      if (IntersectStart)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">774</td>
    <td class="codeLine">      if (IntersectStart)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeLine">        ++It; // IntersectStart: first overlap has been shortened.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">775</td>
    <td class="codeLine">        ++It; // IntersectStart: first overlap has been shortened.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeLine">      while (It.valid() && It.start() >= StartBit && It.stop() <= EndBit) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">776</td>
    <td class="codeLine">      while (It.valid() && It.start() >= StartBit && It.stop() <= EndBit) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "- Erase " << toString(It));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">777</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "- Erase " << toString(It));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeLine">        It.erase(); // This increments It after removing the interval.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">778</td>
    <td class="codeLine">        It.erase(); // This increments It after removing the interval.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">779</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeLine">      // We've dealt with all the overlaps now!</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">780</td>
    <td class="codeLine">      // We've dealt with all the overlaps now!</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeLine">      assert(!FragMap.overlaps(StartBit, EndBit));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">781</td>
    <td class="codeLine">      assert(!FragMap.overlaps(StartBit, EndBit));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "- Insert DEF into now-empty space\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">782</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "- Insert DEF into now-empty space\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeLine">      FragMap.insert(StartBit, EndBit, Base);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">783</td>
    <td class="codeLine">      FragMap.insert(StartBit, EndBit, Base);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">784</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">785</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeLine">    coalesceFragments(BB, Before, Var, StartBit, EndBit, Base, VarLoc.DL,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">786</td>
    <td class="codeLine">    coalesceFragments(BB, Before, Var, StartBit, EndBit, Base, VarLoc.DL,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeLine">                      FragMap);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">787</td>
    <td class="codeLine">                      FragMap);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">788</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">789</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeLine">  bool skipVariable(const DILocalVariable *V) { return !V->getSizeInBits(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">790</td>
    <td class="codeLine">  bool skipVariable(const DILocalVariable *V) { return !V->getSizeInBits(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">791</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeLine">  void process(BasicBlock &BB, VarFragMap &LiveSet) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">792</td>
    <td class="codeLine">  void process(BasicBlock &BB, VarFragMap &LiveSet) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeLine">    BBInsertBeforeMap[&BB].clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">793</td>
    <td class="codeLine">    BBInsertBeforeMap[&BB].clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeLine">    for (auto &I : BB) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">794</td>
    <td class="codeLine">    for (auto &I : BB) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeLine">      if (const auto *Locs = FnVarLocs->getWedge(&I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">795</td>
    <td class="codeLine">      if (const auto *Locs = FnVarLocs->getWedge(&I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeLine">        for (const VarLocInfo &Loc : *Locs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">796</td>
    <td class="codeLine">        for (const VarLocInfo &Loc : *Locs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeLine">          addDef(Loc, I, *I.getParent(), LiveSet);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">797</td>
    <td class="codeLine">          addDef(Loc, I, *I.getParent(), LiveSet);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">798</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">799</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">800</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">801</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">802</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">803</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeLine">  MemLocFragmentFill(Function &Fn,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">804</td>
    <td class="codeLine">  MemLocFragmentFill(Function &Fn,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeLine">                     const DenseSet<DebugAggregate> *VarsWithStackSlot,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">805</td>
    <td class="codeLine">                     const DenseSet<DebugAggregate> *VarsWithStackSlot,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeLine">                     bool CoalesceAdjacentFragments)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">806</td>
    <td class="codeLine">                     bool CoalesceAdjacentFragments)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeLine">      : Fn(Fn), VarsWithStackSlot(VarsWithStackSlot),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">807</td>
    <td class="codeLine">      : Fn(Fn), VarsWithStackSlot(VarsWithStackSlot),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeLine">        CoalesceAdjacentFragments(CoalesceAdjacentFragments) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">808</td>
    <td class="codeLine">        CoalesceAdjacentFragments(CoalesceAdjacentFragments) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">809</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeLine">  /// Add variable locations to \p FnVarLocs so that any bits of a variable</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">810</td>
    <td class="codeLine">  /// Add variable locations to \p FnVarLocs so that any bits of a variable</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeLine">  /// with a memory location have that location explicitly reinstated at each</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">811</td>
    <td class="codeLine">  /// with a memory location have that location explicitly reinstated at each</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeLine">  /// subsequent variable location definition that that doesn't overwrite those</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">812</td>
    <td class="codeLine">  /// subsequent variable location definition that that doesn't overwrite those</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeLine">  /// bits. i.e. after a variable location def, insert new defs for the memory</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">813</td>
    <td class="codeLine">  /// bits. i.e. after a variable location def, insert new defs for the memory</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeLine">  /// location with fragments for the difference of "all bits currently in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">814</td>
    <td class="codeLine">  /// location with fragments for the difference of "all bits currently in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeLine">  /// memory" and "the fragment of the second def". e.g.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">815</td>
    <td class="codeLine">  /// memory" and "the fragment of the second def". e.g.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">816</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeLine">  ///     Before:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">817</td>
    <td class="codeLine">  ///     Before:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">818</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeLine">  ///     var x bits 0 to 63:  value in memory</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">819</td>
    <td class="codeLine">  ///     var x bits 0 to 63:  value in memory</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeLine">  ///     more instructions</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">820</td>
    <td class="codeLine">  ///     more instructions</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeLine">  ///     var x bits 0 to 31:  value is %0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">821</td>
    <td class="codeLine">  ///     var x bits 0 to 31:  value is %0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">822</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeLine">  ///     After:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">823</td>
    <td class="codeLine">  ///     After:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">824</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeLine">  ///     var x bits 0 to 63:  value in memory</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">825</td>
    <td class="codeLine">  ///     var x bits 0 to 63:  value in memory</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeLine">  ///     more instructions</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">826</td>
    <td class="codeLine">  ///     more instructions</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeLine">  ///     var x bits 0 to 31:  value is %0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">827</td>
    <td class="codeLine">  ///     var x bits 0 to 31:  value is %0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeLine">  ///     var x bits 32 to 61: value in memory ; <-- new loc def</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">828</td>
    <td class="codeLine">  ///     var x bits 32 to 61: value in memory ; <-- new loc def</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">829</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeLine">  void run(FunctionVarLocsBuilder *FnVarLocs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">830</td>
    <td class="codeLine">  void run(FunctionVarLocsBuilder *FnVarLocs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeLine">    if (!EnableMemLocFragFill)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">831</td>
    <td class="codeLine">    if (!EnableMemLocFragFill)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">832</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">833</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeLine">    this->FnVarLocs = FnVarLocs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">834</td>
    <td class="codeLine">    this->FnVarLocs = FnVarLocs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">835</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeLine">    // Prepare for traversal.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">836</td>
    <td class="codeLine">    // Prepare for traversal.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">837</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeLine">    ReversePostOrderTraversal<Function *> RPOT(&Fn);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">838</td>
    <td class="codeLine">    ReversePostOrderTraversal<Function *> RPOT(&Fn);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeLine">    std::priority_queue<unsigned int, std::vector<unsigned int>,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">839</td>
    <td class="codeLine">    std::priority_queue<unsigned int, std::vector<unsigned int>,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeLine">                        std::greater<unsigned int>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">840</td>
    <td class="codeLine">                        std::greater<unsigned int>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeLine">        Worklist;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">841</td>
    <td class="codeLine">        Worklist;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeLine">    std::priority_queue<unsigned int, std::vector<unsigned int>,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">842</td>
    <td class="codeLine">    std::priority_queue<unsigned int, std::vector<unsigned int>,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeLine">                        std::greater<unsigned int>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">843</td>
    <td class="codeLine">                        std::greater<unsigned int>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeLine">        Pending;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">844</td>
    <td class="codeLine">        Pending;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeLine">    DenseMap<unsigned int, BasicBlock *> OrderToBB;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">845</td>
    <td class="codeLine">    DenseMap<unsigned int, BasicBlock *> OrderToBB;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeLine">    DenseMap<BasicBlock *, unsigned int> BBToOrder;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">846</td>
    <td class="codeLine">    DenseMap<BasicBlock *, unsigned int> BBToOrder;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeLine">    { // Init OrderToBB and BBToOrder.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">847</td>
    <td class="codeLine">    { // Init OrderToBB and BBToOrder.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeLine">      unsigned int RPONumber = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">848</td>
    <td class="codeLine">      unsigned int RPONumber = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeLine">      for (auto RI = RPOT.begin(), RE = RPOT.end(); RI != RE; ++RI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">849</td>
    <td class="codeLine">      for (auto RI = RPOT.begin(), RE = RPOT.end(); RI != RE; ++RI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeLine">        OrderToBB[RPONumber] = *RI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">850</td>
    <td class="codeLine">        OrderToBB[RPONumber] = *RI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeLine">        BBToOrder[*RI] = RPONumber;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">851</td>
    <td class="codeLine">        BBToOrder[*RI] = RPONumber;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeLine">        Worklist.push(RPONumber);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">852</td>
    <td class="codeLine">        Worklist.push(RPONumber);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeLine">        ++RPONumber;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">853</td>
    <td class="codeLine">        ++RPONumber;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">854</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeLine">      LiveIn.init(RPONumber);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">855</td>
    <td class="codeLine">      LiveIn.init(RPONumber);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeLine">      LiveOut.init(RPONumber);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">856</td>
    <td class="codeLine">      LiveOut.init(RPONumber);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">857</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">858</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeLine">    // Perform the traversal.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">859</td>
    <td class="codeLine">    // Perform the traversal.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">860</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeLine">    // This is a standard "intersect of predecessor outs" dataflow problem. To</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">861</td>
    <td class="codeLine">    // This is a standard "intersect of predecessor outs" dataflow problem. To</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeLine">    // solve it, we perform meet() and process() using the two worklist method</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">862</td>
    <td class="codeLine">    // solve it, we perform meet() and process() using the two worklist method</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeLine">    // until the LiveIn data for each block becomes unchanging.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">863</td>
    <td class="codeLine">    // until the LiveIn data for each block becomes unchanging.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">864</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeLine">    // This dataflow is essentially working on maps of sets and at each meet we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">865</td>
    <td class="codeLine">    // This dataflow is essentially working on maps of sets and at each meet we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeLine">    // intersect the maps and the mapped sets. So, initialized live-in maps</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">866</td>
    <td class="codeLine">    // intersect the maps and the mapped sets. So, initialized live-in maps</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeLine">    // monotonically decrease in value throughout the dataflow.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">867</td>
    <td class="codeLine">    // monotonically decrease in value throughout the dataflow.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeLine">    SmallPtrSet<BasicBlock *, 16> Visited;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">868</td>
    <td class="codeLine">    SmallPtrSet<BasicBlock *, 16> Visited;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeLine">    while (!Worklist.empty() || !Pending.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">869</td>
    <td class="codeLine">    while (!Worklist.empty() || !Pending.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeLine">      // We track what is on the pending worklist to avoid inserting the same</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">870</td>
    <td class="codeLine">      // We track what is on the pending worklist to avoid inserting the same</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeLine">      // thing twice.  We could avoid this with a custom priority queue, but</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">871</td>
    <td class="codeLine">      // thing twice.  We could avoid this with a custom priority queue, but</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeLine">      // this is probably not worth it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">872</td>
    <td class="codeLine">      // this is probably not worth it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeLine">      SmallPtrSet<BasicBlock *, 16> OnPending;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">873</td>
    <td class="codeLine">      SmallPtrSet<BasicBlock *, 16> OnPending;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "Processing Worklist\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">874</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "Processing Worklist\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeLine">      while (!Worklist.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">875</td>
    <td class="codeLine">      while (!Worklist.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeLine">        BasicBlock *BB = OrderToBB[Worklist.top()];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">876</td>
    <td class="codeLine">        BasicBlock *BB = OrderToBB[Worklist.top()];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "\nPop BB " << BB->getName() << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">877</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "\nPop BB " << BB->getName() << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeLine">        Worklist.pop();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">878</td>
    <td class="codeLine">        Worklist.pop();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeLine">        bool InChanged = meet(*BB, Visited);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">879</td>
    <td class="codeLine">        bool InChanged = meet(*BB, Visited);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeLine">        // Always consider LiveIn changed on the first visit.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">880</td>
    <td class="codeLine">        // Always consider LiveIn changed on the first visit.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeLine">        InChanged |= Visited.insert(BB).second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">881</td>
    <td class="codeLine">        InChanged |= Visited.insert(BB).second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeLine">        if (InChanged) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">882</td>
    <td class="codeLine">        if (InChanged) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeLine">          LLVM_DEBUG(dbgs()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">883</td>
    <td class="codeLine">          LLVM_DEBUG(dbgs()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeLine">                     << BB->getName() << " has new InLocs, process it\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">884</td>
    <td class="codeLine">                     << BB->getName() << " has new InLocs, process it\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeLine">          //  Mutate a copy of LiveIn while processing BB. Once we've processed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">885</td>
    <td class="codeLine">          //  Mutate a copy of LiveIn while processing BB. Once we've processed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeLine">          //  the terminator LiveSet is the LiveOut set for BB.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">886</td>
    <td class="codeLine">          //  the terminator LiveSet is the LiveOut set for BB.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeLine">          //  This is an expensive copy!</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">887</td>
    <td class="codeLine">          //  This is an expensive copy!</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeLine">          VarFragMap LiveSet = LiveIn[BB];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">888</td>
    <td class="codeLine">          VarFragMap LiveSet = LiveIn[BB];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">889</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeLine">          // Process the instructions in the block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">890</td>
    <td class="codeLine">          // Process the instructions in the block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeLine">          process(*BB, LiveSet);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">891</td>
    <td class="codeLine">          process(*BB, LiveSet);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">892</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeLine">          // Relatively expensive check: has anything changed in LiveOut for BB?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">893</td>
    <td class="codeLine">          // Relatively expensive check: has anything changed in LiveOut for BB?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeLine">          if (!varFragMapsAreEqual(LiveOut[BB], LiveSet)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">894</td>
    <td class="codeLine">          if (!varFragMapsAreEqual(LiveOut[BB], LiveSet)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeLine">            LLVM_DEBUG(dbgs() << BB->getName()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">895</td>
    <td class="codeLine">            LLVM_DEBUG(dbgs() << BB->getName()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeLine">                              << " has new OutLocs, add succs to worklist: [ ");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">896</td>
    <td class="codeLine">                              << " has new OutLocs, add succs to worklist: [ ");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeLine">            LiveOut[BB] = std::move(LiveSet);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">897</td>
    <td class="codeLine">            LiveOut[BB] = std::move(LiveSet);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeLine">            for (auto I = succ_begin(BB), E = succ_end(BB); I != E; I++) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">898</td>
    <td class="codeLine">            for (auto I = succ_begin(BB), E = succ_end(BB); I != E; I++) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeLine">              if (OnPending.insert(*I).second) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">899</td>
    <td class="codeLine">              if (OnPending.insert(*I).second) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeLine">                LLVM_DEBUG(dbgs() << I->getName() << " ");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">900</td>
    <td class="codeLine">                LLVM_DEBUG(dbgs() << I->getName() << " ");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeLine">                Pending.push(BBToOrder[*I]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">901</td>
    <td class="codeLine">                Pending.push(BBToOrder[*I]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeLine">              }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">902</td>
    <td class="codeLine">              }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeLine">            }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">903</td>
    <td class="codeLine">            }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeLine">            LLVM_DEBUG(dbgs() << "]\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">904</td>
    <td class="codeLine">            LLVM_DEBUG(dbgs() << "]\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">905</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">906</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">907</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeLine">      Worklist.swap(Pending);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">908</td>
    <td class="codeLine">      Worklist.swap(Pending);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeLine">      // At this point, pending must be empty, since it was just the empty</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">909</td>
    <td class="codeLine">      // At this point, pending must be empty, since it was just the empty</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeLine">      // worklist</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">910</td>
    <td class="codeLine">      // worklist</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeLine">      assert(Pending.empty() && "Pending should be empty");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">911</td>
    <td class="codeLine">      assert(Pending.empty() && "Pending should be empty");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">912</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">913</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeLine">    // Insert new location defs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">914</td>
    <td class="codeLine">    // Insert new location defs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeLine">    for (auto &Pair : BBInsertBeforeMap) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">915</td>
    <td class="codeLine">    for (auto &Pair : BBInsertBeforeMap) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeLine">      InsertMap &Map = Pair.second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">916</td>
    <td class="codeLine">      InsertMap &Map = Pair.second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeLine">      for (auto &Pair : Map) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">917</td>
    <td class="codeLine">      for (auto &Pair : Map) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeLine">        Instruction *InsertBefore = Pair.first;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">918</td>
    <td class="codeLine">        Instruction *InsertBefore = Pair.first;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeLine">        assert(InsertBefore && "should never be null");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">919</td>
    <td class="codeLine">        assert(InsertBefore && "should never be null");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeLine">        auto FragMemLocs = Pair.second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">920</td>
    <td class="codeLine">        auto FragMemLocs = Pair.second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeLine">        auto &Ctx = Fn.getContext();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">921</td>
    <td class="codeLine">        auto &Ctx = Fn.getContext();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">922</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeLine">        for (auto &FragMemLoc : FragMemLocs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">923</td>
    <td class="codeLine">        for (auto &FragMemLoc : FragMemLocs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeLine">          DIExpression *Expr = DIExpression::get(Ctx, std::nullopt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">924</td>
    <td class="codeLine">          DIExpression *Expr = DIExpression::get(Ctx, std::nullopt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeLine">          if (FragMemLoc.SizeInBits !=</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">925</td>
    <td class="codeLine">          if (FragMemLoc.SizeInBits !=</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeLine">              *Aggregates[FragMemLoc.Var].first->getSizeInBits())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">926</td>
    <td class="codeLine">              *Aggregates[FragMemLoc.Var].first->getSizeInBits())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeLine">            Expr = *DIExpression::createFragmentExpression(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">927</td>
    <td class="codeLine">            Expr = *DIExpression::createFragmentExpression(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeLine">                Expr, FragMemLoc.OffsetInBits, FragMemLoc.SizeInBits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">928</td>
    <td class="codeLine">                Expr, FragMemLoc.OffsetInBits, FragMemLoc.SizeInBits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeLine">          Expr = DIExpression::prepend(Expr, DIExpression::DerefAfter,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">929</td>
    <td class="codeLine">          Expr = DIExpression::prepend(Expr, DIExpression::DerefAfter,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeLine">                                       FragMemLoc.OffsetInBits / 8);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">930</td>
    <td class="codeLine">                                       FragMemLoc.OffsetInBits / 8);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeLine">          DebugVariable Var(Aggregates[FragMemLoc.Var].first, Expr,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">931</td>
    <td class="codeLine">          DebugVariable Var(Aggregates[FragMemLoc.Var].first, Expr,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeLine">                            FragMemLoc.DL.getInlinedAt());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">932</td>
    <td class="codeLine">                            FragMemLoc.DL.getInlinedAt());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeLine">          FnVarLocs->addVarLoc(InsertBefore, Var, Expr, FragMemLoc.DL,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">933</td>
    <td class="codeLine">          FnVarLocs->addVarLoc(InsertBefore, Var, Expr, FragMemLoc.DL,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeLine">                               Bases[FragMemLoc.Base]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">934</td>
    <td class="codeLine">                               Bases[FragMemLoc.Base]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">935</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">936</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">937</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">938</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">939</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">940</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeLine">/// AssignmentTrackingLowering encapsulates a dataflow analysis over a function</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">941</td>
    <td class="codeLine">/// AssignmentTrackingLowering encapsulates a dataflow analysis over a function</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeLine">/// that interprets assignment tracking debug info metadata and stores in IR to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">942</td>
    <td class="codeLine">/// that interprets assignment tracking debug info metadata and stores in IR to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeLine">/// create a map of variable locations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">943</td>
    <td class="codeLine">/// create a map of variable locations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeLine">class AssignmentTrackingLowering {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">944</td>
    <td class="codeLine">class AssignmentTrackingLowering {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">945</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeLine">  /// The kind of location in use for a variable, where Mem is the stack home,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">946</td>
    <td class="codeLine">  /// The kind of location in use for a variable, where Mem is the stack home,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeLine">  /// Val is an SSA value or const, and None means that there is not one single</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">947</td>
    <td class="codeLine">  /// Val is an SSA value or const, and None means that there is not one single</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeLine">  /// kind (either because there are multiple or because there is none; it may</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">948</td>
    <td class="codeLine">  /// kind (either because there are multiple or because there is none; it may</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeLine">  /// prove useful to split this into two values in the future).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">949</td>
    <td class="codeLine">  /// prove useful to split this into two values in the future).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">950</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeLine">  /// LocKind is a join-semilattice with the partial order:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">951</td>
    <td class="codeLine">  /// LocKind is a join-semilattice with the partial order:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeLine">  /// None > Mem, Val</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">952</td>
    <td class="codeLine">  /// None > Mem, Val</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">953</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeLine">  /// i.e.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">954</td>
    <td class="codeLine">  /// i.e.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeLine">  /// join(Mem, Mem)   = Mem</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">955</td>
    <td class="codeLine">  /// join(Mem, Mem)   = Mem</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeLine">  /// join(Val, Val)   = Val</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">956</td>
    <td class="codeLine">  /// join(Val, Val)   = Val</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeLine">  /// join(Mem, Val)   = None</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">957</td>
    <td class="codeLine">  /// join(Mem, Val)   = None</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeLine">  /// join(None, Mem)  = None</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">958</td>
    <td class="codeLine">  /// join(None, Mem)  = None</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeLine">  /// join(None, Val)  = None</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">959</td>
    <td class="codeLine">  /// join(None, Val)  = None</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeLine">  /// join(None, None) = None</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">960</td>
    <td class="codeLine">  /// join(None, None) = None</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">961</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeLine">  /// Note: the order is not `None > Val > Mem` because we're using DIAssignID</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">962</td>
    <td class="codeLine">  /// Note: the order is not `None > Val > Mem` because we're using DIAssignID</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeLine">  /// to name assignments and are not tracking the actual stored values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">963</td>
    <td class="codeLine">  /// to name assignments and are not tracking the actual stored values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeLine">  /// Therefore currently there's no way to ensure that Mem values and Val</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">964</td>
    <td class="codeLine">  /// Therefore currently there's no way to ensure that Mem values and Val</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeLine">  /// values are the same. This could be a future extension, though it's not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">965</td>
    <td class="codeLine">  /// values are the same. This could be a future extension, though it's not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeLine">  /// clear that many additional locations would be recovered that way in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">966</td>
    <td class="codeLine">  /// clear that many additional locations would be recovered that way in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeLine">  /// practice as the likelihood of this sitation arising naturally seems</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">967</td>
    <td class="codeLine">  /// practice as the likelihood of this sitation arising naturally seems</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeLine">  /// incredibly low.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">968</td>
    <td class="codeLine">  /// incredibly low.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeLine">  enum class LocKind { Mem, Val, None };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">969</td>
    <td class="codeLine">  enum class LocKind { Mem, Val, None };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">970</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeLine">  /// An abstraction of the assignment of a value to a variable or memory</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">971</td>
    <td class="codeLine">  /// An abstraction of the assignment of a value to a variable or memory</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeLine">  /// location.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">972</td>
    <td class="codeLine">  /// location.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">973</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeLine">  /// An Assignment is Known or NoneOrPhi. A Known Assignment means we have a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">974</td>
    <td class="codeLine">  /// An Assignment is Known or NoneOrPhi. A Known Assignment means we have a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeLine">  /// DIAssignID ptr that represents it. NoneOrPhi means that we don't (or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">975</td>
    <td class="codeLine">  /// DIAssignID ptr that represents it. NoneOrPhi means that we don't (or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeLine">  /// can't) know the ID of the last assignment that took place.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">976</td>
    <td class="codeLine">  /// can't) know the ID of the last assignment that took place.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">977</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeLine">  /// The Status of the Assignment (Known or NoneOrPhi) is another</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">978</td>
    <td class="codeLine">  /// The Status of the Assignment (Known or NoneOrPhi) is another</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeLine">  /// join-semilattice. The partial order is:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">979</td>
    <td class="codeLine">  /// join-semilattice. The partial order is:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeLine">  /// NoneOrPhi > Known {id_0, id_1, ...id_N}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">980</td>
    <td class="codeLine">  /// NoneOrPhi > Known {id_0, id_1, ...id_N}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">981</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeLine">  /// i.e. for all values x and y where x != y:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">982</td>
    <td class="codeLine">  /// i.e. for all values x and y where x != y:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeLine">  /// join(x, x) = x</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">983</td>
    <td class="codeLine">  /// join(x, x) = x</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeLine">  /// join(x, y) = NoneOrPhi</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">984</td>
    <td class="codeLine">  /// join(x, y) = NoneOrPhi</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeLine">  struct Assignment {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">985</td>
    <td class="codeLine">  struct Assignment {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeLine">    enum S { Known, NoneOrPhi } Status;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">986</td>
    <td class="codeLine">    enum S { Known, NoneOrPhi } Status;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeLine">    /// ID of the assignment. nullptr if Status is not Known.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">987</td>
    <td class="codeLine">    /// ID of the assignment. nullptr if Status is not Known.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeLine">    DIAssignID *ID;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">988</td>
    <td class="codeLine">    DIAssignID *ID;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeLine">    /// The dbg.assign that marks this dbg-def. Mem-defs don't use this field.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">989</td>
    <td class="codeLine">    /// The dbg.assign that marks this dbg-def. Mem-defs don't use this field.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeLine">    /// May be nullptr.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">990</td>
    <td class="codeLine">    /// May be nullptr.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeLine">    DbgAssignIntrinsic *Source;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">991</td>
    <td class="codeLine">    DbgAssignIntrinsic *Source;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">992</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeLine">    bool isSameSourceAssignment(const Assignment &Other) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">993</td>
    <td class="codeLine">    bool isSameSourceAssignment(const Assignment &Other) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeLine">      // Don't include Source in the equality check. Assignments are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">994</td>
    <td class="codeLine">      // Don't include Source in the equality check. Assignments are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeLine">      // defined by their ID, not debug intrinsic(s).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">995</td>
    <td class="codeLine">      // defined by their ID, not debug intrinsic(s).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeLine">      return std::tie(Status, ID) == std::tie(Other.Status, Other.ID);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">996</td>
    <td class="codeLine">      return std::tie(Status, ID) == std::tie(Other.Status, Other.ID);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">997</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeLine">    void dump(raw_ostream &OS) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">998</td>
    <td class="codeLine">    void dump(raw_ostream &OS) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeLine">      static const char *LUT[] = {"Known", "NoneOrPhi"};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">999</td>
    <td class="codeLine">      static const char *LUT[] = {"Known", "NoneOrPhi"};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeLine">      OS << LUT[Status] << "(id=";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1000</td>
    <td class="codeLine">      OS << LUT[Status] << "(id=";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeLine">      if (ID)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1001</td>
    <td class="codeLine">      if (ID)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeLine">        OS << ID;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1002</td>
    <td class="codeLine">        OS << ID;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeLine">      else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1003</td>
    <td class="codeLine">      else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeLine">        OS << "null";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1004</td>
    <td class="codeLine">        OS << "null";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeLine">      OS << ", s=";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1005</td>
    <td class="codeLine">      OS << ", s=";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeLine">      if (Source)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1006</td>
    <td class="codeLine">      if (Source)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeLine">        OS << *Source;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1007</td>
    <td class="codeLine">        OS << *Source;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeLine">      else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1008</td>
    <td class="codeLine">      else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeLine">        OS << "null";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1009</td>
    <td class="codeLine">        OS << "null";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeLine">      OS << ")";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1010</td>
    <td class="codeLine">      OS << ")";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1011</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1012</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeLine">    static Assignment make(DIAssignID *ID, DbgAssignIntrinsic *Source) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1013</td>
    <td class="codeLine">    static Assignment make(DIAssignID *ID, DbgAssignIntrinsic *Source) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeLine">      return Assignment(Known, ID, Source);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1014</td>
    <td class="codeLine">      return Assignment(Known, ID, Source);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1015</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeLine">    static Assignment makeFromMemDef(DIAssignID *ID) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1016</td>
    <td class="codeLine">    static Assignment makeFromMemDef(DIAssignID *ID) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeLine">      return Assignment(Known, ID, nullptr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1017</td>
    <td class="codeLine">      return Assignment(Known, ID, nullptr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1018</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeLine">    static Assignment makeNoneOrPhi() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1019</td>
    <td class="codeLine">    static Assignment makeNoneOrPhi() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeLine">      return Assignment(NoneOrPhi, nullptr, nullptr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1020</td>
    <td class="codeLine">      return Assignment(NoneOrPhi, nullptr, nullptr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1021</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeLine">    // Again, need a Top value?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1022</td>
    <td class="codeLine">    // Again, need a Top value?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeLine">    Assignment()</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1023</td>
    <td class="codeLine">    Assignment()</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeLine">        : Status(NoneOrPhi), ID(nullptr), Source(nullptr) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1024</td>
    <td class="codeLine">        : Status(NoneOrPhi), ID(nullptr), Source(nullptr) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeLine">    } // Can we delete this?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1025</td>
    <td class="codeLine">    } // Can we delete this?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeLine">    Assignment(S Status, DIAssignID *ID, DbgAssignIntrinsic *Source)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1026</td>
    <td class="codeLine">    Assignment(S Status, DIAssignID *ID, DbgAssignIntrinsic *Source)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeLine">        : Status(Status), ID(ID), Source(Source) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1027</td>
    <td class="codeLine">        : Status(Status), ID(ID), Source(Source) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeLine">      // If the Status is Known then we expect there to be an assignment ID.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1028</td>
    <td class="codeLine">      // If the Status is Known then we expect there to be an assignment ID.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeLine">      assert(Status == NoneOrPhi || ID);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1029</td>
    <td class="codeLine">      assert(Status == NoneOrPhi || ID);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1030</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1031</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1032</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeLine">  using AssignmentMap = SmallVector<Assignment>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1033</td>
    <td class="codeLine">  using AssignmentMap = SmallVector<Assignment>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeLine">  using LocMap = SmallVector<LocKind>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1034</td>
    <td class="codeLine">  using LocMap = SmallVector<LocKind>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeLine">  using OverlapMap = DenseMap<VariableID, SmallVector<VariableID>>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1035</td>
    <td class="codeLine">  using OverlapMap = DenseMap<VariableID, SmallVector<VariableID>>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeLine">  using UntaggedStoreAssignmentMap =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1036</td>
    <td class="codeLine">  using UntaggedStoreAssignmentMap =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeLine">      DenseMap<const Instruction *,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1037</td>
    <td class="codeLine">      DenseMap<const Instruction *,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeLine">               SmallVector<std::pair<VariableID, at::AssignmentInfo>>>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1038</td>
    <td class="codeLine">               SmallVector<std::pair<VariableID, at::AssignmentInfo>>>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1039</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1040</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeLine">  /// The highest numbered VariableID for partially promoted variables plus 1,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1041</td>
    <td class="codeLine">  /// The highest numbered VariableID for partially promoted variables plus 1,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeLine">  /// the values for which start at 1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1042</td>
    <td class="codeLine">  /// the values for which start at 1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeLine">  unsigned TrackedVariablesVectorSize = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1043</td>
    <td class="codeLine">  unsigned TrackedVariablesVectorSize = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeLine">  /// Map a variable to the set of variables that it fully contains.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1044</td>
    <td class="codeLine">  /// Map a variable to the set of variables that it fully contains.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeLine">  OverlapMap VarContains;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1045</td>
    <td class="codeLine">  OverlapMap VarContains;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeLine">  /// Map untagged stores to the variable fragments they assign to. Used by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1046</td>
    <td class="codeLine">  /// Map untagged stores to the variable fragments they assign to. Used by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeLine">  /// processUntaggedInstruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1047</td>
    <td class="codeLine">  /// processUntaggedInstruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeLine">  UntaggedStoreAssignmentMap UntaggedStoreVars;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1048</td>
    <td class="codeLine">  UntaggedStoreAssignmentMap UntaggedStoreVars;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1049</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeLine">  // Machinery to defer inserting dbg.values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1050</td>
    <td class="codeLine">  // Machinery to defer inserting dbg.values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeLine">  using InsertMap = MapVector<Instruction *, SmallVector<VarLocInfo>>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1051</td>
    <td class="codeLine">  using InsertMap = MapVector<Instruction *, SmallVector<VarLocInfo>>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeLine">  InsertMap InsertBeforeMap;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1052</td>
    <td class="codeLine">  InsertMap InsertBeforeMap;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeLine">  /// Clear the location definitions currently cached for insertion after /p</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1053</td>
    <td class="codeLine">  /// Clear the location definitions currently cached for insertion after /p</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeLine">  /// After.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1054</td>
    <td class="codeLine">  /// After.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeLine">  void resetInsertionPoint(Instruction &After);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1055</td>
    <td class="codeLine">  void resetInsertionPoint(Instruction &After);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeLine">  void emitDbgValue(LocKind Kind, const DbgVariableIntrinsic *Source,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1056</td>
    <td class="codeLine">  void emitDbgValue(LocKind Kind, const DbgVariableIntrinsic *Source,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeLine">                    Instruction *After);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1057</td>
    <td class="codeLine">                    Instruction *After);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1058</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeLine">  static bool mapsAreEqual(const BitVector &Mask, const AssignmentMap &A,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1059</td>
    <td class="codeLine">  static bool mapsAreEqual(const BitVector &Mask, const AssignmentMap &A,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeLine">                           const AssignmentMap &B) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1060</td>
    <td class="codeLine">                           const AssignmentMap &B) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeLine">    return llvm::all_of(Mask.set_bits(), [&](unsigned VarID) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1061</td>
    <td class="codeLine">    return llvm::all_of(Mask.set_bits(), [&](unsigned VarID) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeLine">      return A[VarID].isSameSourceAssignment(B[VarID]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1062</td>
    <td class="codeLine">      return A[VarID].isSameSourceAssignment(B[VarID]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1063</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1064</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1065</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeLine">  /// Represents the stack and debug assignments in a block. Used to describe</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1066</td>
    <td class="codeLine">  /// Represents the stack and debug assignments in a block. Used to describe</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeLine">  /// the live-in and live-out values for blocks, as well as the "current"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1067</td>
    <td class="codeLine">  /// the live-in and live-out values for blocks, as well as the "current"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeLine">  /// value as we process each instruction in a block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1068</td>
    <td class="codeLine">  /// value as we process each instruction in a block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeLine">  struct BlockInfo {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1069</td>
    <td class="codeLine">  struct BlockInfo {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeLine">    /// The set of variables (VariableID) being tracked in this block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1070</td>
    <td class="codeLine">    /// The set of variables (VariableID) being tracked in this block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeLine">    BitVector VariableIDsInBlock;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1071</td>
    <td class="codeLine">    BitVector VariableIDsInBlock;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeLine">    /// Dominating assignment to memory for each variable, indexed by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1072</td>
    <td class="codeLine">    /// Dominating assignment to memory for each variable, indexed by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeLine">    /// VariableID.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1073</td>
    <td class="codeLine">    /// VariableID.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeLine">    AssignmentMap StackHomeValue;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1074</td>
    <td class="codeLine">    AssignmentMap StackHomeValue;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeLine">    /// Dominating assignemnt to each variable, indexed by VariableID.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1075</td>
    <td class="codeLine">    /// Dominating assignemnt to each variable, indexed by VariableID.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeLine">    AssignmentMap DebugValue;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1076</td>
    <td class="codeLine">    AssignmentMap DebugValue;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeLine">    /// Location kind for each variable. LiveLoc indicates whether the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1077</td>
    <td class="codeLine">    /// Location kind for each variable. LiveLoc indicates whether the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeLine">    /// dominating assignment in StackHomeValue (LocKind::Mem), DebugValue</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1078</td>
    <td class="codeLine">    /// dominating assignment in StackHomeValue (LocKind::Mem), DebugValue</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeLine">    /// (LocKind::Val), or neither (LocKind::None) is valid, in that order of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1079</td>
    <td class="codeLine">    /// (LocKind::Val), or neither (LocKind::None) is valid, in that order of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeLine">    /// preference. This cannot be derived by inspecting DebugValue and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1080</td>
    <td class="codeLine">    /// preference. This cannot be derived by inspecting DebugValue and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeLine">    /// StackHomeValue due to the fact that there's no distinction in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1081</td>
    <td class="codeLine">    /// StackHomeValue due to the fact that there's no distinction in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeLine">    /// Assignment (the class) between whether an assignment is unknown or a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1082</td>
    <td class="codeLine">    /// Assignment (the class) between whether an assignment is unknown or a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeLine">    /// merge of multiple assignments (both are Status::NoneOrPhi). In other</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1083</td>
    <td class="codeLine">    /// merge of multiple assignments (both are Status::NoneOrPhi). In other</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeLine">    /// words, the memory location may well be valid while both DebugValue and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1084</td>
    <td class="codeLine">    /// words, the memory location may well be valid while both DebugValue and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeLine">    /// StackHomeValue contain Assignments that have a Status of NoneOrPhi.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1085</td>
    <td class="codeLine">    /// StackHomeValue contain Assignments that have a Status of NoneOrPhi.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeLine">    /// Indexed by VariableID.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1086</td>
    <td class="codeLine">    /// Indexed by VariableID.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeLine">    LocMap LiveLoc;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1087</td>
    <td class="codeLine">    LocMap LiveLoc;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1088</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1089</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeLine">    enum AssignmentKind { Stack, Debug };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1090</td>
    <td class="codeLine">    enum AssignmentKind { Stack, Debug };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeLine">    const AssignmentMap &getAssignmentMap(AssignmentKind Kind) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1091</td>
    <td class="codeLine">    const AssignmentMap &getAssignmentMap(AssignmentKind Kind) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeLine">      switch (Kind) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1092</td>
    <td class="codeLine">      switch (Kind) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeLine">      case Stack:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1093</td>
    <td class="codeLine">      case Stack:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeLine">        return StackHomeValue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1094</td>
    <td class="codeLine">        return StackHomeValue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeLine">      case Debug:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1095</td>
    <td class="codeLine">      case Debug:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeLine">        return DebugValue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1096</td>
    <td class="codeLine">        return DebugValue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1097</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeLine">      llvm_unreachable("Unknown AssignmentKind");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1098</td>
    <td class="codeLine">      llvm_unreachable("Unknown AssignmentKind");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1099</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeLine">    AssignmentMap &getAssignmentMap(AssignmentKind Kind) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1100</td>
    <td class="codeLine">    AssignmentMap &getAssignmentMap(AssignmentKind Kind) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeLine">      return const_cast<AssignmentMap &>(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1101</td>
    <td class="codeLine">      return const_cast<AssignmentMap &>(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeLine">          const_cast<const BlockInfo *>(this)->getAssignmentMap(Kind));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1102</td>
    <td class="codeLine">          const_cast<const BlockInfo *>(this)->getAssignmentMap(Kind));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1103</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1104</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeLine">    bool isVariableTracked(VariableID Var) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1105</td>
    <td class="codeLine">    bool isVariableTracked(VariableID Var) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeLine">      return VariableIDsInBlock[static_cast<unsigned>(Var)];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1106</td>
    <td class="codeLine">      return VariableIDsInBlock[static_cast<unsigned>(Var)];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1107</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1108</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeLine">    const Assignment &getAssignment(AssignmentKind Kind, VariableID Var) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1109</td>
    <td class="codeLine">    const Assignment &getAssignment(AssignmentKind Kind, VariableID Var) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeLine">      assert(isVariableTracked(Var) && "Var not tracked in block");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1110</td>
    <td class="codeLine">      assert(isVariableTracked(Var) && "Var not tracked in block");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeLine">      return getAssignmentMap(Kind)[static_cast<unsigned>(Var)];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1111</td>
    <td class="codeLine">      return getAssignmentMap(Kind)[static_cast<unsigned>(Var)];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1112</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1113</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeLine">    LocKind getLocKind(VariableID Var) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1114</td>
    <td class="codeLine">    LocKind getLocKind(VariableID Var) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeLine">      assert(isVariableTracked(Var) && "Var not tracked in block");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1115</td>
    <td class="codeLine">      assert(isVariableTracked(Var) && "Var not tracked in block");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeLine">      return LiveLoc[static_cast<unsigned>(Var)];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1116</td>
    <td class="codeLine">      return LiveLoc[static_cast<unsigned>(Var)];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1117</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1118</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeLine">    /// Set LocKind for \p Var only: does not set LocKind for VariableIDs of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1119</td>
    <td class="codeLine">    /// Set LocKind for \p Var only: does not set LocKind for VariableIDs of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeLine">    /// fragments contained win \p Var.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1120</td>
    <td class="codeLine">    /// fragments contained win \p Var.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeLine">    void setLocKind(VariableID Var, LocKind K) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1121</td>
    <td class="codeLine">    void setLocKind(VariableID Var, LocKind K) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeLine">      VariableIDsInBlock.set(static_cast<unsigned>(Var));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1122</td>
    <td class="codeLine">      VariableIDsInBlock.set(static_cast<unsigned>(Var));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeLine">      LiveLoc[static_cast<unsigned>(Var)] = K;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1123</td>
    <td class="codeLine">      LiveLoc[static_cast<unsigned>(Var)] = K;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1124</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1125</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeLine">    /// Set the assignment in the \p Kind assignment map for \p Var only: does</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1126</td>
    <td class="codeLine">    /// Set the assignment in the \p Kind assignment map for \p Var only: does</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeLine">    /// not set the assignment for VariableIDs of fragments contained win \p</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1127</td>
    <td class="codeLine">    /// not set the assignment for VariableIDs of fragments contained win \p</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeLine">    /// Var.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1128</td>
    <td class="codeLine">    /// Var.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeLine">    void setAssignment(AssignmentKind Kind, VariableID Var,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1129</td>
    <td class="codeLine">    void setAssignment(AssignmentKind Kind, VariableID Var,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeLine">                       const Assignment &AV) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1130</td>
    <td class="codeLine">                       const Assignment &AV) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeLine">      VariableIDsInBlock.set(static_cast<unsigned>(Var));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1131</td>
    <td class="codeLine">      VariableIDsInBlock.set(static_cast<unsigned>(Var));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeLine">      getAssignmentMap(Kind)[static_cast<unsigned>(Var)] = AV;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1132</td>
    <td class="codeLine">      getAssignmentMap(Kind)[static_cast<unsigned>(Var)] = AV;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1133</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1134</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeLine">    /// Return true if there is an assignment matching \p AV in the \p Kind</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1135</td>
    <td class="codeLine">    /// Return true if there is an assignment matching \p AV in the \p Kind</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeLine">    /// assignment map. Does consider assignments for VariableIDs of fragments</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1136</td>
    <td class="codeLine">    /// assignment map. Does consider assignments for VariableIDs of fragments</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeLine">    /// contained win \p Var.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1137</td>
    <td class="codeLine">    /// contained win \p Var.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeLine">    bool hasAssignment(AssignmentKind Kind, VariableID Var,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1138</td>
    <td class="codeLine">    bool hasAssignment(AssignmentKind Kind, VariableID Var,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeLine">                       const Assignment &AV) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1139</td>
    <td class="codeLine">                       const Assignment &AV) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeLine">      if (!isVariableTracked(Var))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1140</td>
    <td class="codeLine">      if (!isVariableTracked(Var))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1141</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeLine">      return AV.isSameSourceAssignment(getAssignment(Kind, Var));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1142</td>
    <td class="codeLine">      return AV.isSameSourceAssignment(getAssignment(Kind, Var));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1143</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1144</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeLine">    /// Compare every element in each map to determine structural equality</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1145</td>
    <td class="codeLine">    /// Compare every element in each map to determine structural equality</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeLine">    /// (slow).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1146</td>
    <td class="codeLine">    /// (slow).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeLine">    bool operator==(const BlockInfo &Other) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1147</td>
    <td class="codeLine">    bool operator==(const BlockInfo &Other) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeLine">      return VariableIDsInBlock == Other.VariableIDsInBlock &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1148</td>
    <td class="codeLine">      return VariableIDsInBlock == Other.VariableIDsInBlock &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeLine">             LiveLoc == Other.LiveLoc &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1149</td>
    <td class="codeLine">             LiveLoc == Other.LiveLoc &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeLine">             mapsAreEqual(VariableIDsInBlock, StackHomeValue,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1150</td>
    <td class="codeLine">             mapsAreEqual(VariableIDsInBlock, StackHomeValue,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeLine">                          Other.StackHomeValue) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1151</td>
    <td class="codeLine">                          Other.StackHomeValue) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeLine">             mapsAreEqual(VariableIDsInBlock, DebugValue, Other.DebugValue);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1152</td>
    <td class="codeLine">             mapsAreEqual(VariableIDsInBlock, DebugValue, Other.DebugValue);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1153</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeLine">    bool operator!=(const BlockInfo &Other) const { return !(*this == Other); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1154</td>
    <td class="codeLine">    bool operator!=(const BlockInfo &Other) const { return !(*this == Other); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeLine">    bool isValid() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1155</td>
    <td class="codeLine">    bool isValid() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeLine">      return LiveLoc.size() == DebugValue.size() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1156</td>
    <td class="codeLine">      return LiveLoc.size() == DebugValue.size() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeLine">             LiveLoc.size() == StackHomeValue.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1157</td>
    <td class="codeLine">             LiveLoc.size() == StackHomeValue.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1158</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1159</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeLine">    /// Clear everything and initialise with ⊤-values for all variables.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1160</td>
    <td class="codeLine">    /// Clear everything and initialise with ⊤-values for all variables.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeLine">    void init(int NumVars) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1161</td>
    <td class="codeLine">    void init(int NumVars) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeLine">      StackHomeValue.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1162</td>
    <td class="codeLine">      StackHomeValue.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeLine">      DebugValue.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1163</td>
    <td class="codeLine">      DebugValue.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeLine">      LiveLoc.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1164</td>
    <td class="codeLine">      LiveLoc.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeLine">      VariableIDsInBlock = BitVector(NumVars);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1165</td>
    <td class="codeLine">      VariableIDsInBlock = BitVector(NumVars);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeLine">      StackHomeValue.insert(StackHomeValue.begin(), NumVars,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1166</td>
    <td class="codeLine">      StackHomeValue.insert(StackHomeValue.begin(), NumVars,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeLine">                            Assignment::makeNoneOrPhi());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1167</td>
    <td class="codeLine">                            Assignment::makeNoneOrPhi());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeLine">      DebugValue.insert(DebugValue.begin(), NumVars,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1168</td>
    <td class="codeLine">      DebugValue.insert(DebugValue.begin(), NumVars,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeLine">                        Assignment::makeNoneOrPhi());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1169</td>
    <td class="codeLine">                        Assignment::makeNoneOrPhi());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeLine">      LiveLoc.insert(LiveLoc.begin(), NumVars, LocKind::None);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1170</td>
    <td class="codeLine">      LiveLoc.insert(LiveLoc.begin(), NumVars, LocKind::None);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1171</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1172</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeLine">    /// Helper for join.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1173</td>
    <td class="codeLine">    /// Helper for join.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeLine">    template <typename ElmtType, typename FnInputType></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1174</td>
    <td class="codeLine">    template <typename ElmtType, typename FnInputType></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeLine">    static void joinElmt(int Index, SmallVector<ElmtType> &Target,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1175</td>
    <td class="codeLine">    static void joinElmt(int Index, SmallVector<ElmtType> &Target,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeLine">                         const SmallVector<ElmtType> &A,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1176</td>
    <td class="codeLine">                         const SmallVector<ElmtType> &A,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeLine">                         const SmallVector<ElmtType> &B,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1177</td>
    <td class="codeLine">                         const SmallVector<ElmtType> &B,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeLine">                         ElmtType (*Fn)(FnInputType, FnInputType)) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1178</td>
    <td class="codeLine">                         ElmtType (*Fn)(FnInputType, FnInputType)) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeLine">      Target[Index] = Fn(A[Index], B[Index]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1179</td>
    <td class="codeLine">      Target[Index] = Fn(A[Index], B[Index]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1180</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeLine">    /// See comment for AssignmentTrackingLowering::joinBlockInfo.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1182</td>
    <td class="codeLine">    /// See comment for AssignmentTrackingLowering::joinBlockInfo.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeLine">    static BlockInfo join(const BlockInfo &A, const BlockInfo &B, int NumVars) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1183</td>
    <td class="codeLine">    static BlockInfo join(const BlockInfo &A, const BlockInfo &B, int NumVars) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeLine">      // Join A and B.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1184</td>
    <td class="codeLine">      // Join A and B.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeLine">      //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1185</td>
    <td class="codeLine">      //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeLine">      // Intersect = join(a, b) for a in A, b in B where Var(a) == Var(b)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1186</td>
    <td class="codeLine">      // Intersect = join(a, b) for a in A, b in B where Var(a) == Var(b)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeLine">      // Difference = join(x, ⊤) for x where Var(x) is in A xor B</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1187</td>
    <td class="codeLine">      // Difference = join(x, ⊤) for x where Var(x) is in A xor B</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeLine">      // Join = Intersect ∪ Difference</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1188</td>
    <td class="codeLine">      // Join = Intersect ∪ Difference</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeLine">      //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1189</td>
    <td class="codeLine">      //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeLine">      // This is achieved by performing a join on elements from A and B with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1190</td>
    <td class="codeLine">      // This is achieved by performing a join on elements from A and B with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeLine">      // variables common to both A and B (join elements indexed by var</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1191</td>
    <td class="codeLine">      // variables common to both A and B (join elements indexed by var</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeLine">      // intersect), then adding ⊤-value elements for vars in A xor B. The</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1192</td>
    <td class="codeLine">      // intersect), then adding ⊤-value elements for vars in A xor B. The</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeLine">      // latter part is equivalent to performing join on elements with variables</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1193</td>
    <td class="codeLine">      // latter part is equivalent to performing join on elements with variables</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeLine">      // in A xor B with the ⊤-value for the map element since join(x, ⊤) = ⊤.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1194</td>
    <td class="codeLine">      // in A xor B with the ⊤-value for the map element since join(x, ⊤) = ⊤.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeLine">      // BlockInfo::init initializes all variable entries to the ⊤ value so we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1195</td>
    <td class="codeLine">      // BlockInfo::init initializes all variable entries to the ⊤ value so we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeLine">      // don't need to explicitly perform that step as Join.VariableIDsInBlock</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1196</td>
    <td class="codeLine">      // don't need to explicitly perform that step as Join.VariableIDsInBlock</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeLine">      // is set to the union of the variables in A and B at the end of this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1197</td>
    <td class="codeLine">      // is set to the union of the variables in A and B at the end of this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeLine">      // function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1198</td>
    <td class="codeLine">      // function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeLine">      BlockInfo Join;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1199</td>
    <td class="codeLine">      BlockInfo Join;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeLine">      Join.init(NumVars);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1200</td>
    <td class="codeLine">      Join.init(NumVars);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1201</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeLine">      BitVector Intersect = A.VariableIDsInBlock;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1202</td>
    <td class="codeLine">      BitVector Intersect = A.VariableIDsInBlock;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeLine">      Intersect &= B.VariableIDsInBlock;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1203</td>
    <td class="codeLine">      Intersect &= B.VariableIDsInBlock;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1204</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeLine">      for (auto VarID : Intersect.set_bits()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1205</td>
    <td class="codeLine">      for (auto VarID : Intersect.set_bits()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeLine">        joinElmt(VarID, Join.LiveLoc, A.LiveLoc, B.LiveLoc, joinKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1206</td>
    <td class="codeLine">        joinElmt(VarID, Join.LiveLoc, A.LiveLoc, B.LiveLoc, joinKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeLine">        joinElmt(VarID, Join.DebugValue, A.DebugValue, B.DebugValue,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1207</td>
    <td class="codeLine">        joinElmt(VarID, Join.DebugValue, A.DebugValue, B.DebugValue,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeLine">                 joinAssignment);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1208</td>
    <td class="codeLine">                 joinAssignment);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeLine">        joinElmt(VarID, Join.StackHomeValue, A.StackHomeValue, B.StackHomeValue,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1209</td>
    <td class="codeLine">        joinElmt(VarID, Join.StackHomeValue, A.StackHomeValue, B.StackHomeValue,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeLine">                 joinAssignment);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1210</td>
    <td class="codeLine">                 joinAssignment);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1211</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1212</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeLine">      Join.VariableIDsInBlock = A.VariableIDsInBlock;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1213</td>
    <td class="codeLine">      Join.VariableIDsInBlock = A.VariableIDsInBlock;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeLine">      Join.VariableIDsInBlock |= B.VariableIDsInBlock;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1214</td>
    <td class="codeLine">      Join.VariableIDsInBlock |= B.VariableIDsInBlock;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeLine">      assert(Join.isValid());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1215</td>
    <td class="codeLine">      assert(Join.isValid());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeLine">      return Join;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1216</td>
    <td class="codeLine">      return Join;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1217</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1218</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1219</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeLine">  Function &Fn;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1220</td>
    <td class="codeLine">  Function &Fn;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeLine">  const DataLayout &Layout;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1221</td>
    <td class="codeLine">  const DataLayout &Layout;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeLine">  const DenseSet<DebugAggregate> *VarsWithStackSlot;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1222</td>
    <td class="codeLine">  const DenseSet<DebugAggregate> *VarsWithStackSlot;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeLine">  FunctionVarLocsBuilder *FnVarLocs;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1223</td>
    <td class="codeLine">  FunctionVarLocsBuilder *FnVarLocs;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeLine">  DenseMap<const BasicBlock *, BlockInfo> LiveIn;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1224</td>
    <td class="codeLine">  DenseMap<const BasicBlock *, BlockInfo> LiveIn;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeLine">  DenseMap<const BasicBlock *, BlockInfo> LiveOut;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1225</td>
    <td class="codeLine">  DenseMap<const BasicBlock *, BlockInfo> LiveOut;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1226</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeLine">  /// Helper for process methods to track variables touched each frame.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1227</td>
    <td class="codeLine">  /// Helper for process methods to track variables touched each frame.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeLine">  DenseSet<VariableID> VarsTouchedThisFrame;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1228</td>
    <td class="codeLine">  DenseSet<VariableID> VarsTouchedThisFrame;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1229</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeLine">  /// The set of variables that sometimes are not located in their stack home.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1230</td>
    <td class="codeLine">  /// The set of variables that sometimes are not located in their stack home.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeLine">  DenseSet<DebugAggregate> NotAlwaysStackHomed;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1231</td>
    <td class="codeLine">  DenseSet<DebugAggregate> NotAlwaysStackHomed;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1232</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeLine">  VariableID getVariableID(const DebugVariable &Var) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1233</td>
    <td class="codeLine">  VariableID getVariableID(const DebugVariable &Var) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeLine">    return static_cast<VariableID>(FnVarLocs->insertVariable(Var));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1234</td>
    <td class="codeLine">    return static_cast<VariableID>(FnVarLocs->insertVariable(Var));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1235</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1236</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeLine">  /// Join the LiveOut values of preds that are contained in \p Visited into</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1237</td>
    <td class="codeLine">  /// Join the LiveOut values of preds that are contained in \p Visited into</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeLine">  /// LiveIn[BB]. Return True if LiveIn[BB] has changed as a result. LiveIn[BB]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1238</td>
    <td class="codeLine">  /// LiveIn[BB]. Return True if LiveIn[BB] has changed as a result. LiveIn[BB]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeLine">  /// values monotonically increase. See the @link joinMethods join methods</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1239</td>
    <td class="codeLine">  /// values monotonically increase. See the @link joinMethods join methods</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeLine">  /// @endlink documentation for more info.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1240</td>
    <td class="codeLine">  /// @endlink documentation for more info.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeLine">  bool join(const BasicBlock &BB, const SmallPtrSet<BasicBlock *, 16> &Visited);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1241</td>
    <td class="codeLine">  bool join(const BasicBlock &BB, const SmallPtrSet<BasicBlock *, 16> &Visited);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeLine">  ///@name joinMethods</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1242</td>
    <td class="codeLine">  ///@name joinMethods</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeLine">  /// Functions that implement `join` (the least upper bound) for the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1243</td>
    <td class="codeLine">  /// Functions that implement `join` (the least upper bound) for the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeLine">  /// join-semilattice types used in the dataflow. There is an explicit bottom</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1244</td>
    <td class="codeLine">  /// join-semilattice types used in the dataflow. There is an explicit bottom</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeLine">  /// value (⊥) for some types and and explicit top value (⊤) for all types.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1245</td>
    <td class="codeLine">  /// value (⊥) for some types and and explicit top value (⊤) for all types.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeLine">  /// By definition:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1246</td>
    <td class="codeLine">  /// By definition:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1247</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeLine">  ///     Join(A, B) >= A && Join(A, B) >= B</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1248</td>
    <td class="codeLine">  ///     Join(A, B) >= A && Join(A, B) >= B</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeLine">  ///     Join(A, ⊥) = A</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1249</td>
    <td class="codeLine">  ///     Join(A, ⊥) = A</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeLine">  ///     Join(A, ⊤) = ⊤</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1250</td>
    <td class="codeLine">  ///     Join(A, ⊤) = ⊤</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1251</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeLine">  /// These invariants are important for monotonicity.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1252</td>
    <td class="codeLine">  /// These invariants are important for monotonicity.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1253</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeLine">  /// For the map-type functions, all unmapped keys in an empty map are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1254</td>
    <td class="codeLine">  /// For the map-type functions, all unmapped keys in an empty map are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeLine">  /// associated with a bottom value (⊥). This represents their values being</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1255</td>
    <td class="codeLine">  /// associated with a bottom value (⊥). This represents their values being</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeLine">  /// unknown. Unmapped keys in non-empty maps (joining two maps with a key</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1256</td>
    <td class="codeLine">  /// unknown. Unmapped keys in non-empty maps (joining two maps with a key</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeLine">  /// only present in one) represents either a variable going out of scope or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1257</td>
    <td class="codeLine">  /// only present in one) represents either a variable going out of scope or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeLine">  /// dropped debug info. It is assumed the key is associated with a top value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1258</td>
    <td class="codeLine">  /// dropped debug info. It is assumed the key is associated with a top value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeLine">  /// (⊤) in this case (unknown location / assignment).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1259</td>
    <td class="codeLine">  /// (⊤) in this case (unknown location / assignment).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeLine">  ///@{</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1260</td>
    <td class="codeLine">  ///@{</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeLine">  static LocKind joinKind(LocKind A, LocKind B);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1261</td>
    <td class="codeLine">  static LocKind joinKind(LocKind A, LocKind B);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeLine">  static Assignment joinAssignment(const Assignment &A, const Assignment &B);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1262</td>
    <td class="codeLine">  static Assignment joinAssignment(const Assignment &A, const Assignment &B);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeLine">  BlockInfo joinBlockInfo(const BlockInfo &A, const BlockInfo &B);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1263</td>
    <td class="codeLine">  BlockInfo joinBlockInfo(const BlockInfo &A, const BlockInfo &B);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeLine">  ///@}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1264</td>
    <td class="codeLine">  ///@}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1265</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeLine">  /// Process the instructions in \p BB updating \p LiveSet along the way. \p</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1266</td>
    <td class="codeLine">  /// Process the instructions in \p BB updating \p LiveSet along the way. \p</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeLine">  /// LiveSet must be initialized with the current live-in locations before</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1267</td>
    <td class="codeLine">  /// LiveSet must be initialized with the current live-in locations before</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeLine">  /// calling this.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1268</td>
    <td class="codeLine">  /// calling this.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeLine">  void process(BasicBlock &BB, BlockInfo *LiveSet);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1269</td>
    <td class="codeLine">  void process(BasicBlock &BB, BlockInfo *LiveSet);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeLine">  ///@name processMethods</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1270</td>
    <td class="codeLine">  ///@name processMethods</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeLine">  /// Methods to process instructions in order to update the LiveSet (current</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1271</td>
    <td class="codeLine">  /// Methods to process instructions in order to update the LiveSet (current</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeLine">  /// location information).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1272</td>
    <td class="codeLine">  /// location information).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeLine">  ///@{</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1273</td>
    <td class="codeLine">  ///@{</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeLine">  void processNonDbgInstruction(Instruction &I, BlockInfo *LiveSet);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1274</td>
    <td class="codeLine">  void processNonDbgInstruction(Instruction &I, BlockInfo *LiveSet);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeLine">  void processDbgInstruction(DbgInfoIntrinsic &I, BlockInfo *LiveSet);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1275</td>
    <td class="codeLine">  void processDbgInstruction(DbgInfoIntrinsic &I, BlockInfo *LiveSet);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeLine">  /// Update \p LiveSet after encountering an instruction with a DIAssignID</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1276</td>
    <td class="codeLine">  /// Update \p LiveSet after encountering an instruction with a DIAssignID</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeLine">  /// attachment, \p I.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1277</td>
    <td class="codeLine">  /// attachment, \p I.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeLine">  void processTaggedInstruction(Instruction &I, BlockInfo *LiveSet);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1278</td>
    <td class="codeLine">  void processTaggedInstruction(Instruction &I, BlockInfo *LiveSet);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeLine">  /// Update \p LiveSet after encountering an instruciton without a DIAssignID</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1279</td>
    <td class="codeLine">  /// Update \p LiveSet after encountering an instruciton without a DIAssignID</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeLine">  /// attachment, \p I.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1280</td>
    <td class="codeLine">  /// attachment, \p I.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeLine">  void processUntaggedInstruction(Instruction &I, BlockInfo *LiveSet);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1281</td>
    <td class="codeLine">  void processUntaggedInstruction(Instruction &I, BlockInfo *LiveSet);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeLine">  void processDbgAssign(DbgAssignIntrinsic &DAI, BlockInfo *LiveSet);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1282</td>
    <td class="codeLine">  void processDbgAssign(DbgAssignIntrinsic &DAI, BlockInfo *LiveSet);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeLine">  void processDbgValue(DbgValueInst &DVI, BlockInfo *LiveSet);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1283</td>
    <td class="codeLine">  void processDbgValue(DbgValueInst &DVI, BlockInfo *LiveSet);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeLine">  /// Add an assignment to memory for the variable /p Var.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1284</td>
    <td class="codeLine">  /// Add an assignment to memory for the variable /p Var.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeLine">  void addMemDef(BlockInfo *LiveSet, VariableID Var, const Assignment &AV);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1285</td>
    <td class="codeLine">  void addMemDef(BlockInfo *LiveSet, VariableID Var, const Assignment &AV);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeLine">  /// Add an assignment to the variable /p Var.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1286</td>
    <td class="codeLine">  /// Add an assignment to the variable /p Var.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeLine">  void addDbgDef(BlockInfo *LiveSet, VariableID Var, const Assignment &AV);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1287</td>
    <td class="codeLine">  void addDbgDef(BlockInfo *LiveSet, VariableID Var, const Assignment &AV);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeLine">  ///@}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1288</td>
    <td class="codeLine">  ///@}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1289</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeLine">  /// Set the LocKind for \p Var.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1290</td>
    <td class="codeLine">  /// Set the LocKind for \p Var.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeLine">  void setLocKind(BlockInfo *LiveSet, VariableID Var, LocKind K);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1291</td>
    <td class="codeLine">  void setLocKind(BlockInfo *LiveSet, VariableID Var, LocKind K);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeLine">  /// Get the live LocKind for a \p Var. Requires addMemDef or addDbgDef to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1292</td>
    <td class="codeLine">  /// Get the live LocKind for a \p Var. Requires addMemDef or addDbgDef to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeLine">  /// have been called for \p Var first.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1293</td>
    <td class="codeLine">  /// have been called for \p Var first.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeLine">  LocKind getLocKind(BlockInfo *LiveSet, VariableID Var);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1294</td>
    <td class="codeLine">  LocKind getLocKind(BlockInfo *LiveSet, VariableID Var);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeLine">  /// Return true if \p Var has an assignment in \p M matching \p AV.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1295</td>
    <td class="codeLine">  /// Return true if \p Var has an assignment in \p M matching \p AV.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeLine">  bool hasVarWithAssignment(BlockInfo *LiveSet, BlockInfo::AssignmentKind Kind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1296</td>
    <td class="codeLine">  bool hasVarWithAssignment(BlockInfo *LiveSet, BlockInfo::AssignmentKind Kind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeLine">                            VariableID Var, const Assignment &AV);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1297</td>
    <td class="codeLine">                            VariableID Var, const Assignment &AV);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeLine">  /// Return the set of VariableIDs corresponding the fragments contained fully</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1298</td>
    <td class="codeLine">  /// Return the set of VariableIDs corresponding the fragments contained fully</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeLine">  /// within the variable/fragment \p Var.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1299</td>
    <td class="codeLine">  /// within the variable/fragment \p Var.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeLine">  ArrayRef<VariableID> getContainedFragments(VariableID Var) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1300</td>
    <td class="codeLine">  ArrayRef<VariableID> getContainedFragments(VariableID Var) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1301</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeLine">  /// Mark \p Var as having been touched this frame. Note, this applies only</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1302</td>
    <td class="codeLine">  /// Mark \p Var as having been touched this frame. Note, this applies only</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeLine">  /// to the exact fragment \p Var and not to any fragments contained within.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1303</td>
    <td class="codeLine">  /// to the exact fragment \p Var and not to any fragments contained within.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeLine">  void touchFragment(VariableID Var);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1304</td>
    <td class="codeLine">  void touchFragment(VariableID Var);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1305</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeLine">  /// Emit info for variables that are fully promoted.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1306</td>
    <td class="codeLine">  /// Emit info for variables that are fully promoted.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeLine">  bool emitPromotedVarLocs(FunctionVarLocsBuilder *FnVarLocs);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1307</td>
    <td class="codeLine">  bool emitPromotedVarLocs(FunctionVarLocsBuilder *FnVarLocs);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1308</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1309</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeLine">  AssignmentTrackingLowering(Function &Fn, const DataLayout &Layout,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1310</td>
    <td class="codeLine">  AssignmentTrackingLowering(Function &Fn, const DataLayout &Layout,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeLine">                             const DenseSet<DebugAggregate> *VarsWithStackSlot)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1311</td>
    <td class="codeLine">                             const DenseSet<DebugAggregate> *VarsWithStackSlot)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeLine">      : Fn(Fn), Layout(Layout), VarsWithStackSlot(VarsWithStackSlot) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1312</td>
    <td class="codeLine">      : Fn(Fn), Layout(Layout), VarsWithStackSlot(VarsWithStackSlot) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeLine">  /// Run the analysis, adding variable location info to \p FnVarLocs. Returns</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1313</td>
    <td class="codeLine">  /// Run the analysis, adding variable location info to \p FnVarLocs. Returns</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeLine">  /// true if any variable locations have been added to FnVarLocs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1314</td>
    <td class="codeLine">  /// true if any variable locations have been added to FnVarLocs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeLine">  bool run(FunctionVarLocsBuilder *FnVarLocs);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1315</td>
    <td class="codeLine">  bool run(FunctionVarLocsBuilder *FnVarLocs);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1316</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeLine">} // namespace</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1317</td>
    <td class="codeLine">} // namespace</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1318</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeLine">ArrayRef<VariableID></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1319</td>
    <td class="codeLine">ArrayRef<VariableID></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeLine">AssignmentTrackingLowering::getContainedFragments(VariableID Var) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1320</td>
    <td class="codeLine">AssignmentTrackingLowering::getContainedFragments(VariableID Var) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeLine">  auto R = VarContains.find(Var);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1321</td>
    <td class="codeLine">  auto R = VarContains.find(Var);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeLine">  if (R == VarContains.end())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1322</td>
    <td class="codeLine">  if (R == VarContains.end())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1323</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeLine">  return R->second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1324</td>
    <td class="codeLine">  return R->second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1325</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1326</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeLine">void AssignmentTrackingLowering::touchFragment(VariableID Var) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1327</td>
    <td class="codeLine">void AssignmentTrackingLowering::touchFragment(VariableID Var) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeLine">  VarsTouchedThisFrame.insert(Var);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1328</td>
    <td class="codeLine">  VarsTouchedThisFrame.insert(Var);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1329</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1330</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeLine">void AssignmentTrackingLowering::setLocKind(BlockInfo *LiveSet, VariableID Var,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1331</td>
    <td class="codeLine">void AssignmentTrackingLowering::setLocKind(BlockInfo *LiveSet, VariableID Var,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeLine">                                            LocKind K) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1332</td>
    <td class="codeLine">                                            LocKind K) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeLine">  auto SetKind = [this](BlockInfo *LiveSet, VariableID Var, LocKind K) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1333</td>
    <td class="codeLine">  auto SetKind = [this](BlockInfo *LiveSet, VariableID Var, LocKind K) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeLine">    LiveSet->setLocKind(Var, K);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1334</td>
    <td class="codeLine">    LiveSet->setLocKind(Var, K);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeLine">    touchFragment(Var);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1335</td>
    <td class="codeLine">    touchFragment(Var);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1336</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeLine">  SetKind(LiveSet, Var, K);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1337</td>
    <td class="codeLine">  SetKind(LiveSet, Var, K);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1338</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeLine">  // Update the LocKind for all fragments contained within Var.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1339</td>
    <td class="codeLine">  // Update the LocKind for all fragments contained within Var.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeLine">  for (VariableID Frag : getContainedFragments(Var))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1340</td>
    <td class="codeLine">  for (VariableID Frag : getContainedFragments(Var))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeLine">    SetKind(LiveSet, Frag, K);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1341</td>
    <td class="codeLine">    SetKind(LiveSet, Frag, K);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1342</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1343</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeLine">AssignmentTrackingLowering::LocKind</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1344</td>
    <td class="codeLine">AssignmentTrackingLowering::LocKind</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeLine">AssignmentTrackingLowering::getLocKind(BlockInfo *LiveSet, VariableID Var) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1345</td>
    <td class="codeLine">AssignmentTrackingLowering::getLocKind(BlockInfo *LiveSet, VariableID Var) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeLine">  return LiveSet->getLocKind(Var);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1346</td>
    <td class="codeLine">  return LiveSet->getLocKind(Var);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1347</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1348</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeLine">void AssignmentTrackingLowering::addMemDef(BlockInfo *LiveSet, VariableID Var,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1349</td>
    <td class="codeLine">void AssignmentTrackingLowering::addMemDef(BlockInfo *LiveSet, VariableID Var,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeLine">                                           const Assignment &AV) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1350</td>
    <td class="codeLine">                                           const Assignment &AV) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeLine">  LiveSet->setAssignment(BlockInfo::Stack, Var, AV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1351</td>
    <td class="codeLine">  LiveSet->setAssignment(BlockInfo::Stack, Var, AV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1352</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeLine">  // Use this assigment for all fragments contained within Var, but do not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1353</td>
    <td class="codeLine">  // Use this assigment for all fragments contained within Var, but do not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeLine">  // provide a Source because we cannot convert Var's value to a value for the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1354</td>
    <td class="codeLine">  // provide a Source because we cannot convert Var's value to a value for the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeLine">  // fragment.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1355</td>
    <td class="codeLine">  // fragment.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeLine">  Assignment FragAV = AV;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1356</td>
    <td class="codeLine">  Assignment FragAV = AV;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeLine">  FragAV.Source = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1357</td>
    <td class="codeLine">  FragAV.Source = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeLine">  for (VariableID Frag : getContainedFragments(Var))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1358</td>
    <td class="codeLine">  for (VariableID Frag : getContainedFragments(Var))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeLine">    LiveSet->setAssignment(BlockInfo::Stack, Frag, FragAV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1359</td>
    <td class="codeLine">    LiveSet->setAssignment(BlockInfo::Stack, Frag, FragAV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1360</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1361</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeLine">void AssignmentTrackingLowering::addDbgDef(BlockInfo *LiveSet, VariableID Var,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1362</td>
    <td class="codeLine">void AssignmentTrackingLowering::addDbgDef(BlockInfo *LiveSet, VariableID Var,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeLine">                                           const Assignment &AV) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1363</td>
    <td class="codeLine">                                           const Assignment &AV) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeLine">  LiveSet->setAssignment(BlockInfo::Debug, Var, AV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1364</td>
    <td class="codeLine">  LiveSet->setAssignment(BlockInfo::Debug, Var, AV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1365</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeLine">  // Use this assigment for all fragments contained within Var, but do not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1366</td>
    <td class="codeLine">  // Use this assigment for all fragments contained within Var, but do not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeLine">  // provide a Source because we cannot convert Var's value to a value for the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1367</td>
    <td class="codeLine">  // provide a Source because we cannot convert Var's value to a value for the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeLine">  // fragment.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1368</td>
    <td class="codeLine">  // fragment.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeLine">  Assignment FragAV = AV;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1369</td>
    <td class="codeLine">  Assignment FragAV = AV;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeLine">  FragAV.Source = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1370</td>
    <td class="codeLine">  FragAV.Source = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeLine">  for (VariableID Frag : getContainedFragments(Var))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1371</td>
    <td class="codeLine">  for (VariableID Frag : getContainedFragments(Var))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeLine">    LiveSet->setAssignment(BlockInfo::Debug, Frag, FragAV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1372</td>
    <td class="codeLine">    LiveSet->setAssignment(BlockInfo::Debug, Frag, FragAV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1373</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1374</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeLine">static DIAssignID *getIDFromInst(const Instruction &I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1375</td>
    <td class="codeLine">static DIAssignID *getIDFromInst(const Instruction &I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeLine">  return cast<DIAssignID>(I.getMetadata(LLVMContext::MD_DIAssignID));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1376</td>
    <td class="codeLine">  return cast<DIAssignID>(I.getMetadata(LLVMContext::MD_DIAssignID));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1377</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1378</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeLine">static DIAssignID *getIDFromMarker(const DbgAssignIntrinsic &DAI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1379</td>
    <td class="codeLine">static DIAssignID *getIDFromMarker(const DbgAssignIntrinsic &DAI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeLine">  return cast<DIAssignID>(DAI.getAssignID());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1380</td>
    <td class="codeLine">  return cast<DIAssignID>(DAI.getAssignID());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1381</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1382</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeLine">/// Return true if \p Var has an assignment in \p M matching \p AV.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1383</td>
    <td class="codeLine">/// Return true if \p Var has an assignment in \p M matching \p AV.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeLine">bool AssignmentTrackingLowering::hasVarWithAssignment(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1384</td>
    <td class="codeLine">bool AssignmentTrackingLowering::hasVarWithAssignment(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeLine">    BlockInfo *LiveSet, BlockInfo::AssignmentKind Kind, VariableID Var,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1385</td>
    <td class="codeLine">    BlockInfo *LiveSet, BlockInfo::AssignmentKind Kind, VariableID Var,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeLine">    const Assignment &AV) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1386</td>
    <td class="codeLine">    const Assignment &AV) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeLine">  if (!LiveSet->hasAssignment(Kind, Var, AV))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1387</td>
    <td class="codeLine">  if (!LiveSet->hasAssignment(Kind, Var, AV))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1388</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1389</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeLine">  // Check all the frags contained within Var as these will have all been</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1390</td>
    <td class="codeLine">  // Check all the frags contained within Var as these will have all been</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeLine">  // mapped to AV at the last store to Var.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1391</td>
    <td class="codeLine">  // mapped to AV at the last store to Var.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeLine">  for (VariableID Frag : getContainedFragments(Var))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1392</td>
    <td class="codeLine">  for (VariableID Frag : getContainedFragments(Var))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeLine">    if (!LiveSet->hasAssignment(Kind, Frag, AV))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1393</td>
    <td class="codeLine">    if (!LiveSet->hasAssignment(Kind, Frag, AV))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1394</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1395</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1396</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1397</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1398</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeLine">const char *locStr(AssignmentTrackingLowering::LocKind Loc) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1399</td>
    <td class="codeLine">const char *locStr(AssignmentTrackingLowering::LocKind Loc) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeLine">  using LocKind = AssignmentTrackingLowering::LocKind;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1400</td>
    <td class="codeLine">  using LocKind = AssignmentTrackingLowering::LocKind;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeLine">  switch (Loc) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1401</td>
    <td class="codeLine">  switch (Loc) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeLine">  case LocKind::Val:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1402</td>
    <td class="codeLine">  case LocKind::Val:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeLine">    return "Val";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1403</td>
    <td class="codeLine">    return "Val";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeLine">  case LocKind::Mem:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1404</td>
    <td class="codeLine">  case LocKind::Mem:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeLine">    return "Mem";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1405</td>
    <td class="codeLine">    return "Mem";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeLine">  case LocKind::None:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1406</td>
    <td class="codeLine">  case LocKind::None:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeLine">    return "None";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1407</td>
    <td class="codeLine">    return "None";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1408</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeLine">  llvm_unreachable("unknown LocKind");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1409</td>
    <td class="codeLine">  llvm_unreachable("unknown LocKind");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1410</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1411</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1412</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeLine">void AssignmentTrackingLowering::emitDbgValue(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1413</td>
    <td class="codeLine">void AssignmentTrackingLowering::emitDbgValue(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeLine">    AssignmentTrackingLowering::LocKind Kind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1414</td>
    <td class="codeLine">    AssignmentTrackingLowering::LocKind Kind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeLine">    const DbgVariableIntrinsic *Source, Instruction *After) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1415</td>
    <td class="codeLine">    const DbgVariableIntrinsic *Source, Instruction *After) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1416</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeLine">  DILocation *DL = Source->getDebugLoc();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1417</td>
    <td class="codeLine">  DILocation *DL = Source->getDebugLoc();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeLine">  auto Emit = [this, Source, After, DL](Metadata *Val, DIExpression *Expr) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1418</td>
    <td class="codeLine">  auto Emit = [this, Source, After, DL](Metadata *Val, DIExpression *Expr) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeLine">    assert(Expr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1419</td>
    <td class="codeLine">    assert(Expr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeLine">    if (!Val)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1420</td>
    <td class="codeLine">    if (!Val)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeLine">      Val = ValueAsMetadata::get(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1421</td>
    <td class="codeLine">      Val = ValueAsMetadata::get(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeLine">          PoisonValue::get(Type::getInt1Ty(Source->getContext())));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1422</td>
    <td class="codeLine">          PoisonValue::get(Type::getInt1Ty(Source->getContext())));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1423</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeLine">    // Find a suitable insert point.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1424</td>
    <td class="codeLine">    // Find a suitable insert point.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeLine">    Instruction *InsertBefore = After->getNextNode();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1425</td>
    <td class="codeLine">    Instruction *InsertBefore = After->getNextNode();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeLine">    assert(InsertBefore && "Shouldn't be inserting after a terminator");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1426</td>
    <td class="codeLine">    assert(InsertBefore && "Shouldn't be inserting after a terminator");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1427</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeLine">    VariableID Var = getVariableID(DebugVariable(Source));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1428</td>
    <td class="codeLine">    VariableID Var = getVariableID(DebugVariable(Source));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeLine">    VarLocInfo VarLoc;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1429</td>
    <td class="codeLine">    VarLocInfo VarLoc;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeLine">    VarLoc.VariableID = static_cast<VariableID>(Var);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1430</td>
    <td class="codeLine">    VarLoc.VariableID = static_cast<VariableID>(Var);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeLine">    VarLoc.Expr = Expr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1431</td>
    <td class="codeLine">    VarLoc.Expr = Expr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeLine">    VarLoc.Values = RawLocationWrapper(Val);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1432</td>
    <td class="codeLine">    VarLoc.Values = RawLocationWrapper(Val);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeLine">    VarLoc.DL = DL;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1433</td>
    <td class="codeLine">    VarLoc.DL = DL;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeLine">    // Insert it into the map for later.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1434</td>
    <td class="codeLine">    // Insert it into the map for later.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeLine">    InsertBeforeMap[InsertBefore].push_back(VarLoc);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1435</td>
    <td class="codeLine">    InsertBeforeMap[InsertBefore].push_back(VarLoc);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1436</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1437</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeLine">  // NOTE: This block can mutate Kind.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1438</td>
    <td class="codeLine">  // NOTE: This block can mutate Kind.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeLine">  if (Kind == LocKind::Mem) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1439</td>
    <td class="codeLine">  if (Kind == LocKind::Mem) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeLine">    const auto *DAI = cast<DbgAssignIntrinsic>(Source);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1440</td>
    <td class="codeLine">    const auto *DAI = cast<DbgAssignIntrinsic>(Source);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeLine">    // Check the address hasn't been dropped (e.g. the debug uses may not have</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1441</td>
    <td class="codeLine">    // Check the address hasn't been dropped (e.g. the debug uses may not have</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeLine">    // been replaced before deleting a Value).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1442</td>
    <td class="codeLine">    // been replaced before deleting a Value).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeLine">    if (DAI->isKillAddress()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1443</td>
    <td class="codeLine">    if (DAI->isKillAddress()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeLine">      // The address isn't valid so treat this as a non-memory def.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1444</td>
    <td class="codeLine">      // The address isn't valid so treat this as a non-memory def.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeLine">      Kind = LocKind::Val;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1445</td>
    <td class="codeLine">      Kind = LocKind::Val;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1446</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeLine">      Value *Val = DAI->getAddress();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1447</td>
    <td class="codeLine">      Value *Val = DAI->getAddress();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeLine">      DIExpression *Expr = DAI->getAddressExpression();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1448</td>
    <td class="codeLine">      DIExpression *Expr = DAI->getAddressExpression();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeLine">      assert(!Expr->getFragmentInfo() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1449</td>
    <td class="codeLine">      assert(!Expr->getFragmentInfo() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeLine">             "fragment info should be stored in value-expression only");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1450</td>
    <td class="codeLine">             "fragment info should be stored in value-expression only");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeLine">      // Copy the fragment info over from the value-expression to the new</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1451</td>
    <td class="codeLine">      // Copy the fragment info over from the value-expression to the new</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeLine">      // DIExpression.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1452</td>
    <td class="codeLine">      // DIExpression.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeLine">      if (auto OptFragInfo = Source->getExpression()->getFragmentInfo()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1453</td>
    <td class="codeLine">      if (auto OptFragInfo = Source->getExpression()->getFragmentInfo()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeLine">        auto FragInfo = *OptFragInfo;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1454</td>
    <td class="codeLine">        auto FragInfo = *OptFragInfo;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeLine">        Expr = *DIExpression::createFragmentExpression(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1455</td>
    <td class="codeLine">        Expr = *DIExpression::createFragmentExpression(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeLine">            Expr, FragInfo.OffsetInBits, FragInfo.SizeInBits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1456</td>
    <td class="codeLine">            Expr, FragInfo.OffsetInBits, FragInfo.SizeInBits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1457</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeLine">      // The address-expression has an implicit deref, add it now.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1458</td>
    <td class="codeLine">      // The address-expression has an implicit deref, add it now.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeLine">      std::tie(Val, Expr) =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1459</td>
    <td class="codeLine">      std::tie(Val, Expr) =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeLine">          walkToAllocaAndPrependOffsetDeref(Layout, Val, Expr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1460</td>
    <td class="codeLine">          walkToAllocaAndPrependOffsetDeref(Layout, Val, Expr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeLine">      Emit(ValueAsMetadata::get(Val), Expr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1461</td>
    <td class="codeLine">      Emit(ValueAsMetadata::get(Val), Expr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1462</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1463</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1464</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1465</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeLine">  if (Kind == LocKind::Val) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1466</td>
    <td class="codeLine">  if (Kind == LocKind::Val) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeLine">    Emit(Source->getRawLocation(), Source->getExpression());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1467</td>
    <td class="codeLine">    Emit(Source->getRawLocation(), Source->getExpression());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1468</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1469</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1470</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeLine">  if (Kind == LocKind::None) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1471</td>
    <td class="codeLine">  if (Kind == LocKind::None) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeLine">    Emit(nullptr, Source->getExpression());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1472</td>
    <td class="codeLine">    Emit(nullptr, Source->getExpression());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1473</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1474</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1475</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1476</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeLine">void AssignmentTrackingLowering::processNonDbgInstruction(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1477</td>
    <td class="codeLine">void AssignmentTrackingLowering::processNonDbgInstruction(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeLine">    Instruction &I, AssignmentTrackingLowering::BlockInfo *LiveSet) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1478</td>
    <td class="codeLine">    Instruction &I, AssignmentTrackingLowering::BlockInfo *LiveSet) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeLine">  if (I.hasMetadata(LLVMContext::MD_DIAssignID))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1479</td>
    <td class="codeLine">  if (I.hasMetadata(LLVMContext::MD_DIAssignID))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeLine">    processTaggedInstruction(I, LiveSet);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1480</td>
    <td class="codeLine">    processTaggedInstruction(I, LiveSet);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1481</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeLine">    processUntaggedInstruction(I, LiveSet);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1482</td>
    <td class="codeLine">    processUntaggedInstruction(I, LiveSet);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1483</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1484</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeLine">void AssignmentTrackingLowering::processUntaggedInstruction(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1485</td>
    <td class="codeLine">void AssignmentTrackingLowering::processUntaggedInstruction(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeLine">    Instruction &I, AssignmentTrackingLowering::BlockInfo *LiveSet) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1486</td>
    <td class="codeLine">    Instruction &I, AssignmentTrackingLowering::BlockInfo *LiveSet) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeLine">  // Interpret stack stores that are not tagged as an assignment in memory for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1487</td>
    <td class="codeLine">  // Interpret stack stores that are not tagged as an assignment in memory for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeLine">  // the variables associated with that address. These stores may not be tagged</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1488</td>
    <td class="codeLine">  // the variables associated with that address. These stores may not be tagged</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeLine">  // because a) the store cannot be represented using dbg.assigns (non-const</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1489</td>
    <td class="codeLine">  // because a) the store cannot be represented using dbg.assigns (non-const</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeLine">  // length or offset) or b) the tag was accidentally dropped during</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1490</td>
    <td class="codeLine">  // length or offset) or b) the tag was accidentally dropped during</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeLine">  // optimisations. For these stores we fall back to assuming that the stack</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1491</td>
    <td class="codeLine">  // optimisations. For these stores we fall back to assuming that the stack</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeLine">  // home is a valid location for the variables. The benefit is that this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1492</td>
    <td class="codeLine">  // home is a valid location for the variables. The benefit is that this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeLine">  // prevents us missing an assignment and therefore incorrectly maintaining</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1493</td>
    <td class="codeLine">  // prevents us missing an assignment and therefore incorrectly maintaining</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeLine">  // earlier location definitions, and in many cases it should be a reasonable</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1494</td>
    <td class="codeLine">  // earlier location definitions, and in many cases it should be a reasonable</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeLine">  // assumption. However, this will occasionally lead to slight</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1495</td>
    <td class="codeLine">  // assumption. However, this will occasionally lead to slight</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeLine">  // inaccuracies. The value of a hoisted untagged store will be visible</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1496</td>
    <td class="codeLine">  // inaccuracies. The value of a hoisted untagged store will be visible</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeLine">  // "early", for example.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1497</td>
    <td class="codeLine">  // "early", for example.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeLine">  assert(!I.hasMetadata(LLVMContext::MD_DIAssignID));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1498</td>
    <td class="codeLine">  assert(!I.hasMetadata(LLVMContext::MD_DIAssignID));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeLine">  auto It = UntaggedStoreVars.find(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1499</td>
    <td class="codeLine">  auto It = UntaggedStoreVars.find(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeLine">  if (It == UntaggedStoreVars.end())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1500</td>
    <td class="codeLine">  if (It == UntaggedStoreVars.end())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeLine">    return; // No variables associated with the store destination.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1501</td>
    <td class="codeLine">    return; // No variables associated with the store destination.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1502</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "processUntaggedInstruction on UNTAGGED INST " << I</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1503</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "processUntaggedInstruction on UNTAGGED INST " << I</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeLine">                    << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1504</td>
    <td class="codeLine">                    << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeLine">  // Iterate over the variables that this store affects, add a NoneOrPhi dbg</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1505</td>
    <td class="codeLine">  // Iterate over the variables that this store affects, add a NoneOrPhi dbg</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeLine">  // and mem def, set lockind to Mem, and emit a location def for each.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1506</td>
    <td class="codeLine">  // and mem def, set lockind to Mem, and emit a location def for each.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeLine">  for (auto [Var, Info] : It->second) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1507</td>
    <td class="codeLine">  for (auto [Var, Info] : It->second) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeLine">    // This instruction is treated as both a debug and memory assignment,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1508</td>
    <td class="codeLine">    // This instruction is treated as both a debug and memory assignment,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeLine">    // meaning the memory location should be used. We don't have an assignment</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1509</td>
    <td class="codeLine">    // meaning the memory location should be used. We don't have an assignment</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeLine">    // ID though so use Assignment::makeNoneOrPhi() to create an imaginary one.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1510</td>
    <td class="codeLine">    // ID though so use Assignment::makeNoneOrPhi() to create an imaginary one.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeLine">    addMemDef(LiveSet, Var, Assignment::makeNoneOrPhi());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1511</td>
    <td class="codeLine">    addMemDef(LiveSet, Var, Assignment::makeNoneOrPhi());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeLine">    addDbgDef(LiveSet, Var, Assignment::makeNoneOrPhi());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1512</td>
    <td class="codeLine">    addDbgDef(LiveSet, Var, Assignment::makeNoneOrPhi());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeLine">    setLocKind(LiveSet, Var, LocKind::Mem);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1513</td>
    <td class="codeLine">    setLocKind(LiveSet, Var, LocKind::Mem);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "  setting Stack LocKind to: " << locStr(LocKind::Mem)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1514</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "  setting Stack LocKind to: " << locStr(LocKind::Mem)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeLine">                      << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1515</td>
    <td class="codeLine">                      << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeLine">    // Build the dbg location def to insert.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1516</td>
    <td class="codeLine">    // Build the dbg location def to insert.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1517</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeLine">    // DIExpression: Add fragment and offset.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1518</td>
    <td class="codeLine">    // DIExpression: Add fragment and offset.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeLine">    DebugVariable V = FnVarLocs->getVariable(Var);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1519</td>
    <td class="codeLine">    DebugVariable V = FnVarLocs->getVariable(Var);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeLine">    DIExpression *DIE = DIExpression::get(I.getContext(), std::nullopt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1520</td>
    <td class="codeLine">    DIExpression *DIE = DIExpression::get(I.getContext(), std::nullopt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeLine">    if (auto Frag = V.getFragment()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1521</td>
    <td class="codeLine">    if (auto Frag = V.getFragment()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeLine">      auto R = DIExpression::createFragmentExpression(DIE, Frag->OffsetInBits,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1522</td>
    <td class="codeLine">      auto R = DIExpression::createFragmentExpression(DIE, Frag->OffsetInBits,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeLine">                                                      Frag->SizeInBits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1523</td>
    <td class="codeLine">                                                      Frag->SizeInBits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeLine">      assert(R && "unexpected createFragmentExpression failure");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1524</td>
    <td class="codeLine">      assert(R && "unexpected createFragmentExpression failure");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeLine">      DIE = *R;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1525</td>
    <td class="codeLine">      DIE = *R;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1526</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeLine">    SmallVector<uint64_t, 3> Ops;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1527</td>
    <td class="codeLine">    SmallVector<uint64_t, 3> Ops;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeLine">    if (Info.OffsetInBits)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1528</td>
    <td class="codeLine">    if (Info.OffsetInBits)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeLine">      Ops = {dwarf::DW_OP_plus_uconst, Info.OffsetInBits / 8};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1529</td>
    <td class="codeLine">      Ops = {dwarf::DW_OP_plus_uconst, Info.OffsetInBits / 8};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeLine">    Ops.push_back(dwarf::DW_OP_deref);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1530</td>
    <td class="codeLine">    Ops.push_back(dwarf::DW_OP_deref);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeLine">    DIE = DIExpression::prependOpcodes(DIE, Ops, /*StackValue=*/false,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1531</td>
    <td class="codeLine">    DIE = DIExpression::prependOpcodes(DIE, Ops, /*StackValue=*/false,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeLine">                                       /*EntryValue=*/false);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1532</td>
    <td class="codeLine">                                       /*EntryValue=*/false);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeLine">    // Find a suitable insert point.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1533</td>
    <td class="codeLine">    // Find a suitable insert point.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeLine">    Instruction *InsertBefore = I.getNextNode();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1534</td>
    <td class="codeLine">    Instruction *InsertBefore = I.getNextNode();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeLine">    assert(InsertBefore && "Shouldn't be inserting after a terminator");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1535</td>
    <td class="codeLine">    assert(InsertBefore && "Shouldn't be inserting after a terminator");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1536</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeLine">    // Get DILocation for this unrecorded assignment.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1537</td>
    <td class="codeLine">    // Get DILocation for this unrecorded assignment.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeLine">    DILocation *InlinedAt = const_cast<DILocation *>(V.getInlinedAt());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1538</td>
    <td class="codeLine">    DILocation *InlinedAt = const_cast<DILocation *>(V.getInlinedAt());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeLine">    const DILocation *DILoc = DILocation::get(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1539</td>
    <td class="codeLine">    const DILocation *DILoc = DILocation::get(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeLine">        Fn.getContext(), 0, 0, V.getVariable()->getScope(), InlinedAt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1540</td>
    <td class="codeLine">        Fn.getContext(), 0, 0, V.getVariable()->getScope(), InlinedAt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1541</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeLine">    VarLocInfo VarLoc;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1542</td>
    <td class="codeLine">    VarLocInfo VarLoc;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeLine">    VarLoc.VariableID = static_cast<VariableID>(Var);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1543</td>
    <td class="codeLine">    VarLoc.VariableID = static_cast<VariableID>(Var);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeLine">    VarLoc.Expr = DIE;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1544</td>
    <td class="codeLine">    VarLoc.Expr = DIE;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeLine">    VarLoc.Values = RawLocationWrapper(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1545</td>
    <td class="codeLine">    VarLoc.Values = RawLocationWrapper(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeLine">        ValueAsMetadata::get(const_cast<AllocaInst *>(Info.Base)));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1546</td>
    <td class="codeLine">        ValueAsMetadata::get(const_cast<AllocaInst *>(Info.Base)));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeLine">    VarLoc.DL = DILoc;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1547</td>
    <td class="codeLine">    VarLoc.DL = DILoc;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeLine">    // 3. Insert it into the map for later.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1548</td>
    <td class="codeLine">    // 3. Insert it into the map for later.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeLine">    InsertBeforeMap[InsertBefore].push_back(VarLoc);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1549</td>
    <td class="codeLine">    InsertBeforeMap[InsertBefore].push_back(VarLoc);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1550</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1551</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1552</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeLine">void AssignmentTrackingLowering::processTaggedInstruction(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1553</td>
    <td class="codeLine">void AssignmentTrackingLowering::processTaggedInstruction(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeLine">    Instruction &I, AssignmentTrackingLowering::BlockInfo *LiveSet) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1554</td>
    <td class="codeLine">    Instruction &I, AssignmentTrackingLowering::BlockInfo *LiveSet) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeLine">  auto Linked = at::getAssignmentMarkers(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1555</td>
    <td class="codeLine">  auto Linked = at::getAssignmentMarkers(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeLine">  // No dbg.assign intrinsics linked.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1556</td>
    <td class="codeLine">  // No dbg.assign intrinsics linked.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeLine">  // FIXME: All vars that have a stack slot this store modifies that don't have</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1557</td>
    <td class="codeLine">  // FIXME: All vars that have a stack slot this store modifies that don't have</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeLine">  // a dbg.assign linked to it should probably treat this like an untagged</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1558</td>
    <td class="codeLine">  // a dbg.assign linked to it should probably treat this like an untagged</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeLine">  // store.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1559</td>
    <td class="codeLine">  // store.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeLine">  if (Linked.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1560</td>
    <td class="codeLine">  if (Linked.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1561</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1562</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "processTaggedInstruction on " << I << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1563</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "processTaggedInstruction on " << I << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeLine">  for (DbgAssignIntrinsic *DAI : Linked) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1564</td>
    <td class="codeLine">  for (DbgAssignIntrinsic *DAI : Linked) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeLine">    VariableID Var = getVariableID(DebugVariable(DAI));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1565</td>
    <td class="codeLine">    VariableID Var = getVariableID(DebugVariable(DAI));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeLine">    // Something has gone wrong if VarsWithStackSlot doesn't contain a variable</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1566</td>
    <td class="codeLine">    // Something has gone wrong if VarsWithStackSlot doesn't contain a variable</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeLine">    // that is linked to a store.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1567</td>
    <td class="codeLine">    // that is linked to a store.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeLine">    assert(VarsWithStackSlot->count(getAggregate(DAI)) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1568</td>
    <td class="codeLine">    assert(VarsWithStackSlot->count(getAggregate(DAI)) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeLine">           "expected DAI's variable to have stack slot");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1569</td>
    <td class="codeLine">           "expected DAI's variable to have stack slot");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1570</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeLine">    Assignment AV = Assignment::makeFromMemDef(getIDFromInst(I));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1571</td>
    <td class="codeLine">    Assignment AV = Assignment::makeFromMemDef(getIDFromInst(I));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeLine">    addMemDef(LiveSet, Var, AV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1572</td>
    <td class="codeLine">    addMemDef(LiveSet, Var, AV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1573</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "   linked to " << *DAI << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1574</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "   linked to " << *DAI << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "   LiveLoc " << locStr(getLocKind(LiveSet, Var))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1575</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "   LiveLoc " << locStr(getLocKind(LiveSet, Var))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeLine">                      << " -> ");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1576</td>
    <td class="codeLine">                      << " -> ");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1577</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeLine">    // The last assignment to the stack is now AV. Check if the last debug</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1578</td>
    <td class="codeLine">    // The last assignment to the stack is now AV. Check if the last debug</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeLine">    // assignment has a matching Assignment.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1579</td>
    <td class="codeLine">    // assignment has a matching Assignment.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeLine">    if (hasVarWithAssignment(LiveSet, BlockInfo::Debug, Var, AV)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1580</td>
    <td class="codeLine">    if (hasVarWithAssignment(LiveSet, BlockInfo::Debug, Var, AV)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeLine">      // The StackHomeValue and DebugValue for this variable match so we can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1581</td>
    <td class="codeLine">      // The StackHomeValue and DebugValue for this variable match so we can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeLine">      // emit a stack home location here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1582</td>
    <td class="codeLine">      // emit a stack home location here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "Mem, Stack matches Debug program\n";);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1583</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "Mem, Stack matches Debug program\n";);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "   Stack val: "; AV.dump(dbgs()); dbgs() << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1584</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "   Stack val: "; AV.dump(dbgs()); dbgs() << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "   Debug val: ";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1585</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "   Debug val: ";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeLine">                 LiveSet->DebugValue[static_cast<unsigned>(Var)].dump(dbgs());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1586</td>
    <td class="codeLine">                 LiveSet->DebugValue[static_cast<unsigned>(Var)].dump(dbgs());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeLine">                 dbgs() << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1587</td>
    <td class="codeLine">                 dbgs() << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeLine">      setLocKind(LiveSet, Var, LocKind::Mem);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1588</td>
    <td class="codeLine">      setLocKind(LiveSet, Var, LocKind::Mem);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeLine">      emitDbgValue(LocKind::Mem, DAI, &I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1589</td>
    <td class="codeLine">      emitDbgValue(LocKind::Mem, DAI, &I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1590</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1591</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1592</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeLine">    // The StackHomeValue and DebugValue for this variable do not match. I.e.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1593</td>
    <td class="codeLine">    // The StackHomeValue and DebugValue for this variable do not match. I.e.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeLine">    // The value currently stored in the stack is not what we'd expect to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1594</td>
    <td class="codeLine">    // The value currently stored in the stack is not what we'd expect to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeLine">    // see, so we cannot use emit a stack home location here. Now we will</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1595</td>
    <td class="codeLine">    // see, so we cannot use emit a stack home location here. Now we will</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeLine">    // look at the live LocKind for the variable and determine an appropriate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1596</td>
    <td class="codeLine">    // look at the live LocKind for the variable and determine an appropriate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeLine">    // dbg.value to emit.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1597</td>
    <td class="codeLine">    // dbg.value to emit.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeLine">    LocKind PrevLoc = getLocKind(LiveSet, Var);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1598</td>
    <td class="codeLine">    LocKind PrevLoc = getLocKind(LiveSet, Var);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeLine">    switch (PrevLoc) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1599</td>
    <td class="codeLine">    switch (PrevLoc) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeLine">    case LocKind::Val: {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1600</td>
    <td class="codeLine">    case LocKind::Val: {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeLine">      // The value in memory in memory has changed but we're not currently</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1601</td>
    <td class="codeLine">      // The value in memory in memory has changed but we're not currently</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeLine">      // using the memory location. Do nothing.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1602</td>
    <td class="codeLine">      // using the memory location. Do nothing.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "Val, (unchanged)\n";);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1603</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "Val, (unchanged)\n";);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeLine">      setLocKind(LiveSet, Var, LocKind::Val);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1604</td>
    <td class="codeLine">      setLocKind(LiveSet, Var, LocKind::Val);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeLine">    } break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1605</td>
    <td class="codeLine">    } break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeLine">    case LocKind::Mem: {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1606</td>
    <td class="codeLine">    case LocKind::Mem: {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeLine">      // There's been an assignment to memory that we were using as a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1607</td>
    <td class="codeLine">      // There's been an assignment to memory that we were using as a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeLine">      // location for this variable, and the Assignment doesn't match what</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1608</td>
    <td class="codeLine">      // location for this variable, and the Assignment doesn't match what</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeLine">      // we'd expect to see in memory.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1609</td>
    <td class="codeLine">      // we'd expect to see in memory.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeLine">      Assignment DbgAV = LiveSet->getAssignment(BlockInfo::Debug, Var);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1610</td>
    <td class="codeLine">      Assignment DbgAV = LiveSet->getAssignment(BlockInfo::Debug, Var);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeLine">      if (DbgAV.Status == Assignment::NoneOrPhi) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1611</td>
    <td class="codeLine">      if (DbgAV.Status == Assignment::NoneOrPhi) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeLine">        // We need to terminate any previously open location now.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1612</td>
    <td class="codeLine">        // We need to terminate any previously open location now.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "None, No Debug value available\n";);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1613</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "None, No Debug value available\n";);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeLine">        setLocKind(LiveSet, Var, LocKind::None);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1614</td>
    <td class="codeLine">        setLocKind(LiveSet, Var, LocKind::None);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeLine">        emitDbgValue(LocKind::None, DAI, &I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1615</td>
    <td class="codeLine">        emitDbgValue(LocKind::None, DAI, &I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1616</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeLine">        // The previous DebugValue Value can be used here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1617</td>
    <td class="codeLine">        // The previous DebugValue Value can be used here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "Val, Debug value is Known\n";);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1618</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "Val, Debug value is Known\n";);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeLine">        setLocKind(LiveSet, Var, LocKind::Val);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1619</td>
    <td class="codeLine">        setLocKind(LiveSet, Var, LocKind::Val);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeLine">        if (DbgAV.Source) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1620</td>
    <td class="codeLine">        if (DbgAV.Source) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeLine">          emitDbgValue(LocKind::Val, DbgAV.Source, &I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1621</td>
    <td class="codeLine">          emitDbgValue(LocKind::Val, DbgAV.Source, &I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeLine">        } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1622</td>
    <td class="codeLine">        } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeLine">          // PrevAV.Source is nullptr so we must emit undef here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1623</td>
    <td class="codeLine">          // PrevAV.Source is nullptr so we must emit undef here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeLine">          emitDbgValue(LocKind::None, DAI, &I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1624</td>
    <td class="codeLine">          emitDbgValue(LocKind::None, DAI, &I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1625</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1626</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeLine">    } break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1627</td>
    <td class="codeLine">    } break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeLine">    case LocKind::None: {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1628</td>
    <td class="codeLine">    case LocKind::None: {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeLine">      // There's been an assignment to memory and we currently are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1629</td>
    <td class="codeLine">      // There's been an assignment to memory and we currently are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeLine">      // not tracking a location for the variable. Do not emit anything.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1630</td>
    <td class="codeLine">      // not tracking a location for the variable. Do not emit anything.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "None, (unchanged)\n";);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1631</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "None, (unchanged)\n";);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeLine">      setLocKind(LiveSet, Var, LocKind::None);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1632</td>
    <td class="codeLine">      setLocKind(LiveSet, Var, LocKind::None);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeLine">    } break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1633</td>
    <td class="codeLine">    } break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1634</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1635</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1636</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1637</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeLine">void AssignmentTrackingLowering::processDbgAssign(DbgAssignIntrinsic &DAI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1638</td>
    <td class="codeLine">void AssignmentTrackingLowering::processDbgAssign(DbgAssignIntrinsic &DAI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeLine">                                                  BlockInfo *LiveSet) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1639</td>
    <td class="codeLine">                                                  BlockInfo *LiveSet) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeLine">  // Only bother tracking variables that are at some point stack homed. Other</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1640</td>
    <td class="codeLine">  // Only bother tracking variables that are at some point stack homed. Other</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeLine">  // variables can be dealt with trivially later.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1641</td>
    <td class="codeLine">  // variables can be dealt with trivially later.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeLine">  if (!VarsWithStackSlot->count(getAggregate(&DAI)))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1642</td>
    <td class="codeLine">  if (!VarsWithStackSlot->count(getAggregate(&DAI)))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1643</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1644</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeLine">  VariableID Var = getVariableID(DebugVariable(&DAI));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1645</td>
    <td class="codeLine">  VariableID Var = getVariableID(DebugVariable(&DAI));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeLine">  Assignment AV = Assignment::make(getIDFromMarker(DAI), &DAI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1646</td>
    <td class="codeLine">  Assignment AV = Assignment::make(getIDFromMarker(DAI), &DAI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeLine">  addDbgDef(LiveSet, Var, AV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1647</td>
    <td class="codeLine">  addDbgDef(LiveSet, Var, AV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1648</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "processDbgAssign on " << DAI << "\n";);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1649</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "processDbgAssign on " << DAI << "\n";);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "   LiveLoc " << locStr(getLocKind(LiveSet, Var))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1650</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "   LiveLoc " << locStr(getLocKind(LiveSet, Var))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeLine">                    << " -> ");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1651</td>
    <td class="codeLine">                    << " -> ");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1652</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeLine">  // Check if the DebugValue and StackHomeValue both hold the same</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1653</td>
    <td class="codeLine">  // Check if the DebugValue and StackHomeValue both hold the same</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeLine">  // Assignment.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1654</td>
    <td class="codeLine">  // Assignment.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeLine">  if (hasVarWithAssignment(LiveSet, BlockInfo::Stack, Var, AV)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1655</td>
    <td class="codeLine">  if (hasVarWithAssignment(LiveSet, BlockInfo::Stack, Var, AV)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeLine">    // They match. We can use the stack home because the debug intrinsics state</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1656</td>
    <td class="codeLine">    // They match. We can use the stack home because the debug intrinsics state</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeLine">    // that an assignment happened here, and we know that specific assignment</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1657</td>
    <td class="codeLine">    // that an assignment happened here, and we know that specific assignment</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeLine">    // was the last one to take place in memory for this variable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1658</td>
    <td class="codeLine">    // was the last one to take place in memory for this variable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeLine">    LocKind Kind;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1659</td>
    <td class="codeLine">    LocKind Kind;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeLine">    if (DAI.isKillAddress()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1660</td>
    <td class="codeLine">    if (DAI.isKillAddress()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeLine">      LLVM_DEBUG(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1661</td>
    <td class="codeLine">      LLVM_DEBUG(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeLine">          dbgs()</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1662</td>
    <td class="codeLine">          dbgs()</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeLine">              << "Val, Stack matches Debug program but address is killed\n";);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1663</td>
    <td class="codeLine">              << "Val, Stack matches Debug program but address is killed\n";);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeLine">      Kind = LocKind::Val;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1664</td>
    <td class="codeLine">      Kind = LocKind::Val;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1665</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "Mem, Stack matches Debug program\n";);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1666</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "Mem, Stack matches Debug program\n";);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeLine">      Kind = LocKind::Mem;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1667</td>
    <td class="codeLine">      Kind = LocKind::Mem;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1668</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeLine">    setLocKind(LiveSet, Var, Kind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1669</td>
    <td class="codeLine">    setLocKind(LiveSet, Var, Kind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeLine">    emitDbgValue(Kind, &DAI, &DAI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1670</td>
    <td class="codeLine">    emitDbgValue(Kind, &DAI, &DAI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1671</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeLine">    // The last assignment to the memory location isn't the one that we want to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1672</td>
    <td class="codeLine">    // The last assignment to the memory location isn't the one that we want to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeLine">    // show to the user so emit a dbg.value(Value). Value may be undef.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1673</td>
    <td class="codeLine">    // show to the user so emit a dbg.value(Value). Value may be undef.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Val, Stack contents is unknown\n";);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1674</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Val, Stack contents is unknown\n";);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeLine">    setLocKind(LiveSet, Var, LocKind::Val);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1675</td>
    <td class="codeLine">    setLocKind(LiveSet, Var, LocKind::Val);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeLine">    emitDbgValue(LocKind::Val, &DAI, &DAI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1676</td>
    <td class="codeLine">    emitDbgValue(LocKind::Val, &DAI, &DAI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1677</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1678</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1679</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeLine">void AssignmentTrackingLowering::processDbgValue(DbgValueInst &DVI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1680</td>
    <td class="codeLine">void AssignmentTrackingLowering::processDbgValue(DbgValueInst &DVI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeLine">                                                 BlockInfo *LiveSet) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1681</td>
    <td class="codeLine">                                                 BlockInfo *LiveSet) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeLine">  // Only other tracking variables that are at some point stack homed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1682</td>
    <td class="codeLine">  // Only other tracking variables that are at some point stack homed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeLine">  // Other variables can be dealt with trivally later.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1683</td>
    <td class="codeLine">  // Other variables can be dealt with trivally later.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeLine">  if (!VarsWithStackSlot->count(getAggregate(&DVI)))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1684</td>
    <td class="codeLine">  if (!VarsWithStackSlot->count(getAggregate(&DVI)))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1685</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1686</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeLine">  VariableID Var = getVariableID(DebugVariable(&DVI));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1687</td>
    <td class="codeLine">  VariableID Var = getVariableID(DebugVariable(&DVI));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeLine">  // We have no ID to create an Assignment with so we mark this assignment as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1688</td>
    <td class="codeLine">  // We have no ID to create an Assignment with so we mark this assignment as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeLine">  // NoneOrPhi. Note that the dbg.value still exists, we just cannot determine</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1689</td>
    <td class="codeLine">  // NoneOrPhi. Note that the dbg.value still exists, we just cannot determine</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeLine">  // the assignment responsible for setting this value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1690</td>
    <td class="codeLine">  // the assignment responsible for setting this value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeLine">  // This is fine; dbg.values are essentially interchangable with unlinked</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1691</td>
    <td class="codeLine">  // This is fine; dbg.values are essentially interchangable with unlinked</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeLine">  // dbg.assigns, and some passes such as mem2reg and instcombine add them to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1692</td>
    <td class="codeLine">  // dbg.assigns, and some passes such as mem2reg and instcombine add them to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeLine">  // PHIs for promoted variables.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1693</td>
    <td class="codeLine">  // PHIs for promoted variables.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeLine">  Assignment AV = Assignment::makeNoneOrPhi();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1694</td>
    <td class="codeLine">  Assignment AV = Assignment::makeNoneOrPhi();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeLine">  addDbgDef(LiveSet, Var, AV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1695</td>
    <td class="codeLine">  addDbgDef(LiveSet, Var, AV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1696</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "processDbgValue on " << DVI << "\n";);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1697</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "processDbgValue on " << DVI << "\n";);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "   LiveLoc " << locStr(getLocKind(LiveSet, Var))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1698</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "   LiveLoc " << locStr(getLocKind(LiveSet, Var))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeLine">                    << " -> Val, dbg.value override");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1699</td>
    <td class="codeLine">                    << " -> Val, dbg.value override");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1700</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeLine">  setLocKind(LiveSet, Var, LocKind::Val);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1701</td>
    <td class="codeLine">  setLocKind(LiveSet, Var, LocKind::Val);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeLine">  emitDbgValue(LocKind::Val, &DVI, &DVI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1702</td>
    <td class="codeLine">  emitDbgValue(LocKind::Val, &DVI, &DVI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1703</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1704</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeLine">static bool hasZeroSizedFragment(DbgVariableIntrinsic &DVI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1705</td>
    <td class="codeLine">static bool hasZeroSizedFragment(DbgVariableIntrinsic &DVI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeLine">  if (auto F = DVI.getExpression()->getFragmentInfo())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1706</td>
    <td class="codeLine">  if (auto F = DVI.getExpression()->getFragmentInfo())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeLine">    return F->SizeInBits == 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1707</td>
    <td class="codeLine">    return F->SizeInBits == 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1708</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1709</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1710</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeLine">void AssignmentTrackingLowering::processDbgInstruction(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1711</td>
    <td class="codeLine">void AssignmentTrackingLowering::processDbgInstruction(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeLine">    DbgInfoIntrinsic &I, AssignmentTrackingLowering::BlockInfo *LiveSet) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1712</td>
    <td class="codeLine">    DbgInfoIntrinsic &I, AssignmentTrackingLowering::BlockInfo *LiveSet) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeLine">  auto *DVI = dyn_cast<DbgVariableIntrinsic>(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1713</td>
    <td class="codeLine">  auto *DVI = dyn_cast<DbgVariableIntrinsic>(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeLine">  if (!DVI)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1714</td>
    <td class="codeLine">  if (!DVI)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1715</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1716</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeLine">  // Ignore assignments to zero bits of the variable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1717</td>
    <td class="codeLine">  // Ignore assignments to zero bits of the variable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeLine">  if (hasZeroSizedFragment(*DVI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1718</td>
    <td class="codeLine">  if (hasZeroSizedFragment(*DVI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1719</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1720</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeLine">  if (auto *DAI = dyn_cast<DbgAssignIntrinsic>(&I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1721</td>
    <td class="codeLine">  if (auto *DAI = dyn_cast<DbgAssignIntrinsic>(&I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeLine">    processDbgAssign(*DAI, LiveSet);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1722</td>
    <td class="codeLine">    processDbgAssign(*DAI, LiveSet);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeLine">  else if (auto *DVI = dyn_cast<DbgValueInst>(&I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1723</td>
    <td class="codeLine">  else if (auto *DVI = dyn_cast<DbgValueInst>(&I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeLine">    processDbgValue(*DVI, LiveSet);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1724</td>
    <td class="codeLine">    processDbgValue(*DVI, LiveSet);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1725</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1726</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeLine">void AssignmentTrackingLowering::resetInsertionPoint(Instruction &After) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1727</td>
    <td class="codeLine">void AssignmentTrackingLowering::resetInsertionPoint(Instruction &After) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeLine">  assert(!After.isTerminator() && "Can't insert after a terminator");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1728</td>
    <td class="codeLine">  assert(!After.isTerminator() && "Can't insert after a terminator");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeLine">  auto R = InsertBeforeMap.find(After.getNextNode());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1729</td>
    <td class="codeLine">  auto R = InsertBeforeMap.find(After.getNextNode());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeLine">  if (R == InsertBeforeMap.end())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1730</td>
    <td class="codeLine">  if (R == InsertBeforeMap.end())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1731</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeLine">  R->second.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1732</td>
    <td class="codeLine">  R->second.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1733</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1734</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeLine">void AssignmentTrackingLowering::process(BasicBlock &BB, BlockInfo *LiveSet) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1735</td>
    <td class="codeLine">void AssignmentTrackingLowering::process(BasicBlock &BB, BlockInfo *LiveSet) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeLine">  for (auto II = BB.begin(), EI = BB.end(); II != EI;) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1736</td>
    <td class="codeLine">  for (auto II = BB.begin(), EI = BB.end(); II != EI;) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeLine">    assert(VarsTouchedThisFrame.empty());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1737</td>
    <td class="codeLine">    assert(VarsTouchedThisFrame.empty());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeLine">    // Process the instructions in "frames". A "frame" includes a single</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1738</td>
    <td class="codeLine">    // Process the instructions in "frames". A "frame" includes a single</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeLine">    // non-debug instruction followed any debug instructions before the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1739</td>
    <td class="codeLine">    // non-debug instruction followed any debug instructions before the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeLine">    // next non-debug instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1740</td>
    <td class="codeLine">    // next non-debug instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeLine">    if (!isa<DbgInfoIntrinsic>(&*II)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1741</td>
    <td class="codeLine">    if (!isa<DbgInfoIntrinsic>(&*II)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeLine">      if (II->isTerminator())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1742</td>
    <td class="codeLine">      if (II->isTerminator())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1743</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeLine">      resetInsertionPoint(*II);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1744</td>
    <td class="codeLine">      resetInsertionPoint(*II);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeLine">      processNonDbgInstruction(*II, LiveSet);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1745</td>
    <td class="codeLine">      processNonDbgInstruction(*II, LiveSet);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeLine">      assert(LiveSet->isValid());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1746</td>
    <td class="codeLine">      assert(LiveSet->isValid());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeLine">      ++II;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1747</td>
    <td class="codeLine">      ++II;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1748</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeLine">    while (II != EI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1749</td>
    <td class="codeLine">    while (II != EI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeLine">      auto *Dbg = dyn_cast<DbgInfoIntrinsic>(&*II);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1750</td>
    <td class="codeLine">      auto *Dbg = dyn_cast<DbgInfoIntrinsic>(&*II);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeLine">      if (!Dbg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1751</td>
    <td class="codeLine">      if (!Dbg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1752</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeLine">      resetInsertionPoint(*II);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1753</td>
    <td class="codeLine">      resetInsertionPoint(*II);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeLine">      processDbgInstruction(*Dbg, LiveSet);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1754</td>
    <td class="codeLine">      processDbgInstruction(*Dbg, LiveSet);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeLine">      assert(LiveSet->isValid());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1755</td>
    <td class="codeLine">      assert(LiveSet->isValid());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeLine">      ++II;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1756</td>
    <td class="codeLine">      ++II;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1757</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1758</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeLine">    // We've processed everything in the "frame". Now determine which variables</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1759</td>
    <td class="codeLine">    // We've processed everything in the "frame". Now determine which variables</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeLine">    // cannot be represented by a dbg.declare.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1760</td>
    <td class="codeLine">    // cannot be represented by a dbg.declare.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeLine">    for (auto Var : VarsTouchedThisFrame) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1761</td>
    <td class="codeLine">    for (auto Var : VarsTouchedThisFrame) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeLine">      LocKind Loc = getLocKind(LiveSet, Var);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1762</td>
    <td class="codeLine">      LocKind Loc = getLocKind(LiveSet, Var);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeLine">      // If a variable's LocKind is anything other than LocKind::Mem then we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1763</td>
    <td class="codeLine">      // If a variable's LocKind is anything other than LocKind::Mem then we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeLine">      // must note that it cannot be represented with a dbg.declare.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1764</td>
    <td class="codeLine">      // must note that it cannot be represented with a dbg.declare.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeLine">      // Note that this check is enough without having to check the result of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1765</td>
    <td class="codeLine">      // Note that this check is enough without having to check the result of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeLine">      // joins() because for join to produce anything other than Mem after</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1766</td>
    <td class="codeLine">      // joins() because for join to produce anything other than Mem after</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeLine">      // we've already seen a Mem we'd be joining None or Val with Mem. In that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1767</td>
    <td class="codeLine">      // we've already seen a Mem we'd be joining None or Val with Mem. In that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeLine">      // case, we've already hit this codepath when we set the LocKind to Val</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1768</td>
    <td class="codeLine">      // case, we've already hit this codepath when we set the LocKind to Val</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeLine">      // or None in that block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1769</td>
    <td class="codeLine">      // or None in that block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeLine">      if (Loc != LocKind::Mem) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1770</td>
    <td class="codeLine">      if (Loc != LocKind::Mem) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeLine">        DebugVariable DbgVar = FnVarLocs->getVariable(Var);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1771</td>
    <td class="codeLine">        DebugVariable DbgVar = FnVarLocs->getVariable(Var);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeLine">        DebugAggregate Aggr{DbgVar.getVariable(), DbgVar.getInlinedAt()};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1772</td>
    <td class="codeLine">        DebugAggregate Aggr{DbgVar.getVariable(), DbgVar.getInlinedAt()};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeLine">        NotAlwaysStackHomed.insert(Aggr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1773</td>
    <td class="codeLine">        NotAlwaysStackHomed.insert(Aggr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1774</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1775</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeLine">    VarsTouchedThisFrame.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1776</td>
    <td class="codeLine">    VarsTouchedThisFrame.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1777</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1778</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1779</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeLine">AssignmentTrackingLowering::LocKind</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1780</td>
    <td class="codeLine">AssignmentTrackingLowering::LocKind</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeLine">AssignmentTrackingLowering::joinKind(LocKind A, LocKind B) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1781</td>
    <td class="codeLine">AssignmentTrackingLowering::joinKind(LocKind A, LocKind B) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeLine">  // Partial order:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1782</td>
    <td class="codeLine">  // Partial order:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeLine">  // None > Mem, Val</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1783</td>
    <td class="codeLine">  // None > Mem, Val</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeLine">  return A == B ? A : LocKind::None;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1784</td>
    <td class="codeLine">  return A == B ? A : LocKind::None;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1785</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1786</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeLine">AssignmentTrackingLowering::Assignment</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1787</td>
    <td class="codeLine">AssignmentTrackingLowering::Assignment</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeLine">AssignmentTrackingLowering::joinAssignment(const Assignment &A,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1788</td>
    <td class="codeLine">AssignmentTrackingLowering::joinAssignment(const Assignment &A,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeLine">                                           const Assignment &B) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1789</td>
    <td class="codeLine">                                           const Assignment &B) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeLine">  // Partial order:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1790</td>
    <td class="codeLine">  // Partial order:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeLine">  // NoneOrPhi(null, null) > Known(v, ?s)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1791</td>
    <td class="codeLine">  // NoneOrPhi(null, null) > Known(v, ?s)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1792</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="codeLine">  // If either are NoneOrPhi the join is NoneOrPhi.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1793</td>
    <td class="codeLine">  // If either are NoneOrPhi the join is NoneOrPhi.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="codeLine">  // If either value is different then the result is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1794</td>
    <td class="codeLine">  // If either value is different then the result is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="codeLine">  // NoneOrPhi (joining two values is a Phi).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1795</td>
    <td class="codeLine">  // NoneOrPhi (joining two values is a Phi).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="codeLine">  if (!A.isSameSourceAssignment(B))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1796</td>
    <td class="codeLine">  if (!A.isSameSourceAssignment(B))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="codeLine">    return Assignment::makeNoneOrPhi();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1797</td>
    <td class="codeLine">    return Assignment::makeNoneOrPhi();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="codeLine">  if (A.Status == Assignment::NoneOrPhi)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1798</td>
    <td class="codeLine">  if (A.Status == Assignment::NoneOrPhi)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="codeLine">    return Assignment::makeNoneOrPhi();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1799</td>
    <td class="codeLine">    return Assignment::makeNoneOrPhi();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1800</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="codeLine">  // Source is used to lookup the value + expression in the debug program if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1801</td>
    <td class="codeLine">  // Source is used to lookup the value + expression in the debug program if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="codeLine">  // the stack slot gets assigned a value earlier than expected. Because</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1802</td>
    <td class="codeLine">  // the stack slot gets assigned a value earlier than expected. Because</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="codeLine">  // we're only tracking the one dbg.assign, we can't capture debug PHIs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1803</td>
    <td class="codeLine">  // we're only tracking the one dbg.assign, we can't capture debug PHIs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="codeLine">  // It's unlikely that we're losing out on much coverage by avoiding that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1804</td>
    <td class="codeLine">  // It's unlikely that we're losing out on much coverage by avoiding that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="codeLine">  // extra work.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1805</td>
    <td class="codeLine">  // extra work.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="codeLine">  // The Source may differ in this situation:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1806</td>
    <td class="codeLine">  // The Source may differ in this situation:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="codeLine">  // Pred.1:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1807</td>
    <td class="codeLine">  // Pred.1:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="codeLine">  //   dbg.assign i32 0, ..., !1, ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1808</td>
    <td class="codeLine">  //   dbg.assign i32 0, ..., !1, ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="codeLine">  // Pred.2:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1809</td>
    <td class="codeLine">  // Pred.2:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="codeLine">  //   dbg.assign i32 1, ..., !1, ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1810</td>
    <td class="codeLine">  //   dbg.assign i32 1, ..., !1, ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="codeLine">  // Here the same assignment (!1) was performed in both preds in the source,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1811</td>
    <td class="codeLine">  // Here the same assignment (!1) was performed in both preds in the source,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="codeLine">  // but we can't use either one unless they are identical (e.g. .we don't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1812</td>
    <td class="codeLine">  // but we can't use either one unless they are identical (e.g. .we don't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="codeLine">  // want to arbitrarily pick between constant values).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1813</td>
    <td class="codeLine">  // want to arbitrarily pick between constant values).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="codeLine">  auto JoinSource = [&]() -> DbgAssignIntrinsic * {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1814</td>
    <td class="codeLine">  auto JoinSource = [&]() -> DbgAssignIntrinsic * {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="codeLine">    if (A.Source == B.Source)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1815</td>
    <td class="codeLine">    if (A.Source == B.Source)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="codeLine">      return A.Source;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1816</td>
    <td class="codeLine">      return A.Source;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="codeLine">    if (A.Source == nullptr || B.Source == nullptr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1817</td>
    <td class="codeLine">    if (A.Source == nullptr || B.Source == nullptr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="codeLine">      return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1818</td>
    <td class="codeLine">      return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="codeLine">    if (A.Source->isIdenticalTo(B.Source))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1819</td>
    <td class="codeLine">    if (A.Source->isIdenticalTo(B.Source))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="codeLine">      return A.Source;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1820</td>
    <td class="codeLine">      return A.Source;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1821</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1822</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="codeLine">  DbgAssignIntrinsic *Source = JoinSource();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1823</td>
    <td class="codeLine">  DbgAssignIntrinsic *Source = JoinSource();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="codeLine">  assert(A.Status == B.Status && A.Status == Assignment::Known);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1824</td>
    <td class="codeLine">  assert(A.Status == B.Status && A.Status == Assignment::Known);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="codeLine">  assert(A.ID == B.ID);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1825</td>
    <td class="codeLine">  assert(A.ID == B.ID);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="codeLine">  return Assignment::make(A.ID, Source);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1826</td>
    <td class="codeLine">  return Assignment::make(A.ID, Source);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1827</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1828</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="codeLine">AssignmentTrackingLowering::BlockInfo</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1829</td>
    <td class="codeLine">AssignmentTrackingLowering::BlockInfo</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="codeLine">AssignmentTrackingLowering::joinBlockInfo(const BlockInfo &A,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1830</td>
    <td class="codeLine">AssignmentTrackingLowering::joinBlockInfo(const BlockInfo &A,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="codeLine">                                          const BlockInfo &B) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1831</td>
    <td class="codeLine">                                          const BlockInfo &B) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="codeLine">  return BlockInfo::join(A, B, TrackedVariablesVectorSize);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1832</td>
    <td class="codeLine">  return BlockInfo::join(A, B, TrackedVariablesVectorSize);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1833</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1834</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="codeLine">bool AssignmentTrackingLowering::join(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1835</td>
    <td class="codeLine">bool AssignmentTrackingLowering::join(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="codeLine">    const BasicBlock &BB, const SmallPtrSet<BasicBlock *, 16> &Visited) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1836</td>
    <td class="codeLine">    const BasicBlock &BB, const SmallPtrSet<BasicBlock *, 16> &Visited) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1837</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="codeLine">  SmallVector<const BasicBlock *> VisitedPreds;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1838</td>
    <td class="codeLine">  SmallVector<const BasicBlock *> VisitedPreds;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="codeLine">  // Ignore backedges if we have not visited the predecessor yet. As the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1839</td>
    <td class="codeLine">  // Ignore backedges if we have not visited the predecessor yet. As the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="codeLine">  // predecessor hasn't yet had locations propagated into it, most locations</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1840</td>
    <td class="codeLine">  // predecessor hasn't yet had locations propagated into it, most locations</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="codeLine">  // will not yet be valid, so treat them as all being uninitialized and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1841</td>
    <td class="codeLine">  // will not yet be valid, so treat them as all being uninitialized and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="codeLine">  // potentially valid. If a location guessed to be correct here is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1842</td>
    <td class="codeLine">  // potentially valid. If a location guessed to be correct here is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="codeLine">  // invalidated later, we will remove it when we revisit this block. This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1843</td>
    <td class="codeLine">  // invalidated later, we will remove it when we revisit this block. This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="codeLine">  // is essentially the same as initialising all LocKinds and Assignments to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1844</td>
    <td class="codeLine">  // is essentially the same as initialising all LocKinds and Assignments to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="codeLine">  // an implicit ⊥ value which is the identity value for the join operation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1845</td>
    <td class="codeLine">  // an implicit ⊥ value which is the identity value for the join operation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="codeLine">  for (auto I = pred_begin(&BB), E = pred_end(&BB); I != E; I++) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1846</td>
    <td class="codeLine">  for (auto I = pred_begin(&BB), E = pred_end(&BB); I != E; I++) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="codeLine">    const BasicBlock *Pred = *I;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1847</td>
    <td class="codeLine">    const BasicBlock *Pred = *I;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="codeLine">    if (Visited.count(Pred))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1848</td>
    <td class="codeLine">    if (Visited.count(Pred))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="codeLine">      VisitedPreds.push_back(Pred);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1849</td>
    <td class="codeLine">      VisitedPreds.push_back(Pred);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1850</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1851</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="codeLine">  // No preds visited yet.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1852</td>
    <td class="codeLine">  // No preds visited yet.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="codeLine">  if (VisitedPreds.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1853</td>
    <td class="codeLine">  if (VisitedPreds.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="codeLine">    auto It = LiveIn.try_emplace(&BB, BlockInfo());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1854</td>
    <td class="codeLine">    auto It = LiveIn.try_emplace(&BB, BlockInfo());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="codeLine">    bool DidInsert = It.second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1855</td>
    <td class="codeLine">    bool DidInsert = It.second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="codeLine">    if (DidInsert)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1856</td>
    <td class="codeLine">    if (DidInsert)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="codeLine">      It.first->second.init(TrackedVariablesVectorSize);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1857</td>
    <td class="codeLine">      It.first->second.init(TrackedVariablesVectorSize);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="codeLine">    return /*Changed*/ DidInsert;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1858</td>
    <td class="codeLine">    return /*Changed*/ DidInsert;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1859</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1860</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="codeLine">  // Exactly one visited pred. Copy the LiveOut from that pred into BB LiveIn.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1861</td>
    <td class="codeLine">  // Exactly one visited pred. Copy the LiveOut from that pred into BB LiveIn.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="codeLine">  if (VisitedPreds.size() == 1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1862</td>
    <td class="codeLine">  if (VisitedPreds.size() == 1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="codeLine">    const BlockInfo &PredLiveOut = LiveOut.find(VisitedPreds[0])->second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1863</td>
    <td class="codeLine">    const BlockInfo &PredLiveOut = LiveOut.find(VisitedPreds[0])->second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="codeLine">    auto CurrentLiveInEntry = LiveIn.find(&BB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1864</td>
    <td class="codeLine">    auto CurrentLiveInEntry = LiveIn.find(&BB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1865</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="codeLine">    // Check if there isn't an entry, or there is but the LiveIn set has</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1866</td>
    <td class="codeLine">    // Check if there isn't an entry, or there is but the LiveIn set has</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="codeLine">    // changed (expensive check).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1867</td>
    <td class="codeLine">    // changed (expensive check).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="codeLine">    if (CurrentLiveInEntry == LiveIn.end())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1868</td>
    <td class="codeLine">    if (CurrentLiveInEntry == LiveIn.end())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="codeLine">      LiveIn.insert(std::make_pair(&BB, PredLiveOut));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1869</td>
    <td class="codeLine">      LiveIn.insert(std::make_pair(&BB, PredLiveOut));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="codeLine">    else if (PredLiveOut != CurrentLiveInEntry->second)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1870</td>
    <td class="codeLine">    else if (PredLiveOut != CurrentLiveInEntry->second)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="codeLine">      CurrentLiveInEntry->second = PredLiveOut;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1871</td>
    <td class="codeLine">      CurrentLiveInEntry->second = PredLiveOut;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1872</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="codeLine">      return /*Changed*/ false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1873</td>
    <td class="codeLine">      return /*Changed*/ false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="codeLine">    return /*Changed*/ true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1874</td>
    <td class="codeLine">    return /*Changed*/ true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1875</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1876</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="codeLine">  // More than one pred. Join LiveOuts of blocks 1 and 2.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1877</td>
    <td class="codeLine">  // More than one pred. Join LiveOuts of blocks 1 and 2.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="codeLine">  assert(VisitedPreds.size() > 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1878</td>
    <td class="codeLine">  assert(VisitedPreds.size() > 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="codeLine">  const BlockInfo &PredLiveOut0 = LiveOut.find(VisitedPreds[0])->second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1879</td>
    <td class="codeLine">  const BlockInfo &PredLiveOut0 = LiveOut.find(VisitedPreds[0])->second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="codeLine">  const BlockInfo &PredLiveOut1 = LiveOut.find(VisitedPreds[1])->second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1880</td>
    <td class="codeLine">  const BlockInfo &PredLiveOut1 = LiveOut.find(VisitedPreds[1])->second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="codeLine">  BlockInfo BBLiveIn = joinBlockInfo(PredLiveOut0, PredLiveOut1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1881</td>
    <td class="codeLine">  BlockInfo BBLiveIn = joinBlockInfo(PredLiveOut0, PredLiveOut1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1882</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="codeLine">  // Join the LiveOuts of subsequent blocks.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1883</td>
    <td class="codeLine">  // Join the LiveOuts of subsequent blocks.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="codeLine">  ArrayRef Tail = ArrayRef(VisitedPreds).drop_front(2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1884</td>
    <td class="codeLine">  ArrayRef Tail = ArrayRef(VisitedPreds).drop_front(2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="codeLine">  for (const BasicBlock *Pred : Tail) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1885</td>
    <td class="codeLine">  for (const BasicBlock *Pred : Tail) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="codeLine">    const auto &PredLiveOut = LiveOut.find(Pred);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1886</td>
    <td class="codeLine">    const auto &PredLiveOut = LiveOut.find(Pred);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="codeLine">    assert(PredLiveOut != LiveOut.end() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1887</td>
    <td class="codeLine">    assert(PredLiveOut != LiveOut.end() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="codeLine">           "block should have been processed already");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1888</td>
    <td class="codeLine">           "block should have been processed already");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="codeLine">    BBLiveIn = joinBlockInfo(std::move(BBLiveIn), PredLiveOut->second);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1889</td>
    <td class="codeLine">    BBLiveIn = joinBlockInfo(std::move(BBLiveIn), PredLiveOut->second);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1890</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1891</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="codeLine">  // Save the joined result for BB.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1892</td>
    <td class="codeLine">  // Save the joined result for BB.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="codeLine">  auto CurrentLiveInEntry = LiveIn.find(&BB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1893</td>
    <td class="codeLine">  auto CurrentLiveInEntry = LiveIn.find(&BB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="codeLine">  // Check if there isn't an entry, or there is but the LiveIn set has changed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1894</td>
    <td class="codeLine">  // Check if there isn't an entry, or there is but the LiveIn set has changed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="codeLine">  // (expensive check).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1895</td>
    <td class="codeLine">  // (expensive check).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="codeLine">  if (CurrentLiveInEntry == LiveIn.end())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1896</td>
    <td class="codeLine">  if (CurrentLiveInEntry == LiveIn.end())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="codeLine">    LiveIn.try_emplace(&BB, std::move(BBLiveIn));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1897</td>
    <td class="codeLine">    LiveIn.try_emplace(&BB, std::move(BBLiveIn));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="codeLine">  else if (BBLiveIn != CurrentLiveInEntry->second)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1898</td>
    <td class="codeLine">  else if (BBLiveIn != CurrentLiveInEntry->second)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="codeLine">    CurrentLiveInEntry->second = std::move(BBLiveIn);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1899</td>
    <td class="codeLine">    CurrentLiveInEntry->second = std::move(BBLiveIn);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1900</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="codeLine">    return /*Changed*/ false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1901</td>
    <td class="codeLine">    return /*Changed*/ false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="codeLine">  return /*Changed*/ true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1902</td>
    <td class="codeLine">  return /*Changed*/ true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1903</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1904</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="codeLine">/// Return true if A fully contains B.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1905</td>
    <td class="codeLine">/// Return true if A fully contains B.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="codeLine">static bool fullyContains(DIExpression::FragmentInfo A,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1906</td>
    <td class="codeLine">static bool fullyContains(DIExpression::FragmentInfo A,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="codeLine">                          DIExpression::FragmentInfo B) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1907</td>
    <td class="codeLine">                          DIExpression::FragmentInfo B) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="codeLine">  auto ALeft = A.OffsetInBits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1908</td>
    <td class="codeLine">  auto ALeft = A.OffsetInBits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="codeLine">  auto BLeft = B.OffsetInBits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1909</td>
    <td class="codeLine">  auto BLeft = B.OffsetInBits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="codeLine">  if (BLeft < ALeft)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1910</td>
    <td class="codeLine">  if (BLeft < ALeft)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1911</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1912</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="codeLine">  auto ARight = ALeft + A.SizeInBits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1913</td>
    <td class="codeLine">  auto ARight = ALeft + A.SizeInBits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="codeLine">  auto BRight = BLeft + B.SizeInBits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1914</td>
    <td class="codeLine">  auto BRight = BLeft + B.SizeInBits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="codeLine">  if (BRight > ARight)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1915</td>
    <td class="codeLine">  if (BRight > ARight)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1916</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1917</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1918</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1919</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="codeLine">static std::optional<at::AssignmentInfo></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1920</td>
    <td class="codeLine">static std::optional<at::AssignmentInfo></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="codeLine">getUntaggedStoreAssignmentInfo(const Instruction &I, const DataLayout &Layout) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1921</td>
    <td class="codeLine">getUntaggedStoreAssignmentInfo(const Instruction &I, const DataLayout &Layout) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="codeLine">  // Don't bother checking if this is an AllocaInst. We know this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1922</td>
    <td class="codeLine">  // Don't bother checking if this is an AllocaInst. We know this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="codeLine">  // instruction has no tag which means there are no variables associated</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1923</td>
    <td class="codeLine">  // instruction has no tag which means there are no variables associated</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="codeLine">  // with it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1924</td>
    <td class="codeLine">  // with it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="codeLine">  if (const auto *SI = dyn_cast<StoreInst>(&I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1925</td>
    <td class="codeLine">  if (const auto *SI = dyn_cast<StoreInst>(&I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="codeLine">    return at::getAssignmentInfo(Layout, SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1926</td>
    <td class="codeLine">    return at::getAssignmentInfo(Layout, SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="codeLine">  if (const auto *MI = dyn_cast<MemIntrinsic>(&I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1927</td>
    <td class="codeLine">  if (const auto *MI = dyn_cast<MemIntrinsic>(&I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="codeLine">    return at::getAssignmentInfo(Layout, MI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1928</td>
    <td class="codeLine">    return at::getAssignmentInfo(Layout, MI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="codeLine">  // Alloca or non-store-like inst.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1929</td>
    <td class="codeLine">  // Alloca or non-store-like inst.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="codeLine">  return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1930</td>
    <td class="codeLine">  return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1931</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1932</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="codeLine">/// Build a map of {Variable x: Variables y} where all variable fragments</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1933</td>
    <td class="codeLine">/// Build a map of {Variable x: Variables y} where all variable fragments</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="codeLine">/// contained within the variable fragment x are in set y. This means that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1934</td>
    <td class="codeLine">/// contained within the variable fragment x are in set y. This means that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="codeLine">/// y does not contain all overlaps because partial overlaps are excluded.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1935</td>
    <td class="codeLine">/// y does not contain all overlaps because partial overlaps are excluded.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1936</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="codeLine">/// While we're iterating over the function, add single location defs for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1937</td>
    <td class="codeLine">/// While we're iterating over the function, add single location defs for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="codeLine">/// dbg.declares to \p FnVarLocs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1938</td>
    <td class="codeLine">/// dbg.declares to \p FnVarLocs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1939</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="codeLine">/// Variables that are interesting to this pass in are added to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1940</td>
    <td class="codeLine">/// Variables that are interesting to this pass in are added to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="codeLine">/// FnVarLocs->Variables first. TrackedVariablesVectorSize is set to the ID of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1941</td>
    <td class="codeLine">/// FnVarLocs->Variables first. TrackedVariablesVectorSize is set to the ID of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="codeLine">/// the last interesting variable plus 1, meaning variables with ID 1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1942</td>
    <td class="codeLine">/// the last interesting variable plus 1, meaning variables with ID 1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="codeLine">/// (inclusive) to TrackedVariablesVectorSize (exclusive) are interesting. The</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1943</td>
    <td class="codeLine">/// (inclusive) to TrackedVariablesVectorSize (exclusive) are interesting. The</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="codeLine">/// subsequent variables are either stack homed or fully promoted.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1944</td>
    <td class="codeLine">/// subsequent variables are either stack homed or fully promoted.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1945</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="codeLine">/// Finally, populate UntaggedStoreVars with a mapping of untagged stores to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1946</td>
    <td class="codeLine">/// Finally, populate UntaggedStoreVars with a mapping of untagged stores to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="codeLine">/// the stored-to variable fragments.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1947</td>
    <td class="codeLine">/// the stored-to variable fragments.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1948</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="codeLine">/// These tasks are bundled together to reduce the number of times we need</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1949</td>
    <td class="codeLine">/// These tasks are bundled together to reduce the number of times we need</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="codeLine">/// to iterate over the function as they can be achieved together in one pass.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1950</td>
    <td class="codeLine">/// to iterate over the function as they can be achieved together in one pass.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="codeLine">static AssignmentTrackingLowering::OverlapMap buildOverlapMapAndRecordDeclares(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1951</td>
    <td class="codeLine">static AssignmentTrackingLowering::OverlapMap buildOverlapMapAndRecordDeclares(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="codeLine">    Function &Fn, FunctionVarLocsBuilder *FnVarLocs,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1952</td>
    <td class="codeLine">    Function &Fn, FunctionVarLocsBuilder *FnVarLocs,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="codeLine">    const DenseSet<DebugAggregate> &VarsWithStackSlot,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1953</td>
    <td class="codeLine">    const DenseSet<DebugAggregate> &VarsWithStackSlot,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="codeLine">    AssignmentTrackingLowering::UntaggedStoreAssignmentMap &UntaggedStoreVars,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1954</td>
    <td class="codeLine">    AssignmentTrackingLowering::UntaggedStoreAssignmentMap &UntaggedStoreVars,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="codeLine">    unsigned &TrackedVariablesVectorSize) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1955</td>
    <td class="codeLine">    unsigned &TrackedVariablesVectorSize) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="codeLine">  DenseSet<DebugVariable> Seen;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1956</td>
    <td class="codeLine">  DenseSet<DebugVariable> Seen;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="codeLine">  // Map of Variable: [Fragments].</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1957</td>
    <td class="codeLine">  // Map of Variable: [Fragments].</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="codeLine">  DenseMap<DebugAggregate, SmallVector<DebugVariable, 8>> FragmentMap;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1958</td>
    <td class="codeLine">  DenseMap<DebugAggregate, SmallVector<DebugVariable, 8>> FragmentMap;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="codeLine">  // Iterate over all instructions:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1959</td>
    <td class="codeLine">  // Iterate over all instructions:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="codeLine">  // - dbg.declare    -> add single location variable record</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1960</td>
    <td class="codeLine">  // - dbg.declare    -> add single location variable record</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="codeLine">  // - dbg.*          -> Add fragments to FragmentMap</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1961</td>
    <td class="codeLine">  // - dbg.*          -> Add fragments to FragmentMap</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="codeLine">  // - untagged store -> Add fragments to FragmentMap and update</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1962</td>
    <td class="codeLine">  // - untagged store -> Add fragments to FragmentMap and update</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="codeLine">  //                     UntaggedStoreVars.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1963</td>
    <td class="codeLine">  //                     UntaggedStoreVars.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="codeLine">  // We need to add fragments for untagged stores too so that we can correctly</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1964</td>
    <td class="codeLine">  // We need to add fragments for untagged stores too so that we can correctly</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="codeLine">  // clobber overlapped fragment locations later.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1965</td>
    <td class="codeLine">  // clobber overlapped fragment locations later.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="codeLine">  SmallVector<DbgDeclareInst *> Declares;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1966</td>
    <td class="codeLine">  SmallVector<DbgDeclareInst *> Declares;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="codeLine">  for (auto &BB : Fn) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1967</td>
    <td class="codeLine">  for (auto &BB : Fn) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="codeLine">    for (auto &I : BB) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1968</td>
    <td class="codeLine">    for (auto &I : BB) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="codeLine">      if (auto *DDI = dyn_cast<DbgDeclareInst>(&I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1969</td>
    <td class="codeLine">      if (auto *DDI = dyn_cast<DbgDeclareInst>(&I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="codeLine">        Declares.push_back(DDI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1970</td>
    <td class="codeLine">        Declares.push_back(DDI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="codeLine">      } else if (auto *DII = dyn_cast<DbgVariableIntrinsic>(&I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1971</td>
    <td class="codeLine">      } else if (auto *DII = dyn_cast<DbgVariableIntrinsic>(&I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="codeLine">        DebugVariable DV = DebugVariable(DII);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1972</td>
    <td class="codeLine">        DebugVariable DV = DebugVariable(DII);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="codeLine">        DebugAggregate DA = {DV.getVariable(), DV.getInlinedAt()};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1973</td>
    <td class="codeLine">        DebugAggregate DA = {DV.getVariable(), DV.getInlinedAt()};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="codeLine">        if (!VarsWithStackSlot.contains(DA))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1974</td>
    <td class="codeLine">        if (!VarsWithStackSlot.contains(DA))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1975</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="codeLine">        if (Seen.insert(DV).second)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1976</td>
    <td class="codeLine">        if (Seen.insert(DV).second)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="codeLine">          FragmentMap[DA].push_back(DV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1977</td>
    <td class="codeLine">          FragmentMap[DA].push_back(DV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="codeLine">      } else if (auto Info = getUntaggedStoreAssignmentInfo(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1978</td>
    <td class="codeLine">      } else if (auto Info = getUntaggedStoreAssignmentInfo(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="codeLine">                     I, Fn.getParent()->getDataLayout())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1979</td>
    <td class="codeLine">                     I, Fn.getParent()->getDataLayout())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="codeLine">        // Find markers linked to this alloca.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1980</td>
    <td class="codeLine">        // Find markers linked to this alloca.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="codeLine">        for (DbgAssignIntrinsic *DAI : at::getAssignmentMarkers(Info->Base)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1981</td>
    <td class="codeLine">        for (DbgAssignIntrinsic *DAI : at::getAssignmentMarkers(Info->Base)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="codeLine">          // Discard the fragment if it covers the entire variable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1982</td>
    <td class="codeLine">          // Discard the fragment if it covers the entire variable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="codeLine">          std::optional<DIExpression::FragmentInfo> FragInfo =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1983</td>
    <td class="codeLine">          std::optional<DIExpression::FragmentInfo> FragInfo =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="codeLine">              [&Info, DAI]() -> std::optional<DIExpression::FragmentInfo> {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1984</td>
    <td class="codeLine">              [&Info, DAI]() -> std::optional<DIExpression::FragmentInfo> {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="codeLine">            DIExpression::FragmentInfo F;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1985</td>
    <td class="codeLine">            DIExpression::FragmentInfo F;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="codeLine">            F.OffsetInBits = Info->OffsetInBits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1986</td>
    <td class="codeLine">            F.OffsetInBits = Info->OffsetInBits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="codeLine">            F.SizeInBits = Info->SizeInBits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1987</td>
    <td class="codeLine">            F.SizeInBits = Info->SizeInBits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="codeLine">            if (auto ExistingFrag = DAI->getExpression()->getFragmentInfo())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1988</td>
    <td class="codeLine">            if (auto ExistingFrag = DAI->getExpression()->getFragmentInfo())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="codeLine">              F.OffsetInBits += ExistingFrag->OffsetInBits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1989</td>
    <td class="codeLine">              F.OffsetInBits += ExistingFrag->OffsetInBits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="codeLine">            if (auto Sz = DAI->getVariable()->getSizeInBits()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1990</td>
    <td class="codeLine">            if (auto Sz = DAI->getVariable()->getSizeInBits()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="codeLine">              if (F.OffsetInBits == 0 && F.SizeInBits == *Sz)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1991</td>
    <td class="codeLine">              if (F.OffsetInBits == 0 && F.SizeInBits == *Sz)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="codeLine">                return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1992</td>
    <td class="codeLine">                return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="codeLine">            }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1993</td>
    <td class="codeLine">            }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="codeLine">            return F;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1994</td>
    <td class="codeLine">            return F;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="codeLine">          }();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1995</td>
    <td class="codeLine">          }();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1996</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="codeLine">          DebugVariable DV = DebugVariable(DAI->getVariable(), FragInfo,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1997</td>
    <td class="codeLine">          DebugVariable DV = DebugVariable(DAI->getVariable(), FragInfo,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="codeLine">                                           DAI->getDebugLoc().getInlinedAt());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1998</td>
    <td class="codeLine">                                           DAI->getDebugLoc().getInlinedAt());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="codeLine">          DebugAggregate DA = {DV.getVariable(), DV.getInlinedAt()};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1999</td>
    <td class="codeLine">          DebugAggregate DA = {DV.getVariable(), DV.getInlinedAt()};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="codeLine">          if (!VarsWithStackSlot.contains(DA))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2000</td>
    <td class="codeLine">          if (!VarsWithStackSlot.contains(DA))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="codeLine">            continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2001</td>
    <td class="codeLine">            continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2002</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="codeLine">          // Cache this info for later.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2003</td>
    <td class="codeLine">          // Cache this info for later.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="codeLine">          UntaggedStoreVars[&I].push_back(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2004</td>
    <td class="codeLine">          UntaggedStoreVars[&I].push_back(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="codeLine">              {FnVarLocs->insertVariable(DV), *Info});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2005</td>
    <td class="codeLine">              {FnVarLocs->insertVariable(DV), *Info});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2006</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="codeLine">          if (Seen.insert(DV).second)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2007</td>
    <td class="codeLine">          if (Seen.insert(DV).second)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="codeLine">            FragmentMap[DA].push_back(DV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2008</td>
    <td class="codeLine">            FragmentMap[DA].push_back(DV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2009</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2010</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2011</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2012</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2013</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="codeLine">  // Sort the fragment map for each DebugAggregate in ascending</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2014</td>
    <td class="codeLine">  // Sort the fragment map for each DebugAggregate in ascending</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="codeLine">  // order of fragment size - there should be no duplicates.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2015</td>
    <td class="codeLine">  // order of fragment size - there should be no duplicates.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="codeLine">  for (auto &Pair : FragmentMap) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2016</td>
    <td class="codeLine">  for (auto &Pair : FragmentMap) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="codeLine">    SmallVector<DebugVariable, 8> &Frags = Pair.second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2017</td>
    <td class="codeLine">    SmallVector<DebugVariable, 8> &Frags = Pair.second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="codeLine">    std::sort(Frags.begin(), Frags.end(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2018</td>
    <td class="codeLine">    std::sort(Frags.begin(), Frags.end(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="codeLine">              [](const DebugVariable &Next, const DebugVariable &Elmt) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2019</td>
    <td class="codeLine">              [](const DebugVariable &Next, const DebugVariable &Elmt) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="codeLine">                return Elmt.getFragmentOrDefault().SizeInBits ></td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2020</td>
    <td class="codeLine">                return Elmt.getFragmentOrDefault().SizeInBits ></td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="codeLine">                       Next.getFragmentOrDefault().SizeInBits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2021</td>
    <td class="codeLine">                       Next.getFragmentOrDefault().SizeInBits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="codeLine">              });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2022</td>
    <td class="codeLine">              });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="codeLine">    // Check for duplicates.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2023</td>
    <td class="codeLine">    // Check for duplicates.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="codeLine">    assert(std::adjacent_find(Frags.begin(), Frags.end()) == Frags.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2024</td>
    <td class="codeLine">    assert(std::adjacent_find(Frags.begin(), Frags.end()) == Frags.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2025</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2026</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="codeLine">  // Build the map.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2027</td>
    <td class="codeLine">  // Build the map.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="codeLine">  AssignmentTrackingLowering::OverlapMap Map;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2028</td>
    <td class="codeLine">  AssignmentTrackingLowering::OverlapMap Map;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="codeLine">  for (auto &Pair : FragmentMap) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2029</td>
    <td class="codeLine">  for (auto &Pair : FragmentMap) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="codeLine">    auto &Frags = Pair.second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2030</td>
    <td class="codeLine">    auto &Frags = Pair.second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="codeLine">    for (auto It = Frags.begin(), IEnd = Frags.end(); It != IEnd; ++It) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2031</td>
    <td class="codeLine">    for (auto It = Frags.begin(), IEnd = Frags.end(); It != IEnd; ++It) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="codeLine">      DIExpression::FragmentInfo Frag = It->getFragmentOrDefault();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2032</td>
    <td class="codeLine">      DIExpression::FragmentInfo Frag = It->getFragmentOrDefault();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="codeLine">      // Find the frags that this is contained within.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2033</td>
    <td class="codeLine">      // Find the frags that this is contained within.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="codeLine">      //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2034</td>
    <td class="codeLine">      //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="codeLine">      // Because Frags is sorted by size and none have the same offset and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2035</td>
    <td class="codeLine">      // Because Frags is sorted by size and none have the same offset and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="codeLine">      // size, we know that this frag can only be contained by subsequent</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2036</td>
    <td class="codeLine">      // size, we know that this frag can only be contained by subsequent</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="codeLine">      // elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2037</td>
    <td class="codeLine">      // elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="codeLine">      SmallVector<DebugVariable, 8>::iterator OtherIt = It;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2038</td>
    <td class="codeLine">      SmallVector<DebugVariable, 8>::iterator OtherIt = It;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="codeLine">      ++OtherIt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2039</td>
    <td class="codeLine">      ++OtherIt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="codeLine">      VariableID ThisVar = FnVarLocs->insertVariable(*It);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2040</td>
    <td class="codeLine">      VariableID ThisVar = FnVarLocs->insertVariable(*It);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="codeLine">      for (; OtherIt != IEnd; ++OtherIt) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2041</td>
    <td class="codeLine">      for (; OtherIt != IEnd; ++OtherIt) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="codeLine">        DIExpression::FragmentInfo OtherFrag = OtherIt->getFragmentOrDefault();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2042</td>
    <td class="codeLine">        DIExpression::FragmentInfo OtherFrag = OtherIt->getFragmentOrDefault();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="codeLine">        VariableID OtherVar = FnVarLocs->insertVariable(*OtherIt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2043</td>
    <td class="codeLine">        VariableID OtherVar = FnVarLocs->insertVariable(*OtherIt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="codeLine">        if (fullyContains(OtherFrag, Frag))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2044</td>
    <td class="codeLine">        if (fullyContains(OtherFrag, Frag))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="codeLine">          Map[OtherVar].push_back(ThisVar);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2045</td>
    <td class="codeLine">          Map[OtherVar].push_back(ThisVar);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2046</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2047</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2048</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2049</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="codeLine">  // VariableIDs are 1-based so the variable-tracking bitvector needs</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2050</td>
    <td class="codeLine">  // VariableIDs are 1-based so the variable-tracking bitvector needs</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="codeLine">  // NumVariables plus 1 bits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2051</td>
    <td class="codeLine">  // NumVariables plus 1 bits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="codeLine">  TrackedVariablesVectorSize = FnVarLocs->getNumVariables() + 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2052</td>
    <td class="codeLine">  TrackedVariablesVectorSize = FnVarLocs->getNumVariables() + 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2053</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="codeLine">  // Finally, insert the declares afterwards, so the first IDs are all</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2054</td>
    <td class="codeLine">  // Finally, insert the declares afterwards, so the first IDs are all</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="codeLine">  // partially stack homed vars.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2055</td>
    <td class="codeLine">  // partially stack homed vars.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="codeLine">  for (auto *DDI : Declares)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2056</td>
    <td class="codeLine">  for (auto *DDI : Declares)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="codeLine">    FnVarLocs->addSingleLocVar(DebugVariable(DDI), DDI->getExpression(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2057</td>
    <td class="codeLine">    FnVarLocs->addSingleLocVar(DebugVariable(DDI), DDI->getExpression(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="codeLine">                               DDI->getDebugLoc(), DDI->getWrappedLocation());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2058</td>
    <td class="codeLine">                               DDI->getDebugLoc(), DDI->getWrappedLocation());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="codeLine">  return Map;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2059</td>
    <td class="codeLine">  return Map;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2060</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2061</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="codeLine">bool AssignmentTrackingLowering::run(FunctionVarLocsBuilder *FnVarLocsBuilder) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2062</td>
    <td class="codeLine">bool AssignmentTrackingLowering::run(FunctionVarLocsBuilder *FnVarLocsBuilder) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="codeLine">  if (Fn.size() > MaxNumBlocks) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2063</td>
    <td class="codeLine">  if (Fn.size() > MaxNumBlocks) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "[AT] Dropping var locs in: " << Fn.getName()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2064</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "[AT] Dropping var locs in: " << Fn.getName()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="codeLine">                      << ": too many blocks (" << Fn.size() << ")\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2065</td>
    <td class="codeLine">                      << ": too many blocks (" << Fn.size() << ")\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="codeLine">    at::deleteAll(&Fn);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2066</td>
    <td class="codeLine">    at::deleteAll(&Fn);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2067</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2068</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2069</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="codeLine">  FnVarLocs = FnVarLocsBuilder;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2070</td>
    <td class="codeLine">  FnVarLocs = FnVarLocsBuilder;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2071</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="codeLine">  // The general structure here is inspired by VarLocBasedImpl.cpp</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2072</td>
    <td class="codeLine">  // The general structure here is inspired by VarLocBasedImpl.cpp</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="codeLine">  // (LiveDebugValues).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2073</td>
    <td class="codeLine">  // (LiveDebugValues).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2074</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="codeLine">  // Build the variable fragment overlap map.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2075</td>
    <td class="codeLine">  // Build the variable fragment overlap map.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="codeLine">  // Note that this pass doesn't handle partial overlaps correctly (FWIW</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2076</td>
    <td class="codeLine">  // Note that this pass doesn't handle partial overlaps correctly (FWIW</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="codeLine">  // neither does LiveDebugVariables) because that is difficult to do and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2077</td>
    <td class="codeLine">  // neither does LiveDebugVariables) because that is difficult to do and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="codeLine">  // appears to be rare occurance.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2078</td>
    <td class="codeLine">  // appears to be rare occurance.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="codeLine">  VarContains = buildOverlapMapAndRecordDeclares(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2079</td>
    <td class="codeLine">  VarContains = buildOverlapMapAndRecordDeclares(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="codeLine">      Fn, FnVarLocs, *VarsWithStackSlot, UntaggedStoreVars,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2080</td>
    <td class="codeLine">      Fn, FnVarLocs, *VarsWithStackSlot, UntaggedStoreVars,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="codeLine">      TrackedVariablesVectorSize);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2081</td>
    <td class="codeLine">      TrackedVariablesVectorSize);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2082</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="codeLine">  // Prepare for traversal.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2083</td>
    <td class="codeLine">  // Prepare for traversal.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="codeLine">  ReversePostOrderTraversal<Function *> RPOT(&Fn);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2084</td>
    <td class="codeLine">  ReversePostOrderTraversal<Function *> RPOT(&Fn);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="codeLine">  std::priority_queue<unsigned int, std::vector<unsigned int>,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2085</td>
    <td class="codeLine">  std::priority_queue<unsigned int, std::vector<unsigned int>,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="codeLine">                      std::greater<unsigned int>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2086</td>
    <td class="codeLine">                      std::greater<unsigned int>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="codeLine">      Worklist;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2087</td>
    <td class="codeLine">      Worklist;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="codeLine">  std::priority_queue<unsigned int, std::vector<unsigned int>,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2088</td>
    <td class="codeLine">  std::priority_queue<unsigned int, std::vector<unsigned int>,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="codeLine">                      std::greater<unsigned int>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2089</td>
    <td class="codeLine">                      std::greater<unsigned int>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="codeLine">      Pending;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2090</td>
    <td class="codeLine">      Pending;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="codeLine">  DenseMap<unsigned int, BasicBlock *> OrderToBB;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2091</td>
    <td class="codeLine">  DenseMap<unsigned int, BasicBlock *> OrderToBB;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="codeLine">  DenseMap<BasicBlock *, unsigned int> BBToOrder;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2092</td>
    <td class="codeLine">  DenseMap<BasicBlock *, unsigned int> BBToOrder;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="codeLine">  { // Init OrderToBB and BBToOrder.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2093</td>
    <td class="codeLine">  { // Init OrderToBB and BBToOrder.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="codeLine">    unsigned int RPONumber = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2094</td>
    <td class="codeLine">    unsigned int RPONumber = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="codeLine">    for (auto RI = RPOT.begin(), RE = RPOT.end(); RI != RE; ++RI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2095</td>
    <td class="codeLine">    for (auto RI = RPOT.begin(), RE = RPOT.end(); RI != RE; ++RI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="codeLine">      OrderToBB[RPONumber] = *RI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2096</td>
    <td class="codeLine">      OrderToBB[RPONumber] = *RI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="codeLine">      BBToOrder[*RI] = RPONumber;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2097</td>
    <td class="codeLine">      BBToOrder[*RI] = RPONumber;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="codeLine">      Worklist.push(RPONumber);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2098</td>
    <td class="codeLine">      Worklist.push(RPONumber);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="codeLine">      ++RPONumber;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2099</td>
    <td class="codeLine">      ++RPONumber;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2100</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="codeLine">    LiveIn.init(RPONumber);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2101</td>
    <td class="codeLine">    LiveIn.init(RPONumber);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="codeLine">    LiveOut.init(RPONumber);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2102</td>
    <td class="codeLine">    LiveOut.init(RPONumber);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2103</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2104</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="codeLine">  // Perform the traversal.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2105</td>
    <td class="codeLine">  // Perform the traversal.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2106</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="codeLine">  // This is a standard "union of predecessor outs" dataflow problem. To solve</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2107</td>
    <td class="codeLine">  // This is a standard "union of predecessor outs" dataflow problem. To solve</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="codeLine">  // it, we perform join() and process() using the two worklist method until</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2108</td>
    <td class="codeLine">  // it, we perform join() and process() using the two worklist method until</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="codeLine">  // the LiveIn data for each block becomes unchanging. The "proof" that this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2109</td>
    <td class="codeLine">  // the LiveIn data for each block becomes unchanging. The "proof" that this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="codeLine">  // terminates can be put together by looking at the comments around LocKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2110</td>
    <td class="codeLine">  // terminates can be put together by looking at the comments around LocKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="codeLine">  // Assignment, and the various join methods, which show that all the elements</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2111</td>
    <td class="codeLine">  // Assignment, and the various join methods, which show that all the elements</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="codeLine">  // involved are made up of join-semilattices; LiveIn(n) can only</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2112</td>
    <td class="codeLine">  // involved are made up of join-semilattices; LiveIn(n) can only</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="codeLine">  // monotonically increase in value throughout the dataflow.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2113</td>
    <td class="codeLine">  // monotonically increase in value throughout the dataflow.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2114</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="codeLine">  SmallPtrSet<BasicBlock *, 16> Visited;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2115</td>
    <td class="codeLine">  SmallPtrSet<BasicBlock *, 16> Visited;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="codeLine">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2116</td>
    <td class="codeLine">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="codeLine">    // We track what is on the pending worklist to avoid inserting the same</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2117</td>
    <td class="codeLine">    // We track what is on the pending worklist to avoid inserting the same</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="codeLine">    // thing twice.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2118</td>
    <td class="codeLine">    // thing twice.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="codeLine">    SmallPtrSet<BasicBlock *, 16> OnPending;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2119</td>
    <td class="codeLine">    SmallPtrSet<BasicBlock *, 16> OnPending;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Processing Worklist\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2120</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Processing Worklist\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="codeLine">    while (!Worklist.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2121</td>
    <td class="codeLine">    while (!Worklist.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="codeLine">      BasicBlock *BB = OrderToBB[Worklist.top()];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2122</td>
    <td class="codeLine">      BasicBlock *BB = OrderToBB[Worklist.top()];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "\nPop BB " << BB->getName() << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2123</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "\nPop BB " << BB->getName() << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="codeLine">      Worklist.pop();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2124</td>
    <td class="codeLine">      Worklist.pop();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="codeLine">      bool InChanged = join(*BB, Visited);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2125</td>
    <td class="codeLine">      bool InChanged = join(*BB, Visited);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="codeLine">      // Always consider LiveIn changed on the first visit.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2126</td>
    <td class="codeLine">      // Always consider LiveIn changed on the first visit.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="codeLine">      InChanged |= Visited.insert(BB).second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2127</td>
    <td class="codeLine">      InChanged |= Visited.insert(BB).second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="codeLine">      if (InChanged) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2128</td>
    <td class="codeLine">      if (InChanged) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << BB->getName() << " has new InLocs, process it\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2129</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << BB->getName() << " has new InLocs, process it\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="codeLine">        // Mutate a copy of LiveIn while processing BB. After calling process</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2130</td>
    <td class="codeLine">        // Mutate a copy of LiveIn while processing BB. After calling process</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="codeLine">        // LiveSet is the LiveOut set for BB.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2131</td>
    <td class="codeLine">        // LiveSet is the LiveOut set for BB.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="codeLine">        BlockInfo LiveSet = LiveIn[BB];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2132</td>
    <td class="codeLine">        BlockInfo LiveSet = LiveIn[BB];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2133</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="codeLine">        // Process the instructions in the block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2134</td>
    <td class="codeLine">        // Process the instructions in the block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="codeLine">        process(*BB, &LiveSet);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2135</td>
    <td class="codeLine">        process(*BB, &LiveSet);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2136</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="codeLine">        // Relatively expensive check: has anything changed in LiveOut for BB?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2137</td>
    <td class="codeLine">        // Relatively expensive check: has anything changed in LiveOut for BB?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="codeLine">        if (LiveOut[BB] != LiveSet) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2138</td>
    <td class="codeLine">        if (LiveOut[BB] != LiveSet) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="codeLine">          LLVM_DEBUG(dbgs() << BB->getName()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2139</td>
    <td class="codeLine">          LLVM_DEBUG(dbgs() << BB->getName()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="codeLine">                            << " has new OutLocs, add succs to worklist: [ ");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2140</td>
    <td class="codeLine">                            << " has new OutLocs, add succs to worklist: [ ");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="codeLine">          LiveOut[BB] = std::move(LiveSet);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2141</td>
    <td class="codeLine">          LiveOut[BB] = std::move(LiveSet);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="codeLine">          for (auto I = succ_begin(BB), E = succ_end(BB); I != E; I++) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2142</td>
    <td class="codeLine">          for (auto I = succ_begin(BB), E = succ_end(BB); I != E; I++) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="codeLine">            if (OnPending.insert(*I).second) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2143</td>
    <td class="codeLine">            if (OnPending.insert(*I).second) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="codeLine">              LLVM_DEBUG(dbgs() << I->getName() << " ");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2144</td>
    <td class="codeLine">              LLVM_DEBUG(dbgs() << I->getName() << " ");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="codeLine">              Pending.push(BBToOrder[*I]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2145</td>
    <td class="codeLine">              Pending.push(BBToOrder[*I]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="codeLine">            }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2146</td>
    <td class="codeLine">            }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2147</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="codeLine">          LLVM_DEBUG(dbgs() << "]\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2148</td>
    <td class="codeLine">          LLVM_DEBUG(dbgs() << "]\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2149</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2150</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2151</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="codeLine">    Worklist.swap(Pending);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2152</td>
    <td class="codeLine">    Worklist.swap(Pending);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="codeLine">    // At this point, pending must be empty, since it was just the empty</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2153</td>
    <td class="codeLine">    // At this point, pending must be empty, since it was just the empty</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="codeLine">    // worklist</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2154</td>
    <td class="codeLine">    // worklist</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="codeLine">    assert(Pending.empty() && "Pending should be empty");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2155</td>
    <td class="codeLine">    assert(Pending.empty() && "Pending should be empty");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2156</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2157</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="codeLine">  // That's the hard part over. Now we just have some admin to do.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2158</td>
    <td class="codeLine">  // That's the hard part over. Now we just have some admin to do.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2159</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="codeLine">  // Record whether we inserted any intrinsics.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2160</td>
    <td class="codeLine">  // Record whether we inserted any intrinsics.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="codeLine">  bool InsertedAnyIntrinsics = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2161</td>
    <td class="codeLine">  bool InsertedAnyIntrinsics = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2162</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="codeLine">  // Identify and add defs for single location variables.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2163</td>
    <td class="codeLine">  // Identify and add defs for single location variables.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2164</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="codeLine">  // Go through all of the defs that we plan to add. If the aggregate variable</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2165</td>
    <td class="codeLine">  // Go through all of the defs that we plan to add. If the aggregate variable</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="codeLine">  // it's a part of is not in the NotAlwaysStackHomed set we can emit a single</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2166</td>
    <td class="codeLine">  // it's a part of is not in the NotAlwaysStackHomed set we can emit a single</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="codeLine">  // location def and omit the rest. Add an entry to AlwaysStackHomed so that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2167</td>
    <td class="codeLine">  // location def and omit the rest. Add an entry to AlwaysStackHomed so that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="codeLine">  // we can identify those uneeded defs later.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2168</td>
    <td class="codeLine">  // we can identify those uneeded defs later.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="codeLine">  DenseSet<DebugAggregate> AlwaysStackHomed;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2169</td>
    <td class="codeLine">  DenseSet<DebugAggregate> AlwaysStackHomed;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="codeLine">  for (const auto &Pair : InsertBeforeMap) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2170</td>
    <td class="codeLine">  for (const auto &Pair : InsertBeforeMap) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="codeLine">    const auto &Vec = Pair.second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2171</td>
    <td class="codeLine">    const auto &Vec = Pair.second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="codeLine">    for (VarLocInfo VarLoc : Vec) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2172</td>
    <td class="codeLine">    for (VarLocInfo VarLoc : Vec) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="codeLine">      DebugVariable Var = FnVarLocs->getVariable(VarLoc.VariableID);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2173</td>
    <td class="codeLine">      DebugVariable Var = FnVarLocs->getVariable(VarLoc.VariableID);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="codeLine">      DebugAggregate Aggr{Var.getVariable(), Var.getInlinedAt()};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2174</td>
    <td class="codeLine">      DebugAggregate Aggr{Var.getVariable(), Var.getInlinedAt()};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2175</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="codeLine">      // Skip this Var if it's not always stack homed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2176</td>
    <td class="codeLine">      // Skip this Var if it's not always stack homed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="codeLine">      if (NotAlwaysStackHomed.contains(Aggr))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2177</td>
    <td class="codeLine">      if (NotAlwaysStackHomed.contains(Aggr))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2178</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2179</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="codeLine">      // Skip complex cases such as when different fragments of a variable have</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2180</td>
    <td class="codeLine">      // Skip complex cases such as when different fragments of a variable have</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="codeLine">      // been split into different allocas. Skipping in this case means falling</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2181</td>
    <td class="codeLine">      // been split into different allocas. Skipping in this case means falling</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="codeLine">      // back to using a list of defs (which could reduce coverage, but is no</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2182</td>
    <td class="codeLine">      // back to using a list of defs (which could reduce coverage, but is no</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="codeLine">      // less correct).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2183</td>
    <td class="codeLine">      // less correct).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="codeLine">      bool Simple =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2184</td>
    <td class="codeLine">      bool Simple =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="codeLine">          VarLoc.Expr->getNumElements() == 1 && VarLoc.Expr->startsWithDeref();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2185</td>
    <td class="codeLine">          VarLoc.Expr->getNumElements() == 1 && VarLoc.Expr->startsWithDeref();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="codeLine">      if (!Simple) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2186</td>
    <td class="codeLine">      if (!Simple) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="codeLine">        NotAlwaysStackHomed.insert(Aggr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2187</td>
    <td class="codeLine">        NotAlwaysStackHomed.insert(Aggr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2188</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2189</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2190</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="codeLine">      // All source assignments to this variable remain and all stores to any</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2191</td>
    <td class="codeLine">      // All source assignments to this variable remain and all stores to any</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="codeLine">      // part of the variable store to the same address (with varying</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2192</td>
    <td class="codeLine">      // part of the variable store to the same address (with varying</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="codeLine">      // offsets). We can just emit a single location for the whole variable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2193</td>
    <td class="codeLine">      // offsets). We can just emit a single location for the whole variable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="codeLine">      //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2194</td>
    <td class="codeLine">      //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="codeLine">      // Unless we've already done so, create the single location def now.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2195</td>
    <td class="codeLine">      // Unless we've already done so, create the single location def now.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="codeLine">      if (AlwaysStackHomed.insert(Aggr).second) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2196</td>
    <td class="codeLine">      if (AlwaysStackHomed.insert(Aggr).second) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="codeLine">        assert(!VarLoc.Values.hasArgList());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2197</td>
    <td class="codeLine">        assert(!VarLoc.Values.hasArgList());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="codeLine">        // TODO: When more complex cases are handled VarLoc.Expr should be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2198</td>
    <td class="codeLine">        // TODO: When more complex cases are handled VarLoc.Expr should be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="codeLine">        // built appropriately rather than always using an empty DIExpression.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2199</td>
    <td class="codeLine">        // built appropriately rather than always using an empty DIExpression.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="codeLine">        // The assert below is a reminder.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2200</td>
    <td class="codeLine">        // The assert below is a reminder.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="codeLine">        assert(Simple);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2201</td>
    <td class="codeLine">        assert(Simple);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="codeLine">        VarLoc.Expr = DIExpression::get(Fn.getContext(), std::nullopt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2202</td>
    <td class="codeLine">        VarLoc.Expr = DIExpression::get(Fn.getContext(), std::nullopt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="codeLine">        DebugVariable Var = FnVarLocs->getVariable(VarLoc.VariableID);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2203</td>
    <td class="codeLine">        DebugVariable Var = FnVarLocs->getVariable(VarLoc.VariableID);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="codeLine">        FnVarLocs->addSingleLocVar(Var, VarLoc.Expr, VarLoc.DL, VarLoc.Values);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2204</td>
    <td class="codeLine">        FnVarLocs->addSingleLocVar(Var, VarLoc.Expr, VarLoc.DL, VarLoc.Values);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="codeLine">        InsertedAnyIntrinsics = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2205</td>
    <td class="codeLine">        InsertedAnyIntrinsics = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2206</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2207</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2208</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2209</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="codeLine">  // Insert the other DEFs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2210</td>
    <td class="codeLine">  // Insert the other DEFs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="codeLine">  for (const auto &[InsertBefore, Vec] : InsertBeforeMap) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2211</td>
    <td class="codeLine">  for (const auto &[InsertBefore, Vec] : InsertBeforeMap) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="codeLine">    SmallVector<VarLocInfo> NewDefs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2212</td>
    <td class="codeLine">    SmallVector<VarLocInfo> NewDefs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="codeLine">    for (const VarLocInfo &VarLoc : Vec) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2213</td>
    <td class="codeLine">    for (const VarLocInfo &VarLoc : Vec) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="codeLine">      DebugVariable Var = FnVarLocs->getVariable(VarLoc.VariableID);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2214</td>
    <td class="codeLine">      DebugVariable Var = FnVarLocs->getVariable(VarLoc.VariableID);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="codeLine">      DebugAggregate Aggr{Var.getVariable(), Var.getInlinedAt()};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2215</td>
    <td class="codeLine">      DebugAggregate Aggr{Var.getVariable(), Var.getInlinedAt()};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="codeLine">      // If this variable is always stack homed then we have already inserted a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2216</td>
    <td class="codeLine">      // If this variable is always stack homed then we have already inserted a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="codeLine">      // dbg.declare and deleted this dbg.value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2217</td>
    <td class="codeLine">      // dbg.declare and deleted this dbg.value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="codeLine">      if (AlwaysStackHomed.contains(Aggr))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2218</td>
    <td class="codeLine">      if (AlwaysStackHomed.contains(Aggr))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2219</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="codeLine">      NewDefs.push_back(VarLoc);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2220</td>
    <td class="codeLine">      NewDefs.push_back(VarLoc);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="codeLine">      InsertedAnyIntrinsics = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2221</td>
    <td class="codeLine">      InsertedAnyIntrinsics = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2222</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2223</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="codeLine">    FnVarLocs->setWedge(InsertBefore, std::move(NewDefs));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2224</td>
    <td class="codeLine">    FnVarLocs->setWedge(InsertBefore, std::move(NewDefs));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2225</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2226</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="codeLine">  InsertedAnyIntrinsics |= emitPromotedVarLocs(FnVarLocs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2227</td>
    <td class="codeLine">  InsertedAnyIntrinsics |= emitPromotedVarLocs(FnVarLocs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2228</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="codeLine">  return InsertedAnyIntrinsics;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2229</td>
    <td class="codeLine">  return InsertedAnyIntrinsics;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2230</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2231</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="codeLine">bool AssignmentTrackingLowering::emitPromotedVarLocs(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2232</td>
    <td class="codeLine">bool AssignmentTrackingLowering::emitPromotedVarLocs(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="codeLine">    FunctionVarLocsBuilder *FnVarLocs) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2233</td>
    <td class="codeLine">    FunctionVarLocsBuilder *FnVarLocs) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="codeLine">  bool InsertedAnyIntrinsics = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2234</td>
    <td class="codeLine">  bool InsertedAnyIntrinsics = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="codeLine">  // Go through every block, translating debug intrinsics for fully promoted</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2235</td>
    <td class="codeLine">  // Go through every block, translating debug intrinsics for fully promoted</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="codeLine">  // variables into FnVarLocs location defs. No analysis required for these.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2236</td>
    <td class="codeLine">  // variables into FnVarLocs location defs. No analysis required for these.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="codeLine">  for (auto &BB : Fn) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2237</td>
    <td class="codeLine">  for (auto &BB : Fn) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="codeLine">    for (auto &I : BB) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2238</td>
    <td class="codeLine">    for (auto &I : BB) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="codeLine">      // Skip instructions other than dbg.values and dbg.assigns.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2239</td>
    <td class="codeLine">      // Skip instructions other than dbg.values and dbg.assigns.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="codeLine">      auto *DVI = dyn_cast<DbgValueInst>(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2240</td>
    <td class="codeLine">      auto *DVI = dyn_cast<DbgValueInst>(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="codeLine">      if (!DVI)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2241</td>
    <td class="codeLine">      if (!DVI)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2242</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="codeLine">      // Skip variables that haven't been promoted - we've dealt with those</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2243</td>
    <td class="codeLine">      // Skip variables that haven't been promoted - we've dealt with those</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="codeLine">      // already.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2244</td>
    <td class="codeLine">      // already.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="codeLine">      if (VarsWithStackSlot->contains(getAggregate(DVI)))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2245</td>
    <td class="codeLine">      if (VarsWithStackSlot->contains(getAggregate(DVI)))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2246</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="codeLine">      Instruction *InsertBefore = I.getNextNode();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2247</td>
    <td class="codeLine">      Instruction *InsertBefore = I.getNextNode();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="codeLine">      assert(InsertBefore && "Unexpected: debug intrinsics after a terminator");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2248</td>
    <td class="codeLine">      assert(InsertBefore && "Unexpected: debug intrinsics after a terminator");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="codeLine">      FnVarLocs->addVarLoc(InsertBefore, DebugVariable(DVI),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2249</td>
    <td class="codeLine">      FnVarLocs->addVarLoc(InsertBefore, DebugVariable(DVI),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="codeLine">                           DVI->getExpression(), DVI->getDebugLoc(),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2250</td>
    <td class="codeLine">                           DVI->getExpression(), DVI->getDebugLoc(),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="codeLine">                           DVI->getWrappedLocation());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2251</td>
    <td class="codeLine">                           DVI->getWrappedLocation());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="codeLine">      InsertedAnyIntrinsics = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2252</td>
    <td class="codeLine">      InsertedAnyIntrinsics = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2253</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2254</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="codeLine">  return InsertedAnyIntrinsics;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2255</td>
    <td class="codeLine">  return InsertedAnyIntrinsics;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2256</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2257</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="codeLine">/// Remove redundant definitions within sequences of consecutive location defs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2258</td>
    <td class="codeLine">/// Remove redundant definitions within sequences of consecutive location defs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="codeLine">/// This is done using a backward scan to keep the last def describing a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2259</td>
    <td class="codeLine">/// This is done using a backward scan to keep the last def describing a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="codeLine">/// specific variable/fragment.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2260</td>
    <td class="codeLine">/// specific variable/fragment.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2261</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="codeLine">/// This implements removeRedundantDbgInstrsUsingBackwardScan from</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2262</td>
    <td class="codeLine">/// This implements removeRedundantDbgInstrsUsingBackwardScan from</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="codeLine">/// lib/Transforms/Utils/BasicBlockUtils.cpp for locations described with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2263</td>
    <td class="codeLine">/// lib/Transforms/Utils/BasicBlockUtils.cpp for locations described with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="codeLine">/// FunctionVarLocsBuilder instead of with intrinsics.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2264</td>
    <td class="codeLine">/// FunctionVarLocsBuilder instead of with intrinsics.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="codeLine">static bool</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2265</td>
    <td class="codeLine">static bool</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="codeLine">removeRedundantDbgLocsUsingBackwardScan(const BasicBlock *BB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2266</td>
    <td class="codeLine">removeRedundantDbgLocsUsingBackwardScan(const BasicBlock *BB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="codeLine">                                        FunctionVarLocsBuilder &FnVarLocs) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2267</td>
    <td class="codeLine">                                        FunctionVarLocsBuilder &FnVarLocs) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2268</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="codeLine">  SmallDenseMap<DebugAggregate, BitVector> VariableDefinedBits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2269</td>
    <td class="codeLine">  SmallDenseMap<DebugAggregate, BitVector> VariableDefinedBits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="codeLine">  // Scan over the entire block, not just over the instructions mapped by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2270</td>
    <td class="codeLine">  // Scan over the entire block, not just over the instructions mapped by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="codeLine">  // FnVarLocs, because wedges in FnVarLocs may only be seperated by debug</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2271</td>
    <td class="codeLine">  // FnVarLocs, because wedges in FnVarLocs may only be seperated by debug</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="codeLine">  // instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2272</td>
    <td class="codeLine">  // instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="codeLine">  for (const Instruction &I : reverse(*BB)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2273</td>
    <td class="codeLine">  for (const Instruction &I : reverse(*BB)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="codeLine">    if (!isa<DbgVariableIntrinsic>(I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2274</td>
    <td class="codeLine">    if (!isa<DbgVariableIntrinsic>(I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="codeLine">      // Sequence of consecutive defs ended. Clear map for the next one.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2275</td>
    <td class="codeLine">      // Sequence of consecutive defs ended. Clear map for the next one.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="codeLine">      VariableDefinedBits.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2276</td>
    <td class="codeLine">      VariableDefinedBits.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2277</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2278</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="codeLine">    // Get the location defs that start just before this instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2279</td>
    <td class="codeLine">    // Get the location defs that start just before this instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="codeLine">    const auto *Locs = FnVarLocs.getWedge(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2280</td>
    <td class="codeLine">    const auto *Locs = FnVarLocs.getWedge(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="codeLine">    if (!Locs)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2281</td>
    <td class="codeLine">    if (!Locs)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2282</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2283</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="codeLine">    NumWedgesScanned++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2284</td>
    <td class="codeLine">    NumWedgesScanned++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="codeLine">    bool ChangedThisWedge = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2285</td>
    <td class="codeLine">    bool ChangedThisWedge = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="codeLine">    // The new pruned set of defs, reversed because we're scanning backwards.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2286</td>
    <td class="codeLine">    // The new pruned set of defs, reversed because we're scanning backwards.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="codeLine">    SmallVector<VarLocInfo> NewDefsReversed;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2287</td>
    <td class="codeLine">    SmallVector<VarLocInfo> NewDefsReversed;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2288</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="codeLine">    // Iterate over the existing defs in reverse.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2289</td>
    <td class="codeLine">    // Iterate over the existing defs in reverse.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="codeLine">    for (auto RIt = Locs->rbegin(), REnd = Locs->rend(); RIt != REnd; ++RIt) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2290</td>
    <td class="codeLine">    for (auto RIt = Locs->rbegin(), REnd = Locs->rend(); RIt != REnd; ++RIt) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="codeLine">      NumDefsScanned++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2291</td>
    <td class="codeLine">      NumDefsScanned++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="codeLine">      DebugAggregate Aggr =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2292</td>
    <td class="codeLine">      DebugAggregate Aggr =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="codeLine">          getAggregate(FnVarLocs.getVariable(RIt->VariableID));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2293</td>
    <td class="codeLine">          getAggregate(FnVarLocs.getVariable(RIt->VariableID));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="codeLine">      uint64_t SizeInBits = Aggr.first->getSizeInBits().value_or(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2294</td>
    <td class="codeLine">      uint64_t SizeInBits = Aggr.first->getSizeInBits().value_or(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2295</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="codeLine">      if (SizeInBits == 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2296</td>
    <td class="codeLine">      if (SizeInBits == 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="codeLine">        // If the size is unknown (0) then keep this location def to be safe.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2297</td>
    <td class="codeLine">        // If the size is unknown (0) then keep this location def to be safe.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="codeLine">        NewDefsReversed.push_back(*RIt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2298</td>
    <td class="codeLine">        NewDefsReversed.push_back(*RIt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2299</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2300</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2301</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="codeLine">      // Only keep this location definition if it is not fully eclipsed by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2302</td>
    <td class="codeLine">      // Only keep this location definition if it is not fully eclipsed by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="codeLine">      // other definitions in this wedge that come after it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2303</td>
    <td class="codeLine">      // other definitions in this wedge that come after it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2304</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="codeLine">      // Inert the bits the location definition defines.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2305</td>
    <td class="codeLine">      // Inert the bits the location definition defines.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="codeLine">      auto InsertResult =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2306</td>
    <td class="codeLine">      auto InsertResult =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="codeLine">          VariableDefinedBits.try_emplace(Aggr, BitVector(SizeInBits));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2307</td>
    <td class="codeLine">          VariableDefinedBits.try_emplace(Aggr, BitVector(SizeInBits));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="codeLine">      bool FirstDefinition = InsertResult.second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2308</td>
    <td class="codeLine">      bool FirstDefinition = InsertResult.second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="codeLine">      BitVector &DefinedBits = InsertResult.first->second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2309</td>
    <td class="codeLine">      BitVector &DefinedBits = InsertResult.first->second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2310</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="codeLine">      DIExpression::FragmentInfo Fragment =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2311</td>
    <td class="codeLine">      DIExpression::FragmentInfo Fragment =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="codeLine">          RIt->Expr->getFragmentInfo().value_or(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2312</td>
    <td class="codeLine">          RIt->Expr->getFragmentInfo().value_or(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="codeLine">              DIExpression::FragmentInfo(SizeInBits, 0));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2313</td>
    <td class="codeLine">              DIExpression::FragmentInfo(SizeInBits, 0));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="codeLine">      bool InvalidFragment = Fragment.endInBits() > SizeInBits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2314</td>
    <td class="codeLine">      bool InvalidFragment = Fragment.endInBits() > SizeInBits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2315</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="codeLine">      // If this defines any previously undefined bits, keep it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2316</td>
    <td class="codeLine">      // If this defines any previously undefined bits, keep it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="codeLine">      if (FirstDefinition || InvalidFragment ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2317</td>
    <td class="codeLine">      if (FirstDefinition || InvalidFragment ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="codeLine">          DefinedBits.find_first_unset_in(Fragment.startInBits(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2318</td>
    <td class="codeLine">          DefinedBits.find_first_unset_in(Fragment.startInBits(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="codeLine">                                          Fragment.endInBits()) != -1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2319</td>
    <td class="codeLine">                                          Fragment.endInBits()) != -1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="codeLine">        if (!InvalidFragment)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2320</td>
    <td class="codeLine">        if (!InvalidFragment)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="codeLine">          DefinedBits.set(Fragment.startInBits(), Fragment.endInBits());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2321</td>
    <td class="codeLine">          DefinedBits.set(Fragment.startInBits(), Fragment.endInBits());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="codeLine">        NewDefsReversed.push_back(*RIt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2322</td>
    <td class="codeLine">        NewDefsReversed.push_back(*RIt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2323</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2324</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2325</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="codeLine">      // Redundant def found: throw it away. Since the wedge of defs is being</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2326</td>
    <td class="codeLine">      // Redundant def found: throw it away. Since the wedge of defs is being</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="codeLine">      // rebuilt, doing nothing is the same as deleting an entry.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2327</td>
    <td class="codeLine">      // rebuilt, doing nothing is the same as deleting an entry.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="codeLine">      ChangedThisWedge = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2328</td>
    <td class="codeLine">      ChangedThisWedge = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="codeLine">      NumDefsRemoved++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2329</td>
    <td class="codeLine">      NumDefsRemoved++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2330</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2331</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="codeLine">    // Un-reverse the defs and replace the wedge with the pruned version.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2332</td>
    <td class="codeLine">    // Un-reverse the defs and replace the wedge with the pruned version.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="codeLine">    if (ChangedThisWedge) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2333</td>
    <td class="codeLine">    if (ChangedThisWedge) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="codeLine">      std::reverse(NewDefsReversed.begin(), NewDefsReversed.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2334</td>
    <td class="codeLine">      std::reverse(NewDefsReversed.begin(), NewDefsReversed.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="codeLine">      FnVarLocs.setWedge(&I, std::move(NewDefsReversed));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2335</td>
    <td class="codeLine">      FnVarLocs.setWedge(&I, std::move(NewDefsReversed));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="codeLine">      NumWedgesChanged++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2336</td>
    <td class="codeLine">      NumWedgesChanged++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="codeLine">      Changed = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2337</td>
    <td class="codeLine">      Changed = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2338</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2339</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2340</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2341</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2342</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2343</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="codeLine">/// Remove redundant location defs using a forward scan. This can remove a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2344</td>
    <td class="codeLine">/// Remove redundant location defs using a forward scan. This can remove a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="codeLine">/// location definition that is redundant due to indicating that a variable has</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2345</td>
    <td class="codeLine">/// location definition that is redundant due to indicating that a variable has</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="codeLine">/// the same value as is already being indicated by an earlier def.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2346</td>
    <td class="codeLine">/// the same value as is already being indicated by an earlier def.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2347</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="codeLine">/// This implements removeRedundantDbgInstrsUsingForwardScan from</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2348</td>
    <td class="codeLine">/// This implements removeRedundantDbgInstrsUsingForwardScan from</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="codeLine">/// lib/Transforms/Utils/BasicBlockUtils.cpp for locations described with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2349</td>
    <td class="codeLine">/// lib/Transforms/Utils/BasicBlockUtils.cpp for locations described with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="codeLine">/// FunctionVarLocsBuilder instead of with intrinsics</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2350</td>
    <td class="codeLine">/// FunctionVarLocsBuilder instead of with intrinsics</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="codeLine">static bool</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2351</td>
    <td class="codeLine">static bool</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="codeLine">removeRedundantDbgLocsUsingForwardScan(const BasicBlock *BB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2352</td>
    <td class="codeLine">removeRedundantDbgLocsUsingForwardScan(const BasicBlock *BB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="codeLine">                                       FunctionVarLocsBuilder &FnVarLocs) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2353</td>
    <td class="codeLine">                                       FunctionVarLocsBuilder &FnVarLocs) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2354</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="codeLine">  DenseMap<DebugVariable, std::pair<RawLocationWrapper, DIExpression *>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2355</td>
    <td class="codeLine">  DenseMap<DebugVariable, std::pair<RawLocationWrapper, DIExpression *>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="codeLine">      VariableMap;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2356</td>
    <td class="codeLine">      VariableMap;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2357</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="codeLine">  // Scan over the entire block, not just over the instructions mapped by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2358</td>
    <td class="codeLine">  // Scan over the entire block, not just over the instructions mapped by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="codeLine">  // FnVarLocs, because wedges in FnVarLocs may only be seperated by debug</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2359</td>
    <td class="codeLine">  // FnVarLocs, because wedges in FnVarLocs may only be seperated by debug</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="codeLine">  // instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2360</td>
    <td class="codeLine">  // instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="codeLine">  for (const Instruction &I : *BB) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2361</td>
    <td class="codeLine">  for (const Instruction &I : *BB) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="codeLine">    // Get the defs that come just before this instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2362</td>
    <td class="codeLine">    // Get the defs that come just before this instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="codeLine">    const auto *Locs = FnVarLocs.getWedge(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2363</td>
    <td class="codeLine">    const auto *Locs = FnVarLocs.getWedge(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="codeLine">    if (!Locs)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2364</td>
    <td class="codeLine">    if (!Locs)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2365</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2366</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="codeLine">    NumWedgesScanned++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2367</td>
    <td class="codeLine">    NumWedgesScanned++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="codeLine">    bool ChangedThisWedge = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2368</td>
    <td class="codeLine">    bool ChangedThisWedge = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="codeLine">    // The new pruned set of defs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2369</td>
    <td class="codeLine">    // The new pruned set of defs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="codeLine">    SmallVector<VarLocInfo> NewDefs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2370</td>
    <td class="codeLine">    SmallVector<VarLocInfo> NewDefs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2371</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="codeLine">    // Iterate over the existing defs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2372</td>
    <td class="codeLine">    // Iterate over the existing defs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="codeLine">    for (const VarLocInfo &Loc : *Locs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2373</td>
    <td class="codeLine">    for (const VarLocInfo &Loc : *Locs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="codeLine">      NumDefsScanned++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2374</td>
    <td class="codeLine">      NumDefsScanned++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="codeLine">      DebugVariable Key(FnVarLocs.getVariable(Loc.VariableID).getVariable(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2375</td>
    <td class="codeLine">      DebugVariable Key(FnVarLocs.getVariable(Loc.VariableID).getVariable(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="codeLine">                        std::nullopt, Loc.DL.getInlinedAt());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2376</td>
    <td class="codeLine">                        std::nullopt, Loc.DL.getInlinedAt());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="codeLine">      auto VMI = VariableMap.find(Key);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2377</td>
    <td class="codeLine">      auto VMI = VariableMap.find(Key);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2378</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="codeLine">      // Update the map if we found a new value/expression describing the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2379</td>
    <td class="codeLine">      // Update the map if we found a new value/expression describing the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="codeLine">      // variable, or if the variable wasn't mapped already.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2380</td>
    <td class="codeLine">      // variable, or if the variable wasn't mapped already.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="codeLine">      if (VMI == VariableMap.end() || VMI->second.first != Loc.Values ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2381</td>
    <td class="codeLine">      if (VMI == VariableMap.end() || VMI->second.first != Loc.Values ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="codeLine">          VMI->second.second != Loc.Expr) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2382</td>
    <td class="codeLine">          VMI->second.second != Loc.Expr) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="codeLine">        VariableMap[Key] = {Loc.Values, Loc.Expr};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2383</td>
    <td class="codeLine">        VariableMap[Key] = {Loc.Values, Loc.Expr};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="codeLine">        NewDefs.push_back(Loc);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2384</td>
    <td class="codeLine">        NewDefs.push_back(Loc);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2385</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2386</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2387</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="codeLine">      // Did not insert this Loc, which is the same as removing it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2388</td>
    <td class="codeLine">      // Did not insert this Loc, which is the same as removing it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="codeLine">      ChangedThisWedge = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2389</td>
    <td class="codeLine">      ChangedThisWedge = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="codeLine">      NumDefsRemoved++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2390</td>
    <td class="codeLine">      NumDefsRemoved++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2391</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2392</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="codeLine">    // Replace the existing wedge with the pruned version.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2393</td>
    <td class="codeLine">    // Replace the existing wedge with the pruned version.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="codeLine">    if (ChangedThisWedge) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2394</td>
    <td class="codeLine">    if (ChangedThisWedge) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="codeLine">      FnVarLocs.setWedge(&I, std::move(NewDefs));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2395</td>
    <td class="codeLine">      FnVarLocs.setWedge(&I, std::move(NewDefs));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="codeLine">      NumWedgesChanged++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2396</td>
    <td class="codeLine">      NumWedgesChanged++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="codeLine">      Changed = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2397</td>
    <td class="codeLine">      Changed = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2398</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2399</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2400</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2401</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2402</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2403</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="codeLine">static bool</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2404</td>
    <td class="codeLine">static bool</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="codeLine">removeUndefDbgLocsFromEntryBlock(const BasicBlock *BB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2405</td>
    <td class="codeLine">removeUndefDbgLocsFromEntryBlock(const BasicBlock *BB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="codeLine">                                 FunctionVarLocsBuilder &FnVarLocs) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2406</td>
    <td class="codeLine">                                 FunctionVarLocsBuilder &FnVarLocs) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="codeLine">  assert(BB->isEntryBlock());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2407</td>
    <td class="codeLine">  assert(BB->isEntryBlock());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="codeLine">  // Do extra work to ensure that we remove semantically unimportant undefs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2408</td>
    <td class="codeLine">  // Do extra work to ensure that we remove semantically unimportant undefs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2409</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="codeLine">  // This is to work around the fact that SelectionDAG will hoist dbg.values</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2410</td>
    <td class="codeLine">  // This is to work around the fact that SelectionDAG will hoist dbg.values</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="codeLine">  // using argument values to the top of the entry block. That can move arg</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2411</td>
    <td class="codeLine">  // using argument values to the top of the entry block. That can move arg</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="codeLine">  // dbg.values before undef and constant dbg.values which they previously</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2412</td>
    <td class="codeLine">  // dbg.values before undef and constant dbg.values which they previously</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="codeLine">  // followed. The easiest thing to do is to just try to feed SelectionDAG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2413</td>
    <td class="codeLine">  // followed. The easiest thing to do is to just try to feed SelectionDAG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="codeLine">  // input it's happy with.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2414</td>
    <td class="codeLine">  // input it's happy with.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2415</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="codeLine">  // Map of {Variable x: Fragments y} where the fragments y of variable x have</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2416</td>
    <td class="codeLine">  // Map of {Variable x: Fragments y} where the fragments y of variable x have</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="codeLine">  // have at least one non-undef location defined already. Don't use directly,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2417</td>
    <td class="codeLine">  // have at least one non-undef location defined already. Don't use directly,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="codeLine">  // instead call DefineBits and HasDefinedBits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2418</td>
    <td class="codeLine">  // instead call DefineBits and HasDefinedBits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="codeLine">  SmallDenseMap<DebugAggregate, SmallDenseSet<DIExpression::FragmentInfo>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2419</td>
    <td class="codeLine">  SmallDenseMap<DebugAggregate, SmallDenseSet<DIExpression::FragmentInfo>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="codeLine">      VarsWithDef;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2420</td>
    <td class="codeLine">      VarsWithDef;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="codeLine">  // Specify that V (a fragment of A) has a non-undef location.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2421</td>
    <td class="codeLine">  // Specify that V (a fragment of A) has a non-undef location.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="codeLine">  auto DefineBits = [&VarsWithDef](DebugAggregate A, DebugVariable V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2422</td>
    <td class="codeLine">  auto DefineBits = [&VarsWithDef](DebugAggregate A, DebugVariable V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="codeLine">    VarsWithDef[A].insert(V.getFragmentOrDefault());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2423</td>
    <td class="codeLine">    VarsWithDef[A].insert(V.getFragmentOrDefault());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2424</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="codeLine">  // Return true if a non-undef location has been defined for V (a fragment of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2425</td>
    <td class="codeLine">  // Return true if a non-undef location has been defined for V (a fragment of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="codeLine">  // A). Doesn't imply that the location is currently non-undef, just that a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2426</td>
    <td class="codeLine">  // A). Doesn't imply that the location is currently non-undef, just that a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="codeLine">  // non-undef location has been seen previously.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2427</td>
    <td class="codeLine">  // non-undef location has been seen previously.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="codeLine">  auto HasDefinedBits = [&VarsWithDef](DebugAggregate A, DebugVariable V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2428</td>
    <td class="codeLine">  auto HasDefinedBits = [&VarsWithDef](DebugAggregate A, DebugVariable V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="codeLine">    auto FragsIt = VarsWithDef.find(A);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2429</td>
    <td class="codeLine">    auto FragsIt = VarsWithDef.find(A);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="codeLine">    if (FragsIt == VarsWithDef.end())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2430</td>
    <td class="codeLine">    if (FragsIt == VarsWithDef.end())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2431</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="codeLine">    return llvm::any_of(FragsIt->second, [V](auto Frag) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2432</td>
    <td class="codeLine">    return llvm::any_of(FragsIt->second, [V](auto Frag) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="codeLine">      return DIExpression::fragmentsOverlap(Frag, V.getFragmentOrDefault());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2433</td>
    <td class="codeLine">      return DIExpression::fragmentsOverlap(Frag, V.getFragmentOrDefault());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2434</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2435</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2436</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2437</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="codeLine">  DenseMap<DebugVariable, std::pair<Value *, DIExpression *>> VariableMap;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2438</td>
    <td class="codeLine">  DenseMap<DebugVariable, std::pair<Value *, DIExpression *>> VariableMap;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2439</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="codeLine">  // Scan over the entire block, not just over the instructions mapped by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2440</td>
    <td class="codeLine">  // Scan over the entire block, not just over the instructions mapped by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="codeLine">  // FnVarLocs, because wedges in FnVarLocs may only be seperated by debug</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2441</td>
    <td class="codeLine">  // FnVarLocs, because wedges in FnVarLocs may only be seperated by debug</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="codeLine">  // instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2442</td>
    <td class="codeLine">  // instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="codeLine">  for (const Instruction &I : *BB) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2443</td>
    <td class="codeLine">  for (const Instruction &I : *BB) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="codeLine">    // Get the defs that come just before this instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2444</td>
    <td class="codeLine">    // Get the defs that come just before this instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="codeLine">    const auto *Locs = FnVarLocs.getWedge(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2445</td>
    <td class="codeLine">    const auto *Locs = FnVarLocs.getWedge(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="codeLine">    if (!Locs)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2446</td>
    <td class="codeLine">    if (!Locs)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2447</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2448</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="codeLine">    NumWedgesScanned++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2449</td>
    <td class="codeLine">    NumWedgesScanned++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="codeLine">    bool ChangedThisWedge = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2450</td>
    <td class="codeLine">    bool ChangedThisWedge = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="codeLine">    // The new pruned set of defs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2451</td>
    <td class="codeLine">    // The new pruned set of defs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="codeLine">    SmallVector<VarLocInfo> NewDefs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2452</td>
    <td class="codeLine">    SmallVector<VarLocInfo> NewDefs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2453</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="codeLine">    // Iterate over the existing defs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2454</td>
    <td class="codeLine">    // Iterate over the existing defs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="codeLine">    for (const VarLocInfo &Loc : *Locs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2455</td>
    <td class="codeLine">    for (const VarLocInfo &Loc : *Locs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="codeLine">      NumDefsScanned++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2456</td>
    <td class="codeLine">      NumDefsScanned++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="codeLine">      DebugAggregate Aggr{FnVarLocs.getVariable(Loc.VariableID).getVariable(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2457</td>
    <td class="codeLine">      DebugAggregate Aggr{FnVarLocs.getVariable(Loc.VariableID).getVariable(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="codeLine">                          Loc.DL.getInlinedAt()};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2458</td>
    <td class="codeLine">                          Loc.DL.getInlinedAt()};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="codeLine">      DebugVariable Var = FnVarLocs.getVariable(Loc.VariableID);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2459</td>
    <td class="codeLine">      DebugVariable Var = FnVarLocs.getVariable(Loc.VariableID);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2460</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="codeLine">      // Remove undef entries that are encountered before any non-undef</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2461</td>
    <td class="codeLine">      // Remove undef entries that are encountered before any non-undef</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="codeLine">      // intrinsics from the entry block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2462</td>
    <td class="codeLine">      // intrinsics from the entry block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="codeLine">      if (Loc.Values.isKillLocation(Loc.Expr) && !HasDefinedBits(Aggr, Var)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2463</td>
    <td class="codeLine">      if (Loc.Values.isKillLocation(Loc.Expr) && !HasDefinedBits(Aggr, Var)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="codeLine">        // Did not insert this Loc, which is the same as removing it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2464</td>
    <td class="codeLine">        // Did not insert this Loc, which is the same as removing it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="codeLine">        NumDefsRemoved++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2465</td>
    <td class="codeLine">        NumDefsRemoved++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="codeLine">        ChangedThisWedge = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2466</td>
    <td class="codeLine">        ChangedThisWedge = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2467</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2468</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2469</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="codeLine">      DefineBits(Aggr, Var);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2470</td>
    <td class="codeLine">      DefineBits(Aggr, Var);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="codeLine">      NewDefs.push_back(Loc);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2471</td>
    <td class="codeLine">      NewDefs.push_back(Loc);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2472</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2473</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="codeLine">    // Replace the existing wedge with the pruned version.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2474</td>
    <td class="codeLine">    // Replace the existing wedge with the pruned version.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2475</td>
    <td class="codeLine">    if (ChangedThisWedge) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2475</td>
    <td class="codeLine">    if (ChangedThisWedge) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2476</td>
    <td class="codeLine">      FnVarLocs.setWedge(&I, std::move(NewDefs));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2476</td>
    <td class="codeLine">      FnVarLocs.setWedge(&I, std::move(NewDefs));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2477</td>
    <td class="codeLine">      NumWedgesChanged++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2477</td>
    <td class="codeLine">      NumWedgesChanged++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2478</td>
    <td class="codeLine">      Changed = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2478</td>
    <td class="codeLine">      Changed = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2479</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2479</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2480</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2480</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2481</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2481</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2482</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2482</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2483</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2483</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2484</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2484</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2485</td>
    <td class="codeLine">static bool removeRedundantDbgLocs(const BasicBlock *BB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2485</td>
    <td class="codeLine">static bool removeRedundantDbgLocs(const BasicBlock *BB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2486</td>
    <td class="codeLine">                                   FunctionVarLocsBuilder &FnVarLocs) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2486</td>
    <td class="codeLine">                                   FunctionVarLocsBuilder &FnVarLocs) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2487</td>
    <td class="codeLine">  bool MadeChanges = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2487</td>
    <td class="codeLine">  bool MadeChanges = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2488</td>
    <td class="codeLine">  MadeChanges |= removeRedundantDbgLocsUsingBackwardScan(BB, FnVarLocs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2488</td>
    <td class="codeLine">  MadeChanges |= removeRedundantDbgLocsUsingBackwardScan(BB, FnVarLocs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2489</td>
    <td class="codeLine">  if (BB->isEntryBlock())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2489</td>
    <td class="codeLine">  if (BB->isEntryBlock())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2490</td>
    <td class="codeLine">    MadeChanges |= removeUndefDbgLocsFromEntryBlock(BB, FnVarLocs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2490</td>
    <td class="codeLine">    MadeChanges |= removeUndefDbgLocsFromEntryBlock(BB, FnVarLocs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2491</td>
    <td class="codeLine">  MadeChanges |= removeRedundantDbgLocsUsingForwardScan(BB, FnVarLocs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2491</td>
    <td class="codeLine">  MadeChanges |= removeRedundantDbgLocsUsingForwardScan(BB, FnVarLocs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2492</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2492</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2493</td>
    <td class="codeLine">  if (MadeChanges)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2493</td>
    <td class="codeLine">  if (MadeChanges)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2494</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Removed redundant dbg locs from: " << BB->getName()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2494</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Removed redundant dbg locs from: " << BB->getName()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2495</td>
    <td class="codeLine">                      << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2495</td>
    <td class="codeLine">                      << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2496</td>
    <td class="codeLine">  return MadeChanges;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2496</td>
    <td class="codeLine">  return MadeChanges;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2497</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2497</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2498</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2498</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2499</td>
    <td class="codeLine">static DenseSet<DebugAggregate> findVarsWithStackSlot(Function &Fn) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2499</td>
    <td class="codeLine">static DenseSet<DebugAggregate> findVarsWithStackSlot(Function &Fn) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2500</td>
    <td class="codeLine">  DenseSet<DebugAggregate> Result;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2500</td>
    <td class="codeLine">  DenseSet<DebugAggregate> Result;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2501</td>
    <td class="codeLine">  for (auto &BB : Fn) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2501</td>
    <td class="codeLine">  for (auto &BB : Fn) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2502</td>
    <td class="codeLine">    for (auto &I : BB) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2502</td>
    <td class="codeLine">    for (auto &I : BB) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2503</td>
    <td class="codeLine">      // Any variable linked to an instruction is considered</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2503</td>
    <td class="codeLine">      // Any variable linked to an instruction is considered</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2504</td>
    <td class="codeLine">      // interesting. Ideally we only need to check Allocas, however, a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2504</td>
    <td class="codeLine">      // interesting. Ideally we only need to check Allocas, however, a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2505</td>
    <td class="codeLine">      // DIAssignID might get dropped from an alloca but not stores. In that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2505</td>
    <td class="codeLine">      // DIAssignID might get dropped from an alloca but not stores. In that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2506</td>
    <td class="codeLine">      // case, we need to consider the variable interesting for NFC behaviour</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2506</td>
    <td class="codeLine">      // case, we need to consider the variable interesting for NFC behaviour</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2507</td>
    <td class="codeLine">      // with this change. TODO: Consider only looking at allocas.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2507</td>
    <td class="codeLine">      // with this change. TODO: Consider only looking at allocas.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2508</td>
    <td class="codeLine">      for (DbgAssignIntrinsic *DAI : at::getAssignmentMarkers(&I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2508</td>
    <td class="codeLine">      for (DbgAssignIntrinsic *DAI : at::getAssignmentMarkers(&I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2509</td>
    <td class="codeLine">        Result.insert({DAI->getVariable(), DAI->getDebugLoc().getInlinedAt()});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2509</td>
    <td class="codeLine">        Result.insert({DAI->getVariable(), DAI->getDebugLoc().getInlinedAt()});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2510</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2510</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2511</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2511</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2512</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2512</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2513</td>
    <td class="codeLine">  return Result;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2513</td>
    <td class="codeLine">  return Result;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2514</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2514</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2515</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2515</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2516</td>
    <td class="codeLine">static void analyzeFunction(Function &Fn, const DataLayout &Layout,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2516</td>
    <td class="codeLine">static void analyzeFunction(Function &Fn, const DataLayout &Layout,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2517</td>
    <td class="codeLine">                            FunctionVarLocsBuilder *FnVarLocs) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2517</td>
    <td class="codeLine">                            FunctionVarLocsBuilder *FnVarLocs) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2518</td>
    <td class="codeLine">  // The analysis will generate location definitions for all variables, but we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2518</td>
    <td class="codeLine">  // The analysis will generate location definitions for all variables, but we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2519</td>
    <td class="codeLine">  // only need to perform a dataflow on the set of variables which have a stack</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2519</td>
    <td class="codeLine">  // only need to perform a dataflow on the set of variables which have a stack</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2520</td>
    <td class="codeLine">  // slot. Find those now.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2520</td>
    <td class="codeLine">  // slot. Find those now.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2521</td>
    <td class="codeLine">  DenseSet<DebugAggregate> VarsWithStackSlot = findVarsWithStackSlot(Fn);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2521</td>
    <td class="codeLine">  DenseSet<DebugAggregate> VarsWithStackSlot = findVarsWithStackSlot(Fn);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2522</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2522</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2523</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2523</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2524</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2524</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2525</td>
    <td class="codeLine">  // Use a scope block to clean up AssignmentTrackingLowering before running</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2525</td>
    <td class="codeLine">  // Use a scope block to clean up AssignmentTrackingLowering before running</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2526</td>
    <td class="codeLine">  // MemLocFragmentFill to reduce peak memory consumption.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2526</td>
    <td class="codeLine">  // MemLocFragmentFill to reduce peak memory consumption.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2527</td>
    <td class="codeLine">  {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2527</td>
    <td class="codeLine">  {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2528</td>
    <td class="codeLine">    AssignmentTrackingLowering Pass(Fn, Layout, &VarsWithStackSlot);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2528</td>
    <td class="codeLine">    AssignmentTrackingLowering Pass(Fn, Layout, &VarsWithStackSlot);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2529</td>
    <td class="codeLine">    Changed = Pass.run(FnVarLocs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2529</td>
    <td class="codeLine">    Changed = Pass.run(FnVarLocs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2530</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2530</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2531</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2531</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2532</td>
    <td class="codeLine">  if (Changed) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2532</td>
    <td class="codeLine">  if (Changed) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2533</td>
    <td class="codeLine">    MemLocFragmentFill Pass(Fn, &VarsWithStackSlot,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2533</td>
    <td class="codeLine">    MemLocFragmentFill Pass(Fn, &VarsWithStackSlot,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2534</td>
    <td class="codeLine">                            shouldCoalesceFragments(Fn));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2534</td>
    <td class="codeLine">                            shouldCoalesceFragments(Fn));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2535</td>
    <td class="codeLine">    Pass.run(FnVarLocs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2535</td>
    <td class="codeLine">    Pass.run(FnVarLocs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2536</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2536</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2537</td>
    <td class="codeLine">    // Remove redundant entries. As well as reducing memory consumption and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2537</td>
    <td class="codeLine">    // Remove redundant entries. As well as reducing memory consumption and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2538</td>
    <td class="codeLine">    // avoiding waiting cycles later by burning some now, this has another</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2538</td>
    <td class="codeLine">    // avoiding waiting cycles later by burning some now, this has another</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2539</td>
    <td class="codeLine">    // important job. That is to work around some SelectionDAG quirks. See</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2539</td>
    <td class="codeLine">    // important job. That is to work around some SelectionDAG quirks. See</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2540</td>
    <td class="codeLine">    // removeRedundantDbgLocsUsingForwardScan comments for more info on that.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2540</td>
    <td class="codeLine">    // removeRedundantDbgLocsUsingForwardScan comments for more info on that.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2541</td>
    <td class="codeLine">    for (auto &BB : Fn)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2541</td>
    <td class="codeLine">    for (auto &BB : Fn)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2542</td>
    <td class="codeLine">      removeRedundantDbgLocs(&BB, *FnVarLocs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2542</td>
    <td class="codeLine">      removeRedundantDbgLocs(&BB, *FnVarLocs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2543</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2543</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2544</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2544</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2545</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2545</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2546</td>
    <td class="codeLine coveredLine">bool AssignmentTrackingAnalysis::runOnFunction(Function &F) {</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2546</td>
    <td class="codeLine coveredLine">bool AssignmentTrackingAnalysis::runOnFunction(Function &F) {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2547</td>
    <td class="codeLine coveredLine">  if (!isAssignmentTrackingEnabled(*F.getParent()))</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2547</td>
    <td class="codeLine coveredLine">  if (!isAssignmentTrackingEnabled(*F.getParent()))</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2548</td>
    <td class="codeLine coveredLine">    return false;</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2548</td>
    <td class="codeLine coveredLine">    return false;</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2549</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2549</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2550</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "AssignmentTrackingAnalysis run on " << F.getName()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2550</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "AssignmentTrackingAnalysis run on " << F.getName()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2551</td>
    <td class="codeLine">                    << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2551</td>
    <td class="codeLine">                    << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2552</td>
    <td class="codeLine">  auto DL = std::make_unique<DataLayout>(F.getParent());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2552</td>
    <td class="codeLine">  auto DL = std::make_unique<DataLayout>(F.getParent());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2553</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2553</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2554</td>
    <td class="codeLine">  // Clear previous results.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2554</td>
    <td class="codeLine">  // Clear previous results.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2555</td>
    <td class="codeLine">  Results->clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2555</td>
    <td class="codeLine">  Results->clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2556</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2556</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2557</td>
    <td class="codeLine">  FunctionVarLocsBuilder Builder;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2557</td>
    <td class="codeLine">  FunctionVarLocsBuilder Builder;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2558</td>
    <td class="codeLine">  analyzeFunction(F, *DL.get(), &Builder);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2558</td>
    <td class="codeLine">  analyzeFunction(F, *DL.get(), &Builder);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2559</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2559</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2560</td>
    <td class="codeLine">  // Save these results.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2560</td>
    <td class="codeLine">  // Save these results.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2561</td>
    <td class="codeLine">  Results->init(Builder);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2561</td>
    <td class="codeLine">  Results->init(Builder);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2562</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2562</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2563</td>
    <td class="codeLine">  if (PrintResults && isFunctionInPrintList(F.getName()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2563</td>
    <td class="codeLine">  if (PrintResults && isFunctionInPrintList(F.getName()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2564</td>
    <td class="codeLine">    Results->print(errs(), F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2564</td>
    <td class="codeLine">    Results->print(errs(), F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2565</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2565</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2566</td>
    <td class="codeLine">  // Return false because this pass does not modify the function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2566</td>
    <td class="codeLine">  // Return false because this pass does not modify the function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2567</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2567</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2568</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2568</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2569</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2569</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2570</td>
    <td class="codeLine coveredLine">AssignmentTrackingAnalysis::AssignmentTrackingAnalysis()</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2570</td>
    <td class="codeLine coveredLine">AssignmentTrackingAnalysis::AssignmentTrackingAnalysis()</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2571</td>
    <td class="codeLine coveredLine">    : FunctionPass(ID), Results(std::make_unique<FunctionVarLocs>()) {}</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2571</td>
    <td class="codeLine coveredLine">    : FunctionPass(ID), Results(std::make_unique<FunctionVarLocs>()) {}</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2572</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2572</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2573</td>
    <td class="codeLine">char AssignmentTrackingAnalysis::ID = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2573</td>
    <td class="codeLine">char AssignmentTrackingAnalysis::ID = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2574</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2574</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2575</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS(AssignmentTrackingAnalysis, DEBUG_TYPE,</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2575</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS(AssignmentTrackingAnalysis, DEBUG_TYPE,</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2576</td>
    <td class="codeLine">                "Assignment Tracking Analysis", false, true)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2576</td>
    <td class="codeLine">                "Assignment Tracking Analysis", false, true)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2577</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2577</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
</table>
    </div>
    <button id="myBtn" onclick="topFunction()" title="Go to top" type="button">Top</button>
    <script src="../Javascript/drop_down.js"></script>
    <script src="../Javascript/top_button.js"></script>
  </body>
</html>