<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>AMDGPULowerModuleLDSPass.cpp</title>
    <link rel="stylesheet" href="../Style/style.css" />
  </head>
  <body>
    <div class="headerDiv">
      <h1>
        Code Coverage
      </h1>
      <p>
        Source file: /home/nikola/Desktop/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp
      </p>
    </div>
    <button class="collapsible" type="button">Open Summary Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Summary Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line number</th>
    <th class="mainTh">Line</th>
    <th class="mainTh">Number of hits</th>
    <th class="mainTh">Tests that cover line</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="">//===-- AMDGPULowerModuleLDSPass.cpp ------------------------------*- C++ -*-=//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="">// This pass eliminates local data store, LDS, uses from non-kernel functions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="">// LDS is contiguous memory allocated per kernel execution.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="">// Background.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="">// The programming model is global variables, or equivalently function local</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="">// static variables, accessible from kernels or other functions. For uses from</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="">// kernels this is straightforward - assign an integer to the kernel for the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="">// memory required by all the variables combined, allocate them within that.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="">// For uses from functions there are performance tradeoffs to choose between.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="">// This model means the GPU runtime can specify the amount of memory allocated.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="">// If this is more than the kernel assumed, the excess can be made available</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="">// using a language specific feature, which IR represents as a variable with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="">// no initializer. This feature is referred to here as "Dynamic LDS" and is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="">// lowered slightly differently to the normal case.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="">// Consequences of this GPU feature:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="">// - memory is limited and exceeding it halts compilation</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="">// - a global accessed by one kernel exists independent of other kernels</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="">// - a global exists independent of simultaneous execution of the same kernel</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="">// - the address of the global may be different from different kernels as they</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="">//   do not alias, which permits only allocating variables they use</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="">// - if the address is allowed to differ, functions need help to find it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="">// Uses from kernels are implemented here by grouping them in a per-kernel</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="">// struct instance. This duplicates the variables, accurately modelling their</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="">// aliasing properties relative to a single global representation. It also</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="">// permits control over alignment via padding.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="">// Uses from functions are more complicated and the primary purpose of this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="">// IR pass. Several different lowering are chosen between to meet requirements</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="">// to avoid allocating any LDS where it is not necessary, as that impacts</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="">// occupancy and may fail the compilation, while not imposing overhead on a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="">// feature whose primary advantage over global memory is performance. The basic</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="">// design goal is to avoid one kernel imposing overhead on another.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="">// Implementation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="">// LDS variables with constant annotation or non-undef initializer are passed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="">// through unchanged for simplification or error diagnostics in later passes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="">// Non-undef initializers are not yet implemented for LDS.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="">// LDS variables that are always allocated at the same address can be found</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="">// by lookup at that address. Otherwise runtime information/cost is required.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="">// The simplest strategy possible is to group all LDS variables in a single</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="">// struct and allocate that struct in every kernel such that the original</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="">// variables are always at the same address. LDS is however a limited resource</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="">// so this strategy is unusable in practice. It is not implemented here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="">// Strategy | Precise allocation | Zero runtime cost | General purpose |</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="">//  --------+--------------------+-------------------+-----------------+</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="">//   Module |                 No |               Yes |             Yes |</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="">//    Table |                Yes |                No |             Yes |</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="">//   Kernel |                Yes |               Yes |              No |</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="">//   Hybrid |                Yes |           Partial |             Yes |</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="">// "Module" spends LDS memory to save cycles. "Table" spends cycles and global</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="">// memory to save LDS. "Kernel" is as fast as kernel allocation but only works</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="">// for variables that are known reachable from a single kernel. "Hybrid" picks</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="">// between all three. When forced to choose between LDS and cycles we minimise</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="">// LDS use.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="">// The "module" lowering implemented here finds LDS variables which are used by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="">// non-kernel functions and creates a new struct with a field for each of those</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="">// LDS variables. Variables that are only used from kernels are excluded.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="">// The "table" lowering implemented here has three components.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="">// First kernels are assigned a unique integer identifier which is available in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="">// functions it calls through the intrinsic amdgcn_lds_kernel_id. The integer</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="">// is passed through a specific SGPR, thus works with indirect calls.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="">// Second, each kernel allocates LDS variables independent of other kernels and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="">// writes the addresses it chose for each variable into an array in consistent</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="">// order. If the kernel does not allocate a given variable, it writes undef to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="">// the corresponding array location. These arrays are written to a constant</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="">// table in the order matching the kernel unique integer identifier.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="">// Third, uses from non-kernel functions are replaced with a table lookup using</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="">// the intrinsic function to find the address of the variable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="">// "Kernel" lowering is only applicable for variables that are unambiguously</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="">// reachable from exactly one kernel. For those cases, accesses to the variable</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="">// can be lowered to ConstantExpr address of a struct instance specific to that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="">// one kernel. This is zero cost in space and in compute. It will raise a fatal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="">// error on any variable that might be reachable from multiple kernels and is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="">// thus most easily used as part of the hybrid lowering strategy.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="">// Hybrid lowering is a mixture of the above. It uses the zero cost kernel</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="">// lowering where it can. It lowers the variable accessed by the greatest</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="">// number of kernels using the module strategy as that is free for the first</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="">// variable. Any futher variables that can be lowered with the module strategy</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="">// without incurring LDS memory overhead are. The remaining ones are lowered</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="">// via table.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="">// Consequences</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="">// - No heuristics or user controlled magic numbers, hybrid is the right choice</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="">// - Kernels that don't use functions (or have had them all inlined) are not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="">//   affected by any lowering for kernels that do.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="">// - Kernels that don't make indirect function calls are not affected by those</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="">//   that do.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="">// - Variables which are used by lots of kernels, e.g. those injected by a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="">//   language runtime in most kernels, are expected to have no overhead</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="">// - Implementations that instantiate templates per-kernel where those templates</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="">//   use LDS are expected to hit the "Kernel" lowering strategy</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="">// - The runtime properties impose a cost in compiler implementation complexity</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="">// Dynamic LDS implementation</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="">// Dynamic LDS is lowered similarly to the "table" strategy above and uses the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="">// same intrinsic to identify which kernel is at the root of the dynamic call</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="">// graph. This relies on the specified behaviour that all dynamic LDS variables</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="">// alias one another, i.e. are at the same address, with respect to a given</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="">// kernel. Therefore this pass creates new dynamic LDS variables for each kernel</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="">// that allocates any dynamic LDS and builds a table of addresses out of those.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="">// The AMDGPUPromoteAlloca pass skips kernels that use dynamic LDS.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="">// The corresponding optimisation for "kernel" lowering where the table lookup</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="">// is elided is not implemented.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="">// Implementation notes / limitations</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="">// A single LDS global variable represents an instance per kernel that can reach</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="">// said variables. This pass essentially specialises said variables per kernel.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="">// Handling ConstantExpr during the pass complicated this significantly so now</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="">// all ConstantExpr uses of LDS variables are expanded to instructions. This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="">// may need amending when implementing non-undef initialisers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="">// Lowering is split between this IR pass and the back end. This pass chooses</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="">// where given variables should be allocated and marks them with metadata,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="">// MD_absolute_symbol. The backend places the variables in coincidentally the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="">// same location and raises a fatal error if something has gone awry. This works</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="">// in practice because the only pass between this one and the backend that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="">// changes LDS is PromoteAlloca and the changes it makes do not conflict.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="">// Addresses are written to constant global arrays based on the same metadata.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="">// The backend lowers LDS variables in the order of traversal of the function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="">// This is at odds with the deterministic layout required. The workaround is to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="">// allocate the fixed-address variables immediately upon starting the function</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="">// where they can be placed as intended. This requires a means of mapping from</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="">// the function to the variables that it allocates. For the module scope lds,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="">// this is via metadata indicating whether the variable is not required. If a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="">// pass deletes that metadata, a fatal error on disagreement with the absolute</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="">// symbol metadata will occur. For kernel scope and dynamic, this is by _name_</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="">// correspondence between the function and the variable. It requires the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="">// kernel to have a name (which is only a limitation for tests in practice) and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="">// for nothing to rename the corresponding symbols. This is a hazard if the pass</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="">// is run multiple times during debugging. Alternative schemes considered all</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="">// involve bespoke metadata.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="">// If the name correspondence can be replaced, multiple distinct kernels that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="">// have the same memory layout can map to the same kernel id (as the address</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="">// itself is handled by the absolute symbol metadata) and that will allow more</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="">// uses of the "kernel" style faster lowering and reduce the size of the lookup</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="">// tables.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="">// There is a test that checks this does not fire for a graphics shader. This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="">// lowering is expected to work for graphics if the isKernel test is changed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="">// The current markUsedByKernel is sufficient for PromoteAlloca but is elided</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="">// before codegen. Replacing this with an equivalent intrinsic which lasts until</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="">// shortly after the machine function lowering of LDS would help break the name</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="">// mapping. The other part needed is probably to amend PromoteAlloca to embed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="">// the LDS variables it creates in the same struct created here. That avoids the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="">// current hazard where a PromoteAlloca LDS variable might be allocated before</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="">// the kernel scope (and thus error on the address check). Given a new invariant</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="">// that no LDS variables exist outside of the structs managed here, and an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="">// intrinsic that lasts until after the LDS frame lowering, it should be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="">// possible to drop the name mapping and fold equivalent memory layouts.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="">#include "AMDGPU.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="">#include "Utils/AMDGPUBaseInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="">#include "Utils/AMDGPUMemoryUtils.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="">#include "llvm/ADT/BitVector.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="">#include "llvm/ADT/DenseMap.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="">#include "llvm/ADT/DenseSet.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="">#include "llvm/ADT/STLExtras.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="">#include "llvm/ADT/SetOperations.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="">#include "llvm/ADT/SetVector.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="">#include "llvm/Analysis/CallGraph.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="">#include "llvm/IR/Constants.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="">#include "llvm/IR/DerivedTypes.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="">#include "llvm/IR/IRBuilder.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="">#include "llvm/IR/InlineAsm.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="">#include "llvm/IR/Instructions.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="">#include "llvm/IR/IntrinsicsAMDGPU.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="">#include "llvm/IR/MDBuilder.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="">#include "llvm/IR/ReplaceConstant.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="">#include "llvm/InitializePasses.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="">#include "llvm/Pass.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="">#include "llvm/Support/CommandLine.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="">#include "llvm/Support/Debug.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="">#include "llvm/Support/Format.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="">#include "llvm/Support/OptimizedStructLayout.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="">#include "llvm/Support/raw_ostream.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="">#include "llvm/Transforms/Utils/BasicBlockUtils.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="">#include "llvm/Transforms/Utils/ModuleUtils.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="">#include <tuple></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="">#include <vector></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="">#include <cstdio></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="">#define DEBUG_TYPE "amdgpu-lower-module-lds"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="">using namespace llvm;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="">namespace {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="">cl::opt<bool> SuperAlignLDSGlobals(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="">    "amdgpu-super-align-lds-globals",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="">    cl::desc("Increase alignment of LDS if it is not on align boundary"),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="">    cl::init(true), cl::Hidden);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="">enum class LoweringKind { module, table, kernel, hybrid };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="">cl::opt<LoweringKind> LoweringKindLoc(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="">    "amdgpu-lower-module-lds-strategy",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="">    cl::desc("Specify lowering strategy for function LDS access:"), cl::Hidden,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="">    cl::init(LoweringKind::hybrid),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="">    cl::values(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="">        clEnumValN(LoweringKind::table, "table", "Lower via table lookup"),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="">        clEnumValN(LoweringKind::module, "module", "Lower via module struct"),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="">        clEnumValN(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="">            LoweringKind::kernel, "kernel",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="">            "Lower variables reachable from one kernel, otherwise abort"),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="">        clEnumValN(LoweringKind::hybrid, "hybrid",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="">                   "Lower via mixture of above strategies")));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="uncoveredLine">bool isKernelLDS(const Function *F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="">  // Some weirdness here. AMDGPU::isKernelCC does not call into</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="">  // AMDGPU::isKernel with the calling conv, it instead calls into</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="">  // isModuleEntryFunction which returns true for more calling conventions</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="">  // than AMDGPU::isKernel does. There's a FIXME on AMDGPU::isKernel.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="">  // There's also a test that checks that the LDS lowering does not hit on</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="">  // a graphics shader, denoted amdgpu_ps, so stay with the limited case.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="">  // Putting LDS in the name of the function to draw attention to this.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="uncoveredLine">  return AMDGPU::isKernel(F->getCallingConv());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="uncoveredLine">template <typename T> std::vector<T> sortByName(std::vector<T> &&V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="uncoveredLine">  llvm::sort(V.begin(), V.end(), [](const auto *L, const auto *R) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="uncoveredLine">    return L->getName() < R->getName();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="uncoveredLine">  return {std::move(V)};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="">class AMDGPULowerModuleLDS : public ModulePass {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="">  static void</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="uncoveredLine">  removeLocalVarsFromUsedLists(Module &M,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="">                               const DenseSet<GlobalVariable *> &LocalVars) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="">    // The verifier rejects used lists containing an inttoptr of a constant</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="">    // so remove the variables from these lists before replaceAllUsesWith</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="uncoveredLine">    SmallPtrSet<Constant *, 8> LocalVarsSet;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="uncoveredLine">    for (GlobalVariable *LocalVar : LocalVars)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="uncoveredLine">      LocalVarsSet.insert(cast<Constant>(LocalVar->stripPointerCasts()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="uncoveredLine">    removeFromUsedLists(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="uncoveredLine">        M, [&LocalVarsSet](Constant *C) { return LocalVarsSet.count(C); });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="uncoveredLine">    for (GlobalVariable *LocalVar : LocalVars)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="uncoveredLine">      LocalVar->removeDeadConstantUsers();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="uncoveredLine">  static void markUsedByKernel(Function *Func, GlobalVariable *SGV) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="">    // The llvm.amdgcn.module.lds instance is implicitly used by all kernels</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="">    // that might call a function which accesses a field within it. This is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="">    // presently approximated to 'all kernels' if there are any such functions</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="">    // in the module. This implicit use is redefined as an explicit use here so</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="">    // that later passes, specifically PromoteAlloca, account for the required</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="">    // memory without any knowledge of this transform.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="">    // An operand bundle on llvm.donothing works because the call instruction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="">    // survives until after the last pass that needs to account for LDS. It is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="">    // better than inline asm as the latter survives until the end of codegen. A</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="">    // totally robust solution would be a function with the same semantics as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="">    // llvm.donothing that takes a pointer to the instance and is lowered to a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="">    // no-op after LDS is allocated, but that is not presently necessary.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="">    // This intrinsic is eliminated shortly before instruction selection. It</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="">    // does not suffice to indicate to ISel that a given global which is not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="">    // immediately used by the kernel must still be allocated by it. An</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="">    // equivalent target specific intrinsic which lasts until immediately after</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="">    // codegen would suffice for that, but one would still need to ensure that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="">    // the variables are allocated in the anticpated order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="uncoveredLine">    IRBuilder<> Builder(Func->getEntryBlock().getFirstNonPHI());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="">    Function *Decl =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="uncoveredLine">        Intrinsic::getDeclaration(Func->getParent(), Intrinsic::donothing, {});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="">    Value *UseInstance[1] = {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="uncoveredLine">        Builder.CreateConstInBoundsGEP1_32(SGV->getValueType(), SGV, 0)};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="uncoveredLine">    Builder.CreateCall(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="">        Decl, {}, {OperandBundleDefT<Value *>("ExplicitUse", UseInstance)});</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="uncoveredLine">  static bool eliminateConstantExprUsesOfLDSFromAllInstructions(Module &M) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="">    // Constants are uniqued within LLVM. A ConstantExpr referring to a LDS</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="">    // global may have uses from multiple different functions as a result.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="">    // This pass specialises LDS variables with respect to the kernel that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="">    // allocates them.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="">    // This is semantically equivalent to (the unimplemented as slow):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="">    // for (auto &F : M.functions())</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="">    //   for (auto &BB : F)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="">    //     for (auto &I : BB)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="">    //       for (Use &Op : I.operands())</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="">    //         if (constantExprUsesLDS(Op))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="">    //           replaceConstantExprInFunction(I, Op);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="uncoveredLine">    SmallVector<Constant *> LDSGlobals;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="uncoveredLine">    for (auto &GV : M.globals())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="uncoveredLine">      if (AMDGPU::isLDSVariableToLower(GV))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="uncoveredLine">        LDSGlobals.push_back(&GV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="uncoveredLine">    return convertUsersOfConstantsToInstructions(LDSGlobals);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="">  static char ID;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="uncoveredLine">  AMDGPULowerModuleLDS() : ModulePass(ID) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="uncoveredLine">    initializeAMDGPULowerModuleLDSPass(*PassRegistry::getPassRegistry());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="">  using FunctionVariableMap = DenseMap<Function *, DenseSet<GlobalVariable *>>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="">  using VariableFunctionMap = DenseMap<GlobalVariable *, DenseSet<Function *>>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="uncoveredLine">  static void getUsesOfLDSByFunction(CallGraph const &CG, Module &M,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="">                                     FunctionVariableMap &kernels,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="">                                     FunctionVariableMap &functions) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="">    // Get uses from the current function, excluding uses by called functions</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="">    // Two output variables to avoid walking the globals list twice</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="uncoveredLine">    for (auto &GV : M.globals()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="uncoveredLine">      if (!AMDGPU::isLDSVariableToLower(GV)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="uncoveredLine">      if (GV.isAbsoluteSymbolRef()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="uncoveredLine">        report_fatal_error(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="">            "LDS variables with absolute addresses are unimplemented.");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="uncoveredLine">      for (User *V : GV.users()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="uncoveredLine">        if (auto *I = dyn_cast<Instruction>(V)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="uncoveredLine">          Function *F = I->getFunction();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="uncoveredLine">          if (isKernelLDS(F)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="uncoveredLine">            kernels[F].insert(&GV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="">          } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="uncoveredLine">            functions[F].insert(&GV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="">  struct LDSUsesInfoTy {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="">    FunctionVariableMap direct_access;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="">    FunctionVariableMap indirect_access;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="uncoveredLine">  static LDSUsesInfoTy getTransitiveUsesOfLDS(CallGraph const &CG, Module &M) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="uncoveredLine">    FunctionVariableMap direct_map_kernel;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="uncoveredLine">    FunctionVariableMap direct_map_function;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="uncoveredLine">    getUsesOfLDSByFunction(CG, M, direct_map_kernel, direct_map_function);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="">    // Collect variables that are used by functions whose address has escaped</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="uncoveredLine">    DenseSet<GlobalVariable *> VariablesReachableThroughFunctionPointer;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="uncoveredLine">    for (Function &F : M.functions()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="uncoveredLine">      if (!isKernelLDS(&F))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="uncoveredLine">        if (F.hasAddressTaken(nullptr,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="">                              /* IgnoreCallbackUses */ false,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="">                              /* IgnoreAssumeLikeCalls */ false,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="">                              /* IgnoreLLVMUsed */ true,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="">                              /* IgnoreArcAttachedCall */ false)) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="uncoveredLine">          set_union(VariablesReachableThroughFunctionPointer,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="uncoveredLine">                    direct_map_function[&F]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="uncoveredLine">    auto functionMakesUnknownCall = [&](const Function *F) -> bool {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="uncoveredLine">      assert(!F->isDeclaration());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="uncoveredLine">      for (const CallGraphNode::CallRecord &R : *CG[F]) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="uncoveredLine">        if (!R.second->getFunction()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="uncoveredLine">          return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="uncoveredLine">    };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="">    // Work out which variables are reachable through function calls</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="uncoveredLine">    FunctionVariableMap transitive_map_function = direct_map_function;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="">    // If the function makes any unknown call, assume the worst case that it can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="">    // access all variables accessed by functions whose address escaped</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="uncoveredLine">    for (Function &F : M.functions()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="uncoveredLine">      if (!F.isDeclaration() && functionMakesUnknownCall(&F)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="uncoveredLine">        if (!isKernelLDS(&F)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="uncoveredLine">          set_union(transitive_map_function[&F],</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="">                    VariablesReachableThroughFunctionPointer);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="">    // Direct implementation of collecting all variables reachable from each</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="">    // function</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="uncoveredLine">    for (Function &Func : M.functions()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="uncoveredLine">      if (Func.isDeclaration() || isKernelLDS(&Func))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="uncoveredLine">      DenseSet<Function *> seen; // catches cycles</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="uncoveredLine">      SmallVector<Function *, 4> wip{&Func};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="uncoveredLine">      while (!wip.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="uncoveredLine">        Function *F = wip.pop_back_val();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="">        // Can accelerate this by referring to transitive map for functions that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="">        // have already been computed, with more care than this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="uncoveredLine">        set_union(transitive_map_function[&Func], direct_map_function[F]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="uncoveredLine">        for (const CallGraphNode::CallRecord &R : *CG[F]) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="uncoveredLine">          Function *ith = R.second->getFunction();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="uncoveredLine">          if (ith) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="uncoveredLine">            if (!seen.contains(ith)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="uncoveredLine">              seen.insert(ith);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="uncoveredLine">              wip.push_back(ith);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="">            }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="">    // direct_map_kernel lists which variables are used by the kernel</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="">    // find the variables which are used through a function call</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="uncoveredLine">    FunctionVariableMap indirect_map_kernel;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="uncoveredLine">    for (Function &Func : M.functions()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="uncoveredLine">      if (Func.isDeclaration() || !isKernelLDS(&Func))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="uncoveredLine">      for (const CallGraphNode::CallRecord &R : *CG[&Func]) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="uncoveredLine">        Function *ith = R.second->getFunction();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="uncoveredLine">        if (ith) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="uncoveredLine">          set_union(indirect_map_kernel[&Func], transitive_map_function[ith]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="">        } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="uncoveredLine">          set_union(indirect_map_kernel[&Func],</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="">                    VariablesReachableThroughFunctionPointer);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="uncoveredLine">    return {std::move(direct_map_kernel), std::move(indirect_map_kernel)};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="">  struct LDSVariableReplacement {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="">    GlobalVariable *SGV = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="">    DenseMap<GlobalVariable *, Constant *> LDSVarsToConstantGEP;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="">  // remap from lds global to a constantexpr gep to where it has been moved to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="">  // for each kernel</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="">  // an array with an element for each kernel containing where the corresponding</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="">  // variable was remapped to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="uncoveredLine">  static Constant *getAddressesOfVariablesInKernel(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="">      LLVMContext &Ctx, ArrayRef<GlobalVariable *> Variables,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="">      const DenseMap<GlobalVariable *, Constant *> &LDSVarsToConstantGEP) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="">    // Create a ConstantArray containing the address of each Variable within the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="">    // kernel corresponding to LDSVarsToConstantGEP, or poison if that kernel</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="">    // does not allocate it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="">    // TODO: Drop the ptrtoint conversion</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="uncoveredLine">    Type *I32 = Type::getInt32Ty(Ctx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="uncoveredLine">    ArrayType *KernelOffsetsType = ArrayType::get(I32, Variables.size());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="uncoveredLine">    SmallVector<Constant *> Elements;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="uncoveredLine">    for (size_t i = 0; i < Variables.size(); i++) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="uncoveredLine">      GlobalVariable *GV = Variables[i];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="uncoveredLine">      auto ConstantGepIt = LDSVarsToConstantGEP.find(GV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="uncoveredLine">      if (ConstantGepIt != LDSVarsToConstantGEP.end()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="uncoveredLine">        auto elt = ConstantExpr::getPtrToInt(ConstantGepIt->second, I32);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="uncoveredLine">        Elements.push_back(elt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="uncoveredLine">        Elements.push_back(PoisonValue::get(I32));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="uncoveredLine">    return ConstantArray::get(KernelOffsetsType, Elements);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="uncoveredLine">  static GlobalVariable *buildLookupTable(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="">      Module &M, ArrayRef<GlobalVariable *> Variables,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="">      ArrayRef<Function *> kernels,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="">      DenseMap<Function *, LDSVariableReplacement> &KernelToReplacement) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="uncoveredLine">    if (Variables.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="uncoveredLine">      return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="uncoveredLine">    LLVMContext &Ctx = M.getContext();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="uncoveredLine">    const size_t NumberVariables = Variables.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="uncoveredLine">    const size_t NumberKernels = kernels.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="">    ArrayType *KernelOffsetsType =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="uncoveredLine">        ArrayType::get(Type::getInt32Ty(Ctx), NumberVariables);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="">    ArrayType *AllKernelsOffsetsType =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="uncoveredLine">        ArrayType::get(KernelOffsetsType, NumberKernels);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="uncoveredLine">    Constant *Missing = PoisonValue::get(KernelOffsetsType);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="uncoveredLine">    std::vector<Constant *> overallConstantExprElts(NumberKernels);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="uncoveredLine">    for (size_t i = 0; i < NumberKernels; i++) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="uncoveredLine">      auto Replacement = KernelToReplacement.find(kernels[i]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="uncoveredLine">      overallConstantExprElts[i] =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="uncoveredLine">          (Replacement == KernelToReplacement.end())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="uncoveredLine">              ? Missing</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="uncoveredLine">              : getAddressesOfVariablesInKernel(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="uncoveredLine">                    Ctx, Variables, Replacement->second.LDSVarsToConstantGEP);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="">    Constant *init =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="uncoveredLine">        ConstantArray::get(AllKernelsOffsetsType, overallConstantExprElts);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="">    return new GlobalVariable(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="">        M, AllKernelsOffsetsType, true, GlobalValue::InternalLinkage, init,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="">        "llvm.amdgcn.lds.offset.table", nullptr, GlobalValue::NotThreadLocal,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="uncoveredLine">        AMDGPUAS::CONSTANT_ADDRESS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="uncoveredLine">  void replaceUseWithTableLookup(Module &M, IRBuilder<> &Builder,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="">                                 GlobalVariable *LookupTable,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="">                                 GlobalVariable *GV, Use &U,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="">                                 Value *OptionalIndex) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="">    // Table is a constant array of the same length as OrderedKernels</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="uncoveredLine">    LLVMContext &Ctx = M.getContext();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="uncoveredLine">    Type *I32 = Type::getInt32Ty(Ctx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="uncoveredLine">    auto *I = cast<Instruction>(U.getUser());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="uncoveredLine">    Value *tableKernelIndex = getTableLookupKernelIndex(M, I->getFunction());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="uncoveredLine">    if (auto *Phi = dyn_cast<PHINode>(I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="uncoveredLine">      BasicBlock *BB = Phi->getIncomingBlock(U);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="uncoveredLine">      Builder.SetInsertPoint(&(*(BB->getFirstInsertionPt())));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="uncoveredLine">      Builder.SetInsertPoint(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="">    SmallVector<Value *, 3> GEPIdx = {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="uncoveredLine">        ConstantInt::get(I32, 0),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="">        tableKernelIndex,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="uncoveredLine">    };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="uncoveredLine">    if (OptionalIndex)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="uncoveredLine">      GEPIdx.push_back(OptionalIndex);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="uncoveredLine">    Value *Address = Builder.CreateInBoundsGEP(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="uncoveredLine">        LookupTable->getValueType(), LookupTable, GEPIdx, GV->getName());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="uncoveredLine">    Value *loaded = Builder.CreateLoad(I32, Address);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="">    Value *replacement =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="uncoveredLine">        Builder.CreateIntToPtr(loaded, GV->getType(), GV->getName());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="uncoveredLine">    U.set(replacement);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="uncoveredLine">  void replaceUsesInInstructionsWithTableLookup(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="">      Module &M, ArrayRef<GlobalVariable *> ModuleScopeVariables,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="">      GlobalVariable *LookupTable) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="uncoveredLine">    LLVMContext &Ctx = M.getContext();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="uncoveredLine">    IRBuilder<> Builder(Ctx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="uncoveredLine">    Type *I32 = Type::getInt32Ty(Ctx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="uncoveredLine">    for (size_t Index = 0; Index < ModuleScopeVariables.size(); Index++) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="uncoveredLine">      auto *GV = ModuleScopeVariables[Index];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="uncoveredLine">      for (Use &U : make_early_inc_range(GV->uses())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="uncoveredLine">        auto *I = dyn_cast<Instruction>(U.getUser());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="uncoveredLine">        if (!I)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="uncoveredLine">        replaceUseWithTableLookup(M, Builder, LookupTable, GV, U,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="uncoveredLine">                                  ConstantInt::get(I32, Index));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="uncoveredLine">  static DenseSet<Function *> kernelsThatIndirectlyAccessAnyOfPassedVariables(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="">      Module &M, LDSUsesInfoTy &LDSUsesInfo,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="">      DenseSet<GlobalVariable *> const &VariableSet) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="uncoveredLine">    DenseSet<Function *> KernelSet;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="uncoveredLine">    if (VariableSet.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="uncoveredLine">      return KernelSet;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="uncoveredLine">    for (Function &Func : M.functions()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="uncoveredLine">      if (Func.isDeclaration() || !isKernelLDS(&Func))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="uncoveredLine">      for (GlobalVariable *GV : LDSUsesInfo.indirect_access[&Func]) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="uncoveredLine">        if (VariableSet.contains(GV)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="uncoveredLine">          KernelSet.insert(&Func);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="uncoveredLine">          break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="uncoveredLine">    return KernelSet;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="">  static GlobalVariable *</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="uncoveredLine">  chooseBestVariableForModuleStrategy(const DataLayout &DL,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="">                                      VariableFunctionMap &LDSVars) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="">    // Find the global variable with the most indirect uses from kernels</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="">    struct CandidateTy {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="">      GlobalVariable *GV = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="">      size_t UserCount = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="">      size_t Size = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="">      CandidateTy() = default;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="uncoveredLine">      CandidateTy(GlobalVariable *GV, uint64_t UserCount, uint64_t AllocSize)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="uncoveredLine">          : GV(GV), UserCount(UserCount), Size(AllocSize) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="uncoveredLine">      bool operator<(const CandidateTy &Other) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="">        // Fewer users makes module scope variable less attractive</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="uncoveredLine">        if (UserCount < Other.UserCount) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="uncoveredLine">          return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="uncoveredLine">        if (UserCount > Other.UserCount) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="uncoveredLine">          return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="">        // Bigger makes module scope variable less attractive</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="uncoveredLine">        if (Size < Other.Size) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="uncoveredLine">          return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="uncoveredLine">        if (Size > Other.Size) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="uncoveredLine">          return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="">        // Arbitrary but consistent</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="uncoveredLine">        return GV->getName() < Other.GV->getName();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="">    };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="uncoveredLine">    CandidateTy MostUsed;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="uncoveredLine">    for (auto &K : LDSVars) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="uncoveredLine">      GlobalVariable *GV = K.first;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="uncoveredLine">      if (K.second.size() <= 1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="">        // A variable reachable by only one kernel is best lowered with kernel</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="">        // strategy</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="">      CandidateTy Candidate(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="uncoveredLine">          GV, K.second.size(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="uncoveredLine">          DL.getTypeAllocSize(GV->getValueType()).getFixedValue());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="uncoveredLine">      if (MostUsed < Candidate)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="uncoveredLine">        MostUsed = Candidate;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="uncoveredLine">    return MostUsed.GV;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="uncoveredLine">  static void recordLDSAbsoluteAddress(Module *M, GlobalVariable *GV,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="">                                       uint32_t Address) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="">    // Write the specified address into metadata where it can be retrieved by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="">    // the assembler. Format is a half open range, [Address Address+1)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="uncoveredLine">    LLVMContext &Ctx = M->getContext();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="">    auto *IntTy =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="uncoveredLine">        M->getDataLayout().getIntPtrType(Ctx, AMDGPUAS::LOCAL_ADDRESS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="uncoveredLine">    auto *MinC = ConstantAsMetadata::get(ConstantInt::get(IntTy, Address));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="uncoveredLine">    auto *MaxC = ConstantAsMetadata::get(ConstantInt::get(IntTy, Address + 1));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="uncoveredLine">    GV->setMetadata(LLVMContext::MD_absolute_symbol,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="uncoveredLine">                    MDNode::get(Ctx, {MinC, MaxC}));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="">  DenseMap<Function *, Value *> tableKernelIndexCache;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="uncoveredLine">  Value *getTableLookupKernelIndex(Module &M, Function *F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="">    // Accesses from a function use the amdgcn_lds_kernel_id intrinsic which</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="">    // lowers to a read from a live in register. Emit it once in the entry</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="">    // block to spare deduplicating it later.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="uncoveredLine">    auto [It, Inserted] = tableKernelIndexCache.try_emplace(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="uncoveredLine">    if (Inserted) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="">      Function *Decl =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="uncoveredLine">          Intrinsic::getDeclaration(&M, Intrinsic::amdgcn_lds_kernel_id, {});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="uncoveredLine">      auto InsertAt = F->getEntryBlock().getFirstNonPHIOrDbgOrAlloca();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="uncoveredLine">      IRBuilder<> Builder(&*InsertAt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="uncoveredLine">      It->second = Builder.CreateCall(Decl, {});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="uncoveredLine">    return It->second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="uncoveredLine">  static std::vector<Function *> assignLDSKernelIDToEachKernel(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="">      Module *M, DenseSet<Function *> const &KernelsThatAllocateTableLDS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="">      DenseSet<Function *> const &KernelsThatIndirectlyAllocateDynamicLDS) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="">    // Associate kernels in the set with an arbirary but reproducible order and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="">    // annotate them with that order in metadata. This metadata is recognised by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="">    // the backend and lowered to a SGPR which can be read from using</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="">    // amdgcn_lds_kernel_id.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="uncoveredLine">    std::vector<Function *> OrderedKernels;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="uncoveredLine">    if (!KernelsThatAllocateTableLDS.empty() ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="uncoveredLine">        !KernelsThatIndirectlyAllocateDynamicLDS.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="uncoveredLine">      for (Function &Func : M->functions()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="uncoveredLine">        if (Func.isDeclaration())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="uncoveredLine">        if (!isKernelLDS(&Func))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="uncoveredLine">        if (KernelsThatAllocateTableLDS.contains(&Func) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="uncoveredLine">            KernelsThatIndirectlyAllocateDynamicLDS.contains(&Func)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="uncoveredLine">          assert(Func.hasName()); // else fatal error earlier</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="uncoveredLine">          OrderedKernels.push_back(&Func);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="">      // Put them in an arbitrary but reproducible order</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="uncoveredLine">      OrderedKernels = sortByName(std::move(OrderedKernels));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="">      // Annotate the kernels with their order in this vector</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="uncoveredLine">      LLVMContext &Ctx = M->getContext();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="uncoveredLine">      IRBuilder<> Builder(Ctx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="uncoveredLine">      if (OrderedKernels.size() > UINT32_MAX) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="">        // 32 bit keeps it in one SGPR. > 2**32 kernels won't fit on the GPU</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="uncoveredLine">        report_fatal_error("Unimplemented LDS lowering for > 2**32 kernels");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="uncoveredLine">      for (size_t i = 0; i < OrderedKernels.size(); i++) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="">        Metadata *AttrMDArgs[1] = {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="uncoveredLine">            ConstantAsMetadata::get(Builder.getInt32(i)),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="uncoveredLine">        };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="uncoveredLine">        OrderedKernels[i]->setMetadata("llvm.amdgcn.lds.kernel.id",</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="uncoveredLine">                                       MDNode::get(Ctx, AttrMDArgs));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="uncoveredLine">    return OrderedKernels;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="uncoveredLine">  static void partitionVariablesIntoIndirectStrategies(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="">      Module &M, LDSUsesInfoTy const &LDSUsesInfo,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="">      VariableFunctionMap &LDSToKernelsThatNeedToAccessItIndirectly,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="">      DenseSet<GlobalVariable *> &ModuleScopeVariables,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="">      DenseSet<GlobalVariable *> &TableLookupVariables,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="">      DenseSet<GlobalVariable *> &KernelAccessVariables,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="">      DenseSet<GlobalVariable *> &DynamicVariables) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="">    GlobalVariable *HybridModuleRoot =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="uncoveredLine">        LoweringKindLoc != LoweringKind::hybrid</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="uncoveredLine">            ? nullptr</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="uncoveredLine">            : chooseBestVariableForModuleStrategy(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="uncoveredLine">                  M.getDataLayout(), LDSToKernelsThatNeedToAccessItIndirectly);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="uncoveredLine">    DenseSet<Function *> const EmptySet;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="">    DenseSet<Function *> const &HybridModuleRootKernels =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="uncoveredLine">        HybridModuleRoot</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="uncoveredLine">            ? LDSToKernelsThatNeedToAccessItIndirectly[HybridModuleRoot]</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="uncoveredLine">            : EmptySet;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="uncoveredLine">    for (auto &K : LDSToKernelsThatNeedToAccessItIndirectly) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="">      // Each iteration of this loop assigns exactly one global variable to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="">      // exactly one of the implementation strategies.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="uncoveredLine">      GlobalVariable *GV = K.first;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="uncoveredLine">      assert(AMDGPU::isLDSVariableToLower(*GV));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="uncoveredLine">      assert(K.second.size() != 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="uncoveredLine">      if (AMDGPU::isDynamicLDS(*GV)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="uncoveredLine">        DynamicVariables.insert(GV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="uncoveredLine">      switch (LoweringKindLoc) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="uncoveredLine">      case LoweringKind::module:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="uncoveredLine">        ModuleScopeVariables.insert(GV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="uncoveredLine">      case LoweringKind::table:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="uncoveredLine">        TableLookupVariables.insert(GV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="uncoveredLine">      case LoweringKind::kernel:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="uncoveredLine">        if (K.second.size() == 1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="uncoveredLine">          KernelAccessVariables.insert(GV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="">        } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="uncoveredLine">          report_fatal_error(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="uncoveredLine">              "cannot lower LDS '" + GV->getName() +</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="uncoveredLine">              "' to kernel access as it is reachable from multiple kernels");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="uncoveredLine">      case LoweringKind::hybrid: {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="uncoveredLine">        if (GV == HybridModuleRoot) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="uncoveredLine">          assert(K.second.size() != 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="uncoveredLine">          ModuleScopeVariables.insert(GV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="uncoveredLine">        } else if (K.second.size() == 1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="uncoveredLine">          KernelAccessVariables.insert(GV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="uncoveredLine">        } else if (set_is_subset(K.second, HybridModuleRootKernels)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="uncoveredLine">          ModuleScopeVariables.insert(GV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="">        } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="uncoveredLine">          TableLookupVariables.insert(GV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="">    // All LDS variables accessed indirectly have now been partitioned into</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="">    // the distinct lowering strategies.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="uncoveredLine">    assert(ModuleScopeVariables.size() + TableLookupVariables.size() +</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="">               KernelAccessVariables.size() + DynamicVariables.size() ==</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="">           LDSToKernelsThatNeedToAccessItIndirectly.size());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="uncoveredLine">  static GlobalVariable *lowerModuleScopeStructVariables(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="">      Module &M, DenseSet<GlobalVariable *> const &ModuleScopeVariables,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="">      DenseSet<Function *> const &KernelsThatAllocateModuleLDS) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="">    // Create a struct to hold the ModuleScopeVariables</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="">    // Replace all uses of those variables from non-kernel functions with the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="">    // new struct instance Replace only the uses from kernel functions that will</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="">    // allocate this instance. That is a space optimisation - kernels that use a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="">    // subset of the module scope struct and do not need to allocate it for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="">    // indirect calls will only allocate the subset they use (they do so as part</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="">    // of the per-kernel lowering).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="uncoveredLine">    if (ModuleScopeVariables.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="uncoveredLine">      return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="uncoveredLine">    LLVMContext &Ctx = M.getContext();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="">    LDSVariableReplacement ModuleScopeReplacement =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="">        createLDSVariableReplacement(M, "llvm.amdgcn.module.lds",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="uncoveredLine">                                     ModuleScopeVariables);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="uncoveredLine">    appendToCompilerUsed(M, {static_cast<GlobalValue *>(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="uncoveredLine">                                ConstantExpr::getPointerBitCastOrAddrSpaceCast(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="">                                    cast<Constant>(ModuleScopeReplacement.SGV),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="uncoveredLine">                                    Type::getInt8PtrTy(Ctx)))});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="">    // module.lds will be allocated at zero in any kernel that allocates it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="uncoveredLine">    recordLDSAbsoluteAddress(&M, ModuleScopeReplacement.SGV, 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="">    // historic</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="uncoveredLine">    removeLocalVarsFromUsedLists(M, ModuleScopeVariables);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="">    // Replace all uses of module scope variable from non-kernel functions</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="uncoveredLine">    replaceLDSVariablesWithStruct(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="uncoveredLine">        M, ModuleScopeVariables, ModuleScopeReplacement, [&](Use &U) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="uncoveredLine">          Instruction *I = dyn_cast<Instruction>(U.getUser());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="uncoveredLine">          if (!I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="uncoveredLine">            return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="uncoveredLine">          Function *F = I->getFunction();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="uncoveredLine">          return !isKernelLDS(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="">        });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="">    // Replace uses of module scope variable from kernel functions that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="">    // allocate the module scope variable, otherwise leave them unchanged</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="">    // Record on each kernel whether the module scope global is used by it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="uncoveredLine">    for (Function &Func : M.functions()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="uncoveredLine">      if (Func.isDeclaration() || !isKernelLDS(&Func))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="uncoveredLine">      if (KernelsThatAllocateModuleLDS.contains(&Func)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="uncoveredLine">        replaceLDSVariablesWithStruct(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="uncoveredLine">            M, ModuleScopeVariables, ModuleScopeReplacement, [&](Use &U) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="uncoveredLine">              Instruction *I = dyn_cast<Instruction>(U.getUser());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="uncoveredLine">              if (!I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="uncoveredLine">                return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="">              }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="uncoveredLine">              Function *F = I->getFunction();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="uncoveredLine">              return F == &Func;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="">            });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="uncoveredLine">        markUsedByKernel(&Func, ModuleScopeReplacement.SGV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="uncoveredLine">    return ModuleScopeReplacement.SGV;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="">  static DenseMap<Function *, LDSVariableReplacement></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="uncoveredLine">  lowerKernelScopeStructVariables(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="">      Module &M, LDSUsesInfoTy &LDSUsesInfo,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="">      DenseSet<GlobalVariable *> const &ModuleScopeVariables,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="">      DenseSet<Function *> const &KernelsThatAllocateModuleLDS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="">      GlobalVariable *MaybeModuleScopeStruct) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="">    // Create a struct for each kernel for the non-module-scope variables.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="uncoveredLine">    DenseMap<Function *, LDSVariableReplacement> KernelToReplacement;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="uncoveredLine">    for (Function &Func : M.functions()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="uncoveredLine">      if (Func.isDeclaration() || !isKernelLDS(&Func))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="uncoveredLine">      DenseSet<GlobalVariable *> KernelUsedVariables;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="">      // Allocating variables that are used directly in this struct to get</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="">      // alignment aware allocation and predictable frame size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="uncoveredLine">      for (auto &v : LDSUsesInfo.direct_access[&Func]) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="uncoveredLine">        if (!AMDGPU::isDynamicLDS(*v)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="uncoveredLine">          KernelUsedVariables.insert(v);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="">      // Allocating variables that are accessed indirectly so that a lookup of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="">      // this struct instance can find them from nested functions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="uncoveredLine">      for (auto &v : LDSUsesInfo.indirect_access[&Func]) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="uncoveredLine">        if (!AMDGPU::isDynamicLDS(*v)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="uncoveredLine">          KernelUsedVariables.insert(v);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="">      // Variables allocated in module lds must all resolve to that struct,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="">      // not to the per-kernel instance.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="uncoveredLine">      if (KernelsThatAllocateModuleLDS.contains(&Func)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="uncoveredLine">        for (GlobalVariable *v : ModuleScopeVariables) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="uncoveredLine">          KernelUsedVariables.erase(v);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="uncoveredLine">      if (KernelUsedVariables.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="">        // Either used no LDS, or the LDS it used was all in the module struct</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="">        // or dynamically sized</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="">      // The association between kernel function and LDS struct is done by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="">      // symbol name, which only works if the function in question has a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="">      // name This is not expected to be a problem in practice as kernels</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="">      // are called by name making anonymous ones (which are named by the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="">      // backend) difficult to use. This does mean that llvm test cases need</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="">      // to name the kernels.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="uncoveredLine">      if (!Func.hasName()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="uncoveredLine">        report_fatal_error("Anonymous kernels cannot use LDS variables");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="">      std::string VarName =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="uncoveredLine">          (Twine("llvm.amdgcn.kernel.") + Func.getName() + ".lds").str();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="">      auto Replacement =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="uncoveredLine">          createLDSVariableReplacement(M, VarName, KernelUsedVariables);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="">      // If any indirect uses, create a direct use to ensure allocation</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="">      // TODO: Simpler to unconditionally mark used but that regresses</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="">      // codegen in test/CodeGen/AMDGPU/noclobber-barrier.ll</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="uncoveredLine">      auto Accesses = LDSUsesInfo.indirect_access.find(&Func);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="uncoveredLine">      if ((Accesses != LDSUsesInfo.indirect_access.end()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="uncoveredLine">          !Accesses->second.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="uncoveredLine">        markUsedByKernel(&Func, Replacement.SGV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="">      // remove preserves existing codegen</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="uncoveredLine">      removeLocalVarsFromUsedLists(M, KernelUsedVariables);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="uncoveredLine">      KernelToReplacement[&Func] = Replacement;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="">      // Rewrite uses within kernel to the new struct</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="uncoveredLine">      replaceLDSVariablesWithStruct(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="uncoveredLine">          M, KernelUsedVariables, Replacement, [&Func](Use &U) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="uncoveredLine">            Instruction *I = dyn_cast<Instruction>(U.getUser());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="uncoveredLine">            return I && I->getFunction() == &Func;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="">          });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="uncoveredLine">    return KernelToReplacement;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="">  static GlobalVariable *</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="uncoveredLine">  buildRepresentativeDynamicLDSInstance(Module &M, LDSUsesInfoTy &LDSUsesInfo,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="">                                        Function *func) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="">    // Create a dynamic lds variable with a name associated with the passed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="">    // function that has the maximum alignment of any dynamic lds variable</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="">    // reachable from this kernel. Dynamic LDS is allocated after the static LDS</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="">    // allocation, possibly after alignment padding. The representative variable</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="">    // created here has the maximum alignment of any other dynamic variable</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="">    // reachable by that kernel. All dynamic LDS variables are allocated at the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="">    // same address in each kernel in order to provide the documented aliasing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="">    // semantics. Setting the alignment here allows this IR pass to accurately</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="">    // predict the exact constant at which it will be allocated.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="uncoveredLine">    assert(isKernelLDS(func));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="uncoveredLine">    LLVMContext &Ctx = M.getContext();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="uncoveredLine">    const DataLayout &DL = M.getDataLayout();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="uncoveredLine">    Align MaxDynamicAlignment(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="uncoveredLine">    auto UpdateMaxAlignment = [&MaxDynamicAlignment, &DL](GlobalVariable *GV) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="uncoveredLine">      if (AMDGPU::isDynamicLDS(*GV)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="uncoveredLine">        MaxDynamicAlignment =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="uncoveredLine">            std::max(MaxDynamicAlignment, AMDGPU::getAlign(DL, GV));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="uncoveredLine">    };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="uncoveredLine">    for (GlobalVariable *GV : LDSUsesInfo.indirect_access[func]) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="uncoveredLine">      UpdateMaxAlignment(GV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="uncoveredLine">    for (GlobalVariable *GV : LDSUsesInfo.direct_access[func]) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="uncoveredLine">      UpdateMaxAlignment(GV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="uncoveredLine">    assert(func->hasName()); // Checked by caller</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="uncoveredLine">    auto emptyCharArray = ArrayType::get(Type::getInt8Ty(Ctx), 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="">    GlobalVariable *N = new GlobalVariable(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="">        M, emptyCharArray, false, GlobalValue::ExternalLinkage, nullptr,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="uncoveredLine">        Twine("llvm.amdgcn." + func->getName() + ".dynlds"), nullptr, GlobalValue::NotThreadLocal, AMDGPUAS::LOCAL_ADDRESS,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="uncoveredLine">        false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="uncoveredLine">    N->setAlignment(MaxDynamicAlignment);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="uncoveredLine">    assert(AMDGPU::isDynamicLDS(*N));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="uncoveredLine">    return N;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="uncoveredLine">  DenseMap<Function *, GlobalVariable *> lowerDynamicLDSVariables(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="">      Module &M, LDSUsesInfoTy &LDSUsesInfo,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="">      DenseSet<Function *> const &KernelsThatIndirectlyAllocateDynamicLDS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="">      DenseSet<GlobalVariable *> const &DynamicVariables,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="">      std::vector<Function *> const &OrderedKernels) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="uncoveredLine">    DenseMap<Function *, GlobalVariable *> KernelToCreatedDynamicLDS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="uncoveredLine">    if (!KernelsThatIndirectlyAllocateDynamicLDS.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="uncoveredLine">      LLVMContext &Ctx = M.getContext();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="uncoveredLine">      IRBuilder<> Builder(Ctx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="uncoveredLine">      Type *I32 = Type::getInt32Ty(Ctx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="uncoveredLine">      std::vector<Constant *> newDynamicLDS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="">      // Table is built in the same order as OrderedKernels</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="uncoveredLine">      for (auto &func : OrderedKernels) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="uncoveredLine">        if (KernelsThatIndirectlyAllocateDynamicLDS.contains(func)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="uncoveredLine">          assert(isKernelLDS(func));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="uncoveredLine">          if (!func->hasName()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="uncoveredLine">            report_fatal_error("Anonymous kernels cannot use LDS variables");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="">          GlobalVariable *N =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="uncoveredLine">              buildRepresentativeDynamicLDSInstance(M, LDSUsesInfo, func);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="uncoveredLine">          KernelToCreatedDynamicLDS[func] = N;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="uncoveredLine">          markUsedByKernel(func, N);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="uncoveredLine">          auto emptyCharArray = ArrayType::get(Type::getInt8Ty(Ctx), 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="uncoveredLine">          auto GEP = ConstantExpr::getGetElementPtr(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="">              emptyCharArray, N, ConstantInt::get(I32, 0), true);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="uncoveredLine">          newDynamicLDS.push_back(ConstantExpr::getPtrToInt(GEP, I32));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="">        } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="uncoveredLine">          newDynamicLDS.push_back(PoisonValue::get(I32));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="uncoveredLine">      assert(OrderedKernels.size() == newDynamicLDS.size());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="uncoveredLine">      ArrayType *t = ArrayType::get(I32, newDynamicLDS.size());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="uncoveredLine">      Constant *init = ConstantArray::get(t, newDynamicLDS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="">      GlobalVariable *table = new GlobalVariable(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="">          M, t, true, GlobalValue::InternalLinkage, init,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="">          "llvm.amdgcn.dynlds.offset.table", nullptr,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="uncoveredLine">          GlobalValue::NotThreadLocal, AMDGPUAS::CONSTANT_ADDRESS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="uncoveredLine">      for (GlobalVariable *GV : DynamicVariables) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="uncoveredLine">        for (Use &U : make_early_inc_range(GV->uses())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="uncoveredLine">          auto *I = dyn_cast<Instruction>(U.getUser());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="uncoveredLine">          if (!I)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="uncoveredLine">            continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="uncoveredLine">          if (isKernelLDS(I->getFunction()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="uncoveredLine">            continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="uncoveredLine">          replaceUseWithTableLookup(M, Builder, table, GV, U, nullptr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="uncoveredLine">    return KernelToCreatedDynamicLDS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="uncoveredLine">  bool runOnModule(Module &M) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="uncoveredLine">    CallGraph CG = CallGraph(M);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="uncoveredLine">    bool Changed = superAlignLDSGlobals(M);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="uncoveredLine">    Changed |= eliminateConstantExprUsesOfLDSFromAllInstructions(M);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="uncoveredLine">    Changed = true; // todo: narrow this down</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="">    // For each kernel, what variables does it access directly or through</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="">    // callees</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="uncoveredLine">    LDSUsesInfoTy LDSUsesInfo = getTransitiveUsesOfLDS(CG, M);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="">    // For each variable accessed through callees, which kernels access it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="uncoveredLine">    VariableFunctionMap LDSToKernelsThatNeedToAccessItIndirectly;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="uncoveredLine">    for (auto &K : LDSUsesInfo.indirect_access) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="uncoveredLine">      Function *F = K.first;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="uncoveredLine">      assert(isKernelLDS(F));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="uncoveredLine">      for (GlobalVariable *GV : K.second) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="uncoveredLine">        LDSToKernelsThatNeedToAccessItIndirectly[GV].insert(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="">    // Partition variables accessed indirectly into the different strategies</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="uncoveredLine">    DenseSet<GlobalVariable *> ModuleScopeVariables;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="uncoveredLine">    DenseSet<GlobalVariable *> TableLookupVariables;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="uncoveredLine">    DenseSet<GlobalVariable *> KernelAccessVariables;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="uncoveredLine">    DenseSet<GlobalVariable *> DynamicVariables;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="uncoveredLine">    partitionVariablesIntoIndirectStrategies(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="">        M, LDSUsesInfo, LDSToKernelsThatNeedToAccessItIndirectly,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="">        ModuleScopeVariables, TableLookupVariables, KernelAccessVariables,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="">        DynamicVariables);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="">    // If the kernel accesses a variable that is going to be stored in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="">    // module instance through a call then that kernel needs to allocate the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="">    // module instance</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="">    const DenseSet<Function *> KernelsThatAllocateModuleLDS =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="">        kernelsThatIndirectlyAccessAnyOfPassedVariables(M, LDSUsesInfo,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="uncoveredLine">                                                        ModuleScopeVariables);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="">    const DenseSet<Function *> KernelsThatAllocateTableLDS =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="">        kernelsThatIndirectlyAccessAnyOfPassedVariables(M, LDSUsesInfo,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="uncoveredLine">                                                        TableLookupVariables);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="">    const DenseSet<Function *> KernelsThatIndirectlyAllocateDynamicLDS =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="">        kernelsThatIndirectlyAccessAnyOfPassedVariables(M, LDSUsesInfo,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="uncoveredLine">                                                        DynamicVariables);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="uncoveredLine">    GlobalVariable *MaybeModuleScopeStruct = lowerModuleScopeStructVariables(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="">        M, ModuleScopeVariables, KernelsThatAllocateModuleLDS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="">    DenseMap<Function *, LDSVariableReplacement> KernelToReplacement =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="">        lowerKernelScopeStructVariables(M, LDSUsesInfo, ModuleScopeVariables,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="">                                        KernelsThatAllocateModuleLDS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="uncoveredLine">                                        MaybeModuleScopeStruct);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="">    // Lower zero cost accesses to the kernel instances just created</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="uncoveredLine">    for (auto &GV : KernelAccessVariables) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="uncoveredLine">      auto &funcs = LDSToKernelsThatNeedToAccessItIndirectly[GV];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="uncoveredLine">      assert(funcs.size() == 1); // Only one kernel can access it</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="">      LDSVariableReplacement Replacement =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="uncoveredLine">          KernelToReplacement[*(funcs.begin())];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="uncoveredLine">      DenseSet<GlobalVariable *> Vec;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="uncoveredLine">      Vec.insert(GV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="uncoveredLine">      replaceLDSVariablesWithStruct(M, Vec, Replacement, [](Use &U) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="uncoveredLine">        return isa<Instruction>(U.getUser());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="">      });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="">    // The ith element of this vector is kernel id i</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="">    std::vector<Function *> OrderedKernels =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="">        assignLDSKernelIDToEachKernel(&M, KernelsThatAllocateTableLDS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="uncoveredLine">                                      KernelsThatIndirectlyAllocateDynamicLDS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="uncoveredLine">    if (!KernelsThatAllocateTableLDS.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="uncoveredLine">      LLVMContext &Ctx = M.getContext();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="uncoveredLine">      IRBuilder<> Builder(Ctx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="">      // The order must be consistent between lookup table and accesses to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="">      // lookup table</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="">      auto TableLookupVariablesOrdered =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="uncoveredLine">          sortByName(std::vector<GlobalVariable *>(TableLookupVariables.begin(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="uncoveredLine">                                                   TableLookupVariables.end()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="uncoveredLine">      GlobalVariable *LookupTable = buildLookupTable(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="">          M, TableLookupVariablesOrdered, OrderedKernels, KernelToReplacement);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="uncoveredLine">      replaceUsesInInstructionsWithTableLookup(M, TableLookupVariablesOrdered,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="">                                               LookupTable);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="">    DenseMap<Function *, GlobalVariable *> KernelToCreatedDynamicLDS =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="">        lowerDynamicLDSVariables(M, LDSUsesInfo,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="">                                 KernelsThatIndirectlyAllocateDynamicLDS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="uncoveredLine">                                 DynamicVariables, OrderedKernels);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="">    // All kernel frames have been allocated. Calculate and record the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="">    // addresses.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="">    {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="uncoveredLine">      const DataLayout &DL = M.getDataLayout();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="uncoveredLine">      for (Function &Func : M.functions()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="uncoveredLine">        if (Func.isDeclaration() || !isKernelLDS(&Func))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="">        // All three of these are optional. The first variable is allocated at</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="">        // zero. They are allocated by AMDGPUMachineFunction as one block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="">        // Layout:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="">        //{</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="">        //  module.lds</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="">        //  alignment padding</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="">        //  kernel instance</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="">        //  alignment padding</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="">        //  dynamic lds variables</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="">        //}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="">        const bool AllocateModuleScopeStruct =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="uncoveredLine">            MaybeModuleScopeStruct &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="uncoveredLine">            KernelsThatAllocateModuleLDS.contains(&Func);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="uncoveredLine">        auto Replacement = KernelToReplacement.find(&Func);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="">        const bool AllocateKernelScopeStruct =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="uncoveredLine">            Replacement != KernelToReplacement.end();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="">        const bool AllocateDynamicVariable =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="uncoveredLine">            KernelToCreatedDynamicLDS.contains(&Func);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="uncoveredLine">        uint32_t Offset = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="uncoveredLine">        if (AllocateModuleScopeStruct) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="">          // Allocated at zero, recorded once on construction, not once per</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="">          // kernel</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="uncoveredLine">          Offset += DL.getTypeAllocSize(MaybeModuleScopeStruct->getValueType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="uncoveredLine">        if (AllocateKernelScopeStruct) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="uncoveredLine">          GlobalVariable *KernelStruct = Replacement->second.SGV;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="uncoveredLine">          Offset = alignTo(Offset, AMDGPU::getAlign(DL, KernelStruct));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="uncoveredLine">          recordLDSAbsoluteAddress(&M, KernelStruct, Offset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="uncoveredLine">          Offset += DL.getTypeAllocSize(KernelStruct->getValueType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="">        // If there is dynamic allocation, the alignment needed is included in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="">        // the static frame size. There may be no reference to the dynamic</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="">        // variable in the kernel itself, so without including it here, that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="">        // alignment padding could be missed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="uncoveredLine">        if (AllocateDynamicVariable) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="uncoveredLine">          GlobalVariable *DynamicVariable = KernelToCreatedDynamicLDS[&Func];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="uncoveredLine">          Offset = alignTo(Offset, AMDGPU::getAlign(DL, DynamicVariable));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="uncoveredLine">          recordLDSAbsoluteAddress(&M, DynamicVariable, Offset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="uncoveredLine">        if (Offset != 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="uncoveredLine">          std::string Buffer;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="uncoveredLine">          raw_string_ostream SS{Buffer};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="uncoveredLine">          SS << format("%u", Offset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="">          // Instead of explictly marking kernels that access dynamic variables</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="">          // using special case metadata, annotate with min-lds == max-lds, i.e.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="">          // that there is no more space available for allocating more static</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="">          // LDS variables. That is the right condition to prevent allocating</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="">          // more variables which would collide with the addresses assigned to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="">          // dynamic variables.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="uncoveredLine">          if (AllocateDynamicVariable)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="uncoveredLine">            SS << format(",%u", Offset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="uncoveredLine">          Func.addFnAttr("amdgpu-lds-size", Buffer);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="uncoveredLine">        }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="uncoveredLine">    for (auto &GV : make_early_inc_range(M.globals()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="uncoveredLine">      if (AMDGPU::isLDSVariableToLower(GV)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="">        // probably want to remove from used lists</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="uncoveredLine">        GV.removeDeadConstantUsers();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="uncoveredLine">        if (GV.use_empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="uncoveredLine">          GV.eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="uncoveredLine">    return Changed;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="">  // Increase the alignment of LDS globals if necessary to maximise the chance</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="">  // that we can use aligned LDS instructions to access them.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="uncoveredLine">  static bool superAlignLDSGlobals(Module &M) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="uncoveredLine">    const DataLayout &DL = M.getDataLayout();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="uncoveredLine">    bool Changed = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="uncoveredLine">    if (!SuperAlignLDSGlobals) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="uncoveredLine">      return Changed;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="uncoveredLine">    for (auto &GV : M.globals()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="uncoveredLine">      if (GV.getType()->getPointerAddressSpace() != AMDGPUAS::LOCAL_ADDRESS) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="">        // Only changing alignment of LDS variables</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="uncoveredLine">      if (!GV.hasInitializer()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="">        // cuda/hip extern __shared__ variable, leave alignment alone</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="uncoveredLine">      Align Alignment = AMDGPU::getAlign(DL, &GV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="uncoveredLine">      TypeSize GVSize = DL.getTypeAllocSize(GV.getValueType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="uncoveredLine">      if (GVSize > 8) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="">        // We might want to use a b96 or b128 load/store</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="uncoveredLine">        Alignment = std::max(Alignment, Align(16));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="uncoveredLine">      } else if (GVSize > 4) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="">        // We might want to use a b64 load/store</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="uncoveredLine">        Alignment = std::max(Alignment, Align(8));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="uncoveredLine">      } else if (GVSize > 2) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="">        // We might want to use a b32 load/store</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="uncoveredLine">        Alignment = std::max(Alignment, Align(4));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="uncoveredLine">      } else if (GVSize > 1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="">        // We might want to use a b16 load/store</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="uncoveredLine">        Alignment = std::max(Alignment, Align(2));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="uncoveredLine">      if (Alignment != AMDGPU::getAlign(DL, &GV)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="uncoveredLine">        Changed = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="uncoveredLine">        GV.setAlignment(Alignment);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="uncoveredLine">    return Changed;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="uncoveredLine">  static LDSVariableReplacement createLDSVariableReplacement(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="">      Module &M, std::string VarName,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="">      DenseSet<GlobalVariable *> const &LDSVarsToTransform) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="">    // Create a struct instance containing LDSVarsToTransform and map from those</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="">    // variables to ConstantExprGEP</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="">    // Variables may be introduced to meet alignment requirements. No aliasing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="">    // metadata is useful for these as they have no uses. Erased before return.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="uncoveredLine">    LLVMContext &Ctx = M.getContext();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="uncoveredLine">    const DataLayout &DL = M.getDataLayout();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="uncoveredLine">    assert(!LDSVarsToTransform.empty());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="uncoveredLine">    SmallVector<OptimizedStructLayoutField, 8> LayoutFields;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="uncoveredLine">    LayoutFields.reserve(LDSVarsToTransform.size());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="">    {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="">      // The order of fields in this struct depends on the order of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="">      // varables in the argument which varies when changing how they</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="">      // are identified, leading to spurious test breakage.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="uncoveredLine">      auto Sorted = sortByName(std::vector<GlobalVariable *>(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="uncoveredLine">          LDSVarsToTransform.begin(), LDSVarsToTransform.end()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="uncoveredLine">      for (GlobalVariable *GV : Sorted) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="">        OptimizedStructLayoutField F(GV,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="uncoveredLine">                                     DL.getTypeAllocSize(GV->getValueType()),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="uncoveredLine">                                     AMDGPU::getAlign(DL, GV));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="uncoveredLine">        LayoutFields.emplace_back(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="uncoveredLine">    performOptimizedStructLayout(LayoutFields);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="uncoveredLine">    std::vector<GlobalVariable *> LocalVars;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="uncoveredLine">    BitVector IsPaddingField;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="uncoveredLine">    LocalVars.reserve(LDSVarsToTransform.size()); // will be at least this large</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="uncoveredLine">    IsPaddingField.reserve(LDSVarsToTransform.size());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="">    {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="uncoveredLine">      uint64_t CurrentOffset = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="uncoveredLine">      for (size_t I = 0; I < LayoutFields.size(); I++) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="">        GlobalVariable *FGV = static_cast<GlobalVariable *>(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="uncoveredLine">            const_cast<void *>(LayoutFields[I].Id));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="uncoveredLine">        Align DataAlign = LayoutFields[I].Alignment;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="uncoveredLine">        uint64_t DataAlignV = DataAlign.value();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="uncoveredLine">        if (uint64_t Rem = CurrentOffset % DataAlignV) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="uncoveredLine">          uint64_t Padding = DataAlignV - Rem;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="">          // Append an array of padding bytes to meet alignment requested</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="">          // Note (o +      (a - (o % a)) ) % a == 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="">          //      (offset + Padding       ) % align == 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="uncoveredLine">          Type *ATy = ArrayType::get(Type::getInt8Ty(Ctx), Padding);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="uncoveredLine">          LocalVars.push_back(new GlobalVariable(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="uncoveredLine">              M, ATy, false, GlobalValue::InternalLinkage, UndefValue::get(ATy),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="uncoveredLine">              "", nullptr, GlobalValue::NotThreadLocal, AMDGPUAS::LOCAL_ADDRESS,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="uncoveredLine">              false));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="uncoveredLine">          IsPaddingField.push_back(true);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="uncoveredLine">          CurrentOffset += Padding;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="uncoveredLine">        LocalVars.push_back(FGV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="uncoveredLine">        IsPaddingField.push_back(false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="uncoveredLine">        CurrentOffset += LayoutFields[I].Size;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="uncoveredLine">    std::vector<Type *> LocalVarTypes;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="uncoveredLine">    LocalVarTypes.reserve(LocalVars.size());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="uncoveredLine">    std::transform(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="">        LocalVars.cbegin(), LocalVars.cend(), std::back_inserter(LocalVarTypes),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="uncoveredLine">        [](const GlobalVariable *V) -> Type * { return V->getValueType(); });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="uncoveredLine">    StructType *LDSTy = StructType::create(Ctx, LocalVarTypes, VarName + ".t");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="uncoveredLine">    Align StructAlign = AMDGPU::getAlign(DL, LocalVars[0]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="">    GlobalVariable *SGV = new GlobalVariable(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="uncoveredLine">        M, LDSTy, false, GlobalValue::InternalLinkage, UndefValue::get(LDSTy),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="uncoveredLine">        VarName, nullptr, GlobalValue::NotThreadLocal, AMDGPUAS::LOCAL_ADDRESS,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="uncoveredLine">        false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="uncoveredLine">    SGV->setAlignment(StructAlign);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="uncoveredLine">    DenseMap<GlobalVariable *, Constant *> Map;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="uncoveredLine">    Type *I32 = Type::getInt32Ty(Ctx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="uncoveredLine">    for (size_t I = 0; I < LocalVars.size(); I++) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="uncoveredLine">      GlobalVariable *GV = LocalVars[I];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="uncoveredLine">      Constant *GEPIdx[] = {ConstantInt::get(I32, 0), ConstantInt::get(I32, I)};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="uncoveredLine">      Constant *GEP = ConstantExpr::getGetElementPtr(LDSTy, SGV, GEPIdx, true);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="uncoveredLine">      if (IsPaddingField[I]) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="uncoveredLine">        assert(GV->use_empty());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="uncoveredLine">        GV->eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="uncoveredLine">        Map[GV] = GEP;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="uncoveredLine">    assert(Map.size() == LDSVarsToTransform.size());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="uncoveredLine">    return {SGV, std::move(Map)};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="">  template <typename PredicateTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="uncoveredLine">  static void replaceLDSVariablesWithStruct(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="">      Module &M, DenseSet<GlobalVariable *> const &LDSVarsToTransformArg,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="">      const LDSVariableReplacement &Replacement, PredicateTy Predicate) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="uncoveredLine">    LLVMContext &Ctx = M.getContext();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="uncoveredLine">    const DataLayout &DL = M.getDataLayout();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="">    // A hack... we need to insert the aliasing info in a predictable order for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="">    // lit tests. Would like to have them in a stable order already, ideally the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="">    // same order they get allocated, which might mean an ordered set container</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="uncoveredLine">    auto LDSVarsToTransform = sortByName(std::vector<GlobalVariable *>(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="">        LDSVarsToTransformArg.begin(), LDSVarsToTransformArg.end()));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="">    // Create alias.scope and their lists. Each field in the new structure</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="">    // does not alias with all other fields.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="uncoveredLine">    SmallVector<MDNode *> AliasScopes;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="uncoveredLine">    SmallVector<Metadata *> NoAliasList;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="uncoveredLine">    const size_t NumberVars = LDSVarsToTransform.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="uncoveredLine">    if (NumberVars > 1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="uncoveredLine">      MDBuilder MDB(Ctx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="uncoveredLine">      AliasScopes.reserve(NumberVars);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="uncoveredLine">      MDNode *Domain = MDB.createAnonymousAliasScopeDomain();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="uncoveredLine">      for (size_t I = 0; I < NumberVars; I++) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="uncoveredLine">        MDNode *Scope = MDB.createAnonymousAliasScope(Domain);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="uncoveredLine">        AliasScopes.push_back(Scope);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="uncoveredLine">      NoAliasList.append(&AliasScopes[1], AliasScopes.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="">    // Replace uses of ith variable with a constantexpr to the corresponding</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="">    // field of the instance that will be allocated by AMDGPUMachineFunction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="uncoveredLine">    for (size_t I = 0; I < NumberVars; I++) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="uncoveredLine">      GlobalVariable *GV = LDSVarsToTransform[I];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="uncoveredLine">      Constant *GEP = Replacement.LDSVarsToConstantGEP.at(GV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="uncoveredLine">      GV->replaceUsesWithIf(GEP, Predicate);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="uncoveredLine">      APInt APOff(DL.getIndexTypeSizeInBits(GEP->getType()), 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="uncoveredLine">      GEP->stripAndAccumulateInBoundsConstantOffsets(DL, APOff);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="uncoveredLine">      uint64_t Offset = APOff.getZExtValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="">      Align A =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="uncoveredLine">          commonAlignment(Replacement.SGV->getAlign().valueOrOne(), Offset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="uncoveredLine">      if (I)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="uncoveredLine">        NoAliasList[I - 1] = AliasScopes[I - 1];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="uncoveredLine">      MDNode *NoAlias =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="uncoveredLine">          NoAliasList.empty() ? nullptr : MDNode::get(Ctx, NoAliasList);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="uncoveredLine">      MDNode *AliasScope =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="uncoveredLine">          AliasScopes.empty() ? nullptr : MDNode::get(Ctx, {AliasScopes[I]});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="uncoveredLine">      refineUsesAlignmentAndAA(GEP, A, DL, AliasScope, NoAlias);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="uncoveredLine">  static void refineUsesAlignmentAndAA(Value *Ptr, Align A,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="">                                       const DataLayout &DL, MDNode *AliasScope,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="">                                       MDNode *NoAlias, unsigned MaxDepth = 5) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="uncoveredLine">    if (!MaxDepth || (A == 1 && !AliasScope))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="uncoveredLine">      return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="uncoveredLine">    for (User *U : Ptr->users()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="uncoveredLine">      if (auto *I = dyn_cast<Instruction>(U)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="uncoveredLine">        if (AliasScope && I->mayReadOrWriteMemory()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="uncoveredLine">          MDNode *AS = I->getMetadata(LLVMContext::MD_alias_scope);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="uncoveredLine">          AS = (AS ? MDNode::getMostGenericAliasScope(AS, AliasScope)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="">                   : AliasScope);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="uncoveredLine">          I->setMetadata(LLVMContext::MD_alias_scope, AS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="uncoveredLine">          MDNode *NA = I->getMetadata(LLVMContext::MD_noalias);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="uncoveredLine">          NA = (NA ? MDNode::intersect(NA, NoAlias) : NoAlias);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="uncoveredLine">          I->setMetadata(LLVMContext::MD_noalias, NA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="uncoveredLine">      if (auto *LI = dyn_cast<LoadInst>(U)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="uncoveredLine">        LI->setAlignment(std::max(A, LI->getAlign()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="uncoveredLine">      if (auto *SI = dyn_cast<StoreInst>(U)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="uncoveredLine">        if (SI->getPointerOperand() == Ptr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="uncoveredLine">          SI->setAlignment(std::max(A, SI->getAlign()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="uncoveredLine">      if (auto *AI = dyn_cast<AtomicRMWInst>(U)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="">        // None of atomicrmw operations can work on pointers, but let's</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="">        // check it anyway in case it will or we will process ConstantExpr.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="uncoveredLine">        if (AI->getPointerOperand() == Ptr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="uncoveredLine">          AI->setAlignment(std::max(A, AI->getAlign()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="uncoveredLine">      if (auto *AI = dyn_cast<AtomicCmpXchgInst>(U)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="uncoveredLine">        if (AI->getPointerOperand() == Ptr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="uncoveredLine">          AI->setAlignment(std::max(A, AI->getAlign()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="uncoveredLine">      if (auto *GEP = dyn_cast<GetElementPtrInst>(U)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="uncoveredLine">        unsigned BitWidth = DL.getIndexTypeSizeInBits(GEP->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="uncoveredLine">        APInt Off(BitWidth, 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="uncoveredLine">        if (GEP->getPointerOperand() == Ptr) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="uncoveredLine">          Align GA;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="uncoveredLine">          if (GEP->accumulateConstantOffset(DL, Off))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="uncoveredLine">            GA = commonAlignment(A, Off.getLimitedValue());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="uncoveredLine">          refineUsesAlignmentAndAA(GEP, GA, DL, AliasScope, NoAlias,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="">                                   MaxDepth - 1);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="uncoveredLine">      }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="uncoveredLine">      if (auto *I = dyn_cast<Instruction>(U)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="uncoveredLine">        if (I->getOpcode() == Instruction::BitCast ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="uncoveredLine">            I->getOpcode() == Instruction::AddrSpaceCast)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="uncoveredLine">          refineUsesAlignmentAndAA(I, A, DL, AliasScope, NoAlias, MaxDepth - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="">} // namespace</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="">char AMDGPULowerModuleLDS::ID = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="">char &llvm::AMDGPULowerModuleLDSID = AMDGPULowerModuleLDS::ID;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="coveredLine">INITIALIZE_PASS(AMDGPULowerModuleLDS, DEBUG_TYPE,</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="">                "Lower uses of LDS variables from non-kernel functions", false,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="">                false)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="uncoveredLine">ModulePass *llvm::createAMDGPULowerModuleLDSPass() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="uncoveredLine">  return new AMDGPULowerModuleLDS();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="uncoveredLine">PreservedAnalyses AMDGPULowerModuleLDSPass::run(Module &M,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="">                                                ModuleAnalysisManager &) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="uncoveredLine">  return AMDGPULowerModuleLDS().runOnModule(M) ? PreservedAnalyses::none()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="uncoveredLine">                                               : PreservedAnalyses::all();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Functions Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Functions Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Function name</th>
    <th class="mainTh">Number of hits</th>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_111isKernelLDSEPKN4llvm8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_110sortByNameIPN4llvm14GlobalVariableEEESt6vectorIT_SaIS5_EEOS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_110sortByNameIPN4llvm8FunctionEEESt6vectorIT_SaIS5_EEOS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_110sortByNameIPN4llvm8FunctionEEESt6vectorIT_SaIS5_EEOS7_ENKUlPKS5_PKT0_E_clIS2_S2_EEDaSA_SD_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_110sortByNameIPN4llvm14GlobalVariableEEESt6vectorIT_SaIS5_EEOS7_ENKUlPKS5_PKT0_E_clIS2_S2_EEDaSA_SD_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AMDGPULowerModuleLDS28removeLocalVarsFromUsedListsERN4llvm6ModuleERKNS1_8DenseSetIPNS1_14GlobalVariableENS1_12DenseMapInfoIS6_vEEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_120AMDGPULowerModuleLDS28removeLocalVarsFromUsedListsERN4llvm6ModuleERKNS1_8DenseSetIPNS1_14GlobalVariableENS1_12DenseMapInfoIS6_vEEEEENKUlPNS1_8ConstantEE_clESD_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AMDGPULowerModuleLDS16markUsedByKernelEPN4llvm8FunctionEPNS1_14GlobalVariableE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AMDGPULowerModuleLDS49eliminateConstantExprUsesOfLDSFromAllInstructionsERN4llvm6ModuleE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AMDGPULowerModuleLDSC2Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AMDGPULowerModuleLDS22getUsesOfLDSByFunctionERKN4llvm9CallGraphERNS1_6ModuleERNS1_8DenseMapIPNS1_8FunctionENS1_8DenseSetIPNS1_14GlobalVariableENS1_12DenseMapInfoISC_vEEEENSD_IS9_vEENS1_6detail12DenseMapPairIS9_SF_EEEESL_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AMDGPULowerModuleLDS22getTransitiveUsesOfLDSERKN4llvm9CallGraphERNS1_6ModuleE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_120AMDGPULowerModuleLDS22getTransitiveUsesOfLDSERKN4llvm9CallGraphERNS1_6ModuleEENKUlPKNS1_8FunctionEE_clES9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AMDGPULowerModuleLDS31getAddressesOfVariablesInKernelERN4llvm11LLVMContextENS1_8ArrayRefIPNS1_14GlobalVariableEEERKNS1_8DenseMapIS6_PNS1_8ConstantENS1_12DenseMapInfoIS6_vEENS1_6detail12DenseMapPairIS6_SA_EEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AMDGPULowerModuleLDS16buildLookupTableERN4llvm6ModuleENS1_8ArrayRefIPNS1_14GlobalVariableEEENS4_IPNS1_8FunctionEEERNS1_8DenseMapIS9_NS0_22LDSVariableReplacementENS1_12DenseMapInfoIS9_vEENS1_6detail12DenseMapPairIS9_SC_EEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AMDGPULowerModuleLDS25replaceUseWithTableLookupERN4llvm6ModuleERNS1_9IRBuilderINS1_14ConstantFolderENS1_24IRBuilderDefaultInserterEEEPNS1_14GlobalVariableESA_RNS1_3UseEPNS1_5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AMDGPULowerModuleLDS40replaceUsesInInstructionsWithTableLookupERN4llvm6ModuleENS1_8ArrayRefIPNS1_14GlobalVariableEEES6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AMDGPULowerModuleLDS47kernelsThatIndirectlyAccessAnyOfPassedVariablesERN4llvm6ModuleERNS0_13LDSUsesInfoTyERKNS1_8DenseSetIPNS1_14GlobalVariableENS1_12DenseMapInfoIS8_vEEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AMDGPULowerModuleLDS35chooseBestVariableForModuleStrategyERKN4llvm10DataLayoutERNS1_8DenseMapIPNS1_14GlobalVariableENS1_8DenseSetIPNS1_8FunctionENS1_12DenseMapInfoISA_vEEEENSB_IS7_vEENS1_6detail12DenseMapPairIS7_SD_EEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_120AMDGPULowerModuleLDS35chooseBestVariableForModuleStrategyERKN4llvm10DataLayoutERNS1_8DenseMapIPNS1_14GlobalVariableENS1_8DenseSetIPNS1_8FunctionENS1_12DenseMapInfoISA_vEEEENSB_IS7_vEENS1_6detail12DenseMapPairIS7_SD_EEEEEN11CandidateTyC2ES7_mm</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_120AMDGPULowerModuleLDS35chooseBestVariableForModuleStrategyERKN4llvm10DataLayoutERNS1_8DenseMapIPNS1_14GlobalVariableENS1_8DenseSetIPNS1_8FunctionENS1_12DenseMapInfoISA_vEEEENSB_IS7_vEENS1_6detail12DenseMapPairIS7_SD_EEEEENK11CandidateTyltERKSK_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AMDGPULowerModuleLDS24recordLDSAbsoluteAddressEPN4llvm6ModuleEPNS1_14GlobalVariableEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AMDGPULowerModuleLDS25getTableLookupKernelIndexERN4llvm6ModuleEPNS1_8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AMDGPULowerModuleLDS29assignLDSKernelIDToEachKernelEPN4llvm6ModuleERKNS1_8DenseSetIPNS1_8FunctionENS1_12DenseMapInfoIS6_vEEEESB_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AMDGPULowerModuleLDS40partitionVariablesIntoIndirectStrategiesERN4llvm6ModuleERKNS0_13LDSUsesInfoTyERNS1_8DenseMapIPNS1_14GlobalVariableENS1_8DenseSetIPNS1_8FunctionENS1_12DenseMapInfoISC_vEEEENSD_IS9_vEENS1_6detail12DenseMapPairIS9_SF_EEEERNSA_IS9_SG_EESN_SN_SN_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AMDGPULowerModuleLDS31lowerModuleScopeStructVariablesERN4llvm6ModuleERKNS1_8DenseSetIPNS1_14GlobalVariableENS1_12DenseMapInfoIS6_vEEEERKNS4_IPNS1_8FunctionENS7_ISD_vEEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_120AMDGPULowerModuleLDS31lowerModuleScopeStructVariablesERN4llvm6ModuleERKNS1_8DenseSetIPNS1_14GlobalVariableENS1_12DenseMapInfoIS6_vEEEERKNS4_IPNS1_8FunctionENS7_ISD_vEEEEENKUlRNS1_3UseEE_clESJ_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_120AMDGPULowerModuleLDS31lowerModuleScopeStructVariablesERN4llvm6ModuleERKNS1_8DenseSetIPNS1_14GlobalVariableENS1_12DenseMapInfoIS6_vEEEERKNS4_IPNS1_8FunctionENS7_ISD_vEEEEENKUlRNS1_3UseEE0_clESJ_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AMDGPULowerModuleLDS31lowerKernelScopeStructVariablesERN4llvm6ModuleERNS0_13LDSUsesInfoTyERKNS1_8DenseSetIPNS1_14GlobalVariableENS1_12DenseMapInfoIS8_vEEEERKNS6_IPNS1_8FunctionENS9_ISF_vEEEES8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_120AMDGPULowerModuleLDS31lowerKernelScopeStructVariablesERN4llvm6ModuleERNS0_13LDSUsesInfoTyERKNS1_8DenseSetIPNS1_14GlobalVariableENS1_12DenseMapInfoIS8_vEEEERKNS6_IPNS1_8FunctionENS9_ISF_vEEEES8_ENKUlRNS1_3UseEE_clESL_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AMDGPULowerModuleLDS37buildRepresentativeDynamicLDSInstanceERN4llvm6ModuleERNS0_13LDSUsesInfoTyEPNS1_8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_120AMDGPULowerModuleLDS37buildRepresentativeDynamicLDSInstanceERN4llvm6ModuleERNS0_13LDSUsesInfoTyEPNS1_8FunctionEENKUlPNS1_14GlobalVariableEE_clES9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AMDGPULowerModuleLDS24lowerDynamicLDSVariablesERN4llvm6ModuleERNS0_13LDSUsesInfoTyERKNS1_8DenseSetIPNS1_8FunctionENS1_12DenseMapInfoIS8_vEEEERKNS6_IPNS1_14GlobalVariableENS9_ISF_vEEEERKSt6vectorIS8_SaIS8_EE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AMDGPULowerModuleLDS11runOnModuleERN4llvm6ModuleE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_120AMDGPULowerModuleLDS11runOnModuleERN4llvm6ModuleEENKUlRNS1_3UseEE_clES5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AMDGPULowerModuleLDS20superAlignLDSGlobalsERN4llvm6ModuleE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AMDGPULowerModuleLDS28createLDSVariableReplacementERN4llvm6ModuleENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS1_8DenseSetIPNS1_14GlobalVariableENS1_12DenseMapInfoISC_vEEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_120AMDGPULowerModuleLDS28createLDSVariableReplacementERN4llvm6ModuleENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS1_8DenseSetIPNS1_14GlobalVariableENS1_12DenseMapInfoISC_vEEEEENKUlPKSB_E_clESJ_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AMDGPULowerModuleLDS29replaceLDSVariablesWithStructIZNS0_31lowerKernelScopeStructVariablesERN4llvm6ModuleERNS0_13LDSUsesInfoTyERKNS2_8DenseSetIPNS2_14GlobalVariableENS2_12DenseMapInfoIS9_vEEEERKNS7_IPNS2_8FunctionENSA_ISG_vEEEES9_EUlRNS2_3UseEE_EEvS4_SE_RKNS0_22LDSVariableReplacementET_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AMDGPULowerModuleLDS29replaceLDSVariablesWithStructIZNS0_11runOnModuleERN4llvm6ModuleEEUlRNS2_3UseEE_EEvS4_RKNS2_8DenseSetIPNS2_14GlobalVariableENS2_12DenseMapInfoISA_vEEEERKNS0_22LDSVariableReplacementET_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AMDGPULowerModuleLDS29replaceLDSVariablesWithStructIZNS0_31lowerModuleScopeStructVariablesERN4llvm6ModuleERKNS2_8DenseSetIPNS2_14GlobalVariableENS2_12DenseMapInfoIS7_vEEEERKNS5_IPNS2_8FunctionENS8_ISE_vEEEEEUlRNS2_3UseEE_EEvS4_SC_RKNS0_22LDSVariableReplacementET_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AMDGPULowerModuleLDS29replaceLDSVariablesWithStructIZNS0_31lowerModuleScopeStructVariablesERN4llvm6ModuleERKNS2_8DenseSetIPNS2_14GlobalVariableENS2_12DenseMapInfoIS7_vEEEERKNS5_IPNS2_8FunctionENS8_ISE_vEEEEEUlRNS2_3UseEE0_EEvS4_SC_RKNS0_22LDSVariableReplacementET_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AMDGPULowerModuleLDS24refineUsesAlignmentAndAAEPN4llvm5ValueENS1_5AlignERKNS1_10DataLayoutEPNS1_6MDNodeES9_j</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL38initializeAMDGPULowerModuleLDSPassOnceRN4llvm12PassRegistryE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm34initializeAMDGPULowerModuleLDSPassERNS_12PassRegistryE</td>
    <td class="numberOfCalls">4</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm30createAMDGPULowerModuleLDSPassEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm24AMDGPULowerModuleLDSPass3runERNS_6ModuleERNS_15AnalysisManagerIS1_JEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Coverage Diff</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Coverage Diff</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeline">//===-- AMDGPULowerModuleLDSPass.cpp ------------------------------*- C++ -*-=//</td>
    <td class="lineNumber">1</td>
    <td class="codeline">//===-- AMDGPULowerModuleLDSPass.cpp ------------------------------*- C++ -*-=//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeline">// This pass eliminates local data store, LDS, uses from non-kernel functions.</td>
    <td class="lineNumber">9</td>
    <td class="codeline">// This pass eliminates local data store, LDS, uses from non-kernel functions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeline">// LDS is contiguous memory allocated per kernel execution.</td>
    <td class="lineNumber">10</td>
    <td class="codeline">// LDS is contiguous memory allocated per kernel execution.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeline">//</td>
    <td class="lineNumber">11</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeline">// Background.</td>
    <td class="lineNumber">12</td>
    <td class="codeline">// Background.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeline">//</td>
    <td class="lineNumber">13</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeline">// The programming model is global variables, or equivalently function local</td>
    <td class="lineNumber">14</td>
    <td class="codeline">// The programming model is global variables, or equivalently function local</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeline">// static variables, accessible from kernels or other functions. For uses from</td>
    <td class="lineNumber">15</td>
    <td class="codeline">// static variables, accessible from kernels or other functions. For uses from</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeline">// kernels this is straightforward - assign an integer to the kernel for the</td>
    <td class="lineNumber">16</td>
    <td class="codeline">// kernels this is straightforward - assign an integer to the kernel for the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeline">// memory required by all the variables combined, allocate them within that.</td>
    <td class="lineNumber">17</td>
    <td class="codeline">// memory required by all the variables combined, allocate them within that.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeline">// For uses from functions there are performance tradeoffs to choose between.</td>
    <td class="lineNumber">18</td>
    <td class="codeline">// For uses from functions there are performance tradeoffs to choose between.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeline">//</td>
    <td class="lineNumber">19</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeline">// This model means the GPU runtime can specify the amount of memory allocated.</td>
    <td class="lineNumber">20</td>
    <td class="codeline">// This model means the GPU runtime can specify the amount of memory allocated.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeline">// If this is more than the kernel assumed, the excess can be made available</td>
    <td class="lineNumber">21</td>
    <td class="codeline">// If this is more than the kernel assumed, the excess can be made available</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeline">// using a language specific feature, which IR represents as a variable with</td>
    <td class="lineNumber">22</td>
    <td class="codeline">// using a language specific feature, which IR represents as a variable with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeline">// no initializer. This feature is referred to here as "Dynamic LDS" and is</td>
    <td class="lineNumber">23</td>
    <td class="codeline">// no initializer. This feature is referred to here as "Dynamic LDS" and is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeline">// lowered slightly differently to the normal case.</td>
    <td class="lineNumber">24</td>
    <td class="codeline">// lowered slightly differently to the normal case.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeline">//</td>
    <td class="lineNumber">25</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeline">// Consequences of this GPU feature:</td>
    <td class="lineNumber">26</td>
    <td class="codeline">// Consequences of this GPU feature:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeline">// - memory is limited and exceeding it halts compilation</td>
    <td class="lineNumber">27</td>
    <td class="codeline">// - memory is limited and exceeding it halts compilation</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeline">// - a global accessed by one kernel exists independent of other kernels</td>
    <td class="lineNumber">28</td>
    <td class="codeline">// - a global accessed by one kernel exists independent of other kernels</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeline">// - a global exists independent of simultaneous execution of the same kernel</td>
    <td class="lineNumber">29</td>
    <td class="codeline">// - a global exists independent of simultaneous execution of the same kernel</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeline">// - the address of the global may be different from different kernels as they</td>
    <td class="lineNumber">30</td>
    <td class="codeline">// - the address of the global may be different from different kernels as they</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeline">//   do not alias, which permits only allocating variables they use</td>
    <td class="lineNumber">31</td>
    <td class="codeline">//   do not alias, which permits only allocating variables they use</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeline">// - if the address is allowed to differ, functions need help to find it</td>
    <td class="lineNumber">32</td>
    <td class="codeline">// - if the address is allowed to differ, functions need help to find it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeline">//</td>
    <td class="lineNumber">33</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeline">// Uses from kernels are implemented here by grouping them in a per-kernel</td>
    <td class="lineNumber">34</td>
    <td class="codeline">// Uses from kernels are implemented here by grouping them in a per-kernel</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeline">// struct instance. This duplicates the variables, accurately modelling their</td>
    <td class="lineNumber">35</td>
    <td class="codeline">// struct instance. This duplicates the variables, accurately modelling their</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeline">// aliasing properties relative to a single global representation. It also</td>
    <td class="lineNumber">36</td>
    <td class="codeline">// aliasing properties relative to a single global representation. It also</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeline">// permits control over alignment via padding.</td>
    <td class="lineNumber">37</td>
    <td class="codeline">// permits control over alignment via padding.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeline">//</td>
    <td class="lineNumber">38</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeline">// Uses from functions are more complicated and the primary purpose of this</td>
    <td class="lineNumber">39</td>
    <td class="codeline">// Uses from functions are more complicated and the primary purpose of this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeline">// IR pass. Several different lowering are chosen between to meet requirements</td>
    <td class="lineNumber">40</td>
    <td class="codeline">// IR pass. Several different lowering are chosen between to meet requirements</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeline">// to avoid allocating any LDS where it is not necessary, as that impacts</td>
    <td class="lineNumber">41</td>
    <td class="codeline">// to avoid allocating any LDS where it is not necessary, as that impacts</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeline">// occupancy and may fail the compilation, while not imposing overhead on a</td>
    <td class="lineNumber">42</td>
    <td class="codeline">// occupancy and may fail the compilation, while not imposing overhead on a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeline">// feature whose primary advantage over global memory is performance. The basic</td>
    <td class="lineNumber">43</td>
    <td class="codeline">// feature whose primary advantage over global memory is performance. The basic</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeline">// design goal is to avoid one kernel imposing overhead on another.</td>
    <td class="lineNumber">44</td>
    <td class="codeline">// design goal is to avoid one kernel imposing overhead on another.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeline">//</td>
    <td class="lineNumber">45</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeline">// Implementation.</td>
    <td class="lineNumber">46</td>
    <td class="codeline">// Implementation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeline">//</td>
    <td class="lineNumber">47</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeline">// LDS variables with constant annotation or non-undef initializer are passed</td>
    <td class="lineNumber">48</td>
    <td class="codeline">// LDS variables with constant annotation or non-undef initializer are passed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeline">// through unchanged for simplification or error diagnostics in later passes.</td>
    <td class="lineNumber">49</td>
    <td class="codeline">// through unchanged for simplification or error diagnostics in later passes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeline">// Non-undef initializers are not yet implemented for LDS.</td>
    <td class="lineNumber">50</td>
    <td class="codeline">// Non-undef initializers are not yet implemented for LDS.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeline">//</td>
    <td class="lineNumber">51</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeline">// LDS variables that are always allocated at the same address can be found</td>
    <td class="lineNumber">52</td>
    <td class="codeline">// LDS variables that are always allocated at the same address can be found</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeline">// by lookup at that address. Otherwise runtime information/cost is required.</td>
    <td class="lineNumber">53</td>
    <td class="codeline">// by lookup at that address. Otherwise runtime information/cost is required.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeline">//</td>
    <td class="lineNumber">54</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeline">// The simplest strategy possible is to group all LDS variables in a single</td>
    <td class="lineNumber">55</td>
    <td class="codeline">// The simplest strategy possible is to group all LDS variables in a single</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeline">// struct and allocate that struct in every kernel such that the original</td>
    <td class="lineNumber">56</td>
    <td class="codeline">// struct and allocate that struct in every kernel such that the original</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeline">// variables are always at the same address. LDS is however a limited resource</td>
    <td class="lineNumber">57</td>
    <td class="codeline">// variables are always at the same address. LDS is however a limited resource</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeline">// so this strategy is unusable in practice. It is not implemented here.</td>
    <td class="lineNumber">58</td>
    <td class="codeline">// so this strategy is unusable in practice. It is not implemented here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeline">//</td>
    <td class="lineNumber">59</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeline">// Strategy | Precise allocation | Zero runtime cost | General purpose |</td>
    <td class="lineNumber">60</td>
    <td class="codeline">// Strategy | Precise allocation | Zero runtime cost | General purpose |</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeline">//  --------+--------------------+-------------------+-----------------+</td>
    <td class="lineNumber">61</td>
    <td class="codeline">//  --------+--------------------+-------------------+-----------------+</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeline">//   Module |                 No |               Yes |             Yes |</td>
    <td class="lineNumber">62</td>
    <td class="codeline">//   Module |                 No |               Yes |             Yes |</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeline">//    Table |                Yes |                No |             Yes |</td>
    <td class="lineNumber">63</td>
    <td class="codeline">//    Table |                Yes |                No |             Yes |</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeline">//   Kernel |                Yes |               Yes |              No |</td>
    <td class="lineNumber">64</td>
    <td class="codeline">//   Kernel |                Yes |               Yes |              No |</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeline">//   Hybrid |                Yes |           Partial |             Yes |</td>
    <td class="lineNumber">65</td>
    <td class="codeline">//   Hybrid |                Yes |           Partial |             Yes |</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeline">//</td>
    <td class="lineNumber">66</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeline">// "Module" spends LDS memory to save cycles. "Table" spends cycles and global</td>
    <td class="lineNumber">67</td>
    <td class="codeline">// "Module" spends LDS memory to save cycles. "Table" spends cycles and global</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeline">// memory to save LDS. "Kernel" is as fast as kernel allocation but only works</td>
    <td class="lineNumber">68</td>
    <td class="codeline">// memory to save LDS. "Kernel" is as fast as kernel allocation but only works</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeline">// for variables that are known reachable from a single kernel. "Hybrid" picks</td>
    <td class="lineNumber">69</td>
    <td class="codeline">// for variables that are known reachable from a single kernel. "Hybrid" picks</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeline">// between all three. When forced to choose between LDS and cycles we minimise</td>
    <td class="lineNumber">70</td>
    <td class="codeline">// between all three. When forced to choose between LDS and cycles we minimise</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeline">// LDS use.</td>
    <td class="lineNumber">71</td>
    <td class="codeline">// LDS use.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeline"></td>
    <td class="lineNumber">72</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeline">// The "module" lowering implemented here finds LDS variables which are used by</td>
    <td class="lineNumber">73</td>
    <td class="codeline">// The "module" lowering implemented here finds LDS variables which are used by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeline">// non-kernel functions and creates a new struct with a field for each of those</td>
    <td class="lineNumber">74</td>
    <td class="codeline">// non-kernel functions and creates a new struct with a field for each of those</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeline">// LDS variables. Variables that are only used from kernels are excluded.</td>
    <td class="lineNumber">75</td>
    <td class="codeline">// LDS variables. Variables that are only used from kernels are excluded.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeline">//</td>
    <td class="lineNumber">76</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeline">// The "table" lowering implemented here has three components.</td>
    <td class="lineNumber">77</td>
    <td class="codeline">// The "table" lowering implemented here has three components.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeline">// First kernels are assigned a unique integer identifier which is available in</td>
    <td class="lineNumber">78</td>
    <td class="codeline">// First kernels are assigned a unique integer identifier which is available in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeline">// functions it calls through the intrinsic amdgcn_lds_kernel_id. The integer</td>
    <td class="lineNumber">79</td>
    <td class="codeline">// functions it calls through the intrinsic amdgcn_lds_kernel_id. The integer</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeline">// is passed through a specific SGPR, thus works with indirect calls.</td>
    <td class="lineNumber">80</td>
    <td class="codeline">// is passed through a specific SGPR, thus works with indirect calls.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeline">// Second, each kernel allocates LDS variables independent of other kernels and</td>
    <td class="lineNumber">81</td>
    <td class="codeline">// Second, each kernel allocates LDS variables independent of other kernels and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeline">// writes the addresses it chose for each variable into an array in consistent</td>
    <td class="lineNumber">82</td>
    <td class="codeline">// writes the addresses it chose for each variable into an array in consistent</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeline">// order. If the kernel does not allocate a given variable, it writes undef to</td>
    <td class="lineNumber">83</td>
    <td class="codeline">// order. If the kernel does not allocate a given variable, it writes undef to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeline">// the corresponding array location. These arrays are written to a constant</td>
    <td class="lineNumber">84</td>
    <td class="codeline">// the corresponding array location. These arrays are written to a constant</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeline">// table in the order matching the kernel unique integer identifier.</td>
    <td class="lineNumber">85</td>
    <td class="codeline">// table in the order matching the kernel unique integer identifier.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeline">// Third, uses from non-kernel functions are replaced with a table lookup using</td>
    <td class="lineNumber">86</td>
    <td class="codeline">// Third, uses from non-kernel functions are replaced with a table lookup using</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeline">// the intrinsic function to find the address of the variable.</td>
    <td class="lineNumber">87</td>
    <td class="codeline">// the intrinsic function to find the address of the variable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeline">//</td>
    <td class="lineNumber">88</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeline">// "Kernel" lowering is only applicable for variables that are unambiguously</td>
    <td class="lineNumber">89</td>
    <td class="codeline">// "Kernel" lowering is only applicable for variables that are unambiguously</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeline">// reachable from exactly one kernel. For those cases, accesses to the variable</td>
    <td class="lineNumber">90</td>
    <td class="codeline">// reachable from exactly one kernel. For those cases, accesses to the variable</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeline">// can be lowered to ConstantExpr address of a struct instance specific to that</td>
    <td class="lineNumber">91</td>
    <td class="codeline">// can be lowered to ConstantExpr address of a struct instance specific to that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeline">// one kernel. This is zero cost in space and in compute. It will raise a fatal</td>
    <td class="lineNumber">92</td>
    <td class="codeline">// one kernel. This is zero cost in space and in compute. It will raise a fatal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeline">// error on any variable that might be reachable from multiple kernels and is</td>
    <td class="lineNumber">93</td>
    <td class="codeline">// error on any variable that might be reachable from multiple kernels and is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeline">// thus most easily used as part of the hybrid lowering strategy.</td>
    <td class="lineNumber">94</td>
    <td class="codeline">// thus most easily used as part of the hybrid lowering strategy.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeline">//</td>
    <td class="lineNumber">95</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeline">// Hybrid lowering is a mixture of the above. It uses the zero cost kernel</td>
    <td class="lineNumber">96</td>
    <td class="codeline">// Hybrid lowering is a mixture of the above. It uses the zero cost kernel</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeline">// lowering where it can. It lowers the variable accessed by the greatest</td>
    <td class="lineNumber">97</td>
    <td class="codeline">// lowering where it can. It lowers the variable accessed by the greatest</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeline">// number of kernels using the module strategy as that is free for the first</td>
    <td class="lineNumber">98</td>
    <td class="codeline">// number of kernels using the module strategy as that is free for the first</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeline">// variable. Any futher variables that can be lowered with the module strategy</td>
    <td class="lineNumber">99</td>
    <td class="codeline">// variable. Any futher variables that can be lowered with the module strategy</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeline">// without incurring LDS memory overhead are. The remaining ones are lowered</td>
    <td class="lineNumber">100</td>
    <td class="codeline">// without incurring LDS memory overhead are. The remaining ones are lowered</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeline">// via table.</td>
    <td class="lineNumber">101</td>
    <td class="codeline">// via table.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeline">//</td>
    <td class="lineNumber">102</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeline">// Consequences</td>
    <td class="lineNumber">103</td>
    <td class="codeline">// Consequences</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeline">// - No heuristics or user controlled magic numbers, hybrid is the right choice</td>
    <td class="lineNumber">104</td>
    <td class="codeline">// - No heuristics or user controlled magic numbers, hybrid is the right choice</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeline">// - Kernels that don't use functions (or have had them all inlined) are not</td>
    <td class="lineNumber">105</td>
    <td class="codeline">// - Kernels that don't use functions (or have had them all inlined) are not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeline">//   affected by any lowering for kernels that do.</td>
    <td class="lineNumber">106</td>
    <td class="codeline">//   affected by any lowering for kernels that do.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeline">// - Kernels that don't make indirect function calls are not affected by those</td>
    <td class="lineNumber">107</td>
    <td class="codeline">// - Kernels that don't make indirect function calls are not affected by those</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeline">//   that do.</td>
    <td class="lineNumber">108</td>
    <td class="codeline">//   that do.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeline">// - Variables which are used by lots of kernels, e.g. those injected by a</td>
    <td class="lineNumber">109</td>
    <td class="codeline">// - Variables which are used by lots of kernels, e.g. those injected by a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeline">//   language runtime in most kernels, are expected to have no overhead</td>
    <td class="lineNumber">110</td>
    <td class="codeline">//   language runtime in most kernels, are expected to have no overhead</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeline">// - Implementations that instantiate templates per-kernel where those templates</td>
    <td class="lineNumber">111</td>
    <td class="codeline">// - Implementations that instantiate templates per-kernel where those templates</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeline">//   use LDS are expected to hit the "Kernel" lowering strategy</td>
    <td class="lineNumber">112</td>
    <td class="codeline">//   use LDS are expected to hit the "Kernel" lowering strategy</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeline">// - The runtime properties impose a cost in compiler implementation complexity</td>
    <td class="lineNumber">113</td>
    <td class="codeline">// - The runtime properties impose a cost in compiler implementation complexity</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeline">//</td>
    <td class="lineNumber">114</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeline">// Dynamic LDS implementation</td>
    <td class="lineNumber">115</td>
    <td class="codeline">// Dynamic LDS implementation</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeline">// Dynamic LDS is lowered similarly to the "table" strategy above and uses the</td>
    <td class="lineNumber">116</td>
    <td class="codeline">// Dynamic LDS is lowered similarly to the "table" strategy above and uses the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeline">// same intrinsic to identify which kernel is at the root of the dynamic call</td>
    <td class="lineNumber">117</td>
    <td class="codeline">// same intrinsic to identify which kernel is at the root of the dynamic call</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeline">// graph. This relies on the specified behaviour that all dynamic LDS variables</td>
    <td class="lineNumber">118</td>
    <td class="codeline">// graph. This relies on the specified behaviour that all dynamic LDS variables</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeline">// alias one another, i.e. are at the same address, with respect to a given</td>
    <td class="lineNumber">119</td>
    <td class="codeline">// alias one another, i.e. are at the same address, with respect to a given</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeline">// kernel. Therefore this pass creates new dynamic LDS variables for each kernel</td>
    <td class="lineNumber">120</td>
    <td class="codeline">// kernel. Therefore this pass creates new dynamic LDS variables for each kernel</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeline">// that allocates any dynamic LDS and builds a table of addresses out of those.</td>
    <td class="lineNumber">121</td>
    <td class="codeline">// that allocates any dynamic LDS and builds a table of addresses out of those.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeline">// The AMDGPUPromoteAlloca pass skips kernels that use dynamic LDS.</td>
    <td class="lineNumber">122</td>
    <td class="codeline">// The AMDGPUPromoteAlloca pass skips kernels that use dynamic LDS.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeline">// The corresponding optimisation for "kernel" lowering where the table lookup</td>
    <td class="lineNumber">123</td>
    <td class="codeline">// The corresponding optimisation for "kernel" lowering where the table lookup</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeline">// is elided is not implemented.</td>
    <td class="lineNumber">124</td>
    <td class="codeline">// is elided is not implemented.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeline">//</td>
    <td class="lineNumber">125</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeline">//</td>
    <td class="lineNumber">126</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeline">// Implementation notes / limitations</td>
    <td class="lineNumber">127</td>
    <td class="codeline">// Implementation notes / limitations</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeline">// A single LDS global variable represents an instance per kernel that can reach</td>
    <td class="lineNumber">128</td>
    <td class="codeline">// A single LDS global variable represents an instance per kernel that can reach</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeline">// said variables. This pass essentially specialises said variables per kernel.</td>
    <td class="lineNumber">129</td>
    <td class="codeline">// said variables. This pass essentially specialises said variables per kernel.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeline">// Handling ConstantExpr during the pass complicated this significantly so now</td>
    <td class="lineNumber">130</td>
    <td class="codeline">// Handling ConstantExpr during the pass complicated this significantly so now</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeline">// all ConstantExpr uses of LDS variables are expanded to instructions. This</td>
    <td class="lineNumber">131</td>
    <td class="codeline">// all ConstantExpr uses of LDS variables are expanded to instructions. This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeline">// may need amending when implementing non-undef initialisers.</td>
    <td class="lineNumber">132</td>
    <td class="codeline">// may need amending when implementing non-undef initialisers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeline">//</td>
    <td class="lineNumber">133</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeline">// Lowering is split between this IR pass and the back end. This pass chooses</td>
    <td class="lineNumber">134</td>
    <td class="codeline">// Lowering is split between this IR pass and the back end. This pass chooses</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeline">// where given variables should be allocated and marks them with metadata,</td>
    <td class="lineNumber">135</td>
    <td class="codeline">// where given variables should be allocated and marks them with metadata,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeline">// MD_absolute_symbol. The backend places the variables in coincidentally the</td>
    <td class="lineNumber">136</td>
    <td class="codeline">// MD_absolute_symbol. The backend places the variables in coincidentally the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeline">// same location and raises a fatal error if something has gone awry. This works</td>
    <td class="lineNumber">137</td>
    <td class="codeline">// same location and raises a fatal error if something has gone awry. This works</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeline">// in practice because the only pass between this one and the backend that</td>
    <td class="lineNumber">138</td>
    <td class="codeline">// in practice because the only pass between this one and the backend that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeline">// changes LDS is PromoteAlloca and the changes it makes do not conflict.</td>
    <td class="lineNumber">139</td>
    <td class="codeline">// changes LDS is PromoteAlloca and the changes it makes do not conflict.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeline">//</td>
    <td class="lineNumber">140</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeline">// Addresses are written to constant global arrays based on the same metadata.</td>
    <td class="lineNumber">141</td>
    <td class="codeline">// Addresses are written to constant global arrays based on the same metadata.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeline">//</td>
    <td class="lineNumber">142</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeline">// The backend lowers LDS variables in the order of traversal of the function.</td>
    <td class="lineNumber">143</td>
    <td class="codeline">// The backend lowers LDS variables in the order of traversal of the function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeline">// This is at odds with the deterministic layout required. The workaround is to</td>
    <td class="lineNumber">144</td>
    <td class="codeline">// This is at odds with the deterministic layout required. The workaround is to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeline">// allocate the fixed-address variables immediately upon starting the function</td>
    <td class="lineNumber">145</td>
    <td class="codeline">// allocate the fixed-address variables immediately upon starting the function</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeline">// where they can be placed as intended. This requires a means of mapping from</td>
    <td class="lineNumber">146</td>
    <td class="codeline">// where they can be placed as intended. This requires a means of mapping from</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeline">// the function to the variables that it allocates. For the module scope lds,</td>
    <td class="lineNumber">147</td>
    <td class="codeline">// the function to the variables that it allocates. For the module scope lds,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeline">// this is via metadata indicating whether the variable is not required. If a</td>
    <td class="lineNumber">148</td>
    <td class="codeline">// this is via metadata indicating whether the variable is not required. If a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeline">// pass deletes that metadata, a fatal error on disagreement with the absolute</td>
    <td class="lineNumber">149</td>
    <td class="codeline">// pass deletes that metadata, a fatal error on disagreement with the absolute</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeline">// symbol metadata will occur. For kernel scope and dynamic, this is by _name_</td>
    <td class="lineNumber">150</td>
    <td class="codeline">// symbol metadata will occur. For kernel scope and dynamic, this is by _name_</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeline">// correspondence between the function and the variable. It requires the</td>
    <td class="lineNumber">151</td>
    <td class="codeline">// correspondence between the function and the variable. It requires the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeline">// kernel to have a name (which is only a limitation for tests in practice) and</td>
    <td class="lineNumber">152</td>
    <td class="codeline">// kernel to have a name (which is only a limitation for tests in practice) and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeline">// for nothing to rename the corresponding symbols. This is a hazard if the pass</td>
    <td class="lineNumber">153</td>
    <td class="codeline">// for nothing to rename the corresponding symbols. This is a hazard if the pass</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeline">// is run multiple times during debugging. Alternative schemes considered all</td>
    <td class="lineNumber">154</td>
    <td class="codeline">// is run multiple times during debugging. Alternative schemes considered all</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeline">// involve bespoke metadata.</td>
    <td class="lineNumber">155</td>
    <td class="codeline">// involve bespoke metadata.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeline">//</td>
    <td class="lineNumber">156</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeline">// If the name correspondence can be replaced, multiple distinct kernels that</td>
    <td class="lineNumber">157</td>
    <td class="codeline">// If the name correspondence can be replaced, multiple distinct kernels that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeline">// have the same memory layout can map to the same kernel id (as the address</td>
    <td class="lineNumber">158</td>
    <td class="codeline">// have the same memory layout can map to the same kernel id (as the address</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeline">// itself is handled by the absolute symbol metadata) and that will allow more</td>
    <td class="lineNumber">159</td>
    <td class="codeline">// itself is handled by the absolute symbol metadata) and that will allow more</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeline">// uses of the "kernel" style faster lowering and reduce the size of the lookup</td>
    <td class="lineNumber">160</td>
    <td class="codeline">// uses of the "kernel" style faster lowering and reduce the size of the lookup</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeline">// tables.</td>
    <td class="lineNumber">161</td>
    <td class="codeline">// tables.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeline">//</td>
    <td class="lineNumber">162</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeline">// There is a test that checks this does not fire for a graphics shader. This</td>
    <td class="lineNumber">163</td>
    <td class="codeline">// There is a test that checks this does not fire for a graphics shader. This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeline">// lowering is expected to work for graphics if the isKernel test is changed.</td>
    <td class="lineNumber">164</td>
    <td class="codeline">// lowering is expected to work for graphics if the isKernel test is changed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeline">//</td>
    <td class="lineNumber">165</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeline">// The current markUsedByKernel is sufficient for PromoteAlloca but is elided</td>
    <td class="lineNumber">166</td>
    <td class="codeline">// The current markUsedByKernel is sufficient for PromoteAlloca but is elided</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeline">// before codegen. Replacing this with an equivalent intrinsic which lasts until</td>
    <td class="lineNumber">167</td>
    <td class="codeline">// before codegen. Replacing this with an equivalent intrinsic which lasts until</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeline">// shortly after the machine function lowering of LDS would help break the name</td>
    <td class="lineNumber">168</td>
    <td class="codeline">// shortly after the machine function lowering of LDS would help break the name</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeline">// mapping. The other part needed is probably to amend PromoteAlloca to embed</td>
    <td class="lineNumber">169</td>
    <td class="codeline">// mapping. The other part needed is probably to amend PromoteAlloca to embed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeline">// the LDS variables it creates in the same struct created here. That avoids the</td>
    <td class="lineNumber">170</td>
    <td class="codeline">// the LDS variables it creates in the same struct created here. That avoids the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeline">// current hazard where a PromoteAlloca LDS variable might be allocated before</td>
    <td class="lineNumber">171</td>
    <td class="codeline">// current hazard where a PromoteAlloca LDS variable might be allocated before</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeline">// the kernel scope (and thus error on the address check). Given a new invariant</td>
    <td class="lineNumber">172</td>
    <td class="codeline">// the kernel scope (and thus error on the address check). Given a new invariant</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeline">// that no LDS variables exist outside of the structs managed here, and an</td>
    <td class="lineNumber">173</td>
    <td class="codeline">// that no LDS variables exist outside of the structs managed here, and an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeline">// intrinsic that lasts until after the LDS frame lowering, it should be</td>
    <td class="lineNumber">174</td>
    <td class="codeline">// intrinsic that lasts until after the LDS frame lowering, it should be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeline">// possible to drop the name mapping and fold equivalent memory layouts.</td>
    <td class="lineNumber">175</td>
    <td class="codeline">// possible to drop the name mapping and fold equivalent memory layouts.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeline">//</td>
    <td class="lineNumber">176</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">177</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeline"></td>
    <td class="lineNumber">178</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeline">#include "AMDGPU.h"</td>
    <td class="lineNumber">179</td>
    <td class="codeline">#include "AMDGPU.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeline">#include "Utils/AMDGPUBaseInfo.h"</td>
    <td class="lineNumber">180</td>
    <td class="codeline">#include "Utils/AMDGPUBaseInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeline">#include "Utils/AMDGPUMemoryUtils.h"</td>
    <td class="lineNumber">181</td>
    <td class="codeline">#include "Utils/AMDGPUMemoryUtils.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeline">#include "llvm/ADT/BitVector.h"</td>
    <td class="lineNumber">182</td>
    <td class="codeline">#include "llvm/ADT/BitVector.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeline">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">183</td>
    <td class="codeline">#include "llvm/ADT/DenseMap.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeline">#include "llvm/ADT/DenseSet.h"</td>
    <td class="lineNumber">184</td>
    <td class="codeline">#include "llvm/ADT/DenseSet.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeline">#include "llvm/ADT/STLExtras.h"</td>
    <td class="lineNumber">185</td>
    <td class="codeline">#include "llvm/ADT/STLExtras.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeline">#include "llvm/ADT/SetOperations.h"</td>
    <td class="lineNumber">186</td>
    <td class="codeline">#include "llvm/ADT/SetOperations.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeline">#include "llvm/ADT/SetVector.h"</td>
    <td class="lineNumber">187</td>
    <td class="codeline">#include "llvm/ADT/SetVector.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeline">#include "llvm/Analysis/CallGraph.h"</td>
    <td class="lineNumber">188</td>
    <td class="codeline">#include "llvm/Analysis/CallGraph.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeline">#include "llvm/IR/Constants.h"</td>
    <td class="lineNumber">189</td>
    <td class="codeline">#include "llvm/IR/Constants.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeline">#include "llvm/IR/DerivedTypes.h"</td>
    <td class="lineNumber">190</td>
    <td class="codeline">#include "llvm/IR/DerivedTypes.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeline">#include "llvm/IR/IRBuilder.h"</td>
    <td class="lineNumber">191</td>
    <td class="codeline">#include "llvm/IR/IRBuilder.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeline">#include "llvm/IR/InlineAsm.h"</td>
    <td class="lineNumber">192</td>
    <td class="codeline">#include "llvm/IR/InlineAsm.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeline">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">193</td>
    <td class="codeline">#include "llvm/IR/Instructions.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeline">#include "llvm/IR/IntrinsicsAMDGPU.h"</td>
    <td class="lineNumber">194</td>
    <td class="codeline">#include "llvm/IR/IntrinsicsAMDGPU.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeline">#include "llvm/IR/MDBuilder.h"</td>
    <td class="lineNumber">195</td>
    <td class="codeline">#include "llvm/IR/MDBuilder.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeline">#include "llvm/IR/ReplaceConstant.h"</td>
    <td class="lineNumber">196</td>
    <td class="codeline">#include "llvm/IR/ReplaceConstant.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeline">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">197</td>
    <td class="codeline">#include "llvm/InitializePasses.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeline">#include "llvm/Pass.h"</td>
    <td class="lineNumber">198</td>
    <td class="codeline">#include "llvm/Pass.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeline">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">199</td>
    <td class="codeline">#include "llvm/Support/CommandLine.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeline">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">200</td>
    <td class="codeline">#include "llvm/Support/Debug.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeline">#include "llvm/Support/Format.h"</td>
    <td class="lineNumber">201</td>
    <td class="codeline">#include "llvm/Support/Format.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeline">#include "llvm/Support/OptimizedStructLayout.h"</td>
    <td class="lineNumber">202</td>
    <td class="codeline">#include "llvm/Support/OptimizedStructLayout.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeline">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">203</td>
    <td class="codeline">#include "llvm/Support/raw_ostream.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeline">#include "llvm/Transforms/Utils/BasicBlockUtils.h"</td>
    <td class="lineNumber">204</td>
    <td class="codeline">#include "llvm/Transforms/Utils/BasicBlockUtils.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeline">#include "llvm/Transforms/Utils/ModuleUtils.h"</td>
    <td class="lineNumber">205</td>
    <td class="codeline">#include "llvm/Transforms/Utils/ModuleUtils.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeline"></td>
    <td class="lineNumber">206</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeline">#include <tuple></td>
    <td class="lineNumber">207</td>
    <td class="codeline">#include <tuple></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeline">#include <vector></td>
    <td class="lineNumber">208</td>
    <td class="codeline">#include <vector></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeline"></td>
    <td class="lineNumber">209</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeline">#include <cstdio></td>
    <td class="lineNumber">210</td>
    <td class="codeline">#include <cstdio></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeline"></td>
    <td class="lineNumber">211</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeline">#define DEBUG_TYPE "amdgpu-lower-module-lds"</td>
    <td class="lineNumber">212</td>
    <td class="codeline">#define DEBUG_TYPE "amdgpu-lower-module-lds"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeline"></td>
    <td class="lineNumber">213</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeline">using namespace llvm;</td>
    <td class="lineNumber">214</td>
    <td class="codeline">using namespace llvm;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeline"></td>
    <td class="lineNumber">215</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeline">namespace {</td>
    <td class="lineNumber">216</td>
    <td class="codeline">namespace {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeline"></td>
    <td class="lineNumber">217</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeline">cl::opt<bool> SuperAlignLDSGlobals(</td>
    <td class="lineNumber">218</td>
    <td class="codeline">cl::opt<bool> SuperAlignLDSGlobals(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeline">    "amdgpu-super-align-lds-globals",</td>
    <td class="lineNumber">219</td>
    <td class="codeline">    "amdgpu-super-align-lds-globals",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeline">    cl::desc("Increase alignment of LDS if it is not on align boundary"),</td>
    <td class="lineNumber">220</td>
    <td class="codeline">    cl::desc("Increase alignment of LDS if it is not on align boundary"),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeline">    cl::init(true), cl::Hidden);</td>
    <td class="lineNumber">221</td>
    <td class="codeline">    cl::init(true), cl::Hidden);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeline"></td>
    <td class="lineNumber">222</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeline">enum class LoweringKind { module, table, kernel, hybrid };</td>
    <td class="lineNumber">223</td>
    <td class="codeline">enum class LoweringKind { module, table, kernel, hybrid };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeline">cl::opt<LoweringKind> LoweringKindLoc(</td>
    <td class="lineNumber">224</td>
    <td class="codeline">cl::opt<LoweringKind> LoweringKindLoc(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeline">    "amdgpu-lower-module-lds-strategy",</td>
    <td class="lineNumber">225</td>
    <td class="codeline">    "amdgpu-lower-module-lds-strategy",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeline">    cl::desc("Specify lowering strategy for function LDS access:"), cl::Hidden,</td>
    <td class="lineNumber">226</td>
    <td class="codeline">    cl::desc("Specify lowering strategy for function LDS access:"), cl::Hidden,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeline">    cl::init(LoweringKind::hybrid),</td>
    <td class="lineNumber">227</td>
    <td class="codeline">    cl::init(LoweringKind::hybrid),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeline">    cl::values(</td>
    <td class="lineNumber">228</td>
    <td class="codeline">    cl::values(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeline">        clEnumValN(LoweringKind::table, "table", "Lower via table lookup"),</td>
    <td class="lineNumber">229</td>
    <td class="codeline">        clEnumValN(LoweringKind::table, "table", "Lower via table lookup"),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeline">        clEnumValN(LoweringKind::module, "module", "Lower via module struct"),</td>
    <td class="lineNumber">230</td>
    <td class="codeline">        clEnumValN(LoweringKind::module, "module", "Lower via module struct"),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeline">        clEnumValN(</td>
    <td class="lineNumber">231</td>
    <td class="codeline">        clEnumValN(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeline">            LoweringKind::kernel, "kernel",</td>
    <td class="lineNumber">232</td>
    <td class="codeline">            LoweringKind::kernel, "kernel",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeline">            "Lower variables reachable from one kernel, otherwise abort"),</td>
    <td class="lineNumber">233</td>
    <td class="codeline">            "Lower variables reachable from one kernel, otherwise abort"),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeline">        clEnumValN(LoweringKind::hybrid, "hybrid",</td>
    <td class="lineNumber">234</td>
    <td class="codeline">        clEnumValN(LoweringKind::hybrid, "hybrid",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeline">                   "Lower via mixture of above strategies")));</td>
    <td class="lineNumber">235</td>
    <td class="codeline">                   "Lower via mixture of above strategies")));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeline"></td>
    <td class="lineNumber">236</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeline">bool isKernelLDS(const Function *F) {</td>
    <td class="lineNumber">237</td>
    <td class="codeline">bool isKernelLDS(const Function *F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeline">  // Some weirdness here. AMDGPU::isKernelCC does not call into</td>
    <td class="lineNumber">238</td>
    <td class="codeline">  // Some weirdness here. AMDGPU::isKernelCC does not call into</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeline">  // AMDGPU::isKernel with the calling conv, it instead calls into</td>
    <td class="lineNumber">239</td>
    <td class="codeline">  // AMDGPU::isKernel with the calling conv, it instead calls into</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeline">  // isModuleEntryFunction which returns true for more calling conventions</td>
    <td class="lineNumber">240</td>
    <td class="codeline">  // isModuleEntryFunction which returns true for more calling conventions</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeline">  // than AMDGPU::isKernel does. There's a FIXME on AMDGPU::isKernel.</td>
    <td class="lineNumber">241</td>
    <td class="codeline">  // than AMDGPU::isKernel does. There's a FIXME on AMDGPU::isKernel.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeline">  // There's also a test that checks that the LDS lowering does not hit on</td>
    <td class="lineNumber">242</td>
    <td class="codeline">  // There's also a test that checks that the LDS lowering does not hit on</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeline">  // a graphics shader, denoted amdgpu_ps, so stay with the limited case.</td>
    <td class="lineNumber">243</td>
    <td class="codeline">  // a graphics shader, denoted amdgpu_ps, so stay with the limited case.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeline">  // Putting LDS in the name of the function to draw attention to this.</td>
    <td class="lineNumber">244</td>
    <td class="codeline">  // Putting LDS in the name of the function to draw attention to this.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeline">  return AMDGPU::isKernel(F->getCallingConv());</td>
    <td class="lineNumber">245</td>
    <td class="codeline">  return AMDGPU::isKernel(F->getCallingConv());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeline">}</td>
    <td class="lineNumber">246</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeline"></td>
    <td class="lineNumber">247</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeline">template <typename T> std::vector<T> sortByName(std::vector<T> &&V) {</td>
    <td class="lineNumber">248</td>
    <td class="codeline">template <typename T> std::vector<T> sortByName(std::vector<T> &&V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeline">  llvm::sort(V.begin(), V.end(), [](const auto *L, const auto *R) {</td>
    <td class="lineNumber">249</td>
    <td class="codeline">  llvm::sort(V.begin(), V.end(), [](const auto *L, const auto *R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeline">    return L->getName() < R->getName();</td>
    <td class="lineNumber">250</td>
    <td class="codeline">    return L->getName() < R->getName();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">251</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeline">  return {std::move(V)};</td>
    <td class="lineNumber">252</td>
    <td class="codeline">  return {std::move(V)};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeline">}</td>
    <td class="lineNumber">253</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeline"></td>
    <td class="lineNumber">254</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeline">class AMDGPULowerModuleLDS : public ModulePass {</td>
    <td class="lineNumber">255</td>
    <td class="codeline">class AMDGPULowerModuleLDS : public ModulePass {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeline"></td>
    <td class="lineNumber">256</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeline">  static void</td>
    <td class="lineNumber">257</td>
    <td class="codeline">  static void</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeline">  removeLocalVarsFromUsedLists(Module &M,</td>
    <td class="lineNumber">258</td>
    <td class="codeline">  removeLocalVarsFromUsedLists(Module &M,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeline">                               const DenseSet<GlobalVariable *> &LocalVars) {</td>
    <td class="lineNumber">259</td>
    <td class="codeline">                               const DenseSet<GlobalVariable *> &LocalVars) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeline">    // The verifier rejects used lists containing an inttoptr of a constant</td>
    <td class="lineNumber">260</td>
    <td class="codeline">    // The verifier rejects used lists containing an inttoptr of a constant</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeline">    // so remove the variables from these lists before replaceAllUsesWith</td>
    <td class="lineNumber">261</td>
    <td class="codeline">    // so remove the variables from these lists before replaceAllUsesWith</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeline">    SmallPtrSet<Constant *, 8> LocalVarsSet;</td>
    <td class="lineNumber">262</td>
    <td class="codeline">    SmallPtrSet<Constant *, 8> LocalVarsSet;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeline">    for (GlobalVariable *LocalVar : LocalVars)</td>
    <td class="lineNumber">263</td>
    <td class="codeline">    for (GlobalVariable *LocalVar : LocalVars)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeline">      LocalVarsSet.insert(cast<Constant>(LocalVar->stripPointerCasts()));</td>
    <td class="lineNumber">264</td>
    <td class="codeline">      LocalVarsSet.insert(cast<Constant>(LocalVar->stripPointerCasts()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeline"></td>
    <td class="lineNumber">265</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeline">    removeFromUsedLists(</td>
    <td class="lineNumber">266</td>
    <td class="codeline">    removeFromUsedLists(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeline">        M, [&LocalVarsSet](Constant *C) { return LocalVarsSet.count(C); });</td>
    <td class="lineNumber">267</td>
    <td class="codeline">        M, [&LocalVarsSet](Constant *C) { return LocalVarsSet.count(C); });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeline"></td>
    <td class="lineNumber">268</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeline">    for (GlobalVariable *LocalVar : LocalVars)</td>
    <td class="lineNumber">269</td>
    <td class="codeline">    for (GlobalVariable *LocalVar : LocalVars)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeline">      LocalVar->removeDeadConstantUsers();</td>
    <td class="lineNumber">270</td>
    <td class="codeline">      LocalVar->removeDeadConstantUsers();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">271</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeline"></td>
    <td class="lineNumber">272</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeline">  static void markUsedByKernel(Function *Func, GlobalVariable *SGV) {</td>
    <td class="lineNumber">273</td>
    <td class="codeline">  static void markUsedByKernel(Function *Func, GlobalVariable *SGV) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeline">    // The llvm.amdgcn.module.lds instance is implicitly used by all kernels</td>
    <td class="lineNumber">274</td>
    <td class="codeline">    // The llvm.amdgcn.module.lds instance is implicitly used by all kernels</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeline">    // that might call a function which accesses a field within it. This is</td>
    <td class="lineNumber">275</td>
    <td class="codeline">    // that might call a function which accesses a field within it. This is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeline">    // presently approximated to 'all kernels' if there are any such functions</td>
    <td class="lineNumber">276</td>
    <td class="codeline">    // presently approximated to 'all kernels' if there are any such functions</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeline">    // in the module. This implicit use is redefined as an explicit use here so</td>
    <td class="lineNumber">277</td>
    <td class="codeline">    // in the module. This implicit use is redefined as an explicit use here so</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeline">    // that later passes, specifically PromoteAlloca, account for the required</td>
    <td class="lineNumber">278</td>
    <td class="codeline">    // that later passes, specifically PromoteAlloca, account for the required</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeline">    // memory without any knowledge of this transform.</td>
    <td class="lineNumber">279</td>
    <td class="codeline">    // memory without any knowledge of this transform.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeline"></td>
    <td class="lineNumber">280</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeline">    // An operand bundle on llvm.donothing works because the call instruction</td>
    <td class="lineNumber">281</td>
    <td class="codeline">    // An operand bundle on llvm.donothing works because the call instruction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeline">    // survives until after the last pass that needs to account for LDS. It is</td>
    <td class="lineNumber">282</td>
    <td class="codeline">    // survives until after the last pass that needs to account for LDS. It is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeline">    // better than inline asm as the latter survives until the end of codegen. A</td>
    <td class="lineNumber">283</td>
    <td class="codeline">    // better than inline asm as the latter survives until the end of codegen. A</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeline">    // totally robust solution would be a function with the same semantics as</td>
    <td class="lineNumber">284</td>
    <td class="codeline">    // totally robust solution would be a function with the same semantics as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeline">    // llvm.donothing that takes a pointer to the instance and is lowered to a</td>
    <td class="lineNumber">285</td>
    <td class="codeline">    // llvm.donothing that takes a pointer to the instance and is lowered to a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeline">    // no-op after LDS is allocated, but that is not presently necessary.</td>
    <td class="lineNumber">286</td>
    <td class="codeline">    // no-op after LDS is allocated, but that is not presently necessary.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeline"></td>
    <td class="lineNumber">287</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeline">    // This intrinsic is eliminated shortly before instruction selection. It</td>
    <td class="lineNumber">288</td>
    <td class="codeline">    // This intrinsic is eliminated shortly before instruction selection. It</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeline">    // does not suffice to indicate to ISel that a given global which is not</td>
    <td class="lineNumber">289</td>
    <td class="codeline">    // does not suffice to indicate to ISel that a given global which is not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeline">    // immediately used by the kernel must still be allocated by it. An</td>
    <td class="lineNumber">290</td>
    <td class="codeline">    // immediately used by the kernel must still be allocated by it. An</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeline">    // equivalent target specific intrinsic which lasts until immediately after</td>
    <td class="lineNumber">291</td>
    <td class="codeline">    // equivalent target specific intrinsic which lasts until immediately after</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeline">    // codegen would suffice for that, but one would still need to ensure that</td>
    <td class="lineNumber">292</td>
    <td class="codeline">    // codegen would suffice for that, but one would still need to ensure that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeline">    // the variables are allocated in the anticpated order.</td>
    <td class="lineNumber">293</td>
    <td class="codeline">    // the variables are allocated in the anticpated order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeline">    IRBuilder<> Builder(Func->getEntryBlock().getFirstNonPHI());</td>
    <td class="lineNumber">294</td>
    <td class="codeline">    IRBuilder<> Builder(Func->getEntryBlock().getFirstNonPHI());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeline"></td>
    <td class="lineNumber">295</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeline">    Function *Decl =</td>
    <td class="lineNumber">296</td>
    <td class="codeline">    Function *Decl =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeline">        Intrinsic::getDeclaration(Func->getParent(), Intrinsic::donothing, {});</td>
    <td class="lineNumber">297</td>
    <td class="codeline">        Intrinsic::getDeclaration(Func->getParent(), Intrinsic::donothing, {});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeline"></td>
    <td class="lineNumber">298</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeline">    Value *UseInstance[1] = {</td>
    <td class="lineNumber">299</td>
    <td class="codeline">    Value *UseInstance[1] = {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeline">        Builder.CreateConstInBoundsGEP1_32(SGV->getValueType(), SGV, 0)};</td>
    <td class="lineNumber">300</td>
    <td class="codeline">        Builder.CreateConstInBoundsGEP1_32(SGV->getValueType(), SGV, 0)};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeline"></td>
    <td class="lineNumber">301</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeline">    Builder.CreateCall(</td>
    <td class="lineNumber">302</td>
    <td class="codeline">    Builder.CreateCall(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeline">        Decl, {}, {OperandBundleDefT<Value *>("ExplicitUse", UseInstance)});</td>
    <td class="lineNumber">303</td>
    <td class="codeline">        Decl, {}, {OperandBundleDefT<Value *>("ExplicitUse", UseInstance)});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">304</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeline"></td>
    <td class="lineNumber">305</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeline">  static bool eliminateConstantExprUsesOfLDSFromAllInstructions(Module &M) {</td>
    <td class="lineNumber">306</td>
    <td class="codeline">  static bool eliminateConstantExprUsesOfLDSFromAllInstructions(Module &M) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeline">    // Constants are uniqued within LLVM. A ConstantExpr referring to a LDS</td>
    <td class="lineNumber">307</td>
    <td class="codeline">    // Constants are uniqued within LLVM. A ConstantExpr referring to a LDS</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeline">    // global may have uses from multiple different functions as a result.</td>
    <td class="lineNumber">308</td>
    <td class="codeline">    // global may have uses from multiple different functions as a result.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeline">    // This pass specialises LDS variables with respect to the kernel that</td>
    <td class="lineNumber">309</td>
    <td class="codeline">    // This pass specialises LDS variables with respect to the kernel that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeline">    // allocates them.</td>
    <td class="lineNumber">310</td>
    <td class="codeline">    // allocates them.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeline"></td>
    <td class="lineNumber">311</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeline">    // This is semantically equivalent to (the unimplemented as slow):</td>
    <td class="lineNumber">312</td>
    <td class="codeline">    // This is semantically equivalent to (the unimplemented as slow):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeline">    // for (auto &F : M.functions())</td>
    <td class="lineNumber">313</td>
    <td class="codeline">    // for (auto &F : M.functions())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeline">    //   for (auto &BB : F)</td>
    <td class="lineNumber">314</td>
    <td class="codeline">    //   for (auto &BB : F)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeline">    //     for (auto &I : BB)</td>
    <td class="lineNumber">315</td>
    <td class="codeline">    //     for (auto &I : BB)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeline">    //       for (Use &Op : I.operands())</td>
    <td class="lineNumber">316</td>
    <td class="codeline">    //       for (Use &Op : I.operands())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeline">    //         if (constantExprUsesLDS(Op))</td>
    <td class="lineNumber">317</td>
    <td class="codeline">    //         if (constantExprUsesLDS(Op))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeline">    //           replaceConstantExprInFunction(I, Op);</td>
    <td class="lineNumber">318</td>
    <td class="codeline">    //           replaceConstantExprInFunction(I, Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeline"></td>
    <td class="lineNumber">319</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeline">    SmallVector<Constant *> LDSGlobals;</td>
    <td class="lineNumber">320</td>
    <td class="codeline">    SmallVector<Constant *> LDSGlobals;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeline">    for (auto &GV : M.globals())</td>
    <td class="lineNumber">321</td>
    <td class="codeline">    for (auto &GV : M.globals())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeline">      if (AMDGPU::isLDSVariableToLower(GV))</td>
    <td class="lineNumber">322</td>
    <td class="codeline">      if (AMDGPU::isLDSVariableToLower(GV))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeline">        LDSGlobals.push_back(&GV);</td>
    <td class="lineNumber">323</td>
    <td class="codeline">        LDSGlobals.push_back(&GV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeline"></td>
    <td class="lineNumber">324</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeline">    return convertUsersOfConstantsToInstructions(LDSGlobals);</td>
    <td class="lineNumber">325</td>
    <td class="codeline">    return convertUsersOfConstantsToInstructions(LDSGlobals);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">326</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeline"></td>
    <td class="lineNumber">327</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">328</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeline">  static char ID;</td>
    <td class="lineNumber">329</td>
    <td class="codeline">  static char ID;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeline"></td>
    <td class="lineNumber">330</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeline">  AMDGPULowerModuleLDS() : ModulePass(ID) {</td>
    <td class="lineNumber">331</td>
    <td class="codeline">  AMDGPULowerModuleLDS() : ModulePass(ID) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeline">    initializeAMDGPULowerModuleLDSPass(*PassRegistry::getPassRegistry());</td>
    <td class="lineNumber">332</td>
    <td class="codeline">    initializeAMDGPULowerModuleLDSPass(*PassRegistry::getPassRegistry());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">333</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeline"></td>
    <td class="lineNumber">334</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeline">  using FunctionVariableMap = DenseMap<Function *, DenseSet<GlobalVariable *>>;</td>
    <td class="lineNumber">335</td>
    <td class="codeline">  using FunctionVariableMap = DenseMap<Function *, DenseSet<GlobalVariable *>>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeline"></td>
    <td class="lineNumber">336</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeline">  using VariableFunctionMap = DenseMap<GlobalVariable *, DenseSet<Function *>>;</td>
    <td class="lineNumber">337</td>
    <td class="codeline">  using VariableFunctionMap = DenseMap<GlobalVariable *, DenseSet<Function *>>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeline"></td>
    <td class="lineNumber">338</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeline">  static void getUsesOfLDSByFunction(CallGraph const &CG, Module &M,</td>
    <td class="lineNumber">339</td>
    <td class="codeline">  static void getUsesOfLDSByFunction(CallGraph const &CG, Module &M,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeline">                                     FunctionVariableMap &kernels,</td>
    <td class="lineNumber">340</td>
    <td class="codeline">                                     FunctionVariableMap &kernels,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeline">                                     FunctionVariableMap &functions) {</td>
    <td class="lineNumber">341</td>
    <td class="codeline">                                     FunctionVariableMap &functions) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeline"></td>
    <td class="lineNumber">342</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeline">    // Get uses from the current function, excluding uses by called functions</td>
    <td class="lineNumber">343</td>
    <td class="codeline">    // Get uses from the current function, excluding uses by called functions</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeline">    // Two output variables to avoid walking the globals list twice</td>
    <td class="lineNumber">344</td>
    <td class="codeline">    // Two output variables to avoid walking the globals list twice</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeline">    for (auto &GV : M.globals()) {</td>
    <td class="lineNumber">345</td>
    <td class="codeline">    for (auto &GV : M.globals()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeline">      if (!AMDGPU::isLDSVariableToLower(GV)) {</td>
    <td class="lineNumber">346</td>
    <td class="codeline">      if (!AMDGPU::isLDSVariableToLower(GV)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">347</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">348</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeline"></td>
    <td class="lineNumber">349</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeline">      if (GV.isAbsoluteSymbolRef()) {</td>
    <td class="lineNumber">350</td>
    <td class="codeline">      if (GV.isAbsoluteSymbolRef()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeline">        report_fatal_error(</td>
    <td class="lineNumber">351</td>
    <td class="codeline">        report_fatal_error(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeline">            "LDS variables with absolute addresses are unimplemented.");</td>
    <td class="lineNumber">352</td>
    <td class="codeline">            "LDS variables with absolute addresses are unimplemented.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">353</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeline"></td>
    <td class="lineNumber">354</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeline">      for (User *V : GV.users()) {</td>
    <td class="lineNumber">355</td>
    <td class="codeline">      for (User *V : GV.users()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeline">        if (auto *I = dyn_cast<Instruction>(V)) {</td>
    <td class="lineNumber">356</td>
    <td class="codeline">        if (auto *I = dyn_cast<Instruction>(V)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeline">          Function *F = I->getFunction();</td>
    <td class="lineNumber">357</td>
    <td class="codeline">          Function *F = I->getFunction();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeline">          if (isKernelLDS(F)) {</td>
    <td class="lineNumber">358</td>
    <td class="codeline">          if (isKernelLDS(F)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeline">            kernels[F].insert(&GV);</td>
    <td class="lineNumber">359</td>
    <td class="codeline">            kernels[F].insert(&GV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeline">          } else {</td>
    <td class="lineNumber">360</td>
    <td class="codeline">          } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeline">            functions[F].insert(&GV);</td>
    <td class="lineNumber">361</td>
    <td class="codeline">            functions[F].insert(&GV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">362</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">363</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">364</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">365</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">366</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeline"></td>
    <td class="lineNumber">367</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeline">  struct LDSUsesInfoTy {</td>
    <td class="lineNumber">368</td>
    <td class="codeline">  struct LDSUsesInfoTy {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeline">    FunctionVariableMap direct_access;</td>
    <td class="lineNumber">369</td>
    <td class="codeline">    FunctionVariableMap direct_access;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeline">    FunctionVariableMap indirect_access;</td>
    <td class="lineNumber">370</td>
    <td class="codeline">    FunctionVariableMap indirect_access;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">371</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeline"></td>
    <td class="lineNumber">372</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeline">  static LDSUsesInfoTy getTransitiveUsesOfLDS(CallGraph const &CG, Module &M) {</td>
    <td class="lineNumber">373</td>
    <td class="codeline">  static LDSUsesInfoTy getTransitiveUsesOfLDS(CallGraph const &CG, Module &M) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeline"></td>
    <td class="lineNumber">374</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeline">    FunctionVariableMap direct_map_kernel;</td>
    <td class="lineNumber">375</td>
    <td class="codeline">    FunctionVariableMap direct_map_kernel;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeline">    FunctionVariableMap direct_map_function;</td>
    <td class="lineNumber">376</td>
    <td class="codeline">    FunctionVariableMap direct_map_function;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeline">    getUsesOfLDSByFunction(CG, M, direct_map_kernel, direct_map_function);</td>
    <td class="lineNumber">377</td>
    <td class="codeline">    getUsesOfLDSByFunction(CG, M, direct_map_kernel, direct_map_function);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeline"></td>
    <td class="lineNumber">378</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeline">    // Collect variables that are used by functions whose address has escaped</td>
    <td class="lineNumber">379</td>
    <td class="codeline">    // Collect variables that are used by functions whose address has escaped</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeline">    DenseSet<GlobalVariable *> VariablesReachableThroughFunctionPointer;</td>
    <td class="lineNumber">380</td>
    <td class="codeline">    DenseSet<GlobalVariable *> VariablesReachableThroughFunctionPointer;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeline">    for (Function &F : M.functions()) {</td>
    <td class="lineNumber">381</td>
    <td class="codeline">    for (Function &F : M.functions()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeline">      if (!isKernelLDS(&F))</td>
    <td class="lineNumber">382</td>
    <td class="codeline">      if (!isKernelLDS(&F))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeline">        if (F.hasAddressTaken(nullptr,</td>
    <td class="lineNumber">383</td>
    <td class="codeline">        if (F.hasAddressTaken(nullptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeline">                              /* IgnoreCallbackUses */ false,</td>
    <td class="lineNumber">384</td>
    <td class="codeline">                              /* IgnoreCallbackUses */ false,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeline">                              /* IgnoreAssumeLikeCalls */ false,</td>
    <td class="lineNumber">385</td>
    <td class="codeline">                              /* IgnoreAssumeLikeCalls */ false,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeline">                              /* IgnoreLLVMUsed */ true,</td>
    <td class="lineNumber">386</td>
    <td class="codeline">                              /* IgnoreLLVMUsed */ true,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeline">                              /* IgnoreArcAttachedCall */ false)) {</td>
    <td class="lineNumber">387</td>
    <td class="codeline">                              /* IgnoreArcAttachedCall */ false)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeline">          set_union(VariablesReachableThroughFunctionPointer,</td>
    <td class="lineNumber">388</td>
    <td class="codeline">          set_union(VariablesReachableThroughFunctionPointer,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeline">                    direct_map_function[&F]);</td>
    <td class="lineNumber">389</td>
    <td class="codeline">                    direct_map_function[&F]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">390</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">391</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeline"></td>
    <td class="lineNumber">392</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeline">    auto functionMakesUnknownCall = [&](const Function *F) -> bool {</td>
    <td class="lineNumber">393</td>
    <td class="codeline">    auto functionMakesUnknownCall = [&](const Function *F) -> bool {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeline">      assert(!F->isDeclaration());</td>
    <td class="lineNumber">394</td>
    <td class="codeline">      assert(!F->isDeclaration());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeline">      for (const CallGraphNode::CallRecord &R : *CG[F]) {</td>
    <td class="lineNumber">395</td>
    <td class="codeline">      for (const CallGraphNode::CallRecord &R : *CG[F]) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeline">        if (!R.second->getFunction()) {</td>
    <td class="lineNumber">396</td>
    <td class="codeline">        if (!R.second->getFunction()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeline">          return true;</td>
    <td class="lineNumber">397</td>
    <td class="codeline">          return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">398</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">399</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">400</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeline">    };</td>
    <td class="lineNumber">401</td>
    <td class="codeline">    };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeline"></td>
    <td class="lineNumber">402</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeline">    // Work out which variables are reachable through function calls</td>
    <td class="lineNumber">403</td>
    <td class="codeline">    // Work out which variables are reachable through function calls</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeline">    FunctionVariableMap transitive_map_function = direct_map_function;</td>
    <td class="lineNumber">404</td>
    <td class="codeline">    FunctionVariableMap transitive_map_function = direct_map_function;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeline"></td>
    <td class="lineNumber">405</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeline">    // If the function makes any unknown call, assume the worst case that it can</td>
    <td class="lineNumber">406</td>
    <td class="codeline">    // If the function makes any unknown call, assume the worst case that it can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeline">    // access all variables accessed by functions whose address escaped</td>
    <td class="lineNumber">407</td>
    <td class="codeline">    // access all variables accessed by functions whose address escaped</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeline">    for (Function &F : M.functions()) {</td>
    <td class="lineNumber">408</td>
    <td class="codeline">    for (Function &F : M.functions()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeline">      if (!F.isDeclaration() && functionMakesUnknownCall(&F)) {</td>
    <td class="lineNumber">409</td>
    <td class="codeline">      if (!F.isDeclaration() && functionMakesUnknownCall(&F)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeline">        if (!isKernelLDS(&F)) {</td>
    <td class="lineNumber">410</td>
    <td class="codeline">        if (!isKernelLDS(&F)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeline">          set_union(transitive_map_function[&F],</td>
    <td class="lineNumber">411</td>
    <td class="codeline">          set_union(transitive_map_function[&F],</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeline">                    VariablesReachableThroughFunctionPointer);</td>
    <td class="lineNumber">412</td>
    <td class="codeline">                    VariablesReachableThroughFunctionPointer);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">413</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">414</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">415</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeline"></td>
    <td class="lineNumber">416</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeline">    // Direct implementation of collecting all variables reachable from each</td>
    <td class="lineNumber">417</td>
    <td class="codeline">    // Direct implementation of collecting all variables reachable from each</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeline">    // function</td>
    <td class="lineNumber">418</td>
    <td class="codeline">    // function</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeline">    for (Function &Func : M.functions()) {</td>
    <td class="lineNumber">419</td>
    <td class="codeline">    for (Function &Func : M.functions()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeline">      if (Func.isDeclaration() || isKernelLDS(&Func))</td>
    <td class="lineNumber">420</td>
    <td class="codeline">      if (Func.isDeclaration() || isKernelLDS(&Func))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">421</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeline"></td>
    <td class="lineNumber">422</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeline">      DenseSet<Function *> seen; // catches cycles</td>
    <td class="lineNumber">423</td>
    <td class="codeline">      DenseSet<Function *> seen; // catches cycles</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeline">      SmallVector<Function *, 4> wip{&Func};</td>
    <td class="lineNumber">424</td>
    <td class="codeline">      SmallVector<Function *, 4> wip{&Func};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeline"></td>
    <td class="lineNumber">425</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeline">      while (!wip.empty()) {</td>
    <td class="lineNumber">426</td>
    <td class="codeline">      while (!wip.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeline">        Function *F = wip.pop_back_val();</td>
    <td class="lineNumber">427</td>
    <td class="codeline">        Function *F = wip.pop_back_val();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeline"></td>
    <td class="lineNumber">428</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeline">        // Can accelerate this by referring to transitive map for functions that</td>
    <td class="lineNumber">429</td>
    <td class="codeline">        // Can accelerate this by referring to transitive map for functions that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeline">        // have already been computed, with more care than this</td>
    <td class="lineNumber">430</td>
    <td class="codeline">        // have already been computed, with more care than this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeline">        set_union(transitive_map_function[&Func], direct_map_function[F]);</td>
    <td class="lineNumber">431</td>
    <td class="codeline">        set_union(transitive_map_function[&Func], direct_map_function[F]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeline"></td>
    <td class="lineNumber">432</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeline">        for (const CallGraphNode::CallRecord &R : *CG[F]) {</td>
    <td class="lineNumber">433</td>
    <td class="codeline">        for (const CallGraphNode::CallRecord &R : *CG[F]) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeline">          Function *ith = R.second->getFunction();</td>
    <td class="lineNumber">434</td>
    <td class="codeline">          Function *ith = R.second->getFunction();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeline">          if (ith) {</td>
    <td class="lineNumber">435</td>
    <td class="codeline">          if (ith) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeline">            if (!seen.contains(ith)) {</td>
    <td class="lineNumber">436</td>
    <td class="codeline">            if (!seen.contains(ith)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeline">              seen.insert(ith);</td>
    <td class="lineNumber">437</td>
    <td class="codeline">              seen.insert(ith);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeline">              wip.push_back(ith);</td>
    <td class="lineNumber">438</td>
    <td class="codeline">              wip.push_back(ith);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeline">            }</td>
    <td class="lineNumber">439</td>
    <td class="codeline">            }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">440</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">441</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">442</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">443</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeline"></td>
    <td class="lineNumber">444</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeline">    // direct_map_kernel lists which variables are used by the kernel</td>
    <td class="lineNumber">445</td>
    <td class="codeline">    // direct_map_kernel lists which variables are used by the kernel</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeline">    // find the variables which are used through a function call</td>
    <td class="lineNumber">446</td>
    <td class="codeline">    // find the variables which are used through a function call</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeline">    FunctionVariableMap indirect_map_kernel;</td>
    <td class="lineNumber">447</td>
    <td class="codeline">    FunctionVariableMap indirect_map_kernel;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeline"></td>
    <td class="lineNumber">448</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeline">    for (Function &Func : M.functions()) {</td>
    <td class="lineNumber">449</td>
    <td class="codeline">    for (Function &Func : M.functions()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeline">      if (Func.isDeclaration() || !isKernelLDS(&Func))</td>
    <td class="lineNumber">450</td>
    <td class="codeline">      if (Func.isDeclaration() || !isKernelLDS(&Func))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">451</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeline"></td>
    <td class="lineNumber">452</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeline">      for (const CallGraphNode::CallRecord &R : *CG[&Func]) {</td>
    <td class="lineNumber">453</td>
    <td class="codeline">      for (const CallGraphNode::CallRecord &R : *CG[&Func]) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeline">        Function *ith = R.second->getFunction();</td>
    <td class="lineNumber">454</td>
    <td class="codeline">        Function *ith = R.second->getFunction();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeline">        if (ith) {</td>
    <td class="lineNumber">455</td>
    <td class="codeline">        if (ith) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeline">          set_union(indirect_map_kernel[&Func], transitive_map_function[ith]);</td>
    <td class="lineNumber">456</td>
    <td class="codeline">          set_union(indirect_map_kernel[&Func], transitive_map_function[ith]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeline">        } else {</td>
    <td class="lineNumber">457</td>
    <td class="codeline">        } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeline">          set_union(indirect_map_kernel[&Func],</td>
    <td class="lineNumber">458</td>
    <td class="codeline">          set_union(indirect_map_kernel[&Func],</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeline">                    VariablesReachableThroughFunctionPointer);</td>
    <td class="lineNumber">459</td>
    <td class="codeline">                    VariablesReachableThroughFunctionPointer);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">460</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">461</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">462</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeline"></td>
    <td class="lineNumber">463</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeline">    return {std::move(direct_map_kernel), std::move(indirect_map_kernel)};</td>
    <td class="lineNumber">464</td>
    <td class="codeline">    return {std::move(direct_map_kernel), std::move(indirect_map_kernel)};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">465</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeline"></td>
    <td class="lineNumber">466</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeline">  struct LDSVariableReplacement {</td>
    <td class="lineNumber">467</td>
    <td class="codeline">  struct LDSVariableReplacement {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeline">    GlobalVariable *SGV = nullptr;</td>
    <td class="lineNumber">468</td>
    <td class="codeline">    GlobalVariable *SGV = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeline">    DenseMap<GlobalVariable *, Constant *> LDSVarsToConstantGEP;</td>
    <td class="lineNumber">469</td>
    <td class="codeline">    DenseMap<GlobalVariable *, Constant *> LDSVarsToConstantGEP;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">470</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeline"></td>
    <td class="lineNumber">471</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeline">  // remap from lds global to a constantexpr gep to where it has been moved to</td>
    <td class="lineNumber">472</td>
    <td class="codeline">  // remap from lds global to a constantexpr gep to where it has been moved to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeline">  // for each kernel</td>
    <td class="lineNumber">473</td>
    <td class="codeline">  // for each kernel</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeline">  // an array with an element for each kernel containing where the corresponding</td>
    <td class="lineNumber">474</td>
    <td class="codeline">  // an array with an element for each kernel containing where the corresponding</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeline">  // variable was remapped to</td>
    <td class="lineNumber">475</td>
    <td class="codeline">  // variable was remapped to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeline"></td>
    <td class="lineNumber">476</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeline">  static Constant *getAddressesOfVariablesInKernel(</td>
    <td class="lineNumber">477</td>
    <td class="codeline">  static Constant *getAddressesOfVariablesInKernel(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeline">      LLVMContext &Ctx, ArrayRef<GlobalVariable *> Variables,</td>
    <td class="lineNumber">478</td>
    <td class="codeline">      LLVMContext &Ctx, ArrayRef<GlobalVariable *> Variables,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeline">      const DenseMap<GlobalVariable *, Constant *> &LDSVarsToConstantGEP) {</td>
    <td class="lineNumber">479</td>
    <td class="codeline">      const DenseMap<GlobalVariable *, Constant *> &LDSVarsToConstantGEP) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeline">    // Create a ConstantArray containing the address of each Variable within the</td>
    <td class="lineNumber">480</td>
    <td class="codeline">    // Create a ConstantArray containing the address of each Variable within the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeline">    // kernel corresponding to LDSVarsToConstantGEP, or poison if that kernel</td>
    <td class="lineNumber">481</td>
    <td class="codeline">    // kernel corresponding to LDSVarsToConstantGEP, or poison if that kernel</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeline">    // does not allocate it</td>
    <td class="lineNumber">482</td>
    <td class="codeline">    // does not allocate it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeline">    // TODO: Drop the ptrtoint conversion</td>
    <td class="lineNumber">483</td>
    <td class="codeline">    // TODO: Drop the ptrtoint conversion</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeline"></td>
    <td class="lineNumber">484</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeline">    Type *I32 = Type::getInt32Ty(Ctx);</td>
    <td class="lineNumber">485</td>
    <td class="codeline">    Type *I32 = Type::getInt32Ty(Ctx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeline"></td>
    <td class="lineNumber">486</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeline">    ArrayType *KernelOffsetsType = ArrayType::get(I32, Variables.size());</td>
    <td class="lineNumber">487</td>
    <td class="codeline">    ArrayType *KernelOffsetsType = ArrayType::get(I32, Variables.size());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeline"></td>
    <td class="lineNumber">488</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeline">    SmallVector<Constant *> Elements;</td>
    <td class="lineNumber">489</td>
    <td class="codeline">    SmallVector<Constant *> Elements;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeline">    for (size_t i = 0; i < Variables.size(); i++) {</td>
    <td class="lineNumber">490</td>
    <td class="codeline">    for (size_t i = 0; i < Variables.size(); i++) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeline">      GlobalVariable *GV = Variables[i];</td>
    <td class="lineNumber">491</td>
    <td class="codeline">      GlobalVariable *GV = Variables[i];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeline">      auto ConstantGepIt = LDSVarsToConstantGEP.find(GV);</td>
    <td class="lineNumber">492</td>
    <td class="codeline">      auto ConstantGepIt = LDSVarsToConstantGEP.find(GV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeline">      if (ConstantGepIt != LDSVarsToConstantGEP.end()) {</td>
    <td class="lineNumber">493</td>
    <td class="codeline">      if (ConstantGepIt != LDSVarsToConstantGEP.end()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeline">        auto elt = ConstantExpr::getPtrToInt(ConstantGepIt->second, I32);</td>
    <td class="lineNumber">494</td>
    <td class="codeline">        auto elt = ConstantExpr::getPtrToInt(ConstantGepIt->second, I32);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeline">        Elements.push_back(elt);</td>
    <td class="lineNumber">495</td>
    <td class="codeline">        Elements.push_back(elt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">496</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeline">        Elements.push_back(PoisonValue::get(I32));</td>
    <td class="lineNumber">497</td>
    <td class="codeline">        Elements.push_back(PoisonValue::get(I32));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">498</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">499</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeline">    return ConstantArray::get(KernelOffsetsType, Elements);</td>
    <td class="lineNumber">500</td>
    <td class="codeline">    return ConstantArray::get(KernelOffsetsType, Elements);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">501</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeline"></td>
    <td class="lineNumber">502</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeline">  static GlobalVariable *buildLookupTable(</td>
    <td class="lineNumber">503</td>
    <td class="codeline">  static GlobalVariable *buildLookupTable(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeline">      Module &M, ArrayRef<GlobalVariable *> Variables,</td>
    <td class="lineNumber">504</td>
    <td class="codeline">      Module &M, ArrayRef<GlobalVariable *> Variables,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeline">      ArrayRef<Function *> kernels,</td>
    <td class="lineNumber">505</td>
    <td class="codeline">      ArrayRef<Function *> kernels,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeline">      DenseMap<Function *, LDSVariableReplacement> &KernelToReplacement) {</td>
    <td class="lineNumber">506</td>
    <td class="codeline">      DenseMap<Function *, LDSVariableReplacement> &KernelToReplacement) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeline">    if (Variables.empty()) {</td>
    <td class="lineNumber">507</td>
    <td class="codeline">    if (Variables.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeline">      return nullptr;</td>
    <td class="lineNumber">508</td>
    <td class="codeline">      return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">509</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeline">    LLVMContext &Ctx = M.getContext();</td>
    <td class="lineNumber">510</td>
    <td class="codeline">    LLVMContext &Ctx = M.getContext();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeline"></td>
    <td class="lineNumber">511</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeline">    const size_t NumberVariables = Variables.size();</td>
    <td class="lineNumber">512</td>
    <td class="codeline">    const size_t NumberVariables = Variables.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeline">    const size_t NumberKernels = kernels.size();</td>
    <td class="lineNumber">513</td>
    <td class="codeline">    const size_t NumberKernels = kernels.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeline"></td>
    <td class="lineNumber">514</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeline">    ArrayType *KernelOffsetsType =</td>
    <td class="lineNumber">515</td>
    <td class="codeline">    ArrayType *KernelOffsetsType =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeline">        ArrayType::get(Type::getInt32Ty(Ctx), NumberVariables);</td>
    <td class="lineNumber">516</td>
    <td class="codeline">        ArrayType::get(Type::getInt32Ty(Ctx), NumberVariables);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeline"></td>
    <td class="lineNumber">517</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeline">    ArrayType *AllKernelsOffsetsType =</td>
    <td class="lineNumber">518</td>
    <td class="codeline">    ArrayType *AllKernelsOffsetsType =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeline">        ArrayType::get(KernelOffsetsType, NumberKernels);</td>
    <td class="lineNumber">519</td>
    <td class="codeline">        ArrayType::get(KernelOffsetsType, NumberKernels);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeline"></td>
    <td class="lineNumber">520</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeline">    Constant *Missing = PoisonValue::get(KernelOffsetsType);</td>
    <td class="lineNumber">521</td>
    <td class="codeline">    Constant *Missing = PoisonValue::get(KernelOffsetsType);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeline">    std::vector<Constant *> overallConstantExprElts(NumberKernels);</td>
    <td class="lineNumber">522</td>
    <td class="codeline">    std::vector<Constant *> overallConstantExprElts(NumberKernels);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeline">    for (size_t i = 0; i < NumberKernels; i++) {</td>
    <td class="lineNumber">523</td>
    <td class="codeline">    for (size_t i = 0; i < NumberKernels; i++) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeline">      auto Replacement = KernelToReplacement.find(kernels[i]);</td>
    <td class="lineNumber">524</td>
    <td class="codeline">      auto Replacement = KernelToReplacement.find(kernels[i]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeline">      overallConstantExprElts[i] =</td>
    <td class="lineNumber">525</td>
    <td class="codeline">      overallConstantExprElts[i] =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeline">          (Replacement == KernelToReplacement.end())</td>
    <td class="lineNumber">526</td>
    <td class="codeline">          (Replacement == KernelToReplacement.end())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeline">              ? Missing</td>
    <td class="lineNumber">527</td>
    <td class="codeline">              ? Missing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeline">              : getAddressesOfVariablesInKernel(</td>
    <td class="lineNumber">528</td>
    <td class="codeline">              : getAddressesOfVariablesInKernel(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeline">                    Ctx, Variables, Replacement->second.LDSVarsToConstantGEP);</td>
    <td class="lineNumber">529</td>
    <td class="codeline">                    Ctx, Variables, Replacement->second.LDSVarsToConstantGEP);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">530</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeline"></td>
    <td class="lineNumber">531</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeline">    Constant *init =</td>
    <td class="lineNumber">532</td>
    <td class="codeline">    Constant *init =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeline">        ConstantArray::get(AllKernelsOffsetsType, overallConstantExprElts);</td>
    <td class="lineNumber">533</td>
    <td class="codeline">        ConstantArray::get(AllKernelsOffsetsType, overallConstantExprElts);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeline"></td>
    <td class="lineNumber">534</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeline">    return new GlobalVariable(</td>
    <td class="lineNumber">535</td>
    <td class="codeline">    return new GlobalVariable(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeline">        M, AllKernelsOffsetsType, true, GlobalValue::InternalLinkage, init,</td>
    <td class="lineNumber">536</td>
    <td class="codeline">        M, AllKernelsOffsetsType, true, GlobalValue::InternalLinkage, init,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeline">        "llvm.amdgcn.lds.offset.table", nullptr, GlobalValue::NotThreadLocal,</td>
    <td class="lineNumber">537</td>
    <td class="codeline">        "llvm.amdgcn.lds.offset.table", nullptr, GlobalValue::NotThreadLocal,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeline">        AMDGPUAS::CONSTANT_ADDRESS);</td>
    <td class="lineNumber">538</td>
    <td class="codeline">        AMDGPUAS::CONSTANT_ADDRESS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">539</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeline"></td>
    <td class="lineNumber">540</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeline">  void replaceUseWithTableLookup(Module &M, IRBuilder<> &Builder,</td>
    <td class="lineNumber">541</td>
    <td class="codeline">  void replaceUseWithTableLookup(Module &M, IRBuilder<> &Builder,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeline">                                 GlobalVariable *LookupTable,</td>
    <td class="lineNumber">542</td>
    <td class="codeline">                                 GlobalVariable *LookupTable,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeline">                                 GlobalVariable *GV, Use &U,</td>
    <td class="lineNumber">543</td>
    <td class="codeline">                                 GlobalVariable *GV, Use &U,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeline">                                 Value *OptionalIndex) {</td>
    <td class="lineNumber">544</td>
    <td class="codeline">                                 Value *OptionalIndex) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeline">    // Table is a constant array of the same length as OrderedKernels</td>
    <td class="lineNumber">545</td>
    <td class="codeline">    // Table is a constant array of the same length as OrderedKernels</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeline">    LLVMContext &Ctx = M.getContext();</td>
    <td class="lineNumber">546</td>
    <td class="codeline">    LLVMContext &Ctx = M.getContext();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeline">    Type *I32 = Type::getInt32Ty(Ctx);</td>
    <td class="lineNumber">547</td>
    <td class="codeline">    Type *I32 = Type::getInt32Ty(Ctx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeline">    auto *I = cast<Instruction>(U.getUser());</td>
    <td class="lineNumber">548</td>
    <td class="codeline">    auto *I = cast<Instruction>(U.getUser());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeline"></td>
    <td class="lineNumber">549</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeline">    Value *tableKernelIndex = getTableLookupKernelIndex(M, I->getFunction());</td>
    <td class="lineNumber">550</td>
    <td class="codeline">    Value *tableKernelIndex = getTableLookupKernelIndex(M, I->getFunction());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeline"></td>
    <td class="lineNumber">551</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeline">    if (auto *Phi = dyn_cast<PHINode>(I)) {</td>
    <td class="lineNumber">552</td>
    <td class="codeline">    if (auto *Phi = dyn_cast<PHINode>(I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeline">      BasicBlock *BB = Phi->getIncomingBlock(U);</td>
    <td class="lineNumber">553</td>
    <td class="codeline">      BasicBlock *BB = Phi->getIncomingBlock(U);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeline">      Builder.SetInsertPoint(&(*(BB->getFirstInsertionPt())));</td>
    <td class="lineNumber">554</td>
    <td class="codeline">      Builder.SetInsertPoint(&(*(BB->getFirstInsertionPt())));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">555</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeline">      Builder.SetInsertPoint(I);</td>
    <td class="lineNumber">556</td>
    <td class="codeline">      Builder.SetInsertPoint(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">557</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeline"></td>
    <td class="lineNumber">558</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeline">    SmallVector<Value *, 3> GEPIdx = {</td>
    <td class="lineNumber">559</td>
    <td class="codeline">    SmallVector<Value *, 3> GEPIdx = {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeline">        ConstantInt::get(I32, 0),</td>
    <td class="lineNumber">560</td>
    <td class="codeline">        ConstantInt::get(I32, 0),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeline">        tableKernelIndex,</td>
    <td class="lineNumber">561</td>
    <td class="codeline">        tableKernelIndex,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeline">    };</td>
    <td class="lineNumber">562</td>
    <td class="codeline">    };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeline">    if (OptionalIndex)</td>
    <td class="lineNumber">563</td>
    <td class="codeline">    if (OptionalIndex)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeline">      GEPIdx.push_back(OptionalIndex);</td>
    <td class="lineNumber">564</td>
    <td class="codeline">      GEPIdx.push_back(OptionalIndex);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeline"></td>
    <td class="lineNumber">565</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeline">    Value *Address = Builder.CreateInBoundsGEP(</td>
    <td class="lineNumber">566</td>
    <td class="codeline">    Value *Address = Builder.CreateInBoundsGEP(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeline">        LookupTable->getValueType(), LookupTable, GEPIdx, GV->getName());</td>
    <td class="lineNumber">567</td>
    <td class="codeline">        LookupTable->getValueType(), LookupTable, GEPIdx, GV->getName());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeline"></td>
    <td class="lineNumber">568</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeline">    Value *loaded = Builder.CreateLoad(I32, Address);</td>
    <td class="lineNumber">569</td>
    <td class="codeline">    Value *loaded = Builder.CreateLoad(I32, Address);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeline"></td>
    <td class="lineNumber">570</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeline">    Value *replacement =</td>
    <td class="lineNumber">571</td>
    <td class="codeline">    Value *replacement =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeline">        Builder.CreateIntToPtr(loaded, GV->getType(), GV->getName());</td>
    <td class="lineNumber">572</td>
    <td class="codeline">        Builder.CreateIntToPtr(loaded, GV->getType(), GV->getName());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeline"></td>
    <td class="lineNumber">573</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeline">    U.set(replacement);</td>
    <td class="lineNumber">574</td>
    <td class="codeline">    U.set(replacement);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">575</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeline"></td>
    <td class="lineNumber">576</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeline">  void replaceUsesInInstructionsWithTableLookup(</td>
    <td class="lineNumber">577</td>
    <td class="codeline">  void replaceUsesInInstructionsWithTableLookup(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeline">      Module &M, ArrayRef<GlobalVariable *> ModuleScopeVariables,</td>
    <td class="lineNumber">578</td>
    <td class="codeline">      Module &M, ArrayRef<GlobalVariable *> ModuleScopeVariables,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeline">      GlobalVariable *LookupTable) {</td>
    <td class="lineNumber">579</td>
    <td class="codeline">      GlobalVariable *LookupTable) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeline"></td>
    <td class="lineNumber">580</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeline">    LLVMContext &Ctx = M.getContext();</td>
    <td class="lineNumber">581</td>
    <td class="codeline">    LLVMContext &Ctx = M.getContext();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeline">    IRBuilder<> Builder(Ctx);</td>
    <td class="lineNumber">582</td>
    <td class="codeline">    IRBuilder<> Builder(Ctx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeline">    Type *I32 = Type::getInt32Ty(Ctx);</td>
    <td class="lineNumber">583</td>
    <td class="codeline">    Type *I32 = Type::getInt32Ty(Ctx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeline"></td>
    <td class="lineNumber">584</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeline">    for (size_t Index = 0; Index < ModuleScopeVariables.size(); Index++) {</td>
    <td class="lineNumber">585</td>
    <td class="codeline">    for (size_t Index = 0; Index < ModuleScopeVariables.size(); Index++) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeline">      auto *GV = ModuleScopeVariables[Index];</td>
    <td class="lineNumber">586</td>
    <td class="codeline">      auto *GV = ModuleScopeVariables[Index];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeline"></td>
    <td class="lineNumber">587</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeline">      for (Use &U : make_early_inc_range(GV->uses())) {</td>
    <td class="lineNumber">588</td>
    <td class="codeline">      for (Use &U : make_early_inc_range(GV->uses())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeline">        auto *I = dyn_cast<Instruction>(U.getUser());</td>
    <td class="lineNumber">589</td>
    <td class="codeline">        auto *I = dyn_cast<Instruction>(U.getUser());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeline">        if (!I)</td>
    <td class="lineNumber">590</td>
    <td class="codeline">        if (!I)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">591</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeline"></td>
    <td class="lineNumber">592</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeline">        replaceUseWithTableLookup(M, Builder, LookupTable, GV, U,</td>
    <td class="lineNumber">593</td>
    <td class="codeline">        replaceUseWithTableLookup(M, Builder, LookupTable, GV, U,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeline">                                  ConstantInt::get(I32, Index));</td>
    <td class="lineNumber">594</td>
    <td class="codeline">                                  ConstantInt::get(I32, Index));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">595</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">596</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">597</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeline"></td>
    <td class="lineNumber">598</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeline">  static DenseSet<Function *> kernelsThatIndirectlyAccessAnyOfPassedVariables(</td>
    <td class="lineNumber">599</td>
    <td class="codeline">  static DenseSet<Function *> kernelsThatIndirectlyAccessAnyOfPassedVariables(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeline">      Module &M, LDSUsesInfoTy &LDSUsesInfo,</td>
    <td class="lineNumber">600</td>
    <td class="codeline">      Module &M, LDSUsesInfoTy &LDSUsesInfo,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeline">      DenseSet<GlobalVariable *> const &VariableSet) {</td>
    <td class="lineNumber">601</td>
    <td class="codeline">      DenseSet<GlobalVariable *> const &VariableSet) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeline"></td>
    <td class="lineNumber">602</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeline">    DenseSet<Function *> KernelSet;</td>
    <td class="lineNumber">603</td>
    <td class="codeline">    DenseSet<Function *> KernelSet;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeline"></td>
    <td class="lineNumber">604</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeline">    if (VariableSet.empty())</td>
    <td class="lineNumber">605</td>
    <td class="codeline">    if (VariableSet.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeline">      return KernelSet;</td>
    <td class="lineNumber">606</td>
    <td class="codeline">      return KernelSet;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeline"></td>
    <td class="lineNumber">607</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeline">    for (Function &Func : M.functions()) {</td>
    <td class="lineNumber">608</td>
    <td class="codeline">    for (Function &Func : M.functions()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeline">      if (Func.isDeclaration() || !isKernelLDS(&Func))</td>
    <td class="lineNumber">609</td>
    <td class="codeline">      if (Func.isDeclaration() || !isKernelLDS(&Func))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">610</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeline">      for (GlobalVariable *GV : LDSUsesInfo.indirect_access[&Func]) {</td>
    <td class="lineNumber">611</td>
    <td class="codeline">      for (GlobalVariable *GV : LDSUsesInfo.indirect_access[&Func]) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeline">        if (VariableSet.contains(GV)) {</td>
    <td class="lineNumber">612</td>
    <td class="codeline">        if (VariableSet.contains(GV)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeline">          KernelSet.insert(&Func);</td>
    <td class="lineNumber">613</td>
    <td class="codeline">          KernelSet.insert(&Func);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeline">          break;</td>
    <td class="lineNumber">614</td>
    <td class="codeline">          break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">615</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">616</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">617</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeline"></td>
    <td class="lineNumber">618</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeline">    return KernelSet;</td>
    <td class="lineNumber">619</td>
    <td class="codeline">    return KernelSet;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">620</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeline"></td>
    <td class="lineNumber">621</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeline">  static GlobalVariable *</td>
    <td class="lineNumber">622</td>
    <td class="codeline">  static GlobalVariable *</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeline">  chooseBestVariableForModuleStrategy(const DataLayout &DL,</td>
    <td class="lineNumber">623</td>
    <td class="codeline">  chooseBestVariableForModuleStrategy(const DataLayout &DL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeline">                                      VariableFunctionMap &LDSVars) {</td>
    <td class="lineNumber">624</td>
    <td class="codeline">                                      VariableFunctionMap &LDSVars) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeline">    // Find the global variable with the most indirect uses from kernels</td>
    <td class="lineNumber">625</td>
    <td class="codeline">    // Find the global variable with the most indirect uses from kernels</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeline"></td>
    <td class="lineNumber">626</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeline">    struct CandidateTy {</td>
    <td class="lineNumber">627</td>
    <td class="codeline">    struct CandidateTy {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeline">      GlobalVariable *GV = nullptr;</td>
    <td class="lineNumber">628</td>
    <td class="codeline">      GlobalVariable *GV = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeline">      size_t UserCount = 0;</td>
    <td class="lineNumber">629</td>
    <td class="codeline">      size_t UserCount = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeline">      size_t Size = 0;</td>
    <td class="lineNumber">630</td>
    <td class="codeline">      size_t Size = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeline"></td>
    <td class="lineNumber">631</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeline">      CandidateTy() = default;</td>
    <td class="lineNumber">632</td>
    <td class="codeline">      CandidateTy() = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeline"></td>
    <td class="lineNumber">633</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeline">      CandidateTy(GlobalVariable *GV, uint64_t UserCount, uint64_t AllocSize)</td>
    <td class="lineNumber">634</td>
    <td class="codeline">      CandidateTy(GlobalVariable *GV, uint64_t UserCount, uint64_t AllocSize)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeline">          : GV(GV), UserCount(UserCount), Size(AllocSize) {}</td>
    <td class="lineNumber">635</td>
    <td class="codeline">          : GV(GV), UserCount(UserCount), Size(AllocSize) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeline"></td>
    <td class="lineNumber">636</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeline">      bool operator<(const CandidateTy &Other) const {</td>
    <td class="lineNumber">637</td>
    <td class="codeline">      bool operator<(const CandidateTy &Other) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeline">        // Fewer users makes module scope variable less attractive</td>
    <td class="lineNumber">638</td>
    <td class="codeline">        // Fewer users makes module scope variable less attractive</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeline">        if (UserCount < Other.UserCount) {</td>
    <td class="lineNumber">639</td>
    <td class="codeline">        if (UserCount < Other.UserCount) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeline">          return true;</td>
    <td class="lineNumber">640</td>
    <td class="codeline">          return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">641</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeline">        if (UserCount > Other.UserCount) {</td>
    <td class="lineNumber">642</td>
    <td class="codeline">        if (UserCount > Other.UserCount) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeline">          return false;</td>
    <td class="lineNumber">643</td>
    <td class="codeline">          return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">644</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeline"></td>
    <td class="lineNumber">645</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeline">        // Bigger makes module scope variable less attractive</td>
    <td class="lineNumber">646</td>
    <td class="codeline">        // Bigger makes module scope variable less attractive</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeline">        if (Size < Other.Size) {</td>
    <td class="lineNumber">647</td>
    <td class="codeline">        if (Size < Other.Size) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeline">          return false;</td>
    <td class="lineNumber">648</td>
    <td class="codeline">          return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">649</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeline"></td>
    <td class="lineNumber">650</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeline">        if (Size > Other.Size) {</td>
    <td class="lineNumber">651</td>
    <td class="codeline">        if (Size > Other.Size) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeline">          return true;</td>
    <td class="lineNumber">652</td>
    <td class="codeline">          return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">653</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeline"></td>
    <td class="lineNumber">654</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeline">        // Arbitrary but consistent</td>
    <td class="lineNumber">655</td>
    <td class="codeline">        // Arbitrary but consistent</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeline">        return GV->getName() < Other.GV->getName();</td>
    <td class="lineNumber">656</td>
    <td class="codeline">        return GV->getName() < Other.GV->getName();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">657</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeline">    };</td>
    <td class="lineNumber">658</td>
    <td class="codeline">    };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeline"></td>
    <td class="lineNumber">659</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeline">    CandidateTy MostUsed;</td>
    <td class="lineNumber">660</td>
    <td class="codeline">    CandidateTy MostUsed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeline"></td>
    <td class="lineNumber">661</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeline">    for (auto &K : LDSVars) {</td>
    <td class="lineNumber">662</td>
    <td class="codeline">    for (auto &K : LDSVars) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeline">      GlobalVariable *GV = K.first;</td>
    <td class="lineNumber">663</td>
    <td class="codeline">      GlobalVariable *GV = K.first;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeline">      if (K.second.size() <= 1) {</td>
    <td class="lineNumber">664</td>
    <td class="codeline">      if (K.second.size() <= 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeline">        // A variable reachable by only one kernel is best lowered with kernel</td>
    <td class="lineNumber">665</td>
    <td class="codeline">        // A variable reachable by only one kernel is best lowered with kernel</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeline">        // strategy</td>
    <td class="lineNumber">666</td>
    <td class="codeline">        // strategy</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">667</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">668</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeline">      CandidateTy Candidate(</td>
    <td class="lineNumber">669</td>
    <td class="codeline">      CandidateTy Candidate(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeline">          GV, K.second.size(),</td>
    <td class="lineNumber">670</td>
    <td class="codeline">          GV, K.second.size(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeline">          DL.getTypeAllocSize(GV->getValueType()).getFixedValue());</td>
    <td class="lineNumber">671</td>
    <td class="codeline">          DL.getTypeAllocSize(GV->getValueType()).getFixedValue());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeline">      if (MostUsed < Candidate)</td>
    <td class="lineNumber">672</td>
    <td class="codeline">      if (MostUsed < Candidate)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeline">        MostUsed = Candidate;</td>
    <td class="lineNumber">673</td>
    <td class="codeline">        MostUsed = Candidate;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">674</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeline"></td>
    <td class="lineNumber">675</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeline">    return MostUsed.GV;</td>
    <td class="lineNumber">676</td>
    <td class="codeline">    return MostUsed.GV;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">677</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeline"></td>
    <td class="lineNumber">678</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeline">  static void recordLDSAbsoluteAddress(Module *M, GlobalVariable *GV,</td>
    <td class="lineNumber">679</td>
    <td class="codeline">  static void recordLDSAbsoluteAddress(Module *M, GlobalVariable *GV,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeline">                                       uint32_t Address) {</td>
    <td class="lineNumber">680</td>
    <td class="codeline">                                       uint32_t Address) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeline">    // Write the specified address into metadata where it can be retrieved by</td>
    <td class="lineNumber">681</td>
    <td class="codeline">    // Write the specified address into metadata where it can be retrieved by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeline">    // the assembler. Format is a half open range, [Address Address+1)</td>
    <td class="lineNumber">682</td>
    <td class="codeline">    // the assembler. Format is a half open range, [Address Address+1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeline">    LLVMContext &Ctx = M->getContext();</td>
    <td class="lineNumber">683</td>
    <td class="codeline">    LLVMContext &Ctx = M->getContext();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeline">    auto *IntTy =</td>
    <td class="lineNumber">684</td>
    <td class="codeline">    auto *IntTy =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeline">        M->getDataLayout().getIntPtrType(Ctx, AMDGPUAS::LOCAL_ADDRESS);</td>
    <td class="lineNumber">685</td>
    <td class="codeline">        M->getDataLayout().getIntPtrType(Ctx, AMDGPUAS::LOCAL_ADDRESS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeline">    auto *MinC = ConstantAsMetadata::get(ConstantInt::get(IntTy, Address));</td>
    <td class="lineNumber">686</td>
    <td class="codeline">    auto *MinC = ConstantAsMetadata::get(ConstantInt::get(IntTy, Address));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeline">    auto *MaxC = ConstantAsMetadata::get(ConstantInt::get(IntTy, Address + 1));</td>
    <td class="lineNumber">687</td>
    <td class="codeline">    auto *MaxC = ConstantAsMetadata::get(ConstantInt::get(IntTy, Address + 1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeline">    GV->setMetadata(LLVMContext::MD_absolute_symbol,</td>
    <td class="lineNumber">688</td>
    <td class="codeline">    GV->setMetadata(LLVMContext::MD_absolute_symbol,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeline">                    MDNode::get(Ctx, {MinC, MaxC}));</td>
    <td class="lineNumber">689</td>
    <td class="codeline">                    MDNode::get(Ctx, {MinC, MaxC}));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">690</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeline"></td>
    <td class="lineNumber">691</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeline">  DenseMap<Function *, Value *> tableKernelIndexCache;</td>
    <td class="lineNumber">692</td>
    <td class="codeline">  DenseMap<Function *, Value *> tableKernelIndexCache;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeline">  Value *getTableLookupKernelIndex(Module &M, Function *F) {</td>
    <td class="lineNumber">693</td>
    <td class="codeline">  Value *getTableLookupKernelIndex(Module &M, Function *F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeline">    // Accesses from a function use the amdgcn_lds_kernel_id intrinsic which</td>
    <td class="lineNumber">694</td>
    <td class="codeline">    // Accesses from a function use the amdgcn_lds_kernel_id intrinsic which</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeline">    // lowers to a read from a live in register. Emit it once in the entry</td>
    <td class="lineNumber">695</td>
    <td class="codeline">    // lowers to a read from a live in register. Emit it once in the entry</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeline">    // block to spare deduplicating it later.</td>
    <td class="lineNumber">696</td>
    <td class="codeline">    // block to spare deduplicating it later.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeline">    auto [It, Inserted] = tableKernelIndexCache.try_emplace(F);</td>
    <td class="lineNumber">697</td>
    <td class="codeline">    auto [It, Inserted] = tableKernelIndexCache.try_emplace(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeline">    if (Inserted) {</td>
    <td class="lineNumber">698</td>
    <td class="codeline">    if (Inserted) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeline">      Function *Decl =</td>
    <td class="lineNumber">699</td>
    <td class="codeline">      Function *Decl =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeline">          Intrinsic::getDeclaration(&M, Intrinsic::amdgcn_lds_kernel_id, {});</td>
    <td class="lineNumber">700</td>
    <td class="codeline">          Intrinsic::getDeclaration(&M, Intrinsic::amdgcn_lds_kernel_id, {});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeline"></td>
    <td class="lineNumber">701</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeline">      auto InsertAt = F->getEntryBlock().getFirstNonPHIOrDbgOrAlloca();</td>
    <td class="lineNumber">702</td>
    <td class="codeline">      auto InsertAt = F->getEntryBlock().getFirstNonPHIOrDbgOrAlloca();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeline">      IRBuilder<> Builder(&*InsertAt);</td>
    <td class="lineNumber">703</td>
    <td class="codeline">      IRBuilder<> Builder(&*InsertAt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeline"></td>
    <td class="lineNumber">704</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeline">      It->second = Builder.CreateCall(Decl, {});</td>
    <td class="lineNumber">705</td>
    <td class="codeline">      It->second = Builder.CreateCall(Decl, {});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">706</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeline"></td>
    <td class="lineNumber">707</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeline">    return It->second;</td>
    <td class="lineNumber">708</td>
    <td class="codeline">    return It->second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">709</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeline"></td>
    <td class="lineNumber">710</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeline">  static std::vector<Function *> assignLDSKernelIDToEachKernel(</td>
    <td class="lineNumber">711</td>
    <td class="codeline">  static std::vector<Function *> assignLDSKernelIDToEachKernel(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeline">      Module *M, DenseSet<Function *> const &KernelsThatAllocateTableLDS,</td>
    <td class="lineNumber">712</td>
    <td class="codeline">      Module *M, DenseSet<Function *> const &KernelsThatAllocateTableLDS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeline">      DenseSet<Function *> const &KernelsThatIndirectlyAllocateDynamicLDS) {</td>
    <td class="lineNumber">713</td>
    <td class="codeline">      DenseSet<Function *> const &KernelsThatIndirectlyAllocateDynamicLDS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeline">    // Associate kernels in the set with an arbirary but reproducible order and</td>
    <td class="lineNumber">714</td>
    <td class="codeline">    // Associate kernels in the set with an arbirary but reproducible order and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeline">    // annotate them with that order in metadata. This metadata is recognised by</td>
    <td class="lineNumber">715</td>
    <td class="codeline">    // annotate them with that order in metadata. This metadata is recognised by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeline">    // the backend and lowered to a SGPR which can be read from using</td>
    <td class="lineNumber">716</td>
    <td class="codeline">    // the backend and lowered to a SGPR which can be read from using</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeline">    // amdgcn_lds_kernel_id.</td>
    <td class="lineNumber">717</td>
    <td class="codeline">    // amdgcn_lds_kernel_id.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeline"></td>
    <td class="lineNumber">718</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeline">    std::vector<Function *> OrderedKernels;</td>
    <td class="lineNumber">719</td>
    <td class="codeline">    std::vector<Function *> OrderedKernels;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeline">    if (!KernelsThatAllocateTableLDS.empty() ||</td>
    <td class="lineNumber">720</td>
    <td class="codeline">    if (!KernelsThatAllocateTableLDS.empty() ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeline">        !KernelsThatIndirectlyAllocateDynamicLDS.empty()) {</td>
    <td class="lineNumber">721</td>
    <td class="codeline">        !KernelsThatIndirectlyAllocateDynamicLDS.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeline"></td>
    <td class="lineNumber">722</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeline">      for (Function &Func : M->functions()) {</td>
    <td class="lineNumber">723</td>
    <td class="codeline">      for (Function &Func : M->functions()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeline">        if (Func.isDeclaration())</td>
    <td class="lineNumber">724</td>
    <td class="codeline">        if (Func.isDeclaration())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">725</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeline">        if (!isKernelLDS(&Func))</td>
    <td class="lineNumber">726</td>
    <td class="codeline">        if (!isKernelLDS(&Func))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">727</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeline"></td>
    <td class="lineNumber">728</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeline">        if (KernelsThatAllocateTableLDS.contains(&Func) ||</td>
    <td class="lineNumber">729</td>
    <td class="codeline">        if (KernelsThatAllocateTableLDS.contains(&Func) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeline">            KernelsThatIndirectlyAllocateDynamicLDS.contains(&Func)) {</td>
    <td class="lineNumber">730</td>
    <td class="codeline">            KernelsThatIndirectlyAllocateDynamicLDS.contains(&Func)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeline">          assert(Func.hasName()); // else fatal error earlier</td>
    <td class="lineNumber">731</td>
    <td class="codeline">          assert(Func.hasName()); // else fatal error earlier</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeline">          OrderedKernels.push_back(&Func);</td>
    <td class="lineNumber">732</td>
    <td class="codeline">          OrderedKernels.push_back(&Func);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">733</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">734</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeline"></td>
    <td class="lineNumber">735</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeline">      // Put them in an arbitrary but reproducible order</td>
    <td class="lineNumber">736</td>
    <td class="codeline">      // Put them in an arbitrary but reproducible order</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeline">      OrderedKernels = sortByName(std::move(OrderedKernels));</td>
    <td class="lineNumber">737</td>
    <td class="codeline">      OrderedKernels = sortByName(std::move(OrderedKernels));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeline"></td>
    <td class="lineNumber">738</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeline">      // Annotate the kernels with their order in this vector</td>
    <td class="lineNumber">739</td>
    <td class="codeline">      // Annotate the kernels with their order in this vector</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeline">      LLVMContext &Ctx = M->getContext();</td>
    <td class="lineNumber">740</td>
    <td class="codeline">      LLVMContext &Ctx = M->getContext();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeline">      IRBuilder<> Builder(Ctx);</td>
    <td class="lineNumber">741</td>
    <td class="codeline">      IRBuilder<> Builder(Ctx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeline"></td>
    <td class="lineNumber">742</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeline">      if (OrderedKernels.size() > UINT32_MAX) {</td>
    <td class="lineNumber">743</td>
    <td class="codeline">      if (OrderedKernels.size() > UINT32_MAX) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeline">        // 32 bit keeps it in one SGPR. > 2**32 kernels won't fit on the GPU</td>
    <td class="lineNumber">744</td>
    <td class="codeline">        // 32 bit keeps it in one SGPR. > 2**32 kernels won't fit on the GPU</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeline">        report_fatal_error("Unimplemented LDS lowering for > 2**32 kernels");</td>
    <td class="lineNumber">745</td>
    <td class="codeline">        report_fatal_error("Unimplemented LDS lowering for > 2**32 kernels");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">746</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeline"></td>
    <td class="lineNumber">747</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeline">      for (size_t i = 0; i < OrderedKernels.size(); i++) {</td>
    <td class="lineNumber">748</td>
    <td class="codeline">      for (size_t i = 0; i < OrderedKernels.size(); i++) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeline">        Metadata *AttrMDArgs[1] = {</td>
    <td class="lineNumber">749</td>
    <td class="codeline">        Metadata *AttrMDArgs[1] = {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeline">            ConstantAsMetadata::get(Builder.getInt32(i)),</td>
    <td class="lineNumber">750</td>
    <td class="codeline">            ConstantAsMetadata::get(Builder.getInt32(i)),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeline">        };</td>
    <td class="lineNumber">751</td>
    <td class="codeline">        };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeline">        OrderedKernels[i]->setMetadata("llvm.amdgcn.lds.kernel.id",</td>
    <td class="lineNumber">752</td>
    <td class="codeline">        OrderedKernels[i]->setMetadata("llvm.amdgcn.lds.kernel.id",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeline">                                       MDNode::get(Ctx, AttrMDArgs));</td>
    <td class="lineNumber">753</td>
    <td class="codeline">                                       MDNode::get(Ctx, AttrMDArgs));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">754</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">755</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeline">    return OrderedKernels;</td>
    <td class="lineNumber">756</td>
    <td class="codeline">    return OrderedKernels;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">757</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeline"></td>
    <td class="lineNumber">758</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeline">  static void partitionVariablesIntoIndirectStrategies(</td>
    <td class="lineNumber">759</td>
    <td class="codeline">  static void partitionVariablesIntoIndirectStrategies(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeline">      Module &M, LDSUsesInfoTy const &LDSUsesInfo,</td>
    <td class="lineNumber">760</td>
    <td class="codeline">      Module &M, LDSUsesInfoTy const &LDSUsesInfo,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeline">      VariableFunctionMap &LDSToKernelsThatNeedToAccessItIndirectly,</td>
    <td class="lineNumber">761</td>
    <td class="codeline">      VariableFunctionMap &LDSToKernelsThatNeedToAccessItIndirectly,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeline">      DenseSet<GlobalVariable *> &ModuleScopeVariables,</td>
    <td class="lineNumber">762</td>
    <td class="codeline">      DenseSet<GlobalVariable *> &ModuleScopeVariables,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeline">      DenseSet<GlobalVariable *> &TableLookupVariables,</td>
    <td class="lineNumber">763</td>
    <td class="codeline">      DenseSet<GlobalVariable *> &TableLookupVariables,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeline">      DenseSet<GlobalVariable *> &KernelAccessVariables,</td>
    <td class="lineNumber">764</td>
    <td class="codeline">      DenseSet<GlobalVariable *> &KernelAccessVariables,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeline">      DenseSet<GlobalVariable *> &DynamicVariables) {</td>
    <td class="lineNumber">765</td>
    <td class="codeline">      DenseSet<GlobalVariable *> &DynamicVariables) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeline"></td>
    <td class="lineNumber">766</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeline">    GlobalVariable *HybridModuleRoot =</td>
    <td class="lineNumber">767</td>
    <td class="codeline">    GlobalVariable *HybridModuleRoot =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeline">        LoweringKindLoc != LoweringKind::hybrid</td>
    <td class="lineNumber">768</td>
    <td class="codeline">        LoweringKindLoc != LoweringKind::hybrid</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeline">            ? nullptr</td>
    <td class="lineNumber">769</td>
    <td class="codeline">            ? nullptr</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeline">            : chooseBestVariableForModuleStrategy(</td>
    <td class="lineNumber">770</td>
    <td class="codeline">            : chooseBestVariableForModuleStrategy(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeline">                  M.getDataLayout(), LDSToKernelsThatNeedToAccessItIndirectly);</td>
    <td class="lineNumber">771</td>
    <td class="codeline">                  M.getDataLayout(), LDSToKernelsThatNeedToAccessItIndirectly);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeline"></td>
    <td class="lineNumber">772</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeline">    DenseSet<Function *> const EmptySet;</td>
    <td class="lineNumber">773</td>
    <td class="codeline">    DenseSet<Function *> const EmptySet;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeline">    DenseSet<Function *> const &HybridModuleRootKernels =</td>
    <td class="lineNumber">774</td>
    <td class="codeline">    DenseSet<Function *> const &HybridModuleRootKernels =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeline">        HybridModuleRoot</td>
    <td class="lineNumber">775</td>
    <td class="codeline">        HybridModuleRoot</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeline">            ? LDSToKernelsThatNeedToAccessItIndirectly[HybridModuleRoot]</td>
    <td class="lineNumber">776</td>
    <td class="codeline">            ? LDSToKernelsThatNeedToAccessItIndirectly[HybridModuleRoot]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeline">            : EmptySet;</td>
    <td class="lineNumber">777</td>
    <td class="codeline">            : EmptySet;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeline"></td>
    <td class="lineNumber">778</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeline">    for (auto &K : LDSToKernelsThatNeedToAccessItIndirectly) {</td>
    <td class="lineNumber">779</td>
    <td class="codeline">    for (auto &K : LDSToKernelsThatNeedToAccessItIndirectly) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeline">      // Each iteration of this loop assigns exactly one global variable to</td>
    <td class="lineNumber">780</td>
    <td class="codeline">      // Each iteration of this loop assigns exactly one global variable to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeline">      // exactly one of the implementation strategies.</td>
    <td class="lineNumber">781</td>
    <td class="codeline">      // exactly one of the implementation strategies.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeline"></td>
    <td class="lineNumber">782</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeline">      GlobalVariable *GV = K.first;</td>
    <td class="lineNumber">783</td>
    <td class="codeline">      GlobalVariable *GV = K.first;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeline">      assert(AMDGPU::isLDSVariableToLower(*GV));</td>
    <td class="lineNumber">784</td>
    <td class="codeline">      assert(AMDGPU::isLDSVariableToLower(*GV));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeline">      assert(K.second.size() != 0);</td>
    <td class="lineNumber">785</td>
    <td class="codeline">      assert(K.second.size() != 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeline"></td>
    <td class="lineNumber">786</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeline">      if (AMDGPU::isDynamicLDS(*GV)) {</td>
    <td class="lineNumber">787</td>
    <td class="codeline">      if (AMDGPU::isDynamicLDS(*GV)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeline">        DynamicVariables.insert(GV);</td>
    <td class="lineNumber">788</td>
    <td class="codeline">        DynamicVariables.insert(GV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">789</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">790</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeline"></td>
    <td class="lineNumber">791</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeline">      switch (LoweringKindLoc) {</td>
    <td class="lineNumber">792</td>
    <td class="codeline">      switch (LoweringKindLoc) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeline">      case LoweringKind::module:</td>
    <td class="lineNumber">793</td>
    <td class="codeline">      case LoweringKind::module:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeline">        ModuleScopeVariables.insert(GV);</td>
    <td class="lineNumber">794</td>
    <td class="codeline">        ModuleScopeVariables.insert(GV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">795</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeline"></td>
    <td class="lineNumber">796</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeline">      case LoweringKind::table:</td>
    <td class="lineNumber">797</td>
    <td class="codeline">      case LoweringKind::table:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeline">        TableLookupVariables.insert(GV);</td>
    <td class="lineNumber">798</td>
    <td class="codeline">        TableLookupVariables.insert(GV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">799</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeline"></td>
    <td class="lineNumber">800</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeline">      case LoweringKind::kernel:</td>
    <td class="lineNumber">801</td>
    <td class="codeline">      case LoweringKind::kernel:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeline">        if (K.second.size() == 1) {</td>
    <td class="lineNumber">802</td>
    <td class="codeline">        if (K.second.size() == 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeline">          KernelAccessVariables.insert(GV);</td>
    <td class="lineNumber">803</td>
    <td class="codeline">          KernelAccessVariables.insert(GV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeline">        } else {</td>
    <td class="lineNumber">804</td>
    <td class="codeline">        } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeline">          report_fatal_error(</td>
    <td class="lineNumber">805</td>
    <td class="codeline">          report_fatal_error(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeline">              "cannot lower LDS '" + GV->getName() +</td>
    <td class="lineNumber">806</td>
    <td class="codeline">              "cannot lower LDS '" + GV->getName() +</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeline">              "' to kernel access as it is reachable from multiple kernels");</td>
    <td class="lineNumber">807</td>
    <td class="codeline">              "' to kernel access as it is reachable from multiple kernels");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">808</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">809</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeline"></td>
    <td class="lineNumber">810</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeline">      case LoweringKind::hybrid: {</td>
    <td class="lineNumber">811</td>
    <td class="codeline">      case LoweringKind::hybrid: {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeline">        if (GV == HybridModuleRoot) {</td>
    <td class="lineNumber">812</td>
    <td class="codeline">        if (GV == HybridModuleRoot) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeline">          assert(K.second.size() != 1);</td>
    <td class="lineNumber">813</td>
    <td class="codeline">          assert(K.second.size() != 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeline">          ModuleScopeVariables.insert(GV);</td>
    <td class="lineNumber">814</td>
    <td class="codeline">          ModuleScopeVariables.insert(GV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeline">        } else if (K.second.size() == 1) {</td>
    <td class="lineNumber">815</td>
    <td class="codeline">        } else if (K.second.size() == 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeline">          KernelAccessVariables.insert(GV);</td>
    <td class="lineNumber">816</td>
    <td class="codeline">          KernelAccessVariables.insert(GV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeline">        } else if (set_is_subset(K.second, HybridModuleRootKernels)) {</td>
    <td class="lineNumber">817</td>
    <td class="codeline">        } else if (set_is_subset(K.second, HybridModuleRootKernels)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeline">          ModuleScopeVariables.insert(GV);</td>
    <td class="lineNumber">818</td>
    <td class="codeline">          ModuleScopeVariables.insert(GV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeline">        } else {</td>
    <td class="lineNumber">819</td>
    <td class="codeline">        } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeline">          TableLookupVariables.insert(GV);</td>
    <td class="lineNumber">820</td>
    <td class="codeline">          TableLookupVariables.insert(GV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">821</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">822</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">823</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">824</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">825</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeline"></td>
    <td class="lineNumber">826</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeline">    // All LDS variables accessed indirectly have now been partitioned into</td>
    <td class="lineNumber">827</td>
    <td class="codeline">    // All LDS variables accessed indirectly have now been partitioned into</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeline">    // the distinct lowering strategies.</td>
    <td class="lineNumber">828</td>
    <td class="codeline">    // the distinct lowering strategies.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeline">    assert(ModuleScopeVariables.size() + TableLookupVariables.size() +</td>
    <td class="lineNumber">829</td>
    <td class="codeline">    assert(ModuleScopeVariables.size() + TableLookupVariables.size() +</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeline">               KernelAccessVariables.size() + DynamicVariables.size() ==</td>
    <td class="lineNumber">830</td>
    <td class="codeline">               KernelAccessVariables.size() + DynamicVariables.size() ==</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeline">           LDSToKernelsThatNeedToAccessItIndirectly.size());</td>
    <td class="lineNumber">831</td>
    <td class="codeline">           LDSToKernelsThatNeedToAccessItIndirectly.size());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">832</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeline"></td>
    <td class="lineNumber">833</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeline">  static GlobalVariable *lowerModuleScopeStructVariables(</td>
    <td class="lineNumber">834</td>
    <td class="codeline">  static GlobalVariable *lowerModuleScopeStructVariables(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeline">      Module &M, DenseSet<GlobalVariable *> const &ModuleScopeVariables,</td>
    <td class="lineNumber">835</td>
    <td class="codeline">      Module &M, DenseSet<GlobalVariable *> const &ModuleScopeVariables,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeline">      DenseSet<Function *> const &KernelsThatAllocateModuleLDS) {</td>
    <td class="lineNumber">836</td>
    <td class="codeline">      DenseSet<Function *> const &KernelsThatAllocateModuleLDS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeline">    // Create a struct to hold the ModuleScopeVariables</td>
    <td class="lineNumber">837</td>
    <td class="codeline">    // Create a struct to hold the ModuleScopeVariables</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeline">    // Replace all uses of those variables from non-kernel functions with the</td>
    <td class="lineNumber">838</td>
    <td class="codeline">    // Replace all uses of those variables from non-kernel functions with the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeline">    // new struct instance Replace only the uses from kernel functions that will</td>
    <td class="lineNumber">839</td>
    <td class="codeline">    // new struct instance Replace only the uses from kernel functions that will</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeline">    // allocate this instance. That is a space optimisation - kernels that use a</td>
    <td class="lineNumber">840</td>
    <td class="codeline">    // allocate this instance. That is a space optimisation - kernels that use a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeline">    // subset of the module scope struct and do not need to allocate it for</td>
    <td class="lineNumber">841</td>
    <td class="codeline">    // subset of the module scope struct and do not need to allocate it for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeline">    // indirect calls will only allocate the subset they use (they do so as part</td>
    <td class="lineNumber">842</td>
    <td class="codeline">    // indirect calls will only allocate the subset they use (they do so as part</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeline">    // of the per-kernel lowering).</td>
    <td class="lineNumber">843</td>
    <td class="codeline">    // of the per-kernel lowering).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeline">    if (ModuleScopeVariables.empty()) {</td>
    <td class="lineNumber">844</td>
    <td class="codeline">    if (ModuleScopeVariables.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeline">      return nullptr;</td>
    <td class="lineNumber">845</td>
    <td class="codeline">      return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">846</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeline"></td>
    <td class="lineNumber">847</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeline">    LLVMContext &Ctx = M.getContext();</td>
    <td class="lineNumber">848</td>
    <td class="codeline">    LLVMContext &Ctx = M.getContext();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeline"></td>
    <td class="lineNumber">849</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeline">    LDSVariableReplacement ModuleScopeReplacement =</td>
    <td class="lineNumber">850</td>
    <td class="codeline">    LDSVariableReplacement ModuleScopeReplacement =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeline">        createLDSVariableReplacement(M, "llvm.amdgcn.module.lds",</td>
    <td class="lineNumber">851</td>
    <td class="codeline">        createLDSVariableReplacement(M, "llvm.amdgcn.module.lds",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeline">                                     ModuleScopeVariables);</td>
    <td class="lineNumber">852</td>
    <td class="codeline">                                     ModuleScopeVariables);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeline"></td>
    <td class="lineNumber">853</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeline">    appendToCompilerUsed(M, {static_cast<GlobalValue *>(</td>
    <td class="lineNumber">854</td>
    <td class="codeline">    appendToCompilerUsed(M, {static_cast<GlobalValue *>(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeline">                                ConstantExpr::getPointerBitCastOrAddrSpaceCast(</td>
    <td class="lineNumber">855</td>
    <td class="codeline">                                ConstantExpr::getPointerBitCastOrAddrSpaceCast(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeline">                                    cast<Constant>(ModuleScopeReplacement.SGV),</td>
    <td class="lineNumber">856</td>
    <td class="codeline">                                    cast<Constant>(ModuleScopeReplacement.SGV),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeline">                                    Type::getInt8PtrTy(Ctx)))});</td>
    <td class="lineNumber">857</td>
    <td class="codeline">                                    Type::getInt8PtrTy(Ctx)))});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeline"></td>
    <td class="lineNumber">858</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeline">    // module.lds will be allocated at zero in any kernel that allocates it</td>
    <td class="lineNumber">859</td>
    <td class="codeline">    // module.lds will be allocated at zero in any kernel that allocates it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeline">    recordLDSAbsoluteAddress(&M, ModuleScopeReplacement.SGV, 0);</td>
    <td class="lineNumber">860</td>
    <td class="codeline">    recordLDSAbsoluteAddress(&M, ModuleScopeReplacement.SGV, 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeline"></td>
    <td class="lineNumber">861</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeline">    // historic</td>
    <td class="lineNumber">862</td>
    <td class="codeline">    // historic</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeline">    removeLocalVarsFromUsedLists(M, ModuleScopeVariables);</td>
    <td class="lineNumber">863</td>
    <td class="codeline">    removeLocalVarsFromUsedLists(M, ModuleScopeVariables);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeline"></td>
    <td class="lineNumber">864</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeline">    // Replace all uses of module scope variable from non-kernel functions</td>
    <td class="lineNumber">865</td>
    <td class="codeline">    // Replace all uses of module scope variable from non-kernel functions</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeline">    replaceLDSVariablesWithStruct(</td>
    <td class="lineNumber">866</td>
    <td class="codeline">    replaceLDSVariablesWithStruct(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeline">        M, ModuleScopeVariables, ModuleScopeReplacement, [&](Use &U) {</td>
    <td class="lineNumber">867</td>
    <td class="codeline">        M, ModuleScopeVariables, ModuleScopeReplacement, [&](Use &U) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeline">          Instruction *I = dyn_cast<Instruction>(U.getUser());</td>
    <td class="lineNumber">868</td>
    <td class="codeline">          Instruction *I = dyn_cast<Instruction>(U.getUser());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeline">          if (!I) {</td>
    <td class="lineNumber">869</td>
    <td class="codeline">          if (!I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeline">            return false;</td>
    <td class="lineNumber">870</td>
    <td class="codeline">            return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">871</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeline">          Function *F = I->getFunction();</td>
    <td class="lineNumber">872</td>
    <td class="codeline">          Function *F = I->getFunction();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeline">          return !isKernelLDS(F);</td>
    <td class="lineNumber">873</td>
    <td class="codeline">          return !isKernelLDS(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeline">        });</td>
    <td class="lineNumber">874</td>
    <td class="codeline">        });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeline"></td>
    <td class="lineNumber">875</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeline">    // Replace uses of module scope variable from kernel functions that</td>
    <td class="lineNumber">876</td>
    <td class="codeline">    // Replace uses of module scope variable from kernel functions that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeline">    // allocate the module scope variable, otherwise leave them unchanged</td>
    <td class="lineNumber">877</td>
    <td class="codeline">    // allocate the module scope variable, otherwise leave them unchanged</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeline">    // Record on each kernel whether the module scope global is used by it</td>
    <td class="lineNumber">878</td>
    <td class="codeline">    // Record on each kernel whether the module scope global is used by it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeline"></td>
    <td class="lineNumber">879</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeline">    for (Function &Func : M.functions()) {</td>
    <td class="lineNumber">880</td>
    <td class="codeline">    for (Function &Func : M.functions()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeline">      if (Func.isDeclaration() || !isKernelLDS(&Func))</td>
    <td class="lineNumber">881</td>
    <td class="codeline">      if (Func.isDeclaration() || !isKernelLDS(&Func))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">882</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeline"></td>
    <td class="lineNumber">883</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeline">      if (KernelsThatAllocateModuleLDS.contains(&Func)) {</td>
    <td class="lineNumber">884</td>
    <td class="codeline">      if (KernelsThatAllocateModuleLDS.contains(&Func)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeline">        replaceLDSVariablesWithStruct(</td>
    <td class="lineNumber">885</td>
    <td class="codeline">        replaceLDSVariablesWithStruct(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeline">            M, ModuleScopeVariables, ModuleScopeReplacement, [&](Use &U) {</td>
    <td class="lineNumber">886</td>
    <td class="codeline">            M, ModuleScopeVariables, ModuleScopeReplacement, [&](Use &U) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeline">              Instruction *I = dyn_cast<Instruction>(U.getUser());</td>
    <td class="lineNumber">887</td>
    <td class="codeline">              Instruction *I = dyn_cast<Instruction>(U.getUser());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeline">              if (!I) {</td>
    <td class="lineNumber">888</td>
    <td class="codeline">              if (!I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeline">                return false;</td>
    <td class="lineNumber">889</td>
    <td class="codeline">                return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeline">              }</td>
    <td class="lineNumber">890</td>
    <td class="codeline">              }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeline">              Function *F = I->getFunction();</td>
    <td class="lineNumber">891</td>
    <td class="codeline">              Function *F = I->getFunction();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeline">              return F == &Func;</td>
    <td class="lineNumber">892</td>
    <td class="codeline">              return F == &Func;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeline">            });</td>
    <td class="lineNumber">893</td>
    <td class="codeline">            });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeline"></td>
    <td class="lineNumber">894</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeline">        markUsedByKernel(&Func, ModuleScopeReplacement.SGV);</td>
    <td class="lineNumber">895</td>
    <td class="codeline">        markUsedByKernel(&Func, ModuleScopeReplacement.SGV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">896</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">897</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeline"></td>
    <td class="lineNumber">898</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeline">    return ModuleScopeReplacement.SGV;</td>
    <td class="lineNumber">899</td>
    <td class="codeline">    return ModuleScopeReplacement.SGV;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">900</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeline"></td>
    <td class="lineNumber">901</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeline">  static DenseMap<Function *, LDSVariableReplacement></td>
    <td class="lineNumber">902</td>
    <td class="codeline">  static DenseMap<Function *, LDSVariableReplacement></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeline">  lowerKernelScopeStructVariables(</td>
    <td class="lineNumber">903</td>
    <td class="codeline">  lowerKernelScopeStructVariables(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeline">      Module &M, LDSUsesInfoTy &LDSUsesInfo,</td>
    <td class="lineNumber">904</td>
    <td class="codeline">      Module &M, LDSUsesInfoTy &LDSUsesInfo,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeline">      DenseSet<GlobalVariable *> const &ModuleScopeVariables,</td>
    <td class="lineNumber">905</td>
    <td class="codeline">      DenseSet<GlobalVariable *> const &ModuleScopeVariables,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeline">      DenseSet<Function *> const &KernelsThatAllocateModuleLDS,</td>
    <td class="lineNumber">906</td>
    <td class="codeline">      DenseSet<Function *> const &KernelsThatAllocateModuleLDS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeline">      GlobalVariable *MaybeModuleScopeStruct) {</td>
    <td class="lineNumber">907</td>
    <td class="codeline">      GlobalVariable *MaybeModuleScopeStruct) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeline"></td>
    <td class="lineNumber">908</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeline">    // Create a struct for each kernel for the non-module-scope variables.</td>
    <td class="lineNumber">909</td>
    <td class="codeline">    // Create a struct for each kernel for the non-module-scope variables.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeline"></td>
    <td class="lineNumber">910</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeline">    DenseMap<Function *, LDSVariableReplacement> KernelToReplacement;</td>
    <td class="lineNumber">911</td>
    <td class="codeline">    DenseMap<Function *, LDSVariableReplacement> KernelToReplacement;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeline">    for (Function &Func : M.functions()) {</td>
    <td class="lineNumber">912</td>
    <td class="codeline">    for (Function &Func : M.functions()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeline">      if (Func.isDeclaration() || !isKernelLDS(&Func))</td>
    <td class="lineNumber">913</td>
    <td class="codeline">      if (Func.isDeclaration() || !isKernelLDS(&Func))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">914</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeline"></td>
    <td class="lineNumber">915</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeline">      DenseSet<GlobalVariable *> KernelUsedVariables;</td>
    <td class="lineNumber">916</td>
    <td class="codeline">      DenseSet<GlobalVariable *> KernelUsedVariables;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeline">      // Allocating variables that are used directly in this struct to get</td>
    <td class="lineNumber">917</td>
    <td class="codeline">      // Allocating variables that are used directly in this struct to get</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeline">      // alignment aware allocation and predictable frame size.</td>
    <td class="lineNumber">918</td>
    <td class="codeline">      // alignment aware allocation and predictable frame size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeline">      for (auto &v : LDSUsesInfo.direct_access[&Func]) {</td>
    <td class="lineNumber">919</td>
    <td class="codeline">      for (auto &v : LDSUsesInfo.direct_access[&Func]) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeline">        if (!AMDGPU::isDynamicLDS(*v)) {</td>
    <td class="lineNumber">920</td>
    <td class="codeline">        if (!AMDGPU::isDynamicLDS(*v)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeline">          KernelUsedVariables.insert(v);</td>
    <td class="lineNumber">921</td>
    <td class="codeline">          KernelUsedVariables.insert(v);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">922</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">923</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeline"></td>
    <td class="lineNumber">924</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeline">      // Allocating variables that are accessed indirectly so that a lookup of</td>
    <td class="lineNumber">925</td>
    <td class="codeline">      // Allocating variables that are accessed indirectly so that a lookup of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeline">      // this struct instance can find them from nested functions.</td>
    <td class="lineNumber">926</td>
    <td class="codeline">      // this struct instance can find them from nested functions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeline">      for (auto &v : LDSUsesInfo.indirect_access[&Func]) {</td>
    <td class="lineNumber">927</td>
    <td class="codeline">      for (auto &v : LDSUsesInfo.indirect_access[&Func]) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeline">        if (!AMDGPU::isDynamicLDS(*v)) {</td>
    <td class="lineNumber">928</td>
    <td class="codeline">        if (!AMDGPU::isDynamicLDS(*v)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeline">          KernelUsedVariables.insert(v);</td>
    <td class="lineNumber">929</td>
    <td class="codeline">          KernelUsedVariables.insert(v);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">930</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">931</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeline"></td>
    <td class="lineNumber">932</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeline">      // Variables allocated in module lds must all resolve to that struct,</td>
    <td class="lineNumber">933</td>
    <td class="codeline">      // Variables allocated in module lds must all resolve to that struct,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeline">      // not to the per-kernel instance.</td>
    <td class="lineNumber">934</td>
    <td class="codeline">      // not to the per-kernel instance.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeline">      if (KernelsThatAllocateModuleLDS.contains(&Func)) {</td>
    <td class="lineNumber">935</td>
    <td class="codeline">      if (KernelsThatAllocateModuleLDS.contains(&Func)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeline">        for (GlobalVariable *v : ModuleScopeVariables) {</td>
    <td class="lineNumber">936</td>
    <td class="codeline">        for (GlobalVariable *v : ModuleScopeVariables) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeline">          KernelUsedVariables.erase(v);</td>
    <td class="lineNumber">937</td>
    <td class="codeline">          KernelUsedVariables.erase(v);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">938</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">939</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeline"></td>
    <td class="lineNumber">940</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeline">      if (KernelUsedVariables.empty()) {</td>
    <td class="lineNumber">941</td>
    <td class="codeline">      if (KernelUsedVariables.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeline">        // Either used no LDS, or the LDS it used was all in the module struct</td>
    <td class="lineNumber">942</td>
    <td class="codeline">        // Either used no LDS, or the LDS it used was all in the module struct</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeline">        // or dynamically sized</td>
    <td class="lineNumber">943</td>
    <td class="codeline">        // or dynamically sized</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">944</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">945</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeline"></td>
    <td class="lineNumber">946</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeline">      // The association between kernel function and LDS struct is done by</td>
    <td class="lineNumber">947</td>
    <td class="codeline">      // The association between kernel function and LDS struct is done by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeline">      // symbol name, which only works if the function in question has a</td>
    <td class="lineNumber">948</td>
    <td class="codeline">      // symbol name, which only works if the function in question has a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeline">      // name This is not expected to be a problem in practice as kernels</td>
    <td class="lineNumber">949</td>
    <td class="codeline">      // name This is not expected to be a problem in practice as kernels</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeline">      // are called by name making anonymous ones (which are named by the</td>
    <td class="lineNumber">950</td>
    <td class="codeline">      // are called by name making anonymous ones (which are named by the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeline">      // backend) difficult to use. This does mean that llvm test cases need</td>
    <td class="lineNumber">951</td>
    <td class="codeline">      // backend) difficult to use. This does mean that llvm test cases need</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeline">      // to name the kernels.</td>
    <td class="lineNumber">952</td>
    <td class="codeline">      // to name the kernels.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeline">      if (!Func.hasName()) {</td>
    <td class="lineNumber">953</td>
    <td class="codeline">      if (!Func.hasName()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeline">        report_fatal_error("Anonymous kernels cannot use LDS variables");</td>
    <td class="lineNumber">954</td>
    <td class="codeline">        report_fatal_error("Anonymous kernels cannot use LDS variables");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">955</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeline"></td>
    <td class="lineNumber">956</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeline">      std::string VarName =</td>
    <td class="lineNumber">957</td>
    <td class="codeline">      std::string VarName =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeline">          (Twine("llvm.amdgcn.kernel.") + Func.getName() + ".lds").str();</td>
    <td class="lineNumber">958</td>
    <td class="codeline">          (Twine("llvm.amdgcn.kernel.") + Func.getName() + ".lds").str();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeline"></td>
    <td class="lineNumber">959</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeline">      auto Replacement =</td>
    <td class="lineNumber">960</td>
    <td class="codeline">      auto Replacement =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeline">          createLDSVariableReplacement(M, VarName, KernelUsedVariables);</td>
    <td class="lineNumber">961</td>
    <td class="codeline">          createLDSVariableReplacement(M, VarName, KernelUsedVariables);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeline"></td>
    <td class="lineNumber">962</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeline">      // If any indirect uses, create a direct use to ensure allocation</td>
    <td class="lineNumber">963</td>
    <td class="codeline">      // If any indirect uses, create a direct use to ensure allocation</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeline">      // TODO: Simpler to unconditionally mark used but that regresses</td>
    <td class="lineNumber">964</td>
    <td class="codeline">      // TODO: Simpler to unconditionally mark used but that regresses</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeline">      // codegen in test/CodeGen/AMDGPU/noclobber-barrier.ll</td>
    <td class="lineNumber">965</td>
    <td class="codeline">      // codegen in test/CodeGen/AMDGPU/noclobber-barrier.ll</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeline">      auto Accesses = LDSUsesInfo.indirect_access.find(&Func);</td>
    <td class="lineNumber">966</td>
    <td class="codeline">      auto Accesses = LDSUsesInfo.indirect_access.find(&Func);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeline">      if ((Accesses != LDSUsesInfo.indirect_access.end()) &&</td>
    <td class="lineNumber">967</td>
    <td class="codeline">      if ((Accesses != LDSUsesInfo.indirect_access.end()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeline">          !Accesses->second.empty())</td>
    <td class="lineNumber">968</td>
    <td class="codeline">          !Accesses->second.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeline">        markUsedByKernel(&Func, Replacement.SGV);</td>
    <td class="lineNumber">969</td>
    <td class="codeline">        markUsedByKernel(&Func, Replacement.SGV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeline"></td>
    <td class="lineNumber">970</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeline">      // remove preserves existing codegen</td>
    <td class="lineNumber">971</td>
    <td class="codeline">      // remove preserves existing codegen</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeline">      removeLocalVarsFromUsedLists(M, KernelUsedVariables);</td>
    <td class="lineNumber">972</td>
    <td class="codeline">      removeLocalVarsFromUsedLists(M, KernelUsedVariables);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeline">      KernelToReplacement[&Func] = Replacement;</td>
    <td class="lineNumber">973</td>
    <td class="codeline">      KernelToReplacement[&Func] = Replacement;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeline"></td>
    <td class="lineNumber">974</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeline">      // Rewrite uses within kernel to the new struct</td>
    <td class="lineNumber">975</td>
    <td class="codeline">      // Rewrite uses within kernel to the new struct</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeline">      replaceLDSVariablesWithStruct(</td>
    <td class="lineNumber">976</td>
    <td class="codeline">      replaceLDSVariablesWithStruct(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeline">          M, KernelUsedVariables, Replacement, [&Func](Use &U) {</td>
    <td class="lineNumber">977</td>
    <td class="codeline">          M, KernelUsedVariables, Replacement, [&Func](Use &U) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeline">            Instruction *I = dyn_cast<Instruction>(U.getUser());</td>
    <td class="lineNumber">978</td>
    <td class="codeline">            Instruction *I = dyn_cast<Instruction>(U.getUser());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeline">            return I && I->getFunction() == &Func;</td>
    <td class="lineNumber">979</td>
    <td class="codeline">            return I && I->getFunction() == &Func;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeline">          });</td>
    <td class="lineNumber">980</td>
    <td class="codeline">          });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">981</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeline">    return KernelToReplacement;</td>
    <td class="lineNumber">982</td>
    <td class="codeline">    return KernelToReplacement;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">983</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeline"></td>
    <td class="lineNumber">984</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeline">  static GlobalVariable *</td>
    <td class="lineNumber">985</td>
    <td class="codeline">  static GlobalVariable *</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeline">  buildRepresentativeDynamicLDSInstance(Module &M, LDSUsesInfoTy &LDSUsesInfo,</td>
    <td class="lineNumber">986</td>
    <td class="codeline">  buildRepresentativeDynamicLDSInstance(Module &M, LDSUsesInfoTy &LDSUsesInfo,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeline">                                        Function *func) {</td>
    <td class="lineNumber">987</td>
    <td class="codeline">                                        Function *func) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeline">    // Create a dynamic lds variable with a name associated with the passed</td>
    <td class="lineNumber">988</td>
    <td class="codeline">    // Create a dynamic lds variable with a name associated with the passed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeline">    // function that has the maximum alignment of any dynamic lds variable</td>
    <td class="lineNumber">989</td>
    <td class="codeline">    // function that has the maximum alignment of any dynamic lds variable</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeline">    // reachable from this kernel. Dynamic LDS is allocated after the static LDS</td>
    <td class="lineNumber">990</td>
    <td class="codeline">    // reachable from this kernel. Dynamic LDS is allocated after the static LDS</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeline">    // allocation, possibly after alignment padding. The representative variable</td>
    <td class="lineNumber">991</td>
    <td class="codeline">    // allocation, possibly after alignment padding. The representative variable</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeline">    // created here has the maximum alignment of any other dynamic variable</td>
    <td class="lineNumber">992</td>
    <td class="codeline">    // created here has the maximum alignment of any other dynamic variable</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeline">    // reachable by that kernel. All dynamic LDS variables are allocated at the</td>
    <td class="lineNumber">993</td>
    <td class="codeline">    // reachable by that kernel. All dynamic LDS variables are allocated at the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeline">    // same address in each kernel in order to provide the documented aliasing</td>
    <td class="lineNumber">994</td>
    <td class="codeline">    // same address in each kernel in order to provide the documented aliasing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeline">    // semantics. Setting the alignment here allows this IR pass to accurately</td>
    <td class="lineNumber">995</td>
    <td class="codeline">    // semantics. Setting the alignment here allows this IR pass to accurately</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeline">    // predict the exact constant at which it will be allocated.</td>
    <td class="lineNumber">996</td>
    <td class="codeline">    // predict the exact constant at which it will be allocated.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeline"></td>
    <td class="lineNumber">997</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeline">    assert(isKernelLDS(func));</td>
    <td class="lineNumber">998</td>
    <td class="codeline">    assert(isKernelLDS(func));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeline"></td>
    <td class="lineNumber">999</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeline">    LLVMContext &Ctx = M.getContext();</td>
    <td class="lineNumber">1000</td>
    <td class="codeline">    LLVMContext &Ctx = M.getContext();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeline">    const DataLayout &DL = M.getDataLayout();</td>
    <td class="lineNumber">1001</td>
    <td class="codeline">    const DataLayout &DL = M.getDataLayout();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeline">    Align MaxDynamicAlignment(1);</td>
    <td class="lineNumber">1002</td>
    <td class="codeline">    Align MaxDynamicAlignment(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeline"></td>
    <td class="lineNumber">1003</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeline">    auto UpdateMaxAlignment = [&MaxDynamicAlignment, &DL](GlobalVariable *GV) {</td>
    <td class="lineNumber">1004</td>
    <td class="codeline">    auto UpdateMaxAlignment = [&MaxDynamicAlignment, &DL](GlobalVariable *GV) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeline">      if (AMDGPU::isDynamicLDS(*GV)) {</td>
    <td class="lineNumber">1005</td>
    <td class="codeline">      if (AMDGPU::isDynamicLDS(*GV)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeline">        MaxDynamicAlignment =</td>
    <td class="lineNumber">1006</td>
    <td class="codeline">        MaxDynamicAlignment =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeline">            std::max(MaxDynamicAlignment, AMDGPU::getAlign(DL, GV));</td>
    <td class="lineNumber">1007</td>
    <td class="codeline">            std::max(MaxDynamicAlignment, AMDGPU::getAlign(DL, GV));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1008</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeline">    };</td>
    <td class="lineNumber">1009</td>
    <td class="codeline">    };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeline"></td>
    <td class="lineNumber">1010</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeline">    for (GlobalVariable *GV : LDSUsesInfo.indirect_access[func]) {</td>
    <td class="lineNumber">1011</td>
    <td class="codeline">    for (GlobalVariable *GV : LDSUsesInfo.indirect_access[func]) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeline">      UpdateMaxAlignment(GV);</td>
    <td class="lineNumber">1012</td>
    <td class="codeline">      UpdateMaxAlignment(GV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1013</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeline"></td>
    <td class="lineNumber">1014</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeline">    for (GlobalVariable *GV : LDSUsesInfo.direct_access[func]) {</td>
    <td class="lineNumber">1015</td>
    <td class="codeline">    for (GlobalVariable *GV : LDSUsesInfo.direct_access[func]) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeline">      UpdateMaxAlignment(GV);</td>
    <td class="lineNumber">1016</td>
    <td class="codeline">      UpdateMaxAlignment(GV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1017</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeline"></td>
    <td class="lineNumber">1018</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeline">    assert(func->hasName()); // Checked by caller</td>
    <td class="lineNumber">1019</td>
    <td class="codeline">    assert(func->hasName()); // Checked by caller</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeline">    auto emptyCharArray = ArrayType::get(Type::getInt8Ty(Ctx), 0);</td>
    <td class="lineNumber">1020</td>
    <td class="codeline">    auto emptyCharArray = ArrayType::get(Type::getInt8Ty(Ctx), 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeline">    GlobalVariable *N = new GlobalVariable(</td>
    <td class="lineNumber">1021</td>
    <td class="codeline">    GlobalVariable *N = new GlobalVariable(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeline">        M, emptyCharArray, false, GlobalValue::ExternalLinkage, nullptr,</td>
    <td class="lineNumber">1022</td>
    <td class="codeline">        M, emptyCharArray, false, GlobalValue::ExternalLinkage, nullptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeline">        Twine("llvm.amdgcn." + func->getName() + ".dynlds"), nullptr, GlobalValue::NotThreadLocal, AMDGPUAS::LOCAL_ADDRESS,</td>
    <td class="lineNumber">1023</td>
    <td class="codeline">        Twine("llvm.amdgcn." + func->getName() + ".dynlds"), nullptr, GlobalValue::NotThreadLocal, AMDGPUAS::LOCAL_ADDRESS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeline">        false);</td>
    <td class="lineNumber">1024</td>
    <td class="codeline">        false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeline">    N->setAlignment(MaxDynamicAlignment);</td>
    <td class="lineNumber">1025</td>
    <td class="codeline">    N->setAlignment(MaxDynamicAlignment);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeline"></td>
    <td class="lineNumber">1026</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeline">    assert(AMDGPU::isDynamicLDS(*N));</td>
    <td class="lineNumber">1027</td>
    <td class="codeline">    assert(AMDGPU::isDynamicLDS(*N));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeline">    return N;</td>
    <td class="lineNumber">1028</td>
    <td class="codeline">    return N;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1029</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeline"></td>
    <td class="lineNumber">1030</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeline">  DenseMap<Function *, GlobalVariable *> lowerDynamicLDSVariables(</td>
    <td class="lineNumber">1031</td>
    <td class="codeline">  DenseMap<Function *, GlobalVariable *> lowerDynamicLDSVariables(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeline">      Module &M, LDSUsesInfoTy &LDSUsesInfo,</td>
    <td class="lineNumber">1032</td>
    <td class="codeline">      Module &M, LDSUsesInfoTy &LDSUsesInfo,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeline">      DenseSet<Function *> const &KernelsThatIndirectlyAllocateDynamicLDS,</td>
    <td class="lineNumber">1033</td>
    <td class="codeline">      DenseSet<Function *> const &KernelsThatIndirectlyAllocateDynamicLDS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeline">      DenseSet<GlobalVariable *> const &DynamicVariables,</td>
    <td class="lineNumber">1034</td>
    <td class="codeline">      DenseSet<GlobalVariable *> const &DynamicVariables,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeline">      std::vector<Function *> const &OrderedKernels) {</td>
    <td class="lineNumber">1035</td>
    <td class="codeline">      std::vector<Function *> const &OrderedKernels) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeline">    DenseMap<Function *, GlobalVariable *> KernelToCreatedDynamicLDS;</td>
    <td class="lineNumber">1036</td>
    <td class="codeline">    DenseMap<Function *, GlobalVariable *> KernelToCreatedDynamicLDS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeline">    if (!KernelsThatIndirectlyAllocateDynamicLDS.empty()) {</td>
    <td class="lineNumber">1037</td>
    <td class="codeline">    if (!KernelsThatIndirectlyAllocateDynamicLDS.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeline">      LLVMContext &Ctx = M.getContext();</td>
    <td class="lineNumber">1038</td>
    <td class="codeline">      LLVMContext &Ctx = M.getContext();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeline">      IRBuilder<> Builder(Ctx);</td>
    <td class="lineNumber">1039</td>
    <td class="codeline">      IRBuilder<> Builder(Ctx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeline">      Type *I32 = Type::getInt32Ty(Ctx);</td>
    <td class="lineNumber">1040</td>
    <td class="codeline">      Type *I32 = Type::getInt32Ty(Ctx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeline"></td>
    <td class="lineNumber">1041</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeline">      std::vector<Constant *> newDynamicLDS;</td>
    <td class="lineNumber">1042</td>
    <td class="codeline">      std::vector<Constant *> newDynamicLDS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeline"></td>
    <td class="lineNumber">1043</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeline">      // Table is built in the same order as OrderedKernels</td>
    <td class="lineNumber">1044</td>
    <td class="codeline">      // Table is built in the same order as OrderedKernels</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeline">      for (auto &func : OrderedKernels) {</td>
    <td class="lineNumber">1045</td>
    <td class="codeline">      for (auto &func : OrderedKernels) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeline"></td>
    <td class="lineNumber">1046</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeline">        if (KernelsThatIndirectlyAllocateDynamicLDS.contains(func)) {</td>
    <td class="lineNumber">1047</td>
    <td class="codeline">        if (KernelsThatIndirectlyAllocateDynamicLDS.contains(func)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeline">          assert(isKernelLDS(func));</td>
    <td class="lineNumber">1048</td>
    <td class="codeline">          assert(isKernelLDS(func));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeline">          if (!func->hasName()) {</td>
    <td class="lineNumber">1049</td>
    <td class="codeline">          if (!func->hasName()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeline">            report_fatal_error("Anonymous kernels cannot use LDS variables");</td>
    <td class="lineNumber">1050</td>
    <td class="codeline">            report_fatal_error("Anonymous kernels cannot use LDS variables");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">1051</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeline"></td>
    <td class="lineNumber">1052</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeline">          GlobalVariable *N =</td>
    <td class="lineNumber">1053</td>
    <td class="codeline">          GlobalVariable *N =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeline">              buildRepresentativeDynamicLDSInstance(M, LDSUsesInfo, func);</td>
    <td class="lineNumber">1054</td>
    <td class="codeline">              buildRepresentativeDynamicLDSInstance(M, LDSUsesInfo, func);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeline"></td>
    <td class="lineNumber">1055</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeline">          KernelToCreatedDynamicLDS[func] = N;</td>
    <td class="lineNumber">1056</td>
    <td class="codeline">          KernelToCreatedDynamicLDS[func] = N;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeline"></td>
    <td class="lineNumber">1057</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeline">          markUsedByKernel(func, N);</td>
    <td class="lineNumber">1058</td>
    <td class="codeline">          markUsedByKernel(func, N);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeline"></td>
    <td class="lineNumber">1059</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeline">          auto emptyCharArray = ArrayType::get(Type::getInt8Ty(Ctx), 0);</td>
    <td class="lineNumber">1060</td>
    <td class="codeline">          auto emptyCharArray = ArrayType::get(Type::getInt8Ty(Ctx), 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeline">          auto GEP = ConstantExpr::getGetElementPtr(</td>
    <td class="lineNumber">1061</td>
    <td class="codeline">          auto GEP = ConstantExpr::getGetElementPtr(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeline">              emptyCharArray, N, ConstantInt::get(I32, 0), true);</td>
    <td class="lineNumber">1062</td>
    <td class="codeline">              emptyCharArray, N, ConstantInt::get(I32, 0), true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeline">          newDynamicLDS.push_back(ConstantExpr::getPtrToInt(GEP, I32));</td>
    <td class="lineNumber">1063</td>
    <td class="codeline">          newDynamicLDS.push_back(ConstantExpr::getPtrToInt(GEP, I32));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeline">        } else {</td>
    <td class="lineNumber">1064</td>
    <td class="codeline">        } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeline">          newDynamicLDS.push_back(PoisonValue::get(I32));</td>
    <td class="lineNumber">1065</td>
    <td class="codeline">          newDynamicLDS.push_back(PoisonValue::get(I32));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1066</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1067</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeline">      assert(OrderedKernels.size() == newDynamicLDS.size());</td>
    <td class="lineNumber">1068</td>
    <td class="codeline">      assert(OrderedKernels.size() == newDynamicLDS.size());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeline"></td>
    <td class="lineNumber">1069</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeline">      ArrayType *t = ArrayType::get(I32, newDynamicLDS.size());</td>
    <td class="lineNumber">1070</td>
    <td class="codeline">      ArrayType *t = ArrayType::get(I32, newDynamicLDS.size());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeline">      Constant *init = ConstantArray::get(t, newDynamicLDS);</td>
    <td class="lineNumber">1071</td>
    <td class="codeline">      Constant *init = ConstantArray::get(t, newDynamicLDS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeline">      GlobalVariable *table = new GlobalVariable(</td>
    <td class="lineNumber">1072</td>
    <td class="codeline">      GlobalVariable *table = new GlobalVariable(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeline">          M, t, true, GlobalValue::InternalLinkage, init,</td>
    <td class="lineNumber">1073</td>
    <td class="codeline">          M, t, true, GlobalValue::InternalLinkage, init,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeline">          "llvm.amdgcn.dynlds.offset.table", nullptr,</td>
    <td class="lineNumber">1074</td>
    <td class="codeline">          "llvm.amdgcn.dynlds.offset.table", nullptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeline">          GlobalValue::NotThreadLocal, AMDGPUAS::CONSTANT_ADDRESS);</td>
    <td class="lineNumber">1075</td>
    <td class="codeline">          GlobalValue::NotThreadLocal, AMDGPUAS::CONSTANT_ADDRESS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeline"></td>
    <td class="lineNumber">1076</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeline">      for (GlobalVariable *GV : DynamicVariables) {</td>
    <td class="lineNumber">1077</td>
    <td class="codeline">      for (GlobalVariable *GV : DynamicVariables) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeline">        for (Use &U : make_early_inc_range(GV->uses())) {</td>
    <td class="lineNumber">1078</td>
    <td class="codeline">        for (Use &U : make_early_inc_range(GV->uses())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeline">          auto *I = dyn_cast<Instruction>(U.getUser());</td>
    <td class="lineNumber">1079</td>
    <td class="codeline">          auto *I = dyn_cast<Instruction>(U.getUser());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeline">          if (!I)</td>
    <td class="lineNumber">1080</td>
    <td class="codeline">          if (!I)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeline">            continue;</td>
    <td class="lineNumber">1081</td>
    <td class="codeline">            continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeline">          if (isKernelLDS(I->getFunction()))</td>
    <td class="lineNumber">1082</td>
    <td class="codeline">          if (isKernelLDS(I->getFunction()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeline">            continue;</td>
    <td class="lineNumber">1083</td>
    <td class="codeline">            continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeline"></td>
    <td class="lineNumber">1084</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeline">          replaceUseWithTableLookup(M, Builder, table, GV, U, nullptr);</td>
    <td class="lineNumber">1085</td>
    <td class="codeline">          replaceUseWithTableLookup(M, Builder, table, GV, U, nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1086</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1087</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1088</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeline">    return KernelToCreatedDynamicLDS;</td>
    <td class="lineNumber">1089</td>
    <td class="codeline">    return KernelToCreatedDynamicLDS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1090</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeline"></td>
    <td class="lineNumber">1091</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeline">  bool runOnModule(Module &M) override {</td>
    <td class="lineNumber">1092</td>
    <td class="codeline">  bool runOnModule(Module &M) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeline">    CallGraph CG = CallGraph(M);</td>
    <td class="lineNumber">1093</td>
    <td class="codeline">    CallGraph CG = CallGraph(M);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeline">    bool Changed = superAlignLDSGlobals(M);</td>
    <td class="lineNumber">1094</td>
    <td class="codeline">    bool Changed = superAlignLDSGlobals(M);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeline"></td>
    <td class="lineNumber">1095</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeline">    Changed |= eliminateConstantExprUsesOfLDSFromAllInstructions(M);</td>
    <td class="lineNumber">1096</td>
    <td class="codeline">    Changed |= eliminateConstantExprUsesOfLDSFromAllInstructions(M);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeline"></td>
    <td class="lineNumber">1097</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeline">    Changed = true; // todo: narrow this down</td>
    <td class="lineNumber">1098</td>
    <td class="codeline">    Changed = true; // todo: narrow this down</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeline"></td>
    <td class="lineNumber">1099</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeline">    // For each kernel, what variables does it access directly or through</td>
    <td class="lineNumber">1100</td>
    <td class="codeline">    // For each kernel, what variables does it access directly or through</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeline">    // callees</td>
    <td class="lineNumber">1101</td>
    <td class="codeline">    // callees</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeline">    LDSUsesInfoTy LDSUsesInfo = getTransitiveUsesOfLDS(CG, M);</td>
    <td class="lineNumber">1102</td>
    <td class="codeline">    LDSUsesInfoTy LDSUsesInfo = getTransitiveUsesOfLDS(CG, M);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeline"></td>
    <td class="lineNumber">1103</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeline">    // For each variable accessed through callees, which kernels access it</td>
    <td class="lineNumber">1104</td>
    <td class="codeline">    // For each variable accessed through callees, which kernels access it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeline">    VariableFunctionMap LDSToKernelsThatNeedToAccessItIndirectly;</td>
    <td class="lineNumber">1105</td>
    <td class="codeline">    VariableFunctionMap LDSToKernelsThatNeedToAccessItIndirectly;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeline">    for (auto &K : LDSUsesInfo.indirect_access) {</td>
    <td class="lineNumber">1106</td>
    <td class="codeline">    for (auto &K : LDSUsesInfo.indirect_access) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeline">      Function *F = K.first;</td>
    <td class="lineNumber">1107</td>
    <td class="codeline">      Function *F = K.first;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeline">      assert(isKernelLDS(F));</td>
    <td class="lineNumber">1108</td>
    <td class="codeline">      assert(isKernelLDS(F));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeline">      for (GlobalVariable *GV : K.second) {</td>
    <td class="lineNumber">1109</td>
    <td class="codeline">      for (GlobalVariable *GV : K.second) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeline">        LDSToKernelsThatNeedToAccessItIndirectly[GV].insert(F);</td>
    <td class="lineNumber">1110</td>
    <td class="codeline">        LDSToKernelsThatNeedToAccessItIndirectly[GV].insert(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1111</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1112</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeline"></td>
    <td class="lineNumber">1113</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeline">    // Partition variables accessed indirectly into the different strategies</td>
    <td class="lineNumber">1114</td>
    <td class="codeline">    // Partition variables accessed indirectly into the different strategies</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeline">    DenseSet<GlobalVariable *> ModuleScopeVariables;</td>
    <td class="lineNumber">1115</td>
    <td class="codeline">    DenseSet<GlobalVariable *> ModuleScopeVariables;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeline">    DenseSet<GlobalVariable *> TableLookupVariables;</td>
    <td class="lineNumber">1116</td>
    <td class="codeline">    DenseSet<GlobalVariable *> TableLookupVariables;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeline">    DenseSet<GlobalVariable *> KernelAccessVariables;</td>
    <td class="lineNumber">1117</td>
    <td class="codeline">    DenseSet<GlobalVariable *> KernelAccessVariables;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeline">    DenseSet<GlobalVariable *> DynamicVariables;</td>
    <td class="lineNumber">1118</td>
    <td class="codeline">    DenseSet<GlobalVariable *> DynamicVariables;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeline">    partitionVariablesIntoIndirectStrategies(</td>
    <td class="lineNumber">1119</td>
    <td class="codeline">    partitionVariablesIntoIndirectStrategies(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeline">        M, LDSUsesInfo, LDSToKernelsThatNeedToAccessItIndirectly,</td>
    <td class="lineNumber">1120</td>
    <td class="codeline">        M, LDSUsesInfo, LDSToKernelsThatNeedToAccessItIndirectly,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeline">        ModuleScopeVariables, TableLookupVariables, KernelAccessVariables,</td>
    <td class="lineNumber">1121</td>
    <td class="codeline">        ModuleScopeVariables, TableLookupVariables, KernelAccessVariables,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeline">        DynamicVariables);</td>
    <td class="lineNumber">1122</td>
    <td class="codeline">        DynamicVariables);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeline"></td>
    <td class="lineNumber">1123</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeline">    // If the kernel accesses a variable that is going to be stored in the</td>
    <td class="lineNumber">1124</td>
    <td class="codeline">    // If the kernel accesses a variable that is going to be stored in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeline">    // module instance through a call then that kernel needs to allocate the</td>
    <td class="lineNumber">1125</td>
    <td class="codeline">    // module instance through a call then that kernel needs to allocate the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeline">    // module instance</td>
    <td class="lineNumber">1126</td>
    <td class="codeline">    // module instance</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeline">    const DenseSet<Function *> KernelsThatAllocateModuleLDS =</td>
    <td class="lineNumber">1127</td>
    <td class="codeline">    const DenseSet<Function *> KernelsThatAllocateModuleLDS =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeline">        kernelsThatIndirectlyAccessAnyOfPassedVariables(M, LDSUsesInfo,</td>
    <td class="lineNumber">1128</td>
    <td class="codeline">        kernelsThatIndirectlyAccessAnyOfPassedVariables(M, LDSUsesInfo,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeline">                                                        ModuleScopeVariables);</td>
    <td class="lineNumber">1129</td>
    <td class="codeline">                                                        ModuleScopeVariables);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeline">    const DenseSet<Function *> KernelsThatAllocateTableLDS =</td>
    <td class="lineNumber">1130</td>
    <td class="codeline">    const DenseSet<Function *> KernelsThatAllocateTableLDS =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeline">        kernelsThatIndirectlyAccessAnyOfPassedVariables(M, LDSUsesInfo,</td>
    <td class="lineNumber">1131</td>
    <td class="codeline">        kernelsThatIndirectlyAccessAnyOfPassedVariables(M, LDSUsesInfo,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeline">                                                        TableLookupVariables);</td>
    <td class="lineNumber">1132</td>
    <td class="codeline">                                                        TableLookupVariables);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeline"></td>
    <td class="lineNumber">1133</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeline">    const DenseSet<Function *> KernelsThatIndirectlyAllocateDynamicLDS =</td>
    <td class="lineNumber">1134</td>
    <td class="codeline">    const DenseSet<Function *> KernelsThatIndirectlyAllocateDynamicLDS =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeline">        kernelsThatIndirectlyAccessAnyOfPassedVariables(M, LDSUsesInfo,</td>
    <td class="lineNumber">1135</td>
    <td class="codeline">        kernelsThatIndirectlyAccessAnyOfPassedVariables(M, LDSUsesInfo,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeline">                                                        DynamicVariables);</td>
    <td class="lineNumber">1136</td>
    <td class="codeline">                                                        DynamicVariables);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeline"></td>
    <td class="lineNumber">1137</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeline">    GlobalVariable *MaybeModuleScopeStruct = lowerModuleScopeStructVariables(</td>
    <td class="lineNumber">1138</td>
    <td class="codeline">    GlobalVariable *MaybeModuleScopeStruct = lowerModuleScopeStructVariables(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeline">        M, ModuleScopeVariables, KernelsThatAllocateModuleLDS);</td>
    <td class="lineNumber">1139</td>
    <td class="codeline">        M, ModuleScopeVariables, KernelsThatAllocateModuleLDS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeline"></td>
    <td class="lineNumber">1140</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeline">    DenseMap<Function *, LDSVariableReplacement> KernelToReplacement =</td>
    <td class="lineNumber">1141</td>
    <td class="codeline">    DenseMap<Function *, LDSVariableReplacement> KernelToReplacement =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeline">        lowerKernelScopeStructVariables(M, LDSUsesInfo, ModuleScopeVariables,</td>
    <td class="lineNumber">1142</td>
    <td class="codeline">        lowerKernelScopeStructVariables(M, LDSUsesInfo, ModuleScopeVariables,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeline">                                        KernelsThatAllocateModuleLDS,</td>
    <td class="lineNumber">1143</td>
    <td class="codeline">                                        KernelsThatAllocateModuleLDS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeline">                                        MaybeModuleScopeStruct);</td>
    <td class="lineNumber">1144</td>
    <td class="codeline">                                        MaybeModuleScopeStruct);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeline"></td>
    <td class="lineNumber">1145</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeline">    // Lower zero cost accesses to the kernel instances just created</td>
    <td class="lineNumber">1146</td>
    <td class="codeline">    // Lower zero cost accesses to the kernel instances just created</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeline">    for (auto &GV : KernelAccessVariables) {</td>
    <td class="lineNumber">1147</td>
    <td class="codeline">    for (auto &GV : KernelAccessVariables) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeline">      auto &funcs = LDSToKernelsThatNeedToAccessItIndirectly[GV];</td>
    <td class="lineNumber">1148</td>
    <td class="codeline">      auto &funcs = LDSToKernelsThatNeedToAccessItIndirectly[GV];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeline">      assert(funcs.size() == 1); // Only one kernel can access it</td>
    <td class="lineNumber">1149</td>
    <td class="codeline">      assert(funcs.size() == 1); // Only one kernel can access it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeline">      LDSVariableReplacement Replacement =</td>
    <td class="lineNumber">1150</td>
    <td class="codeline">      LDSVariableReplacement Replacement =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeline">          KernelToReplacement[*(funcs.begin())];</td>
    <td class="lineNumber">1151</td>
    <td class="codeline">          KernelToReplacement[*(funcs.begin())];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeline"></td>
    <td class="lineNumber">1152</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeline">      DenseSet<GlobalVariable *> Vec;</td>
    <td class="lineNumber">1153</td>
    <td class="codeline">      DenseSet<GlobalVariable *> Vec;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeline">      Vec.insert(GV);</td>
    <td class="lineNumber">1154</td>
    <td class="codeline">      Vec.insert(GV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeline"></td>
    <td class="lineNumber">1155</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeline">      replaceLDSVariablesWithStruct(M, Vec, Replacement, [](Use &U) {</td>
    <td class="lineNumber">1156</td>
    <td class="codeline">      replaceLDSVariablesWithStruct(M, Vec, Replacement, [](Use &U) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeline">        return isa<Instruction>(U.getUser());</td>
    <td class="lineNumber">1157</td>
    <td class="codeline">        return isa<Instruction>(U.getUser());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeline">      });</td>
    <td class="lineNumber">1158</td>
    <td class="codeline">      });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1159</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeline"></td>
    <td class="lineNumber">1160</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeline">    // The ith element of this vector is kernel id i</td>
    <td class="lineNumber">1161</td>
    <td class="codeline">    // The ith element of this vector is kernel id i</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeline">    std::vector<Function *> OrderedKernels =</td>
    <td class="lineNumber">1162</td>
    <td class="codeline">    std::vector<Function *> OrderedKernels =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeline">        assignLDSKernelIDToEachKernel(&M, KernelsThatAllocateTableLDS,</td>
    <td class="lineNumber">1163</td>
    <td class="codeline">        assignLDSKernelIDToEachKernel(&M, KernelsThatAllocateTableLDS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeline">                                      KernelsThatIndirectlyAllocateDynamicLDS);</td>
    <td class="lineNumber">1164</td>
    <td class="codeline">                                      KernelsThatIndirectlyAllocateDynamicLDS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeline"></td>
    <td class="lineNumber">1165</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeline">    if (!KernelsThatAllocateTableLDS.empty()) {</td>
    <td class="lineNumber">1166</td>
    <td class="codeline">    if (!KernelsThatAllocateTableLDS.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeline">      LLVMContext &Ctx = M.getContext();</td>
    <td class="lineNumber">1167</td>
    <td class="codeline">      LLVMContext &Ctx = M.getContext();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeline">      IRBuilder<> Builder(Ctx);</td>
    <td class="lineNumber">1168</td>
    <td class="codeline">      IRBuilder<> Builder(Ctx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeline"></td>
    <td class="lineNumber">1169</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeline">      // The order must be consistent between lookup table and accesses to</td>
    <td class="lineNumber">1170</td>
    <td class="codeline">      // The order must be consistent between lookup table and accesses to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeline">      // lookup table</td>
    <td class="lineNumber">1171</td>
    <td class="codeline">      // lookup table</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeline">      auto TableLookupVariablesOrdered =</td>
    <td class="lineNumber">1172</td>
    <td class="codeline">      auto TableLookupVariablesOrdered =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeline">          sortByName(std::vector<GlobalVariable *>(TableLookupVariables.begin(),</td>
    <td class="lineNumber">1173</td>
    <td class="codeline">          sortByName(std::vector<GlobalVariable *>(TableLookupVariables.begin(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeline">                                                   TableLookupVariables.end()));</td>
    <td class="lineNumber">1174</td>
    <td class="codeline">                                                   TableLookupVariables.end()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeline"></td>
    <td class="lineNumber">1175</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeline">      GlobalVariable *LookupTable = buildLookupTable(</td>
    <td class="lineNumber">1176</td>
    <td class="codeline">      GlobalVariable *LookupTable = buildLookupTable(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeline">          M, TableLookupVariablesOrdered, OrderedKernels, KernelToReplacement);</td>
    <td class="lineNumber">1177</td>
    <td class="codeline">          M, TableLookupVariablesOrdered, OrderedKernels, KernelToReplacement);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeline">      replaceUsesInInstructionsWithTableLookup(M, TableLookupVariablesOrdered,</td>
    <td class="lineNumber">1178</td>
    <td class="codeline">      replaceUsesInInstructionsWithTableLookup(M, TableLookupVariablesOrdered,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeline">                                               LookupTable);</td>
    <td class="lineNumber">1179</td>
    <td class="codeline">                                               LookupTable);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1180</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeline"></td>
    <td class="lineNumber">1181</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeline">    DenseMap<Function *, GlobalVariable *> KernelToCreatedDynamicLDS =</td>
    <td class="lineNumber">1182</td>
    <td class="codeline">    DenseMap<Function *, GlobalVariable *> KernelToCreatedDynamicLDS =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeline">        lowerDynamicLDSVariables(M, LDSUsesInfo,</td>
    <td class="lineNumber">1183</td>
    <td class="codeline">        lowerDynamicLDSVariables(M, LDSUsesInfo,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeline">                                 KernelsThatIndirectlyAllocateDynamicLDS,</td>
    <td class="lineNumber">1184</td>
    <td class="codeline">                                 KernelsThatIndirectlyAllocateDynamicLDS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeline">                                 DynamicVariables, OrderedKernels);</td>
    <td class="lineNumber">1185</td>
    <td class="codeline">                                 DynamicVariables, OrderedKernels);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeline"></td>
    <td class="lineNumber">1186</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeline">    // All kernel frames have been allocated. Calculate and record the</td>
    <td class="lineNumber">1187</td>
    <td class="codeline">    // All kernel frames have been allocated. Calculate and record the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeline">    // addresses.</td>
    <td class="lineNumber">1188</td>
    <td class="codeline">    // addresses.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeline">    {</td>
    <td class="lineNumber">1189</td>
    <td class="codeline">    {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeline">      const DataLayout &DL = M.getDataLayout();</td>
    <td class="lineNumber">1190</td>
    <td class="codeline">      const DataLayout &DL = M.getDataLayout();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeline"></td>
    <td class="lineNumber">1191</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeline">      for (Function &Func : M.functions()) {</td>
    <td class="lineNumber">1192</td>
    <td class="codeline">      for (Function &Func : M.functions()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeline">        if (Func.isDeclaration() || !isKernelLDS(&Func))</td>
    <td class="lineNumber">1193</td>
    <td class="codeline">        if (Func.isDeclaration() || !isKernelLDS(&Func))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">1194</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeline"></td>
    <td class="lineNumber">1195</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeline">        // All three of these are optional. The first variable is allocated at</td>
    <td class="lineNumber">1196</td>
    <td class="codeline">        // All three of these are optional. The first variable is allocated at</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeline">        // zero. They are allocated by AMDGPUMachineFunction as one block.</td>
    <td class="lineNumber">1197</td>
    <td class="codeline">        // zero. They are allocated by AMDGPUMachineFunction as one block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeline">        // Layout:</td>
    <td class="lineNumber">1198</td>
    <td class="codeline">        // Layout:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeline">        //{</td>
    <td class="lineNumber">1199</td>
    <td class="codeline">        //{</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeline">        //  module.lds</td>
    <td class="lineNumber">1200</td>
    <td class="codeline">        //  module.lds</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeline">        //  alignment padding</td>
    <td class="lineNumber">1201</td>
    <td class="codeline">        //  alignment padding</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeline">        //  kernel instance</td>
    <td class="lineNumber">1202</td>
    <td class="codeline">        //  kernel instance</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeline">        //  alignment padding</td>
    <td class="lineNumber">1203</td>
    <td class="codeline">        //  alignment padding</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeline">        //  dynamic lds variables</td>
    <td class="lineNumber">1204</td>
    <td class="codeline">        //  dynamic lds variables</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeline">        //}</td>
    <td class="lineNumber">1205</td>
    <td class="codeline">        //}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeline"></td>
    <td class="lineNumber">1206</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeline">        const bool AllocateModuleScopeStruct =</td>
    <td class="lineNumber">1207</td>
    <td class="codeline">        const bool AllocateModuleScopeStruct =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeline">            MaybeModuleScopeStruct &&</td>
    <td class="lineNumber">1208</td>
    <td class="codeline">            MaybeModuleScopeStruct &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeline">            KernelsThatAllocateModuleLDS.contains(&Func);</td>
    <td class="lineNumber">1209</td>
    <td class="codeline">            KernelsThatAllocateModuleLDS.contains(&Func);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeline"></td>
    <td class="lineNumber">1210</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeline">        auto Replacement = KernelToReplacement.find(&Func);</td>
    <td class="lineNumber">1211</td>
    <td class="codeline">        auto Replacement = KernelToReplacement.find(&Func);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeline">        const bool AllocateKernelScopeStruct =</td>
    <td class="lineNumber">1212</td>
    <td class="codeline">        const bool AllocateKernelScopeStruct =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeline">            Replacement != KernelToReplacement.end();</td>
    <td class="lineNumber">1213</td>
    <td class="codeline">            Replacement != KernelToReplacement.end();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeline"></td>
    <td class="lineNumber">1214</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeline">        const bool AllocateDynamicVariable =</td>
    <td class="lineNumber">1215</td>
    <td class="codeline">        const bool AllocateDynamicVariable =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeline">            KernelToCreatedDynamicLDS.contains(&Func);</td>
    <td class="lineNumber">1216</td>
    <td class="codeline">            KernelToCreatedDynamicLDS.contains(&Func);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeline"></td>
    <td class="lineNumber">1217</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeline">        uint32_t Offset = 0;</td>
    <td class="lineNumber">1218</td>
    <td class="codeline">        uint32_t Offset = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeline"></td>
    <td class="lineNumber">1219</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeline">        if (AllocateModuleScopeStruct) {</td>
    <td class="lineNumber">1220</td>
    <td class="codeline">        if (AllocateModuleScopeStruct) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeline">          // Allocated at zero, recorded once on construction, not once per</td>
    <td class="lineNumber">1221</td>
    <td class="codeline">          // Allocated at zero, recorded once on construction, not once per</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeline">          // kernel</td>
    <td class="lineNumber">1222</td>
    <td class="codeline">          // kernel</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeline">          Offset += DL.getTypeAllocSize(MaybeModuleScopeStruct->getValueType());</td>
    <td class="lineNumber">1223</td>
    <td class="codeline">          Offset += DL.getTypeAllocSize(MaybeModuleScopeStruct->getValueType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1224</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeline"></td>
    <td class="lineNumber">1225</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeline">        if (AllocateKernelScopeStruct) {</td>
    <td class="lineNumber">1226</td>
    <td class="codeline">        if (AllocateKernelScopeStruct) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeline">          GlobalVariable *KernelStruct = Replacement->second.SGV;</td>
    <td class="lineNumber">1227</td>
    <td class="codeline">          GlobalVariable *KernelStruct = Replacement->second.SGV;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeline">          Offset = alignTo(Offset, AMDGPU::getAlign(DL, KernelStruct));</td>
    <td class="lineNumber">1228</td>
    <td class="codeline">          Offset = alignTo(Offset, AMDGPU::getAlign(DL, KernelStruct));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeline">          recordLDSAbsoluteAddress(&M, KernelStruct, Offset);</td>
    <td class="lineNumber">1229</td>
    <td class="codeline">          recordLDSAbsoluteAddress(&M, KernelStruct, Offset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeline">          Offset += DL.getTypeAllocSize(KernelStruct->getValueType());</td>
    <td class="lineNumber">1230</td>
    <td class="codeline">          Offset += DL.getTypeAllocSize(KernelStruct->getValueType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1231</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeline"></td>
    <td class="lineNumber">1232</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeline">        // If there is dynamic allocation, the alignment needed is included in</td>
    <td class="lineNumber">1233</td>
    <td class="codeline">        // If there is dynamic allocation, the alignment needed is included in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeline">        // the static frame size. There may be no reference to the dynamic</td>
    <td class="lineNumber">1234</td>
    <td class="codeline">        // the static frame size. There may be no reference to the dynamic</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeline">        // variable in the kernel itself, so without including it here, that</td>
    <td class="lineNumber">1235</td>
    <td class="codeline">        // variable in the kernel itself, so without including it here, that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeline">        // alignment padding could be missed.</td>
    <td class="lineNumber">1236</td>
    <td class="codeline">        // alignment padding could be missed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeline">        if (AllocateDynamicVariable) {</td>
    <td class="lineNumber">1237</td>
    <td class="codeline">        if (AllocateDynamicVariable) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeline">          GlobalVariable *DynamicVariable = KernelToCreatedDynamicLDS[&Func];</td>
    <td class="lineNumber">1238</td>
    <td class="codeline">          GlobalVariable *DynamicVariable = KernelToCreatedDynamicLDS[&Func];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeline">          Offset = alignTo(Offset, AMDGPU::getAlign(DL, DynamicVariable));</td>
    <td class="lineNumber">1239</td>
    <td class="codeline">          Offset = alignTo(Offset, AMDGPU::getAlign(DL, DynamicVariable));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeline">          recordLDSAbsoluteAddress(&M, DynamicVariable, Offset);</td>
    <td class="lineNumber">1240</td>
    <td class="codeline">          recordLDSAbsoluteAddress(&M, DynamicVariable, Offset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1241</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeline"></td>
    <td class="lineNumber">1242</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeline">        if (Offset != 0) {</td>
    <td class="lineNumber">1243</td>
    <td class="codeline">        if (Offset != 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeline">          std::string Buffer;</td>
    <td class="lineNumber">1244</td>
    <td class="codeline">          std::string Buffer;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeline">          raw_string_ostream SS{Buffer};</td>
    <td class="lineNumber">1245</td>
    <td class="codeline">          raw_string_ostream SS{Buffer};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeline">          SS << format("%u", Offset);</td>
    <td class="lineNumber">1246</td>
    <td class="codeline">          SS << format("%u", Offset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeline"></td>
    <td class="lineNumber">1247</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeline">          // Instead of explictly marking kernels that access dynamic variables</td>
    <td class="lineNumber">1248</td>
    <td class="codeline">          // Instead of explictly marking kernels that access dynamic variables</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeline">          // using special case metadata, annotate with min-lds == max-lds, i.e.</td>
    <td class="lineNumber">1249</td>
    <td class="codeline">          // using special case metadata, annotate with min-lds == max-lds, i.e.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeline">          // that there is no more space available for allocating more static</td>
    <td class="lineNumber">1250</td>
    <td class="codeline">          // that there is no more space available for allocating more static</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeline">          // LDS variables. That is the right condition to prevent allocating</td>
    <td class="lineNumber">1251</td>
    <td class="codeline">          // LDS variables. That is the right condition to prevent allocating</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeline">          // more variables which would collide with the addresses assigned to</td>
    <td class="lineNumber">1252</td>
    <td class="codeline">          // more variables which would collide with the addresses assigned to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeline">          // dynamic variables.</td>
    <td class="lineNumber">1253</td>
    <td class="codeline">          // dynamic variables.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeline">          if (AllocateDynamicVariable)</td>
    <td class="lineNumber">1254</td>
    <td class="codeline">          if (AllocateDynamicVariable)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeline">            SS << format(",%u", Offset);</td>
    <td class="lineNumber">1255</td>
    <td class="codeline">            SS << format(",%u", Offset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeline"></td>
    <td class="lineNumber">1256</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeline">          Func.addFnAttr("amdgpu-lds-size", Buffer);</td>
    <td class="lineNumber">1257</td>
    <td class="codeline">          Func.addFnAttr("amdgpu-lds-size", Buffer);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1258</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1259</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1260</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeline"></td>
    <td class="lineNumber">1261</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeline">    for (auto &GV : make_early_inc_range(M.globals()))</td>
    <td class="lineNumber">1262</td>
    <td class="codeline">    for (auto &GV : make_early_inc_range(M.globals()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeline">      if (AMDGPU::isLDSVariableToLower(GV)) {</td>
    <td class="lineNumber">1263</td>
    <td class="codeline">      if (AMDGPU::isLDSVariableToLower(GV)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeline">        // probably want to remove from used lists</td>
    <td class="lineNumber">1264</td>
    <td class="codeline">        // probably want to remove from used lists</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeline">        GV.removeDeadConstantUsers();</td>
    <td class="lineNumber">1265</td>
    <td class="codeline">        GV.removeDeadConstantUsers();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeline">        if (GV.use_empty())</td>
    <td class="lineNumber">1266</td>
    <td class="codeline">        if (GV.use_empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeline">          GV.eraseFromParent();</td>
    <td class="lineNumber">1267</td>
    <td class="codeline">          GV.eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1268</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeline"></td>
    <td class="lineNumber">1269</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeline">    return Changed;</td>
    <td class="lineNumber">1270</td>
    <td class="codeline">    return Changed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1271</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeline"></td>
    <td class="lineNumber">1272</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">1273</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeline">  // Increase the alignment of LDS globals if necessary to maximise the chance</td>
    <td class="lineNumber">1274</td>
    <td class="codeline">  // Increase the alignment of LDS globals if necessary to maximise the chance</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeline">  // that we can use aligned LDS instructions to access them.</td>
    <td class="lineNumber">1275</td>
    <td class="codeline">  // that we can use aligned LDS instructions to access them.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeline">  static bool superAlignLDSGlobals(Module &M) {</td>
    <td class="lineNumber">1276</td>
    <td class="codeline">  static bool superAlignLDSGlobals(Module &M) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeline">    const DataLayout &DL = M.getDataLayout();</td>
    <td class="lineNumber">1277</td>
    <td class="codeline">    const DataLayout &DL = M.getDataLayout();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeline">    bool Changed = false;</td>
    <td class="lineNumber">1278</td>
    <td class="codeline">    bool Changed = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeline">    if (!SuperAlignLDSGlobals) {</td>
    <td class="lineNumber">1279</td>
    <td class="codeline">    if (!SuperAlignLDSGlobals) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeline">      return Changed;</td>
    <td class="lineNumber">1280</td>
    <td class="codeline">      return Changed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1281</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeline"></td>
    <td class="lineNumber">1282</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeline">    for (auto &GV : M.globals()) {</td>
    <td class="lineNumber">1283</td>
    <td class="codeline">    for (auto &GV : M.globals()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeline">      if (GV.getType()->getPointerAddressSpace() != AMDGPUAS::LOCAL_ADDRESS) {</td>
    <td class="lineNumber">1284</td>
    <td class="codeline">      if (GV.getType()->getPointerAddressSpace() != AMDGPUAS::LOCAL_ADDRESS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeline">        // Only changing alignment of LDS variables</td>
    <td class="lineNumber">1285</td>
    <td class="codeline">        // Only changing alignment of LDS variables</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1286</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1287</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeline">      if (!GV.hasInitializer()) {</td>
    <td class="lineNumber">1288</td>
    <td class="codeline">      if (!GV.hasInitializer()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeline">        // cuda/hip extern __shared__ variable, leave alignment alone</td>
    <td class="lineNumber">1289</td>
    <td class="codeline">        // cuda/hip extern __shared__ variable, leave alignment alone</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1290</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1291</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeline"></td>
    <td class="lineNumber">1292</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeline">      Align Alignment = AMDGPU::getAlign(DL, &GV);</td>
    <td class="lineNumber">1293</td>
    <td class="codeline">      Align Alignment = AMDGPU::getAlign(DL, &GV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeline">      TypeSize GVSize = DL.getTypeAllocSize(GV.getValueType());</td>
    <td class="lineNumber">1294</td>
    <td class="codeline">      TypeSize GVSize = DL.getTypeAllocSize(GV.getValueType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeline"></td>
    <td class="lineNumber">1295</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeline">      if (GVSize > 8) {</td>
    <td class="lineNumber">1296</td>
    <td class="codeline">      if (GVSize > 8) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeline">        // We might want to use a b96 or b128 load/store</td>
    <td class="lineNumber">1297</td>
    <td class="codeline">        // We might want to use a b96 or b128 load/store</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeline">        Alignment = std::max(Alignment, Align(16));</td>
    <td class="lineNumber">1298</td>
    <td class="codeline">        Alignment = std::max(Alignment, Align(16));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeline">      } else if (GVSize > 4) {</td>
    <td class="lineNumber">1299</td>
    <td class="codeline">      } else if (GVSize > 4) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeline">        // We might want to use a b64 load/store</td>
    <td class="lineNumber">1300</td>
    <td class="codeline">        // We might want to use a b64 load/store</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeline">        Alignment = std::max(Alignment, Align(8));</td>
    <td class="lineNumber">1301</td>
    <td class="codeline">        Alignment = std::max(Alignment, Align(8));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeline">      } else if (GVSize > 2) {</td>
    <td class="lineNumber">1302</td>
    <td class="codeline">      } else if (GVSize > 2) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeline">        // We might want to use a b32 load/store</td>
    <td class="lineNumber">1303</td>
    <td class="codeline">        // We might want to use a b32 load/store</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeline">        Alignment = std::max(Alignment, Align(4));</td>
    <td class="lineNumber">1304</td>
    <td class="codeline">        Alignment = std::max(Alignment, Align(4));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeline">      } else if (GVSize > 1) {</td>
    <td class="lineNumber">1305</td>
    <td class="codeline">      } else if (GVSize > 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeline">        // We might want to use a b16 load/store</td>
    <td class="lineNumber">1306</td>
    <td class="codeline">        // We might want to use a b16 load/store</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeline">        Alignment = std::max(Alignment, Align(2));</td>
    <td class="lineNumber">1307</td>
    <td class="codeline">        Alignment = std::max(Alignment, Align(2));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1308</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeline"></td>
    <td class="lineNumber">1309</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeline">      if (Alignment != AMDGPU::getAlign(DL, &GV)) {</td>
    <td class="lineNumber">1310</td>
    <td class="codeline">      if (Alignment != AMDGPU::getAlign(DL, &GV)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeline">        Changed = true;</td>
    <td class="lineNumber">1311</td>
    <td class="codeline">        Changed = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeline">        GV.setAlignment(Alignment);</td>
    <td class="lineNumber">1312</td>
    <td class="codeline">        GV.setAlignment(Alignment);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1313</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1314</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeline">    return Changed;</td>
    <td class="lineNumber">1315</td>
    <td class="codeline">    return Changed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1316</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeline"></td>
    <td class="lineNumber">1317</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeline">  static LDSVariableReplacement createLDSVariableReplacement(</td>
    <td class="lineNumber">1318</td>
    <td class="codeline">  static LDSVariableReplacement createLDSVariableReplacement(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeline">      Module &M, std::string VarName,</td>
    <td class="lineNumber">1319</td>
    <td class="codeline">      Module &M, std::string VarName,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeline">      DenseSet<GlobalVariable *> const &LDSVarsToTransform) {</td>
    <td class="lineNumber">1320</td>
    <td class="codeline">      DenseSet<GlobalVariable *> const &LDSVarsToTransform) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeline">    // Create a struct instance containing LDSVarsToTransform and map from those</td>
    <td class="lineNumber">1321</td>
    <td class="codeline">    // Create a struct instance containing LDSVarsToTransform and map from those</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeline">    // variables to ConstantExprGEP</td>
    <td class="lineNumber">1322</td>
    <td class="codeline">    // variables to ConstantExprGEP</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeline">    // Variables may be introduced to meet alignment requirements. No aliasing</td>
    <td class="lineNumber">1323</td>
    <td class="codeline">    // Variables may be introduced to meet alignment requirements. No aliasing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeline">    // metadata is useful for these as they have no uses. Erased before return.</td>
    <td class="lineNumber">1324</td>
    <td class="codeline">    // metadata is useful for these as they have no uses. Erased before return.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeline"></td>
    <td class="lineNumber">1325</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeline">    LLVMContext &Ctx = M.getContext();</td>
    <td class="lineNumber">1326</td>
    <td class="codeline">    LLVMContext &Ctx = M.getContext();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeline">    const DataLayout &DL = M.getDataLayout();</td>
    <td class="lineNumber">1327</td>
    <td class="codeline">    const DataLayout &DL = M.getDataLayout();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeline">    assert(!LDSVarsToTransform.empty());</td>
    <td class="lineNumber">1328</td>
    <td class="codeline">    assert(!LDSVarsToTransform.empty());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeline"></td>
    <td class="lineNumber">1329</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeline">    SmallVector<OptimizedStructLayoutField, 8> LayoutFields;</td>
    <td class="lineNumber">1330</td>
    <td class="codeline">    SmallVector<OptimizedStructLayoutField, 8> LayoutFields;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeline">    LayoutFields.reserve(LDSVarsToTransform.size());</td>
    <td class="lineNumber">1331</td>
    <td class="codeline">    LayoutFields.reserve(LDSVarsToTransform.size());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeline">    {</td>
    <td class="lineNumber">1332</td>
    <td class="codeline">    {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeline">      // The order of fields in this struct depends on the order of</td>
    <td class="lineNumber">1333</td>
    <td class="codeline">      // The order of fields in this struct depends on the order of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeline">      // varables in the argument which varies when changing how they</td>
    <td class="lineNumber">1334</td>
    <td class="codeline">      // varables in the argument which varies when changing how they</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeline">      // are identified, leading to spurious test breakage.</td>
    <td class="lineNumber">1335</td>
    <td class="codeline">      // are identified, leading to spurious test breakage.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeline">      auto Sorted = sortByName(std::vector<GlobalVariable *>(</td>
    <td class="lineNumber">1336</td>
    <td class="codeline">      auto Sorted = sortByName(std::vector<GlobalVariable *>(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeline">          LDSVarsToTransform.begin(), LDSVarsToTransform.end()));</td>
    <td class="lineNumber">1337</td>
    <td class="codeline">          LDSVarsToTransform.begin(), LDSVarsToTransform.end()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeline"></td>
    <td class="lineNumber">1338</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeline">      for (GlobalVariable *GV : Sorted) {</td>
    <td class="lineNumber">1339</td>
    <td class="codeline">      for (GlobalVariable *GV : Sorted) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeline">        OptimizedStructLayoutField F(GV,</td>
    <td class="lineNumber">1340</td>
    <td class="codeline">        OptimizedStructLayoutField F(GV,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeline">                                     DL.getTypeAllocSize(GV->getValueType()),</td>
    <td class="lineNumber">1341</td>
    <td class="codeline">                                     DL.getTypeAllocSize(GV->getValueType()),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeline">                                     AMDGPU::getAlign(DL, GV));</td>
    <td class="lineNumber">1342</td>
    <td class="codeline">                                     AMDGPU::getAlign(DL, GV));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeline">        LayoutFields.emplace_back(F);</td>
    <td class="lineNumber">1343</td>
    <td class="codeline">        LayoutFields.emplace_back(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1344</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1345</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeline"></td>
    <td class="lineNumber">1346</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeline">    performOptimizedStructLayout(LayoutFields);</td>
    <td class="lineNumber">1347</td>
    <td class="codeline">    performOptimizedStructLayout(LayoutFields);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeline"></td>
    <td class="lineNumber">1348</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeline">    std::vector<GlobalVariable *> LocalVars;</td>
    <td class="lineNumber">1349</td>
    <td class="codeline">    std::vector<GlobalVariable *> LocalVars;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeline">    BitVector IsPaddingField;</td>
    <td class="lineNumber">1350</td>
    <td class="codeline">    BitVector IsPaddingField;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeline">    LocalVars.reserve(LDSVarsToTransform.size()); // will be at least this large</td>
    <td class="lineNumber">1351</td>
    <td class="codeline">    LocalVars.reserve(LDSVarsToTransform.size()); // will be at least this large</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeline">    IsPaddingField.reserve(LDSVarsToTransform.size());</td>
    <td class="lineNumber">1352</td>
    <td class="codeline">    IsPaddingField.reserve(LDSVarsToTransform.size());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeline">    {</td>
    <td class="lineNumber">1353</td>
    <td class="codeline">    {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeline">      uint64_t CurrentOffset = 0;</td>
    <td class="lineNumber">1354</td>
    <td class="codeline">      uint64_t CurrentOffset = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeline">      for (size_t I = 0; I < LayoutFields.size(); I++) {</td>
    <td class="lineNumber">1355</td>
    <td class="codeline">      for (size_t I = 0; I < LayoutFields.size(); I++) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeline">        GlobalVariable *FGV = static_cast<GlobalVariable *>(</td>
    <td class="lineNumber">1356</td>
    <td class="codeline">        GlobalVariable *FGV = static_cast<GlobalVariable *>(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeline">            const_cast<void *>(LayoutFields[I].Id));</td>
    <td class="lineNumber">1357</td>
    <td class="codeline">            const_cast<void *>(LayoutFields[I].Id));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeline">        Align DataAlign = LayoutFields[I].Alignment;</td>
    <td class="lineNumber">1358</td>
    <td class="codeline">        Align DataAlign = LayoutFields[I].Alignment;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeline"></td>
    <td class="lineNumber">1359</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeline">        uint64_t DataAlignV = DataAlign.value();</td>
    <td class="lineNumber">1360</td>
    <td class="codeline">        uint64_t DataAlignV = DataAlign.value();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeline">        if (uint64_t Rem = CurrentOffset % DataAlignV) {</td>
    <td class="lineNumber">1361</td>
    <td class="codeline">        if (uint64_t Rem = CurrentOffset % DataAlignV) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeline">          uint64_t Padding = DataAlignV - Rem;</td>
    <td class="lineNumber">1362</td>
    <td class="codeline">          uint64_t Padding = DataAlignV - Rem;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeline"></td>
    <td class="lineNumber">1363</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeline">          // Append an array of padding bytes to meet alignment requested</td>
    <td class="lineNumber">1364</td>
    <td class="codeline">          // Append an array of padding bytes to meet alignment requested</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeline">          // Note (o +      (a - (o % a)) ) % a == 0</td>
    <td class="lineNumber">1365</td>
    <td class="codeline">          // Note (o +      (a - (o % a)) ) % a == 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeline">          //      (offset + Padding       ) % align == 0</td>
    <td class="lineNumber">1366</td>
    <td class="codeline">          //      (offset + Padding       ) % align == 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeline"></td>
    <td class="lineNumber">1367</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeline">          Type *ATy = ArrayType::get(Type::getInt8Ty(Ctx), Padding);</td>
    <td class="lineNumber">1368</td>
    <td class="codeline">          Type *ATy = ArrayType::get(Type::getInt8Ty(Ctx), Padding);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeline">          LocalVars.push_back(new GlobalVariable(</td>
    <td class="lineNumber">1369</td>
    <td class="codeline">          LocalVars.push_back(new GlobalVariable(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeline">              M, ATy, false, GlobalValue::InternalLinkage, UndefValue::get(ATy),</td>
    <td class="lineNumber">1370</td>
    <td class="codeline">              M, ATy, false, GlobalValue::InternalLinkage, UndefValue::get(ATy),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeline">              "", nullptr, GlobalValue::NotThreadLocal, AMDGPUAS::LOCAL_ADDRESS,</td>
    <td class="lineNumber">1371</td>
    <td class="codeline">              "", nullptr, GlobalValue::NotThreadLocal, AMDGPUAS::LOCAL_ADDRESS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeline">              false));</td>
    <td class="lineNumber">1372</td>
    <td class="codeline">              false));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeline">          IsPaddingField.push_back(true);</td>
    <td class="lineNumber">1373</td>
    <td class="codeline">          IsPaddingField.push_back(true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeline">          CurrentOffset += Padding;</td>
    <td class="lineNumber">1374</td>
    <td class="codeline">          CurrentOffset += Padding;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1375</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeline"></td>
    <td class="lineNumber">1376</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeline">        LocalVars.push_back(FGV);</td>
    <td class="lineNumber">1377</td>
    <td class="codeline">        LocalVars.push_back(FGV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeline">        IsPaddingField.push_back(false);</td>
    <td class="lineNumber">1378</td>
    <td class="codeline">        IsPaddingField.push_back(false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeline">        CurrentOffset += LayoutFields[I].Size;</td>
    <td class="lineNumber">1379</td>
    <td class="codeline">        CurrentOffset += LayoutFields[I].Size;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1380</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1381</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeline"></td>
    <td class="lineNumber">1382</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeline">    std::vector<Type *> LocalVarTypes;</td>
    <td class="lineNumber">1383</td>
    <td class="codeline">    std::vector<Type *> LocalVarTypes;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeline">    LocalVarTypes.reserve(LocalVars.size());</td>
    <td class="lineNumber">1384</td>
    <td class="codeline">    LocalVarTypes.reserve(LocalVars.size());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeline">    std::transform(</td>
    <td class="lineNumber">1385</td>
    <td class="codeline">    std::transform(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeline">        LocalVars.cbegin(), LocalVars.cend(), std::back_inserter(LocalVarTypes),</td>
    <td class="lineNumber">1386</td>
    <td class="codeline">        LocalVars.cbegin(), LocalVars.cend(), std::back_inserter(LocalVarTypes),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeline">        [](const GlobalVariable *V) -> Type * { return V->getValueType(); });</td>
    <td class="lineNumber">1387</td>
    <td class="codeline">        [](const GlobalVariable *V) -> Type * { return V->getValueType(); });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeline"></td>
    <td class="lineNumber">1388</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeline">    StructType *LDSTy = StructType::create(Ctx, LocalVarTypes, VarName + ".t");</td>
    <td class="lineNumber">1389</td>
    <td class="codeline">    StructType *LDSTy = StructType::create(Ctx, LocalVarTypes, VarName + ".t");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeline"></td>
    <td class="lineNumber">1390</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeline">    Align StructAlign = AMDGPU::getAlign(DL, LocalVars[0]);</td>
    <td class="lineNumber">1391</td>
    <td class="codeline">    Align StructAlign = AMDGPU::getAlign(DL, LocalVars[0]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeline"></td>
    <td class="lineNumber">1392</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeline">    GlobalVariable *SGV = new GlobalVariable(</td>
    <td class="lineNumber">1393</td>
    <td class="codeline">    GlobalVariable *SGV = new GlobalVariable(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeline">        M, LDSTy, false, GlobalValue::InternalLinkage, UndefValue::get(LDSTy),</td>
    <td class="lineNumber">1394</td>
    <td class="codeline">        M, LDSTy, false, GlobalValue::InternalLinkage, UndefValue::get(LDSTy),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeline">        VarName, nullptr, GlobalValue::NotThreadLocal, AMDGPUAS::LOCAL_ADDRESS,</td>
    <td class="lineNumber">1395</td>
    <td class="codeline">        VarName, nullptr, GlobalValue::NotThreadLocal, AMDGPUAS::LOCAL_ADDRESS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeline">        false);</td>
    <td class="lineNumber">1396</td>
    <td class="codeline">        false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeline">    SGV->setAlignment(StructAlign);</td>
    <td class="lineNumber">1397</td>
    <td class="codeline">    SGV->setAlignment(StructAlign);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeline"></td>
    <td class="lineNumber">1398</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeline">    DenseMap<GlobalVariable *, Constant *> Map;</td>
    <td class="lineNumber">1399</td>
    <td class="codeline">    DenseMap<GlobalVariable *, Constant *> Map;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeline">    Type *I32 = Type::getInt32Ty(Ctx);</td>
    <td class="lineNumber">1400</td>
    <td class="codeline">    Type *I32 = Type::getInt32Ty(Ctx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeline">    for (size_t I = 0; I < LocalVars.size(); I++) {</td>
    <td class="lineNumber">1401</td>
    <td class="codeline">    for (size_t I = 0; I < LocalVars.size(); I++) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeline">      GlobalVariable *GV = LocalVars[I];</td>
    <td class="lineNumber">1402</td>
    <td class="codeline">      GlobalVariable *GV = LocalVars[I];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeline">      Constant *GEPIdx[] = {ConstantInt::get(I32, 0), ConstantInt::get(I32, I)};</td>
    <td class="lineNumber">1403</td>
    <td class="codeline">      Constant *GEPIdx[] = {ConstantInt::get(I32, 0), ConstantInt::get(I32, I)};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeline">      Constant *GEP = ConstantExpr::getGetElementPtr(LDSTy, SGV, GEPIdx, true);</td>
    <td class="lineNumber">1404</td>
    <td class="codeline">      Constant *GEP = ConstantExpr::getGetElementPtr(LDSTy, SGV, GEPIdx, true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeline">      if (IsPaddingField[I]) {</td>
    <td class="lineNumber">1405</td>
    <td class="codeline">      if (IsPaddingField[I]) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeline">        assert(GV->use_empty());</td>
    <td class="lineNumber">1406</td>
    <td class="codeline">        assert(GV->use_empty());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeline">        GV->eraseFromParent();</td>
    <td class="lineNumber">1407</td>
    <td class="codeline">        GV->eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">1408</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeline">        Map[GV] = GEP;</td>
    <td class="lineNumber">1409</td>
    <td class="codeline">        Map[GV] = GEP;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1410</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1411</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeline">    assert(Map.size() == LDSVarsToTransform.size());</td>
    <td class="lineNumber">1412</td>
    <td class="codeline">    assert(Map.size() == LDSVarsToTransform.size());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeline">    return {SGV, std::move(Map)};</td>
    <td class="lineNumber">1413</td>
    <td class="codeline">    return {SGV, std::move(Map)};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1414</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeline"></td>
    <td class="lineNumber">1415</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeline">  template <typename PredicateTy></td>
    <td class="lineNumber">1416</td>
    <td class="codeline">  template <typename PredicateTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeline">  static void replaceLDSVariablesWithStruct(</td>
    <td class="lineNumber">1417</td>
    <td class="codeline">  static void replaceLDSVariablesWithStruct(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeline">      Module &M, DenseSet<GlobalVariable *> const &LDSVarsToTransformArg,</td>
    <td class="lineNumber">1418</td>
    <td class="codeline">      Module &M, DenseSet<GlobalVariable *> const &LDSVarsToTransformArg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeline">      const LDSVariableReplacement &Replacement, PredicateTy Predicate) {</td>
    <td class="lineNumber">1419</td>
    <td class="codeline">      const LDSVariableReplacement &Replacement, PredicateTy Predicate) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeline">    LLVMContext &Ctx = M.getContext();</td>
    <td class="lineNumber">1420</td>
    <td class="codeline">    LLVMContext &Ctx = M.getContext();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeline">    const DataLayout &DL = M.getDataLayout();</td>
    <td class="lineNumber">1421</td>
    <td class="codeline">    const DataLayout &DL = M.getDataLayout();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeline"></td>
    <td class="lineNumber">1422</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeline">    // A hack... we need to insert the aliasing info in a predictable order for</td>
    <td class="lineNumber">1423</td>
    <td class="codeline">    // A hack... we need to insert the aliasing info in a predictable order for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeline">    // lit tests. Would like to have them in a stable order already, ideally the</td>
    <td class="lineNumber">1424</td>
    <td class="codeline">    // lit tests. Would like to have them in a stable order already, ideally the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeline">    // same order they get allocated, which might mean an ordered set container</td>
    <td class="lineNumber">1425</td>
    <td class="codeline">    // same order they get allocated, which might mean an ordered set container</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeline">    auto LDSVarsToTransform = sortByName(std::vector<GlobalVariable *>(</td>
    <td class="lineNumber">1426</td>
    <td class="codeline">    auto LDSVarsToTransform = sortByName(std::vector<GlobalVariable *>(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeline">        LDSVarsToTransformArg.begin(), LDSVarsToTransformArg.end()));</td>
    <td class="lineNumber">1427</td>
    <td class="codeline">        LDSVarsToTransformArg.begin(), LDSVarsToTransformArg.end()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeline"></td>
    <td class="lineNumber">1428</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeline">    // Create alias.scope and their lists. Each field in the new structure</td>
    <td class="lineNumber">1429</td>
    <td class="codeline">    // Create alias.scope and their lists. Each field in the new structure</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeline">    // does not alias with all other fields.</td>
    <td class="lineNumber">1430</td>
    <td class="codeline">    // does not alias with all other fields.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeline">    SmallVector<MDNode *> AliasScopes;</td>
    <td class="lineNumber">1431</td>
    <td class="codeline">    SmallVector<MDNode *> AliasScopes;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeline">    SmallVector<Metadata *> NoAliasList;</td>
    <td class="lineNumber">1432</td>
    <td class="codeline">    SmallVector<Metadata *> NoAliasList;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeline">    const size_t NumberVars = LDSVarsToTransform.size();</td>
    <td class="lineNumber">1433</td>
    <td class="codeline">    const size_t NumberVars = LDSVarsToTransform.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeline">    if (NumberVars > 1) {</td>
    <td class="lineNumber">1434</td>
    <td class="codeline">    if (NumberVars > 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeline">      MDBuilder MDB(Ctx);</td>
    <td class="lineNumber">1435</td>
    <td class="codeline">      MDBuilder MDB(Ctx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeline">      AliasScopes.reserve(NumberVars);</td>
    <td class="lineNumber">1436</td>
    <td class="codeline">      AliasScopes.reserve(NumberVars);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeline">      MDNode *Domain = MDB.createAnonymousAliasScopeDomain();</td>
    <td class="lineNumber">1437</td>
    <td class="codeline">      MDNode *Domain = MDB.createAnonymousAliasScopeDomain();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeline">      for (size_t I = 0; I < NumberVars; I++) {</td>
    <td class="lineNumber">1438</td>
    <td class="codeline">      for (size_t I = 0; I < NumberVars; I++) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeline">        MDNode *Scope = MDB.createAnonymousAliasScope(Domain);</td>
    <td class="lineNumber">1439</td>
    <td class="codeline">        MDNode *Scope = MDB.createAnonymousAliasScope(Domain);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeline">        AliasScopes.push_back(Scope);</td>
    <td class="lineNumber">1440</td>
    <td class="codeline">        AliasScopes.push_back(Scope);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1441</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeline">      NoAliasList.append(&AliasScopes[1], AliasScopes.end());</td>
    <td class="lineNumber">1442</td>
    <td class="codeline">      NoAliasList.append(&AliasScopes[1], AliasScopes.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1443</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeline"></td>
    <td class="lineNumber">1444</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeline">    // Replace uses of ith variable with a constantexpr to the corresponding</td>
    <td class="lineNumber">1445</td>
    <td class="codeline">    // Replace uses of ith variable with a constantexpr to the corresponding</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeline">    // field of the instance that will be allocated by AMDGPUMachineFunction</td>
    <td class="lineNumber">1446</td>
    <td class="codeline">    // field of the instance that will be allocated by AMDGPUMachineFunction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeline">    for (size_t I = 0; I < NumberVars; I++) {</td>
    <td class="lineNumber">1447</td>
    <td class="codeline">    for (size_t I = 0; I < NumberVars; I++) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeline">      GlobalVariable *GV = LDSVarsToTransform[I];</td>
    <td class="lineNumber">1448</td>
    <td class="codeline">      GlobalVariable *GV = LDSVarsToTransform[I];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeline">      Constant *GEP = Replacement.LDSVarsToConstantGEP.at(GV);</td>
    <td class="lineNumber">1449</td>
    <td class="codeline">      Constant *GEP = Replacement.LDSVarsToConstantGEP.at(GV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeline"></td>
    <td class="lineNumber">1450</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeline">      GV->replaceUsesWithIf(GEP, Predicate);</td>
    <td class="lineNumber">1451</td>
    <td class="codeline">      GV->replaceUsesWithIf(GEP, Predicate);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeline"></td>
    <td class="lineNumber">1452</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeline">      APInt APOff(DL.getIndexTypeSizeInBits(GEP->getType()), 0);</td>
    <td class="lineNumber">1453</td>
    <td class="codeline">      APInt APOff(DL.getIndexTypeSizeInBits(GEP->getType()), 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeline">      GEP->stripAndAccumulateInBoundsConstantOffsets(DL, APOff);</td>
    <td class="lineNumber">1454</td>
    <td class="codeline">      GEP->stripAndAccumulateInBoundsConstantOffsets(DL, APOff);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeline">      uint64_t Offset = APOff.getZExtValue();</td>
    <td class="lineNumber">1455</td>
    <td class="codeline">      uint64_t Offset = APOff.getZExtValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeline"></td>
    <td class="lineNumber">1456</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeline">      Align A =</td>
    <td class="lineNumber">1457</td>
    <td class="codeline">      Align A =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeline">          commonAlignment(Replacement.SGV->getAlign().valueOrOne(), Offset);</td>
    <td class="lineNumber">1458</td>
    <td class="codeline">          commonAlignment(Replacement.SGV->getAlign().valueOrOne(), Offset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeline"></td>
    <td class="lineNumber">1459</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeline">      if (I)</td>
    <td class="lineNumber">1460</td>
    <td class="codeline">      if (I)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeline">        NoAliasList[I - 1] = AliasScopes[I - 1];</td>
    <td class="lineNumber">1461</td>
    <td class="codeline">        NoAliasList[I - 1] = AliasScopes[I - 1];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeline">      MDNode *NoAlias =</td>
    <td class="lineNumber">1462</td>
    <td class="codeline">      MDNode *NoAlias =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeline">          NoAliasList.empty() ? nullptr : MDNode::get(Ctx, NoAliasList);</td>
    <td class="lineNumber">1463</td>
    <td class="codeline">          NoAliasList.empty() ? nullptr : MDNode::get(Ctx, NoAliasList);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeline">      MDNode *AliasScope =</td>
    <td class="lineNumber">1464</td>
    <td class="codeline">      MDNode *AliasScope =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeline">          AliasScopes.empty() ? nullptr : MDNode::get(Ctx, {AliasScopes[I]});</td>
    <td class="lineNumber">1465</td>
    <td class="codeline">          AliasScopes.empty() ? nullptr : MDNode::get(Ctx, {AliasScopes[I]});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeline"></td>
    <td class="lineNumber">1466</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeline">      refineUsesAlignmentAndAA(GEP, A, DL, AliasScope, NoAlias);</td>
    <td class="lineNumber">1467</td>
    <td class="codeline">      refineUsesAlignmentAndAA(GEP, A, DL, AliasScope, NoAlias);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1468</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1469</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeline"></td>
    <td class="lineNumber">1470</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeline">  static void refineUsesAlignmentAndAA(Value *Ptr, Align A,</td>
    <td class="lineNumber">1471</td>
    <td class="codeline">  static void refineUsesAlignmentAndAA(Value *Ptr, Align A,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeline">                                       const DataLayout &DL, MDNode *AliasScope,</td>
    <td class="lineNumber">1472</td>
    <td class="codeline">                                       const DataLayout &DL, MDNode *AliasScope,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeline">                                       MDNode *NoAlias, unsigned MaxDepth = 5) {</td>
    <td class="lineNumber">1473</td>
    <td class="codeline">                                       MDNode *NoAlias, unsigned MaxDepth = 5) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeline">    if (!MaxDepth || (A == 1 && !AliasScope))</td>
    <td class="lineNumber">1474</td>
    <td class="codeline">    if (!MaxDepth || (A == 1 && !AliasScope))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">1475</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeline"></td>
    <td class="lineNumber">1476</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeline">    for (User *U : Ptr->users()) {</td>
    <td class="lineNumber">1477</td>
    <td class="codeline">    for (User *U : Ptr->users()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeline">      if (auto *I = dyn_cast<Instruction>(U)) {</td>
    <td class="lineNumber">1478</td>
    <td class="codeline">      if (auto *I = dyn_cast<Instruction>(U)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeline">        if (AliasScope && I->mayReadOrWriteMemory()) {</td>
    <td class="lineNumber">1479</td>
    <td class="codeline">        if (AliasScope && I->mayReadOrWriteMemory()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeline">          MDNode *AS = I->getMetadata(LLVMContext::MD_alias_scope);</td>
    <td class="lineNumber">1480</td>
    <td class="codeline">          MDNode *AS = I->getMetadata(LLVMContext::MD_alias_scope);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeline">          AS = (AS ? MDNode::getMostGenericAliasScope(AS, AliasScope)</td>
    <td class="lineNumber">1481</td>
    <td class="codeline">          AS = (AS ? MDNode::getMostGenericAliasScope(AS, AliasScope)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeline">                   : AliasScope);</td>
    <td class="lineNumber">1482</td>
    <td class="codeline">                   : AliasScope);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeline">          I->setMetadata(LLVMContext::MD_alias_scope, AS);</td>
    <td class="lineNumber">1483</td>
    <td class="codeline">          I->setMetadata(LLVMContext::MD_alias_scope, AS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeline"></td>
    <td class="lineNumber">1484</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeline">          MDNode *NA = I->getMetadata(LLVMContext::MD_noalias);</td>
    <td class="lineNumber">1485</td>
    <td class="codeline">          MDNode *NA = I->getMetadata(LLVMContext::MD_noalias);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeline">          NA = (NA ? MDNode::intersect(NA, NoAlias) : NoAlias);</td>
    <td class="lineNumber">1486</td>
    <td class="codeline">          NA = (NA ? MDNode::intersect(NA, NoAlias) : NoAlias);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeline">          I->setMetadata(LLVMContext::MD_noalias, NA);</td>
    <td class="lineNumber">1487</td>
    <td class="codeline">          I->setMetadata(LLVMContext::MD_noalias, NA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1488</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1489</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeline"></td>
    <td class="lineNumber">1490</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeline">      if (auto *LI = dyn_cast<LoadInst>(U)) {</td>
    <td class="lineNumber">1491</td>
    <td class="codeline">      if (auto *LI = dyn_cast<LoadInst>(U)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeline">        LI->setAlignment(std::max(A, LI->getAlign()));</td>
    <td class="lineNumber">1492</td>
    <td class="codeline">        LI->setAlignment(std::max(A, LI->getAlign()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1493</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1494</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeline">      if (auto *SI = dyn_cast<StoreInst>(U)) {</td>
    <td class="lineNumber">1495</td>
    <td class="codeline">      if (auto *SI = dyn_cast<StoreInst>(U)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeline">        if (SI->getPointerOperand() == Ptr)</td>
    <td class="lineNumber">1496</td>
    <td class="codeline">        if (SI->getPointerOperand() == Ptr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeline">          SI->setAlignment(std::max(A, SI->getAlign()));</td>
    <td class="lineNumber">1497</td>
    <td class="codeline">          SI->setAlignment(std::max(A, SI->getAlign()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1498</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1499</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeline">      if (auto *AI = dyn_cast<AtomicRMWInst>(U)) {</td>
    <td class="lineNumber">1500</td>
    <td class="codeline">      if (auto *AI = dyn_cast<AtomicRMWInst>(U)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeline">        // None of atomicrmw operations can work on pointers, but let's</td>
    <td class="lineNumber">1501</td>
    <td class="codeline">        // None of atomicrmw operations can work on pointers, but let's</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeline">        // check it anyway in case it will or we will process ConstantExpr.</td>
    <td class="lineNumber">1502</td>
    <td class="codeline">        // check it anyway in case it will or we will process ConstantExpr.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeline">        if (AI->getPointerOperand() == Ptr)</td>
    <td class="lineNumber">1503</td>
    <td class="codeline">        if (AI->getPointerOperand() == Ptr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeline">          AI->setAlignment(std::max(A, AI->getAlign()));</td>
    <td class="lineNumber">1504</td>
    <td class="codeline">          AI->setAlignment(std::max(A, AI->getAlign()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1505</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1506</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeline">      if (auto *AI = dyn_cast<AtomicCmpXchgInst>(U)) {</td>
    <td class="lineNumber">1507</td>
    <td class="codeline">      if (auto *AI = dyn_cast<AtomicCmpXchgInst>(U)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeline">        if (AI->getPointerOperand() == Ptr)</td>
    <td class="lineNumber">1508</td>
    <td class="codeline">        if (AI->getPointerOperand() == Ptr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeline">          AI->setAlignment(std::max(A, AI->getAlign()));</td>
    <td class="lineNumber">1509</td>
    <td class="codeline">          AI->setAlignment(std::max(A, AI->getAlign()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1510</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1511</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeline">      if (auto *GEP = dyn_cast<GetElementPtrInst>(U)) {</td>
    <td class="lineNumber">1512</td>
    <td class="codeline">      if (auto *GEP = dyn_cast<GetElementPtrInst>(U)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeline">        unsigned BitWidth = DL.getIndexTypeSizeInBits(GEP->getType());</td>
    <td class="lineNumber">1513</td>
    <td class="codeline">        unsigned BitWidth = DL.getIndexTypeSizeInBits(GEP->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeline">        APInt Off(BitWidth, 0);</td>
    <td class="lineNumber">1514</td>
    <td class="codeline">        APInt Off(BitWidth, 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeline">        if (GEP->getPointerOperand() == Ptr) {</td>
    <td class="lineNumber">1515</td>
    <td class="codeline">        if (GEP->getPointerOperand() == Ptr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeline">          Align GA;</td>
    <td class="lineNumber">1516</td>
    <td class="codeline">          Align GA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeline">          if (GEP->accumulateConstantOffset(DL, Off))</td>
    <td class="lineNumber">1517</td>
    <td class="codeline">          if (GEP->accumulateConstantOffset(DL, Off))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeline">            GA = commonAlignment(A, Off.getLimitedValue());</td>
    <td class="lineNumber">1518</td>
    <td class="codeline">            GA = commonAlignment(A, Off.getLimitedValue());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeline">          refineUsesAlignmentAndAA(GEP, GA, DL, AliasScope, NoAlias,</td>
    <td class="lineNumber">1519</td>
    <td class="codeline">          refineUsesAlignmentAndAA(GEP, GA, DL, AliasScope, NoAlias,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeline">                                   MaxDepth - 1);</td>
    <td class="lineNumber">1520</td>
    <td class="codeline">                                   MaxDepth - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1521</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1522</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1523</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeline">      if (auto *I = dyn_cast<Instruction>(U)) {</td>
    <td class="lineNumber">1524</td>
    <td class="codeline">      if (auto *I = dyn_cast<Instruction>(U)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeline">        if (I->getOpcode() == Instruction::BitCast ||</td>
    <td class="lineNumber">1525</td>
    <td class="codeline">        if (I->getOpcode() == Instruction::BitCast ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeline">            I->getOpcode() == Instruction::AddrSpaceCast)</td>
    <td class="lineNumber">1526</td>
    <td class="codeline">            I->getOpcode() == Instruction::AddrSpaceCast)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeline">          refineUsesAlignmentAndAA(I, A, DL, AliasScope, NoAlias, MaxDepth - 1);</td>
    <td class="lineNumber">1527</td>
    <td class="codeline">          refineUsesAlignmentAndAA(I, A, DL, AliasScope, NoAlias, MaxDepth - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1528</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1529</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1530</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1531</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeline"></td>
    <td class="lineNumber">1532</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeline">} // namespace</td>
    <td class="lineNumber">1533</td>
    <td class="codeline">} // namespace</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeline">char AMDGPULowerModuleLDS::ID = 0;</td>
    <td class="lineNumber">1534</td>
    <td class="codeline">char AMDGPULowerModuleLDS::ID = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeline"></td>
    <td class="lineNumber">1535</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeline">char &llvm::AMDGPULowerModuleLDSID = AMDGPULowerModuleLDS::ID;</td>
    <td class="lineNumber">1536</td>
    <td class="codeline">char &llvm::AMDGPULowerModuleLDSID = AMDGPULowerModuleLDS::ID;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeline"></td>
    <td class="lineNumber">1537</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeline">INITIALIZE_PASS(AMDGPULowerModuleLDS, DEBUG_TYPE,</td>
    <td class="lineNumber">1538</td>
    <td class="codeline">INITIALIZE_PASS(AMDGPULowerModuleLDS, DEBUG_TYPE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeline">                "Lower uses of LDS variables from non-kernel functions", false,</td>
    <td class="lineNumber">1539</td>
    <td class="codeline">                "Lower uses of LDS variables from non-kernel functions", false,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeline">                false)</td>
    <td class="lineNumber">1540</td>
    <td class="codeline">                false)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeline"></td>
    <td class="lineNumber">1541</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeline">ModulePass *llvm::createAMDGPULowerModuleLDSPass() {</td>
    <td class="lineNumber">1542</td>
    <td class="codeline">ModulePass *llvm::createAMDGPULowerModuleLDSPass() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeline">  return new AMDGPULowerModuleLDS();</td>
    <td class="lineNumber">1543</td>
    <td class="codeline">  return new AMDGPULowerModuleLDS();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1544</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeline"></td>
    <td class="lineNumber">1545</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeline">PreservedAnalyses AMDGPULowerModuleLDSPass::run(Module &M,</td>
    <td class="lineNumber">1546</td>
    <td class="codeline">PreservedAnalyses AMDGPULowerModuleLDSPass::run(Module &M,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeline">                                                ModuleAnalysisManager &) {</td>
    <td class="lineNumber">1547</td>
    <td class="codeline">                                                ModuleAnalysisManager &) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeline">  return AMDGPULowerModuleLDS().runOnModule(M) ? PreservedAnalyses::none()</td>
    <td class="lineNumber">1548</td>
    <td class="codeline">  return AMDGPULowerModuleLDS().runOnModule(M) ? PreservedAnalyses::none()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeline">                                               : PreservedAnalyses::all();</td>
    <td class="lineNumber">1549</td>
    <td class="codeline">                                               : PreservedAnalyses::all();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1550</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeline"></td>
    <td class="lineNumber">1551</td>
    <td class="codeline"></td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Side By Side Comparison</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Side By Side Comparison</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeLine">//===-- AMDGPULowerModuleLDSPass.cpp ------------------------------*- C++ -*-=//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1</td>
    <td class="codeLine">//===-- AMDGPULowerModuleLDSPass.cpp ------------------------------*- C++ -*-=//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeLine">// This pass eliminates local data store, LDS, uses from non-kernel functions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">9</td>
    <td class="codeLine">// This pass eliminates local data store, LDS, uses from non-kernel functions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeLine">// LDS is contiguous memory allocated per kernel execution.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">10</td>
    <td class="codeLine">// LDS is contiguous memory allocated per kernel execution.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">11</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeLine">// Background.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">12</td>
    <td class="codeLine">// Background.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">13</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeLine">// The programming model is global variables, or equivalently function local</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">14</td>
    <td class="codeLine">// The programming model is global variables, or equivalently function local</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeLine">// static variables, accessible from kernels or other functions. For uses from</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">15</td>
    <td class="codeLine">// static variables, accessible from kernels or other functions. For uses from</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeLine">// kernels this is straightforward - assign an integer to the kernel for the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">16</td>
    <td class="codeLine">// kernels this is straightforward - assign an integer to the kernel for the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeLine">// memory required by all the variables combined, allocate them within that.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">17</td>
    <td class="codeLine">// memory required by all the variables combined, allocate them within that.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeLine">// For uses from functions there are performance tradeoffs to choose between.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">18</td>
    <td class="codeLine">// For uses from functions there are performance tradeoffs to choose between.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">19</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeLine">// This model means the GPU runtime can specify the amount of memory allocated.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">20</td>
    <td class="codeLine">// This model means the GPU runtime can specify the amount of memory allocated.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeLine">// If this is more than the kernel assumed, the excess can be made available</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">21</td>
    <td class="codeLine">// If this is more than the kernel assumed, the excess can be made available</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeLine">// using a language specific feature, which IR represents as a variable with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">22</td>
    <td class="codeLine">// using a language specific feature, which IR represents as a variable with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeLine">// no initializer. This feature is referred to here as "Dynamic LDS" and is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">23</td>
    <td class="codeLine">// no initializer. This feature is referred to here as "Dynamic LDS" and is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeLine">// lowered slightly differently to the normal case.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">24</td>
    <td class="codeLine">// lowered slightly differently to the normal case.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">25</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeLine">// Consequences of this GPU feature:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">26</td>
    <td class="codeLine">// Consequences of this GPU feature:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeLine">// - memory is limited and exceeding it halts compilation</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">27</td>
    <td class="codeLine">// - memory is limited and exceeding it halts compilation</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeLine">// - a global accessed by one kernel exists independent of other kernels</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">28</td>
    <td class="codeLine">// - a global accessed by one kernel exists independent of other kernels</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeLine">// - a global exists independent of simultaneous execution of the same kernel</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">29</td>
    <td class="codeLine">// - a global exists independent of simultaneous execution of the same kernel</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeLine">// - the address of the global may be different from different kernels as they</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">30</td>
    <td class="codeLine">// - the address of the global may be different from different kernels as they</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeLine">//   do not alias, which permits only allocating variables they use</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">31</td>
    <td class="codeLine">//   do not alias, which permits only allocating variables they use</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeLine">// - if the address is allowed to differ, functions need help to find it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">32</td>
    <td class="codeLine">// - if the address is allowed to differ, functions need help to find it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">33</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeLine">// Uses from kernels are implemented here by grouping them in a per-kernel</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">34</td>
    <td class="codeLine">// Uses from kernels are implemented here by grouping them in a per-kernel</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeLine">// struct instance. This duplicates the variables, accurately modelling their</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">35</td>
    <td class="codeLine">// struct instance. This duplicates the variables, accurately modelling their</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeLine">// aliasing properties relative to a single global representation. It also</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">36</td>
    <td class="codeLine">// aliasing properties relative to a single global representation. It also</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeLine">// permits control over alignment via padding.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">37</td>
    <td class="codeLine">// permits control over alignment via padding.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">38</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeLine">// Uses from functions are more complicated and the primary purpose of this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">39</td>
    <td class="codeLine">// Uses from functions are more complicated and the primary purpose of this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeLine">// IR pass. Several different lowering are chosen between to meet requirements</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">40</td>
    <td class="codeLine">// IR pass. Several different lowering are chosen between to meet requirements</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeLine">// to avoid allocating any LDS where it is not necessary, as that impacts</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">41</td>
    <td class="codeLine">// to avoid allocating any LDS where it is not necessary, as that impacts</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeLine">// occupancy and may fail the compilation, while not imposing overhead on a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">42</td>
    <td class="codeLine">// occupancy and may fail the compilation, while not imposing overhead on a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeLine">// feature whose primary advantage over global memory is performance. The basic</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">43</td>
    <td class="codeLine">// feature whose primary advantage over global memory is performance. The basic</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeLine">// design goal is to avoid one kernel imposing overhead on another.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">44</td>
    <td class="codeLine">// design goal is to avoid one kernel imposing overhead on another.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">45</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeLine">// Implementation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">46</td>
    <td class="codeLine">// Implementation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">47</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeLine">// LDS variables with constant annotation or non-undef initializer are passed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">48</td>
    <td class="codeLine">// LDS variables with constant annotation or non-undef initializer are passed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeLine">// through unchanged for simplification or error diagnostics in later passes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">49</td>
    <td class="codeLine">// through unchanged for simplification or error diagnostics in later passes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeLine">// Non-undef initializers are not yet implemented for LDS.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">50</td>
    <td class="codeLine">// Non-undef initializers are not yet implemented for LDS.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">51</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeLine">// LDS variables that are always allocated at the same address can be found</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">52</td>
    <td class="codeLine">// LDS variables that are always allocated at the same address can be found</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeLine">// by lookup at that address. Otherwise runtime information/cost is required.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">53</td>
    <td class="codeLine">// by lookup at that address. Otherwise runtime information/cost is required.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">54</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeLine">// The simplest strategy possible is to group all LDS variables in a single</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">55</td>
    <td class="codeLine">// The simplest strategy possible is to group all LDS variables in a single</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeLine">// struct and allocate that struct in every kernel such that the original</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">56</td>
    <td class="codeLine">// struct and allocate that struct in every kernel such that the original</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeLine">// variables are always at the same address. LDS is however a limited resource</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">57</td>
    <td class="codeLine">// variables are always at the same address. LDS is however a limited resource</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeLine">// so this strategy is unusable in practice. It is not implemented here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">58</td>
    <td class="codeLine">// so this strategy is unusable in practice. It is not implemented here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">59</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeLine">// Strategy | Precise allocation | Zero runtime cost | General purpose |</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">60</td>
    <td class="codeLine">// Strategy | Precise allocation | Zero runtime cost | General purpose |</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeLine">//  --------+--------------------+-------------------+-----------------+</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">61</td>
    <td class="codeLine">//  --------+--------------------+-------------------+-----------------+</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeLine">//   Module |                 No |               Yes |             Yes |</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">62</td>
    <td class="codeLine">//   Module |                 No |               Yes |             Yes |</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeLine">//    Table |                Yes |                No |             Yes |</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">63</td>
    <td class="codeLine">//    Table |                Yes |                No |             Yes |</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeLine">//   Kernel |                Yes |               Yes |              No |</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">64</td>
    <td class="codeLine">//   Kernel |                Yes |               Yes |              No |</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeLine">//   Hybrid |                Yes |           Partial |             Yes |</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">65</td>
    <td class="codeLine">//   Hybrid |                Yes |           Partial |             Yes |</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">66</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeLine">// "Module" spends LDS memory to save cycles. "Table" spends cycles and global</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">67</td>
    <td class="codeLine">// "Module" spends LDS memory to save cycles. "Table" spends cycles and global</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeLine">// memory to save LDS. "Kernel" is as fast as kernel allocation but only works</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">68</td>
    <td class="codeLine">// memory to save LDS. "Kernel" is as fast as kernel allocation but only works</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeLine">// for variables that are known reachable from a single kernel. "Hybrid" picks</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">69</td>
    <td class="codeLine">// for variables that are known reachable from a single kernel. "Hybrid" picks</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeLine">// between all three. When forced to choose between LDS and cycles we minimise</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">70</td>
    <td class="codeLine">// between all three. When forced to choose between LDS and cycles we minimise</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeLine">// LDS use.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">71</td>
    <td class="codeLine">// LDS use.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">72</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeLine">// The "module" lowering implemented here finds LDS variables which are used by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">73</td>
    <td class="codeLine">// The "module" lowering implemented here finds LDS variables which are used by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeLine">// non-kernel functions and creates a new struct with a field for each of those</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">74</td>
    <td class="codeLine">// non-kernel functions and creates a new struct with a field for each of those</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeLine">// LDS variables. Variables that are only used from kernels are excluded.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">75</td>
    <td class="codeLine">// LDS variables. Variables that are only used from kernels are excluded.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">76</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeLine">// The "table" lowering implemented here has three components.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">77</td>
    <td class="codeLine">// The "table" lowering implemented here has three components.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeLine">// First kernels are assigned a unique integer identifier which is available in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">78</td>
    <td class="codeLine">// First kernels are assigned a unique integer identifier which is available in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeLine">// functions it calls through the intrinsic amdgcn_lds_kernel_id. The integer</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">79</td>
    <td class="codeLine">// functions it calls through the intrinsic amdgcn_lds_kernel_id. The integer</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeLine">// is passed through a specific SGPR, thus works with indirect calls.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">80</td>
    <td class="codeLine">// is passed through a specific SGPR, thus works with indirect calls.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeLine">// Second, each kernel allocates LDS variables independent of other kernels and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">81</td>
    <td class="codeLine">// Second, each kernel allocates LDS variables independent of other kernels and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeLine">// writes the addresses it chose for each variable into an array in consistent</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">82</td>
    <td class="codeLine">// writes the addresses it chose for each variable into an array in consistent</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeLine">// order. If the kernel does not allocate a given variable, it writes undef to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">83</td>
    <td class="codeLine">// order. If the kernel does not allocate a given variable, it writes undef to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeLine">// the corresponding array location. These arrays are written to a constant</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">84</td>
    <td class="codeLine">// the corresponding array location. These arrays are written to a constant</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeLine">// table in the order matching the kernel unique integer identifier.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">85</td>
    <td class="codeLine">// table in the order matching the kernel unique integer identifier.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeLine">// Third, uses from non-kernel functions are replaced with a table lookup using</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">86</td>
    <td class="codeLine">// Third, uses from non-kernel functions are replaced with a table lookup using</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeLine">// the intrinsic function to find the address of the variable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">87</td>
    <td class="codeLine">// the intrinsic function to find the address of the variable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">88</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeLine">// "Kernel" lowering is only applicable for variables that are unambiguously</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">89</td>
    <td class="codeLine">// "Kernel" lowering is only applicable for variables that are unambiguously</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeLine">// reachable from exactly one kernel. For those cases, accesses to the variable</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">90</td>
    <td class="codeLine">// reachable from exactly one kernel. For those cases, accesses to the variable</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeLine">// can be lowered to ConstantExpr address of a struct instance specific to that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">91</td>
    <td class="codeLine">// can be lowered to ConstantExpr address of a struct instance specific to that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeLine">// one kernel. This is zero cost in space and in compute. It will raise a fatal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">92</td>
    <td class="codeLine">// one kernel. This is zero cost in space and in compute. It will raise a fatal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeLine">// error on any variable that might be reachable from multiple kernels and is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">93</td>
    <td class="codeLine">// error on any variable that might be reachable from multiple kernels and is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeLine">// thus most easily used as part of the hybrid lowering strategy.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">94</td>
    <td class="codeLine">// thus most easily used as part of the hybrid lowering strategy.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">95</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeLine">// Hybrid lowering is a mixture of the above. It uses the zero cost kernel</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">96</td>
    <td class="codeLine">// Hybrid lowering is a mixture of the above. It uses the zero cost kernel</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeLine">// lowering where it can. It lowers the variable accessed by the greatest</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">97</td>
    <td class="codeLine">// lowering where it can. It lowers the variable accessed by the greatest</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeLine">// number of kernels using the module strategy as that is free for the first</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">98</td>
    <td class="codeLine">// number of kernels using the module strategy as that is free for the first</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeLine">// variable. Any futher variables that can be lowered with the module strategy</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">99</td>
    <td class="codeLine">// variable. Any futher variables that can be lowered with the module strategy</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeLine">// without incurring LDS memory overhead are. The remaining ones are lowered</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">100</td>
    <td class="codeLine">// without incurring LDS memory overhead are. The remaining ones are lowered</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeLine">// via table.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">101</td>
    <td class="codeLine">// via table.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">102</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeLine">// Consequences</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">103</td>
    <td class="codeLine">// Consequences</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeLine">// - No heuristics or user controlled magic numbers, hybrid is the right choice</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">104</td>
    <td class="codeLine">// - No heuristics or user controlled magic numbers, hybrid is the right choice</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeLine">// - Kernels that don't use functions (or have had them all inlined) are not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">105</td>
    <td class="codeLine">// - Kernels that don't use functions (or have had them all inlined) are not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeLine">//   affected by any lowering for kernels that do.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">106</td>
    <td class="codeLine">//   affected by any lowering for kernels that do.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeLine">// - Kernels that don't make indirect function calls are not affected by those</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">107</td>
    <td class="codeLine">// - Kernels that don't make indirect function calls are not affected by those</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeLine">//   that do.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">108</td>
    <td class="codeLine">//   that do.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeLine">// - Variables which are used by lots of kernels, e.g. those injected by a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">109</td>
    <td class="codeLine">// - Variables which are used by lots of kernels, e.g. those injected by a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeLine">//   language runtime in most kernels, are expected to have no overhead</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">110</td>
    <td class="codeLine">//   language runtime in most kernels, are expected to have no overhead</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeLine">// - Implementations that instantiate templates per-kernel where those templates</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">111</td>
    <td class="codeLine">// - Implementations that instantiate templates per-kernel where those templates</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeLine">//   use LDS are expected to hit the "Kernel" lowering strategy</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">112</td>
    <td class="codeLine">//   use LDS are expected to hit the "Kernel" lowering strategy</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeLine">// - The runtime properties impose a cost in compiler implementation complexity</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">113</td>
    <td class="codeLine">// - The runtime properties impose a cost in compiler implementation complexity</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">114</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeLine">// Dynamic LDS implementation</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">115</td>
    <td class="codeLine">// Dynamic LDS implementation</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeLine">// Dynamic LDS is lowered similarly to the "table" strategy above and uses the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">116</td>
    <td class="codeLine">// Dynamic LDS is lowered similarly to the "table" strategy above and uses the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeLine">// same intrinsic to identify which kernel is at the root of the dynamic call</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">117</td>
    <td class="codeLine">// same intrinsic to identify which kernel is at the root of the dynamic call</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeLine">// graph. This relies on the specified behaviour that all dynamic LDS variables</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">118</td>
    <td class="codeLine">// graph. This relies on the specified behaviour that all dynamic LDS variables</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeLine">// alias one another, i.e. are at the same address, with respect to a given</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">119</td>
    <td class="codeLine">// alias one another, i.e. are at the same address, with respect to a given</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeLine">// kernel. Therefore this pass creates new dynamic LDS variables for each kernel</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">120</td>
    <td class="codeLine">// kernel. Therefore this pass creates new dynamic LDS variables for each kernel</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeLine">// that allocates any dynamic LDS and builds a table of addresses out of those.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">121</td>
    <td class="codeLine">// that allocates any dynamic LDS and builds a table of addresses out of those.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeLine">// The AMDGPUPromoteAlloca pass skips kernels that use dynamic LDS.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">122</td>
    <td class="codeLine">// The AMDGPUPromoteAlloca pass skips kernels that use dynamic LDS.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeLine">// The corresponding optimisation for "kernel" lowering where the table lookup</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">123</td>
    <td class="codeLine">// The corresponding optimisation for "kernel" lowering where the table lookup</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeLine">// is elided is not implemented.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">124</td>
    <td class="codeLine">// is elided is not implemented.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">125</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">126</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeLine">// Implementation notes / limitations</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">127</td>
    <td class="codeLine">// Implementation notes / limitations</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeLine">// A single LDS global variable represents an instance per kernel that can reach</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">128</td>
    <td class="codeLine">// A single LDS global variable represents an instance per kernel that can reach</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeLine">// said variables. This pass essentially specialises said variables per kernel.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">129</td>
    <td class="codeLine">// said variables. This pass essentially specialises said variables per kernel.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeLine">// Handling ConstantExpr during the pass complicated this significantly so now</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">130</td>
    <td class="codeLine">// Handling ConstantExpr during the pass complicated this significantly so now</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeLine">// all ConstantExpr uses of LDS variables are expanded to instructions. This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">131</td>
    <td class="codeLine">// all ConstantExpr uses of LDS variables are expanded to instructions. This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeLine">// may need amending when implementing non-undef initialisers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">132</td>
    <td class="codeLine">// may need amending when implementing non-undef initialisers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">133</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeLine">// Lowering is split between this IR pass and the back end. This pass chooses</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">134</td>
    <td class="codeLine">// Lowering is split between this IR pass and the back end. This pass chooses</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeLine">// where given variables should be allocated and marks them with metadata,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">135</td>
    <td class="codeLine">// where given variables should be allocated and marks them with metadata,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeLine">// MD_absolute_symbol. The backend places the variables in coincidentally the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">136</td>
    <td class="codeLine">// MD_absolute_symbol. The backend places the variables in coincidentally the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeLine">// same location and raises a fatal error if something has gone awry. This works</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">137</td>
    <td class="codeLine">// same location and raises a fatal error if something has gone awry. This works</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeLine">// in practice because the only pass between this one and the backend that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">138</td>
    <td class="codeLine">// in practice because the only pass between this one and the backend that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeLine">// changes LDS is PromoteAlloca and the changes it makes do not conflict.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">139</td>
    <td class="codeLine">// changes LDS is PromoteAlloca and the changes it makes do not conflict.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">140</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeLine">// Addresses are written to constant global arrays based on the same metadata.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">141</td>
    <td class="codeLine">// Addresses are written to constant global arrays based on the same metadata.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">142</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeLine">// The backend lowers LDS variables in the order of traversal of the function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">143</td>
    <td class="codeLine">// The backend lowers LDS variables in the order of traversal of the function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeLine">// This is at odds with the deterministic layout required. The workaround is to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">144</td>
    <td class="codeLine">// This is at odds with the deterministic layout required. The workaround is to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeLine">// allocate the fixed-address variables immediately upon starting the function</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">145</td>
    <td class="codeLine">// allocate the fixed-address variables immediately upon starting the function</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeLine">// where they can be placed as intended. This requires a means of mapping from</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">146</td>
    <td class="codeLine">// where they can be placed as intended. This requires a means of mapping from</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeLine">// the function to the variables that it allocates. For the module scope lds,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">147</td>
    <td class="codeLine">// the function to the variables that it allocates. For the module scope lds,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeLine">// this is via metadata indicating whether the variable is not required. If a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">148</td>
    <td class="codeLine">// this is via metadata indicating whether the variable is not required. If a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeLine">// pass deletes that metadata, a fatal error on disagreement with the absolute</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">149</td>
    <td class="codeLine">// pass deletes that metadata, a fatal error on disagreement with the absolute</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeLine">// symbol metadata will occur. For kernel scope and dynamic, this is by _name_</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">150</td>
    <td class="codeLine">// symbol metadata will occur. For kernel scope and dynamic, this is by _name_</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeLine">// correspondence between the function and the variable. It requires the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">151</td>
    <td class="codeLine">// correspondence between the function and the variable. It requires the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeLine">// kernel to have a name (which is only a limitation for tests in practice) and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">152</td>
    <td class="codeLine">// kernel to have a name (which is only a limitation for tests in practice) and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeLine">// for nothing to rename the corresponding symbols. This is a hazard if the pass</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">153</td>
    <td class="codeLine">// for nothing to rename the corresponding symbols. This is a hazard if the pass</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeLine">// is run multiple times during debugging. Alternative schemes considered all</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">154</td>
    <td class="codeLine">// is run multiple times during debugging. Alternative schemes considered all</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeLine">// involve bespoke metadata.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">155</td>
    <td class="codeLine">// involve bespoke metadata.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">156</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeLine">// If the name correspondence can be replaced, multiple distinct kernels that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">157</td>
    <td class="codeLine">// If the name correspondence can be replaced, multiple distinct kernels that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeLine">// have the same memory layout can map to the same kernel id (as the address</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">158</td>
    <td class="codeLine">// have the same memory layout can map to the same kernel id (as the address</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeLine">// itself is handled by the absolute symbol metadata) and that will allow more</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">159</td>
    <td class="codeLine">// itself is handled by the absolute symbol metadata) and that will allow more</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeLine">// uses of the "kernel" style faster lowering and reduce the size of the lookup</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">160</td>
    <td class="codeLine">// uses of the "kernel" style faster lowering and reduce the size of the lookup</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeLine">// tables.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">161</td>
    <td class="codeLine">// tables.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">162</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeLine">// There is a test that checks this does not fire for a graphics shader. This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">163</td>
    <td class="codeLine">// There is a test that checks this does not fire for a graphics shader. This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeLine">// lowering is expected to work for graphics if the isKernel test is changed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">164</td>
    <td class="codeLine">// lowering is expected to work for graphics if the isKernel test is changed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">165</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeLine">// The current markUsedByKernel is sufficient for PromoteAlloca but is elided</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">166</td>
    <td class="codeLine">// The current markUsedByKernel is sufficient for PromoteAlloca but is elided</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeLine">// before codegen. Replacing this with an equivalent intrinsic which lasts until</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">167</td>
    <td class="codeLine">// before codegen. Replacing this with an equivalent intrinsic which lasts until</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeLine">// shortly after the machine function lowering of LDS would help break the name</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">168</td>
    <td class="codeLine">// shortly after the machine function lowering of LDS would help break the name</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeLine">// mapping. The other part needed is probably to amend PromoteAlloca to embed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">169</td>
    <td class="codeLine">// mapping. The other part needed is probably to amend PromoteAlloca to embed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeLine">// the LDS variables it creates in the same struct created here. That avoids the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">170</td>
    <td class="codeLine">// the LDS variables it creates in the same struct created here. That avoids the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeLine">// current hazard where a PromoteAlloca LDS variable might be allocated before</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">171</td>
    <td class="codeLine">// current hazard where a PromoteAlloca LDS variable might be allocated before</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeLine">// the kernel scope (and thus error on the address check). Given a new invariant</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">172</td>
    <td class="codeLine">// the kernel scope (and thus error on the address check). Given a new invariant</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeLine">// that no LDS variables exist outside of the structs managed here, and an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">173</td>
    <td class="codeLine">// that no LDS variables exist outside of the structs managed here, and an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeLine">// intrinsic that lasts until after the LDS frame lowering, it should be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">174</td>
    <td class="codeLine">// intrinsic that lasts until after the LDS frame lowering, it should be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeLine">// possible to drop the name mapping and fold equivalent memory layouts.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">175</td>
    <td class="codeLine">// possible to drop the name mapping and fold equivalent memory layouts.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">176</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">177</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">178</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeLine">#include "AMDGPU.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">179</td>
    <td class="codeLine">#include "AMDGPU.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeLine">#include "Utils/AMDGPUBaseInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">180</td>
    <td class="codeLine">#include "Utils/AMDGPUBaseInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeLine">#include "Utils/AMDGPUMemoryUtils.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">181</td>
    <td class="codeLine">#include "Utils/AMDGPUMemoryUtils.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeLine">#include "llvm/ADT/BitVector.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">182</td>
    <td class="codeLine">#include "llvm/ADT/BitVector.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeLine">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">183</td>
    <td class="codeLine">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeLine">#include "llvm/ADT/DenseSet.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">184</td>
    <td class="codeLine">#include "llvm/ADT/DenseSet.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeLine">#include "llvm/ADT/STLExtras.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">185</td>
    <td class="codeLine">#include "llvm/ADT/STLExtras.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeLine">#include "llvm/ADT/SetOperations.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">186</td>
    <td class="codeLine">#include "llvm/ADT/SetOperations.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeLine">#include "llvm/ADT/SetVector.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">187</td>
    <td class="codeLine">#include "llvm/ADT/SetVector.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeLine">#include "llvm/Analysis/CallGraph.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">188</td>
    <td class="codeLine">#include "llvm/Analysis/CallGraph.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeLine">#include "llvm/IR/Constants.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">189</td>
    <td class="codeLine">#include "llvm/IR/Constants.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeLine">#include "llvm/IR/DerivedTypes.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">190</td>
    <td class="codeLine">#include "llvm/IR/DerivedTypes.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeLine">#include "llvm/IR/IRBuilder.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">191</td>
    <td class="codeLine">#include "llvm/IR/IRBuilder.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeLine">#include "llvm/IR/InlineAsm.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">192</td>
    <td class="codeLine">#include "llvm/IR/InlineAsm.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeLine">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">193</td>
    <td class="codeLine">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeLine">#include "llvm/IR/IntrinsicsAMDGPU.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">194</td>
    <td class="codeLine">#include "llvm/IR/IntrinsicsAMDGPU.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeLine">#include "llvm/IR/MDBuilder.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">195</td>
    <td class="codeLine">#include "llvm/IR/MDBuilder.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeLine">#include "llvm/IR/ReplaceConstant.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">196</td>
    <td class="codeLine">#include "llvm/IR/ReplaceConstant.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeLine">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">197</td>
    <td class="codeLine">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeLine">#include "llvm/Pass.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">198</td>
    <td class="codeLine">#include "llvm/Pass.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeLine">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">199</td>
    <td class="codeLine">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeLine">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">200</td>
    <td class="codeLine">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeLine">#include "llvm/Support/Format.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">201</td>
    <td class="codeLine">#include "llvm/Support/Format.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeLine">#include "llvm/Support/OptimizedStructLayout.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">202</td>
    <td class="codeLine">#include "llvm/Support/OptimizedStructLayout.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeLine">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">203</td>
    <td class="codeLine">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/BasicBlockUtils.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">204</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/BasicBlockUtils.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/ModuleUtils.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">205</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/ModuleUtils.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">206</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeLine">#include <tuple></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">207</td>
    <td class="codeLine">#include <tuple></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeLine">#include <vector></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">208</td>
    <td class="codeLine">#include <vector></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">209</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeLine">#include <cstdio></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">210</td>
    <td class="codeLine">#include <cstdio></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">211</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeLine">#define DEBUG_TYPE "amdgpu-lower-module-lds"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">212</td>
    <td class="codeLine">#define DEBUG_TYPE "amdgpu-lower-module-lds"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">213</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">214</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">215</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">216</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">217</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeLine">cl::opt<bool> SuperAlignLDSGlobals(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">218</td>
    <td class="codeLine">cl::opt<bool> SuperAlignLDSGlobals(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeLine">    "amdgpu-super-align-lds-globals",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">219</td>
    <td class="codeLine">    "amdgpu-super-align-lds-globals",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeLine">    cl::desc("Increase alignment of LDS if it is not on align boundary"),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">220</td>
    <td class="codeLine">    cl::desc("Increase alignment of LDS if it is not on align boundary"),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeLine">    cl::init(true), cl::Hidden);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">221</td>
    <td class="codeLine">    cl::init(true), cl::Hidden);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">222</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeLine">enum class LoweringKind { module, table, kernel, hybrid };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">223</td>
    <td class="codeLine">enum class LoweringKind { module, table, kernel, hybrid };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeLine">cl::opt<LoweringKind> LoweringKindLoc(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">224</td>
    <td class="codeLine">cl::opt<LoweringKind> LoweringKindLoc(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeLine">    "amdgpu-lower-module-lds-strategy",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">225</td>
    <td class="codeLine">    "amdgpu-lower-module-lds-strategy",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeLine">    cl::desc("Specify lowering strategy for function LDS access:"), cl::Hidden,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">226</td>
    <td class="codeLine">    cl::desc("Specify lowering strategy for function LDS access:"), cl::Hidden,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeLine">    cl::init(LoweringKind::hybrid),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">227</td>
    <td class="codeLine">    cl::init(LoweringKind::hybrid),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeLine">    cl::values(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">228</td>
    <td class="codeLine">    cl::values(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeLine">        clEnumValN(LoweringKind::table, "table", "Lower via table lookup"),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">229</td>
    <td class="codeLine">        clEnumValN(LoweringKind::table, "table", "Lower via table lookup"),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeLine">        clEnumValN(LoweringKind::module, "module", "Lower via module struct"),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">230</td>
    <td class="codeLine">        clEnumValN(LoweringKind::module, "module", "Lower via module struct"),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeLine">        clEnumValN(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">231</td>
    <td class="codeLine">        clEnumValN(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeLine">            LoweringKind::kernel, "kernel",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">232</td>
    <td class="codeLine">            LoweringKind::kernel, "kernel",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeLine">            "Lower variables reachable from one kernel, otherwise abort"),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">233</td>
    <td class="codeLine">            "Lower variables reachable from one kernel, otherwise abort"),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeLine">        clEnumValN(LoweringKind::hybrid, "hybrid",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">234</td>
    <td class="codeLine">        clEnumValN(LoweringKind::hybrid, "hybrid",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeLine">                   "Lower via mixture of above strategies")));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">235</td>
    <td class="codeLine">                   "Lower via mixture of above strategies")));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">236</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeLine">bool isKernelLDS(const Function *F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">237</td>
    <td class="codeLine">bool isKernelLDS(const Function *F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeLine">  // Some weirdness here. AMDGPU::isKernelCC does not call into</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">238</td>
    <td class="codeLine">  // Some weirdness here. AMDGPU::isKernelCC does not call into</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeLine">  // AMDGPU::isKernel with the calling conv, it instead calls into</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">239</td>
    <td class="codeLine">  // AMDGPU::isKernel with the calling conv, it instead calls into</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeLine">  // isModuleEntryFunction which returns true for more calling conventions</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">240</td>
    <td class="codeLine">  // isModuleEntryFunction which returns true for more calling conventions</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeLine">  // than AMDGPU::isKernel does. There's a FIXME on AMDGPU::isKernel.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">241</td>
    <td class="codeLine">  // than AMDGPU::isKernel does. There's a FIXME on AMDGPU::isKernel.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeLine">  // There's also a test that checks that the LDS lowering does not hit on</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">242</td>
    <td class="codeLine">  // There's also a test that checks that the LDS lowering does not hit on</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeLine">  // a graphics shader, denoted amdgpu_ps, so stay with the limited case.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">243</td>
    <td class="codeLine">  // a graphics shader, denoted amdgpu_ps, so stay with the limited case.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeLine">  // Putting LDS in the name of the function to draw attention to this.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">244</td>
    <td class="codeLine">  // Putting LDS in the name of the function to draw attention to this.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeLine">  return AMDGPU::isKernel(F->getCallingConv());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">245</td>
    <td class="codeLine">  return AMDGPU::isKernel(F->getCallingConv());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">246</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">247</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeLine">template <typename T> std::vector<T> sortByName(std::vector<T> &&V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">248</td>
    <td class="codeLine">template <typename T> std::vector<T> sortByName(std::vector<T> &&V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeLine">  llvm::sort(V.begin(), V.end(), [](const auto *L, const auto *R) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">249</td>
    <td class="codeLine">  llvm::sort(V.begin(), V.end(), [](const auto *L, const auto *R) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeLine">    return L->getName() < R->getName();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">250</td>
    <td class="codeLine">    return L->getName() < R->getName();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">251</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeLine">  return {std::move(V)};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">252</td>
    <td class="codeLine">  return {std::move(V)};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">253</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">254</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeLine">class AMDGPULowerModuleLDS : public ModulePass {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">255</td>
    <td class="codeLine">class AMDGPULowerModuleLDS : public ModulePass {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">256</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeLine">  static void</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">257</td>
    <td class="codeLine">  static void</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeLine">  removeLocalVarsFromUsedLists(Module &M,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">258</td>
    <td class="codeLine">  removeLocalVarsFromUsedLists(Module &M,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeLine">                               const DenseSet<GlobalVariable *> &LocalVars) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">259</td>
    <td class="codeLine">                               const DenseSet<GlobalVariable *> &LocalVars) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeLine">    // The verifier rejects used lists containing an inttoptr of a constant</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">260</td>
    <td class="codeLine">    // The verifier rejects used lists containing an inttoptr of a constant</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeLine">    // so remove the variables from these lists before replaceAllUsesWith</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">261</td>
    <td class="codeLine">    // so remove the variables from these lists before replaceAllUsesWith</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeLine">    SmallPtrSet<Constant *, 8> LocalVarsSet;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">262</td>
    <td class="codeLine">    SmallPtrSet<Constant *, 8> LocalVarsSet;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeLine">    for (GlobalVariable *LocalVar : LocalVars)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">263</td>
    <td class="codeLine">    for (GlobalVariable *LocalVar : LocalVars)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeLine">      LocalVarsSet.insert(cast<Constant>(LocalVar->stripPointerCasts()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">264</td>
    <td class="codeLine">      LocalVarsSet.insert(cast<Constant>(LocalVar->stripPointerCasts()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">265</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeLine">    removeFromUsedLists(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">266</td>
    <td class="codeLine">    removeFromUsedLists(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeLine">        M, [&LocalVarsSet](Constant *C) { return LocalVarsSet.count(C); });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">267</td>
    <td class="codeLine">        M, [&LocalVarsSet](Constant *C) { return LocalVarsSet.count(C); });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">268</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeLine">    for (GlobalVariable *LocalVar : LocalVars)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">269</td>
    <td class="codeLine">    for (GlobalVariable *LocalVar : LocalVars)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeLine">      LocalVar->removeDeadConstantUsers();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">270</td>
    <td class="codeLine">      LocalVar->removeDeadConstantUsers();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">271</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">272</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeLine">  static void markUsedByKernel(Function *Func, GlobalVariable *SGV) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">273</td>
    <td class="codeLine">  static void markUsedByKernel(Function *Func, GlobalVariable *SGV) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeLine">    // The llvm.amdgcn.module.lds instance is implicitly used by all kernels</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">274</td>
    <td class="codeLine">    // The llvm.amdgcn.module.lds instance is implicitly used by all kernels</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeLine">    // that might call a function which accesses a field within it. This is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">275</td>
    <td class="codeLine">    // that might call a function which accesses a field within it. This is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeLine">    // presently approximated to 'all kernels' if there are any such functions</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">276</td>
    <td class="codeLine">    // presently approximated to 'all kernels' if there are any such functions</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeLine">    // in the module. This implicit use is redefined as an explicit use here so</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">277</td>
    <td class="codeLine">    // in the module. This implicit use is redefined as an explicit use here so</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeLine">    // that later passes, specifically PromoteAlloca, account for the required</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">278</td>
    <td class="codeLine">    // that later passes, specifically PromoteAlloca, account for the required</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeLine">    // memory without any knowledge of this transform.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">279</td>
    <td class="codeLine">    // memory without any knowledge of this transform.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">280</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeLine">    // An operand bundle on llvm.donothing works because the call instruction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">281</td>
    <td class="codeLine">    // An operand bundle on llvm.donothing works because the call instruction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeLine">    // survives until after the last pass that needs to account for LDS. It is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">282</td>
    <td class="codeLine">    // survives until after the last pass that needs to account for LDS. It is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeLine">    // better than inline asm as the latter survives until the end of codegen. A</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">283</td>
    <td class="codeLine">    // better than inline asm as the latter survives until the end of codegen. A</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeLine">    // totally robust solution would be a function with the same semantics as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">284</td>
    <td class="codeLine">    // totally robust solution would be a function with the same semantics as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeLine">    // llvm.donothing that takes a pointer to the instance and is lowered to a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">285</td>
    <td class="codeLine">    // llvm.donothing that takes a pointer to the instance and is lowered to a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeLine">    // no-op after LDS is allocated, but that is not presently necessary.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">286</td>
    <td class="codeLine">    // no-op after LDS is allocated, but that is not presently necessary.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">287</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeLine">    // This intrinsic is eliminated shortly before instruction selection. It</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">288</td>
    <td class="codeLine">    // This intrinsic is eliminated shortly before instruction selection. It</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeLine">    // does not suffice to indicate to ISel that a given global which is not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">289</td>
    <td class="codeLine">    // does not suffice to indicate to ISel that a given global which is not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeLine">    // immediately used by the kernel must still be allocated by it. An</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">290</td>
    <td class="codeLine">    // immediately used by the kernel must still be allocated by it. An</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeLine">    // equivalent target specific intrinsic which lasts until immediately after</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">291</td>
    <td class="codeLine">    // equivalent target specific intrinsic which lasts until immediately after</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeLine">    // codegen would suffice for that, but one would still need to ensure that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">292</td>
    <td class="codeLine">    // codegen would suffice for that, but one would still need to ensure that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeLine">    // the variables are allocated in the anticpated order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">293</td>
    <td class="codeLine">    // the variables are allocated in the anticpated order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeLine">    IRBuilder<> Builder(Func->getEntryBlock().getFirstNonPHI());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">294</td>
    <td class="codeLine">    IRBuilder<> Builder(Func->getEntryBlock().getFirstNonPHI());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">295</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeLine">    Function *Decl =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">296</td>
    <td class="codeLine">    Function *Decl =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeLine">        Intrinsic::getDeclaration(Func->getParent(), Intrinsic::donothing, {});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">297</td>
    <td class="codeLine">        Intrinsic::getDeclaration(Func->getParent(), Intrinsic::donothing, {});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">298</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeLine">    Value *UseInstance[1] = {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">299</td>
    <td class="codeLine">    Value *UseInstance[1] = {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeLine">        Builder.CreateConstInBoundsGEP1_32(SGV->getValueType(), SGV, 0)};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">300</td>
    <td class="codeLine">        Builder.CreateConstInBoundsGEP1_32(SGV->getValueType(), SGV, 0)};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">301</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeLine">    Builder.CreateCall(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">302</td>
    <td class="codeLine">    Builder.CreateCall(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeLine">        Decl, {}, {OperandBundleDefT<Value *>("ExplicitUse", UseInstance)});</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">303</td>
    <td class="codeLine">        Decl, {}, {OperandBundleDefT<Value *>("ExplicitUse", UseInstance)});</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">304</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">305</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeLine">  static bool eliminateConstantExprUsesOfLDSFromAllInstructions(Module &M) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">306</td>
    <td class="codeLine">  static bool eliminateConstantExprUsesOfLDSFromAllInstructions(Module &M) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeLine">    // Constants are uniqued within LLVM. A ConstantExpr referring to a LDS</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">307</td>
    <td class="codeLine">    // Constants are uniqued within LLVM. A ConstantExpr referring to a LDS</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeLine">    // global may have uses from multiple different functions as a result.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">308</td>
    <td class="codeLine">    // global may have uses from multiple different functions as a result.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeLine">    // This pass specialises LDS variables with respect to the kernel that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">309</td>
    <td class="codeLine">    // This pass specialises LDS variables with respect to the kernel that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeLine">    // allocates them.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">310</td>
    <td class="codeLine">    // allocates them.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">311</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeLine">    // This is semantically equivalent to (the unimplemented as slow):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">312</td>
    <td class="codeLine">    // This is semantically equivalent to (the unimplemented as slow):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeLine">    // for (auto &F : M.functions())</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">313</td>
    <td class="codeLine">    // for (auto &F : M.functions())</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeLine">    //   for (auto &BB : F)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">314</td>
    <td class="codeLine">    //   for (auto &BB : F)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeLine">    //     for (auto &I : BB)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">315</td>
    <td class="codeLine">    //     for (auto &I : BB)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeLine">    //       for (Use &Op : I.operands())</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">316</td>
    <td class="codeLine">    //       for (Use &Op : I.operands())</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeLine">    //         if (constantExprUsesLDS(Op))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">317</td>
    <td class="codeLine">    //         if (constantExprUsesLDS(Op))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeLine">    //           replaceConstantExprInFunction(I, Op);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">318</td>
    <td class="codeLine">    //           replaceConstantExprInFunction(I, Op);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">319</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeLine">    SmallVector<Constant *> LDSGlobals;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">320</td>
    <td class="codeLine">    SmallVector<Constant *> LDSGlobals;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeLine">    for (auto &GV : M.globals())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">321</td>
    <td class="codeLine">    for (auto &GV : M.globals())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeLine">      if (AMDGPU::isLDSVariableToLower(GV))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">322</td>
    <td class="codeLine">      if (AMDGPU::isLDSVariableToLower(GV))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeLine">        LDSGlobals.push_back(&GV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">323</td>
    <td class="codeLine">        LDSGlobals.push_back(&GV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">324</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeLine">    return convertUsersOfConstantsToInstructions(LDSGlobals);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">325</td>
    <td class="codeLine">    return convertUsersOfConstantsToInstructions(LDSGlobals);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">326</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">327</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">328</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeLine">  static char ID;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">329</td>
    <td class="codeLine">  static char ID;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">330</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeLine">  AMDGPULowerModuleLDS() : ModulePass(ID) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">331</td>
    <td class="codeLine">  AMDGPULowerModuleLDS() : ModulePass(ID) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeLine">    initializeAMDGPULowerModuleLDSPass(*PassRegistry::getPassRegistry());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">332</td>
    <td class="codeLine">    initializeAMDGPULowerModuleLDSPass(*PassRegistry::getPassRegistry());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">333</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">334</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeLine">  using FunctionVariableMap = DenseMap<Function *, DenseSet<GlobalVariable *>>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">335</td>
    <td class="codeLine">  using FunctionVariableMap = DenseMap<Function *, DenseSet<GlobalVariable *>>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">336</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeLine">  using VariableFunctionMap = DenseMap<GlobalVariable *, DenseSet<Function *>>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">337</td>
    <td class="codeLine">  using VariableFunctionMap = DenseMap<GlobalVariable *, DenseSet<Function *>>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">338</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeLine">  static void getUsesOfLDSByFunction(CallGraph const &CG, Module &M,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">339</td>
    <td class="codeLine">  static void getUsesOfLDSByFunction(CallGraph const &CG, Module &M,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeLine">                                     FunctionVariableMap &kernels,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">340</td>
    <td class="codeLine">                                     FunctionVariableMap &kernels,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeLine">                                     FunctionVariableMap &functions) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">341</td>
    <td class="codeLine">                                     FunctionVariableMap &functions) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">342</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeLine">    // Get uses from the current function, excluding uses by called functions</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">343</td>
    <td class="codeLine">    // Get uses from the current function, excluding uses by called functions</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeLine">    // Two output variables to avoid walking the globals list twice</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">344</td>
    <td class="codeLine">    // Two output variables to avoid walking the globals list twice</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeLine">    for (auto &GV : M.globals()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">345</td>
    <td class="codeLine">    for (auto &GV : M.globals()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeLine">      if (!AMDGPU::isLDSVariableToLower(GV)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">346</td>
    <td class="codeLine">      if (!AMDGPU::isLDSVariableToLower(GV)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">347</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">348</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">349</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeLine">      if (GV.isAbsoluteSymbolRef()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">350</td>
    <td class="codeLine">      if (GV.isAbsoluteSymbolRef()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeLine">        report_fatal_error(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">351</td>
    <td class="codeLine">        report_fatal_error(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeLine">            "LDS variables with absolute addresses are unimplemented.");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">352</td>
    <td class="codeLine">            "LDS variables with absolute addresses are unimplemented.");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">353</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">354</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeLine">      for (User *V : GV.users()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">355</td>
    <td class="codeLine">      for (User *V : GV.users()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeLine">        if (auto *I = dyn_cast<Instruction>(V)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">356</td>
    <td class="codeLine">        if (auto *I = dyn_cast<Instruction>(V)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeLine">          Function *F = I->getFunction();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">357</td>
    <td class="codeLine">          Function *F = I->getFunction();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeLine">          if (isKernelLDS(F)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">358</td>
    <td class="codeLine">          if (isKernelLDS(F)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeLine">            kernels[F].insert(&GV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">359</td>
    <td class="codeLine">            kernels[F].insert(&GV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeLine">          } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">360</td>
    <td class="codeLine">          } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeLine">            functions[F].insert(&GV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">361</td>
    <td class="codeLine">            functions[F].insert(&GV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">362</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">363</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">364</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">365</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">366</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">367</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeLine">  struct LDSUsesInfoTy {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">368</td>
    <td class="codeLine">  struct LDSUsesInfoTy {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeLine">    FunctionVariableMap direct_access;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">369</td>
    <td class="codeLine">    FunctionVariableMap direct_access;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeLine">    FunctionVariableMap indirect_access;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">370</td>
    <td class="codeLine">    FunctionVariableMap indirect_access;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">371</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">372</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeLine">  static LDSUsesInfoTy getTransitiveUsesOfLDS(CallGraph const &CG, Module &M) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">373</td>
    <td class="codeLine">  static LDSUsesInfoTy getTransitiveUsesOfLDS(CallGraph const &CG, Module &M) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">374</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeLine">    FunctionVariableMap direct_map_kernel;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">375</td>
    <td class="codeLine">    FunctionVariableMap direct_map_kernel;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeLine">    FunctionVariableMap direct_map_function;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">376</td>
    <td class="codeLine">    FunctionVariableMap direct_map_function;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeLine">    getUsesOfLDSByFunction(CG, M, direct_map_kernel, direct_map_function);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">377</td>
    <td class="codeLine">    getUsesOfLDSByFunction(CG, M, direct_map_kernel, direct_map_function);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">378</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeLine">    // Collect variables that are used by functions whose address has escaped</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">379</td>
    <td class="codeLine">    // Collect variables that are used by functions whose address has escaped</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeLine">    DenseSet<GlobalVariable *> VariablesReachableThroughFunctionPointer;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">380</td>
    <td class="codeLine">    DenseSet<GlobalVariable *> VariablesReachableThroughFunctionPointer;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeLine">    for (Function &F : M.functions()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">381</td>
    <td class="codeLine">    for (Function &F : M.functions()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeLine">      if (!isKernelLDS(&F))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">382</td>
    <td class="codeLine">      if (!isKernelLDS(&F))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeLine">        if (F.hasAddressTaken(nullptr,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">383</td>
    <td class="codeLine">        if (F.hasAddressTaken(nullptr,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeLine">                              /* IgnoreCallbackUses */ false,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">384</td>
    <td class="codeLine">                              /* IgnoreCallbackUses */ false,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeLine">                              /* IgnoreAssumeLikeCalls */ false,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">385</td>
    <td class="codeLine">                              /* IgnoreAssumeLikeCalls */ false,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeLine">                              /* IgnoreLLVMUsed */ true,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">386</td>
    <td class="codeLine">                              /* IgnoreLLVMUsed */ true,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeLine">                              /* IgnoreArcAttachedCall */ false)) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">387</td>
    <td class="codeLine">                              /* IgnoreArcAttachedCall */ false)) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeLine">          set_union(VariablesReachableThroughFunctionPointer,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">388</td>
    <td class="codeLine">          set_union(VariablesReachableThroughFunctionPointer,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeLine">                    direct_map_function[&F]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">389</td>
    <td class="codeLine">                    direct_map_function[&F]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">390</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">391</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">392</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeLine">    auto functionMakesUnknownCall = [&](const Function *F) -> bool {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">393</td>
    <td class="codeLine">    auto functionMakesUnknownCall = [&](const Function *F) -> bool {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeLine">      assert(!F->isDeclaration());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">394</td>
    <td class="codeLine">      assert(!F->isDeclaration());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeLine">      for (const CallGraphNode::CallRecord &R : *CG[F]) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">395</td>
    <td class="codeLine">      for (const CallGraphNode::CallRecord &R : *CG[F]) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeLine">        if (!R.second->getFunction()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">396</td>
    <td class="codeLine">        if (!R.second->getFunction()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeLine">          return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">397</td>
    <td class="codeLine">          return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">398</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">399</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">400</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">401</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">402</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeLine">    // Work out which variables are reachable through function calls</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">403</td>
    <td class="codeLine">    // Work out which variables are reachable through function calls</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeLine">    FunctionVariableMap transitive_map_function = direct_map_function;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">404</td>
    <td class="codeLine">    FunctionVariableMap transitive_map_function = direct_map_function;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">405</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeLine">    // If the function makes any unknown call, assume the worst case that it can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">406</td>
    <td class="codeLine">    // If the function makes any unknown call, assume the worst case that it can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeLine">    // access all variables accessed by functions whose address escaped</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">407</td>
    <td class="codeLine">    // access all variables accessed by functions whose address escaped</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeLine">    for (Function &F : M.functions()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">408</td>
    <td class="codeLine">    for (Function &F : M.functions()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeLine">      if (!F.isDeclaration() && functionMakesUnknownCall(&F)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">409</td>
    <td class="codeLine">      if (!F.isDeclaration() && functionMakesUnknownCall(&F)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeLine">        if (!isKernelLDS(&F)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">410</td>
    <td class="codeLine">        if (!isKernelLDS(&F)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeLine">          set_union(transitive_map_function[&F],</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">411</td>
    <td class="codeLine">          set_union(transitive_map_function[&F],</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeLine">                    VariablesReachableThroughFunctionPointer);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">412</td>
    <td class="codeLine">                    VariablesReachableThroughFunctionPointer);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">413</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">414</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">415</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">416</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeLine">    // Direct implementation of collecting all variables reachable from each</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">417</td>
    <td class="codeLine">    // Direct implementation of collecting all variables reachable from each</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeLine">    // function</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">418</td>
    <td class="codeLine">    // function</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeLine">    for (Function &Func : M.functions()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">419</td>
    <td class="codeLine">    for (Function &Func : M.functions()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeLine">      if (Func.isDeclaration() || isKernelLDS(&Func))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">420</td>
    <td class="codeLine">      if (Func.isDeclaration() || isKernelLDS(&Func))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">421</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">422</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeLine">      DenseSet<Function *> seen; // catches cycles</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">423</td>
    <td class="codeLine">      DenseSet<Function *> seen; // catches cycles</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeLine">      SmallVector<Function *, 4> wip{&Func};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">424</td>
    <td class="codeLine">      SmallVector<Function *, 4> wip{&Func};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">425</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeLine">      while (!wip.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">426</td>
    <td class="codeLine">      while (!wip.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeLine">        Function *F = wip.pop_back_val();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">427</td>
    <td class="codeLine">        Function *F = wip.pop_back_val();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">428</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeLine">        // Can accelerate this by referring to transitive map for functions that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">429</td>
    <td class="codeLine">        // Can accelerate this by referring to transitive map for functions that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeLine">        // have already been computed, with more care than this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">430</td>
    <td class="codeLine">        // have already been computed, with more care than this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeLine">        set_union(transitive_map_function[&Func], direct_map_function[F]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">431</td>
    <td class="codeLine">        set_union(transitive_map_function[&Func], direct_map_function[F]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">432</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeLine">        for (const CallGraphNode::CallRecord &R : *CG[F]) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">433</td>
    <td class="codeLine">        for (const CallGraphNode::CallRecord &R : *CG[F]) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeLine">          Function *ith = R.second->getFunction();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">434</td>
    <td class="codeLine">          Function *ith = R.second->getFunction();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeLine">          if (ith) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">435</td>
    <td class="codeLine">          if (ith) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeLine">            if (!seen.contains(ith)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">436</td>
    <td class="codeLine">            if (!seen.contains(ith)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeLine">              seen.insert(ith);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">437</td>
    <td class="codeLine">              seen.insert(ith);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeLine">              wip.push_back(ith);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">438</td>
    <td class="codeLine">              wip.push_back(ith);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeLine">            }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">439</td>
    <td class="codeLine">            }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">440</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">441</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">442</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">443</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">444</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeLine">    // direct_map_kernel lists which variables are used by the kernel</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">445</td>
    <td class="codeLine">    // direct_map_kernel lists which variables are used by the kernel</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeLine">    // find the variables which are used through a function call</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">446</td>
    <td class="codeLine">    // find the variables which are used through a function call</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeLine">    FunctionVariableMap indirect_map_kernel;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">447</td>
    <td class="codeLine">    FunctionVariableMap indirect_map_kernel;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">448</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeLine">    for (Function &Func : M.functions()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">449</td>
    <td class="codeLine">    for (Function &Func : M.functions()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeLine">      if (Func.isDeclaration() || !isKernelLDS(&Func))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">450</td>
    <td class="codeLine">      if (Func.isDeclaration() || !isKernelLDS(&Func))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">451</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">452</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeLine">      for (const CallGraphNode::CallRecord &R : *CG[&Func]) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">453</td>
    <td class="codeLine">      for (const CallGraphNode::CallRecord &R : *CG[&Func]) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeLine">        Function *ith = R.second->getFunction();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">454</td>
    <td class="codeLine">        Function *ith = R.second->getFunction();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeLine">        if (ith) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">455</td>
    <td class="codeLine">        if (ith) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeLine">          set_union(indirect_map_kernel[&Func], transitive_map_function[ith]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">456</td>
    <td class="codeLine">          set_union(indirect_map_kernel[&Func], transitive_map_function[ith]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeLine">        } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">457</td>
    <td class="codeLine">        } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeLine">          set_union(indirect_map_kernel[&Func],</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">458</td>
    <td class="codeLine">          set_union(indirect_map_kernel[&Func],</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeLine">                    VariablesReachableThroughFunctionPointer);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">459</td>
    <td class="codeLine">                    VariablesReachableThroughFunctionPointer);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">460</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">461</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">462</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">463</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeLine">    return {std::move(direct_map_kernel), std::move(indirect_map_kernel)};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">464</td>
    <td class="codeLine">    return {std::move(direct_map_kernel), std::move(indirect_map_kernel)};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">465</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">466</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeLine">  struct LDSVariableReplacement {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">467</td>
    <td class="codeLine">  struct LDSVariableReplacement {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeLine">    GlobalVariable *SGV = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">468</td>
    <td class="codeLine">    GlobalVariable *SGV = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeLine">    DenseMap<GlobalVariable *, Constant *> LDSVarsToConstantGEP;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">469</td>
    <td class="codeLine">    DenseMap<GlobalVariable *, Constant *> LDSVarsToConstantGEP;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">470</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">471</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeLine">  // remap from lds global to a constantexpr gep to where it has been moved to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">472</td>
    <td class="codeLine">  // remap from lds global to a constantexpr gep to where it has been moved to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeLine">  // for each kernel</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">473</td>
    <td class="codeLine">  // for each kernel</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeLine">  // an array with an element for each kernel containing where the corresponding</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">474</td>
    <td class="codeLine">  // an array with an element for each kernel containing where the corresponding</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeLine">  // variable was remapped to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">475</td>
    <td class="codeLine">  // variable was remapped to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">476</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeLine">  static Constant *getAddressesOfVariablesInKernel(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">477</td>
    <td class="codeLine">  static Constant *getAddressesOfVariablesInKernel(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeLine">      LLVMContext &Ctx, ArrayRef<GlobalVariable *> Variables,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">478</td>
    <td class="codeLine">      LLVMContext &Ctx, ArrayRef<GlobalVariable *> Variables,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeLine">      const DenseMap<GlobalVariable *, Constant *> &LDSVarsToConstantGEP) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">479</td>
    <td class="codeLine">      const DenseMap<GlobalVariable *, Constant *> &LDSVarsToConstantGEP) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeLine">    // Create a ConstantArray containing the address of each Variable within the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">480</td>
    <td class="codeLine">    // Create a ConstantArray containing the address of each Variable within the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeLine">    // kernel corresponding to LDSVarsToConstantGEP, or poison if that kernel</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">481</td>
    <td class="codeLine">    // kernel corresponding to LDSVarsToConstantGEP, or poison if that kernel</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeLine">    // does not allocate it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">482</td>
    <td class="codeLine">    // does not allocate it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeLine">    // TODO: Drop the ptrtoint conversion</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">483</td>
    <td class="codeLine">    // TODO: Drop the ptrtoint conversion</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">484</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeLine">    Type *I32 = Type::getInt32Ty(Ctx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">485</td>
    <td class="codeLine">    Type *I32 = Type::getInt32Ty(Ctx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">486</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeLine">    ArrayType *KernelOffsetsType = ArrayType::get(I32, Variables.size());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">487</td>
    <td class="codeLine">    ArrayType *KernelOffsetsType = ArrayType::get(I32, Variables.size());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">488</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeLine">    SmallVector<Constant *> Elements;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">489</td>
    <td class="codeLine">    SmallVector<Constant *> Elements;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeLine">    for (size_t i = 0; i < Variables.size(); i++) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">490</td>
    <td class="codeLine">    for (size_t i = 0; i < Variables.size(); i++) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeLine">      GlobalVariable *GV = Variables[i];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">491</td>
    <td class="codeLine">      GlobalVariable *GV = Variables[i];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeLine">      auto ConstantGepIt = LDSVarsToConstantGEP.find(GV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">492</td>
    <td class="codeLine">      auto ConstantGepIt = LDSVarsToConstantGEP.find(GV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeLine">      if (ConstantGepIt != LDSVarsToConstantGEP.end()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">493</td>
    <td class="codeLine">      if (ConstantGepIt != LDSVarsToConstantGEP.end()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeLine">        auto elt = ConstantExpr::getPtrToInt(ConstantGepIt->second, I32);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">494</td>
    <td class="codeLine">        auto elt = ConstantExpr::getPtrToInt(ConstantGepIt->second, I32);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeLine">        Elements.push_back(elt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">495</td>
    <td class="codeLine">        Elements.push_back(elt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">496</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeLine">        Elements.push_back(PoisonValue::get(I32));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">497</td>
    <td class="codeLine">        Elements.push_back(PoisonValue::get(I32));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">498</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">499</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeLine">    return ConstantArray::get(KernelOffsetsType, Elements);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">500</td>
    <td class="codeLine">    return ConstantArray::get(KernelOffsetsType, Elements);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">501</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">502</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeLine">  static GlobalVariable *buildLookupTable(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">503</td>
    <td class="codeLine">  static GlobalVariable *buildLookupTable(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeLine">      Module &M, ArrayRef<GlobalVariable *> Variables,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">504</td>
    <td class="codeLine">      Module &M, ArrayRef<GlobalVariable *> Variables,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeLine">      ArrayRef<Function *> kernels,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">505</td>
    <td class="codeLine">      ArrayRef<Function *> kernels,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeLine">      DenseMap<Function *, LDSVariableReplacement> &KernelToReplacement) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">506</td>
    <td class="codeLine">      DenseMap<Function *, LDSVariableReplacement> &KernelToReplacement) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeLine">    if (Variables.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">507</td>
    <td class="codeLine">    if (Variables.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeLine">      return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">508</td>
    <td class="codeLine">      return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">509</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeLine">    LLVMContext &Ctx = M.getContext();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">510</td>
    <td class="codeLine">    LLVMContext &Ctx = M.getContext();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">511</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeLine">    const size_t NumberVariables = Variables.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">512</td>
    <td class="codeLine">    const size_t NumberVariables = Variables.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeLine">    const size_t NumberKernels = kernels.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">513</td>
    <td class="codeLine">    const size_t NumberKernels = kernels.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">514</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeLine">    ArrayType *KernelOffsetsType =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">515</td>
    <td class="codeLine">    ArrayType *KernelOffsetsType =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeLine">        ArrayType::get(Type::getInt32Ty(Ctx), NumberVariables);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">516</td>
    <td class="codeLine">        ArrayType::get(Type::getInt32Ty(Ctx), NumberVariables);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">517</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeLine">    ArrayType *AllKernelsOffsetsType =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">518</td>
    <td class="codeLine">    ArrayType *AllKernelsOffsetsType =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeLine">        ArrayType::get(KernelOffsetsType, NumberKernels);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">519</td>
    <td class="codeLine">        ArrayType::get(KernelOffsetsType, NumberKernels);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">520</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeLine">    Constant *Missing = PoisonValue::get(KernelOffsetsType);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">521</td>
    <td class="codeLine">    Constant *Missing = PoisonValue::get(KernelOffsetsType);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeLine">    std::vector<Constant *> overallConstantExprElts(NumberKernels);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">522</td>
    <td class="codeLine">    std::vector<Constant *> overallConstantExprElts(NumberKernels);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeLine">    for (size_t i = 0; i < NumberKernels; i++) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">523</td>
    <td class="codeLine">    for (size_t i = 0; i < NumberKernels; i++) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeLine">      auto Replacement = KernelToReplacement.find(kernels[i]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">524</td>
    <td class="codeLine">      auto Replacement = KernelToReplacement.find(kernels[i]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeLine">      overallConstantExprElts[i] =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">525</td>
    <td class="codeLine">      overallConstantExprElts[i] =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeLine">          (Replacement == KernelToReplacement.end())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">526</td>
    <td class="codeLine">          (Replacement == KernelToReplacement.end())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeLine">              ? Missing</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">527</td>
    <td class="codeLine">              ? Missing</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeLine">              : getAddressesOfVariablesInKernel(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">528</td>
    <td class="codeLine">              : getAddressesOfVariablesInKernel(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeLine">                    Ctx, Variables, Replacement->second.LDSVarsToConstantGEP);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">529</td>
    <td class="codeLine">                    Ctx, Variables, Replacement->second.LDSVarsToConstantGEP);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">530</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">531</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeLine">    Constant *init =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">532</td>
    <td class="codeLine">    Constant *init =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeLine">        ConstantArray::get(AllKernelsOffsetsType, overallConstantExprElts);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">533</td>
    <td class="codeLine">        ConstantArray::get(AllKernelsOffsetsType, overallConstantExprElts);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">534</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeLine">    return new GlobalVariable(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">535</td>
    <td class="codeLine">    return new GlobalVariable(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeLine">        M, AllKernelsOffsetsType, true, GlobalValue::InternalLinkage, init,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">536</td>
    <td class="codeLine">        M, AllKernelsOffsetsType, true, GlobalValue::InternalLinkage, init,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeLine">        "llvm.amdgcn.lds.offset.table", nullptr, GlobalValue::NotThreadLocal,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">537</td>
    <td class="codeLine">        "llvm.amdgcn.lds.offset.table", nullptr, GlobalValue::NotThreadLocal,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeLine">        AMDGPUAS::CONSTANT_ADDRESS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">538</td>
    <td class="codeLine">        AMDGPUAS::CONSTANT_ADDRESS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">539</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">540</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeLine">  void replaceUseWithTableLookup(Module &M, IRBuilder<> &Builder,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">541</td>
    <td class="codeLine">  void replaceUseWithTableLookup(Module &M, IRBuilder<> &Builder,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeLine">                                 GlobalVariable *LookupTable,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">542</td>
    <td class="codeLine">                                 GlobalVariable *LookupTable,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeLine">                                 GlobalVariable *GV, Use &U,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">543</td>
    <td class="codeLine">                                 GlobalVariable *GV, Use &U,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeLine">                                 Value *OptionalIndex) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">544</td>
    <td class="codeLine">                                 Value *OptionalIndex) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeLine">    // Table is a constant array of the same length as OrderedKernels</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">545</td>
    <td class="codeLine">    // Table is a constant array of the same length as OrderedKernels</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeLine">    LLVMContext &Ctx = M.getContext();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">546</td>
    <td class="codeLine">    LLVMContext &Ctx = M.getContext();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeLine">    Type *I32 = Type::getInt32Ty(Ctx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">547</td>
    <td class="codeLine">    Type *I32 = Type::getInt32Ty(Ctx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeLine">    auto *I = cast<Instruction>(U.getUser());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">548</td>
    <td class="codeLine">    auto *I = cast<Instruction>(U.getUser());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">549</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeLine">    Value *tableKernelIndex = getTableLookupKernelIndex(M, I->getFunction());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">550</td>
    <td class="codeLine">    Value *tableKernelIndex = getTableLookupKernelIndex(M, I->getFunction());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">551</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeLine">    if (auto *Phi = dyn_cast<PHINode>(I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">552</td>
    <td class="codeLine">    if (auto *Phi = dyn_cast<PHINode>(I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeLine">      BasicBlock *BB = Phi->getIncomingBlock(U);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">553</td>
    <td class="codeLine">      BasicBlock *BB = Phi->getIncomingBlock(U);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeLine">      Builder.SetInsertPoint(&(*(BB->getFirstInsertionPt())));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">554</td>
    <td class="codeLine">      Builder.SetInsertPoint(&(*(BB->getFirstInsertionPt())));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">555</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeLine">      Builder.SetInsertPoint(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">556</td>
    <td class="codeLine">      Builder.SetInsertPoint(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">557</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">558</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeLine">    SmallVector<Value *, 3> GEPIdx = {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">559</td>
    <td class="codeLine">    SmallVector<Value *, 3> GEPIdx = {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeLine">        ConstantInt::get(I32, 0),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">560</td>
    <td class="codeLine">        ConstantInt::get(I32, 0),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeLine">        tableKernelIndex,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">561</td>
    <td class="codeLine">        tableKernelIndex,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">562</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeLine">    if (OptionalIndex)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">563</td>
    <td class="codeLine">    if (OptionalIndex)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeLine">      GEPIdx.push_back(OptionalIndex);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">564</td>
    <td class="codeLine">      GEPIdx.push_back(OptionalIndex);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">565</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeLine">    Value *Address = Builder.CreateInBoundsGEP(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">566</td>
    <td class="codeLine">    Value *Address = Builder.CreateInBoundsGEP(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeLine">        LookupTable->getValueType(), LookupTable, GEPIdx, GV->getName());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">567</td>
    <td class="codeLine">        LookupTable->getValueType(), LookupTable, GEPIdx, GV->getName());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">568</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeLine">    Value *loaded = Builder.CreateLoad(I32, Address);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">569</td>
    <td class="codeLine">    Value *loaded = Builder.CreateLoad(I32, Address);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">570</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeLine">    Value *replacement =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">571</td>
    <td class="codeLine">    Value *replacement =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeLine">        Builder.CreateIntToPtr(loaded, GV->getType(), GV->getName());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">572</td>
    <td class="codeLine">        Builder.CreateIntToPtr(loaded, GV->getType(), GV->getName());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">573</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeLine">    U.set(replacement);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">574</td>
    <td class="codeLine">    U.set(replacement);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">575</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">576</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeLine">  void replaceUsesInInstructionsWithTableLookup(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">577</td>
    <td class="codeLine">  void replaceUsesInInstructionsWithTableLookup(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeLine">      Module &M, ArrayRef<GlobalVariable *> ModuleScopeVariables,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">578</td>
    <td class="codeLine">      Module &M, ArrayRef<GlobalVariable *> ModuleScopeVariables,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeLine">      GlobalVariable *LookupTable) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">579</td>
    <td class="codeLine">      GlobalVariable *LookupTable) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">580</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeLine">    LLVMContext &Ctx = M.getContext();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">581</td>
    <td class="codeLine">    LLVMContext &Ctx = M.getContext();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeLine">    IRBuilder<> Builder(Ctx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">582</td>
    <td class="codeLine">    IRBuilder<> Builder(Ctx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeLine">    Type *I32 = Type::getInt32Ty(Ctx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">583</td>
    <td class="codeLine">    Type *I32 = Type::getInt32Ty(Ctx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">584</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeLine">    for (size_t Index = 0; Index < ModuleScopeVariables.size(); Index++) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">585</td>
    <td class="codeLine">    for (size_t Index = 0; Index < ModuleScopeVariables.size(); Index++) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeLine">      auto *GV = ModuleScopeVariables[Index];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">586</td>
    <td class="codeLine">      auto *GV = ModuleScopeVariables[Index];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">587</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeLine">      for (Use &U : make_early_inc_range(GV->uses())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">588</td>
    <td class="codeLine">      for (Use &U : make_early_inc_range(GV->uses())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeLine">        auto *I = dyn_cast<Instruction>(U.getUser());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">589</td>
    <td class="codeLine">        auto *I = dyn_cast<Instruction>(U.getUser());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeLine">        if (!I)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">590</td>
    <td class="codeLine">        if (!I)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">591</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">592</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeLine">        replaceUseWithTableLookup(M, Builder, LookupTable, GV, U,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">593</td>
    <td class="codeLine">        replaceUseWithTableLookup(M, Builder, LookupTable, GV, U,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeLine">                                  ConstantInt::get(I32, Index));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">594</td>
    <td class="codeLine">                                  ConstantInt::get(I32, Index));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">595</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">596</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">597</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">598</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeLine">  static DenseSet<Function *> kernelsThatIndirectlyAccessAnyOfPassedVariables(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">599</td>
    <td class="codeLine">  static DenseSet<Function *> kernelsThatIndirectlyAccessAnyOfPassedVariables(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeLine">      Module &M, LDSUsesInfoTy &LDSUsesInfo,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">600</td>
    <td class="codeLine">      Module &M, LDSUsesInfoTy &LDSUsesInfo,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeLine">      DenseSet<GlobalVariable *> const &VariableSet) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">601</td>
    <td class="codeLine">      DenseSet<GlobalVariable *> const &VariableSet) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">602</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeLine">    DenseSet<Function *> KernelSet;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">603</td>
    <td class="codeLine">    DenseSet<Function *> KernelSet;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">604</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeLine">    if (VariableSet.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">605</td>
    <td class="codeLine">    if (VariableSet.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeLine">      return KernelSet;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">606</td>
    <td class="codeLine">      return KernelSet;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">607</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeLine">    for (Function &Func : M.functions()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">608</td>
    <td class="codeLine">    for (Function &Func : M.functions()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeLine">      if (Func.isDeclaration() || !isKernelLDS(&Func))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">609</td>
    <td class="codeLine">      if (Func.isDeclaration() || !isKernelLDS(&Func))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">610</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeLine">      for (GlobalVariable *GV : LDSUsesInfo.indirect_access[&Func]) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">611</td>
    <td class="codeLine">      for (GlobalVariable *GV : LDSUsesInfo.indirect_access[&Func]) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeLine">        if (VariableSet.contains(GV)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">612</td>
    <td class="codeLine">        if (VariableSet.contains(GV)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeLine">          KernelSet.insert(&Func);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">613</td>
    <td class="codeLine">          KernelSet.insert(&Func);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeLine">          break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">614</td>
    <td class="codeLine">          break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">615</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">616</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">617</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">618</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeLine">    return KernelSet;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">619</td>
    <td class="codeLine">    return KernelSet;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">620</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">621</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeLine">  static GlobalVariable *</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">622</td>
    <td class="codeLine">  static GlobalVariable *</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeLine">  chooseBestVariableForModuleStrategy(const DataLayout &DL,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">623</td>
    <td class="codeLine">  chooseBestVariableForModuleStrategy(const DataLayout &DL,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeLine">                                      VariableFunctionMap &LDSVars) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">624</td>
    <td class="codeLine">                                      VariableFunctionMap &LDSVars) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeLine">    // Find the global variable with the most indirect uses from kernels</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">625</td>
    <td class="codeLine">    // Find the global variable with the most indirect uses from kernels</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">626</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeLine">    struct CandidateTy {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">627</td>
    <td class="codeLine">    struct CandidateTy {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeLine">      GlobalVariable *GV = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">628</td>
    <td class="codeLine">      GlobalVariable *GV = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeLine">      size_t UserCount = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">629</td>
    <td class="codeLine">      size_t UserCount = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeLine">      size_t Size = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">630</td>
    <td class="codeLine">      size_t Size = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">631</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeLine">      CandidateTy() = default;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">632</td>
    <td class="codeLine">      CandidateTy() = default;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">633</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeLine">      CandidateTy(GlobalVariable *GV, uint64_t UserCount, uint64_t AllocSize)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">634</td>
    <td class="codeLine">      CandidateTy(GlobalVariable *GV, uint64_t UserCount, uint64_t AllocSize)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeLine">          : GV(GV), UserCount(UserCount), Size(AllocSize) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">635</td>
    <td class="codeLine">          : GV(GV), UserCount(UserCount), Size(AllocSize) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">636</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeLine">      bool operator<(const CandidateTy &Other) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">637</td>
    <td class="codeLine">      bool operator<(const CandidateTy &Other) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeLine">        // Fewer users makes module scope variable less attractive</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">638</td>
    <td class="codeLine">        // Fewer users makes module scope variable less attractive</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeLine">        if (UserCount < Other.UserCount) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">639</td>
    <td class="codeLine">        if (UserCount < Other.UserCount) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeLine">          return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">640</td>
    <td class="codeLine">          return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">641</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeLine">        if (UserCount > Other.UserCount) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">642</td>
    <td class="codeLine">        if (UserCount > Other.UserCount) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeLine">          return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">643</td>
    <td class="codeLine">          return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">644</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">645</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeLine">        // Bigger makes module scope variable less attractive</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">646</td>
    <td class="codeLine">        // Bigger makes module scope variable less attractive</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeLine">        if (Size < Other.Size) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">647</td>
    <td class="codeLine">        if (Size < Other.Size) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeLine">          return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">648</td>
    <td class="codeLine">          return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">649</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">650</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeLine">        if (Size > Other.Size) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">651</td>
    <td class="codeLine">        if (Size > Other.Size) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeLine">          return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">652</td>
    <td class="codeLine">          return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">653</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">654</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeLine">        // Arbitrary but consistent</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">655</td>
    <td class="codeLine">        // Arbitrary but consistent</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeLine">        return GV->getName() < Other.GV->getName();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">656</td>
    <td class="codeLine">        return GV->getName() < Other.GV->getName();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">657</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">658</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">659</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeLine">    CandidateTy MostUsed;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">660</td>
    <td class="codeLine">    CandidateTy MostUsed;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">661</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeLine">    for (auto &K : LDSVars) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">662</td>
    <td class="codeLine">    for (auto &K : LDSVars) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeLine">      GlobalVariable *GV = K.first;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">663</td>
    <td class="codeLine">      GlobalVariable *GV = K.first;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeLine">      if (K.second.size() <= 1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">664</td>
    <td class="codeLine">      if (K.second.size() <= 1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeLine">        // A variable reachable by only one kernel is best lowered with kernel</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">665</td>
    <td class="codeLine">        // A variable reachable by only one kernel is best lowered with kernel</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeLine">        // strategy</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">666</td>
    <td class="codeLine">        // strategy</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">667</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">668</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeLine">      CandidateTy Candidate(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">669</td>
    <td class="codeLine">      CandidateTy Candidate(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeLine">          GV, K.second.size(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">670</td>
    <td class="codeLine">          GV, K.second.size(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeLine">          DL.getTypeAllocSize(GV->getValueType()).getFixedValue());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">671</td>
    <td class="codeLine">          DL.getTypeAllocSize(GV->getValueType()).getFixedValue());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeLine">      if (MostUsed < Candidate)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">672</td>
    <td class="codeLine">      if (MostUsed < Candidate)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeLine">        MostUsed = Candidate;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">673</td>
    <td class="codeLine">        MostUsed = Candidate;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">674</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">675</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeLine">    return MostUsed.GV;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">676</td>
    <td class="codeLine">    return MostUsed.GV;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">677</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">678</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeLine">  static void recordLDSAbsoluteAddress(Module *M, GlobalVariable *GV,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">679</td>
    <td class="codeLine">  static void recordLDSAbsoluteAddress(Module *M, GlobalVariable *GV,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeLine">                                       uint32_t Address) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">680</td>
    <td class="codeLine">                                       uint32_t Address) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeLine">    // Write the specified address into metadata where it can be retrieved by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">681</td>
    <td class="codeLine">    // Write the specified address into metadata where it can be retrieved by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeLine">    // the assembler. Format is a half open range, [Address Address+1)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">682</td>
    <td class="codeLine">    // the assembler. Format is a half open range, [Address Address+1)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeLine">    LLVMContext &Ctx = M->getContext();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">683</td>
    <td class="codeLine">    LLVMContext &Ctx = M->getContext();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeLine">    auto *IntTy =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">684</td>
    <td class="codeLine">    auto *IntTy =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeLine">        M->getDataLayout().getIntPtrType(Ctx, AMDGPUAS::LOCAL_ADDRESS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">685</td>
    <td class="codeLine">        M->getDataLayout().getIntPtrType(Ctx, AMDGPUAS::LOCAL_ADDRESS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeLine">    auto *MinC = ConstantAsMetadata::get(ConstantInt::get(IntTy, Address));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">686</td>
    <td class="codeLine">    auto *MinC = ConstantAsMetadata::get(ConstantInt::get(IntTy, Address));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeLine">    auto *MaxC = ConstantAsMetadata::get(ConstantInt::get(IntTy, Address + 1));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">687</td>
    <td class="codeLine">    auto *MaxC = ConstantAsMetadata::get(ConstantInt::get(IntTy, Address + 1));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeLine">    GV->setMetadata(LLVMContext::MD_absolute_symbol,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">688</td>
    <td class="codeLine">    GV->setMetadata(LLVMContext::MD_absolute_symbol,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeLine">                    MDNode::get(Ctx, {MinC, MaxC}));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">689</td>
    <td class="codeLine">                    MDNode::get(Ctx, {MinC, MaxC}));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">690</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">691</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeLine">  DenseMap<Function *, Value *> tableKernelIndexCache;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">692</td>
    <td class="codeLine">  DenseMap<Function *, Value *> tableKernelIndexCache;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeLine">  Value *getTableLookupKernelIndex(Module &M, Function *F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">693</td>
    <td class="codeLine">  Value *getTableLookupKernelIndex(Module &M, Function *F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeLine">    // Accesses from a function use the amdgcn_lds_kernel_id intrinsic which</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">694</td>
    <td class="codeLine">    // Accesses from a function use the amdgcn_lds_kernel_id intrinsic which</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeLine">    // lowers to a read from a live in register. Emit it once in the entry</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">695</td>
    <td class="codeLine">    // lowers to a read from a live in register. Emit it once in the entry</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeLine">    // block to spare deduplicating it later.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">696</td>
    <td class="codeLine">    // block to spare deduplicating it later.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeLine">    auto [It, Inserted] = tableKernelIndexCache.try_emplace(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">697</td>
    <td class="codeLine">    auto [It, Inserted] = tableKernelIndexCache.try_emplace(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeLine">    if (Inserted) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">698</td>
    <td class="codeLine">    if (Inserted) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeLine">      Function *Decl =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">699</td>
    <td class="codeLine">      Function *Decl =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeLine">          Intrinsic::getDeclaration(&M, Intrinsic::amdgcn_lds_kernel_id, {});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">700</td>
    <td class="codeLine">          Intrinsic::getDeclaration(&M, Intrinsic::amdgcn_lds_kernel_id, {});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">701</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeLine">      auto InsertAt = F->getEntryBlock().getFirstNonPHIOrDbgOrAlloca();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">702</td>
    <td class="codeLine">      auto InsertAt = F->getEntryBlock().getFirstNonPHIOrDbgOrAlloca();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeLine">      IRBuilder<> Builder(&*InsertAt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">703</td>
    <td class="codeLine">      IRBuilder<> Builder(&*InsertAt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">704</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeLine">      It->second = Builder.CreateCall(Decl, {});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">705</td>
    <td class="codeLine">      It->second = Builder.CreateCall(Decl, {});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">706</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">707</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeLine">    return It->second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">708</td>
    <td class="codeLine">    return It->second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">709</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">710</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeLine">  static std::vector<Function *> assignLDSKernelIDToEachKernel(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">711</td>
    <td class="codeLine">  static std::vector<Function *> assignLDSKernelIDToEachKernel(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeLine">      Module *M, DenseSet<Function *> const &KernelsThatAllocateTableLDS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">712</td>
    <td class="codeLine">      Module *M, DenseSet<Function *> const &KernelsThatAllocateTableLDS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeLine">      DenseSet<Function *> const &KernelsThatIndirectlyAllocateDynamicLDS) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">713</td>
    <td class="codeLine">      DenseSet<Function *> const &KernelsThatIndirectlyAllocateDynamicLDS) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeLine">    // Associate kernels in the set with an arbirary but reproducible order and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">714</td>
    <td class="codeLine">    // Associate kernels in the set with an arbirary but reproducible order and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeLine">    // annotate them with that order in metadata. This metadata is recognised by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">715</td>
    <td class="codeLine">    // annotate them with that order in metadata. This metadata is recognised by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeLine">    // the backend and lowered to a SGPR which can be read from using</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">716</td>
    <td class="codeLine">    // the backend and lowered to a SGPR which can be read from using</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeLine">    // amdgcn_lds_kernel_id.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">717</td>
    <td class="codeLine">    // amdgcn_lds_kernel_id.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">718</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeLine">    std::vector<Function *> OrderedKernels;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">719</td>
    <td class="codeLine">    std::vector<Function *> OrderedKernels;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeLine">    if (!KernelsThatAllocateTableLDS.empty() ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">720</td>
    <td class="codeLine">    if (!KernelsThatAllocateTableLDS.empty() ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeLine">        !KernelsThatIndirectlyAllocateDynamicLDS.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">721</td>
    <td class="codeLine">        !KernelsThatIndirectlyAllocateDynamicLDS.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">722</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeLine">      for (Function &Func : M->functions()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">723</td>
    <td class="codeLine">      for (Function &Func : M->functions()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeLine">        if (Func.isDeclaration())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">724</td>
    <td class="codeLine">        if (Func.isDeclaration())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">725</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeLine">        if (!isKernelLDS(&Func))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">726</td>
    <td class="codeLine">        if (!isKernelLDS(&Func))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">727</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">728</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeLine">        if (KernelsThatAllocateTableLDS.contains(&Func) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">729</td>
    <td class="codeLine">        if (KernelsThatAllocateTableLDS.contains(&Func) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeLine">            KernelsThatIndirectlyAllocateDynamicLDS.contains(&Func)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">730</td>
    <td class="codeLine">            KernelsThatIndirectlyAllocateDynamicLDS.contains(&Func)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeLine">          assert(Func.hasName()); // else fatal error earlier</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">731</td>
    <td class="codeLine">          assert(Func.hasName()); // else fatal error earlier</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeLine">          OrderedKernels.push_back(&Func);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">732</td>
    <td class="codeLine">          OrderedKernels.push_back(&Func);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">733</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">734</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">735</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeLine">      // Put them in an arbitrary but reproducible order</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">736</td>
    <td class="codeLine">      // Put them in an arbitrary but reproducible order</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeLine">      OrderedKernels = sortByName(std::move(OrderedKernels));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">737</td>
    <td class="codeLine">      OrderedKernels = sortByName(std::move(OrderedKernels));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">738</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeLine">      // Annotate the kernels with their order in this vector</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">739</td>
    <td class="codeLine">      // Annotate the kernels with their order in this vector</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeLine">      LLVMContext &Ctx = M->getContext();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">740</td>
    <td class="codeLine">      LLVMContext &Ctx = M->getContext();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeLine">      IRBuilder<> Builder(Ctx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">741</td>
    <td class="codeLine">      IRBuilder<> Builder(Ctx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">742</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeLine">      if (OrderedKernels.size() > UINT32_MAX) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">743</td>
    <td class="codeLine">      if (OrderedKernels.size() > UINT32_MAX) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeLine">        // 32 bit keeps it in one SGPR. > 2**32 kernels won't fit on the GPU</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">744</td>
    <td class="codeLine">        // 32 bit keeps it in one SGPR. > 2**32 kernels won't fit on the GPU</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeLine">        report_fatal_error("Unimplemented LDS lowering for > 2**32 kernels");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">745</td>
    <td class="codeLine">        report_fatal_error("Unimplemented LDS lowering for > 2**32 kernels");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">746</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">747</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeLine">      for (size_t i = 0; i < OrderedKernels.size(); i++) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">748</td>
    <td class="codeLine">      for (size_t i = 0; i < OrderedKernels.size(); i++) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeLine">        Metadata *AttrMDArgs[1] = {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">749</td>
    <td class="codeLine">        Metadata *AttrMDArgs[1] = {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeLine">            ConstantAsMetadata::get(Builder.getInt32(i)),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">750</td>
    <td class="codeLine">            ConstantAsMetadata::get(Builder.getInt32(i)),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeLine">        };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">751</td>
    <td class="codeLine">        };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeLine">        OrderedKernels[i]->setMetadata("llvm.amdgcn.lds.kernel.id",</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">752</td>
    <td class="codeLine">        OrderedKernels[i]->setMetadata("llvm.amdgcn.lds.kernel.id",</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeLine">                                       MDNode::get(Ctx, AttrMDArgs));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">753</td>
    <td class="codeLine">                                       MDNode::get(Ctx, AttrMDArgs));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">754</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">755</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeLine">    return OrderedKernels;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">756</td>
    <td class="codeLine">    return OrderedKernels;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">757</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">758</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeLine">  static void partitionVariablesIntoIndirectStrategies(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">759</td>
    <td class="codeLine">  static void partitionVariablesIntoIndirectStrategies(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeLine">      Module &M, LDSUsesInfoTy const &LDSUsesInfo,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">760</td>
    <td class="codeLine">      Module &M, LDSUsesInfoTy const &LDSUsesInfo,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeLine">      VariableFunctionMap &LDSToKernelsThatNeedToAccessItIndirectly,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">761</td>
    <td class="codeLine">      VariableFunctionMap &LDSToKernelsThatNeedToAccessItIndirectly,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeLine">      DenseSet<GlobalVariable *> &ModuleScopeVariables,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">762</td>
    <td class="codeLine">      DenseSet<GlobalVariable *> &ModuleScopeVariables,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeLine">      DenseSet<GlobalVariable *> &TableLookupVariables,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">763</td>
    <td class="codeLine">      DenseSet<GlobalVariable *> &TableLookupVariables,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeLine">      DenseSet<GlobalVariable *> &KernelAccessVariables,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">764</td>
    <td class="codeLine">      DenseSet<GlobalVariable *> &KernelAccessVariables,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeLine">      DenseSet<GlobalVariable *> &DynamicVariables) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">765</td>
    <td class="codeLine">      DenseSet<GlobalVariable *> &DynamicVariables) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">766</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeLine">    GlobalVariable *HybridModuleRoot =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">767</td>
    <td class="codeLine">    GlobalVariable *HybridModuleRoot =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeLine">        LoweringKindLoc != LoweringKind::hybrid</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">768</td>
    <td class="codeLine">        LoweringKindLoc != LoweringKind::hybrid</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeLine">            ? nullptr</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">769</td>
    <td class="codeLine">            ? nullptr</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeLine">            : chooseBestVariableForModuleStrategy(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">770</td>
    <td class="codeLine">            : chooseBestVariableForModuleStrategy(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeLine">                  M.getDataLayout(), LDSToKernelsThatNeedToAccessItIndirectly);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">771</td>
    <td class="codeLine">                  M.getDataLayout(), LDSToKernelsThatNeedToAccessItIndirectly);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">772</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeLine">    DenseSet<Function *> const EmptySet;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">773</td>
    <td class="codeLine">    DenseSet<Function *> const EmptySet;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeLine">    DenseSet<Function *> const &HybridModuleRootKernels =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">774</td>
    <td class="codeLine">    DenseSet<Function *> const &HybridModuleRootKernels =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeLine">        HybridModuleRoot</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">775</td>
    <td class="codeLine">        HybridModuleRoot</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeLine">            ? LDSToKernelsThatNeedToAccessItIndirectly[HybridModuleRoot]</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">776</td>
    <td class="codeLine">            ? LDSToKernelsThatNeedToAccessItIndirectly[HybridModuleRoot]</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeLine">            : EmptySet;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">777</td>
    <td class="codeLine">            : EmptySet;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">778</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeLine">    for (auto &K : LDSToKernelsThatNeedToAccessItIndirectly) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">779</td>
    <td class="codeLine">    for (auto &K : LDSToKernelsThatNeedToAccessItIndirectly) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeLine">      // Each iteration of this loop assigns exactly one global variable to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">780</td>
    <td class="codeLine">      // Each iteration of this loop assigns exactly one global variable to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeLine">      // exactly one of the implementation strategies.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">781</td>
    <td class="codeLine">      // exactly one of the implementation strategies.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">782</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeLine">      GlobalVariable *GV = K.first;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">783</td>
    <td class="codeLine">      GlobalVariable *GV = K.first;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeLine">      assert(AMDGPU::isLDSVariableToLower(*GV));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">784</td>
    <td class="codeLine">      assert(AMDGPU::isLDSVariableToLower(*GV));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeLine">      assert(K.second.size() != 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">785</td>
    <td class="codeLine">      assert(K.second.size() != 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">786</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeLine">      if (AMDGPU::isDynamicLDS(*GV)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">787</td>
    <td class="codeLine">      if (AMDGPU::isDynamicLDS(*GV)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeLine">        DynamicVariables.insert(GV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">788</td>
    <td class="codeLine">        DynamicVariables.insert(GV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">789</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">790</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">791</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeLine">      switch (LoweringKindLoc) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">792</td>
    <td class="codeLine">      switch (LoweringKindLoc) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeLine">      case LoweringKind::module:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">793</td>
    <td class="codeLine">      case LoweringKind::module:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeLine">        ModuleScopeVariables.insert(GV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">794</td>
    <td class="codeLine">        ModuleScopeVariables.insert(GV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">795</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">796</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeLine">      case LoweringKind::table:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">797</td>
    <td class="codeLine">      case LoweringKind::table:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeLine">        TableLookupVariables.insert(GV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">798</td>
    <td class="codeLine">        TableLookupVariables.insert(GV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">799</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">800</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeLine">      case LoweringKind::kernel:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">801</td>
    <td class="codeLine">      case LoweringKind::kernel:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeLine">        if (K.second.size() == 1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">802</td>
    <td class="codeLine">        if (K.second.size() == 1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeLine">          KernelAccessVariables.insert(GV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">803</td>
    <td class="codeLine">          KernelAccessVariables.insert(GV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeLine">        } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">804</td>
    <td class="codeLine">        } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeLine">          report_fatal_error(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">805</td>
    <td class="codeLine">          report_fatal_error(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeLine">              "cannot lower LDS '" + GV->getName() +</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">806</td>
    <td class="codeLine">              "cannot lower LDS '" + GV->getName() +</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeLine">              "' to kernel access as it is reachable from multiple kernels");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">807</td>
    <td class="codeLine">              "' to kernel access as it is reachable from multiple kernels");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">808</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">809</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">810</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeLine">      case LoweringKind::hybrid: {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">811</td>
    <td class="codeLine">      case LoweringKind::hybrid: {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeLine">        if (GV == HybridModuleRoot) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">812</td>
    <td class="codeLine">        if (GV == HybridModuleRoot) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeLine">          assert(K.second.size() != 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">813</td>
    <td class="codeLine">          assert(K.second.size() != 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeLine">          ModuleScopeVariables.insert(GV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">814</td>
    <td class="codeLine">          ModuleScopeVariables.insert(GV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeLine">        } else if (K.second.size() == 1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">815</td>
    <td class="codeLine">        } else if (K.second.size() == 1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeLine">          KernelAccessVariables.insert(GV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">816</td>
    <td class="codeLine">          KernelAccessVariables.insert(GV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeLine">        } else if (set_is_subset(K.second, HybridModuleRootKernels)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">817</td>
    <td class="codeLine">        } else if (set_is_subset(K.second, HybridModuleRootKernels)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeLine">          ModuleScopeVariables.insert(GV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">818</td>
    <td class="codeLine">          ModuleScopeVariables.insert(GV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeLine">        } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">819</td>
    <td class="codeLine">        } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeLine">          TableLookupVariables.insert(GV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">820</td>
    <td class="codeLine">          TableLookupVariables.insert(GV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">821</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">822</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">823</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">824</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">825</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">826</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeLine">    // All LDS variables accessed indirectly have now been partitioned into</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">827</td>
    <td class="codeLine">    // All LDS variables accessed indirectly have now been partitioned into</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeLine">    // the distinct lowering strategies.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">828</td>
    <td class="codeLine">    // the distinct lowering strategies.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeLine">    assert(ModuleScopeVariables.size() + TableLookupVariables.size() +</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">829</td>
    <td class="codeLine">    assert(ModuleScopeVariables.size() + TableLookupVariables.size() +</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeLine">               KernelAccessVariables.size() + DynamicVariables.size() ==</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">830</td>
    <td class="codeLine">               KernelAccessVariables.size() + DynamicVariables.size() ==</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeLine">           LDSToKernelsThatNeedToAccessItIndirectly.size());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">831</td>
    <td class="codeLine">           LDSToKernelsThatNeedToAccessItIndirectly.size());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">832</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">833</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeLine">  static GlobalVariable *lowerModuleScopeStructVariables(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">834</td>
    <td class="codeLine">  static GlobalVariable *lowerModuleScopeStructVariables(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeLine">      Module &M, DenseSet<GlobalVariable *> const &ModuleScopeVariables,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">835</td>
    <td class="codeLine">      Module &M, DenseSet<GlobalVariable *> const &ModuleScopeVariables,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeLine">      DenseSet<Function *> const &KernelsThatAllocateModuleLDS) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">836</td>
    <td class="codeLine">      DenseSet<Function *> const &KernelsThatAllocateModuleLDS) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeLine">    // Create a struct to hold the ModuleScopeVariables</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">837</td>
    <td class="codeLine">    // Create a struct to hold the ModuleScopeVariables</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeLine">    // Replace all uses of those variables from non-kernel functions with the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">838</td>
    <td class="codeLine">    // Replace all uses of those variables from non-kernel functions with the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeLine">    // new struct instance Replace only the uses from kernel functions that will</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">839</td>
    <td class="codeLine">    // new struct instance Replace only the uses from kernel functions that will</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeLine">    // allocate this instance. That is a space optimisation - kernels that use a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">840</td>
    <td class="codeLine">    // allocate this instance. That is a space optimisation - kernels that use a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeLine">    // subset of the module scope struct and do not need to allocate it for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">841</td>
    <td class="codeLine">    // subset of the module scope struct and do not need to allocate it for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeLine">    // indirect calls will only allocate the subset they use (they do so as part</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">842</td>
    <td class="codeLine">    // indirect calls will only allocate the subset they use (they do so as part</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeLine">    // of the per-kernel lowering).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">843</td>
    <td class="codeLine">    // of the per-kernel lowering).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeLine">    if (ModuleScopeVariables.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">844</td>
    <td class="codeLine">    if (ModuleScopeVariables.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeLine">      return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">845</td>
    <td class="codeLine">      return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">846</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">847</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeLine">    LLVMContext &Ctx = M.getContext();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">848</td>
    <td class="codeLine">    LLVMContext &Ctx = M.getContext();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">849</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeLine">    LDSVariableReplacement ModuleScopeReplacement =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">850</td>
    <td class="codeLine">    LDSVariableReplacement ModuleScopeReplacement =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeLine">        createLDSVariableReplacement(M, "llvm.amdgcn.module.lds",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">851</td>
    <td class="codeLine">        createLDSVariableReplacement(M, "llvm.amdgcn.module.lds",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeLine">                                     ModuleScopeVariables);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">852</td>
    <td class="codeLine">                                     ModuleScopeVariables);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">853</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeLine">    appendToCompilerUsed(M, {static_cast<GlobalValue *>(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">854</td>
    <td class="codeLine">    appendToCompilerUsed(M, {static_cast<GlobalValue *>(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeLine">                                ConstantExpr::getPointerBitCastOrAddrSpaceCast(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">855</td>
    <td class="codeLine">                                ConstantExpr::getPointerBitCastOrAddrSpaceCast(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeLine">                                    cast<Constant>(ModuleScopeReplacement.SGV),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">856</td>
    <td class="codeLine">                                    cast<Constant>(ModuleScopeReplacement.SGV),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeLine">                                    Type::getInt8PtrTy(Ctx)))});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">857</td>
    <td class="codeLine">                                    Type::getInt8PtrTy(Ctx)))});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">858</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeLine">    // module.lds will be allocated at zero in any kernel that allocates it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">859</td>
    <td class="codeLine">    // module.lds will be allocated at zero in any kernel that allocates it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeLine">    recordLDSAbsoluteAddress(&M, ModuleScopeReplacement.SGV, 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">860</td>
    <td class="codeLine">    recordLDSAbsoluteAddress(&M, ModuleScopeReplacement.SGV, 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">861</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeLine">    // historic</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">862</td>
    <td class="codeLine">    // historic</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeLine">    removeLocalVarsFromUsedLists(M, ModuleScopeVariables);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">863</td>
    <td class="codeLine">    removeLocalVarsFromUsedLists(M, ModuleScopeVariables);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">864</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeLine">    // Replace all uses of module scope variable from non-kernel functions</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">865</td>
    <td class="codeLine">    // Replace all uses of module scope variable from non-kernel functions</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeLine">    replaceLDSVariablesWithStruct(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">866</td>
    <td class="codeLine">    replaceLDSVariablesWithStruct(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeLine">        M, ModuleScopeVariables, ModuleScopeReplacement, [&](Use &U) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">867</td>
    <td class="codeLine">        M, ModuleScopeVariables, ModuleScopeReplacement, [&](Use &U) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeLine">          Instruction *I = dyn_cast<Instruction>(U.getUser());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">868</td>
    <td class="codeLine">          Instruction *I = dyn_cast<Instruction>(U.getUser());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeLine">          if (!I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">869</td>
    <td class="codeLine">          if (!I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeLine">            return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">870</td>
    <td class="codeLine">            return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">871</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeLine">          Function *F = I->getFunction();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">872</td>
    <td class="codeLine">          Function *F = I->getFunction();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeLine">          return !isKernelLDS(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">873</td>
    <td class="codeLine">          return !isKernelLDS(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeLine">        });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">874</td>
    <td class="codeLine">        });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">875</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeLine">    // Replace uses of module scope variable from kernel functions that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">876</td>
    <td class="codeLine">    // Replace uses of module scope variable from kernel functions that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeLine">    // allocate the module scope variable, otherwise leave them unchanged</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">877</td>
    <td class="codeLine">    // allocate the module scope variable, otherwise leave them unchanged</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeLine">    // Record on each kernel whether the module scope global is used by it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">878</td>
    <td class="codeLine">    // Record on each kernel whether the module scope global is used by it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">879</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeLine">    for (Function &Func : M.functions()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">880</td>
    <td class="codeLine">    for (Function &Func : M.functions()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeLine">      if (Func.isDeclaration() || !isKernelLDS(&Func))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">881</td>
    <td class="codeLine">      if (Func.isDeclaration() || !isKernelLDS(&Func))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">882</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">883</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeLine">      if (KernelsThatAllocateModuleLDS.contains(&Func)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">884</td>
    <td class="codeLine">      if (KernelsThatAllocateModuleLDS.contains(&Func)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeLine">        replaceLDSVariablesWithStruct(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">885</td>
    <td class="codeLine">        replaceLDSVariablesWithStruct(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeLine">            M, ModuleScopeVariables, ModuleScopeReplacement, [&](Use &U) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">886</td>
    <td class="codeLine">            M, ModuleScopeVariables, ModuleScopeReplacement, [&](Use &U) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeLine">              Instruction *I = dyn_cast<Instruction>(U.getUser());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">887</td>
    <td class="codeLine">              Instruction *I = dyn_cast<Instruction>(U.getUser());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeLine">              if (!I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">888</td>
    <td class="codeLine">              if (!I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeLine">                return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">889</td>
    <td class="codeLine">                return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeLine">              }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">890</td>
    <td class="codeLine">              }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeLine">              Function *F = I->getFunction();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">891</td>
    <td class="codeLine">              Function *F = I->getFunction();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeLine">              return F == &Func;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">892</td>
    <td class="codeLine">              return F == &Func;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeLine">            });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">893</td>
    <td class="codeLine">            });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">894</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeLine">        markUsedByKernel(&Func, ModuleScopeReplacement.SGV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">895</td>
    <td class="codeLine">        markUsedByKernel(&Func, ModuleScopeReplacement.SGV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">896</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">897</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">898</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeLine">    return ModuleScopeReplacement.SGV;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">899</td>
    <td class="codeLine">    return ModuleScopeReplacement.SGV;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">900</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">901</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeLine">  static DenseMap<Function *, LDSVariableReplacement></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">902</td>
    <td class="codeLine">  static DenseMap<Function *, LDSVariableReplacement></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeLine">  lowerKernelScopeStructVariables(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">903</td>
    <td class="codeLine">  lowerKernelScopeStructVariables(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeLine">      Module &M, LDSUsesInfoTy &LDSUsesInfo,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">904</td>
    <td class="codeLine">      Module &M, LDSUsesInfoTy &LDSUsesInfo,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeLine">      DenseSet<GlobalVariable *> const &ModuleScopeVariables,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">905</td>
    <td class="codeLine">      DenseSet<GlobalVariable *> const &ModuleScopeVariables,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeLine">      DenseSet<Function *> const &KernelsThatAllocateModuleLDS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">906</td>
    <td class="codeLine">      DenseSet<Function *> const &KernelsThatAllocateModuleLDS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeLine">      GlobalVariable *MaybeModuleScopeStruct) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">907</td>
    <td class="codeLine">      GlobalVariable *MaybeModuleScopeStruct) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">908</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeLine">    // Create a struct for each kernel for the non-module-scope variables.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">909</td>
    <td class="codeLine">    // Create a struct for each kernel for the non-module-scope variables.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">910</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeLine">    DenseMap<Function *, LDSVariableReplacement> KernelToReplacement;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">911</td>
    <td class="codeLine">    DenseMap<Function *, LDSVariableReplacement> KernelToReplacement;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeLine">    for (Function &Func : M.functions()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">912</td>
    <td class="codeLine">    for (Function &Func : M.functions()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeLine">      if (Func.isDeclaration() || !isKernelLDS(&Func))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">913</td>
    <td class="codeLine">      if (Func.isDeclaration() || !isKernelLDS(&Func))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">914</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">915</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeLine">      DenseSet<GlobalVariable *> KernelUsedVariables;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">916</td>
    <td class="codeLine">      DenseSet<GlobalVariable *> KernelUsedVariables;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeLine">      // Allocating variables that are used directly in this struct to get</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">917</td>
    <td class="codeLine">      // Allocating variables that are used directly in this struct to get</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeLine">      // alignment aware allocation and predictable frame size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">918</td>
    <td class="codeLine">      // alignment aware allocation and predictable frame size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeLine">      for (auto &v : LDSUsesInfo.direct_access[&Func]) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">919</td>
    <td class="codeLine">      for (auto &v : LDSUsesInfo.direct_access[&Func]) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeLine">        if (!AMDGPU::isDynamicLDS(*v)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">920</td>
    <td class="codeLine">        if (!AMDGPU::isDynamicLDS(*v)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeLine">          KernelUsedVariables.insert(v);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">921</td>
    <td class="codeLine">          KernelUsedVariables.insert(v);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">922</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">923</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">924</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeLine">      // Allocating variables that are accessed indirectly so that a lookup of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">925</td>
    <td class="codeLine">      // Allocating variables that are accessed indirectly so that a lookup of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeLine">      // this struct instance can find them from nested functions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">926</td>
    <td class="codeLine">      // this struct instance can find them from nested functions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeLine">      for (auto &v : LDSUsesInfo.indirect_access[&Func]) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">927</td>
    <td class="codeLine">      for (auto &v : LDSUsesInfo.indirect_access[&Func]) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeLine">        if (!AMDGPU::isDynamicLDS(*v)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">928</td>
    <td class="codeLine">        if (!AMDGPU::isDynamicLDS(*v)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeLine">          KernelUsedVariables.insert(v);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">929</td>
    <td class="codeLine">          KernelUsedVariables.insert(v);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">930</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">931</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">932</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeLine">      // Variables allocated in module lds must all resolve to that struct,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">933</td>
    <td class="codeLine">      // Variables allocated in module lds must all resolve to that struct,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeLine">      // not to the per-kernel instance.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">934</td>
    <td class="codeLine">      // not to the per-kernel instance.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeLine">      if (KernelsThatAllocateModuleLDS.contains(&Func)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">935</td>
    <td class="codeLine">      if (KernelsThatAllocateModuleLDS.contains(&Func)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeLine">        for (GlobalVariable *v : ModuleScopeVariables) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">936</td>
    <td class="codeLine">        for (GlobalVariable *v : ModuleScopeVariables) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeLine">          KernelUsedVariables.erase(v);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">937</td>
    <td class="codeLine">          KernelUsedVariables.erase(v);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">938</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">939</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">940</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeLine">      if (KernelUsedVariables.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">941</td>
    <td class="codeLine">      if (KernelUsedVariables.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeLine">        // Either used no LDS, or the LDS it used was all in the module struct</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">942</td>
    <td class="codeLine">        // Either used no LDS, or the LDS it used was all in the module struct</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeLine">        // or dynamically sized</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">943</td>
    <td class="codeLine">        // or dynamically sized</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">944</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">945</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">946</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeLine">      // The association between kernel function and LDS struct is done by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">947</td>
    <td class="codeLine">      // The association between kernel function and LDS struct is done by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeLine">      // symbol name, which only works if the function in question has a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">948</td>
    <td class="codeLine">      // symbol name, which only works if the function in question has a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeLine">      // name This is not expected to be a problem in practice as kernels</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">949</td>
    <td class="codeLine">      // name This is not expected to be a problem in practice as kernels</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeLine">      // are called by name making anonymous ones (which are named by the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">950</td>
    <td class="codeLine">      // are called by name making anonymous ones (which are named by the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeLine">      // backend) difficult to use. This does mean that llvm test cases need</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">951</td>
    <td class="codeLine">      // backend) difficult to use. This does mean that llvm test cases need</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeLine">      // to name the kernels.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">952</td>
    <td class="codeLine">      // to name the kernels.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeLine">      if (!Func.hasName()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">953</td>
    <td class="codeLine">      if (!Func.hasName()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeLine">        report_fatal_error("Anonymous kernels cannot use LDS variables");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">954</td>
    <td class="codeLine">        report_fatal_error("Anonymous kernels cannot use LDS variables");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">955</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">956</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeLine">      std::string VarName =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">957</td>
    <td class="codeLine">      std::string VarName =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeLine">          (Twine("llvm.amdgcn.kernel.") + Func.getName() + ".lds").str();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">958</td>
    <td class="codeLine">          (Twine("llvm.amdgcn.kernel.") + Func.getName() + ".lds").str();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">959</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeLine">      auto Replacement =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">960</td>
    <td class="codeLine">      auto Replacement =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeLine">          createLDSVariableReplacement(M, VarName, KernelUsedVariables);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">961</td>
    <td class="codeLine">          createLDSVariableReplacement(M, VarName, KernelUsedVariables);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">962</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeLine">      // If any indirect uses, create a direct use to ensure allocation</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">963</td>
    <td class="codeLine">      // If any indirect uses, create a direct use to ensure allocation</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeLine">      // TODO: Simpler to unconditionally mark used but that regresses</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">964</td>
    <td class="codeLine">      // TODO: Simpler to unconditionally mark used but that regresses</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeLine">      // codegen in test/CodeGen/AMDGPU/noclobber-barrier.ll</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">965</td>
    <td class="codeLine">      // codegen in test/CodeGen/AMDGPU/noclobber-barrier.ll</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeLine">      auto Accesses = LDSUsesInfo.indirect_access.find(&Func);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">966</td>
    <td class="codeLine">      auto Accesses = LDSUsesInfo.indirect_access.find(&Func);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeLine">      if ((Accesses != LDSUsesInfo.indirect_access.end()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">967</td>
    <td class="codeLine">      if ((Accesses != LDSUsesInfo.indirect_access.end()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeLine">          !Accesses->second.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">968</td>
    <td class="codeLine">          !Accesses->second.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeLine">        markUsedByKernel(&Func, Replacement.SGV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">969</td>
    <td class="codeLine">        markUsedByKernel(&Func, Replacement.SGV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">970</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeLine">      // remove preserves existing codegen</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">971</td>
    <td class="codeLine">      // remove preserves existing codegen</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeLine">      removeLocalVarsFromUsedLists(M, KernelUsedVariables);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">972</td>
    <td class="codeLine">      removeLocalVarsFromUsedLists(M, KernelUsedVariables);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeLine">      KernelToReplacement[&Func] = Replacement;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">973</td>
    <td class="codeLine">      KernelToReplacement[&Func] = Replacement;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">974</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeLine">      // Rewrite uses within kernel to the new struct</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">975</td>
    <td class="codeLine">      // Rewrite uses within kernel to the new struct</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeLine">      replaceLDSVariablesWithStruct(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">976</td>
    <td class="codeLine">      replaceLDSVariablesWithStruct(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeLine">          M, KernelUsedVariables, Replacement, [&Func](Use &U) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">977</td>
    <td class="codeLine">          M, KernelUsedVariables, Replacement, [&Func](Use &U) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeLine">            Instruction *I = dyn_cast<Instruction>(U.getUser());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">978</td>
    <td class="codeLine">            Instruction *I = dyn_cast<Instruction>(U.getUser());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeLine">            return I && I->getFunction() == &Func;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">979</td>
    <td class="codeLine">            return I && I->getFunction() == &Func;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeLine">          });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">980</td>
    <td class="codeLine">          });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">981</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeLine">    return KernelToReplacement;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">982</td>
    <td class="codeLine">    return KernelToReplacement;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">983</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">984</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeLine">  static GlobalVariable *</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">985</td>
    <td class="codeLine">  static GlobalVariable *</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeLine">  buildRepresentativeDynamicLDSInstance(Module &M, LDSUsesInfoTy &LDSUsesInfo,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">986</td>
    <td class="codeLine">  buildRepresentativeDynamicLDSInstance(Module &M, LDSUsesInfoTy &LDSUsesInfo,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeLine">                                        Function *func) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">987</td>
    <td class="codeLine">                                        Function *func) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeLine">    // Create a dynamic lds variable with a name associated with the passed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">988</td>
    <td class="codeLine">    // Create a dynamic lds variable with a name associated with the passed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeLine">    // function that has the maximum alignment of any dynamic lds variable</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">989</td>
    <td class="codeLine">    // function that has the maximum alignment of any dynamic lds variable</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeLine">    // reachable from this kernel. Dynamic LDS is allocated after the static LDS</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">990</td>
    <td class="codeLine">    // reachable from this kernel. Dynamic LDS is allocated after the static LDS</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeLine">    // allocation, possibly after alignment padding. The representative variable</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">991</td>
    <td class="codeLine">    // allocation, possibly after alignment padding. The representative variable</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeLine">    // created here has the maximum alignment of any other dynamic variable</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">992</td>
    <td class="codeLine">    // created here has the maximum alignment of any other dynamic variable</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeLine">    // reachable by that kernel. All dynamic LDS variables are allocated at the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">993</td>
    <td class="codeLine">    // reachable by that kernel. All dynamic LDS variables are allocated at the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeLine">    // same address in each kernel in order to provide the documented aliasing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">994</td>
    <td class="codeLine">    // same address in each kernel in order to provide the documented aliasing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeLine">    // semantics. Setting the alignment here allows this IR pass to accurately</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">995</td>
    <td class="codeLine">    // semantics. Setting the alignment here allows this IR pass to accurately</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeLine">    // predict the exact constant at which it will be allocated.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">996</td>
    <td class="codeLine">    // predict the exact constant at which it will be allocated.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">997</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeLine">    assert(isKernelLDS(func));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">998</td>
    <td class="codeLine">    assert(isKernelLDS(func));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">999</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeLine">    LLVMContext &Ctx = M.getContext();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1000</td>
    <td class="codeLine">    LLVMContext &Ctx = M.getContext();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeLine">    const DataLayout &DL = M.getDataLayout();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1001</td>
    <td class="codeLine">    const DataLayout &DL = M.getDataLayout();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeLine">    Align MaxDynamicAlignment(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1002</td>
    <td class="codeLine">    Align MaxDynamicAlignment(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1003</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeLine">    auto UpdateMaxAlignment = [&MaxDynamicAlignment, &DL](GlobalVariable *GV) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1004</td>
    <td class="codeLine">    auto UpdateMaxAlignment = [&MaxDynamicAlignment, &DL](GlobalVariable *GV) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeLine">      if (AMDGPU::isDynamicLDS(*GV)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1005</td>
    <td class="codeLine">      if (AMDGPU::isDynamicLDS(*GV)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeLine">        MaxDynamicAlignment =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1006</td>
    <td class="codeLine">        MaxDynamicAlignment =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeLine">            std::max(MaxDynamicAlignment, AMDGPU::getAlign(DL, GV));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1007</td>
    <td class="codeLine">            std::max(MaxDynamicAlignment, AMDGPU::getAlign(DL, GV));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1008</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1009</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1010</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeLine">    for (GlobalVariable *GV : LDSUsesInfo.indirect_access[func]) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1011</td>
    <td class="codeLine">    for (GlobalVariable *GV : LDSUsesInfo.indirect_access[func]) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeLine">      UpdateMaxAlignment(GV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1012</td>
    <td class="codeLine">      UpdateMaxAlignment(GV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1013</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1014</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeLine">    for (GlobalVariable *GV : LDSUsesInfo.direct_access[func]) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1015</td>
    <td class="codeLine">    for (GlobalVariable *GV : LDSUsesInfo.direct_access[func]) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeLine">      UpdateMaxAlignment(GV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1016</td>
    <td class="codeLine">      UpdateMaxAlignment(GV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1017</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1018</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeLine">    assert(func->hasName()); // Checked by caller</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1019</td>
    <td class="codeLine">    assert(func->hasName()); // Checked by caller</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeLine">    auto emptyCharArray = ArrayType::get(Type::getInt8Ty(Ctx), 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1020</td>
    <td class="codeLine">    auto emptyCharArray = ArrayType::get(Type::getInt8Ty(Ctx), 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeLine">    GlobalVariable *N = new GlobalVariable(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1021</td>
    <td class="codeLine">    GlobalVariable *N = new GlobalVariable(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeLine">        M, emptyCharArray, false, GlobalValue::ExternalLinkage, nullptr,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1022</td>
    <td class="codeLine">        M, emptyCharArray, false, GlobalValue::ExternalLinkage, nullptr,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeLine">        Twine("llvm.amdgcn." + func->getName() + ".dynlds"), nullptr, GlobalValue::NotThreadLocal, AMDGPUAS::LOCAL_ADDRESS,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1023</td>
    <td class="codeLine">        Twine("llvm.amdgcn." + func->getName() + ".dynlds"), nullptr, GlobalValue::NotThreadLocal, AMDGPUAS::LOCAL_ADDRESS,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeLine">        false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1024</td>
    <td class="codeLine">        false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeLine">    N->setAlignment(MaxDynamicAlignment);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1025</td>
    <td class="codeLine">    N->setAlignment(MaxDynamicAlignment);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1026</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeLine">    assert(AMDGPU::isDynamicLDS(*N));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1027</td>
    <td class="codeLine">    assert(AMDGPU::isDynamicLDS(*N));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeLine">    return N;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1028</td>
    <td class="codeLine">    return N;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1029</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1030</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeLine">  DenseMap<Function *, GlobalVariable *> lowerDynamicLDSVariables(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1031</td>
    <td class="codeLine">  DenseMap<Function *, GlobalVariable *> lowerDynamicLDSVariables(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeLine">      Module &M, LDSUsesInfoTy &LDSUsesInfo,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1032</td>
    <td class="codeLine">      Module &M, LDSUsesInfoTy &LDSUsesInfo,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeLine">      DenseSet<Function *> const &KernelsThatIndirectlyAllocateDynamicLDS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1033</td>
    <td class="codeLine">      DenseSet<Function *> const &KernelsThatIndirectlyAllocateDynamicLDS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeLine">      DenseSet<GlobalVariable *> const &DynamicVariables,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1034</td>
    <td class="codeLine">      DenseSet<GlobalVariable *> const &DynamicVariables,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeLine">      std::vector<Function *> const &OrderedKernels) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1035</td>
    <td class="codeLine">      std::vector<Function *> const &OrderedKernels) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeLine">    DenseMap<Function *, GlobalVariable *> KernelToCreatedDynamicLDS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1036</td>
    <td class="codeLine">    DenseMap<Function *, GlobalVariable *> KernelToCreatedDynamicLDS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeLine">    if (!KernelsThatIndirectlyAllocateDynamicLDS.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1037</td>
    <td class="codeLine">    if (!KernelsThatIndirectlyAllocateDynamicLDS.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeLine">      LLVMContext &Ctx = M.getContext();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1038</td>
    <td class="codeLine">      LLVMContext &Ctx = M.getContext();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeLine">      IRBuilder<> Builder(Ctx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1039</td>
    <td class="codeLine">      IRBuilder<> Builder(Ctx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeLine">      Type *I32 = Type::getInt32Ty(Ctx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1040</td>
    <td class="codeLine">      Type *I32 = Type::getInt32Ty(Ctx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1041</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeLine">      std::vector<Constant *> newDynamicLDS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1042</td>
    <td class="codeLine">      std::vector<Constant *> newDynamicLDS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1043</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeLine">      // Table is built in the same order as OrderedKernels</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1044</td>
    <td class="codeLine">      // Table is built in the same order as OrderedKernels</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeLine">      for (auto &func : OrderedKernels) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1045</td>
    <td class="codeLine">      for (auto &func : OrderedKernels) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1046</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeLine">        if (KernelsThatIndirectlyAllocateDynamicLDS.contains(func)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1047</td>
    <td class="codeLine">        if (KernelsThatIndirectlyAllocateDynamicLDS.contains(func)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeLine">          assert(isKernelLDS(func));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1048</td>
    <td class="codeLine">          assert(isKernelLDS(func));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeLine">          if (!func->hasName()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1049</td>
    <td class="codeLine">          if (!func->hasName()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeLine">            report_fatal_error("Anonymous kernels cannot use LDS variables");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1050</td>
    <td class="codeLine">            report_fatal_error("Anonymous kernels cannot use LDS variables");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1051</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1052</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeLine">          GlobalVariable *N =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1053</td>
    <td class="codeLine">          GlobalVariable *N =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeLine">              buildRepresentativeDynamicLDSInstance(M, LDSUsesInfo, func);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1054</td>
    <td class="codeLine">              buildRepresentativeDynamicLDSInstance(M, LDSUsesInfo, func);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1055</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeLine">          KernelToCreatedDynamicLDS[func] = N;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1056</td>
    <td class="codeLine">          KernelToCreatedDynamicLDS[func] = N;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1057</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeLine">          markUsedByKernel(func, N);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1058</td>
    <td class="codeLine">          markUsedByKernel(func, N);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1059</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeLine">          auto emptyCharArray = ArrayType::get(Type::getInt8Ty(Ctx), 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1060</td>
    <td class="codeLine">          auto emptyCharArray = ArrayType::get(Type::getInt8Ty(Ctx), 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeLine">          auto GEP = ConstantExpr::getGetElementPtr(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1061</td>
    <td class="codeLine">          auto GEP = ConstantExpr::getGetElementPtr(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeLine">              emptyCharArray, N, ConstantInt::get(I32, 0), true);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1062</td>
    <td class="codeLine">              emptyCharArray, N, ConstantInt::get(I32, 0), true);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeLine">          newDynamicLDS.push_back(ConstantExpr::getPtrToInt(GEP, I32));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1063</td>
    <td class="codeLine">          newDynamicLDS.push_back(ConstantExpr::getPtrToInt(GEP, I32));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeLine">        } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1064</td>
    <td class="codeLine">        } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeLine">          newDynamicLDS.push_back(PoisonValue::get(I32));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1065</td>
    <td class="codeLine">          newDynamicLDS.push_back(PoisonValue::get(I32));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1066</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1067</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeLine">      assert(OrderedKernels.size() == newDynamicLDS.size());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1068</td>
    <td class="codeLine">      assert(OrderedKernels.size() == newDynamicLDS.size());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1069</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeLine">      ArrayType *t = ArrayType::get(I32, newDynamicLDS.size());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1070</td>
    <td class="codeLine">      ArrayType *t = ArrayType::get(I32, newDynamicLDS.size());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeLine">      Constant *init = ConstantArray::get(t, newDynamicLDS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1071</td>
    <td class="codeLine">      Constant *init = ConstantArray::get(t, newDynamicLDS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeLine">      GlobalVariable *table = new GlobalVariable(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1072</td>
    <td class="codeLine">      GlobalVariable *table = new GlobalVariable(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeLine">          M, t, true, GlobalValue::InternalLinkage, init,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1073</td>
    <td class="codeLine">          M, t, true, GlobalValue::InternalLinkage, init,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeLine">          "llvm.amdgcn.dynlds.offset.table", nullptr,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1074</td>
    <td class="codeLine">          "llvm.amdgcn.dynlds.offset.table", nullptr,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeLine">          GlobalValue::NotThreadLocal, AMDGPUAS::CONSTANT_ADDRESS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1075</td>
    <td class="codeLine">          GlobalValue::NotThreadLocal, AMDGPUAS::CONSTANT_ADDRESS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1076</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeLine">      for (GlobalVariable *GV : DynamicVariables) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1077</td>
    <td class="codeLine">      for (GlobalVariable *GV : DynamicVariables) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeLine">        for (Use &U : make_early_inc_range(GV->uses())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1078</td>
    <td class="codeLine">        for (Use &U : make_early_inc_range(GV->uses())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeLine">          auto *I = dyn_cast<Instruction>(U.getUser());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1079</td>
    <td class="codeLine">          auto *I = dyn_cast<Instruction>(U.getUser());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeLine">          if (!I)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1080</td>
    <td class="codeLine">          if (!I)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeLine">            continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1081</td>
    <td class="codeLine">            continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeLine">          if (isKernelLDS(I->getFunction()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1082</td>
    <td class="codeLine">          if (isKernelLDS(I->getFunction()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeLine">            continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1083</td>
    <td class="codeLine">            continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1084</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeLine">          replaceUseWithTableLookup(M, Builder, table, GV, U, nullptr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1085</td>
    <td class="codeLine">          replaceUseWithTableLookup(M, Builder, table, GV, U, nullptr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1086</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1087</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1088</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeLine">    return KernelToCreatedDynamicLDS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1089</td>
    <td class="codeLine">    return KernelToCreatedDynamicLDS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1090</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1091</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeLine">  bool runOnModule(Module &M) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1092</td>
    <td class="codeLine">  bool runOnModule(Module &M) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeLine">    CallGraph CG = CallGraph(M);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1093</td>
    <td class="codeLine">    CallGraph CG = CallGraph(M);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeLine">    bool Changed = superAlignLDSGlobals(M);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1094</td>
    <td class="codeLine">    bool Changed = superAlignLDSGlobals(M);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1095</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeLine">    Changed |= eliminateConstantExprUsesOfLDSFromAllInstructions(M);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1096</td>
    <td class="codeLine">    Changed |= eliminateConstantExprUsesOfLDSFromAllInstructions(M);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1097</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeLine">    Changed = true; // todo: narrow this down</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1098</td>
    <td class="codeLine">    Changed = true; // todo: narrow this down</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1099</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeLine">    // For each kernel, what variables does it access directly or through</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1100</td>
    <td class="codeLine">    // For each kernel, what variables does it access directly or through</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeLine">    // callees</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1101</td>
    <td class="codeLine">    // callees</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeLine">    LDSUsesInfoTy LDSUsesInfo = getTransitiveUsesOfLDS(CG, M);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1102</td>
    <td class="codeLine">    LDSUsesInfoTy LDSUsesInfo = getTransitiveUsesOfLDS(CG, M);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1103</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeLine">    // For each variable accessed through callees, which kernels access it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1104</td>
    <td class="codeLine">    // For each variable accessed through callees, which kernels access it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeLine">    VariableFunctionMap LDSToKernelsThatNeedToAccessItIndirectly;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1105</td>
    <td class="codeLine">    VariableFunctionMap LDSToKernelsThatNeedToAccessItIndirectly;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeLine">    for (auto &K : LDSUsesInfo.indirect_access) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1106</td>
    <td class="codeLine">    for (auto &K : LDSUsesInfo.indirect_access) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeLine">      Function *F = K.first;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1107</td>
    <td class="codeLine">      Function *F = K.first;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeLine">      assert(isKernelLDS(F));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1108</td>
    <td class="codeLine">      assert(isKernelLDS(F));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeLine">      for (GlobalVariable *GV : K.second) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1109</td>
    <td class="codeLine">      for (GlobalVariable *GV : K.second) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeLine">        LDSToKernelsThatNeedToAccessItIndirectly[GV].insert(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1110</td>
    <td class="codeLine">        LDSToKernelsThatNeedToAccessItIndirectly[GV].insert(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1111</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1112</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1113</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeLine">    // Partition variables accessed indirectly into the different strategies</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1114</td>
    <td class="codeLine">    // Partition variables accessed indirectly into the different strategies</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeLine">    DenseSet<GlobalVariable *> ModuleScopeVariables;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1115</td>
    <td class="codeLine">    DenseSet<GlobalVariable *> ModuleScopeVariables;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeLine">    DenseSet<GlobalVariable *> TableLookupVariables;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1116</td>
    <td class="codeLine">    DenseSet<GlobalVariable *> TableLookupVariables;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeLine">    DenseSet<GlobalVariable *> KernelAccessVariables;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1117</td>
    <td class="codeLine">    DenseSet<GlobalVariable *> KernelAccessVariables;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeLine">    DenseSet<GlobalVariable *> DynamicVariables;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1118</td>
    <td class="codeLine">    DenseSet<GlobalVariable *> DynamicVariables;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeLine">    partitionVariablesIntoIndirectStrategies(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1119</td>
    <td class="codeLine">    partitionVariablesIntoIndirectStrategies(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeLine">        M, LDSUsesInfo, LDSToKernelsThatNeedToAccessItIndirectly,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1120</td>
    <td class="codeLine">        M, LDSUsesInfo, LDSToKernelsThatNeedToAccessItIndirectly,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeLine">        ModuleScopeVariables, TableLookupVariables, KernelAccessVariables,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1121</td>
    <td class="codeLine">        ModuleScopeVariables, TableLookupVariables, KernelAccessVariables,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeLine">        DynamicVariables);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1122</td>
    <td class="codeLine">        DynamicVariables);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1123</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeLine">    // If the kernel accesses a variable that is going to be stored in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1124</td>
    <td class="codeLine">    // If the kernel accesses a variable that is going to be stored in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeLine">    // module instance through a call then that kernel needs to allocate the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1125</td>
    <td class="codeLine">    // module instance through a call then that kernel needs to allocate the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeLine">    // module instance</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1126</td>
    <td class="codeLine">    // module instance</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeLine">    const DenseSet<Function *> KernelsThatAllocateModuleLDS =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1127</td>
    <td class="codeLine">    const DenseSet<Function *> KernelsThatAllocateModuleLDS =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeLine">        kernelsThatIndirectlyAccessAnyOfPassedVariables(M, LDSUsesInfo,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1128</td>
    <td class="codeLine">        kernelsThatIndirectlyAccessAnyOfPassedVariables(M, LDSUsesInfo,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeLine">                                                        ModuleScopeVariables);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1129</td>
    <td class="codeLine">                                                        ModuleScopeVariables);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeLine">    const DenseSet<Function *> KernelsThatAllocateTableLDS =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1130</td>
    <td class="codeLine">    const DenseSet<Function *> KernelsThatAllocateTableLDS =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeLine">        kernelsThatIndirectlyAccessAnyOfPassedVariables(M, LDSUsesInfo,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1131</td>
    <td class="codeLine">        kernelsThatIndirectlyAccessAnyOfPassedVariables(M, LDSUsesInfo,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeLine">                                                        TableLookupVariables);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1132</td>
    <td class="codeLine">                                                        TableLookupVariables);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1133</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeLine">    const DenseSet<Function *> KernelsThatIndirectlyAllocateDynamicLDS =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1134</td>
    <td class="codeLine">    const DenseSet<Function *> KernelsThatIndirectlyAllocateDynamicLDS =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeLine">        kernelsThatIndirectlyAccessAnyOfPassedVariables(M, LDSUsesInfo,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1135</td>
    <td class="codeLine">        kernelsThatIndirectlyAccessAnyOfPassedVariables(M, LDSUsesInfo,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeLine">                                                        DynamicVariables);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1136</td>
    <td class="codeLine">                                                        DynamicVariables);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1137</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeLine">    GlobalVariable *MaybeModuleScopeStruct = lowerModuleScopeStructVariables(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1138</td>
    <td class="codeLine">    GlobalVariable *MaybeModuleScopeStruct = lowerModuleScopeStructVariables(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeLine">        M, ModuleScopeVariables, KernelsThatAllocateModuleLDS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1139</td>
    <td class="codeLine">        M, ModuleScopeVariables, KernelsThatAllocateModuleLDS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1140</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeLine">    DenseMap<Function *, LDSVariableReplacement> KernelToReplacement =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1141</td>
    <td class="codeLine">    DenseMap<Function *, LDSVariableReplacement> KernelToReplacement =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeLine">        lowerKernelScopeStructVariables(M, LDSUsesInfo, ModuleScopeVariables,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1142</td>
    <td class="codeLine">        lowerKernelScopeStructVariables(M, LDSUsesInfo, ModuleScopeVariables,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeLine">                                        KernelsThatAllocateModuleLDS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1143</td>
    <td class="codeLine">                                        KernelsThatAllocateModuleLDS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeLine">                                        MaybeModuleScopeStruct);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1144</td>
    <td class="codeLine">                                        MaybeModuleScopeStruct);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1145</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeLine">    // Lower zero cost accesses to the kernel instances just created</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1146</td>
    <td class="codeLine">    // Lower zero cost accesses to the kernel instances just created</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeLine">    for (auto &GV : KernelAccessVariables) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1147</td>
    <td class="codeLine">    for (auto &GV : KernelAccessVariables) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeLine">      auto &funcs = LDSToKernelsThatNeedToAccessItIndirectly[GV];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1148</td>
    <td class="codeLine">      auto &funcs = LDSToKernelsThatNeedToAccessItIndirectly[GV];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeLine">      assert(funcs.size() == 1); // Only one kernel can access it</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1149</td>
    <td class="codeLine">      assert(funcs.size() == 1); // Only one kernel can access it</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeLine">      LDSVariableReplacement Replacement =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1150</td>
    <td class="codeLine">      LDSVariableReplacement Replacement =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeLine">          KernelToReplacement[*(funcs.begin())];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1151</td>
    <td class="codeLine">          KernelToReplacement[*(funcs.begin())];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1152</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeLine">      DenseSet<GlobalVariable *> Vec;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1153</td>
    <td class="codeLine">      DenseSet<GlobalVariable *> Vec;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeLine">      Vec.insert(GV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1154</td>
    <td class="codeLine">      Vec.insert(GV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1155</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeLine">      replaceLDSVariablesWithStruct(M, Vec, Replacement, [](Use &U) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1156</td>
    <td class="codeLine">      replaceLDSVariablesWithStruct(M, Vec, Replacement, [](Use &U) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeLine">        return isa<Instruction>(U.getUser());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1157</td>
    <td class="codeLine">        return isa<Instruction>(U.getUser());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeLine">      });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1158</td>
    <td class="codeLine">      });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1159</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1160</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeLine">    // The ith element of this vector is kernel id i</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1161</td>
    <td class="codeLine">    // The ith element of this vector is kernel id i</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeLine">    std::vector<Function *> OrderedKernels =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1162</td>
    <td class="codeLine">    std::vector<Function *> OrderedKernels =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeLine">        assignLDSKernelIDToEachKernel(&M, KernelsThatAllocateTableLDS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1163</td>
    <td class="codeLine">        assignLDSKernelIDToEachKernel(&M, KernelsThatAllocateTableLDS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeLine">                                      KernelsThatIndirectlyAllocateDynamicLDS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1164</td>
    <td class="codeLine">                                      KernelsThatIndirectlyAllocateDynamicLDS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1165</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeLine">    if (!KernelsThatAllocateTableLDS.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1166</td>
    <td class="codeLine">    if (!KernelsThatAllocateTableLDS.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeLine">      LLVMContext &Ctx = M.getContext();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1167</td>
    <td class="codeLine">      LLVMContext &Ctx = M.getContext();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeLine">      IRBuilder<> Builder(Ctx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1168</td>
    <td class="codeLine">      IRBuilder<> Builder(Ctx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1169</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeLine">      // The order must be consistent between lookup table and accesses to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1170</td>
    <td class="codeLine">      // The order must be consistent between lookup table and accesses to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeLine">      // lookup table</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1171</td>
    <td class="codeLine">      // lookup table</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeLine">      auto TableLookupVariablesOrdered =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1172</td>
    <td class="codeLine">      auto TableLookupVariablesOrdered =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeLine">          sortByName(std::vector<GlobalVariable *>(TableLookupVariables.begin(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1173</td>
    <td class="codeLine">          sortByName(std::vector<GlobalVariable *>(TableLookupVariables.begin(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeLine">                                                   TableLookupVariables.end()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1174</td>
    <td class="codeLine">                                                   TableLookupVariables.end()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1175</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeLine">      GlobalVariable *LookupTable = buildLookupTable(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1176</td>
    <td class="codeLine">      GlobalVariable *LookupTable = buildLookupTable(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeLine">          M, TableLookupVariablesOrdered, OrderedKernels, KernelToReplacement);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1177</td>
    <td class="codeLine">          M, TableLookupVariablesOrdered, OrderedKernels, KernelToReplacement);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeLine">      replaceUsesInInstructionsWithTableLookup(M, TableLookupVariablesOrdered,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1178</td>
    <td class="codeLine">      replaceUsesInInstructionsWithTableLookup(M, TableLookupVariablesOrdered,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeLine">                                               LookupTable);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1179</td>
    <td class="codeLine">                                               LookupTable);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1180</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeLine">    DenseMap<Function *, GlobalVariable *> KernelToCreatedDynamicLDS =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1182</td>
    <td class="codeLine">    DenseMap<Function *, GlobalVariable *> KernelToCreatedDynamicLDS =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeLine">        lowerDynamicLDSVariables(M, LDSUsesInfo,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1183</td>
    <td class="codeLine">        lowerDynamicLDSVariables(M, LDSUsesInfo,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeLine">                                 KernelsThatIndirectlyAllocateDynamicLDS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1184</td>
    <td class="codeLine">                                 KernelsThatIndirectlyAllocateDynamicLDS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeLine">                                 DynamicVariables, OrderedKernels);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1185</td>
    <td class="codeLine">                                 DynamicVariables, OrderedKernels);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1186</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeLine">    // All kernel frames have been allocated. Calculate and record the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1187</td>
    <td class="codeLine">    // All kernel frames have been allocated. Calculate and record the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeLine">    // addresses.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1188</td>
    <td class="codeLine">    // addresses.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeLine">    {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1189</td>
    <td class="codeLine">    {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeLine">      const DataLayout &DL = M.getDataLayout();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1190</td>
    <td class="codeLine">      const DataLayout &DL = M.getDataLayout();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1191</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeLine">      for (Function &Func : M.functions()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1192</td>
    <td class="codeLine">      for (Function &Func : M.functions()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeLine">        if (Func.isDeclaration() || !isKernelLDS(&Func))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1193</td>
    <td class="codeLine">        if (Func.isDeclaration() || !isKernelLDS(&Func))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1194</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1195</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeLine">        // All three of these are optional. The first variable is allocated at</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1196</td>
    <td class="codeLine">        // All three of these are optional. The first variable is allocated at</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeLine">        // zero. They are allocated by AMDGPUMachineFunction as one block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1197</td>
    <td class="codeLine">        // zero. They are allocated by AMDGPUMachineFunction as one block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeLine">        // Layout:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1198</td>
    <td class="codeLine">        // Layout:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeLine">        //{</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1199</td>
    <td class="codeLine">        //{</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeLine">        //  module.lds</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1200</td>
    <td class="codeLine">        //  module.lds</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeLine">        //  alignment padding</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1201</td>
    <td class="codeLine">        //  alignment padding</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeLine">        //  kernel instance</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1202</td>
    <td class="codeLine">        //  kernel instance</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeLine">        //  alignment padding</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1203</td>
    <td class="codeLine">        //  alignment padding</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeLine">        //  dynamic lds variables</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1204</td>
    <td class="codeLine">        //  dynamic lds variables</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeLine">        //}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1205</td>
    <td class="codeLine">        //}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1206</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeLine">        const bool AllocateModuleScopeStruct =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1207</td>
    <td class="codeLine">        const bool AllocateModuleScopeStruct =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeLine">            MaybeModuleScopeStruct &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1208</td>
    <td class="codeLine">            MaybeModuleScopeStruct &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeLine">            KernelsThatAllocateModuleLDS.contains(&Func);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1209</td>
    <td class="codeLine">            KernelsThatAllocateModuleLDS.contains(&Func);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1210</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeLine">        auto Replacement = KernelToReplacement.find(&Func);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1211</td>
    <td class="codeLine">        auto Replacement = KernelToReplacement.find(&Func);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeLine">        const bool AllocateKernelScopeStruct =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1212</td>
    <td class="codeLine">        const bool AllocateKernelScopeStruct =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeLine">            Replacement != KernelToReplacement.end();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1213</td>
    <td class="codeLine">            Replacement != KernelToReplacement.end();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1214</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeLine">        const bool AllocateDynamicVariable =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1215</td>
    <td class="codeLine">        const bool AllocateDynamicVariable =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeLine">            KernelToCreatedDynamicLDS.contains(&Func);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1216</td>
    <td class="codeLine">            KernelToCreatedDynamicLDS.contains(&Func);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1217</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeLine">        uint32_t Offset = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1218</td>
    <td class="codeLine">        uint32_t Offset = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1219</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeLine">        if (AllocateModuleScopeStruct) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1220</td>
    <td class="codeLine">        if (AllocateModuleScopeStruct) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeLine">          // Allocated at zero, recorded once on construction, not once per</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1221</td>
    <td class="codeLine">          // Allocated at zero, recorded once on construction, not once per</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeLine">          // kernel</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1222</td>
    <td class="codeLine">          // kernel</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeLine">          Offset += DL.getTypeAllocSize(MaybeModuleScopeStruct->getValueType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1223</td>
    <td class="codeLine">          Offset += DL.getTypeAllocSize(MaybeModuleScopeStruct->getValueType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1224</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeLine">        if (AllocateKernelScopeStruct) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1226</td>
    <td class="codeLine">        if (AllocateKernelScopeStruct) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeLine">          GlobalVariable *KernelStruct = Replacement->second.SGV;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1227</td>
    <td class="codeLine">          GlobalVariable *KernelStruct = Replacement->second.SGV;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeLine">          Offset = alignTo(Offset, AMDGPU::getAlign(DL, KernelStruct));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1228</td>
    <td class="codeLine">          Offset = alignTo(Offset, AMDGPU::getAlign(DL, KernelStruct));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeLine">          recordLDSAbsoluteAddress(&M, KernelStruct, Offset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1229</td>
    <td class="codeLine">          recordLDSAbsoluteAddress(&M, KernelStruct, Offset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeLine">          Offset += DL.getTypeAllocSize(KernelStruct->getValueType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1230</td>
    <td class="codeLine">          Offset += DL.getTypeAllocSize(KernelStruct->getValueType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1231</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1232</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeLine">        // If there is dynamic allocation, the alignment needed is included in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1233</td>
    <td class="codeLine">        // If there is dynamic allocation, the alignment needed is included in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeLine">        // the static frame size. There may be no reference to the dynamic</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1234</td>
    <td class="codeLine">        // the static frame size. There may be no reference to the dynamic</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeLine">        // variable in the kernel itself, so without including it here, that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1235</td>
    <td class="codeLine">        // variable in the kernel itself, so without including it here, that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeLine">        // alignment padding could be missed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1236</td>
    <td class="codeLine">        // alignment padding could be missed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeLine">        if (AllocateDynamicVariable) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1237</td>
    <td class="codeLine">        if (AllocateDynamicVariable) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeLine">          GlobalVariable *DynamicVariable = KernelToCreatedDynamicLDS[&Func];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1238</td>
    <td class="codeLine">          GlobalVariable *DynamicVariable = KernelToCreatedDynamicLDS[&Func];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeLine">          Offset = alignTo(Offset, AMDGPU::getAlign(DL, DynamicVariable));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1239</td>
    <td class="codeLine">          Offset = alignTo(Offset, AMDGPU::getAlign(DL, DynamicVariable));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeLine">          recordLDSAbsoluteAddress(&M, DynamicVariable, Offset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1240</td>
    <td class="codeLine">          recordLDSAbsoluteAddress(&M, DynamicVariable, Offset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1241</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1242</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeLine">        if (Offset != 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1243</td>
    <td class="codeLine">        if (Offset != 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeLine">          std::string Buffer;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1244</td>
    <td class="codeLine">          std::string Buffer;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeLine">          raw_string_ostream SS{Buffer};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1245</td>
    <td class="codeLine">          raw_string_ostream SS{Buffer};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeLine">          SS << format("%u", Offset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1246</td>
    <td class="codeLine">          SS << format("%u", Offset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1247</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeLine">          // Instead of explictly marking kernels that access dynamic variables</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1248</td>
    <td class="codeLine">          // Instead of explictly marking kernels that access dynamic variables</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeLine">          // using special case metadata, annotate with min-lds == max-lds, i.e.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1249</td>
    <td class="codeLine">          // using special case metadata, annotate with min-lds == max-lds, i.e.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeLine">          // that there is no more space available for allocating more static</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1250</td>
    <td class="codeLine">          // that there is no more space available for allocating more static</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeLine">          // LDS variables. That is the right condition to prevent allocating</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1251</td>
    <td class="codeLine">          // LDS variables. That is the right condition to prevent allocating</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeLine">          // more variables which would collide with the addresses assigned to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1252</td>
    <td class="codeLine">          // more variables which would collide with the addresses assigned to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeLine">          // dynamic variables.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1253</td>
    <td class="codeLine">          // dynamic variables.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeLine">          if (AllocateDynamicVariable)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1254</td>
    <td class="codeLine">          if (AllocateDynamicVariable)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeLine">            SS << format(",%u", Offset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1255</td>
    <td class="codeLine">            SS << format(",%u", Offset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1256</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeLine">          Func.addFnAttr("amdgpu-lds-size", Buffer);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1257</td>
    <td class="codeLine">          Func.addFnAttr("amdgpu-lds-size", Buffer);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1258</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1259</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1260</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1261</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeLine">    for (auto &GV : make_early_inc_range(M.globals()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1262</td>
    <td class="codeLine">    for (auto &GV : make_early_inc_range(M.globals()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeLine">      if (AMDGPU::isLDSVariableToLower(GV)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1263</td>
    <td class="codeLine">      if (AMDGPU::isLDSVariableToLower(GV)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeLine">        // probably want to remove from used lists</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1264</td>
    <td class="codeLine">        // probably want to remove from used lists</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeLine">        GV.removeDeadConstantUsers();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1265</td>
    <td class="codeLine">        GV.removeDeadConstantUsers();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeLine">        if (GV.use_empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1266</td>
    <td class="codeLine">        if (GV.use_empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeLine">          GV.eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1267</td>
    <td class="codeLine">          GV.eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1268</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1269</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeLine">    return Changed;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1270</td>
    <td class="codeLine">    return Changed;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1271</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1272</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1273</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeLine">  // Increase the alignment of LDS globals if necessary to maximise the chance</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1274</td>
    <td class="codeLine">  // Increase the alignment of LDS globals if necessary to maximise the chance</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeLine">  // that we can use aligned LDS instructions to access them.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1275</td>
    <td class="codeLine">  // that we can use aligned LDS instructions to access them.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeLine">  static bool superAlignLDSGlobals(Module &M) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1276</td>
    <td class="codeLine">  static bool superAlignLDSGlobals(Module &M) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeLine">    const DataLayout &DL = M.getDataLayout();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1277</td>
    <td class="codeLine">    const DataLayout &DL = M.getDataLayout();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeLine">    bool Changed = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1278</td>
    <td class="codeLine">    bool Changed = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeLine">    if (!SuperAlignLDSGlobals) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1279</td>
    <td class="codeLine">    if (!SuperAlignLDSGlobals) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeLine">      return Changed;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1280</td>
    <td class="codeLine">      return Changed;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1281</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1282</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeLine">    for (auto &GV : M.globals()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1283</td>
    <td class="codeLine">    for (auto &GV : M.globals()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeLine">      if (GV.getType()->getPointerAddressSpace() != AMDGPUAS::LOCAL_ADDRESS) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1284</td>
    <td class="codeLine">      if (GV.getType()->getPointerAddressSpace() != AMDGPUAS::LOCAL_ADDRESS) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeLine">        // Only changing alignment of LDS variables</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1285</td>
    <td class="codeLine">        // Only changing alignment of LDS variables</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1286</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1287</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeLine">      if (!GV.hasInitializer()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1288</td>
    <td class="codeLine">      if (!GV.hasInitializer()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeLine">        // cuda/hip extern __shared__ variable, leave alignment alone</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1289</td>
    <td class="codeLine">        // cuda/hip extern __shared__ variable, leave alignment alone</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1290</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1291</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1292</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeLine">      Align Alignment = AMDGPU::getAlign(DL, &GV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1293</td>
    <td class="codeLine">      Align Alignment = AMDGPU::getAlign(DL, &GV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeLine">      TypeSize GVSize = DL.getTypeAllocSize(GV.getValueType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1294</td>
    <td class="codeLine">      TypeSize GVSize = DL.getTypeAllocSize(GV.getValueType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1295</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeLine">      if (GVSize > 8) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1296</td>
    <td class="codeLine">      if (GVSize > 8) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeLine">        // We might want to use a b96 or b128 load/store</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1297</td>
    <td class="codeLine">        // We might want to use a b96 or b128 load/store</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeLine">        Alignment = std::max(Alignment, Align(16));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1298</td>
    <td class="codeLine">        Alignment = std::max(Alignment, Align(16));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeLine">      } else if (GVSize > 4) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1299</td>
    <td class="codeLine">      } else if (GVSize > 4) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeLine">        // We might want to use a b64 load/store</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1300</td>
    <td class="codeLine">        // We might want to use a b64 load/store</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeLine">        Alignment = std::max(Alignment, Align(8));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1301</td>
    <td class="codeLine">        Alignment = std::max(Alignment, Align(8));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeLine">      } else if (GVSize > 2) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1302</td>
    <td class="codeLine">      } else if (GVSize > 2) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeLine">        // We might want to use a b32 load/store</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1303</td>
    <td class="codeLine">        // We might want to use a b32 load/store</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeLine">        Alignment = std::max(Alignment, Align(4));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1304</td>
    <td class="codeLine">        Alignment = std::max(Alignment, Align(4));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeLine">      } else if (GVSize > 1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1305</td>
    <td class="codeLine">      } else if (GVSize > 1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeLine">        // We might want to use a b16 load/store</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1306</td>
    <td class="codeLine">        // We might want to use a b16 load/store</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeLine">        Alignment = std::max(Alignment, Align(2));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1307</td>
    <td class="codeLine">        Alignment = std::max(Alignment, Align(2));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1308</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1309</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeLine">      if (Alignment != AMDGPU::getAlign(DL, &GV)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1310</td>
    <td class="codeLine">      if (Alignment != AMDGPU::getAlign(DL, &GV)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeLine">        Changed = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1311</td>
    <td class="codeLine">        Changed = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeLine">        GV.setAlignment(Alignment);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1312</td>
    <td class="codeLine">        GV.setAlignment(Alignment);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1313</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1314</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeLine">    return Changed;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1315</td>
    <td class="codeLine">    return Changed;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1316</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1317</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeLine">  static LDSVariableReplacement createLDSVariableReplacement(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1318</td>
    <td class="codeLine">  static LDSVariableReplacement createLDSVariableReplacement(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeLine">      Module &M, std::string VarName,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1319</td>
    <td class="codeLine">      Module &M, std::string VarName,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeLine">      DenseSet<GlobalVariable *> const &LDSVarsToTransform) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1320</td>
    <td class="codeLine">      DenseSet<GlobalVariable *> const &LDSVarsToTransform) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeLine">    // Create a struct instance containing LDSVarsToTransform and map from those</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1321</td>
    <td class="codeLine">    // Create a struct instance containing LDSVarsToTransform and map from those</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeLine">    // variables to ConstantExprGEP</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1322</td>
    <td class="codeLine">    // variables to ConstantExprGEP</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeLine">    // Variables may be introduced to meet alignment requirements. No aliasing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1323</td>
    <td class="codeLine">    // Variables may be introduced to meet alignment requirements. No aliasing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeLine">    // metadata is useful for these as they have no uses. Erased before return.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1324</td>
    <td class="codeLine">    // metadata is useful for these as they have no uses. Erased before return.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1325</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeLine">    LLVMContext &Ctx = M.getContext();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1326</td>
    <td class="codeLine">    LLVMContext &Ctx = M.getContext();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeLine">    const DataLayout &DL = M.getDataLayout();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1327</td>
    <td class="codeLine">    const DataLayout &DL = M.getDataLayout();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeLine">    assert(!LDSVarsToTransform.empty());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1328</td>
    <td class="codeLine">    assert(!LDSVarsToTransform.empty());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1329</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeLine">    SmallVector<OptimizedStructLayoutField, 8> LayoutFields;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1330</td>
    <td class="codeLine">    SmallVector<OptimizedStructLayoutField, 8> LayoutFields;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeLine">    LayoutFields.reserve(LDSVarsToTransform.size());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1331</td>
    <td class="codeLine">    LayoutFields.reserve(LDSVarsToTransform.size());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeLine">    {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1332</td>
    <td class="codeLine">    {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeLine">      // The order of fields in this struct depends on the order of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1333</td>
    <td class="codeLine">      // The order of fields in this struct depends on the order of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeLine">      // varables in the argument which varies when changing how they</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1334</td>
    <td class="codeLine">      // varables in the argument which varies when changing how they</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeLine">      // are identified, leading to spurious test breakage.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1335</td>
    <td class="codeLine">      // are identified, leading to spurious test breakage.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeLine">      auto Sorted = sortByName(std::vector<GlobalVariable *>(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1336</td>
    <td class="codeLine">      auto Sorted = sortByName(std::vector<GlobalVariable *>(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeLine">          LDSVarsToTransform.begin(), LDSVarsToTransform.end()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1337</td>
    <td class="codeLine">          LDSVarsToTransform.begin(), LDSVarsToTransform.end()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1338</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeLine">      for (GlobalVariable *GV : Sorted) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1339</td>
    <td class="codeLine">      for (GlobalVariable *GV : Sorted) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeLine">        OptimizedStructLayoutField F(GV,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1340</td>
    <td class="codeLine">        OptimizedStructLayoutField F(GV,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeLine">                                     DL.getTypeAllocSize(GV->getValueType()),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1341</td>
    <td class="codeLine">                                     DL.getTypeAllocSize(GV->getValueType()),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeLine">                                     AMDGPU::getAlign(DL, GV));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1342</td>
    <td class="codeLine">                                     AMDGPU::getAlign(DL, GV));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeLine">        LayoutFields.emplace_back(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1343</td>
    <td class="codeLine">        LayoutFields.emplace_back(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1344</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1345</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1346</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeLine">    performOptimizedStructLayout(LayoutFields);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1347</td>
    <td class="codeLine">    performOptimizedStructLayout(LayoutFields);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1348</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeLine">    std::vector<GlobalVariable *> LocalVars;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1349</td>
    <td class="codeLine">    std::vector<GlobalVariable *> LocalVars;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeLine">    BitVector IsPaddingField;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1350</td>
    <td class="codeLine">    BitVector IsPaddingField;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeLine">    LocalVars.reserve(LDSVarsToTransform.size()); // will be at least this large</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1351</td>
    <td class="codeLine">    LocalVars.reserve(LDSVarsToTransform.size()); // will be at least this large</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeLine">    IsPaddingField.reserve(LDSVarsToTransform.size());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1352</td>
    <td class="codeLine">    IsPaddingField.reserve(LDSVarsToTransform.size());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeLine">    {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1353</td>
    <td class="codeLine">    {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeLine">      uint64_t CurrentOffset = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1354</td>
    <td class="codeLine">      uint64_t CurrentOffset = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeLine">      for (size_t I = 0; I < LayoutFields.size(); I++) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1355</td>
    <td class="codeLine">      for (size_t I = 0; I < LayoutFields.size(); I++) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeLine">        GlobalVariable *FGV = static_cast<GlobalVariable *>(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1356</td>
    <td class="codeLine">        GlobalVariable *FGV = static_cast<GlobalVariable *>(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeLine">            const_cast<void *>(LayoutFields[I].Id));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1357</td>
    <td class="codeLine">            const_cast<void *>(LayoutFields[I].Id));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeLine">        Align DataAlign = LayoutFields[I].Alignment;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1358</td>
    <td class="codeLine">        Align DataAlign = LayoutFields[I].Alignment;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1359</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeLine">        uint64_t DataAlignV = DataAlign.value();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1360</td>
    <td class="codeLine">        uint64_t DataAlignV = DataAlign.value();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeLine">        if (uint64_t Rem = CurrentOffset % DataAlignV) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1361</td>
    <td class="codeLine">        if (uint64_t Rem = CurrentOffset % DataAlignV) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeLine">          uint64_t Padding = DataAlignV - Rem;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1362</td>
    <td class="codeLine">          uint64_t Padding = DataAlignV - Rem;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1363</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeLine">          // Append an array of padding bytes to meet alignment requested</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1364</td>
    <td class="codeLine">          // Append an array of padding bytes to meet alignment requested</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeLine">          // Note (o +      (a - (o % a)) ) % a == 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1365</td>
    <td class="codeLine">          // Note (o +      (a - (o % a)) ) % a == 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeLine">          //      (offset + Padding       ) % align == 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1366</td>
    <td class="codeLine">          //      (offset + Padding       ) % align == 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1367</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeLine">          Type *ATy = ArrayType::get(Type::getInt8Ty(Ctx), Padding);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1368</td>
    <td class="codeLine">          Type *ATy = ArrayType::get(Type::getInt8Ty(Ctx), Padding);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeLine">          LocalVars.push_back(new GlobalVariable(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1369</td>
    <td class="codeLine">          LocalVars.push_back(new GlobalVariable(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeLine">              M, ATy, false, GlobalValue::InternalLinkage, UndefValue::get(ATy),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1370</td>
    <td class="codeLine">              M, ATy, false, GlobalValue::InternalLinkage, UndefValue::get(ATy),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeLine">              "", nullptr, GlobalValue::NotThreadLocal, AMDGPUAS::LOCAL_ADDRESS,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1371</td>
    <td class="codeLine">              "", nullptr, GlobalValue::NotThreadLocal, AMDGPUAS::LOCAL_ADDRESS,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeLine">              false));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1372</td>
    <td class="codeLine">              false));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeLine">          IsPaddingField.push_back(true);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1373</td>
    <td class="codeLine">          IsPaddingField.push_back(true);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeLine">          CurrentOffset += Padding;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1374</td>
    <td class="codeLine">          CurrentOffset += Padding;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1375</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1376</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeLine">        LocalVars.push_back(FGV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1377</td>
    <td class="codeLine">        LocalVars.push_back(FGV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeLine">        IsPaddingField.push_back(false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1378</td>
    <td class="codeLine">        IsPaddingField.push_back(false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeLine">        CurrentOffset += LayoutFields[I].Size;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1379</td>
    <td class="codeLine">        CurrentOffset += LayoutFields[I].Size;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1380</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1381</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1382</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeLine">    std::vector<Type *> LocalVarTypes;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1383</td>
    <td class="codeLine">    std::vector<Type *> LocalVarTypes;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeLine">    LocalVarTypes.reserve(LocalVars.size());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1384</td>
    <td class="codeLine">    LocalVarTypes.reserve(LocalVars.size());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeLine">    std::transform(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1385</td>
    <td class="codeLine">    std::transform(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeLine">        LocalVars.cbegin(), LocalVars.cend(), std::back_inserter(LocalVarTypes),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1386</td>
    <td class="codeLine">        LocalVars.cbegin(), LocalVars.cend(), std::back_inserter(LocalVarTypes),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeLine">        [](const GlobalVariable *V) -> Type * { return V->getValueType(); });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1387</td>
    <td class="codeLine">        [](const GlobalVariable *V) -> Type * { return V->getValueType(); });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1388</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeLine">    StructType *LDSTy = StructType::create(Ctx, LocalVarTypes, VarName + ".t");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1389</td>
    <td class="codeLine">    StructType *LDSTy = StructType::create(Ctx, LocalVarTypes, VarName + ".t");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1390</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeLine">    Align StructAlign = AMDGPU::getAlign(DL, LocalVars[0]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1391</td>
    <td class="codeLine">    Align StructAlign = AMDGPU::getAlign(DL, LocalVars[0]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1392</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeLine">    GlobalVariable *SGV = new GlobalVariable(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1393</td>
    <td class="codeLine">    GlobalVariable *SGV = new GlobalVariable(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeLine">        M, LDSTy, false, GlobalValue::InternalLinkage, UndefValue::get(LDSTy),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1394</td>
    <td class="codeLine">        M, LDSTy, false, GlobalValue::InternalLinkage, UndefValue::get(LDSTy),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeLine">        VarName, nullptr, GlobalValue::NotThreadLocal, AMDGPUAS::LOCAL_ADDRESS,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1395</td>
    <td class="codeLine">        VarName, nullptr, GlobalValue::NotThreadLocal, AMDGPUAS::LOCAL_ADDRESS,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeLine">        false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1396</td>
    <td class="codeLine">        false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeLine">    SGV->setAlignment(StructAlign);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1397</td>
    <td class="codeLine">    SGV->setAlignment(StructAlign);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1398</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeLine">    DenseMap<GlobalVariable *, Constant *> Map;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1399</td>
    <td class="codeLine">    DenseMap<GlobalVariable *, Constant *> Map;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeLine">    Type *I32 = Type::getInt32Ty(Ctx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1400</td>
    <td class="codeLine">    Type *I32 = Type::getInt32Ty(Ctx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeLine">    for (size_t I = 0; I < LocalVars.size(); I++) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1401</td>
    <td class="codeLine">    for (size_t I = 0; I < LocalVars.size(); I++) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeLine">      GlobalVariable *GV = LocalVars[I];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1402</td>
    <td class="codeLine">      GlobalVariable *GV = LocalVars[I];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeLine">      Constant *GEPIdx[] = {ConstantInt::get(I32, 0), ConstantInt::get(I32, I)};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1403</td>
    <td class="codeLine">      Constant *GEPIdx[] = {ConstantInt::get(I32, 0), ConstantInt::get(I32, I)};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeLine">      Constant *GEP = ConstantExpr::getGetElementPtr(LDSTy, SGV, GEPIdx, true);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1404</td>
    <td class="codeLine">      Constant *GEP = ConstantExpr::getGetElementPtr(LDSTy, SGV, GEPIdx, true);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeLine">      if (IsPaddingField[I]) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1405</td>
    <td class="codeLine">      if (IsPaddingField[I]) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeLine">        assert(GV->use_empty());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1406</td>
    <td class="codeLine">        assert(GV->use_empty());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeLine">        GV->eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1407</td>
    <td class="codeLine">        GV->eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1408</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeLine">        Map[GV] = GEP;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1409</td>
    <td class="codeLine">        Map[GV] = GEP;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1410</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1411</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeLine">    assert(Map.size() == LDSVarsToTransform.size());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1412</td>
    <td class="codeLine">    assert(Map.size() == LDSVarsToTransform.size());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeLine">    return {SGV, std::move(Map)};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1413</td>
    <td class="codeLine">    return {SGV, std::move(Map)};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1414</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1415</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeLine">  template <typename PredicateTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1416</td>
    <td class="codeLine">  template <typename PredicateTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeLine">  static void replaceLDSVariablesWithStruct(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1417</td>
    <td class="codeLine">  static void replaceLDSVariablesWithStruct(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeLine">      Module &M, DenseSet<GlobalVariable *> const &LDSVarsToTransformArg,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1418</td>
    <td class="codeLine">      Module &M, DenseSet<GlobalVariable *> const &LDSVarsToTransformArg,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeLine">      const LDSVariableReplacement &Replacement, PredicateTy Predicate) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1419</td>
    <td class="codeLine">      const LDSVariableReplacement &Replacement, PredicateTy Predicate) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeLine">    LLVMContext &Ctx = M.getContext();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1420</td>
    <td class="codeLine">    LLVMContext &Ctx = M.getContext();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeLine">    const DataLayout &DL = M.getDataLayout();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1421</td>
    <td class="codeLine">    const DataLayout &DL = M.getDataLayout();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1422</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeLine">    // A hack... we need to insert the aliasing info in a predictable order for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1423</td>
    <td class="codeLine">    // A hack... we need to insert the aliasing info in a predictable order for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeLine">    // lit tests. Would like to have them in a stable order already, ideally the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1424</td>
    <td class="codeLine">    // lit tests. Would like to have them in a stable order already, ideally the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeLine">    // same order they get allocated, which might mean an ordered set container</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1425</td>
    <td class="codeLine">    // same order they get allocated, which might mean an ordered set container</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeLine">    auto LDSVarsToTransform = sortByName(std::vector<GlobalVariable *>(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1426</td>
    <td class="codeLine">    auto LDSVarsToTransform = sortByName(std::vector<GlobalVariable *>(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeLine">        LDSVarsToTransformArg.begin(), LDSVarsToTransformArg.end()));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1427</td>
    <td class="codeLine">        LDSVarsToTransformArg.begin(), LDSVarsToTransformArg.end()));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1428</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeLine">    // Create alias.scope and their lists. Each field in the new structure</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1429</td>
    <td class="codeLine">    // Create alias.scope and their lists. Each field in the new structure</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeLine">    // does not alias with all other fields.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1430</td>
    <td class="codeLine">    // does not alias with all other fields.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeLine">    SmallVector<MDNode *> AliasScopes;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1431</td>
    <td class="codeLine">    SmallVector<MDNode *> AliasScopes;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeLine">    SmallVector<Metadata *> NoAliasList;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1432</td>
    <td class="codeLine">    SmallVector<Metadata *> NoAliasList;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeLine">    const size_t NumberVars = LDSVarsToTransform.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1433</td>
    <td class="codeLine">    const size_t NumberVars = LDSVarsToTransform.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeLine">    if (NumberVars > 1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1434</td>
    <td class="codeLine">    if (NumberVars > 1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeLine">      MDBuilder MDB(Ctx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1435</td>
    <td class="codeLine">      MDBuilder MDB(Ctx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeLine">      AliasScopes.reserve(NumberVars);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1436</td>
    <td class="codeLine">      AliasScopes.reserve(NumberVars);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeLine">      MDNode *Domain = MDB.createAnonymousAliasScopeDomain();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1437</td>
    <td class="codeLine">      MDNode *Domain = MDB.createAnonymousAliasScopeDomain();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeLine">      for (size_t I = 0; I < NumberVars; I++) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1438</td>
    <td class="codeLine">      for (size_t I = 0; I < NumberVars; I++) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeLine">        MDNode *Scope = MDB.createAnonymousAliasScope(Domain);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1439</td>
    <td class="codeLine">        MDNode *Scope = MDB.createAnonymousAliasScope(Domain);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeLine">        AliasScopes.push_back(Scope);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1440</td>
    <td class="codeLine">        AliasScopes.push_back(Scope);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1441</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeLine">      NoAliasList.append(&AliasScopes[1], AliasScopes.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1442</td>
    <td class="codeLine">      NoAliasList.append(&AliasScopes[1], AliasScopes.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1443</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1444</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeLine">    // Replace uses of ith variable with a constantexpr to the corresponding</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1445</td>
    <td class="codeLine">    // Replace uses of ith variable with a constantexpr to the corresponding</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeLine">    // field of the instance that will be allocated by AMDGPUMachineFunction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1446</td>
    <td class="codeLine">    // field of the instance that will be allocated by AMDGPUMachineFunction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeLine">    for (size_t I = 0; I < NumberVars; I++) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1447</td>
    <td class="codeLine">    for (size_t I = 0; I < NumberVars; I++) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeLine">      GlobalVariable *GV = LDSVarsToTransform[I];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1448</td>
    <td class="codeLine">      GlobalVariable *GV = LDSVarsToTransform[I];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeLine">      Constant *GEP = Replacement.LDSVarsToConstantGEP.at(GV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1449</td>
    <td class="codeLine">      Constant *GEP = Replacement.LDSVarsToConstantGEP.at(GV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1450</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeLine">      GV->replaceUsesWithIf(GEP, Predicate);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1451</td>
    <td class="codeLine">      GV->replaceUsesWithIf(GEP, Predicate);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1452</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeLine">      APInt APOff(DL.getIndexTypeSizeInBits(GEP->getType()), 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1453</td>
    <td class="codeLine">      APInt APOff(DL.getIndexTypeSizeInBits(GEP->getType()), 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeLine">      GEP->stripAndAccumulateInBoundsConstantOffsets(DL, APOff);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1454</td>
    <td class="codeLine">      GEP->stripAndAccumulateInBoundsConstantOffsets(DL, APOff);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeLine">      uint64_t Offset = APOff.getZExtValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1455</td>
    <td class="codeLine">      uint64_t Offset = APOff.getZExtValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1456</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeLine">      Align A =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1457</td>
    <td class="codeLine">      Align A =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeLine">          commonAlignment(Replacement.SGV->getAlign().valueOrOne(), Offset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1458</td>
    <td class="codeLine">          commonAlignment(Replacement.SGV->getAlign().valueOrOne(), Offset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1459</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeLine">      if (I)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1460</td>
    <td class="codeLine">      if (I)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeLine">        NoAliasList[I - 1] = AliasScopes[I - 1];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1461</td>
    <td class="codeLine">        NoAliasList[I - 1] = AliasScopes[I - 1];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeLine">      MDNode *NoAlias =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1462</td>
    <td class="codeLine">      MDNode *NoAlias =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeLine">          NoAliasList.empty() ? nullptr : MDNode::get(Ctx, NoAliasList);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1463</td>
    <td class="codeLine">          NoAliasList.empty() ? nullptr : MDNode::get(Ctx, NoAliasList);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeLine">      MDNode *AliasScope =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1464</td>
    <td class="codeLine">      MDNode *AliasScope =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeLine">          AliasScopes.empty() ? nullptr : MDNode::get(Ctx, {AliasScopes[I]});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1465</td>
    <td class="codeLine">          AliasScopes.empty() ? nullptr : MDNode::get(Ctx, {AliasScopes[I]});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1466</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeLine">      refineUsesAlignmentAndAA(GEP, A, DL, AliasScope, NoAlias);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1467</td>
    <td class="codeLine">      refineUsesAlignmentAndAA(GEP, A, DL, AliasScope, NoAlias);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1468</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1469</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1470</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeLine">  static void refineUsesAlignmentAndAA(Value *Ptr, Align A,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1471</td>
    <td class="codeLine">  static void refineUsesAlignmentAndAA(Value *Ptr, Align A,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeLine">                                       const DataLayout &DL, MDNode *AliasScope,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1472</td>
    <td class="codeLine">                                       const DataLayout &DL, MDNode *AliasScope,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeLine">                                       MDNode *NoAlias, unsigned MaxDepth = 5) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1473</td>
    <td class="codeLine">                                       MDNode *NoAlias, unsigned MaxDepth = 5) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeLine">    if (!MaxDepth || (A == 1 && !AliasScope))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1474</td>
    <td class="codeLine">    if (!MaxDepth || (A == 1 && !AliasScope))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1475</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1476</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeLine">    for (User *U : Ptr->users()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1477</td>
    <td class="codeLine">    for (User *U : Ptr->users()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeLine">      if (auto *I = dyn_cast<Instruction>(U)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1478</td>
    <td class="codeLine">      if (auto *I = dyn_cast<Instruction>(U)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeLine">        if (AliasScope && I->mayReadOrWriteMemory()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1479</td>
    <td class="codeLine">        if (AliasScope && I->mayReadOrWriteMemory()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeLine">          MDNode *AS = I->getMetadata(LLVMContext::MD_alias_scope);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1480</td>
    <td class="codeLine">          MDNode *AS = I->getMetadata(LLVMContext::MD_alias_scope);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeLine">          AS = (AS ? MDNode::getMostGenericAliasScope(AS, AliasScope)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1481</td>
    <td class="codeLine">          AS = (AS ? MDNode::getMostGenericAliasScope(AS, AliasScope)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeLine">                   : AliasScope);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1482</td>
    <td class="codeLine">                   : AliasScope);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeLine">          I->setMetadata(LLVMContext::MD_alias_scope, AS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1483</td>
    <td class="codeLine">          I->setMetadata(LLVMContext::MD_alias_scope, AS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1484</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeLine">          MDNode *NA = I->getMetadata(LLVMContext::MD_noalias);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1485</td>
    <td class="codeLine">          MDNode *NA = I->getMetadata(LLVMContext::MD_noalias);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeLine">          NA = (NA ? MDNode::intersect(NA, NoAlias) : NoAlias);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1486</td>
    <td class="codeLine">          NA = (NA ? MDNode::intersect(NA, NoAlias) : NoAlias);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeLine">          I->setMetadata(LLVMContext::MD_noalias, NA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1487</td>
    <td class="codeLine">          I->setMetadata(LLVMContext::MD_noalias, NA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1488</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1489</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1490</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeLine">      if (auto *LI = dyn_cast<LoadInst>(U)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1491</td>
    <td class="codeLine">      if (auto *LI = dyn_cast<LoadInst>(U)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeLine">        LI->setAlignment(std::max(A, LI->getAlign()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1492</td>
    <td class="codeLine">        LI->setAlignment(std::max(A, LI->getAlign()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1493</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1494</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeLine">      if (auto *SI = dyn_cast<StoreInst>(U)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1495</td>
    <td class="codeLine">      if (auto *SI = dyn_cast<StoreInst>(U)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeLine">        if (SI->getPointerOperand() == Ptr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1496</td>
    <td class="codeLine">        if (SI->getPointerOperand() == Ptr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeLine">          SI->setAlignment(std::max(A, SI->getAlign()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1497</td>
    <td class="codeLine">          SI->setAlignment(std::max(A, SI->getAlign()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1498</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1499</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeLine">      if (auto *AI = dyn_cast<AtomicRMWInst>(U)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1500</td>
    <td class="codeLine">      if (auto *AI = dyn_cast<AtomicRMWInst>(U)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeLine">        // None of atomicrmw operations can work on pointers, but let's</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1501</td>
    <td class="codeLine">        // None of atomicrmw operations can work on pointers, but let's</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeLine">        // check it anyway in case it will or we will process ConstantExpr.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1502</td>
    <td class="codeLine">        // check it anyway in case it will or we will process ConstantExpr.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeLine">        if (AI->getPointerOperand() == Ptr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1503</td>
    <td class="codeLine">        if (AI->getPointerOperand() == Ptr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeLine">          AI->setAlignment(std::max(A, AI->getAlign()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1504</td>
    <td class="codeLine">          AI->setAlignment(std::max(A, AI->getAlign()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1505</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1506</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeLine">      if (auto *AI = dyn_cast<AtomicCmpXchgInst>(U)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1507</td>
    <td class="codeLine">      if (auto *AI = dyn_cast<AtomicCmpXchgInst>(U)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeLine">        if (AI->getPointerOperand() == Ptr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1508</td>
    <td class="codeLine">        if (AI->getPointerOperand() == Ptr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeLine">          AI->setAlignment(std::max(A, AI->getAlign()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1509</td>
    <td class="codeLine">          AI->setAlignment(std::max(A, AI->getAlign()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1510</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1511</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeLine">      if (auto *GEP = dyn_cast<GetElementPtrInst>(U)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1512</td>
    <td class="codeLine">      if (auto *GEP = dyn_cast<GetElementPtrInst>(U)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeLine">        unsigned BitWidth = DL.getIndexTypeSizeInBits(GEP->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1513</td>
    <td class="codeLine">        unsigned BitWidth = DL.getIndexTypeSizeInBits(GEP->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeLine">        APInt Off(BitWidth, 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1514</td>
    <td class="codeLine">        APInt Off(BitWidth, 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeLine">        if (GEP->getPointerOperand() == Ptr) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1515</td>
    <td class="codeLine">        if (GEP->getPointerOperand() == Ptr) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeLine">          Align GA;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1516</td>
    <td class="codeLine">          Align GA;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeLine">          if (GEP->accumulateConstantOffset(DL, Off))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1517</td>
    <td class="codeLine">          if (GEP->accumulateConstantOffset(DL, Off))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeLine">            GA = commonAlignment(A, Off.getLimitedValue());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1518</td>
    <td class="codeLine">            GA = commonAlignment(A, Off.getLimitedValue());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeLine">          refineUsesAlignmentAndAA(GEP, GA, DL, AliasScope, NoAlias,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1519</td>
    <td class="codeLine">          refineUsesAlignmentAndAA(GEP, GA, DL, AliasScope, NoAlias,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeLine">                                   MaxDepth - 1);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1520</td>
    <td class="codeLine">                                   MaxDepth - 1);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1521</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1522</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1523</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeLine">      if (auto *I = dyn_cast<Instruction>(U)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1524</td>
    <td class="codeLine">      if (auto *I = dyn_cast<Instruction>(U)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeLine">        if (I->getOpcode() == Instruction::BitCast ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1525</td>
    <td class="codeLine">        if (I->getOpcode() == Instruction::BitCast ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeLine">            I->getOpcode() == Instruction::AddrSpaceCast)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1526</td>
    <td class="codeLine">            I->getOpcode() == Instruction::AddrSpaceCast)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeLine">          refineUsesAlignmentAndAA(I, A, DL, AliasScope, NoAlias, MaxDepth - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1527</td>
    <td class="codeLine">          refineUsesAlignmentAndAA(I, A, DL, AliasScope, NoAlias, MaxDepth - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1528</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1529</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1530</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1531</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1532</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeLine">} // namespace</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1533</td>
    <td class="codeLine">} // namespace</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeLine">char AMDGPULowerModuleLDS::ID = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1534</td>
    <td class="codeLine">char AMDGPULowerModuleLDS::ID = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1535</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeLine">char &llvm::AMDGPULowerModuleLDSID = AMDGPULowerModuleLDS::ID;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1536</td>
    <td class="codeLine">char &llvm::AMDGPULowerModuleLDSID = AMDGPULowerModuleLDS::ID;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1537</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS(AMDGPULowerModuleLDS, DEBUG_TYPE,</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">1538</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS(AMDGPULowerModuleLDS, DEBUG_TYPE,</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeLine">                "Lower uses of LDS variables from non-kernel functions", false,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1539</td>
    <td class="codeLine">                "Lower uses of LDS variables from non-kernel functions", false,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeLine">                false)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1540</td>
    <td class="codeLine">                false)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1541</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeLine">ModulePass *llvm::createAMDGPULowerModuleLDSPass() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1542</td>
    <td class="codeLine">ModulePass *llvm::createAMDGPULowerModuleLDSPass() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeLine">  return new AMDGPULowerModuleLDS();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1543</td>
    <td class="codeLine">  return new AMDGPULowerModuleLDS();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1544</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1545</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeLine">PreservedAnalyses AMDGPULowerModuleLDSPass::run(Module &M,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1546</td>
    <td class="codeLine">PreservedAnalyses AMDGPULowerModuleLDSPass::run(Module &M,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeLine">                                                ModuleAnalysisManager &) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1547</td>
    <td class="codeLine">                                                ModuleAnalysisManager &) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeLine">  return AMDGPULowerModuleLDS().runOnModule(M) ? PreservedAnalyses::none()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1548</td>
    <td class="codeLine">  return AMDGPULowerModuleLDS().runOnModule(M) ? PreservedAnalyses::none()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeLine">                                               : PreservedAnalyses::all();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1549</td>
    <td class="codeLine">                                               : PreservedAnalyses::all();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1550</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1551</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
</table>
    </div>
    <button id="myBtn" onclick="topFunction()" title="Go to top" type="button">Top</button>
    <script src="../Javascript/drop_down.js"></script>
    <script src="../Javascript/top_button.js"></script>
  </body>
</html>